This is simplification.info, produced by makeinfo version 4.8 from
simplification.texi.


File: simplification.info,  Node: Top,  Next: Introduction to simplification,  Prev: (dir),  Up: (dir)

simplification
**************

* Menu:

* Introduction to simplification::
* Definitions for simplification::
* Function and variable index::


File: simplification.info,  Node: Introduction to simplification,  Next: Definitions for simplification,  Prev: Top,  Up: Top

Introduction to simplification
==============================

The directory `maxima/share/simplification' contains several scripts
which implement simplification rules and functions, and also some
functions not related to simplification.


File: simplification.info,  Node: Definitions for simplification,  Next: Function and variable index,  Prev: Introduction to simplification,  Up: Top

Definitions for simplification
==============================

 -- Add on package: absimp
     The `absimp' package contains pattern-matching rules that extend
     the built-in simplification rules for the `abs' and `signum'
     functions.  `absimp' respects relations established with the
     built-in `assume' function and by declarations such as
     `modedeclare (m, even, n, odd)'  for even or odd integers.

     `absimp' defines `unitramp' and `unitstep' functions in terms of
     `abs' and `signum'.

     `load (absimp)' loads this package.  `demo (absimp)' shows a
     demonstration of this package.

     Examples:

          (%i1) load (absimp);
          (%o1) /usr/share/maxima/5.9.2/share/simplification/absimp.mac
          (%i2) (abs (x))^2;
                                          2
          (%o2)                          x
          (%i3) diff (abs (x), x);
                                         x
          (%o3)                        ------
                                       abs(x)
          (%i4) cosh (abs (x));
          (%o4)                        cosh(x)

 -- Add on package: facexp
     The `facexp' package contains several related  functions that
     provide the user with the ability to structure expressions by
     controlled expansion.   This capability  is especially  useful
     when  the expression contains variables that have physical
     meaning, because it is  often true that the most economical form
     of such an expression can be  obtained by fully expanding the
     expression with respect to those variables, and then factoring
     their coefficients.  While it is  true that this  procedure is not
     difficult to carry out using standard Maxima  functions, additional
     fine-tuning may also  be desirable, and  these finishing touches
     can be more  difficult to  apply.

     The  function `facsum'  and its  related forms provide a
     convenient means for controlling the structure  of expressions in
     this way.  Another function, `collectterms', can be used to add
     two or more expressions that have already been simplified to this
     form, without resimplifying the whole expression again.  This
     function may be useful when the expressions are very large.

     `load (facexp)' loads this package.  `demo (facexp)' shows a
     demonstration of this package.

 -- Function: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Returns  a form  of <expr>  which depends  on the arguments
     <arg_1>, ..., <arg_n>.  The arguments can be any form suitable for
     `ratvars', or they can be lists  of such  forms.  If  the
     arguments  are not  lists, then  the form returned is  fully
     expanded with respect  to the arguments,  and the coefficients of
     the arguments are factored.  These  coefficients are free of the
     arguments, except perhaps in a non-rational sense.

     If any of the arguments are  lists, then all such lists are
     combined into  a  single  list,   and  instead  of  calling
     `factor'   on  the coefficients  of  the  arguments,  `facsum'
     calls  itself   on  these coefficients, using  this newly
     constructed  single list as  the new argument list  for this
     recursive  call.  This  process can  be  repeated to arbitrary
     depth by nesting the desired elements in lists.

     It is possible that one may wish to `facsum' with respect  to more
     complicated subexpressions,  such as  `log (x + y)'.  Such
     arguments are also  permissible.   With  no  variable
     specification,  for example `facsum (<expr>)', the  result
     returned  is the same  as that  returned by `ratsimp (<expr>)'.

     Occasionally the user may wish to obtain any of the  above forms
     for expressions which are specified only by their leading
     operators.  For example, one may wish  to `facsum' with respect to
     all  `log''s.  In this situation, one may  include among the
     arguments either  the specific `log''s which are to be treated in
     this way, or  alternatively, either the expression  `operator
     (log)' or `'operator (log)'.   If one  wished to `facsum' the
     expression <expr> with respect to the operators <op_1>, ...,
     <op_n>, one   would  evaluate  `facsum (<expr>, operator (<op_1>,
     ..., <op_n>))'.  The `operator' form may also appear inside list
     arguments.

     In  addition,  the  setting  of  the  switches   `facsum_combine'
     and `nextlayerfactor' may affect the result of `facsum'.

 -- Global variable: nextlayerfactor
     Default value: `false'

     When `nextlayerfactor' is `true', recursive calls  of `facsum' are
     applied  to  the  factors  of  the  factored  form   of  the
     coefficients of the arguments.

     When  `false', `facsum' is applied to each coefficient as a whole
     whenever recusive calls to  `facsum' occur.

     Inclusion   of   the  atom `nextlayerfactor' in  the argument
     list of `facsum'  has the  effect of `nextlayerfactor: true', but
     for the next level of the expression only.  Since
     `nextlayerfactor' is  always bound to  either `true' or  `false',
     it must be presented single-quoted whenever it appears in the
     argument list of `facsum'.

 -- Global variable: facsum_combine
     Default value: `true'

     `facsum_combine' controls the form  of the final result  returned
     by `facsum'  when  its  argument  is  a  quotient  of
     polynomials.   If `facsum_combine' is `false'  then the form will
     be returned as  a fully expanded  sum  as described  above,  but
     if  `true',  then  the expression returned is a ratio of
     polynomials, with each polynomial in the form described above.

     The `true' setting of this switch is useful when one wants to
     `facsum' both  the numerator and  denominator of  a rational
     expression,  but  does not  want  the denominator  to  be
     multiplied through the terms of the numerator.

 -- Function: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Returns a  form of <expr>  which is obtained by calling  `facsum'
     on the factors  of <expr> with <arg_1>, ... <arg_n> as arguments.
     If any of the factors of <expr> is raised to a  power, both the
     factor and the exponent will be processed in this way.

 -- Function: collectterms (<arg_1>, ..., <arg_n>)
     If several  expressions  have been simplified  with  `facsum',
     `factorfacsum',  `factenexpand',  `facexpten' or
     `factorfacexpten',  and  they are  to  be added  together,  it
     may be desirable   to  combine   them  using   the   function
     `collecterms'.  `collecterms' can take as arguments  all of the
     arguments that  can be given  to these  other associated
     functions with  the  exception of `nextlayerfactor', which has no
     effect on `collectterms'.  The advantage of `collectterms'  is
     that it  returns a form  similar to  `facsum', but since it is
     adding forms that have already been processed by `facsum', it
     does  not  need  to  repeat  that  effort.   This  capability is
     especially useful when the expressions to be summed are very large.

 -- Function: rempart (<expr>, <n>)
     Removes part <n> from the expression <expr>.

     If <n> is a list of the form `[<l>, <m>]' then parts <l> thru <m>
     are removed.

 -- Function: wronskian ([<f_1>, ..., <f_n>], <x>)
     Returns the Wronskian matrix of the functions <f_1>, ..., <f_n> in
     the variable <x>.

     <f_1>, ..., <f_n> may be the names of user-defined functions, or
     expressions in the variable <x>.

     The determinant of the Wronskian matrix is the Wronskian
     determinant of the set of functions.  The functions are linearly
     dependent if this determinant is zero.

 -- Function: tracematrix (<M>)
     Returns the trace (sum of the diagonal elements) of matrix <M>.

 -- Function: rational (z)
     Multiplies numerator and denominator of <z> by the complex
     conjugate of denominator, thus rationalizing the denominator.
     Returns canonical rational expression (CRE) form if given one,
     else returns general form.

 -- Function: logand (x,y)
     Returns logical (bit-wise) "and" of arguments x and y.

 -- Function: logor (x,y)
     Returns logical (bit-wise) "or" of arguments x and y.

 -- Function: logxor (x,y)
     Returns logical (bit-wise) exclusive-or of arguments x and y.

 -- Function: nonzeroandfreeof (<x>, <expr>)
     Returns `true' if <expr> is nonzero and `freeof (<x>, <expr>)'
     returns `true'.  Returns `false' otherwise.

 -- Function: linear (<expr>, <x>)
     When <expr> is an expression linear in variable <x>, `linear'
     returns `<a>*<x> + <b>' where <a> is nonzero, and <a> and <b> are
     free of <x>.  Otherwise, `linear' returns <expr>.

 -- Function: quadratic (<expr>, <x>)
     When <expr> is an expression quadratic in variable <x>,
     `quadratic' returns `<a>*<x>^2 + <b>*x + <c>' where <a> is nonzero,
     and <a>, <b>, and <c> are free of <x>.  Otherwise, `quadratic'
     returns <expr>.

 -- Function: gcdivide (<p>, <q>)
     When `takegcd' is `true', `gcdivide' divides the polynomials <p>
     and <q> by their greatest common divisor and returns the ratio of
     the results.

     When `takegcd' is `false', `gcdivide' returns the ratio `<p>/<q>'.

 -- Function: arithmetic (<a>, <d>, <n>)
     Returns the <n>-th term of the arithmetic series `<a>, <a> + <d>,
     <a> + 2*<d>, ..., <a> + (<n> - 1)*<d>'.

 -- Function: geometric (<a>, <r>, <n>)
     Returns the <n>-th term of the geometric series `<a>, <a>*<r>,
     <a>*<r>^2, ..., <a>*<r>^(<n> - 1)'.

 -- Function: harmonic (<a>, <b>, <c>, <n>)
     Returns the <n>-th term of the harmonic series `<a>/<b>, <a>/(<b>
     + <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> - 1)*<c>)'.

 -- Function: arithsum (<a>, <d>, <n>)
     Returns the sum of the arithmetic series from 1 to <n>.

 -- Function: geosum (<a>, <r>, <n>)
     Returns the sum of the geometric series from 1 to <n>.  If <n> is
     infinity (`inf') then a sum is finite only if the value of <r> is
     not equal to 1.

 -- Function: gaussprob (<x>)
     Returns the Gaussian probability function `%e^(-<x>^2/2) /
     sqrt(2*%pi)'.

 -- Function: gd (<x>)
     Returns the Gudermannian function `2 * atan(%e^<x> - %pi/2)'.

 -- Function: agd (<x>)
     Returns the inverse Gudermannian function `log (tan (%pi/4 +
     x/2)))'.

 -- Function: vers (<x>)
     Returns the versed sine `1 - cos (x)'.

 -- Function: covers (<x>)
     Returns the coversed sine `1 - sin (<x>)'.

 -- Function: exsec (<x>)
     Returns the exsecant `sec (<x>) - 1'.

 -- Function: hav (<x>)
     Returns the haversine `(1 - cos(x))/2'.

 -- Function: combination (<n>, <r>)
     Returns the number of combinations of <n> objects taken <r> at a
     time.

 -- Function: permutation (<n>, <r>)
     Returns the number of permutations of <r> objects selected from a
     set of <n> objects.

 -- Add on package: ineq
     The `ineq' package contains simplification rules for inequalities.

     Be careful about using parentheses around the inequalities: when
     the user types in `(A > B) + (C = 5)' the result is `A + C > B +
     5', but `A > B + C = 5' is a syntax error, and `(A > B + C) = 5'
     is something else entirely.

     Do `disprule (all)' to see a complete listing of the rule
     definitions.

     The user will be queried if Maxima is unable to decide the sign of
     a quantity multiplying an inequality.

     The most common mis-feature is illustrated by:

          eq: a > b;
          2*eq;
          % - eq;

     Another problem is 0 times an inequality; the default to have this
     turn into 0 has been left alone. However, if you type
     `X*<some_inequality>' and Maxima asks about the sign of `X' and you
     respond `zero' (or `z'), the program returns `X*<some_inequality>'
     and not use the information that `X' is 0. You should do `ev (%,
     x: 0)' in such a case, as the database will only be used for
     comparison purposes in decisions, and not for the purpose of
     evaluating `X'.

     The user may note a slower response when this package is loaded, as
     the simplifier is forced to examine more rules than without the
     package, so you might wish to remove the rules after making use of
     them. Do `kill (rules)' to eliminate all of the rules (including
     any that you might have defined); or you may be more selective by
     killing only some of them; or use `remrule' on a specific rule.

     Note that if you load this package after defining your own rules
     you will clobber your rules that have the same name. The rules in
     this package are: `*rule1', ..., `*rule8', `+rule1', ...,
     `+rule18', and you must enclose the rulename in quotes to refer to
     it, as in `remrule ("+", "+rule1")' to specifically remove the
     first rule on `"+"' or `disprule ("*rule2")' to display the
     definition of the second multiplicative rule.

 -- Function: reduce_consts (<expr>)
     Replaces constant subexpressions of <expr> with constructed
     constant atoms, saving the definition of all these constructed
     constants in the list of equations `const_eqns', and returning the
     modified <expr>.  Those parts of <expr> are constant which return
     `true' when operated on by the function `constantp'.  Hence,
     before invoking `reduce_consts', one should do

          declare ([<objects to be given the constant property>], constant)$

     to set up a database of the constant quantities occurring in your
     expressions.

     If you are planning to generate Fortran output after these symbolic
     calculations, one of the first code sections should be the
     calculation of all constants.  To generate this code segment, do

          map ('fortran, const_eqns)$

     Variables besides `const_eqns' which affect `reduce_consts' are:

     `const_prefix' (default value: `xx') is the string of characters
     used to prefix all symbols generated by `reduce_consts' to
     represent constant subexpressions.

     `const_counter' (default value: 1) is the integer index used to
     generate unique symbols to represent each constant subexpression
     found by `reduce_consts'.

     `load (rducon)' loads this function.  `demo (rducon)' shows a
     demonstration of this function.

 -- Function: gcfac (<expr>)
     `gcfac' is a factoring function that attempts to apply the same
     heuristics which scientists apply in trying to make expressions
     simpler.  `gcfac' is limited to monomial-type factoring.  For a
     sum, `gcfac' does the following:

       1. Factors over the integers.

       2. Factors out the largest powers of terms occurring as
          coefficients, regardless of the complexity of the terms.

       3. Uses (1) and (2) in factoring adjacent pairs of terms.

       4. Repeatedly and recursively applies these techniques until the
          expression no longer changes.

     Item (3) does not necessarily do an optimal job of pairwise
     factoring because of the combinatorially-difficult nature of
     finding which of all possible rearrangements of the pairs yields
     the most compact pair-factored result.

     `load (scifac)' loads this function.  `demo (scifac)' shows a
     demonstration of this function.

 -- Function: sqrtdenest (<expr>)
     Denests `sqrt' of simple, numerical, binomial surds, where
     possible.  E.g.

          (c1) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);

                        sqrt(3)
                   sqrt(------- + 1)
                           2
          (d1)   ---------------------
                 sqrt(11 sqrt(2) - 12)

          (c2) sqrtdenest(%);

                    sqrt(3)   1
                    ------- + -
                       2      2
          (d2)     -------------
                      1/4    3/4
                   3 2    - 2

     Sometimes it helps to apply `sqrtdenest' more than once, on such as
     `(19601-13860 sqrt(2))^(7/4)'.

     `load (sqdnst)' loads this function.


File: simplification.info,  Node: Function and variable index,  Prev: Definitions for simplification,  Up: Top

Appendix A Function and variable index
**************************************

 [index ]
* Menu:

* agd:                                   Definitions for simplification.
                                                              (line 231)
* arithmetic:                            Definitions for simplification.
                                                              (line 204)
* arithsum:                              Definitions for simplification.
                                                              (line 216)
* collectterms:                          Definitions for simplification.
                                                              (line 133)
* combination:                           Definitions for simplification.
                                                              (line 247)
* covers:                                Definitions for simplification.
                                                              (line 238)
* exsec:                                 Definitions for simplification.
                                                              (line 241)
* facsum:                                Definitions for simplification.
                                                              (line  57)
* factorfacsum:                          Definitions for simplification.
                                                              (line 127)
* gaussprob:                             Definitions for simplification.
                                                              (line 224)
* gcdivide:                              Definitions for simplification.
                                                              (line 197)
* gcfac:                                 Definitions for simplification.
                                                              (line 331)
* gd:                                    Definitions for simplification.
                                                              (line 228)
* geometric:                             Definitions for simplification.
                                                              (line 208)
* geosum:                                Definitions for simplification.
                                                              (line 219)
* harmonic:                              Definitions for simplification.
                                                              (line 212)
* hav:                                   Definitions for simplification.
                                                              (line 244)
* linear:                                Definitions for simplification.
                                                              (line 186)
* logand:                                Definitions for simplification.
                                                              (line 173)
* logor:                                 Definitions for simplification.
                                                              (line 176)
* logxor:                                Definitions for simplification.
                                                              (line 179)
* nonzeroandfreeof:                      Definitions for simplification.
                                                              (line 182)
* permutation:                           Definitions for simplification.
                                                              (line 251)
* quadratic:                             Definitions for simplification.
                                                              (line 191)
* rational:                              Definitions for simplification.
                                                              (line 167)
* reduce_consts:                         Definitions for simplification.
                                                              (line 299)
* rempart:                               Definitions for simplification.
                                                              (line 147)
* sqrtdenest:                            Definitions for simplification.
                                                              (line 355)
* tracematrix:                           Definitions for simplification.
                                                              (line 164)
* vers:                                  Definitions for simplification.
                                                              (line 235)
* wronskian:                             Definitions for simplification.
                                                              (line 153)

 [index ]
* Menu:

* absimp:                                Definitions for simplification.
                                                              (line   7)
* facexp:                                Definitions for simplification.
                                                              (line  34)
* facsum_combine:                        Definitions for simplification.
                                                              (line 112)
* ineq:                                  Definitions for simplification.
                                                              (line 255)
* nextlayerfactor:                       Definitions for simplification.
                                                              (line  95)



Tag Table:
Node: Top89
Node: Introduction to simplification338
Node: Definitions for simplification707
Node: Function and variable index16888

End Tag Table
