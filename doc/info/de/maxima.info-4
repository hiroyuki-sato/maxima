This is maxima.info, produced by makeinfo version 4.13 from
/home/robert/maxima/maxima-git/maxima-code/doc/info/de//include-maxima.de.texi.

Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Lineare Algebra,  Next: Tensoren,  Prev: Gleichungen,  Up: Top

19 Lineare Algebra
******************

* Menu:

* Einführung in die lineare Algebra::
* Funktionen und Variablen der linearen Algebra::


File: maxima.info,  Node: Einführung in die lineare Algebra,  Next: Funktionen und Variablen der linearen Algebra,  Prev: Lineare Algebra,  Up: Lineare Algebra

19.1 Einführung in die lineare Algebra
======================================

* Menu:

* Nicht-kommutative Multiplikation::
* Vektoren::
* Eigenwerte::


File: maxima.info,  Node: Nicht-kommutative Multiplikation,  Next: Vektoren,  Prev: Einführung in die lineare Algebra,  Up: Einführung in die lineare Algebra

19.1.1 Nicht-kommutative Multiplikation
---------------------------------------

Der Operator `.' repräsentiert die nichtkommutative Multiplikation oder
das Skalarprodukt. Sind die Argumente 1-spaltige oder 1-reihige Matrizen
`a' und `b', dann ist der Ausdruck `a . b' äquivalent zu
`sum(a[i]*b[i], i, 1, length(a))'. Sind `a' und `b' nicht komplex, dann
ist der vorhergende Ausdruck das Skalarprodukt von `a' und `b'. Das
Skalarprodukt ist als `conjugate(a) . b' definiert, wenn `a' und `b'
komplex sind. Die Funktion `innerproduct'  im Paket `eigen' stellt das
komplexe Skalarprodukt zur Verfügung.

Sind die Argumente `a' und `b' allgemeine Matrizen, dann ist das
Ergebnis der nichtkommutativen Multiplikation das Matrizprodukt der
Argumente.  Die Anzahl der Zeilen der Matrix `b' muss gleich der Anzahl
der Spalten der Matrix `a' sein. Das Ergebnis ist eine Matrix, deren
Anzahl der Zeilen der der Matrix `a' entspricht und deren Anzahl der
Spalten der der Matrix `b' entspricht.

Um den nichtkommutativen Operator `.' vom Dezimalpunkt einer
Gleitkommazahl zu unterscheiden, kann es notwendig sein, dem Operator
ein Leerzeichen voranzustellen und folgen zu lassen. Zum Beispiel ist
`5.e3' die Gleitkommazahl `5000.0' und `5 .  e3' ist `5' multipliziert
mit der Variablen `e3'.

Verschiedene Schalter kontrollieren die Vereinfachung der
nichtkommutativen Multiplikation. Zu diesen gehören:

   dot            dot0nscsimp     dot0simp
   dot1simp       dotassoc        dotconstrules
   dotdistrib     dotexptsimp     dotident
   dotscrules


File: maxima.info,  Node: Vektoren,  Next: Eigenwerte,  Prev: Nicht-kommutative Multiplikation,  Up: Einführung in die lineare Algebra

19.1.2 Vektoren
---------------

`vect' ist ein Paket mit Funktionen der Vektoranalysis.  Mit dem
Kommando `load(vect)' wird das Paket geladen.  Das Kommando
`demo(vect)' zeigt Beispiele.

Das Paket enthält Funktionen, um Ausdrücke mit nicht-kommutativen
Multiplikationen und Kreuzprodukten sowie Gradienten, Divergenzen,
Rotationen und Laplace-Operatoren zu vereinfachen.  Die Vereinfachung
dieser Operatoren wird von verschiedenen Schaltern kontrolliert.
Weiterhin können die Ergebnisse in verschiedenen Koordinatensystemen
berechnet werden.  Mit weiteren Funktionen kann das Skalarpotential
oder das Vektorpotential eines Feldes bestimmt werden.

Das Paket `vect' enthält die folgenden Funktionen: `vectorsimp',
`scalefactors', `express', `potential' und `vectorpotential'.


File: maxima.info,  Node: Eigenwerte,  Prev: Vektoren,  Up: Einführung in die lineare Algebra

19.1.3 Eigenwerte
-----------------

Das Paket `eigen' enthält verschiedene Funktionen, um symbolisch
Eigenwerte und Eigenvektoren zu bestimmen.  Maxima lädt dieses Paket
automatisch, wenn eine der Funktionen dieses Pakets genutzt wird.  Das
Paket kann auch mit dem Kommando `load(eigen)' geladen werden.

Das Kommando `demo(eigen)' zeigt Beispiele für das Paket.  Die Beispiele
können auch mit dem Kommando `batch(eigen' angezeigt werden.  In diesem
Fall wartet Maxima zwischen den einzelnen Beispielen auf die Eingabe des
Nutzers.

Das Paket `eigen' enthält die folgenden Funktionen:

   innerproduct       unitvector            columnvector
   gramschmidt        eigenvalues           eigenvectors
   uniteigenvectors   similaritytransform


File: maxima.info,  Node: Funktionen und Variablen der linearen Algebra,  Prev: Einführung in die lineare Algebra,  Up: Lineare Algebra

19.2 Funktionen und Variablen der linearen Algebra
==================================================

 -- Funktion: addcol (<M>, <list_1>, ..., <list_n>)
     Hängt eine oder mehrere Spalten, die als Listen <list_1>, ...,
     <list_n> übergeben werden, an die Matrix <M> an.

     Beispiel:

          (%i1) M:matrix([a,b],[c,d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) addcol(M,[1,2],[x,y]);
                                   [ a  b  1  x ]
          (%o2)                    [            ]
                                   [ c  d  2  y ]

 -- Funktion: addrow (<M>, <list_1>, ..., <list_n>)
     Hängt eine oder mehrere Zeilen, die als Listen <list_1>, ...,
     <list_n> übergeben werden, an die Matrix <M> an.

     Beispiel:

          (%i1) M:matrix([a,b],[c,d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) addrow(M,[1,2],[x,y]);
                                      [ a  b ]
                                      [      ]
                                      [ c  d ]
          (%o2)                       [      ]
                                      [ 1  2 ]
                                      [      ]
                                      [ x  y ]

 -- Funktion: adjoint (<M>)
     Gibt die adjungierte der Matrix <M> zurück.

 -- Funktion: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ...,
          <x_n>])
     Gibt die erweiterte Koeffizientenmatrix für die Variablen <x_1>,
     ..., <x_n> und dem linearen Gleichungssystem <eqn_1>, ..., <eqn_m>.
     Die erweiterte Koeffizientenmatrix entsteht, wenn an die
     Koeffizientenmatrix des Gleichungssystems die Spalte mit der
     rechten Seite des Gleichungssystems angefügt wird.

     Beispiel:

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]

 -- Funktion: charpoly (<M>, <x>)
     Gibt das charakteristische Polynom der Matrix <M> für die Variable
     <x> zurück.  Das charakterische Polynom wird als `determinant(<M>
     - diagmatrix(length (<M>), <x>))' berechnet.

     Beispiel:

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)

 -- Funktion: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Gibt die Koeffizientenmatrix für die Variablen <x_1>, ..., <x_n>
     des linearen Gleichungssystem <eqn_1>, ..., <eqn_m> zurück.

     Beispiel:

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]

 -- Funktion: col (<M>, <i>)
     Gibt die <i>-te Spalte der Matrix <M> zurück.  Das Ergebnis ist
     eine Matrix.

     Beispiel:

          (%i1) M:matrix([1,2,3],[a,b,c]);
                                     [ 1  2  3 ]
          (%o1)                      [         ]
                                     [ a  b  c ]
          (%i2) col(M,2);
                                        [ 2 ]
          (%o2)                         [   ]
                                        [ b ]

 -- Funktion: columnvector (<L>)
 -- Funktion: covect (<L>)
     Gibt eine Matrix mit einer Spalte zurück, die die Elemente der
     Liste <L> enthält.

     `covect' ist ein Alias-Name für die Funktion `columnvector'.  Das
     Kommando `load(eigen)' lädt die Funktion.

     Beispiel:

          (%i1) load(eigen)$

          (%i2) columnvector ([aa, bb, cc]);
                                       [ aa ]
                                       [    ]
          (%o2)                        [ bb ]
                                       [    ]
                                       [ cc ]

 -- Funktion: copymatrix (<M>)
     Gibt eine Kopie der Matrix <M> zurück.

     Die Zuweisung wie zum Beispiel `m2: m1' kopiert die Matrix `m1'
     nicht.  Wird nach dieser Zuweisung die Matrix `m2' geändert, wird
     auch die Matrix `m1' geändert.  Um eine Kopie zu erhalten, muss
     `m2: copymatrix(m1)' ausgeführt werden.

 -- Funktion: determinant (<M>)
     Berechnet die Determinate der Matrix <M>.  Die angewendete Methode
     ist vergleichbar mit dem Gauß-Verfahren.

     `determinat' wird von den Schaltern `ratmx' und `sparse'
     kontrolliert.  Haben beide Schalter den Wert `true', wird ein
     spezieller Algorithmus für schwachbesetzte Matrizen aufgerufen.

 -- Optionsvariable: detout
     Standardwert: `false'

     Hat `detout' den Wert `true', wird die Determinate einer Matrix,
     für die die inverse Matrix berechnet wird, aus der Matrix
     herausmultipliziert.

     Damit dieser Schalter einen Effekt hat, müssen die Optionsvariablen
     `doallmxops' und `doscmxops' den Wert `false' haben.

     Beispiele:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Funktion: diagmatrix (<n>, <x>)
     Gibt eine <n>-dimensionale Diagonalmatrix zurück, deren
     Diagonalelemente alle den Wert <x> haben.

     <n> muss zu einer ganzen Zahl auswerten.  Ansonsten meldet Maxima
     einen Fehler.

     <x> kann ein beliebiger Ausdruck einschließlich einer Matrix sein.
     Ist <x> eine Matrix, dann wird diese nicht kopiert.

 -- Optionsvariable: doallmxops
     Standardwert: `true'

     Hat `doallmxops' den Wert `true', werden Matrixoperationen
     ausgeführt.  Ist der Wert `false', werden nur die Matrixoperationen
     ausgeführt, die mit den einzelnen `dot'-Schaltern eingeschaltet
     sind.

 -- Optionsvariable: domxexpt
     Standardwert: `true'

     Hat `domxexpt' den Wert `true', wird die Exponentiation
     `exp(<M>)', wobei <M> eine Matrix ist, elementweise für jedes
     einzelne Matrixelement ausgeführt, so dass für jedes Element der
     Matrix gilt `exp (m[i,j])'.  Ansonsten wird die Exponentiation als
     `exp (<ev(M)>' ausgewertet.

     `domxexpt' beeinflußt alle Ausdrücke der Form `<a>^<b>', wobei <a>
     eine Konstante oder ein skalarer Ausdruck und <b> eine Liste oder
     Matrix ist.

     Beispiele:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]

 -- Optionsvariable: domxmxops
     Standardwert: `true'

     Hat `domxmxops' den Wert `true', werden allen Matrix-Matrix und
     Matrix-Listen-Operationen ausgeführt.


 -- Optionsvariable: domxnctimes
     Standardwert: `false'

     Hat `domxnctimes' den Wert `true', werden nichtkommutative Produkte
     von Matrizen ausgeführt.


 -- Optionsvariable: doscmxops
     Standardwert: `false'

     Hat `doscmxops' den Wert `true', werden Skalar-Matrix-Operationen
     ausgeführt.


 -- Optionsvariable: doscmxplus
     Standardwert: `false'

     Hat `doscmxplus' den Wert `true', haben Skalar-Matrix-Operationen
     eine Matrix als Ergebnis.  Dieser Schalter ist nicht unter
     `doallmxops' subsumiert.


 -- Optionsvariable: dot0nscsimp
     Standardwert: `true'

     Hat `dot0nscsimp' den Wert `true', werden nichtkommutative Produkte
     mit einer Null und einem nichtskalaren Term zu einem kommutativen
     Produkt vereinfacht.


 -- Optionsvariable: dot0simp
     Standardwert: `true'

     Hat `dot0simp' den Wert `true', werden nichtkommutative Produkte
     mit einer Null und einem skalaren Term zu einem kommutatitiven
     Produkt vereinfacht.


 -- Optionsvariable: dot1simp
     Standardwert: `true'

     Hat `dot1simp' den Wert `true', werden nichtkommutative Produkte
     mit einer Eins und einem anderen Term zu einem kommutativen
     Produkt vereinfacht.


 -- Optionsvariable: dotassoc
     Standardwert: `true'

     Hat `dotassoc' den Wert `true', vereinfacht Maxima ein Ausdruck
     `(A.B).C' zu `A.(B.C)'.


 -- Optionsvariable: dotconstrules
     Standardwert: `true'

     Hat `dotconstrules' den Wert `true', werden nichtkommutative
     Produkte einer Konstanten und eines Termes zu einem kommutativen
     Produkt vereinfacht.  Die folgenden Optionsvariablen `dot0simp',
     `dot0nscsimp' und `dot1simp' erhalten den Wert `true', wenn
     `construles' eingeschaltet wird.


 -- Optionsvariable: dotdistrib
     Standardwert: `false'

     Hat `dotdistrib' den Wert `true', vereinfacht Maxima einen Ausdruck
     `A.(B + C)' zu `A.B + A.C'.


 -- Optionsvariable: dotexptsimp
     Standardwert: `true'

     Hat `dotexptsimp' den Wert `true', vereinfacht Maxima einen
     Ausdruck `A.A' zu `A^^2'.


 -- Optionsvariable: dotident
     Standardwert: 1

     `dotident' ist der Wert der für den Ausdruck `X^^0' zurückgegeben
     wird.


 -- Optionsvariable: dotscrules
     Standardwert: `false'

     Hat `dotscrules' den Wert `true', vereinfacht Maxima Ausdrücke
     `A.SC' oder `SC.A' zu `SC*A' und `A.(SC*B)' zu `SC*(A.B)'.


 -- Funktion: echelon (<M>)
     Gibt die Matrix <m> in ihrer Stufenform zurück, wie sie im
     Gaußschen Eliminationsverfahren auftritt.

     Im Unterschied zur Funktion `triangularize' wird die Matrix so
     normiert, dass die Hauptdiagonalelemente den Wert 1 haben.

     `lu_factor' und `cholesky' sind weitere Funktionen, um
     Dreiecksmatrizen zu erhalten.

     Beispiel:

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]

 -- Funktion: eigenvalues (<M>)
 -- Funktion: eivals (<M>)
     Gibt eine Liste mit den Eigenwerten der Matrix <M> und deren
     Multiplizitäten zurück.  Die erste Teilliste enthält die
     Eigenwerte, die zweite deren Multiplizitäten.

     `eivals' ist ein Alias-Name der Funktion `eigenvalues'.

     `eigenvalues' ruft die Funktion `solve' auf, um die Nullstellen des
     charakeristischen Polynoms der Matrix zu finden.  Wenn `solve'
     keine Nullstellen finden kann, funktionieren einige Funktionen des
     Pakets nicht.  Dies trifft nicht auf die Funktionen
     `innerproduct', `unitvector', `columnvector' und `gramschmidt' zu.

     Die Eigenwerte, die `solve' findet, können sehr komplizierte
     Ausdrücke sein.  Es kann möglich sein, solche Ausdrücke weiter zu
     vereinfachen.

     Das Paket `eigen' wird automatisch geladen, wenn eine der
     Funktionen `eigenvalues' oder `eigenvectors' aufgerufen wird.


 -- Funktion: eigenvectors (<M>)
 -- Funktion: eivects (<M>)
     Berechnet die Eigenvektoren der Matrix <M>.  Die Rückgabe ist eine
     Liste, die zwei weitere Listen enthält.  Die erste Liste enthält
     die Eigenwerte der Matrix <m> und deren Multiplizitäten.  Die
     zweite Liste enthält die Eigenvektoren.

     `eivects' ist ein Alias-Name der Funktion `eigenvectors'.

     Das Paket `eigen' wird automatisch geladen, wenn die Funktionen
     `eigenvalues' oder `eigenvectors' aufgerufen werden.

     Folgende Schalter kontrollieren `eigenvectors':

    `nondiagonalizable'
          `nondiagonalizabel' hat den Wert `true' oder `false' nach
          Rückkehr der Funktion `eigenvectros' abhängig davon, ob die
          Matrix diagonalisierbar ist oder nicht.

    `hermitianmatrix'
          Hat `hermitianmatrix' den Wert `true', werden die entarteten
          Eigenvektoren einer Hermitischen Matrix mit dem
          Gram-Schmidt-Verfahren orthogonalisiert.

    `knowneigvals'
          Hat `knowneigvals' den Wert `true', werden die Eigenwerte der
          Matrix von den Funktionen des Paketes `eigen' als bekannt
          angenommen.  Die Eigenwerte sind in diesem Fall in der Liste
          `listeigvals' abgespeichert.  Die Liste `listeigvals' muss
          dieselbe Form haben, wie die Rückgabe der Funktion
          `eigenvalues'.


     Die Eigenvektoren werden von der Funktion `algsys' berechnet.  Es
     ist möglich, dass `algsys' die Eigenvektoren nicht findet.  In
     diesem Fall können möglicherweise zunächst die Eigenwerte bestimmt
     und weiter vereinfacht werden.  Dannach kann die Funktion
     `eigenvectors' mit dem Schalter `knowneigvals' aufgerufen werden.

     Siehe auch `eigenvalues'.

     Beispiele:

     Eine Matrix, die einen Eigenvektor zu jedem Eigenwert hat.

          (%i1) M1 : matrix ([11, -1], [1, 7]);
                                     [ 11  - 1 ]
          (%o1)                      [         ]
                                     [ 1    7  ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]],
                                  [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                 val  = 9 - sqrt(3)
                                    1

                                      mult  = 1
                                          1

                              vec  = [[1, sqrt(3) + 2]]
                                 1

                                 val  = sqrt(3) + 9
                                    2

                                      mult  = 1
                                          2

                              vec  = [[1, 2 - sqrt(3)]]
                                 2

          (%o3)                         done

     Eine Matrix, die zwei Eigenvektoren zu jedem Eigenwert hat.

          (%i1) M1 : matrix([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0],
                            [0, 0, 0, 2]);
                                   [ 0  1  0  0 ]
                                   [            ]
                                   [ 0  0  0  0 ]
          (%o1)                    [            ]
                                   [ 0  0  2  0 ]
                                   [            ]
                                   [ 0  0  0  2 ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                             [[0, 0, 1, 0], [0, 0, 0, 1]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                      val  = 0
                                         1

                                      mult  = 2
                                          1

                                vec  = [[1, 0, 0, 0]]
                                   1

                                      val  = 2
                                         2

                                      mult  = 2
                                          2

                         vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                            2

          (%o3)                         done

 -- Funktion: ematrix (<m>, <n>, <x>, <i>, <j>)
     Gibt eine <m> `x' <n>-Matrix zurück, deren Elemente den Wert 0
     haben, bis auf das Element `[<i>, <j>]', das den Wert <x> hat.

 -- Funktion: entermatrix (<m>, <n>)
     Gibt eine <m> `x' <n>-Matrix zurück, die von der Konsole
     eingelesen wird.

     Ist <n> gleich <m>, fragt Maxima nach dem Typ der Matrix.  Folgende
     Typen können angegeben werden: diagonal, symmetric, antisymmetric
     oder allgemein.  Dannach werden die einzelnen Elemente der Matrix
     abgefragt.

     Sind <n> und <m> voneinander verschieden, fragt Maxima nach jedem
     Element der Matrix.

     Die Elemente können beliebige Ausdrücke sein, die ausgewertet
     werden.  `entermatrix' wertet die Argumente aus.

     Beispiel:

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
          4. General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matrix entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]

 -- Funktion: express (<expr>)
     Expandiert Differentialoperatoren in einem Ausdruck in partielle
     Ableitungen.  `express' erkennt die Operatoren `grad', `div',
     `curl', `laplacian' und das Kreuzprodukt `~'.

     Enthält die Rückgabe Substantivformen von Ableitungen, können
     diese mit der Funktion `ev' und den Auswertungsschaltern `nouns'
     oder `diff' ausgewertet werden.

     Mit dem Kommando `load(vect)' wird die Funktion geladen.

     Beispiele:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]

 -- Funktion: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Funktion: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Funktion: genmatrix (<a>, <i_2>, <j_2>)
     Generiert eine Matrix aus einem Array <a>.  Das erste Element der
     Matrix ist der Wert `<a>[<i_1>,<j_1>]' und das letzte Element der
     Matrix ist `<a>[<i_2>,<j_2>]'.  <a> muss ein deklariertes Array
     sein, dass mit der Funktion `array' definiert wurde.  Weiterhin
     kann <a> ein undeklariertes Array, eine Array-Funktion oder ein
     lambda-Ausdruck mit zwei Argumenten sein.

     Wird <j_1> nicht angegeben, nimmt Maxima an, das der Wert gleich
     <i_1> ist.  Werden beide Argumente <j_1> und <i_1> nicht
     angegeben, werden die Werte zu 1 angenommen.

     Ist eines der Elemente `[i,j]' des Arrays nicht definiert, enthält
     die Matrix den symbolischen Wert `<a>[i,j]'.

     Beispiele:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]

 -- Funktion: gramschmidt (<x>)
 -- Funktion: gramschmidt (<x>, <F>)
     Wendet das Gram-Schmidtsche Orthogonalisierungsverfahren auf das
     Argument <x> an.  <x> ist eine Matrix oder eine Liste mit Listen
     für die Spalten.  Das Argument <x> wird von `gramschmidt' nicht
     verändert.  <F> bezeichnet eine Funktion, die als Skalarprodukt
     für das Verfahren verwendet wird.  Wird <F> nicht angegeben, wird
     die Funktion `innerproduct' für das Skalarprodukt angewendet.

     Ist <x> eine Matrix, wird der Algorithmus auf die Zeilen der Matrix
     angewendet.  Ist <x> eine Liste mit Listen, wird der Algorithmus
     auf die Teillisten angewendet, die jeweils die gleiche Anzahl an
     Elementen haben müssen.

     Jede Stufe des Verfahrens ruft die Funktion `factor' auf, um die
     Zwischenergebnisse zu vereinfachen.  Dadurch kann das Ergebnis
     faktorisierte ganze Zahlen enthalten.

     Das Kommando `load(eigen)' lädt die Funktion.

     Beispiele:

     Das Gram-Schmidtsche Orthogonalisierungsverfahren mit
     `innerproduct' als Skalarprodukt.

          (%i1) load (eigen)$
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
          (%o4)                       [0, 0, 0]

     Das Gram-Schmidtsche Orthogonalisierungsverfahren mit einer
     selbstdefinierten Funktion für das Skalarprodukt.

          (%i1) load (eigen)$
          (%i2) ip (f, g) := integrate (f * g, u, a, b);
          (%o2)          ip(f, g) := integrate(f g, u, a, b)
          (%i3) y : gramschmidt([1, sin(u), cos(u)], ip), a=-%pi/2, b=%pi/2;
                                         %pi cos(u) - 2
          (%o3)              [1, sin(u), --------------]
                                              %pi
          (%i4) map(ip,[y[1],y[2],y[3]],[y[2],y[3],y[1]]), a=-%pi/2, b=%pi/2;
          (%o4)                       [0, 0, 0]

 -- Funktion: ident (<n>)
     Gibt eine <n> `x' <n>-Einheitsmatrix zurück.

 -- Funktion: innerproduct (<x>, <y>)
 -- Funktion: inprod (<x>, <y>)
     Gibt das Skalarprodukt der Argumente <x> und <y> zurück.  Die
     Argument können Listen oder 1-spaltige oder 1-reihige Matrizen
     sein.  Das Skalarprodukt wird als `conjugate(x) . y' berechnet,
     wobei `.' der Operator der nicht-kommutativen Multiplikation ist.

     Das Kommando `load(eigen)' lädt die Funktion.

     `inprod' ist ein Alias-Name der Funktion `innerproduct'.


 -- Funktion: invert (<M>)
     Gibt die inverse Matrix der Matrix <M> zurück.  Die inverse Matrix
     wird mittels der Adjunkten Matrix berechnet.

     Mit dieser Methode kann die inverse Matrix auch für große
     Gleitkommazahlen sowie Polynomme als Matrixelemente berechnet
     werden.

     Die Kofaktoren werden mit der Funktion `determinant' berechnet.
     Hat die Optionsvariable `ratmx' den Wert `true', wird die inverse
     Matrix daher ohne einen Wechsel der Darstellung berechnet.

     Die implementierte Methode ist jedoch ineffizient für große
     Matrizen.

     Hat die Optionsvariable `detout' den Wert `true', wird die
     Determinante als Faktor aus der Matrix herausgezogen.

     Die Elemente der inversen Matrix werden nicht automatisch
     expandiert.  Hat <M> Polynome als Elemente, hat das Ergebnis
     möglicherweise mit dem Kommando `expand(invert(m)), detout' eine
     einfachere Form.  Mit der Funktion `multthru' die Determinate in
     die Matrix hereinmultipliziert werden.  Die inverse Matrix kann
     auch folgendermaßen berechnet werden:

          expand (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     Siehe auch den Operator `^^' der nicht-kommutativen Exponentiation
     für eine andere Methode zur Berechnung der inversen Matrix.


 -- Optionsvariable: lmxchar
     Standardwert: `['

     `lmxchar' ist das Zeichen, das für die linke Seite einer Matrix
     ausgegeben wird.  Siehe auch `rmxchar'.

     Beispiel:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]

 -- Funktion: matrix (<row_1>, ..., <row_n>)
     Gibt eine Matrix mit den Spalten <row_1>, ..., <row_n> zurück.
     Jede Spalte ist eine Liste mit Asudrücken.  Alle Spalten müssen
     die gleiche Länge haben.

     Die Addition `+', Subtraktion `-', Multiplikation `*' und Division
     `/' werden elementweise ausgeführt, wenn die Argumente zwei
     Matrizen, ein Skalar und eine Matrix oder eine Matrix und ein
     Skalar sind.  Die Exponentiation `^' wird elementweise ausgeführt,
     wenn die Argumente ein Skalar und eine Matrix oder umgekehrt sind.

     Die nichtkommutatie Multiplikation von Matrizen wird mit dem
     Operator `.' ausgeführt.  Der entsprechende Operator für die
     nichtkommutative Exponentiation ist `^^'. Für eine Matrix `<A>' ist
     `<A> . <A> = <A>^^2'. `<A>^^-1' ist die inverse Matrix, falls
     diese existiert.

     Folgende Schalter kontrollieren die Vereinfachung von Ausdrücken,
     welche die nichtkommutative Multiplikation und Matrizen enthalten:

     `doallmxops', `domxexpt', `domxmxops', `doscmxops' und
     `doscmxplus'.

     Weitere Optionsvariablen für Matrizen sind:

     `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix' und `sparse'.

     Folgende Funktionen akzeptieren Matrizen als ein Argument oder
     haben eine Matrix als Rückgabewert:

     `eigenvalues', `eigenvectors', `determinant', `charpoly',
     `genmatrix', `addcol', `addrow', `copymatrix', `transpose',
     `echelon' and `rank'.

     Beispiele:

     Konstruiere eine Matrix mit Listen.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

     Elementweise Addition zweier Matrizen.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

     Elementweise Subtraktion zweier Matrizen.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

     Elementweise Multiplikation zweier Matrizen.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

     Elementweise Division zweier Matrizen.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

     Elementweise Exponentiation einer Matrix mit einem Skalar.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

     Elementweise Exponentiation eines Skalars mit einer Matrix.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

     Die Exponentiation zweier Matrizen wird nicht elementweise
     ausgeführt.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

     Nichtkommutative Multiplikation zweier Matrizen.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

     Nichtkommutative Exponentiation einer Matrix.  Ist die Basis ein
     Skalar wird die Exponentiation elementweise ausgeführt.  Daher
     haben die Operationen `^^' und `^' für diesen Fall dasselbe
     Ergebnis.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

     Berechnung der inversen Matrix mit `x^^-1'.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]

 -- Funktion: matrixmap (<f>, <M>)
     Gibt eine Matrix mit den Elementen `[i,j]' zurück, die mit
     `<f>(<M>[i,j])' berechnet werden.

     Siehe auch `map', `fullmap', `fullmapl', and `apply'.


 -- Funktion: matrixp (<expr>)
     Gibt `true' zurück, wenn <expr> eine Matrix ist.  Ansonsten wird
     `false' zurückgegeben.

 -- Optionsvariable: matrix_element_add
     Standardwert: `+'

     `matrix_element_add' enthält die Operation für die Ausführung der
     Addition von Matrizen.  Der Optionsvariablen `matrix_element_add'
     kann ein N-Ary-Operator zugewiesen werden.  Der zugewiesene Wert
     kann der Name eines Operators, einer Funktion oder ein
     Lambda-Ausdruck sein.

     Siehe auch `matrix_element_mult' und `matrix_element_transpose'.

     Beispiele:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]

 -- Optionsvariable: matrix_element_mult
     Standardwert: `*'

     `matrix_element_mult' enthält die Operation für die Ausführung der
     Multiplikation von Matrizen.  Der Optionsvariablen
     `matrix_element_mult' kann ein binärer Operator zugewiesen werden.
     Der zugewiesene Wert kann der Name eines Operators, einer Funktion
     oder ein Lambda-Ausdruck sein.

     Der nichtkommutative Operator `.' kann eine sinnvolle Alternative
     sein.

     Siehe auch `matrix_element_add' und `matrix_element_transpose'.

     Beispiele:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]

 -- Optionsvariable: matrix_element_transpose
     Standardwert: `false'

     `matrix_element_transpose' enthält die Operation für die Ausführung
     der Transponierung einer Matrix.  Der Optionsvariablen
     `matrix_element_mult' kann ein unärer Operator zugewiesen werden.
     Der zugewiesene Wert kann der Name eines Operators, einer Funktion
     oder ein Lambda-Ausdruck sein.

     Hat `matrix_element_transpose' den Wert `transpose', wird die
     Funktion `transpose' auf jedes Element der Matrix angewendet.  Hat
     `matrix_element_transpose' den Wert `nonscalars', wird die Funktion
     `transpose' auf nichtskalare Elemente der Matrix angewendet.  Ist
     eines der Elemente ein Atom, muss in diesem Fall das Atom als
     `nonscalar' deklariert sein.

     Mit dem Standardwert `false' wird keine Operation angewendet.

     Siehe auch `matrix_element_add' und `matrix_element_mult'.

     Beispiele:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x)
                - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]

 -- Funktion: mattrace (<M>)
     Gibt die Spur einer quadratischen Matrix <M> zurück.


 -- Funktion: minor (<M>, <i>, <j>)
     Gibt den Minor zu <i>, <j> der Matrix <M> zurück.  Die Matrix
     entsteht durch Streichen der <i>-ten Spalte und <j>-ten Zeile.

 -- Funktion: ncharpoly (<M>, <x>)
     Gibt das charakteristische Polynom der Matrix <M> für die Variable
     <x> zurück.  Diese Funktion ist eine Alternative zur Funktion
     `charpoly'.

     Der Algorithmus von `ncharpoly' ist vorteilhaft gegenüber
     `charpoly', wenn große und dünn besetzte Matrizen vorliegen.  Das
     Kommando `load(nchrpl' lädt die Funktion.

 -- Funktion: newdet (<M>, <n>)
     Berechnet die Determinate der Matrix oder eines Arrays <M> mit dem
     Johnson-Gentleman-Algorithmus.  Das Argument <n> ist die Ordnung.
     Für eine Matrix ist <n> ein optionales Argument.

 -- Funktion: permanent (<M>, <n>)
     Berechnet die Permanente der Matrix <M>.  Die Permanente ist
     ähnlich der Determinate, aber es fehlen die Vorzeichenwechsel.

 -- Funktion: rank (<M>)
     Berechnet den Rang der Matrix <M>.

     <rank> kann ein falsches Ergebnis geben, wenn ein Element
     äquivalent zu Null ist, dies aber nicht von Maxima festgestellt
     werden kann.

 -- Funktion: potential (<givengradient>)
     The calculation makes use of the global variable
     `potentialzeroloc[0]' which must be `nonlist' or of the form

          [indeterminatej=expressionj, indeterminatek=expressionk, ...]

     the former being equivalent to the nonlist expression for all
     right-hand sides in the latter.  The indicated right-hand sides
     are used as the lower limit of integration.  The success of the
     integrations may depend upon their values and order.
     `potentialzeroloc' is initially set to 0.

 -- Optionsvariable: ratmx
     Standardwert: `false'

     Hat `ratmx' den Wert `false', werden die Berechnung einer
     Determinante sowie die Operationen der Addition, Subtraktion und
     Multiplikation in der allgemeinen Darstellung ausgeführt.  Das
     Ergebnis ist wieder eine allgemeine Darstellung.

     Hat `ratmx' den Wert `true', werden die oben genannten Operationen
     in einer CRE-Darstellung ausgeführt un das Ergebnis ist in einer
     CRE-Darstellung.

 -- Optionsvariable: rmxchar
     Standardwert: `]'

     `rmxchar' ist das Zeichen, das für die rechte Seite einer Matrix
     ausgegeben wird.  Siehe auch `lmxchar'.

 -- Funktion: row (<M>, <i>)
     Gibt die <i>-te Spalte der Matrix <M> zurück.  Der Rückgabewert ist
     eine Matrix.

 -- Optionsvariable: scalarmatrixp
     Standardwert: `true'

     Hat `scalarmatrixp' den Wert `true', dann werden 1 x 1-Matrizen,
     die als Ergebnis einer nicht-kommutativen Multiplikation
     auftreten, zu einem Skalar vereinfacht.

     Hat `scalarmatrixp' den Wert `all', dann werden alle 1 x 1-Matrizen
     zu einem Skalar vereinfacht.

     Hat `scalarmatrixp' den Wert `false', werden 1 x 1-Matrizen nicht
     zu einem Skalar vereinfacht.

 -- Funktion: scalefactors (<coordinatetransform>)
     Here coordinatetransform evaluates to the form [[expression1,
     expression2, ...], indeterminate1, indeterminat2, ...], where
     indeterminate1, indeterminate2, etc. are the curvilinear
     coordinate variables and where a set of rectangular Cartesian
     components is given in terms of the curvilinear coordinates by
     [expression1, expression2, ...].  `coordinates' is set to the
     vector [indeterminate1, indeterminate2, ...], and `dimension' is
     set to the length of this vector.  SF[1], SF[2], ...,
     SF[DIMENSION] are set to the coordinate scale factors, and
     `sfprod' is set to the product of these scale factors.  Initially,
     `coordinates' is [X, Y, Z], `dimension' is 3, and
     SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to 3-dimensional
     rectangular Cartesian coordinates.  To expand an expression into
     physical components in the current coordinate system, there is a
     function with usage of the form

 -- Funktion: setelmx (<x>, <i>, <j>, <M>)
     Weist <x> dem Matrixelement `[<i>,<j>]' zu und gibt die
     modifizierte Matrix zurück.

     `<M>[<i>, <j>]: <x>' hat denselben Effekt.  In diesem Fall wird
     jedoch der Wert <x> zurückgeben und nicht die Matrix.

 -- Funktion: similaritytransform (<M>)
 -- Funktion: simtran (<M>)
     `similaritytransform' computes a similarity transform of the matrix
     `M'.  It returns a list which is the output of the
     `uniteigenvectors' command.  In addition if the flag
     `nondiagonalizable' is `false' two global matrices `leftmatrix'
     and `rightmatrix' are computed.  These matrices have the property
     that `leftmatrix . <M> . rightmatrix' is a diagonal matrix with
     the eigenvalues of <M> on the diagonal.  If `nondiagonalizable' is
     `true' the left and right matrices are not computed.

     If the flag `hermitianmatrix' is `true' then `leftmatrix' is the
     complex conjugate of the transpose of `rightmatrix'.  Otherwise
     `leftmatrix' is the inverse of `rightmatrix'.

     `rightmatrix' is the matrix the columns of which are the unit
     eigenvectors of <M>.  The other flags (see `eigenvalues' and
     `eigenvectors') have the same effects since `similaritytransform'
     calls the other functions in the package in order to be able to
     form `rightmatrix'.

     `load ("eigen")' loads this function.

     `simtran' is a synonym for `similaritytransform'.

 -- Optionsvariable: sparse
     Standardwert: `false'

     Haben `sparse' und `ratmx' den Wert `true', verwendet die Funktion
     `determinant' einen speziellen Algorithmus für dünn besetzte
     Matrizen, um die Determinante einer Matrix zu berechnen.

 -- Funktion: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Funktion: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Funktion: submatrix (<M>, <j_1>, ..., <j_n>)
     Gibt eine Matrix zurück, in der die Spalten <i_1>, ..., <i_m> und
     die Zeilen <j_1>, ..., <j_n> der Matrix <M> gelöscht sind.

 -- Funktion: transpose (<M>)
     Gibt die Transponierte der Matrix <M> zurück.

     Ist <M> eine Matrix, ist das Ergebnis eine Matrix <N> mit den
     Elementen `N[i,j] = M[j,i]'.

     Ist <M> eine Liste, ist die Rückgabe eine Matrix <N> mit
     `length(M)' Spalten und einer Zeile.  Die Elemente sind `N[i,1] =
     M[i]'.

     Ansonsten wird eine Substantivform `'transpose(<M>)' zurückgegeben.

 -- Funktion: triangularize (<M>)
     Gibt die obere Dreiecksmatrix für die Matrix `M' zurück, wie sie
     mit dem Gaußschen Eliminationsverfahren berechnet wird.  Die
     Dreiecksmatrix entspricht der Rückgabe der Funktion `echelon' mit
     dem Unterschied, dass die Elemente auf der Diagonalen nicht zu 1
     normalisiert sind.

     Mit den Funktionen `lu_factor' und `cholesky' kann ebenfalls eine
     Matrix in die Dreiecksform transformiert werden.

     Beispiel:

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]

 -- Funktion: uniteigenvectors (<M>)
 -- Funktion: ueivects (<M>)
     Berechnet die Einheitsvektoren der Matrix <M>.  Die Rückgabe ist
     eine Liste, die zwei weitere Listen enthält.  Die erste Liste
     enthält die Eigenwerte der Matrix <M> und deren Multiplizitäten.
     Die zweite Liste enthält die Einheitsvektoren.

     Ansonsten entspricht `uniteigenvectors' der Funktion
     `eigenvectors'.

     Das Kommando `load(eigen)' lädt die Funktion.

     `ueivects' ist ein Alias-Name der Funkion `uniteigenvectors'.

 -- Funktion: unitvector (<x>)
 -- Funktion: uvect (<x>)
     Gibt den Einheitsvektor <x>/norm(<x>) zurück.

     Das Kommando `load(eigen)' lädt die Funktion.

     `uvect' ist ein Alias-Name der Funktion `unitvector'.

 -- Funktion: vectorpotential (<givencurl>)
     Returns the vector potential of a given curl vector, in the current
     coordinate system.  `potentialzeroloc' has a similar role as for
     `potential', but the order of the left-hand sides of the equations
     must be a cyclic permutation of the coordinate variables.

 -- Funktion: vectorsimp (<expr>)
     Applies simplifications and expansions according to the following
     global flags:

     expandall         expanddot             expanddotplus
     expandcross       expandcrossplus       expandcrosscross
     expandgrad        expandgradplus        expandgradprod
     expanddiv         expanddivplus         expanddivprod
     expandcurl        expandcurlplus        expandcurlcurl
     expandlaplacian   expandlaplacianplus   expandlaplacianprod

     All these flags have default value `false'.  The `plus' suffix
     refers to employing additivity or distributivity.  The `prod'
     suffix refers to the expansion for an operand that is any kind of
     product.

    `expandcrosscross'
          Simplifies `p ~ (q ~ r)' to `(p . r)*q - (p . q)*r'.

    `expandcurlcurl'
          Simplifies `curl curl p' to `grad div p + div grad p'.

    `expandlaplaciantodivgrad'
          Simplifies `laplacian p' to `div grad p'.

    `expandcross'
          Enables `expandcrossplus' and `expandcrosscross'.

    `expandplus'
          Enables `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', and `expandlaplacianplus'.

    `expandprod'
          Enables `expandgradprod', `expanddivprod', and
          `expandlaplacianprod'.

     These flags have all been declared `evflag'.


 -- Optionsvariable: vect_cross
     Standardwert: `false'

     Hat `vect_cross' den Wert `true', werden Ausdrücke, die die
     Ableitung eines Kreuzproduktes enthalten, vereinfacht.

     Beispiel:

          (%i1) load(vect)$

          (%i2) vect_cross:false;
          (%o2)                         false
          (%i3) diff(f(x)~g(x),x);
                                  d
          (%o3)                   -- (f(x) ~ g(x))
                                  dx
          (%i4) vect_cross:true;
          (%o4)                         true
          (%i5) diff(f(x)~g(x),x);
                               d                    d
          (%o5)        f(x) ~ (-- (g(x))) - g(x) ~ (-- (f(x)))
                               dx                   dx

 -- Funktion: zeromatrix (<m>, <n>)
     Gibt eine <m> x <n>-Matrix zurück, deren Elemente alle Null sind.


File: maxima.info,  Node: Tensoren,  Next: Zahlentheorie,  Prev: Lineare Algebra,  Up: Top

20 Tensoren
***********

* Menu:

* Tensorpakete in Maxima::
* Paket itensor::
* Paket ctensor::
* Paket atensor::


File: maxima.info,  Node: Tensorpakete in Maxima,  Next: Paket itensor,  Prev: Tensoren,  Up: Tensoren

20.1 Tensorpakete in Maxima
===========================

Maxima hat drei verschiedene Pakete, um mit Tensoren zu rechnen.  Das
Paket `ctensor' implementiert das Rechnen mit Tensoren in der
Koordinatendarstellung und das Paket `itensor' das Rechnen in einer
Indexnotation.  Das Paket `atensor' erlaubt die algebraische
Manipulation von Tensoren in verschiedenen Algebren.

Beim Rechnen in einer Koordinatendarstellung mit dem Paket `ctensor'
werden Tensoren als Arrays oder Matrizen dargestellt.  Operationen mit
Tensoren wie die Tensorverjüngung oder die kovariante Ableitung werden
ausgeführt als Operationen mit den Komponenten des Tensors, die in
einem Array oder einer Matrix gespeichert sind.

Beim Rechnen in der Indexnotation mit dem Paket `itensor' werden
Tensoren als Funktionen ihrer kovarianten und kontravarianten Indizes
sowie den Ableitungen nach den Komponenten dargestellt.  Operationen
wie die Tensorverjüngung oder die kovariante Ableitung werden
ausgeführt, in dem die Indizes manipuliert werden.

Die beiden genannten Pakete `itensor' und `ctensor' für die Behandlung
von mathematischen Problemen im Zusammenhang mit der Riemannschen
Geometrie haben verschiedene Vor- und Nachteile, die sich erst anhand
des zu behandelnden Problems und dessen Schwierigkeitsgrad zeigen.
Folgenden Eigenschaften der beiden Implementierungen sollten beachtet
werden:

Die Darstellung von Tensoren und Tensoroperationen in einer expliziten
Koordinatendarstellung vereinfacht die Nutzung des Paketes `ctensor'.
Die Spezifikation der Metrik und die Ableitung von Tensoren sowie von
Invarianten ist unkompliziert.  Trotz Maximas Methoden für die
Vereinfachung von Ausdrücken kann jedoch eine komplexe Metrik mit
komplizierten funktionalen Abhängigkeiten der Koordinaten leicht zu
sehr großen Ausdrücken führen, die die Struktur eines Ergebnisses
verbergen.  Weiterhin können Rechnungen zu sehr großen
Zwischenergebnisse führen, die zu einem Programmabbruch führen, bevor
die Rechnung beendet werden kann.  Jedoch kann der Nutzer mit einiger
Erfahrung viele dieser Probleme vermeiden.

Aufgrund der besonderen Weise, wie Tensoren und Tensoroperationen als
symbolische Operationen ihrer Indizes dargestellt werden, können
Ausdrücke, die in einer Koordinatendarstellung sehr unhandlich sind,
mit Hilfe spezieller Routinen für symmetrische Objekte in `itensor'
manchmal erheblich vereinfacht werden.  Auf diese Weise kann die
Struktur großer Ausdrücke transparenter sein.  Auf der anderen Seite
kann die Spezifikation einer Metrik, die Definition von Funktionen und
die Auswertung von abgeleiteten indizierten Objekten für den Nutzer
schwierig sein.

Mit dem Paket `itensor' können Ableitungen nach einer indizierten
Variablen ausgeführt werden, wodurch es möglich ist, `itensor' auch für
Probleme im Zusammenhang mit dem Lagrange- oder Hamiltonian-Formalismus
einzusetzen.  Da es möglich ist, die Lagrangeschen Feldgleichungen nach
einer indizierten Variablen abzuleiten, können zum Beispiel die
Euler-Lagrange-Gleichungen in einer Indexnotation aufgestellt werden.
Werden die Gleichungen mit der Funktion `ic_convert'  in eine
Komponentendarstellung für das Paket `ctensor' transformiert, können
die Feldgleichungen in einer bestimmten Koordinatendarstellung gelöst
werden.  Siehe dazu die ausführlichen Beispiele in `einhil.dem' und
`bradic.dem'.


File: maxima.info,  Node: Paket itensor,  Next: Paket ctensor,  Prev: Tensorpakete in Maxima,  Up: Tensoren

20.2 Paket ITENSOR
==================

* Menu:

* Einführung in itensor::
* Funktionen und Variablen für itensor::


File: maxima.info,  Node: Einführung in itensor,  Next: Funktionen und Variablen für itensor,  Prev: Paket itensor,  Up: Paket itensor

20.2.1 Einführung in ITENSOR
----------------------------

Das Paket `itensor' für das Rechnen mit Tensoren in der Indexnotation
wird mit dem Kommando `load(itensor)' geladen.  Mit dem Kommando
`demo(tensor)' wird eine Liste mit verschiedenen Beispielen angezeigt.

Im Paket `itensor' werden Tensoren als indiziertes Objekte dargestellt.
Ein indiziertes Objekt ist eine Funktion mit drei Gruppen an Indizes,
die die kovarianten, kontravarianten und Ableitungsindizes eines
Tensors darstellen.  Das erste Argument der Funktion ist eine Liste der
kovarianten Indizes und das zweite Argument die Liste der
kontravarianten Indizes.  Hat der Tensor keine entsprechenden
Komponenten, dann wird eine leere Liste als Argument angegeben.  Zum
Beispiel repräsentiert `g([a,b], [c]' einen Tensor `g', der zwei
kovariante Indizes `[a,b]', einen kontravarianten Index `[c]' und
keinen Ableitungsindex hat.  Mit der Funktion `ishow'  werden Tensoren
in einer besonderen Schreibweise ausgegeben.

Beispiele:

     (%i1) load(itensor)$

     (%i2) g([a,b], [c]);
     (%o2)                    g([a, b], [c])

     (%i3) ishow(g([a,b], [c]))$
                                    c
     (%t3)                         g
                                    a b

Ableitungsindizes werden als weitere Argumente der Funktion
hinzugefügt, die den Tensor repräsentiert.  Ableitungsindizes können
vom Nutzer angegeben oder bei der Ableitung von Tensoren von Maxima
hinzugefügt werden.  Im Allgemeinen ist die Differentiation kommutativ,
so dass die Reihenfolge der Ableitungsindizes keine Rolle spielt.
Daher werden die Indizes von Maxima bei der Vereinfachung mit
Funktionen wie `rename'  alphabetisch sortiert.  Dies ist jedoch nicht
der Fall, wenn bewegte Bezugssysteme genutzt werden, was mit der
Optionsvariablen `iframe_flag'  angezeigt wird, die in diesem Fall den
Wert `true' erhält.  Es ist zu beachten, dass mit dem Paket `itensor'
Ableitungsindizes nicht angehoben werden können und nur als kovariante
Indizes auftreten.

Beispiele:

     (%i1) load(itensor)$

     (%i2) ishow(t([a,b],[c],j,i))$
                                  c
     (%t2)                       t
                                  a b,j i
     (%i3) ishow(rename(%))$
                                  c
     (%t3)                       t
                                  a b,i j
     (%i4) ishow(t([a,b],[c],j,i) - t([a,b],[c],i,j))$
                             c          c
     (%t4)                  t        - t
                             a b,j i    a b,i j
     (%i5) ishow(rename(%))$
     (%t5)                           0
     (%i6) iframe_flag:true;
     (%o6)                         true
     (%i7) ishow(t([a,b],[c],j,i) - t([a,b],[c],i,j))$
                             c          c
     (%t7)                  t        - t
                             a b,j i    a b,i j
     (%i8) ishow(rename(%))$
                             c          c
     (%t8)                  t        - t
                             a b,j i    a b,i j

Das folgende Beispiel zeigt einen Ausdruck mit verschiedenen
Ableitungen eines Tensors `g'.  Ist `g' der metrische Tensor, dann
entspricht das Ergebnis der Definition des Christoffel-Symbols der
ersten Art.

     (%i1) load(itensor)$

     (%i2) ishow(1/2*(idiff(g([i,k],[]),j) + idiff(g([j,k],[]),i)
                                           - idiff(g([i,j],[]),k)))$
                         g      + g      - g
                          j k,i    i k,j    i j,k
     (%t2)               ------------------------
                                    2

Tensoren werden standardmäßig nicht als symmetrisch angenommen.  Erhält
die Optionsvariable `allsym'  den Wert `true', dann werden alle
Tensoren als symmetrisch in den kovarianten und kontravarianten Indizes
angenommen.

Das Paket `itensor' behandelt Tensoren im Allgemeinen als opake Objekte.
Auf Tensorgleichungen werden algebraischen Regeln insbesondere
Symmetrieregeln und Regeln für die Tensorverjüngung angewendet.
Weiterhin kennt `itensor' die kovariante Ableitung, Krümmung und die
Torsion.  Rechnungen können in bewegten Bezugssystemen ausgeführt
werden.

Beispiele:

Die folgenden Beispiele zeigen einige Anwendungen des Paketes `itensor'.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                     %4 %5
     (%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
             i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                              + e p       + e   p    ))/2
                                                   i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %7                    %6 %7
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %7 i             %6    i j %7      i,j

                                                  %6 %7
                                             - ifg      v   ifb      )/2
                                                         %6    %7 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Funktionen und Variablen für itensor,  Prev: Einführung in itensor,  Up: Paket itensor

20.2.2 Funktionen und Variablen für ITENSOR
-------------------------------------------

* Menu:

* Behandlung indizierter Größen::
* Tensorsymmetrien::
* Tensoranalysis::
* Tensoren in gekrümmten Räumen::
* Begleitende Vielbeine::
* Torsion und Nichtmetrizität::
* Graßmann-Algebra::
* Exportiere als TeX::
* Schnittstelle zum Paket ctensor::
* Reservierte Bezeichner::


File: maxima.info,  Node: Behandlung indizierter Größen,  Next: Tensorsymmetrien,  Prev: Funktionen und Variablen für itensor,  Up: Funktionen und Variablen für itensor

20.2.2.1 Behandlung indizierter Größen
......................................

 -- Funktion: canten (<expr>)
     Ist vergleichbar mit der Funktion `rename'  und vereinfacht den
     Ausdruck <expr> indem gebundene Indizes umbenannt und permutiert
     werden.  Wie die Funktion `rename' kann `canten' nur Ausdrücke mit
     Summen von Tensorprodukten vereinfachen, in denen keine
     Ableitungen nach Tensorkomponenten auftreten.  Daher sollte
     `canten' nur verwendet werden, wenn sich mit der Funktion `canform'
     nicht die gewünschte Vereinfachung eines Ausdrucks erzielen lässt.

     Das Ergebnis der Funktion `canten' ist mathematisch nur korrekt,
     wenn die Tensoren symmetrisch in ihren Indizes sind.  Hat die
     Optionsvariable `allsym'  _nicht_ den Wert `true', bricht `canten'
     mit einer Fehlermeldung ab.

     Siehe auch die Funktion `concan',  mit der Ausdrücke mit Tensoren
     ebenfalls vereinfacht werden können, wobei `concan' zusätzlich
     Tensorverjüngungen ausführt.

 -- Funktion: changename (<old>, <new>, <expr>)
     Ändert den Namen aller Tensoren im Ausdruck <expr> von <old> nach
     <new>.  Das Argument <old> kann ein Symbol oder eine Liste der
     Form `[<name>, <m>, <n>]' sein.  Im letzteren Fall werden nur die
     Tensoren zu <new> umbenannt, die den Namen <name> sowie <m>
     kovariante und <n> kontravariante Indizes haben.

     Beispiel:

     In diesem Beispiel wird der Name <c> zu <w> geändert.

          (%i1) load(itensor)$

          (%i2) expr:a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e$

          (%i3) ishow(changename(c, w, expr))$
                                            k
          (%t3)                 d e w    + a    b
                                     x y    i j  u,v

 -- Funktion: components (<tensor>, <expr>)
     Erlaubt die Zuweisung von Werten an die Komponenten eines Tensors
     <tensor>, die mit dem Argument <expr> angegeben werden.  Immer
     wenn der Tensor <tensor> mit all seinen Indizes in einem Ausdruck
     auftritt, werden die Komponenten mit den angegebenen Werten
     substituiert.  Der Tensor muss die Form `t([...],[...])' haben,
     wobei die Listen auch leer sein können.  Das Argument <expr> ist
     irgendein Ausdruck, der dieselben freien Indizes wie der Tensor
     <tensor> hat.  Sollen Werte an einen Metriktensor zugewiesen
     werden, der Dummy-Indizes hat, so muss auf die Benennung der
     Indizes sorgfältig geachtet werden, um das Auftreten von
     Mehrfachen Dummy-Indizes zu vermeiden.  Mit der Funktion `remcomps'
     werden Zuweisungen der Funktion `components' an die Komponenten
     eines Tensors entfernt.

     Es muss beachtet werden, dass die Funktion `components' nur den
     Typ eines Tensors, aber nicht die Ordnung der Indizes beachtet.
     Werden daher Werte an die Komponenten der Tensoren `x([i,-j],[])',
     `x([-j,i],[])' oder `x([i],[j])' zugewiesen, ergibt sich jeweils
     dasselbe Ergebnis.

     Komponenten können einem indizierten Ausdruck auf vier
     verschiedene Methoden zugeordnet werden.  Zwei Methoden nutzen die
     Funktion `components'.

     1) Als ein indizierte Ausdruck:

          (%i2) components(g([],[i,j]), e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Als eine Matrix:

          (%i5) lg:-ident(4)$ lg[1,1]:1$ lg;
                                      [ 1   0    0    0  ]
                                      [                  ]
                                      [ 0  - 1   0    0  ]
          (%o5)                       [                  ]
                                      [ 0   0   - 1   0  ]
                                      [                  ]
                                      [ 0   0    0   - 1 ]

          (%i6) components(g([i,j],[]), lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([1,1],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Als eine Funktion: Die Werte der Komponenten eines Tensors
     werden durch eine Funktion gegeben.

          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Mit Mustern und Regeln: Im Folgenden wird ein Beispiel mit den
     Funktionen `defrule'  und `applyb1'  gezeigt.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n

 -- Funktion: concan (<expr>)
     Ist vergleichbar mit der Funktion `canten'.    Im Unterschied zu
     `canten' werden zusätzlich Tensorverjüngungen ausgeführt.

 -- Funktion: contract (<expr>)
     Führt die Tensorverjüngungen im Ausdruck <expr> aus, die beliebige
     Summen und Produkte sein können.  `contract' nutzt die
     Informationen, die für die Tensoren mit der Funktion `defcon'
     definiert sind.  Die besten Ergebnisse werden erzielt, wenn der
     Ausdruck <expr> vollständig expandiert wird.  Die Funktion
     `radexpand'  expandiert Produkte und Potenzen von Summen am
     schnellsten, sofern keine Variablen im Nenner der Terme auftreten.
     Die Optionsvariable `gcd'  sollte den Wert `false' haben, wenn das
     Kürzen durch einen größten gemeinsamen Teiler nicht notwendig ist.

 -- Systemvariable: contractions
     Die Liste `contractions'  enthält die Tensoren, die mit der
     Funktion `defcon' die Eigenschaft einer Tensorverjüngung erhalten
     haben.

 -- Funktion: defcon (<tensor_1>)
 -- Funktion: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Gibt einem Tensor <tensor_1> die Eigenschaft, dass die
     Tensorverjüngung des Produktes <tensor_1> mit <tensor_2> das
     Ergebnis <tensor_3> hat.  Wird nur ein Argument <tensor_1>
     angegeben, dann hat die Tensorverjüngung für jeden Tensor
     `tensor', der die korrekten Indizes hat, das Ergebnis `tensor' mit
     neuen Indizes, die die Tensorverjüngung widerspiegeln.

     Wird zum Beispiel die Metrik als `imetric: g' gesetzt, dann wird
     mit `defcon(g)' das Hochstellen und Herunterstellen der Indizes
     mit dem Metriktensor definiert.

     Wird `defcon' wiederholt für einen Tensor aufgerufen, ist jeweils
     die letzte Definition wirksam.

     Die Liste `contractions'  enthält die Tensoren, die mit der
     Funktion `defcon' die Eigenschaft einer Tensorverjüngung erhalten
     haben.

 -- Funktion: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Funktion: dispcon (all)
     Zeigt die Kontraktionseigenschaften der Tensoren <tensor_1>,
     <tensor_2>, ... wie sie mit der Funktion `defcon'  definiert
     wurden.  Das Kommando `dispcon(all)' zeigt alle vom Nutzer
     definierten Kontraktionseigenschaften.

     Beispiel:

     Wird das Paket `itensor' geladen, gibt `dispcon' das folgende
     Ergebnis.

          (%i1) load(itensor)$

          (%i2) dispcon(all);
          (%o2)      [[[ifr, ifri, ifg]], [[ifg, ifg, kdelta]]]

 -- Funktion: entertensor (<name>)
     Die Funktion `entertensor' ermöglicht die Eingabe eines indizierten
     Tensors mit einer beliebigen Anzahl an Tensorindizes und
     Ableitungen.  Es kann ein einzelner Index oder eine Liste mit
     Indizes angegeben werden.  Die Liste kann eine leere Liste sein.

     Beispiel:

          (%i1) load(itensor)$

          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the covariant indices: [i,j];
          Enter a list of the contravariant indices: [k];
          Enter a list of the derivative indices: [];
                                         k
          (%t2)                         a
                                         i j

 -- Optionsvariable: flipflag
     Standardwert: `false'

     Hat die Optionsvariable `flipflag' den Wert `false', werden die
     Indizes von der Funktion `rename'  bei der Umbenennung in der
     Reihenfolge der kontravarianten Indizes sortiert, ansonsten in der
     Reihenfolge der kovarianten Indizes.

     Siehe auch das Beispiel für die Funktion `rename'.


 -- Optionsvariable: icounter
     Standardwert: `0'

     Enthält die laufende Nummer, um den nächsten Dummy-Index zu bilden.
     `icounter' wird automatisch erhöht, bevor der neue Index gebildet
     wird.  Dem Wert `icounter' wird er Präfix `idummyx'
     vorangestellt.  Der Standardwert von `idummyx' ist `%'.

 -- Funktion: idummy ()
     Erhöht den Wert der laufenden Nummer `icounter'  und gibt einen
     neuen Index zurück, indem der Präfix `idummyx'  der Nummer
     `icounter' vorangestellt wird.  Siehe auch die Funktion `indices'.


 -- Optionsvariable: idummyx
     Standardwert: `%'

     Enthält den Präfix, der einem neuen Index vorangestellt wird, der
     mit der Funktion `idummy'  gebildet wird.

 -- Funktion: indexed_tensor (<tensor>)
     Muss ausgeführt werden, bevor einem Tensors <tensor> Komponenten
     zugewiesen werden, für die bereits interne Werte vorliegen wie für
     `ichr1',  `ichr2'  oder `icurvature'.    Siehe das Beispiel zur
     Funktion `icurvature'.

 -- Funktion: indices (<expr>)
     Gibt eine Liste mit zwei Elementen zurück.  Das erste Element ist
     eine Liste mit den Indizes im Ausdruck <expr> die frei sind, also
     nur einmal auftreten.  Das zweite Elemente ist eine Liste mit den
     Indizes, über die summiert wird, die also im Ausdruck genau
     zweimal auftreten.

     Ein Tensorprodukt mit einem Index der mehr als zweimal auftritt,
     ist nicht korrekt formuliert.  Die Funktion `indices' gibt in
     einem solchen Fall jedoch keinen Fehler aus.

     Beispiel:

          (%i1) load(itensor)$

          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                   k l      j m p
          (%t2)                   a        b
                                   i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)          [[l, p, i, n, o, q, r], [k, j, m]]

 -- Funktion: ishow (<expr>)
     Zeigt den Ausdruck <expr> an, wobei Tensoren im Ausdruck mit
     tiefgestellten kovarianten Indizes und hochgestellten
     kontravarianten Indizes sowie die Ableitungen mit durch ein Komma
     getrennten tiefgestellte Indizes angezeigt werden.

     Beispiel:

          (%i1) load(itensor)$

          (%i2) ishow(a([i,j], [k], v,w))$
                                       k
          (%t2)                       a
                                       i j,v w

 -- Funktion: kdels (<L1>, <L2>)
     `kdels' gibt wie die Funktion `kdelta'  ein Kronecker-Delta zurück.
     Im Unterschied zu `kdelta' ist das Kronecker-Delta der Funktion
     `kdels' symmetrisch.

     Beispiele:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b

 -- Funktion: kdelta (<L1>, <L2>)
     Ist das verallgemeinerte Kronecker-Delta im `itensor'-Paket.  Das
     Argument <L1> ist die Liste der kovarianten und <L2> der
     kontravarianten Indizes.  `kdelta([i],[j])' gibt das einfache
     Kronecker-Delta zurück.

     Das `itensor'-Paket erlaubt die Definition des Kronecker-Delta nur
     mit kovarianten oder kontravarianten Indizes, wie zum Beispiel
     `kdelta([i,j],[])'.  Mit diesen Größen kann gerechnet werden, sie
     sind jedoch keine Tensoren.

 -- Regel: lc_l
     `lc_l' ist eine Regel, um Ausdrücke zu vereinfachen, die
     Levi-Civita-Symbole enthalten.  Zusammen mit der Regel `lc_u'
     kann die Regel zum Beispiel mit der Funktion `applyb1'  angewendet
     werden, um Ausdrücke effizienter zu vereinfachen, als durch eine
     Auswertung des Symbols `levi_civita'.

     Beispiele:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
          (%t4)                                  0
          (%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
          (%t5)                                  0

 -- Regel: lc_u
     `lc_u' ist eine Regel, um Ausdrücke zu vereinfachen, die
     Levi-Civita-Symbole enthalten.  Zusammen mit der Regel `lc_c' kann
     die Regel zum Beispiel mit der Funktion `applyb1'  angewendet
     werden, um Ausdrücke effizienter zu vereinfachen, als durch eine
     Auswertung des Symbols `levi_civita'.  Siehe `lc_l'  für Beispiele.

 -- Funktion: lc2kdt (<expr>)
     Vereinfacht den Ausdruck <expr> mit Levi-Civita-Symbolen.  Wenn
     möglich werden diese zu Kronecker-Delta-Symbolen vereinfacht.  Im
     Unterschied zu der Auswertung eines Ausdrucks mit
     Levi-Civita-Symbolen, vermeidet die Funktion `lc2kdt' das
     Einführen von numerischen Indizes, die für eine weitere
     symbolische Vereinfachung zum Beispiel mit den Funktionen `rename'
     oder `contract'  nicht geeignet sind.

     Beispiel:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])
                           *'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     Die Funktion `lc2kdt' benötigt in einigen Fällen den Metriktensor.
     Ist der Metriktensor zuvor nicht mit der Funktion `imetric'
     definiert, dann meldet Maxima einen Fehler.

          (%i7) expr:ishow('levi_civita([],[i,j])
                           *'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g
                              %3             %4               %3
                        k
                  kdelta  ) a
                        %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i    l i  j
          (%t11)                           a    - g    a
                                                        j

 -- Funktion: levi_civita (<L>)
     Ist der Levi-Civita-Tensor, der auch Permutationstensor genannt
     wird.  Der Tensor hat den Wert `1', wenn die Liste <L> eine gerade
     Permutation ganzer Zahlen ist, den Wert `-1' für eine ungerade
     Permutation und ansonsten den Wert `0'.

     Beispiel:

     Für eine Kreisbewegung ist die Bahngeschwindigkeit `v' das
     Kreuzprodukt aus Winkelgeschwindigkeit `w' und Ortsvektor `r'.
     Wir haben also `v = w x r'.  Hier wird eine tensorielle
     Schreibweise des Kreuzproduktes mit dem Levi-Civita-Tensor
     eingeführt.  Der Ausdruck wird sodann für die erste Komponente zu
     der bekannten Definition des Kreuzproduktes vereinfacht.

          (%i1) load(itensor)$

          (%i2) ishow(v([],[a])=
                     'levi_civita([],[a,b,c])*w([b],[])*r([c],[]))$
                              a              a b c
          (%t2)              v  = levi_civita      w  r
                                                    b  c
          (%i3) ishow(subst([a=1],%))$
                              1              1 b c
          (%t3)              v  = levi_civita      w  r
                                                    b  c
          (%i4) ishow(ev(%, levi_civita))$
                                1         1 b c
          (%t4)                v  = kdelta      w  r
                                          1 2 3  b  c
          (%i5) ishow(expand(ev(%, kdelta)))$
                  1         b       c               c       b
          (%t5)  v  = kdelta  kdelta  w  r  - kdelta  kdelta  w  r
                            2       3  b  c         2       3  b  c
          (%i6) ishow(contract(%))$
                                  1
          (%t6)                  v  = w  r  - r  w
                                       2  3    2  3

     In diesem Beispiel wird das Spatprodukt von drei Vektoren `a', `b'
     und `b' mit dem Levi-Civita-Tensor definiert und dann vereinfacht.

          (%i1) load(itensor)$

          (%i2) ishow(levi_civita([],[i,j,k])*a([i],[])*b([j],[])*c([k],[]))$
                                      i j k
          (%t2)                 kdelta      a  b  c
                                      1 2 3  i  j  k
          (%i3) ishow(contract(expand(ev(%,kdelta))))$
          (%t3) a  b  c  - b  a  c  - a  c  b  + c  a  b  + b  c  a
                 1  2  3    1  2  3    1  2  3    1  2  3    1  2  3
                                                                 - c  b  a
                                                                    1  2  3

 -- Funktion: listoftens (<expr>)
     Gibt eine Liste mit allen Tensoren zurück, die im Argument <expr>
     enthalten sind.

     Beispiel:

          (%i1) load(itensor)$

          (%i2) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                            k
          (%t2)                 d e c    + a    b
                                     x y    i j  u,v
          (%i3) ishow(listoftens(%))$
                                  k
          (%t3)                 [a   , b   , c   , d]
                                  i j   u,v   x y

 -- Funktion: remcomps (<tensor>)
     Entfernt alle Werte von den Komponenten des Tensors <tensor>, die
     einen Wert mit der Funktion `components'  erhalten haben.

 -- Funktion: remcon (<tensor_1>, ..., <tensor_n>)
 -- Funktion: remcon (all)
     Entfernt die Eigenschaften der Tensorverjüngung von den Tensoren
     <tensor_1>, ..., <tensor_n>.  `remcon(all)' entfernt die
     Eigenschaften von der Tensorverjüngung für alle Tensoren.  Das
     sind die Tensoren, die in der Liste `contractions'  enthalten sind.

 -- Funktion: rename (<expr>)
 -- Funktion: rename (<expr>, <count>)
     Gibt einen zum Argument <expr> äquivalenten Ausdruck zurück, wobei
     die Summationsindizes mit den Werten aus der liste `[%1, %2, ...]'
     umbenannt sind.  Wird das zusätzlich das Argument <count>
     angegeben, wird die Nummerierung mit dem Wert <count> begonnen.
     Jeder Summationsindex in einem Produkt erhält einen verschiedenen
     Namen.  Für eine Summe wird der Zähler für jeden Term
     zurückgesetzt.  Auf diese Weise wirkt die Funktion `rename' wie
     eine Vereinfachung eines tensoriellen Ausdrucks.  Hat die
     Optionsvariable `allsym'  den Wert `true', werden die Indizes
     alphabetisch nach den kovarianten oder kontravarianten Indizes
     geordnet, entsprechend dem Wert der Optionsvariablen `flipflag'.
     Hat die Optionsvariable `flipflag' den Wert `true', werden die
     Indizes entsprechend der Ordnung der kovarianten Indizes geordnet.
     Es ist häufig der Fall, dass das Ordnen sowohl nach den
     kovarianten als auch den kontravarianten Indizes einen Ausdruck
     besser vereinfacht, als allein die Ordnung nach einer der Indizes.

     Beispiele:

          (%i1) load(itensor)$

          (%i2) allsym: true;
          (%o2)                         true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])
                       *ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])
                       *ichr2([%7,r],[%2])
           -g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])
                         *ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])
                         *ichr2([%7,r],[%2])$

          (%i4) expr: ishow(%)$
                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r
                    %4 %5  %6 %7      u          %1         %3         %2
                 - g      g      ichr2      ichr2      ichr2      ichr2
                                      %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag: true;
          (%o5)                         true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r
                    %4 %5  %6 %7      u          %1         %3         %2
                 - g      g      ichr2      ichr2      ichr2      ichr2
                                      %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag: false;
          (%o7)                         false
          (%i8) rename(%th(2));
          (%o8)                           0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7
                    %1 %2  %3 %4      %6         %5         %7        u
                 - g      g      ichr2      ichr2      ichr2     ichr2
                                      %1 %3      %2 %6      %4 r      %5 %7

 -- Funktion: showcomps (<tensor>)
     Zeigt die Zuweisungen mit der Funktion `components'  an die
     Komponenten des Tensors <tensor>.  Die Funktion `showcomps' kann
     auch die Komponenten eines Tensors mit einer höheren Stufe als 2
     zeigen.

     Beispiel:

          (%i1) load(ctensor)$
          (%i2) load(itensor)$
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false


File: maxima.info,  Node: Tensorsymmetrien,  Next: Tensoranalysis,  Prev: Behandlung indizierter Größen,  Up: Funktionen und Variablen für itensor

20.2.2.2 Tensorsymmetrien
.........................

 -- Optionsvariable: allsym
     Standardwert: `false'

     Hat die Optionsvariable `allsym' den Wert `true', werden alle
     indizierten Größen  als symmetrisch in ihren kovarianten und
     kontravarianten Indizes angenommen.  Ist der Wert `false', werden
     keine Symmetrien für die Indizes angenommen.  Die Indizes von
     Ableitungen werden immer als symmetrisch angenommen, außer wenn
     die Optionsvariable `iframe_flag'  den Wert `true' hat.

 -- Funktion: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Definiert Symmetrieeigenschaften für den Tensor <tensor> mit <m>
     kovarianten und <n> kontravarianten Indizes.  Die Argumente
     <cov_i> und <contr_i> geben Symmetrieeigenschaften zwischen den
     kontravarianten und kontravarianten Indizes an.  Die Argumente
     haben die Form `symoper(<index_1>, <index_2, ...>'.  `symoper' ist
     einer der Symmetrieeigenschaften `sym' für symmetrisch, `anti' für
     antisymmetrisch oder `cyc' für zyklisch und die Argumente <index_i>
     sind ganze Zahlen, die die Position des Index im Tensor <tensor>
     angegeben.  Weiterhin ist die Form `symoper(all)' möglich.  In
     diesem Fall wird die entsprechende Symmetrieeigenschaft für alle
     Indizes angenommen.

     Ist zum Beispiel `b' ein Tensor mit 5 kovarianten Indizes, dann
     wird mit `decsym(b, 5, 3, [sym(1,2), anti(3,4)], [cyc(all)])'
     definiert, dass `b' symmetrisch in den Indizes `1' und `2',
     antisymmetrisch in den Indizes `3' und `4' sowie zyklisch in allen
     kontravarianten Indizes ist.

     Symmetrieeigenschaften, die mit der Funktion `decsym' definiert
     werden, werden von der Funktion `canform'  angewendet.

     Beispiele:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract( expand( a([i1, j1, k1], [])
                     *kdels([i, j, k], [i1, j1, k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]

 -- Funktion: remsym (<tensor>, <m>, <n>)
     Entfernt die Symmetrieeigenschaften des Tensors <tensor>, der <m>
     kovariante und <n> kontravariante Indizes hat.

 -- Funktion: canform (<expr>)
 -- Funktion: canform (<expr>, <rename>)
     Vereinfacht den Ausdruck <expr> indem alle Dummy-Indizes umbenannt
     und umgeordnet werden, wobei vorhandene Symmetrieeigenschaften
     angewendet werden.  Hat die Optionsvariable `allsym' den Wert
     `true', werden alle Indizes als symmetrisch angenommen.  Ansonsten
     werden Symmetrieeigenschaften angewendet, die mit der Funktion
     `decsym'  definiert sind.  Die Dummy-Indizes werden auf gleiche
     Weise umbenannt wie von der Funktion `rename'.    Wird `canform'
     auf einen großen Ausdruck angewendet, kann die Ausführung eine
     lange Zeit beanspruchen.  Die Rechenzeit kann verkürzt werden,
     indem zuerst die Funktion `rename' auf den Ausdruck angewendet
     wird.

     `canform' kann einen Ausdruck nicht immer in die einfachste Form
     bringen, jedoch ist das Ergebnis immer mathematisch korrekt.

     Erhält das optionale zweite Argument <rename> den Wert `false',
     wird die Umbenennung mit der Funktion `rename' nicht ausgeführt.

     Für ein Beispiel siehe die Funktion `decsym'.



File: maxima.info,  Node: Tensoranalysis,  Next: Tensoren in gekrümmten Räumen,  Prev: Tensorsymmetrien,  Up: Funktionen und Variablen für itensor

20.2.2.3 Tensoranalysis
.......................

 -- Funktion: diff (<expr>, <v_1>, <n_1>, <v_2>, <n_2>, ...)
     Ist die gleichnamige Funktion `diff'  für die Differentiation einer
     tensoriellen Größe.  `diff' ist für das Paket `itensor' erweitert.
     Die tensorielle Größe <expr> wird <n_1>-mal nach der Variablen
     <v_1>, <n_2> nach der Variablen <v_2>, ...  abgeleitet.  Die
     Argumente `v_1' können ganze Zahlen von `1', ..., `dim'  sein.  In
     diesem Fall bezeichnen die ganzen Zahlen der Reihe nach die
     Indizes, die in der Optionsvariablen `vect_coords'  abgelegt sind.
     `dim' ist die Dimension der tensoriellen Größen.

     Weiterhin erlaubt die erweiterte Funktion `diff' die Berechnung von
     Ableitungen nach indizierten Variablen.  So können Ausdrücke, die
     den Metriktensor und seine Ableitungen enthalten, nach dem
     Metriktensor und seinen Ableitungen abgeleitet werden.

     Beispiele:

          (%i1) load(itensor)$

          (%i2) depends(v,t);
          (%o2)                        [v(t)]
          (%i3) ishow(diff(v([i,j],[k])^2, t,1))$
                                    k    d    k
          (%t3)                  2 v    (-- (v   ))
                                    i j  dt   i j
          (%i4) ishow(diff(v([i,j],[k])^2, t,2))$
                                 2
                           k    d     k          d    k    2
          (%t4)         2 v    (--- (v   )) + 2 (-- (v   ))
                           i j    2   i j        dt   i j
                                dt

 -- Funktion: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     `idiff' führt Ableitungen nach den Koordinaten einer tensoriellen
     Größe aus.  Im Unterschied dazu führt die Funktion `diff'

     Ableitungen nach den unabhängigen Variablen aus.  Eine tensorielle
     Größe erhält zusätzlich den Index <v_1>, der die Ableitung
     bezeichnet.  Mehrfache Indizes für Ableitungen werden sortiert,
     außer wenn die Optionsvariable `iframe_flag'  den Wert `true' hat.

     `idiff' kann auch die Determinante des Metriktensors ableiten.
     Wird zum Beispiel der Optionsvariablen `imetric'  der Wert `g'
     zugewiesen, dann hat das Kommando `idiff(determinant(g), k)' das
     Ergebnis `2 * determinant(g) * ichr2([%i,k], [%i])', wobei die
     Dummy-Variable passend gewählt wird.

 -- Funktion: liediff (<v>, <ten>)
     Berechnet die Lie-Ableitung eines tensoriellen Ausdrucks <ten> für
     das Vektorfeld <v>.  Das Argument <ten> kann irgendeine tensorielle
     Größe sein.  Das Argument <v> ist der Name eines Vektorfeldes und
     wird ohne Indizes angegeben.

     Beispiel:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                    %1  k        %1  k      %1  k
                                + (v   b      - b   v    + v   b   ) a
                                        ,%1 l    ,l  ,%1    ,l  ,%1   i j

 -- Funktion: rediff (<ten>)
     Wertet jedes Auftreten von Substantivformen der Funktion `idiff'
     in dem tensoriellem Ausdruck <ten> aus.

 -- Funktion: undiff (<expr>)
     Gibt einen zum Argument <expr> äquivalenten Ausdruck zurück, in dem
     alle Ableitungen von indizierten Größen durch Substantivformen der
     Funktion `idiff'  ersetzt sind.


 -- Funktion: evundiff (<expr>)
     Ist äquivalent zur Ausführung der Funktion `undiff',  der die
     Funktionen `ev'  und `rediff'  nachfolgen.

     `evundiff' erlaubt die Auswertung von Ausdrücken, die nicht direkt
     in ihrer abgeleiteten Form ausgewertet werden können.  So führt
     das folgende Beispiel zu einer Fehlermeldung:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Wird jedoch `icurvature' in der Substantivform verwendet, kann der
     Ausdruck mit `evundiff' ausgewertet werden:

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                       l              l         %1           l           %1
                + ichr2        + ichr2     ichr2      + ichr2       ichr2
                       i j,k m        %1 k      i j,m        %1 k,m      i j

     Um Christoffel-Symbole abzuleiten, wird die Funktion `evundiff'
     nicht benötigt:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2

 -- Funktion: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Alle tensoriellen Größen <tensor_i> die im Ausdruck <expr>
     auftreten und keine Ableitungen haben, werden zu Null gesetzt.

 -- Funktion: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Alle tensoriellen Größen <tensor_i> die im Ausdruck <expr>
     auftreten und Ableitungen haben, werden zu Null gesetzt.

 -- Funktion: flushnd (<expr>, <tensor>, <n>)
     Setzt alle Ableitungen der tensoriellen Größe <tensor> die im
     Ausdruck <expr> auftritt und <n> oder mehr Ableitungen hat, auf
     den Wert Null.

     Beispiele:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Funktion: coord (<tensor_1>, <tensor_2>, ...)
 -- Systemvariable: coord
     Gibt der tensoriellen Größe <tensor_i> die Eigenschaft, dass die
     kovariante Ableitung eines Vektors mit dem Namen <tensor_i> das
     Ergebnis Kronecker-Delta hat.

     `coord' ist auch eine Systemvariable, die alle tensoriellen Größen
     enthält, die mit der Funktion `coord' die Eigenschaft der
     kovarianten Ableitung erhalten haben.

     Beispiel:

          (%i1) coord(x);
          (%o1)                         done
          (%i2) idiff(x([],[i]),j);
          (%o2)                   kdelta([j], [i])
          (%i3) coord;
          (%o3)                          [x]

 -- Funktion: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Funktion: remcoord (all)
     Entfernt die mit der Funktion `coord'  definierte Eigenschaft für
     die tensoriellen Größen <tensor_i>.  Das Kommando `remcoord(all)'
     entfernt diese Eigenschaft für alle tensoriellen Größen.

 -- Funktion: makebox (<expr>, <name>)
     Zeigt das Argument <expr> auf die gleiche Weise an wie die Funktion
     `ishow'  mit dem Unterschied, dass der dâAlembert-Operator <name>
     im Ausdruck durch `[]' ersetzt wird.

     Beispiel:

          (%i1) makebox(g([],[i,j])*p([m],[n],i,j),g);
          (%o1)                     []p([m], [n])

 -- Funktion: conmetderiv (<expr>, <tensor>)
     Vereinfacht Ausdrücke, die kovariante und kontravariante
     Ableitungen des Metriktensors enthalten.  `conmetderiv' kann zum
     Beispiel die Ableitungen des kontravarianten Metriktensors in
     Beziehung zu den Christoffel-Symbolen setzen:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Funktion: simpmetderiv (<expr>)
 -- Funktion: simpmetderiv (<expr>[, <stop>])
     Vereinfacht Ausdrücke die Produkte von Ableitungen des
     Metriktensors enthalten.  Im besonderen erkennt `simpmetderiv' die
     folgenden Identitäten:

             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     daher ist

             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     und

            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     was aus den Symmetrien der Christoffel-Symbole folgt.

     Die Funktion `simpmetderiv' akzeptiert einen optionalen Parameter
     <stop>.  Ist dieser vorhanden, stoppt die Funktion nach der ersten
     erfolgreichen Substitution in einem Produkt.  `simpmetderiv'
     beachtet ferner die Optionsvariable `flipflag',  welche die
     Ordnung der Indizes kontrolliert.

     Siehe auch `weyl.dem' für Beispiele der Funktionen `simpmetderiv'
     und `conmetderiv',  die die Vereinfachung des Weyl-Tensors zeigen.

     Beispiel:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

 -- Funktion: flush1deriv (<expr>, <tensor>)
     Setzt alle tensoriellen Größen, die genau einen Ableitungsindex
     haben, auf den Wert Null.

 -- Optionsvariable: vect_coords
     Standardwert: `false'

     Tensoren können durch Angabe von ganzen Zahlen nach den einzelnen
     Komponenten abgeleitet werden.  In diesem Fall bezeichnen die
     ganzen Zahlen der Reihe nach die Indizes, die in der
     Optionsvariablen `vect_coords' abgelegt sind.


File: maxima.info,  Node: Tensoren in gekrümmten Räumen,  Next: Begleitende Vielbeine,  Prev: Tensoranalysis,  Up: Funktionen und Variablen für itensor

20.2.2.4 Tensoren in gekrümmten Räumen
......................................

 -- Funktion: imetric (<g>)
 -- Systemvariable: imetric
     Spezifiziert die Metrik, indem der Variablen `imetric' der Wert `g'
     zugewiesen wird.  Die Eigenschaften für die Verjüngung von
     Tensoren werden mit den Kommandos `defcon(<g>)' und `defcon(<g>,
     <g>, kdelta)' initialisiert.

 -- Funktion: idim (<n>)
     Die Funktion `idim' setzt die Dimension der Metrik zu <n>.  Die
     Variable `dim' auf den Wert <n> gesetzt und die antisymmetrischen
     Eigenschaften des Levi-Civita-Symbols für die Dimension <n> werden
     initialisiert.

 -- Funktion: ichr1 ([<i>, <j>, <k>])
     Gibt das Christoffel-Symbol der ersten Art zurück, das definiert
     ist als

                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k

     Um das Christoffel-Symbol für eine spezielle Metrik auszuwerten,
     muss der Optionsvariablen `imetric'  ein Wert zugewiesen werden.
     Siehe dazu das Beispiel zu `ichr2'.


 -- Funktion: ichr2 ([<i>, <j>], [<k>])
     Gibt das Christoffel-Symbol der zweiten Art zurück, das definiert
     ist als

                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Funktion: icurvature ([<i>, <j>, <k>], [<h>])
     Gibt den Riemannschen Krümmungstensor in einer Darstellung mit
     Christoffel-Symbolen zurück:

                      h             h            h         %1         h
            icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                      i j k         i k,j        %1 j      i k        i j,k
                                      h          %1
                               + ichr2      ichr2
                                      %1 k       i j

 -- Funktion: covdiff (<expr>, <v_1>, <v_2>, ...)
     Gibt die kovariante Ableitung des Ausdruck <expr> nach den
     Variablen <v_i> in einer Darstellung mit Christoffel-Symbolen der
     zweiten Art `ichr2'  zurück.  Um den erhaltenen Ausdruck
     auszuwerten, kann das Kommando `ev(<expr>, ichr2)'.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the covariant indices: [i,j];
          Enter a list of the contravariant indices: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k
          (%t3)     - a     ichr2    - a     ichr2    + a
                       i %1      j s    %1 j      i s    i j,s

                       k     %1
                + ichr2     a
                       %1 s  i j
          (%i4) imetric:g;
          (%o4)                                  g
          (%i5) ishow(ev(%th(2),ichr2))$
                   %1 %4  k
                  g      a     (g       - g       + g      )
                          i %1   s %4,j    j s,%4    j %4,s
          (%t5) - ------------------------------------------
                                      2
              %1 %3  k
             g      a     (g       - g       + g      )
                     %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                                 2
              k %2  %1
             g     a    (g        - g        + g       )
                    i j   s %2,%1    %1 s,%2    %1 %2,s     k
           + ------------------------------------------- + a
                                  2                         i j,s
          (%i6)

 -- Funktion: lorentz_gauge (<expr>)
     Wendet die Lorenz-Eichung an, indem alle indizierten Größen in
     <expr> zu Null gesetzt werden, die einen zu einem kontravarianten
     Index identischen Ableitungsindex haben.

 -- Funktion: igeodesic_coords (<expr>, <name>)
     Bewirkt, dass nicht abgeleitete Christoffel-Symbole und erste
     Ableitungen des Metriktensors im Ausdruck <expr> verschwinden.
     Das Argument <name> bezeichnet die Metrik <name>, wenn im Ausdruck
     <expr> vorhanden und die Christoffel-Symbole werden mit <ichr1>
     und <ichr2> bezeichnet.

     Beispiele:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u
          (%t2) - ichr2      - ichr2     ichr2    + ichr2
                       r t,s        %1 s      r t        r s,t

                                                        u         %1
                                                 + ichr2     ichr2
                                                        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t

                                                       u            u
                                                - ichr2      + ichr2
                                                       r t,s        r s,t
          (%i5) canform(%);
          (%o5)                                  0


File: maxima.info,  Node: Begleitende Vielbeine,  Next: Torsion und Nichtmetrizität,  Prev: Tensoren in gekrümmten Räumen,  Up: Funktionen und Variablen für itensor

20.2.2.5 Begleitende Vielbeine
..............................

Maxima now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary
frame.

To use frames, you must first set `iframe_flag' to `true'.  This causes
the Christoffel-symbols, `ichr1' and `ichr2', to be replaced by the
more general frame connection coefficients `icc1' and `icc2' in
calculations.  Speficially, the behavior of `covdiff' and `icurvature'
is changed.

The frame is defined by two tensors: the inverse frame field (`ifri',
the dual basis tetrad), and the frame metric `ifg'.  The frame metric
is the identity matrix for orthonormal frames, or the Lorentz metric
for orthonormal frames in Minkowski spacetime.  The inverse frame field
defines the frame base (unit vectors).  Contraction properties are
defined for the frame field and the frame metric.

When `iframe_flag' is true, many `itensor' expressions use the frame
metric `ifg' instead of the metric defined by `imetric' for raising and
lowerind indices.

IMPORTANT: Setting the variable `iframe_flag' to `true' does NOT
undefine the contraction properties of a metric defined by a call to
`defcon' or `imetric'.  If a frame field is used, it is best to define
the metric by assigning its name to the variable `imetric' and NOT
invoke the `imetric' function.

Maxima uses these two tensors to define the frame coefficients (`ifc1'
and `ifc2') which form part of the connection coefficients (`icc1' and
`icc2'), as the following example demonstrates:

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                                    %1     i       i
     (%t4)                         v   ifc2     + v
                                           %1 j    ,j
     (%i5) ishow(ev(%,ifc2))$
                               %1    i %2                i
     (%t5)                    v   ifg     ifc1        + v
                                              %1 j %2    ,j
     (%i6) ishow(ev(%,ifc1))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t6)      -------------------------------------------------- + v
                                        2                             ,j
     (%i7) ishow(ifb([a,b,c]))$
                                                        %3    %4
     (%t7)               (ifri        - ifri       ) ifr   ifr
                              a %3,%4       a %4,%3     b     c

An alternate method is used to compute the frame bracket (`ifb') if the
`iframe_bracket_form' flag is set to `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                     %6    %5        %5      %6
     (%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                            a %5     b     c,%6      b,%6    c

 -- Optionsvariable: iframe_flag
     Standardwert: `false'

     To use frames, you must first set `iframe_flag' to `true'.  This
     causes the Christoffel-symbols, `ichr1' and `ichr2', to be replaced
     by the more general frame connection coefficients `icc1' and `icc2'
     in calculations.  Speficially, the behavior of `covdiff' and
     `icurvature' is changed.

     The frame is defined by two tensors: the inverse frame field
     (`ifri', the dual basis tetrad), and the frame metric `ifg'.  The
     frame metric is the identity matrix for orthonormal frames, or the
     Lorentz metric for orthonormal frames in Minkowski spacetime.  The
     inverse frame field defines the frame base (unit vectors).
     Contraction properties are defined for the frame field and the
     frame metric.

     When `iframe_flag' is true, many `itensor' expressions use the
     frame metric `ifg' instead of the metric defined by `imetric' for
     raising and lowerind indices.

     IMPORTANT: Setting the variable `iframe_flag' to `true' does NOT
     undefine the contraction properties of a metric defined by a call
     to `defcon' or `imetric'.  If a frame field is used, it is best to
     define the metric by assigning its name to the variable `imetric'
     and NOT invoke the `imetric' function.

 -- Function: iframes ()
     Since in this version of Maxima, contraction identities for `ifr'
     and `ifri' are always defined, as is the frame bracket (`ifb'),
     this function does nothing.

 -- Variable: ifb
     The frame bracket.  The contribution of the frame metric to the
     connection coefficients is expressed using the frame bracket:

                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     The frame bracket itself is defined in terms of the frame field
     and frame metric.  Two alternate methods of computation are used
     depending on the value of `frame_bracket_form'.  If true (the
     default) or if the `itorsion_flag' is `true':

                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:

                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d

 -- Variable: icc1
     Connection coefficients of the first kind.  In `itensor', defined
     as

          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     In this expression, if `iframe_flag' is true, the
     Christoffel-symbol `ichr1' is replaced with the frame connection
     coefficient `ifc1'.  If `itorsion_flag' is `false', `ikt1' will be
     omitted.  It is also omitted if a frame base is used, as the
     torsion is already calculated as part of the frame bracket.
     Lastly, of `inonmet_flag' is `false', `inmc1' will not be present.

 -- Variable: icc2
     Connection coefficients of the second kind.  In `itensor', defined
     as

              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     In this expression, if `iframe_flag' is true, the
     Christoffel-symbol `ichr2' is replaced with the frame connection
     coefficient `ifc2'.  If `itorsion_flag' is `false', `ikt2' will be
     omitted.  It is also omitted if a frame base is used, as the
     torsion is already calculated as part of the frame bracket.
     Lastly, of `inonmet_flag' is `false', `inmc2' will not be present.

 -- Variable: ifc1
     Frame coefficient of the first kind (also known as Ricci-rotation
     coefficients.) This tensor represents the contribution of the
     frame metric to the connection coefficient of the first kind.
     Defined as:

                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2

 -- Variable: ifc2
     Frame coefficient of the first kind.  This tensor represents the
     contribution of the frame metric to the connection coefficient of
     the first kind.  Defined as a permutation of the frame bracket
     (`ifb') with the appropriate indices raised and lowered as
     necessary:

              c       cd
          ifc2   = ifg   ifc1
              ab             abd

 -- Variable: ifr
     The frame field.  Contracts with the inverse frame field (`ifri')
     to form the frame metric (`ifg').

 -- Variable: ifri
     The inverse frame field.  Specifies the frame base (dual basis
     vectors).  Along with the frame metric, it forms the basis of all
     calculations based on frames.

 -- Variable: ifg
     The frame metric.  Defaults to `kdelta', but can be changed using
     `components'.

 -- Variable: ifgi
     The inverse frame metric.  Contracts with the frame metric (`ifg')
     to `kdelta'.

 -- Option variable: iframe_bracket_form
     Default value: `true'

     Specifies how the frame bracket (`ifb') is computed.


File: maxima.info,  Node: Torsion und Nichtmetrizität,  Next: Graßmann-Algebra,  Prev: Begleitende Vielbeine,  Up: Funktionen und Variablen für itensor

20.2.2.6 Torsion und Nichtmetrizität
....................................

Maxima can now take into account torsion and nonmetricity.  When the
flag `itorsion_flag' is set to `true', the contribution of torsion is
added to the connection coefficients.  Similarly, when the flag
`inonmet_flag' is true, nonmetricity components are included.

 -- Variable: inm
     The nonmetricity vector. Conformal nonmetricity is defined through
     the covariant derivative of the metric tensor. Normally zero, the
     metric tensor's covariant derivative will evaluate to the
     following when `inonmet_flag' is set to `true':

          g     =- g  inm
           ij;k     ij   k

 -- Variable: inmc1
     Covariant permutation of the nonmetricity vector components.
     Defined as

                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitute `ifg' in place of `g' if a frame metric is used.)

 -- Variable: inmc2
     Contravariant permutation of the nonmetricity vector components.
     Used in the connection coefficients if `inonmet_flag' is `true'.
     Defined as:

                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitute `ifg' in place of `g' if a frame metric is used.)

 -- Variable: ikt1
     Covariant permutation of the torsion tensor (also known as
     contorsion).  Defined as:

                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitute `ifg' in place of `g' if a frame metric is used.)

 -- Variable: ikt2
     Contravariant permutation of the torsion tensor (also known as
     contorsion).  Defined as:

              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitute `ifg' in place of `g' if a frame metric is used.)

 -- Variable: itr
     The torsion tensor. For a metric with torsion, repeated covariant
     differentiation on a scalar function will not commute, as
     demonstrated by the following example:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff( covdiff( f( [], []), i), j)
                                - covdiff( covdiff( f( [], []), j), i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff( covdiff( f( [], []), i), j)
                                - covdiff( covdiff( f( [], []), j), i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


File: maxima.info,  Node: Graßmann-Algebra,  Next: Exportiere als TeX,  Prev: Torsion und Nichtmetrizität,  Up: Funktionen und Variablen für itensor

20.2.2.7 Graßmann-Algebra
.........................

The `itensor' package can perform operations on totally antisymmetric
covariant tensor fields. A totally antisymmetric tensor field of rank
(0,L) corresponds with a differential L-form. On these objects, a
multiplication operation known as the exterior product, or wedge
product, is defined.

Unfortunately, not all authors agree on the definition of the wedge
product. Some authors prefer a definition that corresponds with the
notion of antisymmetrization: in these works, the wedge product of two
vector fields, for instance, would be defined as

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

More generally, the product of a p-form and a q-form would be defined as

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

where `D' stands for the Kronecker-delta.

Other authors, however, prefer a "geometric" definition that corresponds
with the notion of the volume element:

     a  /\ a  = a a  - a a
      i     j    i j    j i

and, in the general case

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

Since `itensor' is a tensor algebra package, the first of these two
definitions appears to be the more natural one. Many applications,
however, utilize the second definition. To resolve this dilemma, a flag
has been implemented that controls the behavior of the wedge product: if
`igeowedge_flag' is `false' (the default), the first, "tensorial"
definition is used, otherwise the second, "geometric" definition will
be applied.

 -- Operator: ~
     The wedge product operator is denoted by the tilde `~'. This is a
     binary operator. Its arguments should be expressions involving
     scalars, covariant tensors of rank one, or covariant tensors of
     rank `l' that have been declared antisymmetric in all covariant
     indices.

     The behavior of the wedge product operator is controlled by the
     `igeowedge_flag' flag, as in the following example:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j

 -- Operator: |
     The vertical bar `|' denotes the "contraction with a vector" binary
     operation. When a totally antisymmetric covariant tensor is
     contracted with a contravariant vector, the result is the same
     regardless which index was used for the contraction. Thus, it is
     possible to define the contraction operation in an index-free
     manner.

     In the `itensor' package, contraction with a vector is always
     carried out with respect to the first index in the literal sorting
     order. This ensures better simplification of expressions involving
     the `|' operator. For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note that it is essential that the tensors used with the `|'
     operator be declared totally antisymmetric in their covariant
     indices. Otherwise, the results will be incorrect.

 -- Function: extdiff (<expr>, <i>)
     Computes the exterior derivative of <expr> with respect to the
     index <i>. The exterior derivative is formally defined as the wedge
     product of the partial derivative operator and a differential
     form. As such, this operation is also controlled by the setting of
     `igeowedge_flag'.  For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                    - (a      - a      + a     )
                                       k j,i    k i,j    j i,k

 -- Function: hodge (<expr>)
     Compute the Hodge-dual of <expr>. For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g
                                                               %1 %106
                                       g        g        g      A         /6
                                        %2 %107  %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108

 -- Option variable: igeowedge_flag
     Default value: `false'

     Controls the behavior of the wedge product and exterior
     derivative. When set to `false' (the default), the notion of
     differential forms will correspond with that of a totally
     antisymmetric covariant tensor field.  When set to `true',
     differential forms will agree with the notion of the volume
     element.


File: maxima.info,  Node: Exportiere als TeX,  Next: Schnittstelle zum Paket ctensor,  Prev: Graßmann-Algebra,  Up: Funktionen und Variablen für itensor

20.2.2.8 Exportiere als TeX
...........................

The `itensor' package provides limited support for exporting tensor
expressions to TeX. Since `itensor' expressions appear as function
calls, the regular Maxima `tex' command will not produce the expected
output. You can try instead the `tentex' command, which attempts to
translate tensor expressions into appropriately indexed TeX objects.

 -- Function: tentex (<expr>)
     To use the `tentex' function, you must first load `tentex', as in
     the following example:

          (%i1) load(itensor)$
          (%i2) load(tentex)$
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
                      j k      m1 l        j l      m1 k        j l,k

                                                                i
                                                         + ichr2
                                                                j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note the use of the `idummyx' assignment, to avoid the appearance
     of the percent sign in the TeX expression, which may lead to
     compile errors.

     NB: This version of the `tentex' function is somewhat experimental.


File: maxima.info,  Node: Schnittstelle zum Paket ctensor,  Next: Reservierte Bezeichner,  Prev: Exportiere als TeX,  Up: Funktionen und Variablen für itensor

20.2.2.9 Schnittstelle zum Paket CTENSOR
........................................

Das Paket `itensor' ermöglicht die Generierung von Maxima-Code, der im
Kontext des Paketes `ctensor' ausgeführt werden kann.  Die Funktion
`ic_convert'  erzeugt den Maxima-Code.

 -- Funktion: ic_convert (<eqn>)
     Konvertiert eine `itensor'-Gleichung <eqn> in einen
     `ctensor'-Ausdruck.  Implizite Summen über Dummy-Indizes werden
     explizit ausgeführt und indizierte Größen werden in Arrays
     umgewandelt.  Die Indizes der Arrays sind in der Reihenfolge der
     kovarianten und dann der kontravarianten Indizes der indizierte
     Größe.  Die Ableitung einer indizierten Größe wird durch die
     Substantivform der Ableitung `diff'  nach der Variablen `ct_coords'
     ersetzt, die den Index der Ableitung erhält.  Die
     Christoffel-Symbole `ichr1'  und `ichr2'

     werden zu den Funktionen `lcs' und `mcs' transformiert.  Hat
     `metricconvert' den Wert `true', dann wird der Metriktensor mit
     zwei kovarianten Indizes durch `lg'  und mit zwei kontravarianten
     Indizes durch `ug'  ersetzt.  Weiterhin werden `do'-Schleifen für
     die Summation über die freien Indizes eingeführt.

     Beispiele:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
                *b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim do (
                 for k thru dim do
                  t        : f sum(sum(diff(a , ct_coords ) b
                   i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim do (
                 for k thru dim do
                  t        : f sum(sum(diff(a , ct_coords ) b
                   i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


File: maxima.info,  Node: Reservierte Bezeichner,  Prev: Schnittstelle zum Paket ctensor,  Up: Funktionen und Variablen für itensor

20.2.2.10 Reservierte Bezeichner
................................

Die folgenden Maxima Bezeichner werden im Paket `itensor' intern genutzt
und sollten vom Nutzer nicht umdefiniert werden.

       Keyword    Comments
       ------------------------------------------
       indices2() Internal version of indices()
       conti      Lists contravariant indices
       covi       Lists covariant indices of a indexed object
       deri       Lists derivative indices of an indexed object
       name       Returns the name of an indexed object
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: Paket ctensor,  Next: Paket atensor,  Prev: Paket itensor,  Up: Tensoren

20.3 Paket CTENSOR
==================

* Menu:

* Einführung in ctensor::
* Funktionen und Variablen für ctensor::


File: maxima.info,  Node: Einführung in ctensor,  Next: Funktionen und Variablen für ctensor,  Prev: Paket ctensor,  Up: Paket ctensor

20.3.1 Einführung in CTENSOR
----------------------------

`ctensor' ist ein Paket, um mit den Komponenten eines Tensors zu
rechnen.  Das Paket wird mit dem Kommando `load(ctensor)' geladen.  Zu
Beginn muss das Paket mit dem Kommando `csetup'  initialisiert werden.
Als erstes wird die Anzahl der Dimensionen angegeben.  Werden `2', `3'
oder `4' Dimensionen angegeben, dann erhalten die Koordinaten
standardmäßig die Bezeichnungen `[x,y]', `[x,y,z]' oder `[x,y,z,t]'.
Diese Bezeichnungen können geändert werden, indem der Optionsvariablen
`ct_coords'  eine neue Liste mit den gewünschten Bezeichnungen
zugewiesen wird.

Danach wird eine Metrik eingegeben oder aus einer Datei geladen.  Die
Metrik wird in der Matrix `lg'  gespeichert.  Maxima berechnet die
inverse der Metrik und speichert diese in der Matrix `ug'  ab.  Maxima
bietet die Option an, alle Rechnungen in einer Reihenentwicklung
auszuführen.

Die folgende Sitzung zeigt ein Beispiel für die Initialisierung einer
sphärischen, symmetrischen Metrik, wie sie zum Beispiel im Falle der
Einsteinschen Vakuumgleichen verwendet wird.

Beispiel:

     (%i1) load(ctensor);
     (%o1)      /share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Funktionen und Variablen für ctensor,  Prev: Einführung in ctensor,  Up: Paket ctensor

20.3.2 Funktionen und Variablen für CTENSOR
-------------------------------------------

20.3.2.1 Initialisierung
........................

 -- Funktion: csetup ()
     Mit der Funktion `csetup' wird das Paket `ctensor' initialisiert.
     Vom Nutzer werden die Angaben zu einer Metrik abgefragt.  Für ein
     Beispiel siehe *note Einführung in ctensor::.

 -- Funktion: cmetric (<dis>)
 -- Funktion: cmetric ()
     Die Funktion `cmetric' berechnet die inverse der Metrik und führt
     weitere Initialisierungen für die Rechnung mit Tensoren aus.

     Hat die Optionsvariable `cframe_flag'  den Wert `false', wird die
     inverse Metrik mit der vom Nutzer angegebenen Metrik berechnet,
     die in der Matrix `lg'  enthalten ist, und in der Matrix `ug'
     abgespeichert.  Die Determinante der Metrik wird in der Variablen
     `gdet'  abgelegt.  Ist die Metrik diagonal wird die Variable
     `diagmetric'  entsprechend gesetzt.  Hat das optionale Argument
     <dis> einen von `false' verschiedenen Wert wird die inverse Metrik
     ausgegeben.

     Hat die Optionsvariable `cframe_flag'  den Wert `true', erwartet
     `cmetric', dass die Matrizen `lfg'  für die Metrik des bewegten
     Bezugssystems und `fri' für die inverse dieser Metrik definiert
     sind.  Mit diesen Matrizen berechnet `cmetric' dann die Werte der
     Matrizen `fr' und die inverse `ufg'.


 -- Function: ct_coordsys (<coordinate_system>, <extra_arg>)
 -- Function: ct_coordsys (<coordinate_system>)
     Sets up a predefined coordinate system and metric. The argument
     <coordinate_system> can be one of the following symbols:

           SYMBOL             Dim Coordinates     Description/comments
           ------------------------------------------------------------------
           cartesian2d           2  [x,y]             Cartesian 2D coordinate
                                                      system
           polar                 2  [r,phi]           Polar coordinate system
           elliptic              2  [u,v]             Elliptic coord. system
           confocalelliptic      2  [u,v]             Confocal elliptic
                                                      coordinates
           bipolar               2  [u,v]             Bipolar coord. system
           parabolic             2  [u,v]             Parabolic coord. system
           cartesian3d           3  [x,y,z]           Cartesian 3D coordinate
                                                      system
           polarcylindrical      3  [r,theta,z]       Polar 2D with
                                                      cylindrical z
           ellipticcylindrical   3  [u,v,z]           Elliptic 2D with
                                                      cylindrical z
           confocalellipsoidal   3  [u,v,w]           Confocal ellipsoidal
           bipolarcylindrical    3  [u,v,z]           Bipolar 2D with
                                                      cylindrical z
           paraboliccylindrical  3  [u,v,z]           Parabolic 2D with
                                                      cylindrical z
           paraboloidal          3  [u,v,phi]         Paraboloidal coords.
           conical               3  [u,v,w]           Conical coordinates
           toroidal              3  [u,v,phi]         Toroidal coordinates
           spherical             3  [r,theta,phi]     Spherical coord. system
           oblatespheroidal      3  [u,v,phi]         Oblate spheroidal
                                                      coordinates
           oblatespheroidalsqrt  3  [u,v,phi]
           prolatespheroidal     3  [u,v,phi]         Prolate spheroidal
                                                      coordinates
           prolatespheroidalsqrt 3  [u,v,phi]
           ellipsoidal           3  [r,theta,phi]     Ellipsoidal coordinates
           cartesian4d           4  [x,y,z,t]         Cartesian 4D coordinate
                                                      system
           spherical4d           4  [r,theta,eta,phi] Spherical 4D coordinate
                                                      system
           exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild metric
           interiorschwarzschild 4  [t,z,u,v]         Interior Schwarzschild
                                                      metric
           kerr_newman           4  [t,r,theta,phi]   Charged axially
                                                      symmetric metric

     `coordinate_system' can also be a list of transformation functions,
     followed by a list containing the coordinate variables. For
     instance, you can specify a spherical metric as follows:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                             r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Transformation functions can also be used when `cframe_flag' is
     `true':

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
          (%o4)
           [cos(phi)cos(theta) -cos(phi) r sin(theta) -sin(phi) r cos(theta)]
           [                                                                ]
           [sin(phi)cos(theta) -sin(phi) r sin(theta)  cos(phi) r cos(theta)]
           [                                                                ]
           [    sin(theta)           r cos(theta)                0          ]

          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     The optional argument <extra_arg> can be any one of the following:

     `cylindrical' tells `ct_coordsys' to attach an additional
     cylindrical coordinate.

     `minkowski' tells `ct_coordsys' to attach an additional coordinate
     with negative metric signature.

     `all' tells `ct_coordsys' to call `cmetric' and `christof(false)'
     after setting up the metric.

     If the global variable `verbose' is set to `true', `ct_coordsys'
     displays the values of `dim', `ct_coords', and either `lg' or
     `lfg' and `fri', depending on the value of `cframe_flag'.

 -- Function: init_ctensor ()
     Initializes the `ctensor' package.

     The `init_ctensor' function reinitializes the `ctensor' package. It
     removes all arrays and matrices used by `ctensor', resets all
     flags, resets `dim' to 4, and resets the frame metric to the
     Lorentz-frame.

20.3.2.2 The tensors of curved space
....................................

The main purpose of the `ctensor' package is to compute the tensors of
curved space(time), most notably the tensors used in general relativity.

When a metric base is used, `ctensor' can compute the following tensors:

      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

`ctensor' can also work using moving frames. When `cframe_flag' is set
to `true', the following tensors can be calculated:

      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Function: christof (<dis>)
     A function in the `ctensor' (component tensor) package.  It
     computes the Christoffel symbols of both kinds.  The argument
     <dis> determines which results are to be immediately displayed.
     The Christoffel symbols of the first and second kinds are stored
     in the arrays `lcs[i,j,k]' and `mcs[i,j,k]' respectively and
     defined to be symmetric in the first two indices.  If the argument
     to `christof' is `lcs' or `mcs' then the unique non-zero values of
     `lcs[i,j,k]' or `mcs[i,j,k]', respectively, will be displayed. If
     the argument is `all' then the unique non-zero values of
     `lcs[i,j,k]' and `mcs[i,j,k]' will be displayed.  If the argument
     is `false' then the display of the elements will not occur.  The
     array elements `mcs[i,j,k]' are defined in such a manner that the
     final index is contravariant.

 -- Function: ricci (<dis>)
     A function in the `ctensor' (component tensor) package. `ricci'
     computes the covariant (symmetric) components `ric[i,j]' of the
     Ricci tensor.  If the argument <dis> is `true', then the non-zero
     components are displayed.

 -- Function: uricci (<dis>)
     This function first computes the covariant components `ric[i,j]'
     of the Ricci tensor.  Then the mixed Ricci tensor is computed
     using the contravariant metric tensor.  If the value of the
     argument <dis> is `true', then these mixed components, `uric[i,j]'
     (the index `i' is covariant and the index `j' is contravariant),
     will be displayed directly.  Otherwise, `ricci(false)' will simply
     compute the entries of the array `uric[i,j]' without displaying
     the results.

 -- Function: scurvature ()
     Returns the scalar curvature (obtained by contracting the Ricci
     tensor) of the Riemannian manifold with the given metric.

 -- Function: einstein (<dis>)
     A function in the `ctensor' (component tensor) package.  `einstein'
     computes the mixed Einstein tensor after the Christoffel symbols
     and Ricci tensor have been obtained (with the functions `christof'
     and `ricci').  If the argument <dis> is `true', then the non-zero
     values of the mixed Einstein tensor `ein[i,j]' will be displayed
     where `j' is the contravariant index.  The variable `rateinstein'
     will cause the rational simplification on these components. If
     `ratfac' is `true' then the components will also be factored.

 -- Function: leinstein (<dis>)
     Covariant Einstein-tensor.  `leinstein' stores the values of the
     covariant Einstein tensor in the array `lein'.  The covariant
     Einstein-tensor is computed from the mixed Einstein tensor `ein'
     by multiplying it with the metric tensor.  If the argument <dis>
     is `true', then the non-zero values of the covariant Einstein
     tensor are displayed.

 -- Function: riemann (<dis>)
     A function in the `ctensor' (component tensor) package.  `riemann'
     computes the Riemann curvature tensor from the given metric and
     the corresponding Christoffel symbols. The following index
     conventions are used:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     This notation is consistent with the notation used by the `itensor'
     package and its `icurvature' function.  If the optional argument
     <dis> is `true', the non-zero components `riem[i,j,k,l]' will be
     displayed.  As with the Einstein tensor, various switches set by
     the user control the simplification of the components of the
     Riemann tensor.  If `ratriemann' is `true', then rational
     simplification will be done. If `ratfac' is `true' then each of
     the components will also be factored.

     If the variable `cframe_flag' is `false', the Riemann tensor is
     computed directly from the Christoffel-symbols. If `cframe_flag' is
     `true', the covariant Riemann-tensor is computed first from the
     frame field coefficients.

 -- Function: lriemann (<dis>)
     Covariant Riemann-tensor (`lriem[]').

     Computes the covariant Riemann-tensor as the array `lriem'. If the
     argument <dis> is `true', unique nonzero values are displayed.

     If the variable `cframe_flag' is `true', the covariant Riemann
     tensor is computed directly from the frame field coefficients.
     Otherwise, the (3,1) Riemann tensor is computed first.

     For information on index ordering, see `riemann'.

 -- Function: uriemann (<dis>)
     Computes the contravariant components of the Riemann curvature
     tensor as array elements `uriem[i,j,k,l]'.  These are displayed if
     <dis> is `true'.

 -- Function: rinvariant ()
     Forms the Kretchmann-invariant (`kinvariant') obtained by
     contracting the tensors

          lriem[i,j,k,l]*uriem[i,j,k,l].

     This object is not automatically simplified since it can be very
     large.

 -- Function: weyl (<dis>)
     Computes the Weyl conformal tensor.  If the argument <dis> is
     `true', the non-zero components `weyl[i,j,k,l]' will be displayed
     to the user.  Otherwise, these components will simply be computed
     and stored.  If the switch `ratweyl' is set to `true', then the
     components will be rationally simplified; if `ratfac' is `true'
     then the results will be factored as well.

20.3.2.3 Taylor series expansion
................................

The `ctensor' package has the ability to truncate results by assuming
that they are Taylor-series approximations. This behavior is controlled
by the `ctayswitch' variable; when set to true, `ctensor' makes use
internally of the function `ctaylor' when simplifying results.

The `ctaylor' function is invoked by the following `ctensor' functions:

         Function     Comments
         ---------------------------------
         christof()   For mcs only
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Function: ctaylor ()
     The `ctaylor' function truncates its argument by converting it to
     a Taylor-series using `taylor', and then calling `ratdisrep'. This
     has the combined effect of dropping terms higher order in the
     expansion variable `ctayvar'. The order of terms that should be
     dropped is defined by `ctaypov'; the point around which the series
     expansion is carried out is specified in `ctaypt'.

     As an example, consider a simple metric that is a perturbation of
     the Minkowski metric. Without further restrictions, even a diagonal
     metric produces expressions for the Einstein tensor that are far
     too complex:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],
                          [0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                [ h11 l - 1      0          0                 0            ]
                [                                                          ]
                [     0      h22 l + 1      0                 0            ]
                [                                                          ]
          (%o8) [                        2                                 ]
                [     0          0      r  + h33 l            0            ]
                [                                                          ]
                [                                    2    2                ]
                [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     However, if we recompute this example as an approximation that is
     linear in the variable `l', we get much simpler expressions:

          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                      2               2      4    2
                        - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                 r r                r

     This capability can be useful, for instance, when working in the
     weak field limit far from a gravitational source.

20.3.2.4 Frame fields
.....................

 -- Optionsvariable: cframe_flag
     Standardwert: `false'

     When the variable `cframe_flag' is set to true, the `ctensor'
     package performs its calculations using a moving frame.

 -- Function: frame_bracket (<fr>, <fri>, <diagframe>)
     The frame bracket (`fb[]').

     Computes the frame bracket according to the following definition:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b

20.3.2.5 Algebraic classification
.................................

A new feature (as of November, 2004) of `ctensor' is its ability to
compute the Petrov classification of a 4-dimensional spacetime metric.
For a demonstration of this capability, see the file
`share/tensor/petrov.dem'.

 -- Function: nptetrad ()
     Computes a Newman-Penrose null tetrad (`np') and its raised-index
     counterpart (`npi'). See `petrov' for an example.

     The null tetrad is constructed on the assumption that a
     four-diemensional orthonormal frame metric with metric signature
     (-,+,+,+) is being used.  The components of the null tetrad are
     related to the inverse frame matrix as follows:

          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4

 -- Function: psi (<dis>)
     Computes the five Newman-Penrose coefficients `psi[0]'...`psi[4]'.
     If `psi' is set to `true', the coefficients are displayed.  See
     `petrov' for an example.

     These coefficients are computed from the Weyl-tensor in a
     coordinate base.  If a frame base is used, the Weyl-tensor is
     first converted to a coordinate base, which can be a
     computationally expensive procedure. For this reason, in some
     cases it may be more advantageous to use a coordinate base in the
     first place before the Weyl tensor is computed. Note however, that
     constructing a Newman-Penrose null tetrad requires a frame base.
     Therefore, a meaningful computation sequence may begin with a
     frame base, which is then used to compute `lg' (computed
     automatically by `cmetric' and then `ug'. At this point, you can
     switch back to a coordinate base by setting `cframe_flag' to false
     before beginning to compute the Christoffel symbols. Changing to a
     frame base at a later stage could yield inconsistent results, as
     you may end up with a mixed bag of tensors, some computed in a
     frame base, some in a coordinate base, with no means to
     distinguish between the two.

 -- Function: petrov ()
     Computes the Petrov classification of the metric characterized by
     `psi[0]' ... `psi[4]'.

     For example, the following demonstrates how to obtain the
     Petrov-classification of the Kerr metric:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

          [ sqrt(r - 2 m)           sqrt(r)                                 ]
          [---------------   ---------------------    0            0        ]
          [sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                          ]
          [                                                                 ]
          [ sqrt(r - 2 m)            sqrt(r)                                ]
          [---------------  - ---------------------   0            0        ]
          [sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                         ]
          [                                                                 ]
          [                                          r      %i r sin(theta) ]
          [       0                    0          -------   --------------- ]
          [                                       sqrt(2)       sqrt(2)     ]
          [                                                                 ]
          [                                          r       %i r sin(theta)]
          [       0                    0          -------  - ---------------]
          [                                       sqrt(2)        sqrt(2)    ]

                                       sqrt(r)         sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------,---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m) sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     The Petrov classification function is based on the algorithm
     published in "Classifying geometries in general relativity: III
     Classification in practice" by Pollney, Skea, and d'Inverno,
     Class. Quant. Grav. 17 2885-2902 (2000).  Except for some simple
     test cases, the implementation is untested as of December 19,
     2004, and is likely to contain errors.

20.3.2.6 Torsion and nonmetricity
.................................

`ctensor' has the ability to compute and include torsion and
nonmetricity coefficients in the connection coefficients.

The torsion coefficients are calculated from a user-supplied tensor
`tr', which should be a rank (2,1) tensor. From this, the torsion
coefficients `kt' are computed according to the following formulae:

                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

Note that only the mixed-index tensor is calculated and stored in the
array `kt'.

The nonmetricity coefficients are calculated from the user-supplied
nonmetricity vector `nm'. From this, the nonmetricity coefficients
`nmc' are computed as follows:

                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

where D stands for the Kronecker-delta.

When `ctorsion_flag' is set to `true', the values of `kt' are
substracted from the mixed-indexed connection coefficients computed by
`christof' and stored in `mcs'. Similarly, if `cnonmet_flag' is set to
`true', the values of `nmc' are substracted from the mixed-indexed
connection coefficients.

If necessary, `christof' calls the functions `contortion' and
`nonmetricity' in order to compute `kt' and `nm'.

 -- Function: contortion (<tr>)
     Computes the (2,1) contortion coefficients from the torsion tensor
     <tr>.

 -- Function: nonmetricity (<nm>)
     Computes the (2,1) nonmetricity coefficients from the nonmetricity
     vector <nm>.

20.3.2.7 Miscellaneous features
...............................

 -- Function: ctransform (<M>)
     A function in the `ctensor' (component tensor) package which will
     perform a coordinate transformation upon an arbitrary square
     symmetric matrix <M>. The user must input the functions which
     define the transformation.  (Formerly called `transform'.)

 -- Function: findde (<A>, <n>)
     returns a list of the unique differential equations (expressions)
     corresponding to the elements of the <n> dimensional square array
     <A>. Presently, <n> may be 2 or 3. `deindex' is a global list
     containing the indices of <A> corresponding to these unique
     differential equations. For the Einstein tensor (`ein'), which is
     a two dimensional array, if computed for the metric in the example
     below, `findde' gives the following independent differential
     equations:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a, 0, 0, 0], [ 0, x^2, 0, 0],
                                        [0, 0, x^2*sin(y)^2, 0], [0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x
                  x                     x x         x        x    x

                                                        2          2
                                    + 2 a d d   - 2 a  d , a  x + a  - a]
                                             x       x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]

 -- Function: cograd ()
     Computes the covariant gradient of a scalar function allowing the
     user to choose the corresponding vector name as the example under
     `contragrad' illustrates.

 -- Function: contragrad ()
     Computes the contravariant gradient of a scalar function allowing
     the user to choose the corresponding vector name as the example
     below for the Schwarzschild metric illustrates:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r

 -- Function: dscalar ()
     computes the tensor d'Alembertian of the scalar function once
     dependencies have been declared upon the function. For example:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r

 -- Function: checkdiv ()
     computes the covariant divergence of the mixed second rank tensor
     (whose first index must be covariant) by printing the
     corresponding n components of the vector field (the divergence)
     where n = `dim'. If the argument to the function is `g' then the
     divergence of the Einstein tensor will be formed and must be zero.
     In addition, the divergence (vector) is given the array name `div'.

 -- Function: cgeodesic (<dis>)
     A function in the `ctensor' (component tensor) package.
     `cgeodesic' computes the geodesic equations of motion for a given
     metric.  They are stored in the array `geod[i]'.  If the argument
     <dis> is `true' then these equations are displayed.

 -- Function: bdvac (<f>)
     generates the covariant components of the vacuum field equations of
     the Brans- Dicke gravitational theory. The scalar field is
     specified by the argument <f>, which should be a (quoted) function
     name with functional dependencies, e.g., `'p(x)'.

     The components of the second rank covariant field tensor are
     represented by the array `bd'.

 -- Function: invariant1 ()
     generates the mixed Euler- Lagrange tensor (field equations) for
     the invariant density of R^2. The field equations are the
     components of an array named `inv1'.

 -- Function: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     generates the mixed Euler- Lagrange tensor (field equations) for
     the invariant density of `ric[i,j]*uriem[i,j]'. The field
     equations are the components of an array named `inv2'.

 -- Function: bimetric ()
     *** NOT YET IMPLEMENTED ***

     generates the field equations of Rosen's bimetric theory. The field
     equations are the components of an array named `rosen'.

20.3.2.8 Utility functions
..........................

 -- Function: diagmatrixp (<M>)
     Returns `true' if <M> is a diagonal matrix or (2D) array.

 -- Function: symmetricp (<M>)
     Returns `true' if <M> is a symmetric matrix or (2D) array.

 -- Function: ntermst (<f>)
     gives the user a quick picture of the "size" of the doubly
     subscripted tensor (array) <f>.  It prints two element lists where
     the second element corresponds to NTERMS of the components
     specified by the first elements.  In this way, it is possible to
     quickly find the non-zero expressions and attempt simplification.

 -- Function: cdisplay (<ten>)
     displays all the elements of the tensor <ten>, as represented by a
     multidimensional array. Tensors of rank 0 and 1, as well as other
     types of variables, are displayed as with `ldisplay'. Tensors of
     rank 2 are displayed as 2-dimensional matrices, while tensors of
     higher rank are displayed as a list of 2-dimensional matrices. For
     instance, the Riemann-tensor of the Schwarzschild metric can be
     viewed as:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                    [ 0               0                   0           0     ]
                    [                                                       ]
                    [                              2                        ]
                    [      3 m (r - 2 m)   m    2 m                         ]
                    [ 0  - ------------- + -- - ----      0           0     ]
                    [            4          3     4                         ]
                    [           r          r     r                          ]
                    [                                                       ]
          riem    = [                                m (r - 2 m)            ]
              1, 1  [ 0               0              -----------      0     ]
                    [                                     4                 ]
                    [                                    r                  ]
                    [                                                       ]
                    [                                           m (r - 2 m) ]
                    [ 0               0                   0     ----------- ]
                    [                                                4      ]
                    [                                               r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                       [     2 m                                         ]
                       [ ------------  0        0               0        ]
                       [  2                                              ]
                       [ r  (r - 2 m)                                    ]
                       [                                                 ]
                       [      0        0        0               0        ]
                       [                                                 ]
            riem     = [                         m                       ]
                2, 2   [      0        0  - ------------        0        ]
                       [                     2                           ]
                       [                    r  (r - 2 m)                 ]
                       [                                                 ]
                       [                                         m       ]
                       [      0        0        0         - ------------ ]
                       [                                     2           ]
                       [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                     [        2                                             ]
                     [   m sin (theta)                                      ]
                     [ - -------------         0                0         0 ]
                     [         r                                            ]
                     [                                                      ]
                     [                         2                            ]
                     [                    m sin (theta)                     ]
          riem     = [        0         - -------------         0         0 ]
              4, 4   [                          r                           ]
                     [                                                      ]
                     [                                          2           ]
                     [                                   2 m sin (theta)    ]
                     [        0                0         ---------------  0 ]
                     [                                          r           ]
                     [                                                      ]
                     [        0                0                0         0 ]

          (%o5)                                done

 -- Function: deleten (<L>, <n>)
     Returns a new list consisting of <L> with the <n>'th element
     deleted.

20.3.2.9 Variables used by `ctensor'
....................................

 -- Option variable: dim
     Default value: 4

     An option in the `ctensor' (component tensor) package.  `dim' is
     the dimension of the manifold with the default 4. The command
     `dim: n' will reset the dimension to any other value `n'.

 -- Option variable: diagmetric
     Default value: `false'

     An option in the `ctensor' (component tensor) package.  If
     `diagmetric' is `true' special routines compute all geometrical
     objects (which contain the metric tensor explicitly) by taking
     into consideration the diagonality of the metric. Reduced run
     times will, of course, result. Note: this option is set
     automatically by `csetup' if a diagonal metric is specified.

 -- Option variable: ctrgsimp
     Causes trigonometric simplifications to be used when tensors are
     computed.  Presently, `ctrgsimp' affects only computations
     involving a moving frame.

 -- Option variable: cframe_flag
     Causes computations to be performed relative to a moving frame as
     opposed to a holonomic metric. The frame is defined by the inverse
     frame array `fri' and the frame metric `lfg'. For computations
     using a Cartesian frame, `lfg' should be the unit matrix of the
     appropriate dimension; for computations in a Lorentz frame, `lfg'
     should have the appropriate signature.

 -- Option variable: ctorsion_flag
     Causes the contortion tensor to be included in the computation of
     the connection coefficients. The contortion tensor itself is
     computed by `contortion' from the user-supplied tensor `tr'.

 -- Option variable: cnonmet_flag
     Causes the nonmetricity coefficients to be included in the
     computation of the connection coefficients. The nonmetricity
     coefficients are computed from the user-supplied nonmetricity
     vector `nm' by the function `nonmetricity'.

 -- Option variable: ctayswitch
     If set to `true', causes some `ctensor' computations to be carried
     out using Taylor-series expansions. Presently, `christof', `ricci',
     `uricci', `einstein', and `weyl' take into account this setting.

 -- Option variable: ctayvar
     Variable used for Taylor-series expansion if `ctayswitch' is set to
     `true'.

 -- Option variable: ctaypov
     Maximum power used in Taylor-series expansion when `ctayswitch' is
     set to `true'.

 -- Option variable: ctaypt
     Point around which Taylor-series expansion is carried out when
     `ctayswitch' is set to `true'.

 -- System variable: gdet
     The determinant of the metric tensor `lg'. Computed by `cmetric'
     when `cframe_flag' is set to `false'.

 -- Option variable: ratchristof
     Causes rational simplification to be applied by `christof'.

 -- Option variable: rateinstein
     Default value: `true'

     If `true' rational simplification will be performed on the
     non-zero components of Einstein tensors; if `ratfac' is `true'
     then the components will also be factored.

 -- Option variable: ratriemann
     Default value: `true'

     One of the switches which controls simplification of Riemann
     tensors; if `true', then rational simplification will be done; if
     `ratfac' is `true' then each of the components will also be
     factored.

 -- Option variable: ratweyl
     Default value: `true'

     If `true', this switch causes the `weyl' function to apply
     rational simplification to the values of the Weyl tensor. If
     `ratfac' is `true', then the components will also be factored.

 -- Variable: lfg
     The covariant frame metric. By default, it is initialized to the
     4-dimensional Lorentz frame with signature (+,+,+,-). Used when
     `cframe_flag' is `true'.

 -- Variable: ufg
     The inverse frame metric. Computed from `lfg' when `cmetric' is
     called while `cframe_flag' is set to `true'.

 -- Variable: riem
     The (3,1) Riemann tensor. Computed when the function `riemann' is
     invoked.  For information about index ordering, see the
     description of `riemann'.

     If `cframe_flag' is `true', `riem' is computed from the covariant
     Riemann-tensor `lriem'.

 -- Variable: lriem
     The covariant Riemann tensor. Computed by `lriemann'.

 -- Variable: uriem
     The contravariant Riemann tensor. Computed by `uriemann'.

 -- Variable: ric
     The mixed Ricci-tensor. Computed by `ricci'.

 -- Variable: uric
     The contravariant Ricci-tensor. Computed by `uricci'.

 -- Variable: lg
     The metric tensor. This tensor must be specified (as a `dim' by
     `dim' matrix) before other computations can be performed.

 -- Variable: ug
     The inverse of the metric tensor. Computed by `cmetric'.

 -- Variable: weyl
     The Weyl tensor. Computed by `weyl'.

 -- Variable: fb
     Frame bracket coefficients, as computed by `frame_bracket'.

 -- Variable: kinvariant
     The Kretchmann invariant. Computed by `rinvariant'.

 -- Variable: np
     A Newman-Penrose null tetrad. Computed by `nptetrad'.

 -- Variable: npi
     The raised-index Newman-Penrose null tetrad. Computed by
     `nptetrad'.  Defined as `ug.np'. The product `np.transpose(npi)'
     is constant:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]

 -- Variable: tr
     User-supplied rank-3 tensor representing torsion. Used by
     `contortion'.

 -- Variable: kt
     The contortion tensor, computed from `tr' by `contortion'.

 -- Variable: nm
     User-supplied nonmetricity vector. Used by `nonmetricity'.

 -- Variable: nmc
     The nonmetricity coefficients, computed from `nm' by
     `nonmetricity'.

 -- System variable: tensorkill
     Variable indicating if the tensor package has been initialized.
     Set and used by `csetup', reset by `init_ctensor'.

 -- Option variable: ct_coords
     Default value: `[]'

     An option in the `ctensor' (component tensor) package.
     `ct_coords' contains a list of coordinates.  While normally
     defined when the function `csetup' is called, one may redefine the
     coordinates with the assignment `ct_coords: [j1, j2, ..., jn]'
     where the j's are the new coordinate names.  See also `csetup'.

20.3.2.10 Reserved names
........................

The following names are used internally by the `ctensor' package and
should not be redefined:

       Name         Description
       ---------------------------------------------------------------------
       _lg()        Evaluates to lfg if frame metric used, lg otherwise
       _ug()        Evaluates to ufg if frame metric used, ug otherwise
       cleanup()    Removes items drom the deindex list
       contract4()  Used by psi()
       filemet()    Used by csetup() when reading the metric from a file
       findde1()    Used by findde()
       findde2()    Used by findde()
       findde3()    Used by findde()
       kdelt()      Kronecker-delta (not generalized)
       newmet()     Used by csetup() for setting up a metric interactively
       setflags()   Used by init_ctensor()
       readvalue()
       resimp()
       sermet()     Used by csetup() for entering a metric as Taylor-series
       txyzsum()
       tmetric()    Frame metric, used by cmetric() when cframe_flag:true
       triemann()   Riemann-tensor in frame base, used when cframe_flag:true
       tricci()     Ricci-tensor in frame base, used when cframe_flag:true
       trrc()       Ricci rotation coefficients, used by christof()
       yesp()

20.3.2.11 Changes
.................

In November, 2004, the `ctensor' package was extensively rewritten.
Many functions and variables have been renamed in order to make the
package compatible with the commercial version of Macsyma.

       New Name     Old Name        Description
       ---------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
       lgeod[]      EM              Geodesic equations
       ein[]        G[]             Mixed Einstein-tensor
       ric[]        LR[]            Mixed Ricci-tensor
       ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
       ctaypov      MINP            Maximum power in Taylor-series expansion
       cgeodesic()  MOTION          Compute geodesic equations
       ct_coords    OMEGA           Metric coordinates
       ctayvar      PARAM           Taylor-series expansion variable
       lriem[]      R[]             Covariant Riemann-tensor
       uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
       ratriemann   RATRIEMAN       Rational simplif. of the Riemann-tensor
       uric[]       RICCI[]         Contravariant Ricci-tensor
       uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
       cmetric()    SETMETRIC()     Set up the metric
       ctaypt       TAYPT           Point for Taylor-series expansion
       ctayswitch   TAYSWITCH       Taylor-series setting switch
       csetup()     TSETUP()        Start interactive setup session
       ctransform() TTRANSFORM()    Interactive coordinate transformation
       uriem[]      UR[]            Contravariant Riemann-tensor
       weyl[]       W[]             (3,1) Weyl-tensor


File: maxima.info,  Node: Paket atensor,  Prev: Paket ctensor,  Up: Tensoren

20.4 Paket ATENSOR
==================

* Menu:

* Einführung in atensor::
* Funktionen und Variablen für atensor::


File: maxima.info,  Node: Einführung in atensor,  Next: Funktionen und Variablen für atensor,  Prev: Paket atensor,  Up: Paket atensor

20.4.1 Einführung in ATENSOR
----------------------------

Das Paket `atensor' erlaubt das algebraische Rechnen mit Tensoren.  Mit
dem Kommando `load(atensor)' wird das Paket geladen.  Um das Paket zu
initialisieren, wird die Funktion `init_atensor'  ausgeführt.

Im wesentlichen enthält das Paket `atensor' Regeln für die
Vereinfachung von Ausdrücken mit dem `dot-Operator'  Operator `"."'.
`atensor' kennt verschiedene Algebren.  Mit der Funktion `init_atensor'
werden die Regeln einer Algebra initialisiert.

Um die Möglichkeiten des Paketes `atensor' zu zeigen, wird im Folgenden
die Algebra der Quaternionen als eine Clifford-Algebra Cl(0,2) mit zwei
Basisvektoren definiert.  Die drei imaginären Einheiten `i', `j' und
`k' werden durch die zwei Vektoren `v[1]' und `v[2]' sowie das Produkt
`v[1] . v[2]' dargestellt:

         i = v     j = v     k = v  . v
              1         2         1    2

Das Paket `atensor' hat eine vordefinierte Algebra der Quaternionen.
Hier wird die Algebra der Quaterinonen als Clifford-Algebra Cl(0,2)
definiert und die Multiplikationstabelle der Basisvektoren konstruiert.

     (%i1) load(atensor)$

     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                         done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                          - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                          - 1
     (%i5) q:zeromatrix(4,4);
                              [ 0  0  0  0 ]
                              [            ]
                              [ 0  0  0  0 ]
     (%o5)                    [            ]
                              [ 0  0  0  0 ]
                              [            ]
                              [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                           1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                         done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                        v  . v
                                   1    2
     (%i9) for i from 2 thru 4 do
               for j from 2 thru 4 do
                   q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                         done
     (%i10) q;
                 [    1        v         v      v  . v  ]
                 [              1         2      1    2 ]
                 [                                      ]
                 [   v         - 1     v  . v    - v    ]
                 [    1                 1    2      2   ]
     (%o10)      [                                      ]
                 [   v      - v  . v     - 1      v     ]
                 [    2        1    2              1    ]
                 [                                      ]
                 [ v  . v      v        - v       - 1   ]
                 [  1    2      2          1            ]

Indizierte Symbole mit dem Namen, der in der Optionsvariablen `asymbol'

abgelegt ist, werden von `atensor' als Basisvektoren erkannt.  Dabei
läuft der Index von `1' bis `adim'.    Für indizierte Symbole werden
die Bilinearformen `sf',  `af'  und `av'  ausgewertet.  Die Auswertung
ersetzt die Bilinearform `fun(v[i].v[j])', durch das Matrixelement
`aform[i,j]', wobei `v' einen Basisvektor bezeichnet und `fun' einer
der Bilinearformen `sf' oder `af' ist.  Ist `fun' die Bilinearform
`av', dann wird `v[aform[i,j]]' für `av(v[i],v[j])' substituiert.
Siehe auch die Optionsvariable `aform'.

Die Bilinearformen `sf', `af' und `av' können vom Nutzer neu definiert
werden, um eine gewünschte Algebra zu definieren.

Wird das Paket `atensor' geladen, werden die folgenden Schalter auf die
angegebenen Werte gesetzt:

     dotscrules  : true
     dotdistrib  : true
     dotexptsimp : false

Wird das symbolische Rechnen in einer nicht-assoziativen Algebra
gewünscht, kann auch noch der Schalter `dotassoc'  auf den Wert `false'
gesetzt werden.  In diesem Fall kann jedoch die Funktion `atensimp'
nicht immer eine gewünschte Vereinfachung erzielen.


File: maxima.info,  Node: Funktionen und Variablen für atensor,  Prev: Einführung in atensor,  Up: Paket atensor

20.4.2 Funktionen und Variablen für ATENSOR
-------------------------------------------

 -- Funktion: init_atensor (<alg_type>, <opt_dims>)
 -- Funktion: init_atensor (<alg_type>)
     Initialisiert das Paket `atensor' mit der angegebenen Algebra
     <alg_type>.  Das Argument <alg_type> kann einen der folgenden
     Werte haben:

    `universal'
          Eine allgemeine Algebra, für die keine Vertauschungsregeln
          definiert sind.

    `grassmann'
          Eine Graßmann-Algebra, für die die Vertauschungsregel `u.v +
          v.u = 0' definiert ist.

    `clifford'
          Eine Clifford-Algebra, die durch die Vertauschungsregel `u.v
          + v.u = -2*sf(u,v)' definiert ist.  Die Bilinearform `sf'
          ist eine symmetrische Funktion, die einen skalaren Wert als
          Ergebnis hat.  Das Argument <opt_dims> kann bis zu drei
          positive ganze Zahlen sein, die die positiven, entarteten und
          negativen Dimensionen der Algebra bezeichnen.  Die Dimension
          `adim'  und die Matrix `aform'  werden entsprechend der
          angegebenen Argumente <opt_dims> initialisiert.  Sind keine
          Argumente <opt_dims> vorhanden, wird die Dimension `adim' zu
          Null initialisiert und keine Matrix `aform' definiert.

    `symmetric'
          Eine symmetrische Algebra, die durch die Vertauschungsregel
          `u.v - v.u = 0' definiert ist.

    `symplectic'
          Eine symplektische Algebra, die durch die Vertauschungsregel
          `u.v - v.u = 2*af(u,v)' definiert ist.  Die Bilinearform `af'
          ist eine antisymmetrische Funktion, die einen skalaren Wert
          als Ergebnis hat.  Das Argument <opt_dims> kann bis zu zwei
          positive ganze Zahlen enthalten, die die nicht-degenerierten
          und degenerierten Dimensionen der Algebra bezeichnen.  Die
          Dimension `adim'  und die Matrix `aform'

          werden entsprechend der angegebenen Argumente <opt_dims>
          initialisiert.  Sind keine Argumente <opt_dims> vorhanden,
          wird die Dimension `adim' zu Null initialisiert und keine
          Matrix `aform' definiert.

    `lie_envelop'
          Eine einhüllende Lie-Algebra, die durch die Vertauschungsregel
          `u.v - v.u = 2*av(u,v)' definiert ist, wobei die Bilinearform
          `av'

          eine antisymmetrische Funktion ist.  Das Argument <opt_dims>
          kann eine positive ganze Zahl sein, welche die Dimension der
          Lie-Algebra angibt.  Die Dimension `adim'  und die Matrix
          `aform'  werden entsprechend des Argumentes <opt_dims>
          initialisiert.  Ist kein Argument <opt_dims> vorhanden, wird
          die Dimension `adim' zu Null initialisiert und keine Matrix
          `aform' definiert.

     Die Funktion `init_atensor' kennt weiterhin einige vordefinierte
     Algebren:

    `complex'
          Die Algebra der komplexen Zahlen, die als eine
          Clifford-Algebra Cl(0,1) definiert wird.  Das Kommando
          `init_atensor(complex)' ist äquivalent zum Kommando
          `init_atensor(clifford, 0, 0, 1)'.

    `quaternion'
          Die Algebra der Quaternionen, die als eine Clifford-Algebra
          vom Typ Cl(0,2) definiert wird.  Das Kommando
          `init_atensor(quaternion)' ist äquivalent zum Kommando
          `init_atensor(clifford, 0, 0, 2)'.

    `pauli'
          Die Algebra der Pauli-Matrizen, die als eine Clifford-Algebra
          Cl(3,0) definiert wird.  Das Kommando `init_atensor(pauli)'
          ist äquivalent zum Kommando `init_atensor(clifford, 3)'.

    `dirac'
          Die Algebra der Dirac-Matrizen, die als eine Clifford-Algebra
          Cl(3,0,1) definiert wird.  Das Kommando `init_atensor(dirac)'
          ist äquivalent zum Kommando `init_atensor(clifford, 3, 0, 1)'.

 -- Funktion: atensimp (<expr>)
     Vereinfacht einen Ausdruck <expr> entsprechend der Regeln für die
     Algebra, die mit der Funktion `init_atensor'  festgelegt ist.  Die
     Regeln werden rekursiv auf den Ausdruck angewendet.  Dabei werden
     auch Bilinearformen `sf',  `af'  und `av'  ausgewertet.

     Beispiele:

     Die folgenden Beispiele zeigen das Rechnen mit der Algebra der
     Quaternionen.

          (%i1) load(atensor)$

          (%i2) init_atensor(quaternion);
          (%o2)                         done
          (%i3) atensimp(v[1].v[1]);
          (%o3)                          - 1
          (%i4) atensimp(v[2].v[2]);
          (%o4)                          - 1
          (%i5) atensimp((v[1].v[2]) . (v[1].v[2]));
          (%o5)                          - 1
          (%i6) expand((2*v[1]+3*v[2])^^2);
          (%o6) 9 (v  . v ) + 6 (v  . v ) + 6 (v  . v ) + 4 (v  . v )
                    2    2        2    1        1    2        1    1
          (%i7) atensimp(%);
          (%o7)                         - 13

 -- Optionsvariable: alg_type
     Standardwert: `universal'

     Der Typ der Algebra, die bei der Vereinfachung von Ausdrücken mit
     der Funktion `atensimp'  angewendet wird.  Die Algebra wird von
     der Funktion `init_atensor' initialisiert.  Mögliche Algebren sind
     `universal', `grassmann', `clifford', `symmetric', `symplectic' und
     `lie_envelop'.  Siehe für eine ausführliche Erläuterung der
     Algebren die Funktion `init_atensor'.


 -- Optionsvariable: adim
     Standardwert: `0'

     Die Dimension der Algebra, die bei der Vereinfachung von
     Ausdrücken mit der Funktion `atensimp'  angewendet wird.  Die
     Dimension wird von der Funktion `init_atensor'  initialisiert.
     Ein indiziertes Symbol mit dem Bezeichner `asymbol'  ist dann ein
     Basisvektor, wenn der Index kleiner oder gleich der Dimension
     `adim' ist.

     Beispiel:

     Die Dirac-Algebra hat die Dimension `4' und `v[4]' ist ein
     Basisvektor.

          (%i1) load(atensor)$

          (%i2) init_atensor(dirac);
          (%o2)                         done
          (%i3) adim;
          (%o3)                           4
          (%i4) abasep(v[4]);
          (%o4)                         true

 -- Optionsvariable: aform
     Standardwert: `ident(3)'

     Matrix mit den Werten der Bilinearformen `sf',  `af'  und `av'.
     Der Standardwert ist die dreidimensionale Einheitsmatrix.

     Beispiel:

     Das Beispiel zeigt die Matrix `aform' für eine Lie-Algebra mit drei
     Dimensionen und die Ergebnisse der Bilinearform `av' für diese
     Algebra.

          (%i1) load(atensor)$

          (%i2) init_atensor(lie_envelop, 3);
          (%o2)                         done
          (%i3) aform;
                                  [  0    3   - 2 ]
                                  [               ]
          (%o3)                   [ - 3   0    1  ]
                                  [               ]
                                  [  2   - 1   0  ]
          (%i4) av(v[1], v[2]);
          (%o4)                          v
                                          3
          (%i5) av(v[1], v[3]);
          (%o5)                         - v
                                           2

 -- Optionsvariable: asymbol
     Standardwert: `v'

     Enthält das Symbol, das einen Basisvektor des Paketes `atensor'
     bezeichnet.  Mit der Funktion `abasep'  kann getestet werde, ob ein
     indiziertes Symbol einen Basisvektor der Algebra bezeichnet.

     Beispiel:

     In diesem Beispiel wird `asymbol' auf den Wert `x' gesetzt.

          (%i1) load(atensor)$

          (%i2) init_atensor(symmetric, 2);
          (%o2)                         done
          (%i3) asymbol;
          (%o3)                           v
          (%i4) abasep(v[2]);
          (%o4)                         true
          (%i5) asymbol: x;
          (%o5)                           x
          (%i6) abasep(x[2]);
          (%o6)                         true

 -- Funktion: sf (<u>, <v>)
     Eine symmetrische Bilinearform, die bei der Vereinfachung von
     Ausdrücken mit der Funktion `atensimp'  angewendet wird.  Die
     Funktion kann vom Nutzer durch eine neue Funktion ersetzt werden.
     Die Standardimplementation prüft mit der Funktion `abasep',  ob
     die Argumente <u> und <v> Basisvektoren sind und setzt für diesen
     Fall den entsprechen Wert der Matrix `aform'  ein.

 -- Funktion: af (<u>, <v>)
     Eine antisymmetrische Bilinearform, die bei der Vereinfachung von
     Ausdrücken mit der Funktion `atensimp'  angewendet wird.  Die
     Funktion kann vom Nutzer durch eine neue Funktion ersetzt werden.
     Die Standardimplementation prüft mit der Funktion `abasep',  ob
     die Argumente <u> und <v> Basisvektoren sind und setzt für diesen
     Fall den entsprechenden Wert der Matrix `aform'  ein.

 -- Funktion: av (<u>, <v>)
     Eine antisymmetrische Bilinearform, die bei der Vereinfachung von
     Ausdrücken mit der Funktion `atensimp'  angewendet wird.  Die
     Funktion kann vom Nutzer durch eine neue Funktion ersetzt werden.
     Die Standardimplementation prüft mit der Funktion `abasep',  ob
     die Argumente <u> und <v> Basisvektoren sind und setzt für diesen
     Fall den entsprechenden Wert `v[aform[i,j]]' der Matrix `aform'
     ein.

     Beispiel:

          (%i1) load(atensor)$
          (%i2) adim: 3;
          (%o2)                           3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                  [  0    3   - 2 ]
                                  [               ]
          (%o3)                   [ - 3   0    1  ]
                                  [               ]
                                  [  2   - 1   0  ]
          (%i4) asymbol: x;
          (%o4)                           x
          (%i5) av(x[1], x[2]);
          (%o5)                          x
                                          3
          (%i6) av(x[1], x[3]);
          (%o6)                         - x
                                           2

 -- Funktion: abasep (<v>)
     Prüft, ob das Argument <v> ein Basisvektor ist.  Ein Basisvektor
     ist ein indiziertes Symbol mit dem Symbol `asymbol'  als
     Bezeichner und einem Index im Bereich von `1' bis `adim'.

     Beispiel:

          (%i1) load(atensor)$
          (%i2) asymbol: x$
          (%i3) adim:3$
          (%i4) abasep(x[1]);
          (%o4)                         true
          (%i5) abasep(x[3]);
          (%o5)                         true
          (%i6) abasep(x[4]);
          (%o6)                         false


File: maxima.info,  Node: Zahlentheorie,  Next: Spezielle Funktionen,  Prev: Tensoren,  Up: Top

21 Zahlentheorie
****************

* Menu:

* Funktionen und Variablen der Zahlentheorie::


File: maxima.info,  Node: Funktionen und Variablen der Zahlentheorie,  Prev: Zahlentheorie,  Up: Zahlentheorie

21.1 Funktionen und Variablen der Zahlentheorie
===============================================

 -- Funktion: bern (<n>)
     Gibt die <n>-te Bernoulli-Zahl der ganzen Zahl <n> zurück. Hat die
     Optionsvariable `zerobern' den Wert `false', werden
     Bernoulli-Zahlen unterdrückt, die Null sind.

     Siehe auch `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798

 -- Funktion: bernpoly (<x>, <n>)
     Gibt das <n>-te Bernoulli-Polynom in der Variablen <x> zurück.

 -- Function: bfzeta (<s>, <n>)
     Die Riemannsche Zeta-Funktion für das Argument <s>, die wie folgt
     definiert ist:

                           inf
                           ====
                           \     1
               zeta(s) =    >    --
                           /      s
                           ====  k
                           k = 1

     `bfzeta' gibt einen Wert als große Gleitkommazahl zurück.  Die
     Anzahl der Stellen wird durch das Argument <n> angegeben.

     Anstatt der Funktion `bfzeta' ist die Funktion `zeta'  zu
     bevorzugen, die sowohl für reelle und komplexe Gleitkommazahlen
     und Gleitkommazahlen mit eine beliebigen Genauigkeit die
     Riemannsche Zeta-Funktion berechnen kann.

 -- Funktion: bfhzeta (<s>, <h>, <n>)
     Die Hurwitzsche Zeta-Funktion für die Argumente <s> und <h>, die
     wie folgt definiert ist:

                                  inf
                                  ====
                                  \        1
                   zeta (s,h)  =   >    --------
                                  /            s
                                  ====  (k + h)
                                  k = 0

     `bfhzeta' gibt einen Wert als große Gleitkommazahl zurück.  Die
     Anzahl der Stellen wird durch das Argument <n> angegeben.


 -- Funktion: burn (<n>)
     Gibt eine rational Zahl zurück, die eine Näherung für die <n>-te
     Bernoulli Zahl für die ganze Zahl <n> ist.  `burn' berechnet eine
     Näherung als große Gleitkommatzahl mit der folgenden Beziehung:

                             n - 1  1 - 2 n
                        (- 1)      2        zeta(2 n) (2 n)!
               B(2 n) = ------------------------------------
                                          2 n
                                       %pi

     `burn' kann effizienter als die Funktion `bern' für große,
     einzelne ganze Zahlen <n> sein, da `bern' zunächst alle Bernoulli
     Zahlen bis <n> berechnet.  `burn' ruft für ungerade ganze Zahlen
     und Zahlen die kleiner oder gleich 255 die Funktion `bern' auf.

     Das Kommando `load(bffac)' lädt die Funktion.  Siehe auch `bern'.


 -- Funktion: chinese ([<r_1>, ..., <r_n>], [<m_1>, ..., <m_n>])
     Löst die simultanen Kongruenzen `x = r_1 mod m_1', ..., `x = r_n
     mod m_n'.  Die Reste <r_n> und die Moduli <m_n> müssen ganze
     Zahlen sein, die Moduli zusätzlich positiv und paarweise
     teilerfremd.

          (%i1) mods : [1000, 1001, 1003, 1007];
          (%o1)                   [1000, 1001, 1003, 1007]
          (%i2) lreduce('gcd, mods);
          (%o2)                               1
          (%i3) x : random(apply("*", mods));
          (%o3)                         685124877004
          (%i4) rems : map(lambda([z], mod(x, z)), mods);
          (%o4)                       [4, 568, 54, 624]
          (%i5) chinese(rems, mods);
          (%o5)                         685124877004
          (%i6) chinese([1, 2], [3, n]);
          (%o6)                    chinese([1, 2], [3, n])
          (%i7) %, n = 4;
          (%o7)                              10

 -- Funktion: divsum (<n>, <k>)
 -- Funktion: divsum (<n>)
     `divsum(<n>, <k>)' potenziert die Teiler des Argumentes <n> mit
     dem Argument <k> und gibt die Summe als Ergebnis zurück.

     `divsum(<n>)' gibt die Summe der Teiler der Zahl <n> zurück.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210

 -- Funktion: euler (<n>)
     Gibt die <n>-te Eulersche Zahl für eine nichtnegative ganze Zahl
     <n> zurück.

     Für die Euler-Mascheroni Konstante siehe `%gamma'.

     Beispiele:

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]

 -- Funktion: fib (<n>)
     Gibt die <n-te> Fibonacci-Zahl zurück.  Die Fibonacci-Folge ist
     rekursiv definiert:

             fib(0) = 0
             fib(1) = 1
             fib(n) = fib(n-1) + fib(n-2)

     Für negative ganze Zahlen kann die Fibonacci-Folge erweitert wird
     mit:

                             n + 1
             fib(- n) = (- 1)      f(n)

     Nach einem Aufruf der Funktion `fib(n)', enthält die Systemvariable
     `prevfib' die zur Zahl `n' vorhergehende Fibonacci-Zahl.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

 -- Funktion: fibtophi (<expr>)
     Fibonacci-Zahlen im Ausdruck <expr> werden durch die Goldene Zahl
     `%phi' ausgedrückt.  Siehe `%phi'.

     Beispiele:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

 -- Funktion: ifactors (<n>)
     Faktorisiert eine positive ganze Zahl <n>.  Sind `n = p1^e1 * ...
     * pk^nk' die Faktoren der ganzen Zahl <n>, dann gibt `ifactor' das
     Ergebnis `[[p1, e1], ..., [pk, ek]]' zurück.

     Für die Faktorisierung kommen Probedivisionen mit Primzahlen bis
     9973, Pollards Rho- und p-1-Methode oder Elliptischen Kurven zum
     Einsatz.

     Die Rückgabe von ifactors wird von der Optionsvariablen
     `factors_only'.

     beeinflusst.  Werden lediglich die Primfaktoren ohne ihre
     Multiplizität benötigt, genügt es hierfür, `factors_only : true'
     zu setzen.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600
          (%i3) ifactors(51575319651600), factors_only : true;
          (%o3)                   [2, 3, 5, 1583, 9050207]

 -- Funktion: igcdex (<n>, <k>)
     Gibt die Liste `[a, b, u]' zurück, in der `u' der größte
     gemeinsame Teiler von <n> und <k> ist und in der zusätzlich gilt,
     dass `u = a * <n> + b * <k>'.

     `igcdex' verwendet den Euklidischen Algorithmus.  Siehe auch
     `gcdex'.  .

     Die Eingabe `load(gcdex)' lädt diese Funktion.

     Beispiele:

          (%i1) load(gcdex)$

          (%i2) igcdex(30, 18);
          (%o2)                      [- 1, 2, 6]
          (%i3) igcdex(1526757668, 7835626735736);
          (%o3)            [845922341123, - 164826435, 4]
          (%i4) igcdex(fib(20), fib(21));
          (%o4)                   [4181, - 2584, 1]

 -- Funktion: inrt (<x>, <n>)
     Gibt die ganzzahlige <n>-te Wurzel des Betrags von <x> zurück.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]

 -- Funktion: inv_mod (<n>, <m>)
     Berechnet das modulare Inverse von <n> zum Modul <m>.  Das Argument
     <n> muss eine ganze Zahl und der Modul <p> eine positive ganze Zahl
     sein.  `inv_mod(n, m)' gibt `false' zurück, wenn das modulare
     Inverse nicht existiert.  Das modulare Inverse existiert, wenn <n>
     teilerfremd zum Modul <m> ist.

     Siehe auch die Funktionen `power_mod'  und `mod'.

     Beispiele:

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus = 41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false

 -- Funktion: isqrt (<x>)
     Gibt die ganzzahlige Wurzel des Betrages von <x> zurück, wenn <x>
     eine ganze Zahl ist.  Andernfalls wird eine Substantivform
     zurückgegeben.

 -- Funktion: jacobi (<p>, <q>)
     Berechnet das Jacobi-Symbol für die Argumente <p> und <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]

 -- Funktion: lcm (<expr_1>, ..., <expr_n>)
     Gibt das kleinste gemeinsame Vielfache der Argumente zurück.  Die
     Argumente können ganze Zahlen und allgemeine Ausdrücke sein.

     Mit dem Kommando `load(functs)' wird die Funktion geladen.

 -- Funktion: mod (<x>, <p>)
     Berechnet den Divisionsrest `x mod y' des Arguments <x> zum Modul
     <y>.  <x> und <y> können ganze Zahlen, rationale Zahlen,
     Gleitkommazahlen oder allgemeine Ausdrücke sein.

     Sind <x> und <y> reelle Zahlen und ist <y> ungleich Null, gibt
     `mod(<x>, <y>)' das Ergebnis von `<x> - <y> * floor(<x> / <y>)'
     zurück.  Weiterhin gilt für alle reellen Zahlen `mod(<x>, 0) =
     <x>'.  Für eine Diskussion dieser Definition siehe Kapitel 3.4,
     "Concrete Mathematics" von Graham, Knuth, and Patashnik.  Die
     Funktion `mod(<x>, 1)' ist eine Sägezahnfunktion mit der Periode 1
     mit `mod(1, 1) = 0' und `mod(0, 1) = 0'.

     Der Hauptwert einer komplexen Zahl, die im Intervall `(-%pi, %pi)'
     liegt, kann mit `%pi - mod(%pi - <x>, 2*%pi)' bestimmt werden,
     wobei <x> die komplexe Zahl ist.

     Sind <x> und <y> konstante Ausdrücke, wie zum Beispiel `10 * %pi',
     verwendet `mod' dasselbe `bfloat'.  -Auswertungsschema wie `floor'
     und `ceiling'. Diese Umwandlung kann, wenn auch unwahrscheinlich,
     zu Fehlern führen.

     Für nicht numerische Argumente <x> oder <y> kennt `mod'
     verschiedene Vereinfachungen.

     Siehe auch die Funktionen `power_mod'  und `inv_mod'.

     Beispiele:

     Zeige für zwei große ganze Zahlen, dass für das modulare Rechnen
     die Regel `mod(a+b, m) = mod(mod(a, m) + mod(b, m), m)' gilt.

          (%i1) a : random(10^20) + 10^19;
          (%o1)                 72588919020045581148
          (%i2) b : random(10^20) + 10^19;
          (%o2)                 35463666253140008825
          (%i3) m : random(10^20) + 10^19;
          (%o3)                 39127433614020247557
          (%i4) mod(a+b, m);
          (%o4)                 29797718045145094859
          (%i5) mod(mod(a, m) + mod(b, m), m);
          (%o5)                 29797718045145094859

     Vereinfachung für nicht numerische Argumente.

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0

 -- Funktion: next_prime (<n>)
     Gibt die kleinste Primzahl zurück, die der Zahl <n> folgt.

          (%i1) next_prime(27);
          (%o1)                       29

 -- Funktion: power_mod (<a>, <n>, <m>)
     Verwendet einen modularen Algorithmus, um `a^n mod m' zu berechnen.
     Die Argumente <a> und <n> müssen ganze Zahlen und der Modul <m>
     eine positive ganze Zahl sein.  Ist <n> negativ, wird `inv_mod'

     zur Berechnung des modularen Inversen aufgerufen.

     `power_mod (<a>, <n>, <m>)' ist äquivalent zu `mod(a^n, m)'.  Der
     Algorithmus von `power_mod' ist jedoch insbesondere für große
     ganze Zahlen wesentlich effizienter.

     Siehe auch die Funktionen `inv_mod'  und `mod'.

     Beispiele:

     `power_mod(a, n, m)' ist äquivalent zu `mod(a^n, m'.  Das modulare
     Inverse wird mit der Funktion `inv_mod' berechnet.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15, 5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2, 5);
          (%o4)                          3

     Für große ganze Zahlen ist `power_mod' effizienter.  Der folgende
     Wert kann in keiner vernünftigen Zeit mit `mod(a^n, m)' berechnet
     werden.

          (%i1) power_mod(123456789, 123456789, 987654321);
          (%o1)                       598987215

 -- Funktion: primep (<n>)
     Führt einen Primzahltest für das Argument <n> durch.  Liefert
     `primep' das Ergebnis `false', ist <n> keine Primzahl.  Ist das
     Ergebnis `true', ist <n> mit sehr großer Wahrscheinlichkeit eine
     Primzahl.

     Für ganze Zahlen <n> kleiner als 341550071728321 wird eine
     deterministische Variante des Miller-Rabin-Tests angewandt.  Hat
     in diesem Fall `primep' den Wert `true', dann ist <n> mit
     Sicherheit eine Primzahl.

     Für ganze Zahlen <n> größer 341550071728321 führt `primep'
     `primep_number_of_tests'  Pseudo-Primzahl-Tests nach Miller-Rabin
     und einen Pseudo-Primzahl-Test nach Lucas durch.  Die
     Wahrscheinlichkeit, dass eine zusammen gesetzte Zahl <n> einen
     Miller-Rabin-Test besteht, ist kleiner als 1/4.  Mit dem
     Standardwert 25 `primpe_number_of_tests' sinkt diese
     Wahrscheinlichkeit damit unter einen Wert von 10^-15.

 -- Optionsvariable: primep_number_of_tests
     Standardwert: 25

     Die Anzahl der Pseudo-Primzahl-Tests nach Miller-Rabin in der
     Funktion `primep'.  .

 -- Funktion: prev_prime (<n>)
     Gibt die größte Primzahl zurück, die kleiner als die Zahl <n> ist.

          (%i1) prev_prime(27);
          (%o1)                       23

 -- Funktion: qunit (<n>)
     Findet für das Argument <n> Lösungen der Pellschen Gleichung `a^2
     - <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1

 -- Funktion: totient (<n>)
     Gibt die Anzahl der ganzen Zahlen zurück, die kleiner oder gleich
     <n> und teilerfremd zu <n> sind.

 -- Optionsvariable: zerobern
     Standardwert: `true'

     Hat `zerobern' den Wert `false', werden von den Funktionen `bern'
     diejenigen Bernoulli-Zahlen und von `euler' diejenigen Euler-Zahlen
     ausgeschlossen, die gleich Null sind.  Siehe `bern'  und `euler'.


 -- Funktion: zeta (<n>)
     Die Riemannsche Zeta-Funktion für <s>, die wie folgt definiert ist:

                           inf
                           ====
                           \     1
               zeta(s) =    >    --
                           /      s
                           ====  k
                           k = 1

     Für negative ganze Zahlen <n>, Null und positive gerade ganze
     Zahlen wird `zeta' zu einem exakten Ergebnis vereinfacht.  Damit
     diese Vereinfachung für positive ganze Zahlen ausgeführt wird,
     muss die Optionsvariable `zeta%pi' den Wert `true' haben.  Siehe
     `zeta%pi'.  . Für einfache und beliebig genaue Gleitkommazahlen
     (Typ `bfloat') hat `zeta' ein numerisches Ergebnis.  Für alle
     anderen Argumente einschließlich der komplexen und rationalen
     Zahlen gibt `zeta' eine Substantivform zurück.  Hat die
     Optionsvariable `zeta%pi' den Wert `false', gibt `zeta' auch für
     gerade ganze Zahlen eine Substantivform zurück.

     `zeta(1)' ist nicht definiert.  Maxima kennt jedoch die einseitigen
     Grenzwerte `limit(zeta(x), x, 1, plus' und `limit(zeta(x), x, 1,
     minus'.

     Die Riemannsche Zeta-Funktion wird auf die Argumente von Listen,
     Matrizen und Gleichungen angewendet, wenn die Optionsvariable
     `distribute_over' den Wert `true' hat.

     Siehe auch `bfzeta'  und `zeta%pi'.

     Beispiele:

          (%i1) zeta([-2,-1,0,0.5,2,3,1+%i]);
                                                       2
                      1     1                       %pi
          (%o1) [0, - --, - -, - 1.460354508809586, ----, zeta(3),
                      12    2                        6
                                                              zeta(%i + 1)]
          (%i2) limit(zeta(x),x,1,plus);
          (%o2)                          inf
          (%i3) limit(zeta(x),x,1,minus);
          (%o3)                         minf

 -- Optionsvariable: zeta%pi
     Standardwert: `true'

     Hat `zeta%pi' den Wert `true', vereinfacht die Funktion `zeta(n)'
     für gerade ganzen Zahlen <n> zu einem Ergebnis, das proportional zu
     `%pi^n' ist.  Ansonsten ist das Ergebnis von `zeta' eine
     Substantivform für gerade ganze Zahlen.

     Beispiele:

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)

 -- Funktion: zn_log (<a>, <g>, <n>)
 -- Funktion: zn_log (<a>, <g>, <n>, [[<p1>, <e1>], ..., [<pk>, <ek>]])
     Berechnet den diskreten Logarithmus.  Sei (Z/<n>Z)* eine zyklische
     Gruppe, <g> eine Primitivwurzel modulo <n> und <a> ein Element
     dieser Gruppe.  Dann berechnet `zn_log (a, g, n)' eine Lösung der
     Kongruenz `g^x = a mod n'.

     Der verwendete Algorithmus benötigt die Primfaktorzerlegung des
     Totienten von <n>.  Da diese Berechnung ebenfalls zeitaufwändig
     ist, kann es eventuell sinnvoll sein, die Primfaktoren des
     Totienten vorab zu berechnen und `zn_log' als viertes Argument zu
     übergeben. Die Form muss dabei der Rückgabe von
     `ifactors(totient(n))' mit der Standardeinstellung `false' der
     Optionsvariable `factors_only' entsprechen.

     Als Algorithmus wird die Pohlig-Hellman-Reduktion und das
     Rho-Verfahren von Pollard für den diskreten Logarithmus verwendet.
     Die Laufzeit von `zn_log' hängt im Wesentlichen von der Bitlänge
     des größten Primfaktors des Totienten von <n> ab.

     Siehe auch `zn_primroot' , `zn_order' , `ifactors' , `totient' .

     Beispiele:

     `zn_log (a, g, n)' findet eine Lösung der Kongruenz `g^x = a mod
     n'.

          (%i1) n : 22$
          (%i2) g : zn_primroot(n);
          (%o2)                               7
          (%i3) ord_7 : zn_order(7, n);
          (%o3)                              10
          (%i4) powers_7 : makelist(power_mod(g, x, n), x, 0, ord_7 - 1);
          (%o4)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
          (%i5) zn_log(21, g, n);
          (%o5)                               5
          (%i6) map(lambda([x], zn_log(x, g, n)), powers_7);
          (%o6)                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

     Das optionale vierte Argument muss der Rückgabe von
     `ifactors(totient(n))' entsprechen.  Die Laufzeit hängt im
     Wesentlichen von der Bitlänge des größten Primfaktors des
     Totienten ab.

          (%i1) (p : 2^127-1, primep(p));
          (%o1)                             true
          (%i2) ifs : ifactors(p - 1)$
          (%i3) g : zn_primroot(p, ifs);
          (%o3)                              43
          (%i4) a : power_mod(g, 1234567890, p)$
          (%i5) zn_log(a, g, p, ifs);
          (%o5)                          1234567890
          (%i6) time(%o5);
          (%o6)                            [1.204]
          (%i7) f_max : last(ifs);
          (%o7)                       [77158673929, 1]
          (%i8) slength( printf(false, "~b", f_max[1]) );
          (%o8)                              37

 -- Funktion: zn_order (<x>, <n>)
 -- Funktion: zn_order (<x>, <n>, [[<p1>, <e1>], ..., [<pk>, <ek>]])
     Ist <x> eine Einheit in der endlichen Gruppe (Z/<n>Z)*, so
     berechnet `zn_order' die Ordnung dieses Elements.  Andernfalls
     gibt `zn_order' `false' zurück.  <x> ist eine Einheit modulo <n>,
     falls <x> teilerfremd zu <n> ist.

     Der verwendete Algorithmus benötigt die Primfaktorzerlegung des
     Totienten von <n>.  Da diese Berechnung manchmal recht
     zeitaufwändig ist, kann es eventuell sinnvoll sein, die
     Primfaktoren des Totienten vorab zu berechnen und `zn_order' als
     drittes Argument zu übergeben. Die Form muss dabei der Rückgabe von
     `ifactors(totient(n))' mit der Standardeinstellung `false' der
     Optionsvariable `factors_only' entsprechen.

     Siehe auch `zn_primroot' , `ifactors' , `totient' .

     Beispiele:

     `zn_order' berechnet die Ordnung einer Einheit <x> aus (Z/<n>Z)*.

          (%i1) n : 22$
          (%i2) g : zn_primroot(n);
          (%o2)                               7
          (%i3) units_22 : sublist(makelist(i,i,1,21), lambda([x], gcd(x, n) = 1));
          (%o3)              [1, 3, 5, 7, 9, 13, 15, 17, 19, 21]
          (%i4) (ord_7 : zn_order(7, n)) = totient(n);
          (%o4)                            10 = 10
          (%i5) powers_7 : makelist(power_mod(g,i,n), i,0,ord_7 - 1);
          (%o5)              [1, 7, 5, 13, 3, 21, 15, 17, 9, 19]
          (%i6) map(lambda([x], zn_order(x, n)), powers_7);
          (%o6)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
          (%i7) map(lambda([x], ord_7/gcd(x, ord_7)), makelist(i, i,0,ord_7 - 1));
          (%o7)              [1, 10, 5, 10, 5, 2, 5, 10, 5, 10]
          (%i8) totient(totient(n));
          (%o8)                               4

     Das optionale dritte Argument muss der Rückgabe von
     `ifactors(totient(n))' entsprechen.

          (%i1) (p : 2^142 + 217, primep(p));
          (%o1)                             true
          (%i2) ifs : ifactors( totient(p) )$
          (%i3) g : zn_primroot(p, ifs);
          (%o3)                               3
          (%i4) is( (ord_3 : zn_order(g, p, ifs)) = totient(p) );
          (%o4)                             true
          (%i5) map(lambda([x], ord_3/zn_order(x, p, ifs)), makelist(i,i,2,15));
          (%o5)        [22, 1, 44, 10, 5, 2, 22, 2, 8, 2, 1, 1, 20, 1]

 -- Funktion: zn_primroot (<n>)
 -- Funktion: zn_primroot (<n>, [[<p1>, <e1>], ..., [<pk>, <ek>]])
     Ist die multiplikative Gruppe (Z/<n>Z)* zyklisch, berechnet
     `zn_primroot' die kleinste Primitivwurzel modulo <n>.  Dies ist
     der Fall, wenn <n> gleich `2', `4', `p^k' oder `2*p^k' ist, wobei
     `p' prim und grösser `2' und `k' eine natürliche Zahl ist.
     `zn_primroot' führt einen entsprechenden Prätest durch, wenn die
     Optionsvariable `zn_primroot_pretest'  (Standardwert: `false')
     `true' gesetzt wurde.  In jedem Fall wird die Suche durch die
     obere Schranke `zn_primroot_limit'  begrenzt.

     Ist (Z/<n>Z)* nicht zyklisch oder kann bis `zn_primroot_limit'
     keine Primitivwurzel modulo <n> gefunden werden, gibt `zn_primroot'
     `false' zurück.

     Der verwendete Algorithmus benötigt die Primfaktorzerlegung des
     Totienten von <n>.  Diese Berechnung kann zeitaufwändig sein und
     es kann daher eventuell sinnvoll sein, die Primfaktoren des
     Totienten vorab zu berechnen und `zn_primroot' als zusätzliches
     Argument zu übergeben. Die Form muss dabei der Rückgabe von
     `ifactors(totient(n))' mit der Standardeinstellung `false' der
     Optionsvariable `factors_only' entsprechen.

     Siehe auch `zn_primroot_p' , `zn_order' , `ifactors' , `totient' .

     Beispiele:

     `zn_primroot' berechnet die kleinste Primitivwurzel modulo <n>
     oder gibt `false' zurück.

          (%i1) n : 14$
          (%i2) g : zn_primroot(n);
          (%o2)                               3
          (%i3) zn_order(g, n) = totient(n);
          (%o3)                             6 = 6
          (%i4) n : 15$
          (%i5) zn_primroot(n);
          (%o5)                             false

     Das optionale zweite Argument muss der Rückgabe von
     `ifactors(totient(n))' entsprechen.

          (%i1) (p : 2^142 + 217, primep(p));
          (%o1)                             true
          (%i2) ifs : ifactors( totient(p) )$
          (%i3) g : zn_primroot(p, ifs);
          (%o3)                               3
          (%i4) [time(%o2), time(%o3)];
          (%o4)                    [[15.556972], [0.004]]
          (%i5) is(zn_order(g, p, ifs) = p - 1);
          (%o5)                             true
          (%i6) n : 2^142 + 216$
          (%i7) ifs : ifactors(totient(n))$
          (%i8) zn_primroot(n, ifs),
                zn_primroot_limit : 200, zn_primroot_verbose : true;
          `zn_primroot' stopped at zn_primroot_limit = 200
          (%o8)                             false

 -- Optionsvariable: zn_primroot_limit
     Standardwert: `1000'

     Definiert die obere Schranke für die Suche von `zn_primroot'.
     nach einer Primitivwurzel.  Wurde die Optionsvariable
     `zn_primroot_verbose'.

     (Standardwert: `false') `true' gesetzt, wird beim Erreichen von
     `zn_primroot_limit' ein entsprechender Hinweis ausgegeben.

 -- Funktion: zn_primroot_p (<x>, <n>)
 -- Funktion: zn_primroot_p (<x>, <n>, [[<p1>, <e1>], ..., [<pk>,
          <ek>]])
     Testet, ob <x> eine Primitivwurzel in der multiplikativen Gruppe
     (Z/<n>Z)* ist.

     Der verwendete Algorithmus benötigt die Primfaktorzerlegung des
     Totienten von <n>.  Wird dieser Test nacheinander auf mehrere
     Zahlen angewandt, kann es sinnvoll sein, die Primfaktoren des
     Totienten vorab zu berechnen und `zn_primroot_p' als zusätzliches
     drittes Argument zu übergeben.  Die Form muss dabei der Rückgabe
     von `ifactors(totient(n))' mit der Standardeinstellung `false' der
     Optionsvariable `factors_only' entsprechen.

     Siehe auch `zn_primroot' , `zn_order' , `ifactors' , `totient' .

     Beispiele:

     `zn_primroot_p' als Prädikatfunktion.

          (%i1) n : 14$
          (%i2) units_14 : sublist(makelist(i,i,1,13), lambda([i], gcd(i, n) = 1));
          (%o2)                     [1, 3, 5, 9, 11, 13]
          (%i3) zn_primroot_p(13, n);
          (%o3)                            false
          (%i4) sublist(units_14, lambda([x], zn_primroot_p(x, n)));
          (%o4)                            [3, 5]
          (%i5) map(lambda([x], zn_order(x, n)), units_14);
          (%o5)                      [1, 6, 6, 3, 3, 2]

     Das optionale dritte Argument muss der Rückgabe von
     `ifactors(totient(n))' entsprechen.

          (%i1) (p : 2^142 + 217, primep(p));
          (%o1)                             true
          (%i2) ifs : ifactors( totient(p) )$
          (%i3) sublist(makelist(i,i,1,50), lambda([x], zn_primroot_p(x, p, ifs)));
          (%o3)      [3, 12, 13, 15, 21, 24, 26, 27, 29, 33, 38, 42, 48]
          (%i4) [time(%o2), time(%o3)];
          (%o4)                   [[7.748484], [0.036002]]

 -- Optionsvariable: zn_primroot_pretest
     Standardwert: `false'

     Eine multiplikative Gruppe (Z/`n'Z)* ist zyklisch, wenn `n' gleich
     `2', `4', `p^k' oder `2*p^k' ist, wobei `p' prim und grösser `2'
     und `k' eine natürliche Zahl ist.

     `zn_primroot_pretest' entscheidet darüber, ob `zn_primroot'.   vor
     der Berechnung der kleinsten Primitivwurzel in (Z/`n'Z)* überprüft,
     ob auf `n' überhaupt einer der oben genannten Fälle zutrifft.  Nur
     wenn `zn_primroot_pretest' `true' ist, wird dieser Prätest
     ausgeführt.

 -- Optionsvariable: zn_primroot_verbose
     Standardwert: `false'

     Entscheidet, ob `zn_primroot'.   beim Erreichen von
     `zn_primroot_limit'.

     einen Hinweis ausgibt.


File: maxima.info,  Node: Spezielle Funktionen,  Next: Fourier-Transformationen,  Prev: Zahlentheorie,  Up: Top

22 Spezielle Funktionen
***********************

* Menu:

* Einführung für spezielle Funktionen::
* Bessel-Funktionen und verwandte Funktionen::
* Gammafunktionen und verwandte Funktionen::
* Exponentielle Integrale::
* Fehlerfunktionen::
* Elliptische Funktionen und Integrale::
* Hypergeometrische Funktionen::
* Weitere spezielle Funktionen::


File: maxima.info,  Node: Einführung für spezielle Funktionen,  Next: Bessel-Funktionen und verwandte Funktionen,  Prev: Spezielle Funktionen,  Up: Spezielle Funktionen

22.1 Einführung für spezielle Funktionen
========================================

Spezielle Funktionen haben die folgenden Notationen:

     bessel_j (v, z)                Bessel-Funktion der 1. Art
     bessel_y (v, z)                Bessel-Funktion der 2. Art
     bessel_i (v, z)                Modifizierte Bessel-Funktion der 1. Art
     bessel_k (v, z)                Modifizierte Bessel-Funktion der 2. Art

     hankel_1 (v, z)                Hankel-Funktion der 1. Art
     hankel_2 (v, z)                Hankel-Funktion der 2. Art

     airy_ai (z)                    Airy-Funktion Ai(z)
     airy_bi (z)                    Airy-Funktion Bi(z)
     airy_dai (z)                   Ableitung der Airy-Funktion Ai(z)
     airy_dbi (z)                   Ableitung der Airy-Funktion Bi(z)

     struve_h (v, z)                Struve-Funktion H[v](z)
     struve_l (v, z)                Struve-Funktion L[v](z)

     %f[p,q] ([], [], z)            Hypergeometrische Funktion
     gamma()                        Gammafunktion
     gammagreek(a, z)               unvollständige Gamma-Funktion
     gammaincomplete(a,z)           unvollständige Gamma-Funktion
     hypergeometric(l1, l2, z)      Hypergeometrische Funktion

     %m[u,k] (z)                    Whittaker-Funktion der 1. Art
     %w[u,k] (z)                    Whittaker-Funktion der 2. Art

     erf (z)                        Fehlerfunktion
     erfc (z)                       Komplementäre Fehlerfunktion
     erfi (z)                       imaginäre Fehlerfunktion

     expintegral_e (v,z)            Exponentielles Integral E
     expintegral_e1 (z)             Exponentielles Integral E1
     expintegral_ei (z)             Exponentielles integral Ei
     expintegral_li (z)             Logarithmisches Integral Li
     expintegral_si (z)             Exponentielles Integral Si
     expintegral_ci (z)             Exponentielles Integral Ci
     expintegral_shi (z)            Exponentielles Integral Shi
     expintegral_chi (z)            Exponentielles Integral Chi

     parabolic_cylinder_d (v,z)     Parabolische Zylinderfunktion D


File: maxima.info,  Node: Bessel-Funktionen und verwandte Funktionen,  Next: Gammafunktionen und verwandte Funktionen,  Prev: Einführung für spezielle Funktionen,  Up: Spezielle Funktionen

22.2 Bessel-Funktionen und verwandte Funktionen
===============================================

* Menu:

* Bessel-Funktionen::
* Hankel-Funktionen::
* Airy-Funktionen::
* Struve-Funktionen::


File: maxima.info,  Node: Bessel-Funktionen,  Next: Hankel-Funktionen,  Prev: Bessel-Funktionen und verwandte Funktionen,  Up: Bessel-Funktionen und verwandte Funktionen

22.2.1 Bessel-Funktionen
------------------------

 -- Funktion: bessel_j (<v>, <z>)
     Die Bessel-Funktion der ersten Art der Ordnung v mit dem Argument
     z.  `bessel_j' ist definiert als

                         inf
                         ====             k
                         \           (- 1)           z 2 k + v
                J (z) =   >    -------------------  (-)
                 v       /     k! gamma(v + k + 1)   2
                         ====
                         k = 0

     Die Reihenentwicklung wird nicht für die numerische Berechnung
     genutzt.

     Die Bessel-Funktion `bessel_j' ist für das numerische und
     symbolische Rechnen geeignet.

     Maxima berechnet `bessel_j' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente ganze oder
     rationale Zahlen sind.  Die numerische Berechnung für große
     Gleitkommazahlen ist nicht implementiert.  In diesem Fall gibt
     Maxima eine Substantivform zurück.

     `bessel_j' hat die folgenden Eigenschaften, die mit mit der
     Funktion `properties'  angezeigt werden und auf das symbolische
     Rechnen Einfluss haben:

    `conjugate function'
          `bessel_j' hat Spiegelsymmetrie, wenn das Argument <z> keine
          negative reelle Zahl ist.  Die Spiegelsymmetrie wird zum
          Beispiel von der Funktion `conjugate'  für die Vereinfachung
          eines Ausdrucks genutzt.

    `complex characteristic'
          Maxima kennt den Realteil und den Imaginärteil von `bessel_j'
          für spezielle Argumente v und z.

    `limit function'
          Maxima kennt spezielle Grenzwerte der Funktion `bessel_j'.

    `integral'
          Maxima kennt das Integral der Funktion `bessel_j' für die
          Integrationsvariable z.

    `gradef'
          Maxima kennt die Ableitungen der Funktion `bessel_j' nach den
          Argumenten v und z.

     Die Vereinfachung der Bessel-Funktion `bessel_j' wird von den
     folgenden Optionsvariablen kontrolliert:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und sind die Argumente von `bessel_j' eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist `true'.

    `besselexpand'
          Hat die Optionsvariable `besselexpand'  den Wert `true', wird
          `bessel_j' mit einer halbzahligen Ordnung v als Sinus- und
          Kosinusfunktionen entwickelt.

    `bessel_reduce'
          Hat die Optionsvariable `bessel_reduce'  den Wert `true', wird
          `bessel_j' mit einer ganzzahligen Ordnung n nach
          Bessel-Funktionen `bessel_j' mit der niedrigsten Ordnung `0'
          und `1' entwickelt.

    `hypergeometric_representation'
          Hat die Optionsvariable `hypergeometric_representation'  den
          Wert `true', dann wird `bessel_j' als hypergeometrische
          Funktion dargestellt.

     Weiterhin kennt Maxima die geraden und ungeraden
     Symmetrieeigenschaften von `bessel_j'.  Für eine ganze Zahl n
     vereinfacht daher `bessel_j(-n, z)' zu `(-1)^n bessel_j(n, z)'.

     Maxima kennt noch die Funktion `spherical_bessel_j',  die im Paket
     `orthopoly' definiert ist.   Siehe auch die anderen
     Bessel-Funktionen `bessel_y',  `bessel_i'  und `bessel_k'  sowie
     die weiteren mit den Bessel-Funktionen verwandten Funktionen wie
     die Hankel-Funktionen in *note Hankel-Funktionen::,
     Airy-Funktionen in *note Airy-Funktionen:: und Struve-Funktionen
     in *note Struve-Funktionen::.

     Beispiele:

     Numerisches Rechnen mit der Bessel-Funktion.  Für große
     Gleitkommazahlen ist die numerische Berechnung nicht implementiert.

          (%i1) bessel_j(1,[0.5, 0.5+%i]);
          (%o1) [.2422684576748739, .5124137767280905 %i
                                                       + .3392601907198862]
          (%i2) bessel_j(1,[0.5b0, 0.5b0+%i]);
          (%o2)    [bessel_j(1, 5.0b-1), bessel_j(1, %i + 5.0b-1)]

     Vereinfachungen der Bessel-Funktion mit den Optionsvariablen
     `besselexpand' und `bessel_reduce'.

          (%i3) bessel_j(1/2,x), besselexpand:true;
                                   sqrt(2) sin(x)
          (%o3)                   -----------------
                                  sqrt(%pi) sqrt(x)
          (%i4) bessel_j(3,x), bessel_reduce:true;
                   2 bessel_j(1, x)
                4 (---------------- - bessel_j(0, x))
                          x
          (%o4) ------------------------------------- - bessel_j(1, x)
                                  x

     Ableitungen und Integrale der Bessel-Funktion.  Das letzte
     Beispiel zeigt die Laplace-Transformation der Bessel-Funktion mit
     der Funktion `laplace'.

          (%i5) diff(bessel_j(2,x), x);
                           bessel_j(1, x) - bessel_j(3, x)
          (%o5)            -------------------------------
                                          2
          (%i6) diff(bessel_j(v,x), x);
                       bessel_j(v - 1, x) - bessel_j(v + 1, x)
          (%o6)        ---------------------------------------
                                          2
          (%i7) integrate(bessel_j(v,x), x);
          (%o7)
                                                         2
                              v   1    v   3            x    - v - 1  v + 1
              hypergeometric([- + -], [- + -, v + 1], - --) 2        x
                              2   2    2   2            4
              -------------------------------------------------------------
                                   v   1
                                  (- + -) gamma(v + 1)
                                   2   2
          (%i8) laplace(bessel_j(2,t), t, s);
                                          1       2
                                (1 - sqrt(-- + 1))  s
                                           2
                                          s
          (%o8)                 ---------------------
                                         1
                                    sqrt(-- + 1)
                                          2
                                         s

     Bessel-Funktionen als Lösung einer linearen Differentialgleichung
     zweiter Ordnung.

          (%i1) depends(y, x);
          (%o1)                        [y(x)]
          (%i2) declare(n, integer);
          (%o2)                         done
          (%i3) 'diff(y, x, 2)*x^2 + 'diff(y, x)*x + y*(x^2-n^2) = 0;
                                          2
                               2    2    d y  2   dy
          (%o3)            y (x  - n ) + --- x  + -- x = 0
                                           2      dx
                                         dx
          (%i4) ode2(%, y, x);
          (%o4)      y = %k2 bessel_y(n, x) + %k1 bessel_j(n, x)

 -- Funktion: bessel_y (<v>, <z>)
     Die Bessel-Funktion der zweiten Art der Ordnung v mit dem Argument
     z.  `bessel_y' ist definiert als

                        cos(%pi v) J (z) - J   (z)
                                    v       - v
                Y (z) = --------------------------
                 v              sin(%pi v)

     für den Fall, dass v keine ganze Zahl ist.  Ist v eine ganze Zahl
     n, dann wird die Bessel-Funktion `bessel_y' wie folgt als ein
     Grenzwert definiert

                Y (z) = limit  Y (z)
                 n      v -> n  v

     Die Bessel-Funktion `bessel_y' ist für das numerische und
     symbolische Rechnen geeignet.

     Maxima berechnet `bessel_y' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente ganze oder
     rationale Zahlen sind.  Die numerische Berechnung für große
     Gleitkommazahlen ist nicht implementiert.  In diesem Fall gibt
     Maxima eine Substantivform zurück.

     `bessel_y' hat die folgenden Eigenschaften, die mit mit der
     Funktion `properties'  angezeigt werden und auf das symbolische
     Rechnen Einfluss haben:

    `conjugate function'
          `bessel_y' hat Spiegelsymmetrie, wenn das Argument <z> keine
          negative reelle Zahl ist.  Die Spiegelsymmetrie wird zum
          Beispiel von der Funktion `conjugate'  für die Vereinfachung
          eines Ausdrucks genutzt.

    `complex characteristic'
          Maxima kennt den Realteil und den Imaginärteil von `bessel_y'
          für spezielle Argumente v und z.

    `limit function'
          Maxima kennt spezielle Grenzwerte der Funktion `bessel_y'.

    `integral'
          Maxima kennt das Integral der Funktion `bessel_y' für die
          Integrationsvariable z.

    `gradef'
          Maxima kennt die Ableitungen der Funktion `bessel_y' nach den
          Argumenten v und z.

     Die Vereinfachung der Bessel-Funktion `bessel_y' wird von den
     folgenden Optionsvariablen kontrolliert:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und sind die Argumente von `bessel_y' eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist `true'.

    `besselexpand'
          Hat die Optionsvariable `besselexpand'  den Wert `true', wird
          `bessel_y' mit einer halbzahligen Ordnung v als Sinus- und
          Kosinusfunktionen entwickelt.

    `bessel_reduce'
          Hat die Optionsvariable `bessel_reduce'  den Wert `true', wird
          `bessel_y' mit einer ganzzahligen Ordnung n nach
          Bessel-Funktionen `bessel_y' mit der niedrigsten Ordnung `0'
          und `1' entwickelt.

    `hypergeometric_representation'
          Hat die Optionsvariable `hypergeometric_representation'  den
          Wert `true', dann wird `bessel_y' als hypergeometrische
          Funktion dargestellt.  Es ist zu beachten, dass die
          hypergeometrische Funktion nur für eine nicht ganzzahlige
          Ordnung v gültig ist.

     Weiterhin kennt Maxima die geraden und ungeraden
     Symmetrieeigenschaften von `bessel_y'.  Für eine ganze Zahl n
     vereinfacht daher `bessel_y(-n, z)' zu `(-1)^n bessel_y(n, z)'.

     Maxima kennt noch die Funktion `spherical_bessel_y',  die im Paket
     `orthopoly' definiert ist.   Siehe auch die anderen
     Bessel-Funktionen `bessel_j',  `bessel_i'  und `bessel_k'  sowie
     die weiteren mit den Bessel-Funktionen verwandten Funktionen wie
     die Hankel-Funktionen in *note Hankel-Funktionen::,
     Airy-Funktionen in *note Airy-Funktionen:: und Struve-Funktionen
     in *note Struve-Funktionen::.

     Siehe die Funktion `bessel_j'  für Beispiele mit Bessel-Funktionen.

 -- Funktion: bessel_i (<v>, <z>)
     Die modifizierte Bessel-Funktion der ersten Art der Ordnung v mit
     dem Argument v.  `bessel_i' ist definiert als

                         inf
                         ====
                         \              1            z 2 k + v
                I (z) =   >    -------------------  (-)
                 v       /     k! gamma(v + k + 1)   2
                         ====
                         k = 0

     Die Reihenentwicklung wird nicht für die numerische Berechnung
     genutzt.

     Die Bessel-Funktion `bessel_i' ist für das numerische und
     symbolische Rechnen geeignet.

     Maxima berechnet `bessel_i' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente ganze oder
     rationale Zahlen sind.  Die numerische Berechnung für große
     Gleitkommazahlen ist nicht implementiert.  In diesem Fall gibt
     Maxima eine Substantivform zurück.

     `bessel_i' hat die folgenden Eigenschaften, die mit mit der
     Funktion `properties'  angezeigt werden und auf das symbolische
     Rechnen Einfluss haben:

    `conjugate function'
          `bessel_i' hat Spiegelsymmetrie, wenn das Argument <z> keine
          negative reelle Zahl ist.  Die Spiegelsymmetrie wird zum
          Beispiel von der Funktion `conjugate'  für die Vereinfachung
          eines Ausdrucks genutzt.

    `complex characteristic'
          Maxima kennt den Realteil und den Imaginärteil von `bessel_i'
          für spezielle Argumente v und z.

    `limit function'
          Maxima kennt spezielle Grenzwerte der Funktion `bessel_i'.

    `integral'
          Maxima kennt das Integral der Funktion `bessel_i' für die
          Integrationsvariable z.

    `gradef'
          Maxima kennt die Ableitungen der Funktion `bessel_i' nach den
          Argumenten v und z.

     Die Vereinfachung der Bessel-Funktion `bessel_i' wird von den
     folgenden Optionsvariablen kontrolliert:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und sind die Argumente von `bessel_i' eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist `true'.

    `besselexpand'
          Hat die Optionsvariable `besselexpand'  den Wert `true', wird
          `bessel_i' mit einer halbzahligen Ordnung v als
          Hyperbelfunktionen entwickelt.

    `bessel_reduce'
          Hat die Optionsvariable `bessel_reduce'  den Wert `true', wird
          `bessel_i' mit einer ganzzahligen Ordnung n nach
          Bessel-Funktionen `bessel_i' mit der niedrigsten Ordnung `0'
          und `1' entwickelt.

    `hypergeometric_representation'
          Hat die Optionsvariable `hypergeometric_representation'  den
          Wert `true', dann wird `bessel_i' als hypergeometrische
          Funktion dargestellt.

     Weiterhin kennt Maxima die geraden und ungeraden
     Symmetrieeigenschaften von `bessel_i'.  Für eine ganze Zahl n
     vereinfacht daher `bessel_i(-n, z)' zu `bessel_i(n, z)'.

     Siehe auch die anderen Bessel-Funktionen `bessel_j',

     `bessel_y'  und `bessel_k'  sowie die weiteren mit den
     Bessel-Funktionen verwandten Funktionen wie die Hankel-Funktionen
     in *note Hankel-Funktionen::, Airy-Funktionen in *note
     Airy-Funktionen:: und Struve-Funktionen in *note
     Struve-Funktionen::.

     Siehe die Funktion `bessel_j'  für Beispiele mit Bessel-Funktionen.

 -- Funktion: bessel_k (<v>, <z>)
     Die modifizierte Bessel-Funktion der zweiten Art der Ordnung v mit
     dem Argument z.  `bessel_k' ist definiert als

                        %pi csc(%pi u) (I   (z) - I (z))
                                         - v       u
                K (z) = --------------------------------
                 v                     2

     für den Fall, dass v keine ganze Zahl ist.  Ist v eine ganze Zahl
     n, dann wird die Bessel-Funktion `bessel_k' wie folgt als
     Grenzwert definiert

          (%o5) K (z) = limit  K (z)
                 n      v -> n  v

     Die Bessel-Funktion `bessel_k' ist für das numerische und
     symbolische Rechnen geeignet.

     Maxima berechnet `bessel_k' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente ganze oder
     rationale Zahlen sind.  Die numerische Berechnung für große
     Gleitkommazahlen ist nicht implementiert.  In diesem Fall gibt
     Maxima eine Substantivform zurück.

     `bessel_k' hat die folgenden Eigenschaften, die mit mit der
     Funktion `properties'  angezeigt werden und auf das symbolische
     Rechnen Einfluss haben:

    `conjugate function'
          `bessel_k' hat Spiegelsymmetrie, wenn das Argument <z> keine
          negative reelle Zahl ist.  Die Spiegelsymmetrie wird zum
          Beispiel von der Funktion `conjugate'  für die Vereinfachung
          eines Ausdrucks genutzt.

    `complex characteristic'
          Maxima kennt den Realteil und den Imaginärteil von `bessel_k'
          für spezielle Argumente v und z.

    `limit function'
          Maxima kennt spezielle Grenzwerte der Funktion `bessel_k'.

    `integral'
          Maxima kennt das Integral der Funktion `bessel_k' für die
          Integrationsvariable z.

    `gradef'
          Maxima kennt die Ableitungen der Funktion `bessel_k' nach den
          Argumenten v und z.

     Die Vereinfachung der Bessel-Funktion `bessel_k' wird von den
     folgenden Optionsvariablen kontrolliert:

    `distribute_over'
          Hat die Optionsvariable `distribute_over'  den Wert `true'
          und sind die Argumente von `bessel_k' eine Matrix, Liste oder
          Gleichung wird die Funktion auf die Elemente oder beiden
          Seiten der Gleichung angewendet.  Der Standardwert ist `true'.

    `besselexpand'
          Hat die Optionsvariable `besselexpand'  den Wert `true', wird
          `bessel_k' mit einer halbzahligen Ordnung v als
          Exponentialfunktion entwickelt.

    `bessel_reduce'
          Hat die Optionsvariable `bessel_reduce'  den Wert `true', wird
          `bessel_k' mit einer ganzzahligen Ordnung n nach
          Bessel-Funktionen `bessel_k' mit der niedrigsten Ordnung `0'
          und `1' entwickelt.

    `hypergeometric_representation'
          Hat die Optionsvariable `hypergeometric_representation'  den
          Wert `true', dann wird `bessel_k' als hypergeometrische
          Funktion dargestellt.  Es ist zu beachten, dass die
          hypergeometrische Funktion nur für eine nicht ganzzahlige
          Ordnung v gültig ist.

     Weiterhin kennt Maxima die geraden und ungeraden
     Symmetrieeigenschaften von `bessel_k'.  Für eine ganze Zahl n
     vereinfacht daher `bessel_k(-n, z)' zu `bessel_y(n, z)'.

     Siehe auch die anderen Bessel-Funktionen `bessel_j',  `bessel_y'

     und `bessel_i'  sowie die weiteren mit den Bessel-Funktionen
     verwandten Funktionen wie die Hankel-Funktionen in *note
     Hankel-Funktionen::, Airy-Funktionen in *note Airy-Funktionen::
     und Struve-Funktionen in *note Struve-Funktionen::.

     Siehe die Funktion `bessel_j'  für Beispiele mit Bessel-Funktionen.

 -- Optionsvariable: bessel_reduce
     Standardwert: `false'

     Hat die Optionsvariable `bessel_reduce' den Wert `true', werden
     Bessel-Funktionen mit einer ganzzahligen Ordnung n nach
     Bessel-Funktionen mit der niedrigsten Ordnung 0 und 1 entwickelt.

 -- Optionsvariable: besselexpand
     Standardwert: `false'

     Hat die Optionsvariable `besselexpand' den Wert `true', werden
     Bessel-Funktion mit einer halbzahligen Ordnung v als Sinus-,
     Kosinus-, Hyperbel- oder Exponentialfunktionen entwickelt.  Die
     Optionsvariable `besselexpand' kontrolliert auch die Entwicklung
     der Hankel-Funktionen `hankel_1'  und `hankel_2'  sowie der
     Struve-Funktionen `struve_h'

     und `struve_l'.

     Beispiele:

          (%i1) besselexpand: false$

          (%i2) bessel_j(3/2, z);
                                            3
          (%o2)                    bessel_j(-, z)
                                            2
          (%i3) besselexpand: true$

          (%i4) bessel_j(3/2, z);
                                           sin(z)   cos(z)
                          sqrt(2) sqrt(z) (------ - ------)
                                              2       z
                                             z
          (%o4)           ---------------------------------
                                      sqrt(%pi)

     Weitere Beispiele für die Entwicklungen der Funktionen `bessel_k'
     und `struve_h'.

          (%i5) bessel_k(3/2, z);
                                          1        - z
                               sqrt(%pi) (- + 1) %e
                                          z
          (%o5)                -----------------------
                                   sqrt(2) sqrt(z)

          (%i6) struve_h(3/2, z);
                                                     2
                            2 z sin(z) + 2 cos(z) - z  - 2
          (%o6)           - ------------------------------
                                                   3/2
                                sqrt(2) sqrt(%pi) z

 -- Funktion: scaled_bessel_i (<v>, <z>)
     Die skalierte modifizierte Bessel-Funktion der ersten Art der
     Ordnung v mit dem Argument z.  Diese ist definiert als

                                                          - abs(z)
                scaled_bessel_i(v, z) = bessel_i(v, z) %e

     `scaled_bessel_i' liefert ein numerisches Ergebnis, wenn die
     Argumente v und z Zahlen sind.  Die Funktion kann geeignet sein,
     wenn `bessel_i' für große Argumente z numerisch berechnet werden
     soll.  Ganze, rationale oder große Gleitkommazahlen werden in
     Gleitkommazahlen mit doppelter Genauigkeit umgewandelt.  Sind die
     Argumente keine Zahlen, wird ein vereinfachter Ausdruck mit der
     Funktion `bessel_i'  zurückgegeben.

     `scaled_bessel_i' ist eine Verbfunktion, die nicht für das
     symbolische Rechnen geeignet ist.  Für das symbolische Rechnen ist
     die Funktion `bessel_i'  zu verwenden.

     Beispiele:

          (%i1) scaled_bessel_i(1, 50);
          (%o1)                  .05599312389289544
          (%i2) scaled_bessel_i(1/2, 50);
          (%o2)                  .05641895835477567
          (%i3) scaled_bessel_i(v, x);
                                               - abs(x)
          (%o3)               bessel_i(v, x) %e

 -- Funktion: scaled_bessel_i0 (<z>)
     Entspricht `scaled_bessel_i(0,z)'.  Siehe `scaled_bessel_i'.


 -- Funktion: scaled_bessel_i1 (<z>)
     Entspricht `scaled_bessel_i(1,z)'.  Siehe `scaled_bessel_i'.



File: maxima.info,  Node: Hankel-Funktionen,  Next: Airy-Funktionen,  Prev: Bessel-Funktionen,  Up: Bessel-Funktionen und verwandte Funktionen

22.2.2 Hankel-Funktionen
------------------------

 -- Funktion: hankel_1 (<v>, <z>)
     Die Hankel-Funktion der ersten Art der Ordnung v mit dem Argument
     z.  Siehe A & S 9.1.3.  `hankel_1' ist definiert als

                H1 (z) = J (z) + %i Y (z)
                  v       v          v

     Die Hankel-Funktion `hankel_1' ist für das numerische und
     symbolische Rechnen geeignet.

     Maxima berechnet `hankel_1' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die
     numerische Berechnung für große Gleitkommazahlen ist nicht
     implementiert.  In diesem Fall gibt Maxima eine Substantivform
     zurück.

     Hat die Optionsvariable `besselexpand'  den Wert `true', werden
     Hankel-Funktionen `hankel_1' mit einer halbzahligen Ordnung v als
     Sinus- und Kosinusfunktionen entwickelt.

     Maxima kennt die Ableitung der Hankel-Funktion `hankel_1' nach dem
     zweiten Argument `z'.

     Siehe auch die Funktion `hankel_2'  sowie die Bessel-Funktionen in
     *note Bessel-Funktionen::.

     Beispiele:

     Numerische Berechnung.

          (%i1) hankel_1(1, 0.5);
          (%o1)       .2422684576748738 - 1.471472392670243 %i
          (%i2) hankel_1(1, 0.5+%i);
          (%o2)      - .2558287994862166 %i - 0.239575601883016

     Für eine komplex Ordnung kann Maxima keinen numerischen Wert
     berechnet.  Das Ergebnis ist eine Substantivform.

          (%i3) hankel_1(%i, 0.5+%i);
          (%o3)                hankel_1(%i, %i + 0.5)

     Entwicklung der Hankel-Funktion `hankel_1', wenn die
     Optionsvariable `besselexpand' den Wert `true' hat.

          (%i4) hankel_1(1/2, z), besselexpand:true;
                         sqrt(2) sin(z) - sqrt(2) %i cos(z)
          (%o4)          ----------------------------------
                                 sqrt(%pi) sqrt(z)

     Ableitung der Hankel-Funktion `hankel_1' nach dem Argument <z>.
     Die Ableitung nach der Ordnung <v> ist nicht implementiert.
     Maxima gibt eine Substantivform zurück.

          (%i5)  diff(hankel_1(v,z), z);
                       hankel_1(v - 1, z) - hankel_1(v + 1, z)
          (%o5)        ---------------------------------------
                                          2
          (%i6)  diff(hankel_1(v,z), v);
                                 d
          (%o6)                  -- (hankel_1(v, z))
                                 dv

 -- Funktion: hankel_2 (<v>, <z>)
     Die Hankel-Funktion der zweiten Art der Ordnung v mit dem Argument
     z.  Siehe A & S 9.1.4.  `hankel_2' ist definiert als

                H2 (z) = J (z) - %i Y (z)
                  v       v          v

     Die Hankel-Funktion `hankel_2' ist für das numerische und
     symbolische Rechnen geeignet.

     Maxima berechnet `hankel_2' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die
     numerische Berechnung für große Gleitkommazahlen ist nicht
     implementiert.  In diesem Fall gibt Maxima eine Substantivform
     zurück.

     Hat die Optionsvariable `besselexpand'  den Wert `true', werden
     Hankel-Funktionen `hankel_2' mit einer halbzahligen Ordnung v als
     Sinus- und Kosinusfunktionen entwickelt.

     Maxima kennt die Ableitung der Hankel-Funktion `hankel_2' nach dem
     zweiten Argument `z'.

     Für Beispiele siehe `hankel_1'.    Siehe auch die
     Bessel-Funktionen in *note Bessel-Funktionen::.


File: maxima.info,  Node: Airy-Funktionen,  Next: Struve-Funktionen,  Prev: Hankel-Funktionen,  Up: Bessel-Funktionen und verwandte Funktionen

22.2.3 Airy-Funktionen
----------------------

Die Airy-Funktionen Ai(z) und Bi(z) sind definiert in Abramowitz und
Stegun, Handbook of Mathematical Functions, Kapitel 10.4.  Die
Funktionen `y = Ai(z)' und `y = Bi(z)' sind zwei linear unabhängige
Lösungen der Airy-Differentialgleichung.

            2
           d y
           --- - y z = 0
             2
           dz

 -- Funktion: airy_ai (<z>)
     Die Airy-Funktion Ai(z) (A & S 10.4.2).

     Die Airy-Funktion `airy_ai' ist für das symbolische und numerische
     Rechnen geeignet.  Ist das Argument `z' eine reelle oder komplexe
     Gleitkommazahl, wird `airy_ai' numerisch berechnet.  Mit der
     Optionsvariablen `numer'  oder der Funktion `float'  kann die
     numerische Berechnung erzwungen werden, wenn das Argument eine
     ganze oder rationale Zahl ist.  Die numerische Berechnung für
     große Gleitkommazahlen ist nicht implementiert.

     Maxima kennt den speziellen Wert für das Argument `0'.

     Ist das Argument eine Liste, Matrix oder Gleichung wird die
     Funktion `airy_ai' auf die Elemente der Liste oder beide Seiten
     der Gleichung angewendet.  Siehe auch `distribute_over'.

     Die Ableitung `diff(airy_ai(z), z)' ist als `airy_dai(z)'
     implementiert.  Siehe die Funktion `airy_dai'.

     Weiterhin kennt Maxima das Integral der Airy-Funktion `airy_ai'.

     Siehe auch die Funktionen `airy_bi'  und `airy_dbi'.

     Beispiele:

     Numerische Berechnung für Gleitkommazahlen.  Für ganze und
     rationale Zahlen wird eine Substantivform zurückgegeben.  Maxima
     kennt den speziellen Wert für das Argument `0'.

          (%i1) airy_ai([0.5, 1.0+%i]);
          (%o1) [.2316936064808335, .06045830837183824
                                                    - .1518895658771814 %i]
          (%i2) airy_ai([1, 1/2]);
                                                   1
          (%o2)               [airy_ai(1), airy_ai(-)]
                                                   2
          (%i3) airy_ai(0);
                                          1
          (%o3)                     -------------
                                     2/3       2
                                    3    gamma(-)
                                               3

     Ableitungen und Integral der Airy-Funktion `airy_ai'.

          (%i4) diff(airy_ai(z), z);
          (%o4)                      airy_dai(z)
          (%i5) diff(airy_ai(z), z, 2);
          (%o5)                     z airy_ai(z)
          (%i6) diff(airy_ai(z), z, 3);
          (%o6)              z airy_dai(z) + airy_ai(z)
          (%i7) integrate(airy_ai(z), z);
                                             3
                                1    2  4   z
                hypergeometric([-], [-, -], --) z
                                3    3  3   9
          (%o7) ---------------------------------
                           2/3       2
                          3    gamma(-)
                                     3
                                                                      3
                            1/6       2                  2    4  5   z    2
                           3    gamma(-) hypergeometric([-], [-, -], --) z
                                      3                  3    3  3   9
                         - ------------------------------------------------
                                                4 %pi

 -- Funktion: airy_dai (<z>)
     Die Ableitung der Airy-Funktion `airy_ai'.

     Die Ableitung der Airy-Funktion `airy_dai' ist für das symbolische
     und numerische Rechnen geeignet.  Ist das Argument <z> eine reelle
     oder komplexe Gleitkommazahl, wird `airy_dai' numerisch berechnet.
     Mit der Optionsvariablen `numer'  oder der Funktion `float'  kann
     die numerische Berechnung erzwungen werden, wenn das Argument eine
     ganze oder rationale Zahl ist.  Die numerische Berechnung für
     große Gleitkommazahlen ist nicht implementiert.

     Maxima kennt den speziellen Wert für das Argument `0'.

     Ist das Argument eine Liste, Matrix oder Gleichung wird die
     Funktion `airy_dai' auf die Elemente der Liste oder beide Seiten
     der Gleichung angewendet.  Siehe auch `distribute_over'.

     Maxima kennt die Ableitung und das Integral der Funktion
     `airy_dai'.

     Siehe auch die Airy-Funktionen `airy_bi'  und `airy_dbi'.

     Für Beispiele siehe die Funktion `airy_ai'.


 -- Funktion: airy_bi (<z>)
     Die Airy-Funktion Bi(z) (A & S 10.4.3).

     Die Airy-Funktion `airy_bi' ist für das symbolische und numerische
     Rechnen geeignet.  Ist das Argument `z' eine reelle oder komplexe
     Gleitkommazahl, wird `airy_bi' numerisch berechnet.  Mit der
     Optionsvariablen `numer'  oder der Funktion `float'  kann die
     numerische Berechnung erzwungen werden, wenn das Argument eine
     ganze oder rationale Zahl ist.  Die numerische Berechnung für
     große Gleitkommazahlen ist nicht implementiert.

     Maxima kennt den speziellen Wert für das Argument `0'.

     Ist das Argument eine Liste, Matrix oder Gleichung wird die
     Funktion `airy_bi' auf die Elemente der Liste oder beide Seiten
     der Gleichung angewendet.  Siehe auch `distribute_over'.

     Die Ableitung `diff(airy_bi(z), z)' ist als `airy_dbi(z)'
     implementiert.  Siehe die Funktion `airy_dbi'.

     Weiterhin kennt Maxima das Integral der Airy-Funktion `airy_bi'.

     Siehe auch die Funktionen `airy_ai'  und `airy_dai'.

     Für Beispiele siehe die Funktion `airy_ai'.


 -- Funktion: airy_dbi (<z>)
     Die Ableitung der Airy-Funktion `airy_bi'.

     Die Ableitung der Airy-Funktion `airy_dbi' ist für das symbolische
     und numerische Rechnen geeignet.  Ist das Argument <z> eine reelle
     oder komplexe Gleitkommazahl, wird `airy_dbi' numerisch berechnet.
     Mit der Optionsvariablen `numer'  oder der Funktion `float'  kann
     die numerische Berechnung erzwungen werden, wenn das Argument eine
     ganze oder rationale Zahl ist.  Die numerische Berechnung für
     große Gleitkommazahlen ist nicht implementiert.

     Maxima kennt den speziellen Wert für das Argument `0'.

     Ist das Argument eine Liste, Matrix oder Gleichung wird die
     Funktion `airy_dbi' auf die Elemente der Liste oder beide Seiten
     der Gleichung angewendet.  Siehe auch `distribute_over'.

     Maxima kennt die Ableitung und das Integral der Funktion
     `airy_dbi'.

     Siehe auch die Airy-Funktionen `airy_ai'  und `airy_dai'.

     Für Beispiele siehe die Funktion `airy_ai'.



File: maxima.info,  Node: Struve-Funktionen,  Prev: Airy-Funktionen,  Up: Bessel-Funktionen und verwandte Funktionen

22.2.4 Struve-Funktionen
------------------------

 -- Funktion: struve_h (<v>, <z>)
     Die Struve-Funktion H der Ordnung v mit dem Argument z.  Siehe
     Abramowitz und Stegun, Handbook of Mathematical Functions, Kapitel
     12.  Die Definition ist

                                 inf
                                 ====                  k  2 k
                         z v + 1 \                (- 1)  z
                H (z) = (-)       >    ----------------------------------
                 v       2       /      2 k           3                3
                                 ====  2    gamma(k + -) gamma(v + k + -)
                                 k = 0                2                2

     Die Struve-Funktion `struve_h' ist für das numerische und
     symbolische Rechnen geeignet.  Im Unterschied zu den
     Bessel-Funktionen  ist jedoch die Implementation der Funktion
     `struve_h' weniger vollständig.

     Maxima berechnet `struve_h' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die
     numerische Berechnung für große Gleitkommazahlen ist nicht
     implementiert.  In diesem Fall gibt Maxima eine Substantivform
     zurück.

     Hat die Optionsvariable `besselexpand'  den Wert `true', wird die
     Struve-Funktion `struve_h' mit einer halbzahligen Ordnung v als
     Sinus- und Kosinusfunktionen entwickelt.

     Maxima kennt die Ableitung der Struve-Funktion `struve_h' nach dem
     Argument z.

     Siehe auch die Struve-Funktion `struve_l'.

     Beispiele:

          (%i1) struve_h(1, 0.5);
          (%o1)                  .05217374424234107
          (%i2) struve_h(1, 0.5+%i);
          (%o2)       0.233696520211436 %i - .1522134290663428
          (%i3) struve_h(3/2,x), besselexpand: true;
                                                     2
                            2 x sin(x) + 2 cos(x) - x  - 2
          (%o3)           - ------------------------------
                                                   3/2
                                sqrt(2) sqrt(%pi) x
          (%i4) diff(struve_h(v, x), x);
                             v
                            x
          (%o4) (------------------------- - struve_h(v + 1, x)
                            v           3
                 sqrt(%pi) 2  gamma(v + -)
                                        2
                                                    + struve_h(v - 1, x))/2

 -- Funktion: struve_l (<v>, <z>)
     Die modifizierte Struve-Funktion L der Ordnung v mit dem Argument
     z.  Siehe Abramowitz und Stegun, Handbook of Mathematical
     Functions, Kapitel 12.  Die Definition ist

                                 inf
                                 ====                  2 k
                         z v + 1 \                    z
                L (z) = (-)       >    ----------------------------------
                 v       2       /      2 k           3                3
                                 ====  2    gamma(k + -) gamma(v + k + -)
                                 k = 0                2                2

     Die Struve-Funktion `struve_l' ist für das numerische und
     symbolische Rechnen geeignet.  Im Unterschied zu den
     Bessel-Funktionen  ist jedoch die Implementation der Funktion
     `struve_l' weniger vollständig.

     Maxima berechnet `struve_l' numerisch für reelle und komplexe
     Gleitkommazahlen als Argumente für v und z.  Mit der Funktion
     `float'  oder der Optionsvariablen `numer'  kann die numerische
     Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die
     numerische Berechnung für große Gleitkommazahlen ist nicht
     implementiert.  In diesem Fall gibt Maxima eine Substantivform
     zurück.

     Hat die Optionsvariable `besselexpand'  den Wert `true', wird die
     Struve-Funktion `struve_l' mit einer halbzahligen Ordnung v als
     Sinus- und Kosinusfunktionen entwickelt.

     Maxima kennt die Ableitung der Struve-Funktion `struve_l' nach dem
     Argument z.

     Siehe auch die Struve-Funktion `struve_h'.

     Beispiele:

          (%i1) struve_l(1, 0.5);
          (%o1)                  .05394218262352267
          (%i2) struve_l(1, 0.5+%i);
          (%o2)       .1912720461247995 %i - .1646185598117401
          (%i3) struve_l(3/2,x), besselexpand: true;
                                                     2
                          2 x sinh(x) - 2 cosh(x) - x  + 2
          (%o3)           --------------------------------
                                                  3/2
                               sqrt(2) sqrt(%pi) x
          (%i4) diff(struve_l(v, x), x);
                             v
                            x
          (%o4) (------------------------- + struve_l(v + 1, x)
                            v           3
                 sqrt(%pi) 2  gamma(v + -)
                                        2
                                                    + struve_l(v - 1, x))/2


File: maxima.info,  Node: Gammafunktionen und verwandte Funktionen,  Next: Exponentielle Integrale,  Prev: Bessel-Funktionen und verwandte Funktionen,  Up: Spezielle Funktionen

22.3 Gammafunktionen und verwandte Funktionen
=============================================

Die Gammafunktion und die verwandten Funktionen wie die Beta-, Psi- und
die unvollständige Gammafunktion sind definiert in Abramowitz and
Stegun, Handbook of Mathematical Functions, Kapitel 6.

 -- Funktion: bffac (<x>, <fpprec>)
     Berechnet die Fakultät für große Gleitkommazahlen.  Das Argument
     <x> muss eine große Gleitkommazahl sein.  Das zweite Argument
     <fpprec> ist die Anzahl der Stellen, für die die Fakultät
     berechnet wird.  Das Ergebnis ist eine große Gleitkommazahl.

     Für das symbolische Rechnen mit der Fakultät und der Gammafunktion
     siehe die entsprechenden Funktionen `factorial'  und `gamma'.
     Maxima ruft intern die Funktion `bffac' auf, um die Fakultät
     `factorial' und die Gammafunktion `gamma' für eine große
     Gleitkommazahl numerisch zu berechnen.

     Siehe auch die Funktion `cbffac'  für die Berechnung der Fakultät
     für komplexe große Gleitkommazahlen.

     Beispiel:

          (%i1) bffac(10.5b0, 25);
          (%o1)             1.189942308396224845701304b7
          (%i2) fpprec:25$
          (%i3) 10.5b0!;
          (%o3)             1.189942308396224845701303b7

 -- Funktion: bfpsi (<n>, <x>, <fpprec>)
 -- Funktion: bfpsi0 (<x>, <fpprec>)
     `bfpsi' ist die Polygammafunktion für ein reelles Argument <x> und
     einer ganzzahligen Ordnung <n>.  `bfpsi0' ist die Digammafunktion.
     `bfpsi0(<x>, <fpprec>)' ist äquivalent zu `bfpsi(0, <x>,
     <fpprec>)'.

     Das Argument <x> der Funktionen `bfpsi' und `bfpsi0' muss eine
     große Gleitkommazahl sein.  Das Argument <fpprec> gibt die Anzahl
     der Stellen an, für die die Funktion berechnet wird.  Das Ergebnis
     ist eine große Gleitkommazahl.

     Für das symbolische Rechnen mit der Polygammafunktion siehe die
     Funktion `psi'.    Maxima ruft intern die Funktion `bfpsi' auf, um
     die Polygammafunktion für große Gleitkommazahlen numerisch zu
     berechnen.

     Beispiel:

          (%i1) bfpsi(0, 1, 25);
          (%o1)            - 5.772156649015328606065121b-1
          (%i2) fpprec:25$

          (%i3) psi[0](1.0b0);
          (%o3)            - 5.772156649015328606065121b-1

 -- Funktion: cbffac (<z>, <fpprec>)
     Berechnet die Fakultät für komplexe große Gleitkommazahlen.  Das
     Argument <z> ist eine komplexe große Gleitkommazahl.  Das zweite
     Argument <fpprec> ist die Anzahl der Stellen, für die die Fakultät
     berechnet wird.  Das Ergebnis ist eine komplexe große
     Gleitkommazahl.

     Für das symbolische Rechnen mit der Fakultät und der Gammafunktion
     siehe die entsprechenden Funktionen `factorial'  und `gamma'.
     Maxima ruft intern die Funktion `cbffac' auf, um die Fakultät
     `factorial' und die Gammafunktion `gamma' für eine komplexe große
     Gleitkommazahl numerisch zu berechnen.

     Siehe auch die Funktion `bffac'.


 -- Funktion: gamma (<z>)
     Die Definition der Gammafunktion ist (A & S 6.1.1)

                                 inf
                                /
                                [     z - 1   - t
                     gamma(z) = I    t      %e    dt
                                ]
                                /
                                 0

     Die Gammafunktion `gamma' ist für das numerische und symbolische
     Rechnen geeignet.  Für positive ganze Zahlen und rationale Zahlen
     als Argument <z> wird die Gammafunktion vereinfacht.  Für
     halbzahlige rationale Zahlen ist das Ergebnis der Vereinfachung
     eine rationale Zahl multipliziert mit `sqrt(%pi)'.  Die
     Vereinfachung für ganze Zahlen wird von der Optionsvariablen
     `factlim'  kontrolliert.  Für ganze Zahlen, die größer als
     `factlim' sind, kann es zu einem Überlauf bei der Berechnung der
     Gammafunktion kommen.  Entsprechend wird die Vereinfachung für
     rationale Zahlen von der Optionsvariablen `gammalim'  kontrolliert.

     Für negative ganze Zahlen ist die Gammafunktion `gamma' nicht
     definiert.

     Maxima berechnet `gamma' numerisch für reelle und komplexe
     Argumente <z>.  Das Ergebnis ist eine reelle oder komplexe
     Gleitkommazahl.

     `gamma' hat Spiegelsymmetrie.

     Hat die Optionsvariable `gamma_expand'  den Wert `true', entwickelt
     Maxima die Gammafunktion für Argumente der Form `z+n' und `z-n',
     wobei <n> eine ganze Zahl ist.

     Maxima kennt die Ableitung der Gammafunktion `gamma'.

     Siehe auch die Funktion `makegamma',  um Fakultäten und
     Betafunktionen in einem Ausdruck durch die Gammafunktion zu
     ersetzen.

     Die Euler-Mascheroni-Konstante ist `%gamma'.

     Beispiele:

     Vereinfachung für ganze Zahlen und rationale Zahlen.

          (%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
          (%o1)        [1, 1, 2, 6, 24, 120, 720, 5040, 40320]
          (%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                              sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
          (%o2)   [sqrt(%pi), ---------, -----------, ------------]
                                  2           4            8
          (%i3) map('gamma,[2/3,5/3,7/3]);
                                            2           1
                                    2 gamma(-)  4 gamma(-)
                                2           3           3
          (%o3)          [gamma(-), ----------, ----------]
                                3       3           9

     Numerische Berechnung für reelle und komplexe Argumente.

          (%i4) map('gamma,[2.5,2.5b0]);
          (%o4)     [1.329340388179137, 1.3293403881791370205b0]
          (%i5) map('gamma,[1.0+%i,1.0b0+%i]);
          (%o5) [0.498015668118356 - .1549498283018107 %i,
                    4.9801566811835604272b-1 - 1.5494982830181068513b-1 %i]

     `gamma' hat Spiegelsymmetrie.

          (%i6) declare(z,complex)$
          (%i7) conjugate(gamma(z));
          (%o7)                  gamma(conjugate(z))

     Maxima entwickelt `gamma(z+n)' und `gamma(z-n)', wenn die
     Optionsvariable `gamma_expand' den Wert `true' hat.

          (%i8) gamma_expand:true$

          (%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                         gamma(z)
          (%o9)             [z gamma(z), --------, z + 1]
                                          z - 1

     Die Ableitung der Gammafunktion `gamma'.

          (%i10) diff(gamma(z),z);
          (%o10)                  psi (z) gamma(z)
                                     0

 -- Optionsvariable: gamma_expand
     Standardwert: `false'

     Kontrolliert die Vereinfachung der Gammafunktion `gamma'  und
     verwandte Funktionen wie `gamma_incomplete'  für den Fall, dass
     das Argument die Form `z+n' oder `z-n' hat.  Dabei ist `z' ist ein
     beliebiges Argument und `n' ist eine ganze Zahl.

     Siehe die Funktion `gamma' für ein Beispiel.

 -- Funktion: log_gamma (<z>)
     Der Logarithmus der Gammafunktion.

 -- Funktion: gamma_incomplete (<a>, <z>)
     Die unvollständige Gammafunktion (A & S 6.5.2) die definiert ist
     als

                            inf
                           /
                           [     a - 1   - t
                           I    t      %e    dt
                           ]
                           /
                            z

 -- Funktion: gamma_incomplete_regularized (<a>, <z>)
     Regularisierte unvollständige Gammafunktion (A & S 6.5.1)

                         gamma_incomplete(a, z)
                         ----------------------
                                gamma(a)

 -- Funktion: gamma_incomplete_generalized (<a>, <z1>, <z2>)
     Verallgemeinerte unvollständige Gammafunktion

                            z2
                           /
                           [    a - 1   - t
                           I   t      %e    dt
                           ]
                           /
                            z1

 -- Optionsvariable: gammalim
     Standardwert: 1000000

     Kontrolliert die Vereinfachung der Gammafunktion für rationale
     Argumente.  Ist der Betrag des Arguments der Gammafunktion größer
     als `gammalim', wird die Gammafunktion nicht vereinfacht.  Damit
     wird verhindert, dass die Berechnung der Gammafunktion zu einem
     Überlauf führt und mit einem Fehler abbricht.

     Siehe auch die Optionsvariable `factlim',  um die Vereinfachung für
     ganze Zahlen zu kontrollieren.

 -- Funktion: makegamma (<expr>)
     Ersetzt Fakultäten sowie Binomial- und Betafunktionen durch die
     Gammafunktion `gamma'  im Ausdruck <expr>.

     Siehe auch die Funktion `makefact',  um stattdessen Fakultäten in
     den Ausdruck einzusetzen.

     Beispiel:

          (%i1) expr: binomial(a,b)*gamma(b+1)/gamma(a+1);
                             binomial(a, b) gamma(b + 1)
          (%o1)              ---------------------------
                                    gamma(a + 1)
          (%i2) makegamma(expr);
                                         1
          (%o2)                  ------------------
                                 gamma(- b + a + 1)

 -- Funktion: beta (<a>, <b>)
     Die Betafunktion ist definiert als `gamma(a) gamma(b)/gamma(a+b)'
     (A & S 6.2.1).

     Maxima vereinfacht die Betafunktion für positive ganze Zahlen <a>
     und <b> sowie rationale Zahlen, deren Summe `<a> + <b>' eine ganze
     Zahl ist.  Hat die Optionsvariable `beta_args_sum_to_integer'  den
     Wert `true', vereinfacht Maxima die Betafunktion für allgemeine
     Ausdrücke <a> und <b>, deren Summe eine ganze Zahl ist.

     Ist eines der Argumente <a> oder <b> Null, ist die Betafunktion
     nicht definiert.

     Im allgemeinen ist die Betafunktion nicht definiert für negative
     ganze Zahlen als Argument.  Ausnahme ist der Fall, dass <a = -n>,
     wobei <n> eine positive ganze Zahl und <b> eine positive ganze
     Zahl mit <b <= b> ist.  In diesem Fall kann eine analytische
     Fortsetzung der Betafunktion definiert werden.  Maxima gibt für
     diesen Fall ein Ergebnis zurück.

     Hat die Optionsvariable `beta_expand' den Wert `true', werden
     Ausdrücke wie `beta(a+n, b' und `beta(a-n, b)' oder `beta(a, b+n'
     und `beta(a, b-n)' entwickelt.

     Maxima berechnet die Betafunktion für reelle und komplexe
     Gleitkommazahlen numerisch.  Für die numerische Berechnung nutzt
     Maxima die Funktion `log_gamma' :

                     - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
                   %e

     Maxima kennt Symmetrieeigenschaften der Betafunktion.  Die
     Betafunktion ist symmetrisch und hat Spiegelsymmetrie.

     Maxima kennt die Ableitung der Betafunktion nach den Argumenten
     <a> und <b>.

     Mit der Funktion `makegamma'  kann die Betafunktion durch
     Gammafunktionen ersetzt werden.  Entsprechend ersetzt die Funktion
     `makefact'

     Betafunktionen in einem Ausdruck durch Fakultäten.

     Beispiele:

     Vereinfachung der Betafunktion, wenn eines der Argumente eine
     ganze Zahl ist.

          (%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                                         1   9      1
          (%o1)                         [--, -, ---------]
                                         12  4  a (a + 1)

     Vereinfachung der Betafunktion für zwei rationale Argumente, die
     sich zu einer ganzen Zahl summieren.

          (%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                                    3 %pi   2 %pi
          (%o2)                    [-----, -------, sqrt(2) %pi]
                                      8    sqrt(3)

     Hat die Optionsvariable `beta_args_sum_to_integer' den Wert `true',
     vereinfacht die Betafunktion für allgemeine Ausdrücke, die sich zu
     einer ganzen Zahl summieren.

          (%i3) beta_args_sum_to_integer:true$
          (%i4) beta(a+1,-a+2);
                                          %pi (a - 1) a
          (%o4)                         ------------------
                                        2 sin(%pi (2 - a))

     Die möglichen Ergebnisse, wenn eines der Argumente eine negative
     ganze Zahl ist.

          (%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                              1  1    1
          (%o5)                            [- -, -, - -]
                                              3  6    3

     Vereinfachungen, wenn die Optionsvariable `beta_expand' den Wert
     `true' hat.

          (%i6) beta_expand:true$
          (%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                              a beta(a, b)  beta(a, b) (b + a - 1)  a
          (%o7)              [------------, ----------------------, -]
                                 b + a              a - 1           b

     Die Betafunktion ist nicht definiert, wenn eines der Argumente
     Null ist.

          (%i7) beta(0,b);
          beta: expected nonzero arguments; found 0, b
           -- an error.  To debug this try debugmode(true);

     Numerische Berechnung der Betafunktion für reelle und komplexe
     Argumente.

          (%i8) beta(2.5,2.3);
          (%o8) .08694748611299981

          (%i9) beta(2.5,1.4+%i);
          (%o9) 0.0640144950796695 - .1502078053286415 %i

          (%i10) beta(2.5b0,2.3b0);
          (%o10) 8.694748611299969b-2

          (%i11) beta(2.5b0,1.4b0+%i);
          (%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i

     Die Betafunktion ist symmetrisch und hat Spiegelsymmetrie.

          (%i14) beta(a,b)-beta(b,a);
          (%o14)                                 0
          (%i15) declare(a,complex,b,complex)$
          (%i16) conjugate(beta(a,b));
          (%o16)                 beta(conjugate(a), conjugate(b))

     Ableitung der Betafunktion.

          (%i17) diff(beta(a,b),a);
          (%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                                0             0

 -- Funktion: beta_incomplete (<a>, <b>, <z>)
     Die Definition der unvollständigen Betafunktion ist (A & S 6.6.1)

                                 z
                                /
                                [         b - 1  a - 1
                                I  (1 - t)      t      dt
                                ]
                                /
                                 0

     Diese Definition ist möglich für realpart(a)>0 und realpart(b)>0
     sowie abs(z)<1.  Für andere Werte kann die unvollständige
     Betafunktion als eine verallgemeinerte Hypergeometrische Funktion
     definiert werden:

             gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z

     (Siehe functions.wolfram.com für eine Definition der
     unvollständigen Betafunktion.)

     Für negative ganze Zahlen a = -n und positive ganze Zahlen b = m
     mit m <= n kann die unvollständige Betafunktion definiert werden
     als

                                      m - 1           k
                                      ====  (1 - m)  z
                                n - 1 \            k
                               z       >    -----------
                                      /     k! (n - k)
                                      ====
                                      k = 0

     Maxima nutzt diese Definition, um die Funktion `beta_incomplete'
     für negative ganzzahlige Argumente <a> zu vereinfachen.

     Für positive ganzzahlige Argumente <a> vereinfacht
     `beta_incomplete' für jedes Argument <b> und <z>.  Entsprechend
     vereinfacht `beta_incomplete' für ein positives ganzzahliges
     Argument <b> mit der Ausnahme, dass <a> eine negative ganze Zahl
     ist.

     Für z=0 und realpart(a) > 0 hat `beta_incomplete' den speziellen
     Wert Null.  Für <z=1> und realpart(b) > 0 vereinfacht
     `beta_incomplete' zu einem Ausdruck mit der Betafunktion `beta(a,
     b)'.

     Maxima berechnet `beta_incomplete' numerisch für reelle und
     komplexe Gleitkommazahlen als Argumente.  Für die numerische
     Berechnung nutzt Maxima eine Entwicklung der unvollständigen
     Betafunktion als Kettenbruch.

     Hat die Optionsvariable `beta_expand'  den Wert `true', entwickelt
     Maxima Ausdrücke der Form `beta_incomplete(a+n, b, z)' und
     `beta_incomplete(a-n, b, z)', wobei `n' eine ganze Zahl ist.

     Maxima kennt die Ableitungen der unvollständigen Betafunktion nach
     den Variablen <a>, <b> und <z> und das Integral für die
     Integrationsvariable <z>.

     Beispiele:

     Vereinfachung für eine positive ganze Zahl als Argument <a>.

          (%i1) beta_incomplete(2,b,z);
                                                 b
                                      1 - (1 - z)  (b z + 1)
          (%o1)                       ----------------------
                                            b (b + 1)

     Vereinfachung für eine positive ganze Zahl als Argument <b>.

          (%i2) beta_incomplete(a,2,z);
                                                         a
                                        (a (1 - z) + 1) z
          (%o2)                         ------------------
                                            a (a + 1)

     Vereinfachung für positive ganzzahlige Argumente <a> und <b>.

          (%i3) beta_incomplete(3,2,z);
                                                         3
                                        (3 (1 - z) + 1) z
          (%o3)                         ------------------
                                                12

     <a> ist eine negative ganze Zahl mit b <= (-a).  Maxima vereinfacht
     für diesem Fall.

          (%i4) beta_incomplete(-3,1,z);
                                                 1
          (%o4)                              - ----
                                                  3
                                               3 z

     Für die speziellen Werte z=0 und z=1 vereinfacht Maxima.

          (%i5) assume(a>0,b>0)$
          (%i6) beta_incomplete(a,b,0);
          (%o6)                                 0
          (%i7) beta_incomplete(a,b,1);
          (%o7)                            beta(a, b)

     Numerische Berechnung für reelle Argumente.

          (%i8) beta_incomplete(0.25,0.50,0.9);
          (%o8)                          4.594959440269333
          (%i9)  fpprec:25$
          (%i10) beta_incomplete(0.25,0.50,0.9b0);
          (%o10)                    4.594959440269324086971203b0

     Für abs(z) > 1 ist das Ergebnis komplex.

          (%i11) beta_incomplete(0.25,0.50,1.7);
          (%o11)              5.244115108584249 - 1.45518047787844 %i

     Numerische Ergebnisse für komplexe Argumente.

          (%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
          (%o14)             2.726960675662536 - .3831175704269199 %i
          (%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
          (%o15)             13.04649635168716 %i - 5.802067956270001
          (%i16)

     Entwicklung, wenn `beta_expand' den Wert `true' hat.

          (%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                                 b  a
                             a beta_incomplete(a, b, z)   (1 - z)  z
          (%o23)             -------------------------- - -----------
                                       b + a                 b + a

          (%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                                     b  a - 1
                     beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
          (%o24)     -------------------------------------- - ---------------
                                     1 - a                         1 - a

     Ableitung und Integral der unvollständigen Betafunktion.

          (%i34) diff(beta_incomplete(a, b, z), z);
                                        b - 1  a - 1
          (%o34)                 (1 - z)      z
          (%i35) integrate(beta_incomplete(a, b, z), z);
                        b  a
                 (1 - z)  z
          (%o35) ----------- + beta_incomplete(a, b, z) z
                    b + a
                                                 a beta_incomplete(a, b, z)
                                               - --------------------------
                                                           b + a
          (%i36) factor(diff(%, z));
          (%o36)              beta_incomplete(a, b, z)

 -- Funktion: beta_incomplete_regularized (<a>, <b>, <z>)
     Die regularisierte unvollständige Beta Funktion (A & S 6.6.2), die
     definiert ist als

                        beta_incomplete(a, b, z)
                        ------------------------
                               beta(a, b)

     Wie bei der Funktion `beta_incomplete'  ist diese Definition nicht
     vollständig.  Siehe `functions.wolfram.com' für eine vollständige
     Definition der Funktion.

     `beta_incomplete_regularized' vereinfacht, wenn das Argument <a>
     oder <b> eine positive ganze Zahl ist.  Für Argumente `<z> = 0' und
     `realpart(<a>) > 0' vereinfacht die Funktion
     `beta_incomplete_regularized' zu `0'.  Für `<z> = 1' und
     `realpart(<b>) > 0' vereinfacht die Funktion
     `beta_incomplete_regularized' zu `1'.

     Maxima berechnet `beta_incomplete_regularized' für reelle und
     komplexe Gleitkommazahlen als Argumente numerisch.

     When `beta_expand' is `true', Maxima expands
     `beta_incomplete_regularized' for arguments a+n or a-n, where n is
     an integer.

     Hat die Optionsvariable `beta_expand'  den Wert `true', expandiert
     Maxima `beta_incomplete_regularized' für Argumente a+n oder a-n,
     wobei <n> eine ganze Zahl ist.

     Maxima kennt die Ableitung der Funktion
     `beta_incomplete_regularized' nach den Argumenten <a>, <b> und <z>
     sowie das Integral für das Argument <z>.

     Beispiele:

     Vereinfachung, wenn die Argumente <a> oder <b> ganze Zahlen sind.

          (%i1) beta_incomplete_regularized(2,b,z);
                                          b
          (%o1)                1 - (1 - z)  (b z + 1)
          (%i2) beta_incomplete_regularized(a,2,z);
                                                  a
          (%o2)                  (a (1 - z) + 1) z
          (%i3) beta_incomplete_regularized(3,2,z);
                                                  3
          (%o3)                  (3 (1 - z) + 1) z

     Für die speziellen Werte z=0 und z=1 vereinfacht Maxima.

          (%i4) assume(a>0,b>0)$

          (%i5) beta_incomplete_regularized(a,b,0);
          (%o5)                           0
          (%i6) beta_incomplete_regularized(a,b,1);
          (%o6)                           1

     Numerische Berechnung für reelle und komplexe Argumente.

          (%i7) beta_incomplete_regularized(0.12,0.43,0.9);
          (%o7)                   .9114011367359802
          (%i8) fpprec:32$

          (%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
          (%o9)         9.1140113673598075519946998779975b-1
          (%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
          (%o10)      .2865367499935405 %i - .1229959633346841
          (%i11) fpprec:20$

          (%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
          (%o12) 2.8653674999354036142b-1 %i - 1.2299596333468400163b-1

     Expansion, wenn `beta_expand' den Wert `true' hat.

          (%i13) beta_incomplete_regularized(a+1,b,z);
                                                               b  a
                                                        (1 - z)  z
          (%o13) beta_incomplete_regularized(a, b, z) - ------------
                                                        a beta(a, b)
          (%i14) beta_incomplete_regularized(a-1,b,z);
          (%o14) beta_incomplete_regularized(a, b, z)
                                                               b  a - 1
                                                        (1 - z)  z
                                                   - ----------------------
                                                     beta(a, b) (b + a - 1)

     Die Ableitung und das Integral der Funktion.

          (%i15) diff(beta_incomplete_regularized(a,b,z),z);
                                        b - 1  a - 1
                                 (1 - z)      z
          (%o15)                 -------------------
                                     beta(a, b)
          (%i16) integrate(beta_incomplete_regularized(a,b,z),z);
          (%o16) beta_incomplete_regularized(a, b, z) z
                                                                     b  a
                                                              (1 - z)  z
                    a (beta_incomplete_regularized(a, b, z) - ------------)
                                                              a beta(a, b)
                  - -------------------------------------------------------
                                             b + a

 -- Funktion: beta_incomplete_generalized (<a>, <b>, <z1>, <z2>)
     Die Definition der verallgemeinerten unvollständigen Betafunktion
     ist

                                z2
                               /
                               [          b - 1  a - 1
                               I   (1 - t)      t      dt
                               ]
                               /
                                z1

     Maxima vereinfacht `beta_incomplete_refularized' für positive
     ganzzahlige Argumente <a> und <b>.

     Ist realpart(a)>0 und z1=0 oder z2=0, vereinfacht Maxima
     `beta_incomplete_generalized' zu der Funktion `beta_incomplete'.
     Ist realpart(b)>0 und z1=1 oder <z2=1>, vereinfacht Maxima zu
     einem Ausdruck mit der Funktion `beta'  und `beta_incomplete'.

     Maxima berechnet `beta_incomplete_regularized' numerisch für
     reelle und komplexe Gleitkommazahlen in doppelter und beliebiger
     Genauigkeit.

     Hat die Optionsvariable `beta_expand'  den Wert `true', dann
     expandiert Maxima `beta_incomplete_generalized' für Argumente a+n
     und a-n, wobei <n> eine positive ganze Zahl ist.

     Maxima kennt die Ableitung der Funktion
     `beta_incomplete_generalized' nach den Variablen <a>, <b>, <z1>
     und <z2> sowie die Integrale für die Integrationsvariablen  <z1>
     und <z2>.

     Beispiele:

     Maxima vereinfacht `beta_incomplete_generalized', wenn <a> und <b>
     positive ganze Zahlen sind.

          (%i1) beta_incomplete_generalized(2,b,z1,z2);
                             b                      b
                     (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
          (%o1)      -------------------------------------------
                                      b (b + 1)
          (%i2) beta_incomplete_generalized(a,2,z1,z2);
                                        a                      a
                     (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
          (%o2)      -------------------------------------------
                                      a (a + 1)
          (%i3) beta_incomplete_generalized(3,2,z1,z2);
                        2      2                       2      2
                (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
          (%o3) -----------------------------------------------------------
                                            12

     Vereinfachung für die speziellen Werte z1=0, z2=0, z1=1 und z2=1.

          (%i4) assume(a > 0, b > 0)$
          (%i5) beta_incomplete_generalized(a,b,z1,0);
          (%o5)                    - beta_incomplete(a, b, z1)

          (%i6) beta_incomplete_generalized(a,b,0,z2);
          (%o6)                    - beta_incomplete(a, b, z2)

          (%i7) beta_incomplete_generalized(a,b,z1,1);
          (%o7)              beta(a, b) - beta_incomplete(a, b, z1)

          (%i8) beta_incomplete_generalized(a,b,1,z2);
          (%o8)              beta_incomplete(a, b, z2) - beta(a, b)

     Numerische Berechnung für reelle Argumente in doppelter und
     beliebiger Gleitkommagenauigkeit.

          (%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
          (%o9)                        .09638178086368676

          (%i10) fpprec:32$
          (%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
          (%o10)               9.6381780863686935309170054689964b-2

     Numerische Berechnung für komplexe Argumente in doppelter und
     beliebiger Gleitkommagenauigkeit.

          (%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
          (%o11)           - .09625463003205376 %i - .003323847735353769
          (%i12) fpprec:20$
          (%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
          (%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3

     Expansion für a+n oder a-n und <n> eine positive ganze Zahl, wenn
     `beta_expand' den Wert `true' hat.

          (%i14) beta_expand:true$

          (%i15) beta_incomplete_generalized(a+1,b,z1,z2);
                         b   a           b   a
                 (1 - z1)  z1  - (1 - z2)  z2
          (%o15) -----------------------------
                             b + a
                                a beta_incomplete_generalized(a, b, z1, z2)
                              + -------------------------------------------
                                                   b + a
          (%i16) beta_incomplete_generalized(a-1,b,z1,z2);

                 beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
          (%o16) -------------------------------------------------------
                                          1 - a
                                              b   a - 1           b   a - 1
                                      (1 - z2)  z2      - (1 - z1)  z1
                                    - -------------------------------------
                                                      1 - a

     Ableitung nach der Variablen <z1> und die Integrale für die
     Integrationsvariablen <z1> und <z2>.

          (%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                         b - 1   a - 1
          (%o17)               - (1 - z1)      z1
          (%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
          (%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                            + beta_incomplete(a + 1, b, z1)
          (%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
          (%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                            - beta_incomplete(a + 1, b, z2)

 -- Optionsvariable: beta_expand
     Standardwert: `false'

     Hat die Optionsvariable `beta_expand' den Wert `true', werden
     `beta(a,b)' und verwandte Funktionen für Argumente a+n oder a-n
     entwickelt, wobei <n> eine positive ganze Zahl ist.

 -- Optionsvariable: beta_args_sum_to_integer
     Standardwert: `false'

     Hat die Optionsvariable `beta_args_sum_to_integer' den Wert `true',
     vereinfacht Maxima die Funktion `beta(a,b)', wenn sich die
     Argumente <a> und <b> zu einer ganzen Zahlen summieren.  Siehe
     auch `beta'.


 -- Funktion: psi [<n>](<x>)
     Ist definiert als die Ableitung der Funktion `log(gamma(<x>))' der
     Ordnung `<n>+1'.  `psi[0](<x>)' ist die erste Ableitung,
     `psi[1](<x>)' ist die zweite Ableitung, usw.

     Maxima kann numerische Werte für reelle Gleitkommazahlen
     berechnen.  Weiterhin kann Maxima die Funktion `psi' für rationale
     Argumente zu exakten Werten vereinfachen.  Die Optionsvariablen
     `maxpsiposint',

     `maxpsinegint',  `maxpsifracnum'  und `maxpsifracdenom'
     kontrollieren, den Wertebereich der Argumente für den die Funktion
     `psi' vereinfacht.

     Die Funktion `bfpsi'  des `bffac'-Package kann numerische Werte der
     Funktion `psi' berechnen.

 -- Optionsvariable: maxpsiposint
     Standardwert: `20'

     Die Optionsvariable `maxpsiposint' kontrolliert die Vereinfachung
     der Funktion `psi'  und enthält eine obere positive Schranke.  Ist
     das Argument <x> der Funktion `psi' größer als `maxpsiposint',
     dann versucht Maxima nicht `psi[<n>](<x>)' zu vereinfachen.

     Siehe auch `maxpsifracdenom',  `maxpsifracnum'  und `maxpsinegint'.

     Beispiele:

          (%o1)                          20
          (%i2) psi[0](20);
                                 275295799
          (%o2)                  --------- - %gamma
                                 77597520
          (%i3) maxpsiposint:10;
          (%o3)                          10
          (%i4) psi[0](20);
          (%o4)                       psi (20)
                                         0
          (%i5) psi[0](10);
                                    7129
          (%o5)                     ---- - %gamma
                                    2520

 -- Optionsvariable: maxpsinegint
     Standardwert: `-10'

     Die Optionsvariable `maxpsinegint' kontrolliert die Vereinfachung
     der Funktion `psi'  und enthält eine untere negative Schranke.
     Ist das Argument <x> der Funktion `psi' kleiner als `maxpsinegint',
     dann versucht Maxima nicht `psi[<n>](<x>)' zu vereinfachen.

     Siehe auch `maxpsifracdenom',  `maxpsifracnum'  und `maxpsiposint'.

     Beispiele:

          (%i1) maxpsinegint:-10;
          (%o1)                         - 10
          (%i2) psi[0](-3/2);
                                                     8
          (%o2)                - 2 log(2) - %gamma + -
                                                     3
          (%i3) maxpsinegint:-1;
          (%o3)                          - 1
          (%i4) psi[0](-3/2);
                                             3
          (%o4)                       psi (- -)
                                         0   2
          (%i5) psi[0](-1/2);
          (%o5)                - 2 log(2) - %gamma + 2

 -- Optionsvariable: maxpsifracnum
     Standardwert: `6'

     Die Optionsvariable `maxpsifracnum' kontrolliert die Vereinfachung
     der Funktion `psi'.    Ist das Argument <x> der Funktion `psi' eine
     rationale Zahl kleiner als eins mit `p/q' und ist der Zähler `p'
     größer als `maxpsifracnum', dann versucht Maxima nicht
     `psi[<n>](<x>)' zu vereinfachen.

     Siehe auch `maxpsifracdenom',  `maxpsiposint'  und `maxpsinegint'.

     Beispiele:

          (%i1) maxpsifracnum: 6;
          (%o1)                           6
          (%i2) psi[0](5/6);
                      3 log(3)              sqrt(3) %pi
          (%o2)     - -------- - 2 log(2) + ----------- - %gamma
                         2                       2
          (%i3) maxpsifracnum: 3;
          (%o3)                           3
          (%i4) psi[0](5/6);
                                            5
          (%o4)                        psi (-)
                                          0 6

 -- Optionsvariable: maxpsifracdenom
     Standardwert: `6'

     Die Optionsvariable `maxpsifracdenom' kontrolliert die
     Vereinfachung der Funktion `psi'.    Ist das Argument <x> der
     Funktion `psi' eine rationale Zahl kleiner als eins mit `p/q' und
     ist der Nenner `q' größer als `maxpsifracdenom', dann versucht
     Maxima nicht `psi[<n>](<x>)' zu vereinfachen.

     Siehe auch `maxpsifracnum',  `maxpsiposint'  und `maxpsinegint'.

     Beispiele:

          (%i1) maxpsifracdenom: 6;
          (%o1)                           6
          (%i2) psi[0](1/6);
                      3 log(3)              sqrt(3) %pi
          (%o2)     - -------- - 2 log(2) - ----------- - %gamma
                         2                       2
          (%i3) maxpsifracdenom: 4;
          (%o3)                           4
          (%i4) psi[0](1/6);
                                            1
          (%o4)                        psi (-)
                                          0 6
          (%i5) psi[0](1/5);
                                            1
          (%o5)                        psi (-)
                                          0 5
          (%i6) psi[0](1/4);
                                           %pi
          (%o6)               - 3 log(2) - --- - %gamma
                                            2

 -- Funktion: makefact (<expr>)
     Ersetzt Binomial-, Gamma- und Beta-Funktionen, die im Ausdruck
     <expr> auftreten, durch Fakultäten.

     Siehe auch die Funktion `makegamma'.


 -- Funktion: numfactor (<expr>)
     Gibt einen numerischen Faktor des Produktes <expr> zurück.  Ist
     <expr> kein Produkt oder enthält das Produkt keinen numerischen
     Faktor ist die Rückgabe `1'.

     Beispiel:

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8



Local Variables:
coding: iso-8859-1
End:
