<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on April, 4 2011 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 25. Muster und Regeln</title>

<meta name="description" content="Maxima Manual: 25. Muster und Regeln">
<meta name="keywords" content="Maxima Manual: 25. Muster und Regeln">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Muster-und-Regeln"></a>
<a name="SEC179"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_24.html#SEC178" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC180" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC175" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC182" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 25. Muster und Regeln </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC180">25.1 Einf&uuml;hrung in Muster und Regeln</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC181">25.2 Funktionen und Variablen f&uuml;r Muster und Regeln</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Einf_00fchrung-in-Muster-und-Regeln"></a>
<a name="SEC180"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC179" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC181" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC179" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC179" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC182" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.1 Einf&uuml;hrung in Muster und Regeln </h2>

<p>Dieses Kapitel beschreibt die nutzerdefinierte Mustererkennung und
Vereinfachungsregeln.  Es gibt zwei verschiedene Gruppen an Funktionen, die eine
etwas unterschiedliche Mustererkennung implementieren.  Die eine Gruppe
enth&auml;lt die Funktionen <code><a href="#tellsimp">tellsimp</a></code>,
 <code><a href="#tellsimpafter">tellsimpafter</a></code>,

<code><a href="#defmatch">defmatch</a></code>,
 <code><a href="#defrule">defrule</a></code>,
 <code><a href="#apply1">apply1</a></code>,
 <code><a href="#applyb1">applyb1</a></code>
 und
<code><a href="#apply2">apply2</a></code>.
  In der anderen Gruppe sind die Funktionen <code><a href="#let">let</a></code>
 und
<code><a href="#letsimp">letsimp</a></code>
 enthalten.  Beide Mustererkennungsverfahren verwenden die
Funktion <code><a href="#matchdeclare">matchdeclare</a></code>,
 um Muster zu definieren.
</p>
<p>Regeln, die mit den Funktionen <code>tellsimp</code> und <code>tellsimpafter</code>
definiert werden, werden von Maxima automatisch bei der Vereinfachung von
Ausdr&uuml;cken angewendet.  Regeln die mit den Funktionen <code>defmatch</code>, 
<code>defrule</code> oder <code>let</code> definiert werden, werden durch den Aufruf einer 
Funktion angewendet.
</p>
<p>Es gibt zus&auml;tzliche Mechanismen wie <code><a href="maxima_17.html#tellrat">tellrat</a></code>,
 um Regeln auf Polynome
anzuwenden und weitere Funktionen der kommutativen und nicht-kommutativen
Algebra in dem <code><a href="maxima_32.html#SEC208">affine</a></code>
-Paket.
</p>
<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-Muster-und-Regeln"></a>
<a name="SEC181"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC180" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC182" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC179" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC179" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC182" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 25.2 Funktionen und Variablen f&uuml;r Muster und Regeln </h2>

<p><a name="apply1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>apply1</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1336"></a>
</dt>
<dd><p>Wendet die Regel <var>rule_1</var> auf den Ausdruck <var>expr</var> solange an, bis die
Anwendung fehlschl&auml;gt.  Dann wird die Regel von links nach rechts auf alle
Teilausdr&uuml;cke von <var>expr</var> angewendet.  Ist <var>expr_2</var> das Ergebnis, dann
wird die Regel <var>rule_2</var> auf gleiche Weise auf den Ausdruck <var>expr_2</var>
angewendet.  Zuletzt wird die Regel <var>rule_n</var> angewendet.  Das letzte
Ergebnis wird zur&uuml;ckgegeben.
</p>
<p>Die Optionsvariable <code><a href="#maxapplydepth">maxapplydepth</a></code>
 ist die gr&ouml;&szlig;te
Verschachtelungstiefe f&uuml;r die die Funktionen <code>apply1</code> und
<code><a href="#apply2">apply2</a></code>
 auf einen Ausdruck angewendet werden.
</p>
<p>Siehe auch <code><a href="#applyb1">applyb1</a></code>,
 <code><a href="#apply2">apply2</a></code>
 und <code><a href="#let">let</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o1)               trig1 : tan(x) -&gt; ------
                                      cos(x)
(%i2) defrule(trig2, cot(x), 1/tan(x));
                                        1
(%o2)               trig2 : cot(x) -&gt; ------
                                      tan(x)
(%i3) apply1(cot(x), trig1, trig2);
                               1
(%o3)                        ------
                             tan(x)
(%i4) apply1(cot(x), trig2, trig1);
                             cos(x)
(%o4)                        ------
                             sin(x)
</pre></dd></dl>

<p><a name="apply2"></a>
</p><dl>
<dt><u>Funktion:</u> <b>apply2</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1337"></a>
</dt>
<dd><p>Zun&auml;chst werden nacheinander die Regeln <var>rule_1</var>, <var>rule_2</var>, &hellip; 
auf einen Ausdruck angewendet.  Schl&auml;gt die Anwendung aller Regeln fehl, dann 
werden die Regeln nacheinander auf Teilausdr&uuml;cke von <var>expr</var> angewendet.
Kann eine der Regeln erfolgreich angewendet werden, wird die Anwendung aller 
Regeln auf den Teilausdruck wiederholt.
</p>
<p>Die Optionsvariable <code><a href="#maxapplydepth">maxapplydepth</a></code>
 ist die gr&ouml;&szlig;te
Verschachtelungstiefe f&uuml;r die die Funktionen <code><a href="#apply1">apply1</a></code>
 und <code>apply2</code>
auf einen Ausdruck angewendet werden.
</p>
<p>Siehe auch <code><a href="#apply1">apply1</a></code>,
 <code><a href="#applyb1">applyb1</a></code>
 und <code><a href="#let">let</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                      sin(x)
(%o1)               trig1 : tan(x) -&gt; ------
                                      cos(x)
(%i2) defrule(trig2, cot(x), 1/tan(x));
                                        1
(%o2)               trig2 : cot(x) -&gt; ------
                                      tan(x)
(%i3) apply2(cot(x), trig1, trig2);
                             cos(x)
(%o3)                        ------
                             sin(x)
(%i4) apply2(cot(x), trig2, trig1);
                             cos(x)
(%o4)                        ------
                             sin(x)
</pre></dd></dl>

<p><a name="applyb1"></a>
</p><dl>
<dt><u>Funktion:</u> <b>applyb1</b><i> (<var>expr</var>, <var>rule_1</var>, &hellip;, <var>rule_n</var>)</i>
<a name="IDX1338"></a>
</dt>
<dd><p>Wendet wiederholt die Regel <var>rule_1</var> auf den tiefsten Teilausdruck an.
Schl&auml;gt die Anwendung fehlt, wird der Teilausdruck eine Ebene h&ouml;her 
betrachtet, bis <var>rule_1</var> auf die oberste Ebene des Ausdrucks <var>expr</var>
angewendet wird.  Danach wird auf gleiche Weise die Regel <var>rule_2</var>
auf den Ausdruck <var>expr</var> angewendet.  Nachdem die letzte Regel <var>rule_n</var>
angewendet wurde, wird das Ergebnis zur&uuml;ckgegeben.
</p>
<p><code>applyb1</code> ist vergleichbar mit <code><a href="#apply1">apply1</a></code>
 mit dem Unterschied, dass
die Regeln Bottum-Up angewendet werden.
</p>
<p><code><a href="#maxapplyheight">maxapplyheight</a></code>
 ist die gr&ouml;&szlig;te Verschachtelungstiefe f&uuml;r die
<code>applyb1</code> angewendet wird.
</p>
<p>Siehe auch <code><a href="#apply1">apply1</a></code>,
 <code><a href="#apply2">apply2</a></code>
 und <code><a href="#let">let</a></code>.
</p>

</dd></dl>

<p><a name="clear_005frules"></a>
</p><dl>
<dt><u>Funktion:</u> <b>clear_rules</b><i> ()</i>
<a name="IDX1339"></a>
</dt>
<dd><p>F&uuml;hrt das Kommando <code>kill(rules)</code> aus und setzt den Z&auml;hler f&uuml;r die
Benennung der Regeln der Addition, der Multiplikation und der Exponentiation
zur&uuml;ck.  Siehe auch <code><a href="maxima_4.html#kill">kill</a></code>.
</p>
</dd></dl>

<p><a name="current_005flet_005frule_005fpackage"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>current_let_rule_package</b>
<a name="IDX1340"></a>
</dt>
<dd><p>Standardwert: <code>default_let_rule_package</code>
</p>
<p><code>current_let_rule_package</code> enth&auml;lt den Namen des Regel-Paketes, das von 
den <code>let</code>-Funktionen verwendet wird.  Der Optionsvariablen kann jedes mit 
dem Kommando <code>let</code> definierte Regelpaket zugewiesen werden.
</p>
<p>Wird das Kommando <code>letsimp(expr, rule_pkg_name</code> ausgef&uuml;hrt, dann wird 
f&uuml;r das aktuelle Kommando das Paket <code>rule_pkg_name</code> verwendet.  Der 
Wert der Variablen <code>current_let_rule_package</code> wird nicht ge&auml;ndert.
</p></dd></dl>

<p><a name="default_005flet_005frule_005fpackage"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>default_let_rule_package</b>
<a name="IDX1341"></a>
</dt>
<dd><p>Standardwert: <code>default_let_rule_package</code>
</p>
<p><code>default_let_rule_package</code> ist der Name des Regelpaketes, das verwendet 
wird, wenn kein Regelpaket mit der Funktion <code>let</code> explizit definiert wurde.
</p></dd></dl>

<p><a name="defmatch"></a>
</p><dl>
<dt><u>Funktion:</u> <b>defmatch</b><i> (<var>progname</var>, <var>pattern</var>, <var>x_1</var>, &hellip;, <var>x_n</var>)</i>
<a name="IDX1342"></a>
</dt>
<dt><u>Funktion:</u> <b>defmatch</b><i> (<var>progname</var>, <var>pattern</var>)</i>
<a name="IDX1343"></a>
</dt>
<dd>
<p>Definiert eine Aussagefunktion <code><var>progname</var>(<var>expr</var>, <var>x_1</var>, ...,
<var>x_n</var>)</code>, die einen Ausdruck <var>expr</var> testet, um zu pr&uuml;fen, ob dieser
das Muster <var>pattern</var> enth&auml;lt.
</p>

<p><var>pattern</var> ist ein Ausdruck, der die Musterargumente <var>x_1</var>, &hellip;, 
<var>x_n</var> enth&auml;lt, sowie weitere Mustervariablen enthalten kann, die mit der
Funktion <code><a href="#matchdeclare">matchdeclare</a></code>
 deklariert sind.  Alle Variable, die nicht als
Musterargumente der Funktion <code>defmatch</code> oder als Mustervariable mit
<code>matchdeclare</code> definiert sind, entsprechen sich selbst.
</p>

<p>Das erste Argument der definierten Aussagefunktion <var>progname</var> ist ein
Ausdruck, f&uuml;r den das Muster gepr&uuml;ft wird.  Die weiteren Argumente sind die
Variablen, die den Musterargumenten <var>x_1</var>, &hellip;, <var>x_n</var> des Musters
<var>pattern</var> entsprechen.
</p>

<p>Ist der Test erfolgreich, gibt die Aussagefunktion <var>progname</var> eine Liste
mit Gleichungen zur&uuml;ck.  Die linke Seite der Gleichungen sind die
Musterargumente und Mustervariablen und die rechte Seite sind die
Teilausdr&uuml;cke f&uuml;r die eine &Uuml;bereinstimmung gefunden wurde.  Den
Mustervariablen, jedoch nicht den Musterargumenten, werden die Ergebnisse
zugewiesen.  Ist der Test nicht erfolgreich, ist die R&uuml;ckgabe <code>false</code>.
</p>

<p>Ein Muster, dass keine Musterargumente oder Mustervariablen enth&auml;lt, hat den
R&uuml;ckgabewert <code>true</code>, wenn der Test erfolgreich ist.
</p>

<p>Siehe auch <code><a href="#matchdeclare">matchdeclare</a></code>,
 <code><a href="#defrule">defrule</a></code>,
 <code><a href="#tellsimp">tellsimp</a></code>
 und
<code><a href="#tellsimpafter">tellsimpafter</a></code>.
</p>

<p>Beispiele:
</p>

<p>Definiere eine Funktion <code>linearp(expr, x)</code>, die testet, ob ein Ausdruck
<var>expr</var> die Form <code>a*x+b</code> hat, wobei <code>a</code> und <code>b</code> die Variable
<var>x</var> nicht enthalten und <code>a</code> von Null verschieden ist.  Die Definition
enth&auml;lt das Musterargument <var>x</var>, so dass die Linearit&auml;t des Ausdrucks
f&uuml;r eine beliebige Variable getestet werden kann.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), 
                    b, freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
(%i6) x;
(%o6)                           x
</pre>

<p>Wie oben wird eine Testfunktion definiert, die pr&uuml;ft ob ein Ausdruck
<var>expr</var> linear ist.  In diesem Fall wird kein Musterargument angegeben.  Der 
Test kann nur feststellen, ob ein Ausdruck linear in der Variablen <var>x</var> ist.
Eine andere Variable ist nicht m&ouml;glich.
</p>
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre>

<p>Definiere eine Testfunktion <code>checklimits(expr)</code>, die pr&uuml;ft, ob ein
Ausdruck <var>expr</var> ein bestimmtes Integral ist.
</p>
<pre class="example">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
(%i4) matchdeclare (x, atom);
(%o4)                         done
(%i5) simp : false;
(%o5)                         false
(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
(%i7) simp : true;
(%o7)                         true
(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre></dd></dl>

<p><a name="defrule"></a>
</p><dl>
<dt><u>Funktion:</u> <b>defrule</b><i> (<var>rulename</var>, <var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1344"></a>
</dt>
<dd>
<p>Definiert eine Regeln, um das Muster <var>pattern</var> durch den Ausdruck
<var>replacement</var> zu ersetzen.  Wird die Regeln mit dem Namen <var>rulename</var>
mit den Funktionen <code><a href="#apply1">apply1</a></code>,
 <code><a href="#apply2">apply2</a></code>
 oder <code><a href="#applyb1">applyb1</a></code>
 auf 
einen Ausdruck angewendet, wird alle Teilausdr&uuml;cke, die dem Muster
<var>pattern</var> entsprechen durch den Ausdruck <var>replacement</var> ersetzt.
</p>

<p>Die Regel <var>rulename</var> kann auch als eine Funktion angewendet werden, die,
falls vorhanden, das Muster <var>pattern</var> durch <var>replacement</var> ersetzt.
</p>
<p>Beispiele:
</p>
<p>Es wird eine Regel definiert, um den Ausdruck <code>sin(x)^2</code> nach 
<code>1-cos(x)^2</code> transformiert.  Diese Definition funktioniert nur f&uuml;r einen
Ausdruck <var>sin(x)^2</var>.
</p>
<pre class="example">(%i1) defrule(trig, sin(x)^2, 1-cos(x)^2);
                            2              2
(%o1)             trig : sin (x) -&gt; 1 - cos (x)
(%i2) trig(sin(x)^2);
                                  2
(%o2)                      1 - cos (x)
(%i3) trig(sin(y)^2);
(%o3)                         false
</pre>
<p>In diesem Fall wird zun&auml;chst mit der Funktion <code><a href="#matchdeclare">matchdeclare</a></code>
 eine 
Mustervariable <var>a</var> definiert, der jeder Ausdruck zugewiesen werden kann und
die als Argument der Ersetzungsregel verwendet wird.  Jetzt kann das Argument
der Sinusfunktion ein beliebiger Ausdruck sein.
</p>
<pre class="example">(%i1) matchdeclare(a, true);
(%o1)                         done
(%i2) defrule(trig, sin(a)^2, 1-cos(a)^2);
                            2              2
(%o2)             trig : sin (a) -&gt; 1 - cos (a)
(%i3) trig(sin(x)^2);
                                  2
(%o3)                      1 - cos (x)
(%i4) trig(sin(exp(x))^2);
                                 2   x
(%o4)                     1 - cos (%e )
</pre>
<p>Die Ersetzungsregel kann mit der Funktion <code><a href="#apply1">apply1</a></code>
 auf verschachtelte
Ausdr&uuml;cke angewendet werden.
</p>
<pre class="example">(%i5) trig(exp(sin(x)^2));
(%o5)                         false
(%i6) apply1(exp(sin(x)^2), trig);
                                   2
                            1 - cos (x)
(%o6)                     %e
</pre></dd></dl>

<p><a name="disprule"></a>
</p><dl>
<dt><u>Funktion:</u> <b>disprule</b><i> (<var>rulename_1</var>, &hellip;, <var>rulename_2</var>)</i>
<a name="IDX1345"></a>
</dt>
<dt><u>Funktion:</u> <b>disprule</b><i> (all)</i>
<a name="IDX1346"></a>
</dt>
<dd>
<p>Zeigt die Regeln mit den Namen <var>rulename_1</var>, &hellip;, <var>rulename_n</var> an.
Den einzelnen Regeln werden mit einer Zwischenmarke 
<code><a href="maxima_4.html#linechar">%t</a></code>
 angezeigt.
</p>

<p>Mit dem Kommando <code>disprule(all)</code> werden alle Regeln angezeigt.
</p>

<p><code>disprule</code> wertet die Argumente nicht aus.  Der R&uuml;ckgabewert ist eine
Liste mit den Zwischenmarken, denen eine Regel zugewiesen wurde.
</p>

<p>Sieh auch die Funktion <code><a href="#letrules">letrules</a></code>,
 die die Regeln ausgibt, die mit
der Funktion <code><a href="#let">let</a></code>
 definiert wurden.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
(%i4) disprule (foorule1, &quot;+rule1&quot;, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
(%i6) ''%;
(%o6) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x), 
     +rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre></dd></dl>

<p><a name="let"></a>
</p><dl>
<dt><u>Funktion:</u> <b>let</b><i> (<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, &hellip;, <var>arg_n</var>)</i>
<a name="IDX1347"></a>
</dt>
<dt><u>Funktion:</u> <b>let</b><i> ([<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, &hellip;, <var>arg_n</var>], <var>package_name</var>)</i>
<a name="IDX1348"></a>
</dt>
<dd>
<p>Definiert eine Ersetzungsregel, die mit der Funktion <code><a href="#letsimp">letsimp</a></code>
 auf einen
Ausdruck angewendet wird, so dass <var>prod</var> durch <var>repl</var> ersetzt wird.
Das Argument <var>prod</var> ist ein Produkt von positiven oder negativen Potenzen
der folgenden Terme:
</p>

<ul>
<li>
Atome, nach denen die Funktion <code>letsimp</code> w&ouml;rtlich sucht, wenn kein Muster
mit der Funktion <code><a href="#matchdeclare">matchdeclare</a></code>
 definiert wurde, sowie Atome, denen mit der
Funktion <code>matchdeclare</code> eine Aussagefunktion zugeordnet wurde.

</li><li>
Terme wie <code>sin(x)</code>, <code>n!</code> oder <code>f(x,y)</code>.  Wie f&uuml;r Atome
sucht die Funktion <code>letsimp</code> nach w&ouml;rtlichen &Uuml;bereinstimmungen, sowie
nach &Uuml;bereinstimmungen, die mit der Funktion <code>matchdeclare</code> f&uuml;r einen
Ausdruck definiert wurde.
</li></ul>


<p>Ein Term mit einer positiven Potenz stimmt mit einem Ausdruck nur dann
&uuml;berein, wenn dieser mindestens dieselbe Potenz hat.  Entsprechend gilt f&uuml;r
einen Term mit einer negativen Potenz, dass dieser dann mit einem Ausdruck
&uuml;bereinstimmt, wenn dieser mindestens dieselbe negative Potenz hat.  F&uuml;r
negative Potenzen muss weiterhin die Optionsvariable <code><a href="#letrat">letrat</a></code>
 den Wert
<code>true</code> haben.
</p>

<p>Hat die Funktion <code>let</code> eine Aussagefunktion <var>predname</var> als Argument,
mit dem Argumenten <var>arg_1</var>, &hellip;, <var>arg_n</var>, wird eine vorl&auml;ufige
&Uuml;bereinstimmung dann festgestellt wenn der Ausdruck 
<code>predname(arg_1', ..., arg_n')</code> das Ergebnis <code>true</code> hat.  Die
Argumente <var>arg_i</var> k&ouml;nnen die Namen von Variablen oder Termen sein, die
im Ausdruck <var>pred</var> auftreten.  <var>repl</var> kann ein beliebiger rationaler 
Ausdruck sein.  Treten irgendwelche der Symbole oder Argumente aus <var>prod</var>
im Argument <var>repl</var> auf, wird die entsprechende Substitution ausgef&uuml;hrt.
</p>

<p>Die Optionsvariable <code><a href="#letrat">letrat</a></code>
 kontrolliert die Vereinfachung von Quotienten
durch <code><a href="#letsimp">letsimp</a></code>.
  Hat <code>letrat</code> den Wert <code>false</code>, werden der
Z&auml;hler und der Nenner eines Bruches einzeln vereinfacht.  Der Bruch als ganzes
wird dagegen nicht vereinfacht.  Hat die Optionsvariable <code>letrat</code> den Wert
<code>false</code>, werden nacheinander der Z&auml;hler, der Nenner und dann der Bruch
vereinfacht.
</p>

<p>Die Funktion <code><a href="#letsimp">letsimp</a></code>
 kann mit verschiedenen Regelpaketen arbeiten.  Jedes
Regelpaket kann eine beliebige Anzahl an <code>let</code>-Regeln enthalten und 
erh&auml;lt vom Nutzer einen Namen.  Das Kommando <code>let([<var>prod</var>, 
<var>repl</var>, <var>predname</var>, <var>arg_1</var>, ..., <var>arg_n</var>], <var>package_name</var>)</code>
f&uuml;gt die Regel <var>predname</var> dem Paket <var>package_name</var> hinzu.  Das 
Kommando <code>letsimp(<var>expr</var>, <var>package_name1</var>, <var>package_name2</var>, 
...)</code> ist &auml;quivalent zu <code>letsimp(<var>expr</var>, <var>package_name1</var>)</code>, dem
das Kommando <code>letsimp(%, <var>package_name2</var>)</code>, &hellip; folgt.
</p>

<p>Die Optionsvariable <code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code>
 enth&auml;lt den Namen des
Regelpaketes, das aktuell von der Funktion <code>letsimp</code> verwendet wird.  Der
Optionsvariablen kann jedes mit dem Kommando <code>let</code> definierte Regelpaket 
zugewiesen werden.  Wird mit <code>letsimp(<var>expr</var>, <var>package_name</var>)</code>
ein Regelpaket als Argument &uuml;bergeben, wird dieses anstatt dem in 
<code>current_let_rule_package</code> enthaltene Regelpaket f&uuml;r die Vereinfachung
verwendet.  Wenn nicht anders spezifiziert, hat <code>current_let_rule_package</code>
den Standardwert <code><a href="#default_005flet_005frule_005fpackage">default_let_rule_package</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre></dd></dl>

<p><a name="letrat"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>letrat</b>
<a name="IDX1349"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat die Optionsvariable <code>letrat</code> den Wert <code>false</code>, werden der Z&auml;hler
und der Nenner eines Bruches einzeln vereinfacht.  Der Bruch als ganzes wird
dagegen nicht vereinfacht.
</p>

<p>Hat die Optionsvariable <code>letrat</code> den Wert <code>false</code>, werden nacheinander
der Z&auml;hler, der Nenner und dann der Bruch vereinfacht.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre></dd></dl>

<p><a name="letrules"></a>
</p><dl>
<dt><u>Funktion:</u> <b>letrules</b><i> ()</i>
<a name="IDX1350"></a>
</dt>
<dt><u>Funktion:</u> <b>letrules</b><i> (<var>package_name</var>)</i>
<a name="IDX1351"></a>
</dt>
<dd>
<p>Zeigt die Regeln eines Regel-Paketes an.  Das Kommando <code>letrules()</code> zeigt
die Regeln des aktuellen Regel-Paketes an, das in der Optionsvariablen
<code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code>
 enthalten ist.  Das Kommando 
<code>letrules(<var>package_name</var>)</code> zeigt die Regeln des Paketes
<var>package_name</var> an.
</p>

<p>Wenn der Optionsvariablen <code>current_let_rule_package</code> kein Paket zugewiesen
wurde, enth&auml;lt es den Standardwert <code><a href="#default_005flet_005frule_005fpackage">default_let_rule_package</a></code>.
</p>


<p>Siehe auch die Funktion <code><a href="#disprule">disprule</a></code>,
 um Regeln anzuzeigen, die mit
<code><a href="#tellsimp">tellsimp</a></code>,
 <code><a href="#tellsimpafter">tellsimpafter</a></code>
 und <code><a href="#defrule">defrule</a></code>
 definiert wurden.
</p>
<p>Beispiel:
</p>
<p>Im folgenden Beispiel werden einem Paket mit dem Namen <code>trigrules</code> zwei
Regeln hinzugef&uuml;gt.  Die Regeln werden mit dem Kommando 
<code>letrules(trigrules)</code> angezeigt.  Wird das Paket zum aktuellen Paket
erkl&auml;rt, indem es der Variablen <code>current_let_rule_package</code> zugewiesen
wird, dann werden die Regeln auch mit dem Kommando <code>letrules()</code> angezeigt.
</p>
<pre class="example">(%i1) let([sin(x)^2, 1-cos(x)^2], trigrules);
                        2               2
(%o1)                sin (x) --&gt; 1 - cos (x)
(%i2) let([tan(x), sin(x)/cos(x)], trigrules);
                                   sin(x)
(%o2)                   tan(x) --&gt; ------
                                   cos(x)
(%i3) letrules(trigrules);
                                   sin(x)
                        tan(x) --&gt; ------
                                   cos(x)

                        2               2
                     sin (x) --&gt; 1 - cos (x)

(%o3)                         done
(%i4) letrules();
(%o4)                         done
(%i5) current_let_rule_package: trigrules;
(%o5)                       trigrules
(%i6) letrules();
                                   sin(x)
                        tan(x) --&gt; ------
                                   cos(x)

                        2               2
                     sin (x) --&gt; 1 - cos (x)

(%o6)                         done
</pre></dd></dl>

<p><a name="letsimp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>letsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1352"></a>
</dt>
<dt><u>Funktion:</u> <b>letsimp</b><i> (<var>expr</var>, <var>package_name</var>)</i>
<a name="IDX1353"></a>
</dt>
<dt><u>Funktion:</u> <b>letsimp</b><i> (<var>expr</var>, <var>package_name_1</var>, &hellip;, <var>package_name_n</var>)</i>
<a name="IDX1354"></a>
</dt>
<dd>
<p>Wendet die Substitutionsregeln, die mit der Funktion <code><a href="#let">let</a></code>
 definiert sind,
solange an, bis sich das Argument <var>expr</var> nicht mehr &auml;ndert.  
<code>letsimp(<var>expr</var>)</code> wendet die Regeln der Optionsvariablen
<code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code>
 an.
</p>

<p><code>letsimp(<var>expr</var>), <var>package_name</var>)</code> wendet die Regeln des
Argumentes <var>package_name</var> an.  Die Optionsvariable 
<code>current_let_rule_package</code> &auml;ndert ihren Wert nicht.
</p>

<p><code>letsimp(<var>expr</var>, <var>package_name_1</var>, ..., <var>package_name_n</var>)</code>
ist &auml;quivalent zum Kommando <code>letsimp(<var>expr</var>, 
<var>package_name_1</var>)</code> dem <code>letsimp(%, <var>package_name_2</var>)</code> folgt u.s.w.
</p></dd></dl>

<p><a name="let_005frule_005fpackages"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>let_rule_packages</b>
<a name="IDX1355"></a>
</dt>
<dd><p>Standardwert: <code>[default_let_rule_package]</code>
</p>

<p><code>let_rule_packages</code> ist eine Informationsliste mit den vom Nutzer 
definierten <code>let</code>-Regeln.
</p></dd></dl>

<p><a name="matchdeclare"></a>
</p><dl>
<dt><u>Funktion:</u> <b>matchdeclare</b><i> (<var>a_1</var>, <var>pred_1</var>, &hellip;, <var>a_n</var>, <var>pred_n</var>)</i>
<a name="IDX1356"></a>
</dt>
<dd>
<p>Assoziiert eine Aussage <var>pred_k</var> mit einer Variable oder eine Liste von
Variablen <var>a_k</var>, so dass <var>a_k</var> mit Ausdr&uuml;cken &uuml;bereinstimmt, f&uuml;r
die die Aussage ein anderes Ergebnis als <code>false</code> zur&uuml;ck gibt.
</p>

<p>Eine Aussage ist der Name einer Funktion, ein Lambda-Ausdruck, ein 
Funktionsaufruf, ein Lambda-Ausdruck, dem das letzte Argument fehlt, oder die
Werte <code>true</code> oder <code>all</code>.  Ist die Aussage ein Funktionsaufruf oder
ein Lambda-Aufruf, dann wird der zu testende Ausdruck an die Liste der
Argumente angef&uuml;gt.  Die Argumente werden ausgewertet, wenn die 
&Uuml;bereinstimmung ausgewertet wird.  Ist die Aussage der Name einer Funktion
oder ein Lambda-Ausdruck, ist die zu testende Aussage das einzige Argument.
Eine Aussagefunktion braucht nicht definiert zu sein, wenn <code>matchdeclare</code>
aufgerufen wird.  Die Aussage wird nicht eher ausgewertet, bevor eine 
&Uuml;bereinstimmung getestet wird.
</p>

<p>Eine Aussage kann einen logischen Ausdruck oder die Werte <code>true</code> oder
<code>false</code> zur&uuml;ck geben.  Logische Ausdr&uuml;cke werden von <code><a href="maxima_11.html#is">is</a></code>

von der definierten Regel ausgewertet.  Daher ist es nicht notwendig, dass die
Aussage selbst die Funktion <code>is</code> aufruft.
</p>

<p>Wenn f&uuml;r ein Ausdruck eine &Uuml;bereinstimmung gefunden wird, wird der
Mustervariablen der Ausdruck zugewiesen.  Jedoch nicht f&uuml;r Mustervariablen, 
die Argumente der Addition <code>+</code> oder Multiplikation <code>*</code> sind.  Diese 
Operatoren werden besonders behandelt.  Andere Maxima oder vom Nutzer definierte
N-ary-Operatoren werden dagegen wie andere Funktionen behandelt.
</p>

<p>Im Falle der Addition und Multiplikation kann der Mustervariablen ein einzelner
Term zugewiesen werden, welcher mit der Aussage &uuml;bereinstimmt, aber auch 
eine Summe oder ein Produkt solcher Ausdr&uuml;cke.  Die mehrfache
&Uuml;bereinstimmung ist vorrangig: Aussagen werden in der Reihenfolge ausgewertet,
in der die Mustervariablen im Musterausdruck auftreten.  Stimmt ein Termin mit
mehreren Aussagen &uuml;berein, wird der Term der ersten Aussage zugeordnet, die
zutrifft.  Jede Aussage wird zun&auml;chst auf alle Argumente einer Summe oder
eines Produktes angewendet, bevor die n&auml;chste Aussage ausgewertet wird.  Wird
f&uuml;r die Zahlen 0 oder 1 eine &Uuml;bereinstimmung gefunden und es sind keine
weiteren Terme vorhanden, wird der Mustervariablen 0 oder 1 zugewiesen.
</p>

<p>Der Algorithmus, um Muster mit der Addition und Multiplikation zu verarbeiten,
ist f&uuml;r manche &Uuml;bereinstimmungen abh&auml;ngig von der Anordnung der Terme im
Muster und im Ausdruck f&uuml;r den eine &Uuml;bereinstimmung gesucht wird.  Solange
sich jedoch die einzelnen Muster gegeneinander ausschlie&szlig;en, wird das
Ergebnis nicht von der Reihenfolge der Argumente beeinflu&szlig;t.
</p>

<p>Der Aufruf von <code>matchdeclare</code> f&uuml;r eine Variable <var>a</var> &uuml;berschreibt
einen vorhergehenden Aufruf von <code>matchdeclare</code> f&uuml;r diese Variable.  Nur
die letzte Definition ist wirksam, wenn eine Regel definiert wird.  Sp&auml;tere
&Auml;nderungen der <code>matchdeclare</code>-Eigenschaft eines Symbols haben keinen
Einfluss auf definierte Regeln.
</p>

<p>Das Kommando <code>propvars(matchdeclare)</code> gibt eine Liste der Variablen
zur&uuml;ck, f&uuml;r die eine <code>matchdeclare</code>-Eigenschaft definiert ist.
<code>printprops(<var>a</var>, matchdeclare)</code> gibt die der Variable
zugeordnete Aussage zur&uuml;ck.  <code>printprops(all, matchdeclare)</code> gibt die
Aussagen aller Variablen mit einer <code>matchdeclare</code>-Eigenschaft zur&uuml;ck.
<code>remove(<var>a</var>, matchdeclare)</code> entfernt die 
<code>matchdeclare</code>-Eigenschaft f&uuml;r die Variable <var>a</var>.
</p>

<p>Die Funktion <code><a href="#defmatch">defmatch</a></code>,
 <code><a href="#defrule">defrule</a></code>,
 <code><a href="#tellsimp">tellsimp</a></code>,

<code><a href="#tellsimpafter">tellsimpafter</a></code>
 und <code><a href="#let">let</a></code>
 konstruieren Regeln, die Ausdr&uuml;cke gegen
Muster testen.
</p>

<p><code>matchdeclare</code> wertet die Argumente nicht aus.  <code>matchdeclare</code> gibt
immer <code>done</code> als Ergebnis zur&uuml;ck.
</p>
<p>Beispiele:
</p>

<p>Eine Aussage ist der Name einer Funktion, ein Lambda-Ausdruck, ein 
Funktionsaufruf, ein Lambda-Ausdruck, dem das letzte Argument fehlt, oder die
Werte <code>true</code> oder <code>all</code>.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
(%i5) matchdeclare (ee, true);
(%o5)                         done
(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre>

<p>Stimmt ein Ausdruck mit einer Musteraussage &uuml;berein, wird der Ausdruck der
Mustervariable zugewiesen.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre>

<p>Im Falle der Addition und Multiplikation kann der Mustervariablen ein einzelner
Term zugewiesen werden, welcher mit der Aussage &uuml;bereinstimmt, aber auch 
eine Summe oder ein Produkt solcher Ausdr&uuml;cke.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre>

<p>Wird nach &Uuml;bereinstimmungen f&uuml;r die Argumente der Operatoren <code>+</code> oder
<code>*</code> gesucht und schlie&szlig;en sich die Aussagen gegeneinander aus, ist das
Ergebnis unabh&auml;ngig von der Anordnung der Terme.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                  n
                                         (b + a) 2  sin(x)
(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                 c
</pre>

<p>Die Funktionen <code><a href="maxima_11.html#propvars">propvars</a></code>
 und <code><a href="maxima_11.html#printprops">printprops</a></code>
 geben Informationen &uuml;ber
Mustervariablen.
</p>
<pre class="example">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre></dd></dl>

<p><a name="maxapplydepth"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>maxapplydepth</b>
<a name="IDX1357"></a>
</dt>
<dd><p>Standardwert: 10000
</p>
<p><code>maxapplydepth</code> ist die maximale Tiefe f&uuml;r die die Funktionen
<code><a href="#apply1">apply1</a></code>
 und <code><a href="#apply2">apply2</a></code>
 rekursiv auf einen Ausdruck angewendet werden.
</p></dd></dl>

<p><a name="maxapplyheight"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>maxapplyheight</b>
<a name="IDX1358"></a>
</dt>
<dd><p>Standardwert: 10000
</p>

<p><code>maxapplyheight</code> ist die maximale Gr&ouml;&szlig;e die <code>applyb1</code> erreichen
kann, bevor die Funktion aufgibt.
</p></dd></dl>

<p><a name="remlet"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remlet</b><i> (<var>prod</var>, <var>package_name</var>)</i>
<a name="IDX1359"></a>
</dt>
<dt><u>Funktion:</u> <b>remlet</b><i> ()</i>
<a name="IDX1360"></a>
</dt>
<dt><u>Funktion:</u> <b>remlet</b><i> (all)</i>
<a name="IDX1361"></a>
</dt>
<dt><u>Funktion:</u> <b>remlet</b><i> (all, <var>package_name</var>)</i>
<a name="IDX1362"></a>
</dt>
<dd>
<p>Entfernt die Ersetzungsregel <var>prod</var> -&gt; <var>repl</var> die zuletzt mit der
Funktion <code><a href="#let">let</a></code>
 definiert wurde.  Wird mit dem Argument <var>package_name</var>
ein Paket angegeben, wird die Regeln aus dem Paket entsprechenden Paket
entfernt.
</p>

<p><code>remlet()</code> und <code>remlet(all)</code> entfernen alle Ersetzungsregeln aus dem
aktuellen Paket, das in <code><a href="#current_005flet_005frule_005fpackage">current_let_rule_package</a></code>
 enthalten ist.  Wird
ein Regelpaket als Argument angegeben, werden zus&auml;tzlich die Regeln dieses
Paketes entfernt.
</p>

<p>Soll eine vorhandene Ersetzungsregel durch eine neue Definition ersetzt werden,
muss die Regel zuvor nicht mit <code>remlet</code> entfernt werden.  Die neue
Definition &uuml;berschreibt eine vorhandene Regel.
</p>

<p>Siehe auch <code><a href="#remrule">remrule</a></code>,
 um Regeln zu entfernen, die mit 
<code><a href="#tellsimp">tellsimp</a></code>
 oder <code><a href="#tellsimpafter">tellsimpafter</a></code>
 definiert sind.
</p></dd></dl>

<p><a name="remrule"></a>
</p><dl>
<dt><u>Funktion:</u> <b>remrule</b><i> (<var>op</var>, <var>rulename</var>)</i>
<a name="IDX1363"></a>
</dt>
<dt><u>Funktion:</u> <b>remrule</b><i> (<var>op</var>, all)</i>
<a name="IDX1364"></a>
</dt>
<dd>
<p>Entfernt Regeln die mit den Funktionen <code><a href="#tellsimp">tellsimp</a></code>
 oder 
<code><a href="#tellsimpafter">tellsimpafter</a></code>.
 definiert wurden.
</p>

<p><code>remrule(<var>op</var>, <var>rulename</var>)</code> entfernt die Regel mit dem Namen
<var>rulename</var> vom Operator <var>op</var>.  Ist der Operator <var>op</var> ein 
Maxima-Operator oder ein nutzerdefinierter Operator, der mit Funktionen wie
<code><a href="maxima_7.html#infix">infix</a></code>
 oder <code><a href="maxima_7.html#prefix">prefix</a></code>
 definiert wurde, muss der Name des Operators
<var>op</var> in Anf&uuml;hrungszeichen angegeben werden.
</p>

<p><code>remrule(<var>op</var>, all)</code> entfernt alle Regeln des Operators <var>op</var>.
</p>

<p>Siehe auch die Funktion <code><a href="#remlet">remlet</a></code>,
 um Regeln zu entfernen, die mit der
Funktion <code><a href="#let">let</a></code>
 definiert sind.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
(%i8) remrule (foo, foorule1);
(%o8)                          foo
(%i9) remrule (&quot;+&quot;, ?\+rule1);
(%o9)                           +
(%i10) remrule (&quot;@@&quot;, ?\@\@rule1);
(%o10)                         @@
(%i11) remrule (quux, all);
(%o11)                        quux
(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                         quux(%e, %pi)]
</pre></dd></dl>

<p><a name="rules"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>rules</b>
<a name="IDX1365"></a>
</dt>
<dd><p>Standardwert: <code>[]</code>
</p>
<p>Enth&auml;lt die vom Nutzer mit den Funktionen <code>tellsimp</code>, 
<code>tellsimpafter</code>, <code>defmatch</code> oder <code>defrule</code> definierten Regeln.
Siehe auch <code><a href="maxima_4.html#infolists">infolists</a></code>.
</p>
</dd></dl>

<p><a name="tellsimp"></a>
</p><dl>
<dt><u>Funktion:</u> <b>tellsimp</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1366"></a>
</dt>
<dd>
<p><code>tellsimp</code> ist vergleichbar mit der Funktion <code><a href="#tellsimpafter">tellsimpafter</a></code>,

wobei <code>tellsimp</code> die Vereinfachungsregel vor der Anwendung der eingebauten
Vereinfachungen ausgef&uuml;hrt wird.
</p>

<p><code>tellsimp</code> wird eingesetzt, wenn Maxima Regeln f&uuml;r die Vereinfachung des
Ausdruckes kennt, es jedoch notwendig ist, noch vor Anwendung dieser Regeln
den Ausdruck auf eine andere Art zu modifizieren.  F&uuml;r den Fall das Maxima
den Ausdruck nicht ausreichend vereinfacht, kann es besser sein, eine
Vereinfachungsregel mit <code><a href="#tellsimpafter">tellsimpafter</a></code>
 zu definieren.
</p>

<p>Das Argument <var>pattern</var> kann keine Summe, Produkte, eine einzelne Variable
oder eine Zahl sein.
</p>

<p><code>rules</code> ist eine Informationsliste, die alle Regeln enth&auml;lt die mit den
<code><a href="#tellsimpafter">tellsimpafter</a></code>,
 <code><a href="#defrule">defrule</a></code>,
 <code><a href="#defmatch">defmatch</a></code>
 und
<code><a href="#tellsimp">tellsimp</a></code>
 definiert sind.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre></dd></dl>

<p><a name="tellsimpafter"></a>
</p><dl>
<dt><u>Funktion:</u> <b>tellsimpafter</b><i> (<var>pattern</var>, <var>replacement</var>)</i>
<a name="IDX1367"></a>
</dt>
<dd>
<p>Definiert eine Vereinfachungsregel, die nach Anwendung der eingebauten Regeln
angewendet wird.  <var>pattern</var> ist ein Ausdruck, der Mustervariablen enth&auml;lt,
die mit der Funktion <code><a href="#matchdeclare">matchdeclare</a></code>
 definiert werden und weitere Symbole
und Operatoren, f&uuml;r die die w&ouml;rtliche &Uuml;bereinstimmung in einem Ausdruck 
angenommen wird.  <var>replacement</var> wird in den Ausdruck substituiert, wenn
<var>pattern</var> im Ausdruck gefunden wird.  Mustervariablen in <var>replacement</var>
werden die Werte des gepr&uuml;ften Ausdrucks zugewiesen.
</p>

<p>Das Argument <var>pattern</var> kann ein beliebiger Ausdruck sein, in dem der 
Hauptoperator keine Mustervariable ist.  Die Vereinfachungsregel wird mit dem
Hauptoperator assoziiert.  Der Name von Funktionen, mit einer unten 
beschriebenen Ausnahme, Listen und Arrays k&ouml;nnen in <var>pattern</var> nur als
eine w&ouml;rtliche &Uuml;bereinstimmung und nicht in Mustervariablen auftreten.
Daher k&ouml;nnen Ausdr&uuml;cke wie <code>aa(x)</code> oder <code>bb[y]</code> nicht als Muster
verwendet werden, wenn <code>aa</code> oder <code>bb</code> Mustervariablen sind.  Die Namen
von Funktionen, Listen und Arrays, welche Mustervariablen sind, k&ouml;nnen dann
in <var>pattern</var> auftreten, wenn sie nicht der Hauptoperator sind.
</p>

<p>Es gibt eine Ausnahme der oben genannten Einschr&auml;nkung f&uuml;r die Verwendung
von Funktionsnamen.  Der Name einer indizierten Funktion wie <code>aa[x](y)</code>
kann eine Mustervariable sein, da der Hauptoperator nicht <code>aa</code> ist, sondern
das Lisp-Symbol <code>mqapply</code>.  Dies ist eine Konsequenz der internen
Darstellung einer indizierten Funktion.
</p>


<p>Regeln f&uuml;r die Vereinfachung werden nach der Auswertung eines Ausdrucks 
angewendet, sofern die Auswertung zum Beispiel mit dem Schalter
<code><a href="maxima_8.html#noeval">noeval</a></code>
 nicht unterdr&uuml;ckt wurde.  Regeln, die mit <code>tellsimpafter</code> 
definiert sind, werden nach den vorhandenen Maxima-Regeln und in der Reihenfolge
angewendet werden, in der sie definiert sind.  Die Regeln f&uuml;r die
Vereinfachung werden zun&auml;chst f&uuml;r Teilausdr&uuml;cke und zuletzt f&uuml;r den
ganzen Ausdruck angewendet.  Es kann notwendig sein, Regeln f&uuml;r die
Vereinfachung mehrfach zum Beispiel mit dem <code><a href="maxima_8.html#g_t_0027_0027">Quote-Quote-Operator</a></code>

oder dem Schalter <code><a href="maxima_8.html#infeval">infeval</a></code>
 anzuwenden, um sicher zu gehen, dass alle
Regeln angewendet werden.
</p>

<p>Mustervariable werden als lokale Variablen in Vereinfachungsregeln behandelt.
Sobald eine Regel definiert ist, beeinflusst die Zuweisung eines Wertes an die
Mustervariable nicht die Regel und die Variable wird nicht von der Regel
beeinflusst.  Die Zuweisung an eine Mustervariable, die aufgrund einer
erfolgreichen &Uuml;bereinstimmung des Musters mit einem Ausdruck vorgenommen wird,
beeinflusst nicht den aktuellen Wert der Variablen.  Jedoch sind die
Eigenschaften der Mustervariablen, wie sie zum Beispiel auch mit der Funktion
<code><a href="maxima_11.html#put">put</a></code>
 definiert werden k&ouml;nnen, global in Maxima.
</p>

<p>Die mit <code>tellsimpafter</code> definierte Regel wird nach dem Hauptoperator des
Argumentes <var>pattern</var> benannt.  Regeln der Maxima-Operatoren und mit den
Funktionen <code><a href="maxima_7.html#infix">infix</a></code>,
 <code><a href="maxima_7.html#prefix">prefix</a></code>,
 <code><a href="maxima_7.html#postfix">postfix</a></code>,

<code><a href="maxima_7.html#matchfix">matchfix</a></code>
 und <code><a href="maxima_7.html#nofix">nofix</a></code>
 definierte Operatoren haben einen
Lisp-Bezeichner als Namen.  Alle anderen Regeln haben Maxima-Bezeichner als
Namen.
</p>






<p><code>tellsimpafter</code> werden die Argumente nicht aus.  <code>tellsimpafter</code> gibt
eine Liste der Regeln des Hauptoperators des Argumentes <var>pattern</var>
einschlie&szlig;lich der neu definierten Regeln zur&uuml;ck.
</p>

<p>Siehe auch <code><a href="#matchdeclare">matchdeclare</a></code>,
 <code><a href="#defmatch">defmatch</a></code>,
 <code><a href="#defrule">defrule</a></code>,

<code><a href="#tellsimp">tellsimp</a></code>,
 <code><a href="maxima_4.html#kill">kill</a></code>,
 <code><a href="#remrule">remrule</a></code>
 und <code><a href="#clear_005frules">clear_rules</a></code>.
</p>

<p>Beispiele:
</p>

<p>Das Muster <var>pattern</var> kann ein beliebiger Ausdruck sein, in dem der
Hauptoperator nicht die Mustervariable ist.
</p>
<pre class="example">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre>

<p>Regeln werden in der Reihenfolge angewendet, in der sie definiert wurden.
K&ouml;nnen zwei Regeln mit einem Ausdruck &uuml;bereinstimmen, wird die zuerst
definierte Regel angewendet.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
</pre>

<p>Mustervariable werden als lokale Variable in Vereinfachungsregeln behandelt.  Im
Unterschied dazu behandelt <code><a href="#defmatch">defmatch</a></code>
 Mustervariable als globale Variable.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
</pre>

<p>Die Eigenschaften von Mustervariablen sind global, auch wenn die Werte lokal 
sind.  In diesem Beispiel wird eine Eigenschaft f&uuml;r die Zuweisung an eine
Variable mit der Funktion <code><a href="maxima_26.html#define_005fvariable">define_variable</a></code>
 definiert.  Die Eigenschaft 
des Symbols <code>bb</code> ist global in Maxima.
</p>
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>

<p>Regeln werden nach dem Hauptoperator benannt.  Die Namen der Regeln f&uuml;r
Maxima-Funktionen und nutzerdefinierten Operatoren sind Lisp-Bezeichner.  Alle
anderen Namen sind Maxima-Bezeichner.
</p>
<pre class="example">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) remrule (foo, foorule1);
(%o10)                         foo
(%i11) remrule (&quot;^&quot;, ?\^rule1);
(%o11)                          ^
(%i12) rules;
(%o12)        [foorule2, foorule3, +rule1, *rule1]
</pre>

<p>Ein ausgearbeitetes Beispiel der nicht-kommutativen Multiplikation.
</p>
<pre class="example">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)           gt(i, j) := integerp(j) and i &lt; j
(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC179" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC182" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>April, 4 2011</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
