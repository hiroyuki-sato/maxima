This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Introduction to Sets,  Next: Functions and Variables for Sets,  Prev: Mengen,  Up: Mengen

14.1 Introduction to Sets
=========================

Maxima provides set functions, such as intersection and union, for
finite sets that are defined by explicit enumeration.  Maxima treats
lists and sets as distinct objects. This feature makes it possible to
work with sets that have members that are either lists or sets.

   In addition to functions for finite sets, Maxima provides some
functions related to combinatorics; these include the Stirling numbers
of the first and second kind, the Bell numbers, multinomial
coefficients, partitions of nonnegative integers, and a few others.
Maxima also defines a Kronecker delta function.

14.1.1 Usage
------------

To construct a set with members `a_1, ..., a_n', write `set(a_1, ...,
a_n)' or `{a_1, ..., a_n}'; to construct the empty set, write `set()'
or `{}'.  In input, `set(...)' and `{ ... }' are equivalent.  Sets are
always displayed with curly braces.

   If a member is listed more than once, simplification eliminates the
redundant member.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Two would-be elements <x> and <y> are redundant (i.e., considered
the same for the purpose of set construction) if and only if `is(<x> =
<y>)' yields `true'.  Note that `is(equal(<x>, <y>))' can yield `true'
while `is(<x> = <y>)' yields `false'; in that case the elements <x> and
<y> are considered distinct.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   To construct a set from the elements of a list, use `setify'.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   Set members `x' and `y' are equal provided `is(x = y)' evaluates to
`true'. Thus `rat(x)' and `x' are equal as set members; consequently,

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Further, since `is((x - 1)*(x + 1) = x^2 - 1)' evaluates to `false',
`(x - 1)*(x + 1)' and `x^2 - 1' are distinct set members; thus

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   To reduce this set to a singleton set, apply `rat' to each set
member:

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   To remove redundancies from other sets, you may need to use other
simplification functions. Here is an example that uses `trigsimp':

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   A set is simplified when its members are non-redundant and sorted.
The current version of the set functions uses the Maxima function
`orderlessp' to order sets; however, future versions of the set
functions might use a different ordering function.

   Some operations on sets, such as substitution, automatically force a
re-simplification; for example,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima treats lists and sets as distinct objects; functions such as
`union' and `intersection' complain if any argument is not a set. If
you need to apply a set function to a list, use the `setify' function
to convert it to a set. Thus

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   To extract all set elements of a set `s' that satisfy a predicate
`f', use `subset(s, f)'. (A predicate is a boolean-valued function.)
For example, to find the equations in a given set that do not depend on
a variable `z', use

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                         lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   The section *Note Functions and Variables for Sets:: has a complete
list of the set functions in Maxima.

14.1.2 Set Member Iteration
---------------------------

There two ways to to iterate over set members. One way is the use
`map'; for example:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   The other way is to use `for <x> in <s> do'

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   The Maxima functions `first' and `rest' work correctly on sets.
Applied to a set, `first' returns the first displayed element of a set;
which element that is may be implementation-dependent. If `s' is a set,
then `rest(s)' is equivalent to `disjoin(first(s), s)'.  Currently,
there are other Maxima functions that work correctly on sets.  In
future versions of the set functions, `first' and `rest' may function
differently or not at all.

14.1.3 Bugs
-----------

The set functions use the Maxima function `orderlessp' to order set
members and the (Lisp-level) function `like' to test for set member
equality. Both of these functions have known bugs that may manifest if
you attempt to use sets with members that are lists or matrices that
contain expressions in canonical rational expression (CRE) form. An
example is

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   This expression causes Maxima to halt with an error (the error
message depends on which version of Lisp your Maxima uses). Another
example is

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   These bugs are caused by bugs in `orderlessp' and `like'; they are
not caused by bugs in the set functions. To illustrate, try the
expressions

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Until these bugs are fixed, do not construct sets with members that
are lists or matrices containing expressions in CRE form; a set with a
member in CRE form, however, shouldn't be a problem:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   Maxima's `orderlessp' has another bug that can cause problems with
set functions, namely that the ordering predicate `orderlessp' is not
transitive. The simplest known example that shows this is

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   This bug can cause trouble with all set functions as well as with
Maxima functions in general. It is probable, but not certain, that this
bug can be avoided if all set members are either in CRE form or have
been simplified using `ratsimp'.

   Maxima's `orderless' and `ordergreat' mechanisms are incompatible
with the set functions. If you need to use either `orderless' or
`ordergreat', call those functions before constructing any sets, and do
not call `unorder'.

   If you find something that you think might be a set function bug,
please report it to the Maxima bug database. See `bug_report'.

14.1.4 Authors
--------------

Stavros Macrakis of Cambridge, Massachusetts and Barton Willis of the
University of Nebraska at Kearney (UNK) wrote the Maxima set functions
and their documentation.


File: maxima.info,  Node: Functions and Variables for Sets,  Prev: Introduction to Sets,  Up: Mengen

14.2 Functions and Variables for Sets
=====================================

 -- Function: adjoin (<x>, <a>)
     Returns the union of the set <a> with `{<x>}'.

     `adjoin' complains if <a> is not a literal set.

     `adjoin(<x>, <a>)' and `union(set(<x>), <a>)' are equivalent;
     however, `adjoin' may be somewhat faster than `union'.

     See also `disjoin'.

     Examples:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}


 -- Function: belln (<n>)
     Represents the n-th Bell number.  `belln(n)' is the number of
     partitions of a set with <n> members.

     For nonnegative integers <n>, `belln(<n>)' simplifies to the n-th
     Bell number.  `belln' does not simplify for any other arguments.

     `belln' distributes over equations, lists, matrices, and sets.

     Examples:

     `belln' applied to nonnegative integers.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                                 belln (6));
          (%o3)                         true

     `belln' applied to arguments which are not nonnegative integers.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]


 -- Function: cardinality (<a>)
     Returns the number of distinct elements of the set <a>.

     `cardinality' ignores redundant elements even when simplification
     is disabled.

     Examples:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3


 -- Function: cartesian_product (<b_1>, ... , <b_n>)
     Returns a set of lists of the form `[<x_1>, ..., <x_n>]', where
     <x_1>, ..., <x_n> are elements of the sets <b_1>, ... , <b_n>,
     respectively.

     `cartesian_product' complains if any argument is not a literal set.

     Examples:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}


 -- Function: disjoin (<x>, <a>)
     Returns the set <a> without the member <x>.  If <x> is not a
     member of <a>, return <a> unchanged.

     `disjoin' complains if <a> is not a literal set.

     `disjoin(<x>, <a>)', `delete(<x>, <a>)', and `setdifference(<a>,
     set(<x>))' are all equivalent.  Of these, `disjoin' is generally
     faster than the others.

     Examples:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}


 -- Function: disjointp (<a>, <b>)
     Returns `true' if and only if the sets <a> and <b> are disjoint.

     `disjointp' complains if either <a> or <b> is not a literal set.

     Examples:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false


 -- Function: divisors (<n>)
     Represents the set of divisors of <n>.

     `divisors(<n>)' simplifies to a set of integers when <n> is a
     nonzero integer.  The set of divisors includes the members 1 and
     <n>.  The divisors of a negative integer are the divisors of its
     absolute value.

     `divisors' distributes over equations, lists, matrices, and sets.

     Examples:

     We can verify that 28 is a perfect number: the sum of its divisors
     (except for itself) is 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     `divisors' is a simplifying function.  Substituting 8 for `a' in
     `divisors(a)' yields the divisors without reevaluating
     `divisors(8)'.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     `divisors' distributes over equations, lists, matrices, and sets.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}


 -- Function: elementp (<x>, <a>)
     Returns `true' if and only if <x> is a member of the set <a>.

     `elementp' complains if <a> is not a literal set.

     Examples:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false


 -- Function: emptyp (<a>)
     Return `true' if and only if <a> is the empty set or the empty
     list.

     Examples:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]


 -- Function: equiv_classes (<s>, <F>)
     Returns a set of the equivalence classes of the set <s> with
     respect to the equivalence relation <F>.

     <F> is a function of two variables defined on the Cartesian
     product of <s> with <s>.  The return value of <F> is either `true'
     or `false', or an expression <expr> such that `is(<expr>)' is
     either `true' or `false'.

     When <F> is not an equivalence relation, `equiv_classes' accepts
     it without complaint, but the result is generally incorrect in
     that case.

     Examples:

     The equivalence relation is a lambda expression which returns
     `true' or `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                  lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     The equivalence relation is the name of a relational function
     which `is' evaluates to `true' or `false'.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     The equivalence classes are numbers which differ by a multiple of
     3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                               lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}


 -- Function: every (<f>, <s>)
 -- Function: every (<f>, <L_1>, ..., <L_n>)
     Returns `true' if the predicate <f> is `true' for all given
     arguments.

     Given one set as the second argument, `every(<f>, <s>)' returns
     `true' if `is(<f>(<a_i>))' returns `true' for all <a_i> in <s>.
     `every' may or may not evaluate <f> for all <a_i> in <s>.  Since
     sets are unordered, `every' may evaluate `<f>(<a_i>)' in any order.

     Given one or more lists as arguments, `every(<f>, <L_1>, ...,
     <L_n>)' returns `true' if `is(<f>(<x_1>, ..., <x_n>))' returns
     `true' for all <x_1>, ..., <x_n> in <L_1>, ..., <L_n>,
     respectively.  `every' may or may not evaluate <f> for every
     combination <x_1>, ..., <x_n>.  `every' evaluates lists in the
     order of increasing index.

     Given an empty set `{}' or empty lists `[]' as arguments, `every'
     returns `false'.

     When the global flag `maperror' is `true', all lists <L_1>, ...,
     <L_n> must have equal lengths.  When `maperror' is `false', list
     arguments are effectively truncated to the length of the shortest
     list.

     Return values of the predicate <f> which evaluate (via `is') to
     something other than `true' or `false' are governed by the global
     flag `prederror'.  When `prederror' is `true', such values are
     treated as `false', and the return value from `every' is `false'.
     When `prederror' is `false', such values are treated as `unknown',
     and the return value from `every' is `unknown'.

     Examples:

     `every' applied to a single set.  The predicate is a function of
     one argument.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     `every' applied to two lists.  The predicate is a function of two
     arguments.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Return values of the predicate <f> which evaluate to something
     other than `true' or `false' are governed by the global flag
     `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false


 -- Function: extremal_subset (<s>, <f>, max)
 -- Function: extremal_subset (<s>, <f>, min)
     Returns the subset of <s> for which the function <f> takes on
     maximum or minimum values.

     `extremal_subset(<s>, <f>, max)' returns the subset of the set or
     list <s> for which the real-valued function <f> takes on its
     maximum value.

     `extremal_subset(<s>, <f>, min)' returns the subset of the set or
     list <s> for which the real-valued function <f> takes on its
     minimum value.

     Examples:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}


 -- Function: flatten (<expr>)
     Collects arguments of subexpressions which have the same operator
     as <expr> and constructs an expression from these collected
     arguments.

     Subexpressions in which the operator is different from the main
     operator of `expr' are copied without modification, even if they,
     in turn, contain some subexpressions in which the operator is the
     same as for `expr'.

     It may be possible for `flatten' to construct expressions in which
     the number of arguments differs from the declared arguments for an
     operator; this may provoke an error message from the simplifier or
     evaluator.  `flatten' does not try to detect such situations.

     Expressions with special representations, for example, canonical
     rational expressions (CRE), cannot be flattened; in such cases,
     `flatten' returns its argument unchanged.

     Examples:

     Applied to a list, `flatten' gathers all list elements that are
     lists.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Applied to a set, `flatten' gathers all members of set elements
     that are sets.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     `flatten' is similar to the effect of declaring the main operator
     n-ary.  However, `flatten' has no effect on subexpressions which
     have an operator different from the main operator, while an n-ary
     declaration affects those.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     `flatten' treats subscripted functions the same as any other
     operator.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     It may be possible for `flatten' to construct expressions in which
     the number of arguments differs from the declared arguments for an
     operator;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Function: full_listify (<a>)
     Replaces every set operator in <a> by a list operator, and returns
     the result.  `full_listify' replaces set operators in nested
     subexpressions, even if the main operator is not `set'.

     `listify' replaces only the main operator.

     Examples:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))


 -- Function: fullsetify (<a>)
     When <a> is a list, replaces the list operator with a set operator,
     and applies `fullsetify' to each member which is a set.  When <a>
     is not a list, it is returned unchanged.

     `setify' replaces only the main operator.

     Examples:

     In line `(%o2)', the argument of `f' isn't converted to a set
     because the main operator of `f([b])' isn't a list.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}


 -- Function: identity (<x>)
     Returns <x> for any argument <x>.

     Examples:

     `identity' may be used as a predicate when the arguments are
     already Boolean values.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Function: integer_partitions (<n>)
 -- Function: integer_partitions (<n>, <len>)
     Returns integer partitions of <n>, that is, lists of integers
     which sum to <n>.

     `integer_partitions(<n>)' returns the set of all partitions of the
     integer <n>.  Each partition is a list sorted from greatest to
     least.

     `integer_partitions(<n>, <len>)' returns all partitions that have
     length <len> or less; in this case, zeros are appended to each
     partition with fewer than <len> terms to make each partition have
     exactly <len> terms.  Each partition is a list sorted from
     greatest to least.

     A list [a_1, ..., a_m] is a partition of a nonnegative integer n
     when (1) each a_i is a nonzero integer, and (2) a_1 + ... + a_m =
     n. Thus 0 has no partitions.

     Examples:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     To find all partitions that satisfy a condition, use the function
     `subset'; here is an example that finds all partitions of 10 that
     consist of prime numbers.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}


 -- Function: intersect (<a_1>, ..., <a_n>)
     `intersect' is the same as `intersection', which see.


 -- Function: intersection (<a_1>, ..., <a_n>)
     Returns a set containing the elements that are common to the sets
     <a_1> through <a_n>.

     `intersection' complains if any argument is not a literal set.

     Examples:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}


 -- Function: kron_delta (<x>, <y>)
     Represents the Kronecker delta function.

     `kron_delta' simplifies to 1 when <x> and <y> are identical or
     demonstrably equivalent, and it simplifies to 0 when <x> and <y>
     are demonstrably not equivalent.  Otherwise, it is not certain
     whether <x> and <y> are equivalent, and `kron_delta' simplifies to
     a noun expression.  `kron_delta' implements a cautious policy with
     respect to floating point expressions: if the difference `<x> -
     <y>' is a floating point number, `kron_delta' simplifies to a noun
     expression when <x> is apparently equivalent to <y>.

     Specifically, `kron_delta(<x>, <y>)' simplifies to 1 when `is(x =
     y)' is `true'.  `kron_delta' also simplifies to 1 when
     `sign(abs(<x> - <y>))' is `zero' and `<x> - <y>' is not a floating
     point number (neither an ordinary float nor a bigfloat).
     `kron_delta' simplifies to 0 when `sign(abs(<x> - <y>))' is `pos'.

     Otherwise, `sign(abs(<x> - <y>))' is something other than `pos' or
     `zero', or it is `zero' and `<x> - <y>' is a floating point number.
     In these cases, `kron_delta' returns a noun expression.

     `kron_delta' is declared to be symmetric.  That is,
     `kron_delta(<x>, <y>)' is equal to `kron_delta(<y>, <x>)'.

     Examples:

     The arguments of `kron_delta' are identical.  `kron_delta'
     simplifies to 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     The arguments of `kron_delta' are equivalent, and their difference
     is not a floating point number.  `kron_delta' simplifies to 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     The arguments of `kron_delta' are not equivalent.  `kron_delta'
     simplifies to 0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     The arguments of `kron_delta' might or might not be equivalent.
     `kron_delta' simplifies to a noun expression.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     The arguments of `kron_delta' are equivalent, but their difference
     is a floating point number.  `kron_delta' simplifies to a noun
     expression.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     `kron_delta' is symmetric.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true


 -- Function: listify (<a>)
     Returns a list containing the members of <a> when <a> is a set.
     Otherwise, `listify' returns <a>.

     `full_listify' replaces all set operators in <a> by list operators.

     Examples:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})


 -- Function: lreduce (<F>, <s>)
 -- Function: lreduce (<F>, <s>, <s_0>)
     Extends the binary function <F> to an n-ary function by
     composition, where <s> is a list.

     `lreduce(<F>, <s>)' returns `F(... F(F(s_1, s_2), s_3), ... s_n)'.
     When the optional argument <s_0> is present, the result is
     equivalent to `lreduce(<F>, cons(<s_0>, <s>))'.

     The function <F> is first applied to the leftmost list elements,
     thus the name "lreduce".

     See also `rreduce', `xreduce', and `tree_reduce'.

     Examples:

     `lreduce' without the optional argument.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     `lreduce' with the optional argument.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     `lreduce' applied to built-in binary operators.  `/' is the
     division operator.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d


 -- Function: makeset (<expr>, <x>, <s>)
     Returns a set with members generated from the expression <expr>,
     where <x> is a list of variables in <expr>, and <s> is a set or
     list of lists.  To generate each set member, <expr> is evaluated
     with the variables <x> bound in parallel to a member of <s>.

     Each member of <s> must have the same length as <x>.  The list of
     variables <x> must be a list of symbols, without subscripts.  Even
     if there is only one symbol, <x> must be a list of one element,
     and each member of <s> must be a list of one element.

     See also `makelist'.

     Examples:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}


 -- Function: moebius (<n>)
     Represents the Moebius function.

     When <n> is product of k distinct primes, `moebius(<n>)'
     simplifies to (-1)^k; when <n> = 1, it simplifies to 1; and it
     simplifies to 0 for all other positive integers.

     `moebius' distributes over equations, lists, matrices, and sets.

     Examples:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}


 -- Function: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Function: multinomial_coeff ()
     Returns the multinomial coefficient.

     When each <a_k> is a nonnegative integer, the multinomial
     coefficient gives the number of ways of placing `<a_1> + ... +
     <a_n>' distinct objects into n boxes with <a_k> elements in the
     k'th box. In general, `multinomial_coeff (<a_1>, ..., <a_n>)'
     evaluates to `(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)'.

     `multinomial_coeff()' (with no arguments) evaluates to 1.

     `minfactorial' may be able to simplify the value returned by
     `multinomial_coeff'.

     Examples:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10


 -- Function: num_distinct_partitions (<n>)
 -- Function: num_distinct_partitions (<n>, list)
     Returns the number of distinct integer partitions of <n> when <n>
     is a nonnegative integer.  Otherwise, `num_distinct_partitions'
     returns a noun expression.

     `num_distinct_partitions(<n>, list)' returns a list of the number
     of distinct partitions of 1, 2, 3, ..., <n>.

     A distinct partition of <n> is a list of distinct positive
     integers k_1, ..., k_m such that <n> = k_1 + ... + k_m.

     Examples:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)


 -- Function: num_partitions (<n>)
 -- Function: num_partitions (<n>, list)
     Returns the number of integer partitions of <n> when <n> is a
     nonnegative integer.  Otherwise, `num_partitions' returns a noun
     expression.

     `num_partitions(<n>, list)' returns a list of the number of
     integer partitions of 1, 2, 3, ..., <n>.

     For a nonnegative integer <n>, `num_partitions(<n>)' is equal to
     `cardinality(integer_partitions(<n>))'; however, `num_partitions'
     does not actually construct the set of partitions, so it is much
     faster.

     Examples:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)


 -- Function: partition_set (<a>, <f>)
     Partitions the set <a> according to the predicate <f>.

     `partition_set' returns a list of two sets.  The first set
     comprises the elements of <a> for which <f> evaluates to `false',
     and the second comprises any other elements of <a>.
     `partition_set' does not apply `is' to the return value of <f>.

     `partition_set' complains if <a> is not a literal set.

     See also `subset'.

     Examples:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                               lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]


 -- Function: permutations (<a>)
     Returns a set of all distinct permutations of the members of the
     list or set <a>. Each permutation is a list, not a set.

     When <a> is a list, duplicate members of <a> are included in the
     permutations.

     `permutations' complains if <a> is not a literal list or set.

     See also `random_permutation'.

     Examples:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}


 -- Function: powerset (<a>)
 -- Function: powerset (<a>, <n>)
     Returns the set of all subsets of <a>, or a subset of that set.

     `powerset(<a>)' returns the set of all subsets of the set <a>.
     `powerset(<a>)' has `2^cardinality(<a>)' members.

     `powerset(<a>, <n>)' returns the set of all subsets of <a> that
     have cardinality <n>.

     `powerset' complains if <a> is not a literal set, or if <n> is not
     a nonnegative integer.

     Examples:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}


 -- Function: random_permutation (<a>)
     Returns a random permutation of the set or list <a>, as
     constructed by the Knuth shuffle algorithm.

     The return value is a new list, which is distinct from the
     argument even if all elements happen to be the same.  However, the
     elements of the argument are not copied.

     Examples:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]


 -- Function: rreduce (<F>, <s>)
 -- Function: rreduce (<F>, <s>, <s_{n + 1}>)
     Extends the binary function <F> to an n-ary function by
     composition, where <s> is a list.

     `rreduce(<F>, <s>)' returns `F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))'.  When the optional argument <s_{n + 1}> is present, the
     result is equivalent to `rreduce(<F>, endcons(<s_{n + 1}>, <s>))'.

     The function <F> is first applied to the rightmost list elements,
     thus the name "rreduce".

     See also `lreduce', `tree_reduce', and `xreduce'.

     Examples:

     `rreduce' without the optional argument.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     `rreduce' with the optional argument.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     `rreduce' applied to built-in binary operators.  `/' is the
     division operator.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d


 -- Function: setdifference (<a>, <b>)
     Returns a set containing the elements in the set <a> that are not
     in the set <b>.

     `setdifference' complains if either <a> or <b> is not a literal
     set.

     Examples:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}


 -- Function: setequalp (<a>, <b>)
     Returns `true' if sets <a> and <b> have the same number of elements
     and `is(<x> = <y>)' is `true' for `x' in the elements of <a> and
     `y' in the elements of <b>, considered in the order determined by
     `listify'.  Otherwise, `setequalp' returns `false'.

     Examples:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false


 -- Function: setify (<a>)
     Constructs a set from the elements of the list <a>. Duplicate
     elements of the list <a> are deleted and the elements are sorted
     according to the predicate `orderlessp'.

     `setify' complains if <a> is not a literal list.

     Examples:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}


 -- Function: setp (<a>)
     Returns `true' if and only if <a> is a Maxima set.

     `setp' returns `true' for unsimplified sets (that is, sets with
     redundant members) as well as simplified sets.

     `setp' is equivalent to the Maxima function `setp(a) := not
     atom(a) and op(a) = 'set'.

     Examples:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true


 -- Function: set_partitions (<a>)
 -- Function: set_partitions (<a>, <n>)
     Returns the set of all partitions of <a>, or a subset of that set.

     `set_partitions(<a>, <n>)' returns a set of all decompositions of
     <a> into <n> nonempty disjoint subsets.

     `set_partitions(<a>)' returns the set of all partitions.

     `stirling2' returns the cardinality of the set of partitions of a
     set.

     A set of sets P is a partition of a set S when

       1. each member of P is a nonempty set,

       2. distinct members of P are disjoint,

       3. the union of the members of P equals S.

     Examples:

     The empty set is a partition of itself, the conditions 1 and 2
     being vacuously true.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     The cardinality of the set of partitions of a set can be found
     using `stirling2'.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Each member of `p' should have <n> = 3 members; let's check.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Finally, for each member of `p', the union of its members should
     equal `s'; again let's check.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}


 -- Function: some (<f>, <a>)
 -- Function: some (<f>, <L_1>, ..., <L_n>)
     Returns `true' if the predicate <f> is `true' for one or more
     given arguments.

     Given one set as the second argument, `some(<f>, <s>)' returns
     `true' if `is(<f>(<a_i>))' returns `true' for one or more <a_i> in
     <s>.  `some' may or may not evaluate <f> for all <a_i> in <s>.
     Since sets are unordered, `some' may evaluate `<f>(<a_i>)' in any
     order.

     Given one or more lists as arguments, `some(<f>, <L_1>, ...,
     <L_n>)' returns `true' if `is(<f>(<x_1>, ..., <x_n>))' returns
     `true' for one or more <x_1>, ..., <x_n> in <L_1>, ..., <L_n>,
     respectively.  `some' may or may not evaluate <f> for some
     combinations <x_1>, ..., <x_n>.  `some' evaluates lists in the
     order of increasing index.

     Given an empty set `{}' or empty lists `[]' as arguments, `some'
     returns `false'.

     When the global flag `maperror' is `true', all lists <L_1>, ...,
     <L_n> must have equal lengths.  When `maperror' is `false', list
     arguments are effectively truncated to the length of the shortest
     list.

     Return values of the predicate <f> which evaluate (via `is') to
     something other than `true' or `false' are governed by the global
     flag `prederror'.  When `prederror' is `true', such values are
     treated as `false'.  When `prederror' is `false', such values are
     treated as `unknown'.

     Examples:

     `some' applied to a single set.  The predicate is a function of
     one argument.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     `some' applied to two lists.  The predicate is a function of two
     arguments.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Return values of the predicate <f> which evaluate to something
     other than `true' or `false' are governed by the global flag
     `prederror'.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true


 -- Function: stirling1 (<n>, <m>)
     Represents the Stirling number of the first kind.

     When <n> and <m> are nonnegative integers, the magnitude of
     `stirling1 (<n>, <m>)' is the number of permutations of a set with
     <n> members that have <m> cycles.  For details, see Graham, Knuth
     and Patashnik Concrete Mathematics.  Maxima uses a recursion
     relation to define `stirling1 (<n>, <m>)' for <m> less than 0; it
     is undefined for <n> less than 0 and for non-integer arguments.

     `stirling1' is a simplifying function.  Maxima knows the following
     identities.

       1. stirling1(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling1(n, n) = 1 (Ref. [1])

       3. stirling1(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling1(n + 1, 0) = 0 (Ref. [1])

       5. stirling1(n + 1, 1) = n! (Ref. [1])

       6. stirling1(n + 1, 2) = 2^n  - 1 (Ref. [1])

     These identities are applied when the arguments are literal
     integers or symbols declared as integers, and the first argument
     is nonnegative.  `stirling1' does not simplify for non-integer
     arguments.

     References:

     [1] Donald Knuth, The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     Examples:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' does not simplify for non-integer arguments.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima applies identities to `stirling1'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!


 -- Function: stirling2 (<n>, <m>)
     Represents the Stirling number of the second kind.

     When <n> and <m> are nonnegative integers, `stirling2 (<n>, <m>)'
     is the number of ways a set with cardinality <n> can be
     partitioned into <m> disjoint subsets.  Maxima uses a recursion
     relation to define `stirling2 (<n>, <m>)' for <m> less than 0; it
     is undefined for <n> less than 0 and for non-integer arguments.

     `stirling2' is a simplifying function.  Maxima knows the following
     identities.

       1. stirling2(0, n) = kron_delta(0, n) (Ref. [1])

       2. stirling2(n, n) = 1 (Ref. [1])

       3. stirling2(n, n - 1) = binomial(n, 2) (Ref. [1])

       4. stirling2(n + 1, 1) = 1 (Ref. [1])

       5. stirling2(n + 1, 2) = 2^n  - 1 (Ref. [1])

       6. stirling2(n, 0) = kron_delta(n, 0) (Ref. [2])

       7. stirling2(n, m) = 0 when m > n (Ref. [2])

       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m!  when m and n are integers, and n is nonnegative. (Ref.
          [3])

     These identities are applied when the arguments are literal
     integers or symbols declared as integers, and the first argument
     is nonnegative.  `stirling2' does not simplify for non-integer
     arguments.

     References:

     [1] Donald Knuth. The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     [2] Graham, Knuth, and Patashnik. Concrete Mathematics, Table 264.

     [3] Abramowitz and Stegun. Handbook of Mathematical Functions,
     Section 24.1.4.

     Examples:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' does not simplify for non-integer arguments.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima applies identities to `stirling2'.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1


 -- Function: subset (<a>, <f>)
     Returns the subset of the set <a> that satisfies the predicate <f>.

     `subset' returns a set which comprises the elements of <a> for
     which <f> returns anything other than `false'.  `subset' does not
     apply `is' to the return value of <f>.

     `subset' complains if <a> is not a literal set.

     See also `partition_set'.

     Examples:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}


 -- Function: subsetp (<a>, <b>)
     Returns `true' if and only if the set <a> is a subset of <b>.

     `subsetp' complains if either <a> or <b> is not a literal set.

     Examples:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false


 -- Function: symmdifference (<a_1>, ..., <a_n>)
     Returns the symmetric difference of sets ` <a_1>, ..., <a_n>'.
     Given two arguments, `symmdifference (<a>, <b>)' is the same as:
          union (setdifference (<a>, <b>), setdifference (<b>, <a>)).

     `symmdifference' complains if any argument is not a literal set.

     Examples:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, b, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1,b, z}


 -- Function: tree_reduce (<F>, <s>)
 -- Function: tree_reduce (<F>, <s>, <s_0>)
     Extends the binary function <F> to an n-ary function by
     composition, where <s> is a set or list.

     `tree_reduce' is equivalent to the following: Apply <F> to
     successive pairs of elements to form a new list `[<F>(<s_1>,
     <s_2>), <F>(<s_3>, <s_4>), ...]', carrying the final element
     unchanged if there are an odd number of elements.  Then repeat
     until the list is reduced to a single element, which is the return
     value.

     When the optional argument <s_0> is present, the result is
     equivalent `tree_reduce(<F>, cons(<s_0>, <s>)'.

     For addition of floating point numbers, `tree_reduce' may return a
     sum that has a smaller rounding error than either `rreduce' or
     `lreduce'.

     The elements of <s> and the partial results may be arranged in a
     minimum-depth binary tree, thus the name "tree_reduce".

     Examples:

     `tree_reduce' applied to a list with an even number of elements.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     `tree_reduce' applied to a list with an odd number of elements.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)


 -- Function: union (<a_1>, ..., <a_n>)
     Returns the union of the sets <a_1> through <a_n>.

     `union()' (with no arguments) returns the empty set.

     `union' complains if any argument is not a literal set.

     Examples:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}


 -- Function: xreduce (<F>, <s>)
 -- Function: xreduce (<F>, <s>, <s_0>)
     Extends the function <F> to an n-ary function by composition, or,
     if <F> is already n-ary, applies <F> to <s>.  When <F> is not
     n-ary, `xreduce' is the same as `lreduce'.  The argument <s> is a
     list.

     Functions known to be n-ary include addition `+', multiplication
     `*', `and', `or', `max', `min', and `append'.  Functions may also
     be declared n-ary by `declare(<F>, nary)'.  For these functions,
     `xreduce' is expected to be faster than either `rreduce' or
     `lreduce'.

     When the optional argument <s_0> is present, the result is
     equivalent to `xreduce(<s>, cons(<s_0>, <s>))'.

     Floating point addition is not exactly associative; be that as it
     may, `xreduce' applies Maxima's n-ary addition when <s> contains
     floating point numbers.

     Examples:

     `xreduce' applied to a function known to be n-ary.  `F' is called
     once, with all arguments.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     `xreduce' applied to a function not known to be n-ary.  `G' is
     called several times, with two arguments each time.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]



File: maxima.info,  Node: Summen Produkte und Reihen,  Next: Analysis,  Prev: Mengen,  Up: Top

15 Summen, Produkte und Reihen
******************************

* Menu:

* Summen und Produkte::
* Einfhrung in Reihen::
* Funktionen und Variablen fr Reihen::
* Poisson Reihen::
* Kettenbrche::


File: maxima.info,  Node: Summen und Produkte,  Next: Einfhrung in Reihen,  Prev: Summen Produkte und Reihen,  Up: Summen Produkte und Reihen

15.1 Summen und Produkte
========================

 -- Funktion: bashindices (<expr>)
     Transformiert einen Ausdruck <expr>, der mehrere Summen oder
     Produkte enthlt so, dass alle Summen und Produkte einen
     unterschiedlichen Index haben.  Dies erleichtert zum Beispiel
     Substitutionen mit der Funktion `changevar'.    Die neuen Indizes
     werden mit `j<nummer>' bezeichnet, wobei die Zahl <nummer> der
     Wert der Optionsvariablen `gensumnum'  ist.

     Beispiel:

          (%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                                 inf       inf
                                 ====      ====
                                 \     1   \     1
          (%o1)                   >    - +  >    --
                                 /     k   /      2
                                 ====      ====  k
                                 k = 0     k = 0
          (%i2) bashindices(%);
                               inf         inf
                               ====        ====
                               \      1    \       1
          (%o2)                 >     -- +  >     ---
                               /      j2   /        2
                               ====        ====   j1
                               j2 = 0      j1 = 0

 -- Optionsvariable: cauchysum
     Standardwert: `false'

     Werden zwei Reihen miteinander multipliziert und die
     Optionsvariablen `sumexpand'  sowie `cauchysum' haben beide den
     Wert `true', dann wird die Cauchy-Produktformel angewendet.

     Beispiele:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0

 -- Optionsvariable: genindex
     Standardwert: `i'

     `genindex' enthlt das Zeichen fr den Prfix, der verwendet wird,
     um einen neuen Index fr eine Summe oder ein Produkt zu
     generieren.  Siehe auch `gensumnum'.


 -- Optionsvariable: gensumnum
     Standardwert: 0

     `gensumnum' enthlt die Nummer, die an den Prfix `genindex'
     angehngt wird, um den nchsten Index fr eine Summe oder ein
     Produkt zu generieren.  Hat `gensumnum' den Wert `false', wird der
     Index nur aus dem Zeichen `genindex' gebildet.  Siehe auch
     `genindex'.


 -- Funktion: intosum (<expr>)
     Multipliziert Faktoren in eine Summe herein.  Tritt der Index der
     Summe als ein Faktor auerhalb der Summe auf, wird von der
     Funktion `intosum' ein neuer Index gebildet.  Summen haben die
     Eigenschaft `outative',  so dass Faktoren aus der Summe
     herausgezogen werden.  Mit der Funktion `intosum' wird diese
     Vereinfachung rckgngig gemacht.

     Beispiel:

          (%i1) sum(2*x^2*n^k, k , 0, inf);
                                         inf
                                         ====
                                       2 \      k
          (%o1)                     2 x   >    n
                                         /
                                         ====
                                         k = 0
          (%i2) intosum(%);
                                    inf
                                    ====
                                    \        k  2
          (%o2)                      >    2 n  x
                                    /
                                    ====
                                    k = 0

 -- Funktion: lsum (<expr>, <i>, <L>)
     Bildet die Summe fr den Ausdruck <expr> zum Index <i> fr alle
     Elemente der Liste <L>.  Kann das Argument <L> nicht zu einer Liste
     ausgewertet werden, wird eine Substantivform zurckgegeben.  Siehe
     auch `sum'.

     Beispiele:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)

 -- Funktion: niceindices (<expr>)
     Gibt den Indizes von Summen und Produkten im Ausdruck <expr> einen
     neuen Namen.  `niceindices' benennt die Indizes nacheinander mit
     den Namen, die in der Liste der Optionsvariablen `niceindicespref'
     enthalten sind.  Die Standardnamen sind `[i, j, k, l, m, n]'.
     Sind nicht gengend Namen in der Liste vorhanden, werden weitere
     Indizes durch das Anhngen einer Nummer gebildet.

     `niceindices' wertet das Argument aus.

     Beispiele:

          (%i1) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o1)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i2) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o2)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1

 -- Optionsvariable: niceindicespref
     Standardwert: `[i, j, k, l, m, n]'

     `niceindicespref' ist die Liste mit den Namen, die die Funktion
     `niceindices'  nutzt, um die Indizes von Summen und Produkte
     umzubenennen.

     Beispiele:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1

 -- Funktion: nusum (<expr>, <i>, <i_0>, <i_1>)
     Wendet den Gosper-Algorithmus der unbestimmten Summation fr den
     Ausdruck <expr> und den Index <i> an.  Der Index <i> luft von
     <i_0> bis <i_1>.  Der Ausdruck <expr> und das Ergebnis der
     Summation mssen als Produkte von ganzzahligen Exponentiationen,
     Fakultten, Binomialen und rationalen Funktionen darstellbar sein.

     Die Funktionen `nusum' und `unsum' wenden einige Regeln fr die
     Vereinfachung von Summen und Differenzen von endlichen Produkten
     an.  Siehe auch `unsum'.

     Beispiele:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1

 -- Funktion: product (<expr>, <i>, <i_0>, <i_1>)
     Bildet das Produkt des Ausdrucks <expr> zum Index <i> in den
     Grenzen <i_0> bis <i_1>.  `product' wertet <expr> sowie die untere
     Grenze <i_0> und obere Grenze <i_1> aus.  Der Index <i> wird nicht
     ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> fr jeden Wert des Index <i> ausgewertet.  Das
     Ergebnis ist ein explizites Produkt.  Andernfalls ist der Bereich
     des Index unbestimmt.  Maxima wendet einige einfache Regeln an, um
     das Produkt zu vereinfachen.  Hat die Optionsvariable `simpproduct'
     den Wert `true', wendet Maxima weitere Regeln an, um Produkte zu
     vereinfachen.

     Siehe auch `nouns'  und `evflag'  fr die Auswertung von
     Ausdrcken, die die Substantivform eines Produktes enthalten.

     Beispiele:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- Optionsvariable: simpproduct
     Standardwert: `false'

     Hat `simpproduct' den Wert `true', versucht Maxima ein Produkt
     weiter zu vereinfachen.  Die Vereinfachung kann eine geschlossene
     Form liefern.  Hat `simpproduct' den Wert `false' oder wird das
     Produkt als Substantivform `'product' definiert, werden nur einige
     einfache Regeln von Maxima fr die Vereinfachung angewendet.
     `simpproduct' ist auch ein Auswertungsschalter.  Siehe `evflag'.

     Siehe auch `product'  fr ein Beispiel.


 -- Optionsvariable: simpsum
     Standardwert: `false'

     Hat `simpsum' den Wert `true', versucht Maxima eine Summe oder
     Reihe weiter zu vereinfachen.  Die Vereinfachung kann eine
     geschlossene Form liefern.  Hat `simpsum' den Wert `false' oder
     die Summe oder Reihe liegt als Substantivform `'sum' vor, werden
     nur einige einfache Regeln von Maxima fr die Vereinfachung
     angewendet.  `simpsum' ist auch ein Auswertungsschalter.  Siehe
     `evflag'.

     Siehe auch `sum'  fr ein Beispiel.


 -- Funktion: sum (<expr>, <i>, <i_0>, <i_1>)
     Bildet die Summe des Ausdrucks <expr> zum Index <i> in den Grenzen
     <i_0> bis <i_1>.  Die Funktion `sum' wertet <expr> sowie die
     untere Grenze <i_0> und obere Grenze <i_1> aus.  Der Index <i> wird
     nicht ausgewertet.

     Ist die Differenz der oberen und unteren Grenze eine ganze Zahl,
     wird <expr> fr jeden Wert des Index <i> ausgewertet.  Das
     Ergebnis ist eine explizite Summe.  Andernfalls ist der Bereich
     des Index unbestimmt.  Maxima wendet einige einfache Regeln an, um
     die Summe zu vereinfachen.  Hat die Optionsvariable `simpsum'  den
     Wert `true', wendet Maxima weitere Regeln an, um Summen zu
     vereinfachen.

     Werden zwei unendliche Reihen miteinander multipliziert und die
     Optionsvariablen `sumexpand'  sowie `cauchysum'  haben beide den
     Wert `true', dann wird die Cauchy-Produktformel angewendet.

     Die Optionsvariable `genindex'  enthlt das Zeichen, das der Prfix
     eines automatisch generierten Index ist.  `gensumnum'  enthlt
     eine ganze Zahl, die an den Prfix `genindex' angehngt wird, um
     einen automatischen Index zu generieren.  `gensumnum' wird von
     Maxima automatisch erhht.  Hat `gensumnum' den Wert `false', wird
     keine Zahl an den Prfix angehngt.

     Das Paket `simplify_sum' enthlt die Funktion `simplify_sum',  mit
     der Summen zu einer geschlossenen Form vereinfacht werden knnen.

     Siehe auch `sumcontract',   `sumexpand',  `intosum',
     `bashindices',  `niceindices',  `nouns',   `evflag',  `cauchysum'
     und `zeilberger'.

     Beispiele:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- Funktion: sumcontract (<expr>)
     Fasst alle Summen in dem Ausdruck <expr> zusammen, die sich in
     ihrem oberen und unterem Index nur um eine Konstante voneinander
     unterscheiden.  Das Ergebnis ist eine Ausdruck mit einer Summe,
     fr die Summen, die zusammengefasst werden knnen und weiteren
     Termen, die hinzu addiert werden mssen, um einen quivalenten
     Ausdruck zu erhalten.

     Es kann notwendig sein zunchst das Kommando `intosum(<expr>)'
     auszufhren.  Siehe `intosum'.

     Beispiel:

          (%i1) 'sum(1/l,l,1,n)+'sum(k,k,1,n+2);
                                   n        n + 2
                                  ====      ====
                                  \     1   \
          (%o1)                    >    - +  >    k
                                  /     l   /
                                  ====      ====
                                  l = 1     k = 1
          (%i2) sumcontract(%);
                                      n
                                     ====
                                     \          1
          (%o2)                2 n +  >    (l + -) + 3
                                     /          l
                                     ====
                                     l = 1

 -- Optionsvariable: sumexpand
     Standardwert: `false'

     Hat die Optionsvariable `sumexpand' den Wert `true', werden
     Produkte von Summen und Potenzen von Summen zu verschachtelten
     Summen vereinfacht.  Siehe auch `cauchysum'.

     Beispiele:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0

 -- Funktion: unsum (<f>, <n>)
     Gibt die erste Rckwrtsdifferenz `<f>(<n>) - <f>(<n>-1)' zurck.
     Siehe auch `nusum'.

     Beispiele:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


File: maxima.info,  Node: Einfhrung in Reihen,  Next: Funktionen und Variablen fr Reihen,  Prev: Summen und Produkte,  Up: Summen Produkte und Reihen

15.2 Einfhrung in Reihen
=========================

Maxima kennt die Funktionen `taylor'  und `powerseries',  um die
Reihenentwicklung von differenzierbaren Funktionen zu finden.  Maxima
hat weiterhin Funktionen wie `nusum',  um geschlossene Formen von
Reihen zu finden.  Operationen wie die Addition und Multiplikation
arbeiten wie gewohnt fr Reihen.  Das folgende Kapitel stellt die
Variablen und Funktionen fr eine Reihenentwicklung dar.


File: maxima.info,  Node: Funktionen und Variablen fr Reihen,  Next: Poisson Reihen,  Prev: Einfhrung in Reihen,  Up: Summen Produkte und Reihen

15.3 Funktionen und Variablen fr Reihen
========================================

 -- Funktion: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Fr eine Funktion <f_i> einer Variablen <x_i> definiert
     `deftaylor' den Ausdruck <expr_i> als die Taylorreihe um den
     Nullpunkt.  <expr_i> ist typischerweise ein Polynom in der
     Variablen <x_i> oder eine Summe.  `deftaylor' akzeptiert aber auch
     allgemeinere Ausdrcke.

     `powerseries(<f_i>(<x_i>), <x_i>, 0)' gibt die Reihe zurck, die
     mit `deftaylor' definiert wurde.

     `deftaylor' gibt eine Liste der Funktionen <f_1>, ..., <f_n>
     zurck.  `deftaylor' wertet die Argumente aus.

     Siehe auch `taylor'  und `powerseries'.

     Beispiele:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200

 -- Optionsvariable: maxtayorder
     Standardwert: `true'

     Hat `maxtayorder' den Wert `true', werden bei der algebraischen
     Manipulation von Taylor-Reihen, von der Funktion `taylor'  so viele
     Terme wie mglich mitgefhrt.

 -- Funktion: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)
     Gibt eine Liste aller rationalen Funktionen zurck, die die
     angegebene Taylor-Reihenentwicklung haben und deren Summe des
     Nennergrads und des Zhlergrads kleiner oder gleich des Grads der
     Reihenentwicklung ist.

     Das Argument <taylor_series> ist eine Taylor-Reihe in einer
     Variablen.  Die Argumente <numer_deg_bound> und <denom_deg_bound>
     sind positive ganze Zahlen, die eine Grenze fr den Nennergrad und
     den Zhlergrad der rationalen Funktion angeben.

     Die Taylor-Reihe kann auch eine Laurent-Reihe sein und die Grenzen
     fr den Grad knnen `inf' sein.

     Siehe auch `taylor'.

     Beispiele:

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                   /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Es gibt keine rationale Funktion des Grads 4 im Zhler und Nenner
     fr die oben angegebene Taylor-Reihenentwicklung.  Die Summe des
     Zhlergrads und des Nennergrads mssen mindestens gleich dem Grad
     der Reihenentwicklung sein.  In diesem Fall ist der Grad der
     Taylor-Reihenentwicklung `10'.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]

 -- Funktion: powerseries (<expr>, <x>, <a>)
     Gibt eine geschlossene Form fr die Reihenentwicklung des
     Ausdrucks <expr> in der Variablen <x> um den Punkt <a> zurck.
     Das Argument <a> kann die Werte `inf' oder `infinity' haben.  Die
     Reihenentwicklung fr eine Funktion `f(x)' hat die allgemeine
     Form:
                            inf
                            ====
                            \               n
                 f(x) =      >    b  (x - a)
                            /      n
                            ====
                            n = 0

     Mit den Koeffzienten:
                               !
                      d        !
                      -- (f(x))!
                      dn       !
                               !x = a
                 b  = ---------------
                  n         n!

     Kann die Funktion `powerseries' keine Reihenentwicklung fr den
     Ausdruck <expr> finden, knnen mglicherweise mit der Funktion
     `taylor'  die ersten Terme der Reihenentwicklung berechnet werden.

     Hat die Optionsvariable `verbose'  den Wert `true', werden
     Meldungen zu den verwendeten Algorithmen von der Funktion
     `powerseries' angezeigt.

     Beispiel:

          (%i1) verbose: true$

          (%i2) powerseries (log(sin(x)/x), x, 0);
          trigreduce: can't expand
                           log(sin(x))

          trigreduce: try again after applying the rule:
                                           d
                                         / -- (sin(x))
                                         [ dx
                           log(sin(x)) = I ----------- dx
                                         ]   sin(x)
                                         /


          powerseries: first simplification returned
                                          /
                                          [
                               - log(x) + I cot(x) dx
                                          ]
                                          /

                     inf
                     ====        i1  - 1 + 2 i1             2 i1
                     \      (- 1)   2           bern(2 i1) x
          (%o2)       >     ------------------------------------
                     /                   i1 (2 i1)!
                     ====
                     i1 = 1

 -- Option variable: psexpand
     Default value: `false'

     When `psexpand' is `true', an extended rational function
     expression is displayed fully expanded.  The switch `ratexpand'
     has the same effect.

     When `psexpand' is `false', a multivariate expression is displayed
     just as in the rational function package.

     When `psexpand' is  `multi', then terms with the same total degree
     in the variables are grouped together.

 -- Function: revert (<expr>, <x>)
 -- Function: revert2 (<expr>, <x>, <n>)
     Die Funktion `revert' berechnet eine Taylorreihe in der Variablen
     <x> um den Entwicklungspunkt Null, die der Taylorreihe der
     inversen Funktion entspricht, die von der Taylorreihe <expr>
     reprsentiert wird.  Das Ergebnis ist ein Polynom in einer
     CRE-Darstellung mit dem Grad der hchsten Potenz im Ausdruck
     <expr>.

     Die Funktion `revert2' entspricht der Funktion `revert' mit dem
     Unterschied, dass mit dem dritten Argument <n> der Grad der neuen
     Taylorreihe explizit angegeben werden kann.  Dieser kann kleiner
     oder grer als der Grad der Taylorreihe <expr> sein.

     Mit dem Kommando `load(revert)' werden die Funktionen geladen.

     Siehe auch die Funktion `taylor'.

     Beispiel:

     Die Inverse der Funktion `exp(x) - 1' ist die Funktion `log(x+1)'.
     Mit dem Kommando `revert(taylor(exp(x) - 1, x, 0, 6), x)' wird die
     Taylorreihe der Inversen `log(x+1)' berechnet.

          (%i1) load (revert)$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2

 -- Funktion: taylor (<expr>, <x>, <a>, <n>)
 -- Funktion: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Funktion: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Funktion: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- Funktion: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>,
          <n_2>], ...)
     `taylor(<expr>, <x>, <a>, <n>)' entwickelt den Ausdruck <expr> in
     eine Taylor- oder Laurent-Reihentwicklung in der Variablen <x> um
     den Punkt <a>, die die Terme bis zur Ordnung `(<x> - <a>)^<n>'
     enthlt.

     Hat der Ausdruck <expr> die Form `<f>(<x>)/<g>(<x>)' und hat
     `<g>(<x>)' keine Terme bis zur Ordnung <n>, dann versucht `taylor'
     den Ausdruck `<g>(<x>)' bis zur Ordnung `2 <n>' zu entwickeln.
     Treten in der Entwicklung weiterhin keine von Null verschiedenen
     Terme auf, verdoppelt `taylor' die Ordnung der Entwicklung fr
     `<g>(<x>)' so lange, wie die Ordnung kleiner oder gleich `<n>
     2^taylordepth' ist.  Siehe auch `taylordepth'.

     `taylor(<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' gibt die
     Reihenentwicklung der Ordung n in allen Variablen <x_1>, <x_2>,
     ... um den Punkt `(<a>, <a>, ...)' zurck.

     Die beiden folgenden quivalenten Kommandos `taylor(<expr>,
     [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>], ...)' und
     `taylor(<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' geben eine Reihenentwicklung fr die Variablen
     <x_1>, <x_2>, ... um den Punkt `(<a_1>, <a_2>, ...)' mit den
     Ordnungen <n_1>, <n_2>, ... zurck.

     `taylor(<expr>, [<x>, <a>, <n>, 'asymp])' entwickelt den Ausdruck
     <expr> in negativen Potenzen von `<x> - <a>'.  Der Term mit der
     grten Ordnung ist `(<x> - <a>)^<-n>'.

     Folgende Optionsvariablen kontrollieren die Berechnung einer
     Taylorreihe:

    `maxtayorder'
          Hat `maxtayorder'  den Wert `true', werden bei der
          algebraischen Manipulation von Taylor-Reihen, von der
          Funktion `taylor' so viele Terme wie mglich mitgefhrt.

    `taylordepth'
          Findet `taylor' keine von Null verschiedenen Terme in der
          Reihenentwicklung, wird die Ordnung der Entwicklung solange
          erhht wie sie kleiner oder gleich `2^taylordepth' ist.

    `taylor_logexpand'
          Die Optionsvariable `taylor_logexpand'  kontrolliert die
          Entwicklung von Logarithmusfunktionen, die bei der
          Reihenentwicklung auftreten.  Der Standardwert ist `true' und
          die Logarithmusfunktionen in einer Reihenentwicklung werden
          vollstndig entwickelt.

    `taylor_order_coefficients'
          Die Optionsvariable `taylor_order_coefficients'  kontrolliert
          die Anordung von Termen in einer Reihenentwicklung.  Der
          Standardwert ist `true' und die Anordung entspricht der
          kanonischen Darstellung eines Ausdrucks.

    `taylor_truncate_polynomials'
          Hat die Optionsvariable `taylor_truncate_polynomials'  den
          Wert `false', wird das Ergebnis der Reihenentwicklung eines
          Polynoms als exakt angenommen.

    `taylor_simplifier'
          Die Funktion zur Vereinfachung der Koeffizienten einer
          Entwicklung ist in der Optionsvariablen `taylor_simplifier'
          enthalten.  Der Standardwert ist `simplify'.  Der Variablen
          kann eine nutzerdefinierte Funktion zugewiesen werden.

     Mit der Funktion `taylorp'  kann getestet werden, ob ein Ausdruck
     eine Taylorreihe reprsentiert.  Die Funktion `taylorinfo'  gibt
     Informationen zu einer Taylorreihe aus.  Die spezielle CRE-Form
     einer Taylorreihe wird mit der Funktion `taytorat'  in eine
     Standardform gebracht.  Mit den Funktionen `revert'  und `revert2'
     kann die Taylorreihe einer inversen Funktion berechnet werden.

     Beispiele:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360

 -- Optionsvariable: taylordepth
     Standardwert: 3

     Findet `taylor' keine von Null verschiedenen Terme in der
     Reihenentwicklung, wird die Ordnung der Entwicklung solange erhht
     wie sie kleiner oder gleich `2^taylordepth' ist.

     Siehe auch `taylor'.


 -- Funktion: taylorinfo (<expr>)
     Gibt Informationen ber die Tayolorreihe <expr> zurck.  Die
     Rckgabe ist eine Liste, die Listen mit den Namen der Variablen,
     den Entwicklungspunkten und den Ordnungen der Entwicklung
     enthalten.

     Ist <expr> keine Taylorreihe, ist die Rckgabe `false'.

     Beispiele:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]

 -- Funktion: taylorp (<expr>)
     Hat den Rckgabewert `true', wenn das Argument <expr> eine
     Taylorreihe ist.  Ansonsten ist der Rckgabewert `false'.

 -- Optionsvariable: taylor_logexpand
     Standardwert: `true'

     `taylor_logexpand' kontrolliert die Entwicklung von Logarithmen in
     einer Taylorreihe.  Der Standardwert ist `true' und die
     Logarithmusfunktionen in einer Reihenentwicklung werden
     vollstndig entwickelt.  Ansonsten werden Logarithmusfunktionen so
     weit entwickelt, wie es notwendig ist, um eine formale
     Reihenentwicklung zu erhalten.

 -- Optionsvariable: taylor_order_coefficients
     Standardwert: `true'

     `taylor_order_coefficients' kontrolliert die Ordnung der
     Koeffizienten einer Taylorreihenentwicklung.  Hat
     `taylor_order_coefficients' den Wert `true', werden die
     Koeffizienten kanonisch angeordnet.

 -- Optionsvariable: taylor_simplifier
     Standardwert: `SIMPLIFY'

     Die Optionsvariable `taylor_simplifier' enthlt den Namen der
     Funktion, die fr die Vereinfachung der Koeffizienten einer
     Taylorreihenentwicklung von `taylor'  aufgerufen wird.  Der
     Standardwert ist die Lisp-Funktion `SIMPLIFY'.

 -- Optionsvariable: taylor_truncate_polynomials
     Standardwert: `true'

     Hat die Optionsvariable `taylor_truncate_polynomials' den Wert
     `false', wird das Ergebnis der Reihenentwicklung eines Polynoms
     als exakt angenommen.

     Beispiel:

          (%i1) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:true;
                                    2    4
          (%o1)/T/                 x  + x  + . . .
          (%i2) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:false;
                                        2    4
          (%o2)/T/                     x  + x

 -- Funktion: taytorat (<expr>)
     Konvertiert den Ausdruck <expr> von der speziellen Darstellung
     einer Taylorreihenentwicklung in eine CRE-Form.

     Beispiel:

          (%i1) taylor(atan(x),x,0,5);
                                      3    5
                                     x    x
          (%o1)/T/               x - -- + -- + . . .
                                     3    5
          (%i2) taytorat(%);
                                    5      3
                                 3 x  - 5 x  + 15 x
          (%o2)/R/               ------------------
                                         15

 -- Funktion: trunc (<expr>)
     Die Rckgabe der Funktion `trunc' ist ein Ausdruck, der das
     Argument <expr> in der Ausgabe wie eine Taylorreihenentwicklung
     anzeigt.  Der Ausdruck <expr> wird ansonsten nicht modifiziert.

     Beispiel:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true

 -- Optionsvariable: verbose
     Standardwert: `false'

     Hat die Optionsvariable `verbose' den Wert `true', werden von der
     Funktion `powerseries'  Meldungen ber die verwendeten Algorithmen
     ausgegeben.


File: maxima.info,  Node: Poisson Reihen,  Next: Kettenbrche,  Prev: Funktionen und Variablen fr Reihen,  Up: Summen Produkte und Reihen

15.4 Poisson Reihen
===================

 -- Function: intopois (<a>)
     Converts <a> into a Poisson encoding.

 -- Function: outofpois (<a>)
     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, `outofpois' carries out the
     conversion, i.e., the return value is `outofpois (intopois
     (<a>))'. This function is thus a canonical simplifier for sums of
     powers of sine and cosine terms of a particular type.

 -- Function: poisdiff (<a>, <b>)
     Differentiates <a> with respect to <b>. <b> must occur only in the
     trig arguments or only in the coefficients.

 -- Function: poisexpt (<a>, <b>)
     Functionally identical to `intopois (<a>^<b>)'. <b> must be a
     positive integer.

 -- Function: poisint (<a>, <b>)
     Integrates in a similarly restricted sense (to `poisdiff').
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.

 -- Option variable: poislim
     Default value: 5

     `poislim' determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].

 -- Function: poismap (<series>, <sinfn>, <cosfn>)
     will map the functions <sinfn> on the sine terms and <cosfn> on the
     cosine terms of the Poisson series given. <sinfn> and <cosfn> are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.

 -- Function: poisplus (<a>, <b>)
     Is functionally identical to `intopois (a + b)'.

 -- Function: poissimp (<a>)
     Converts <a> into a Poisson series for <a> in general
     representation.

 -- Special symbol: poisson
     The symbol `/P/' follows the line label of Poisson series
     expressions.

 -- Function: poissubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., `6*u +
     4*v').

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands `cos(<d>)' and
     `sin(<d>)' to order <n> so as to provide the result of substituting
     `<a> + <d>' for <b> in <c>.  The idea is that <d> is an expansion
     in terms of a small parameter.  For example, `poissubst (u, v,
     cos(v), %e, 3)' yields `cos(u)*(1 - %e^2/2) - sin(u)*(%e -
     %e^3/6)'.

 -- Function: poistimes (<a>, <b>)
     Is functionally identical to `intopois (<a>*<b>)'.

 -- Function: poistrim ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the <u>,
     <v>, ..., <z> in a term.  Terms for which `poistrim' is `true'
     (for the coefficients of that term) are eliminated during
     multiplication.

 -- Function: printpois (<a>)
     Prints a Poisson series in a readable format.  In common with
     `outofpois', it will convert <a> into a Poisson encoding first, if
     necessary.


File: maxima.info,  Node: Kettenbrche,  Prev: Poisson Reihen,  Up: Summen Produkte und Reihen

15.5 Kettenbrche
=================

 -- Function: cf (<expr>)
     Converts <expr> into a continued fraction. <expr> is an expression
     comprising continued fractions and square roots of integers.
     Operands in the expression may be combined with arithmetic
     operators. Aside from continued fractions and square roots,
     factors in the expression must be integer or rational numbers.
     Maxima does not know about operations on continued fractions
     outside of `cf'.

     `cf' evaluates its arguments after binding `listarith' to `false'.
     `cf' returns a continued fraction, represented as a list.

     A continued fraction `a + 1/(b + 1/(c + ...))' is represented by
     the list `[a, b, c, ...]'. The list elements `a', `b', `c', ...
     must evaluate to integers. <expr> may also contain `sqrt (n)'
     where `n' is an integer. In this case `cf' will give as many terms
     of the continued fraction as the value of the variable `cflength'
     times the period.

     A continued fraction can be evaluated to a number by evaluating
     the arithmetic representation returned by `cfdisrep'. See also
     `cfexpand' for another way to evaluate a continued fraction.

     See also `cfdisrep', `cfexpand', and `cflength'.

     Examples:

        * <expr> is an expression comprising continued fractions and
          square roots of integers.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controls how many periods of the continued fraction
          are computed for algebraic, irrational numbers.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * A continued fraction can be evaluated by evaluating the
          arithmetic representation returned by `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima does not know about operations on continued fractions
          outside of `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Function: cfdisrep (<list>)
     Constructs and returns an ordinary arithmetic expression of the
     form `a + 1/(b + 1/(c + ...))' from the list representation of a
     continued fraction `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2

 -- Function: cfexpand (<x>)
     Returns a matrix of the numerators and denominators of the last
     (column 1) and next-to-last (column 2) convergents of the
     continued fraction <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902

 -- Option variable: cflength
     Default value: 1

     `cflength' controls the number of terms of the continued fraction
     the function `cf' will give, as the value `cflength' times the
     period.  Thus the default is to give one period.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


File: maxima.info,  Node: Analysis,  Next: Polynome,  Prev: Summen Produkte und Reihen,  Up: Top

16 Analysis
***********

* Menu:

* Funktionen und Variablen fr Grenzwerte::
* Funktionen und Variablen der Differentiation::
* Integration::
* Differentialgleichungen::


File: maxima.info,  Node: Funktionen und Variablen fr Grenzwerte,  Next: Funktionen und Variablen der Differentiation,  Prev: Analysis,  Up: Analysis

16.1 Funktionen und Variablen fr Grenzwerte
============================================

 -- Optionsvariable: lhospitallim
     Standardwert: 4

     `lhospitallim' enthlt die maximale Zahl an Iterationen, fr die
     die L'Hospitalsche Regel von der Funktion `limit' angewendet wird.
     Damit wird verhindert, dass `limit' in eine unendliche Schleife
     gert.


 -- Funktion: limit (<expr>, <x>, <val>, <dir>)
 -- Funktion: limit (<expr>, <x>, <val>)
 -- Funktion: limit (<expr>)
     Berechnet den Grenzwert des Ausdrucks <expr>, wenn die reelle
     Variable <x> gegen den Wert <val> in Richtung <dir> geht.  Die
     Richtung <dir> kann die Werte <plus> fr einen Grenzwert von oben
     und <minus> fr einen Grenzwert von unten haben.  Fr einen
     zweiseitigen Grenzwert wird die Richtung <dir> nicht angegeben.

     Maxima verwendet die folgenden Symbole fr unendliche und
     infinitesimale Gren sowie undefinierte und unbestimmte Gren,
     wie sie als Ergebnis eines Grenzwertes oder als Wert fr die
     Bestimmung eines Grenzwertes auftreten:

    `inf'
          positiv unendlich

    `minf'
          negativ unendlich

    `infinity'
          komplex unendlich

    `zeroa'
          postiv unendlich klein

    `zerob'
          negativ unendlich klein

    `und'
          nicht definiert

    `ind'
          unbestimmt

     `lhospitallim' enthlt die maximale Zahl an Iterationen, fr die
     die L'Hospitalsche Regel von der Funktion `limit' angewendet wird.

     Hat `tlimswitch' den Wert `true', nutzt die Funktion `limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.

     Hat die Optionsvariable `limsubst' den Wert `false', wird die
     Ersetzung von `limit(f(g(x)),x,x0)' durch `f(limit(g(x),x,x0))' fr
     eine unbekannte Funktion `f' verhindert. Siehe auch `limsubst'.

     `limit' kann mit einem Argument aufgerufen werden, um Ausdrcke zu
     vereinfachen, die unendliche oder infinitesimale Gren enthalten.
     Zum Beispiel wird `limit(inf-1)' zu `inf' vereinfacht.

     Der Algorithmus ist in der folgenden Arbeit beschrieben: Wang, P.,
     "Evaluation of Definite Integrals by Symbolic Manipulation", Ph.D.
     thesis, MAC TR-92, October 1971.

     Beispiele:

          (%i1) limit(x*log(x),x,0,plus)
          (%o1)                           0
          (%i2) limit((x+1)^(1/x),x,0)
          (%o2)                          %e
          (%i3) limit(%e^x/x,x,inf)
          (%o3)                          inf
          (%i4) limit(sin(1/x),x,0)
          (%o4)                          ind


 -- Optionsvariable: limsubst
     Standardwert: `false'

     Ist eine Funktion `f' teil eines Ausdrucks fr den Maxima den
     Grenzwert sucht, dann wird folgende Ersetzung ausgefhrt:

             limit   f(g(x)) = f(limit   g(x))
             x -> x0             x -> x0

     Hat die Optionsvariable `limsubst' den Wert `false', fhrt `limit'
     die oben gezeigte Ersetzung nicht fr unbekannte Funktionen `f'
     aus.  Dies vermeidet Fehler wie zum Beispiel ein Ergebnis von 1 fr
     den Grenzwert `limit (f(n)/f(n+1), n, inf)'.  Hat `limsubst' den
     Wert `true', fhrt Maxima die oben gezeigte Ersetzung auch fr
     unbekannte Funktionen `f' aus.

     Beispiele:

     Die Funktion `f' ist nicht definiert.  Maxima gibt im ersten Fall
     eine Substantivform zurck.  Im zweiten Fall nimmt Maxima den
     Grenzwert fr die unbekannte Funktion als `f(10)' an.

          (%i1) limit(f(x),x,10),limsubst:false;
          (%o1)                     limit   f(x)
                                    x -> 10
          (%i2) limit(f(x),x,10),limsubst:true;
          (%o2)                         f(10)


 -- Funktion: tlimit (<expr>, <x>, <val>, <dir>)
 -- Funktion: tlimit (<expr>, <x>, <val>)
 -- Funktion: tlimit (<expr>)
     Bestimmt den Grenzwert mit Hilfe der Taylor-Reihenwicklung des
     Ausdrucks `expr', wenn die Variable <x> gegen den Wert `val' aus
     der Richtung <dir> geht.  Diese Methode wird von `limit'
     angewendet, wenn die Optionsvariable `tlimswitch' den Wert `true'
     ist.  Das ist der Standardwert.


 -- Optionsvariable: tlimswitch
     Standardwert: `true'

     Hat `tlimswitch' den Wert `true', nutzt die Funktion `limit' eine
     Taylor-Reihenentwicklung, wenn der Grenzwert nicht mit anderen
     Methoden bestimmt werden kann.



File: maxima.info,  Node: Funktionen und Variablen der Differentiation,  Next: Integration,  Prev: Funktionen und Variablen fr Grenzwerte,  Up: Analysis

16.2 Funktionen und Variablen der Differentiation
=================================================

 -- Funktion: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Funktion: at (<expr>, <eqn>)
     Wertet den Ausdruck <expr> aus, wobei dessen Variablen die Werte
     annehmen, die in der Liste der Gleichungen `[<eqn_1>, ...,
     <eqn_n>]' oder in der einzelnen Gleichung <eqn> angegeben sind.

     Wenn ein Teilausdruck von einer Variablen abhngt, fr die ein Wert
     angegeben ist, aber kein `atvalue', und er auch sonst nicht
     ausgewertet werden kann, dann wird von `at' eine Substantivform
     zurckgegeben.

     `at' fhrt mehrfache Ersetzungen parallel aus.

     Siehe auch `atvalue'.    Fr andere Funktionen, die Ersetzungen
     ausfhren, siehe weiterhin `subst'  und `ev'.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Funktion: antid (<expr>, <x>, <u(x)>)
     Gibt eine Liste mit zwei Elementen zurck aus denen die
     Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     konstruiert werden kann.  Der Ausdruck <expr> kann eine unbekannte
     Funktion <u> und deren Ableitungen enthalten.  Ist <L> das
     Ergebnis der Funktion `antid', dann ist der Ausdruck `<L>[1]+
     'integrate(<L>[2], <x>)' die gesuchte Stammfunktion des Ausdrucks
     <expr> mit der Variablen <x>.

     Kann `antid' die Stammfunktion vollstndig bestimmen, ist das
     zweite Element der Liste Null.  Hat `antid' keinerlei Erfolg, ist
     das erste Element der Liste Null.  In anderen Fllen enthlt das
     erste Elemente den integrierbaren Anteil des Ausdrucks <expr> und
     das zweite Element den nicht integrierbaren Anteil des Ausdrucks.

     Mit dem Kommando `load(antid)' wird die Funktion geladen.

     `antid' steht in folgender Beziehung zur Funktion `antidiff': Ist
     <L> die Liste mit den Ergebnissen der Funktion `antid', dann hat
     die Funktion `antidiff' das Ergebnis `<L>[1] + 'integrate(<L>[2],
     <x>)' mit <x> als der Variablen des Ausdrucks <expr>.

     Beispiele:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Funktion: antidiff (<expr>, <x>, <u>(<x>))
     Gibt die Stammfunktion des Ausdrucks <expr> mit der Variablen <x>
     zurck.  Der Ausdruck <expr> kann eine unbekannte Funktion <u> und
     deren Ableitungen enthalten.

     Kann `antidiff' die Stammfunktion nicht oder nur teilweise
     bestimmen, enthlt das Ergebnis das Integral des nicht
     bestimmbaren Anteils.

     Mit dem Kommando `load(antid)' wird die Funktion geladen.

     `antidiff' steht in folgender Beziehung zur Funktion `antid': Ist
     <L> die Liste mit den Ergebnissen der Funktion `antid', dann hat
     die Funktion `antidiff' das Ergebnis `<L>[1] + 'integrate(<L>[2],
     <x>)' mit <x> als der Variablen des Ausdrucks <expr>.

     Fr Beispiele und weitere Ausfhrungen siehe die Funktion `antid'.


 -- Eigenschaft: atomgrad
     Wird fr ein Symbol eine Ableitung mit der Funktion `gradef'
     definiert, dann erhlt das Symbol die Eigenschaft `atomgrad'.


 -- Funktion: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Funktion: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Dem Ausdruck <expr> wird der Wert <c> am Punkt `<x> = <a>'
     zugewiesen.  Typischerweise werden Randwerte mit der Funktion
     `atvalue' definiert.

     Der Ausdruck <expr> ist entweder eine Funktion `<f>(<x_1>, ...,
     <x_m>)' oder die Ableitung einer Funktion `diff(<f>(<x_1>, ...,
     <x_m>), <x_1>, <n_1>, ..., <x_n>, <n_m>)'.  Die Argumente mssen
     explizit auftreten.  <n_i> ist die Ordnung der Ableitung bezglich
     der Variablen <x_i>.

     Die Randwerte werden durch die Liste `[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]' definiert.  Eine einzelne Gleichung muss nicht als Liste
     angegeben werden.

     `printprops([<f_1>, <f_2>, ...], atvalue)' zeigt die Randwerte der
     Funktionen `<f_1>, <f_2>, ...' wie sie mit der Funktion `atvalue'
     definiert wurden.  `printprops (<f>, atvalue)' zeigt nur die
     Randwerte fr die Funktion <f>.  `printprops (all, atvalue)' zeigt
     die Randwerte aller Funktionen.

     Die Symbole `@1', `@2', ... reprsentieren die Variablen <x_1>,
     <x_2>, ..., wenn die Randwerte angezeigt werden.

     `atvalue' wertet die Argumente aus.  `atvalue' gibt den Randwert
     <c> zurck.

     Beispiele:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Paket: cartan
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations. The
     `cartan' package implements the functions `ext_diff' and
     `lie_diff', along with the operators `~' (wedge product) and `|'
     (contraction of a form with a vector.)  Type `demo (tensor)' to
     see a brief description of these commands along with examples.

     `cartan' was implemented by F.B. Estabrook and H.D. Wahlquist.


 -- Funktion: del (<x>)
     `del(<x>)' reprsentiert das Differential der Variablen <x>.

     `diff' gibt Ausdrcke zurck, die Differentiale enthalten, wenn
     keine Variablen angegeben sind, nach denen abgeleitet werden soll.
     In diesem Fall gibt `diff' das totale Differential zurck.

     Beispiele:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Funktion: delta (<t>)
     Die Diracsche Delta-Funktion.

     Maxima kennt die Delta-Funktion nur im Zusammenhang mit
     Laplace-Transformationen.  Siehe `laplace'.

     Beispiel:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- Systemvariable: dependencies
     Standardwert: `[]'

     `dependencies' ist eine Liste der Symbole, fr die eine
     Abhngigkeit mit den Funktionen `depends' oder `gradef' definiert
     wurde.  Siehe `depends'  und `gradef'.


 -- Funktion: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Definiert die Abhngigkeit einer Funktion <f> von einer Variablen
     <x>.  Ist keine Abhngigkeit definiert, dann hat die Ableitung
     `diff(f, x)' das Ergebnis Null.  Wird mit dem Kommando `depends(f,
     x)' definiert, dass die Funktion <f> von der Variablen <x>
     abhngt, dann ist das Ergebnis der Ableitung die Substantivform
     `'diff(f,x,1)'.

     Jedes Argument <f_1>, <x_1>, ... kann der Name einer Variablen,
     eines Arrays oder eine Liste mit Namen sein.  Jedes Symbol <f_i>
     hngt ab von den Symbolen der Liste <x_i>.  Ist eines der Symbole
     <f_i> der Name eines Arrays, dann hngen alle Elemente des Arrays
     von <x_i> ab.

     `diff' erkennt indirekte Abhngigkeiten und wendet fr diesen Fall
     die Kettenregel an.

     `remove(<f>, dependency)' entfernt alle Abhngigkeiten, die fr
     <f> definiert wurden.

     `depends' gibt eine Liste der Abhngigkeiten zurck.  Die
     Abhngigkeiten werden in die Informationsliste `dependencies'
     eingetragen.  `depends' wertet die Argumente aus.

     Die Funktion `diff' ist die einzige Maxima-Funktion, die
     Abhngigkeiten erkennt, die mit `depends' definiert wurden.
     Andere Funktionen wie `integrate' oder `laplace' erkennen keine
     Abhngigkeiten die mit der `depends' definiert wurden.  Fr diese
     Funktionen mssen die Abhngigkeiten explizit angegeben werden,
     zum Beispiel als `integrate(f(x), x)'.

     Beispiele:

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Optionsvariable: derivabbrev
     Standardwert: `false'

     Hat `derivabbrev' den Wert `true', werden symbolische Ableitungen
     mit einem tiefgestelltem Index angezeigt.  Ansonsten werden
     Ableitungen als `dy/dy' angezeigt.


 -- Funktion: derivdegree (<expr>, <y>, <x>)
     Gibt die hchste Ableitung des Arguments <y> in Bezug auf die
     Variable <x> zurck, die in dem Ausdruck <expr> enthalten ist.

     Beispiel:

          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Auswertungsschalter: derivlist (<var_1>, ..., <var_k>)
     `derivlist' ist ein Auswertungsschalter fr die Funktion `ev'.
     `ev' fhrt nur die Ableitungen in Bezug auf die angegebenen
     Variablen <var_1>, ..., <var_k> aus.


 -- Optionsvariable: derivsubst
     Standardwert: `false'

     Hat `derivsubst' den Wert `true', werden Substitutionen auch in
     Ausdrcke mit Ableitungen ausgefhrt.  Zum Beispiel hat dann
     `subst(x, 'diff(y, t), 'diff(y, t, 2))' das Ergebnis `'diff(x, t)'.


 -- Funktion: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Funktion: diff (<expr>, <x>, <n>)
 -- Funktion: diff (<expr>, <x>)
 -- Funktion: diff (<expr>)
     Gibt die Ableitungen oder Differentiale des Ausdrucks <expr> in
     Bezug auf alle oder einige der Variablen des Ausdrucks zurck.

     `diff(<expr>, <x>, <n>)' gibt die n-te Ableitung des Ausdrucks
     <expr> in Bezug auf die Variable <x> zurck.

     `diff(<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' gibt die partielle
     Ableitung des Ausdrucks <expr> in Bezug auf die Variablen <x_1>,
     ..., <x_m> zurck.  Dies ist quivalent zu `diff(...
     (diff(<expr>, <x_m>, <n_m>) ...), <x_1>, <n_1>)'.

     `diff(<expr>, <x>)' gibt die erste Ableitung des Ausdrucks <expr>
     in Bezug auf die Variable <x> zurck.

     `diff(<expr>)' gibt das totale Differential des Ausdrucks <expr>
     zurck.  Siehe auch `del'.

     Wenn die Ableitungen nicht ausgefhrt werden sollen, kann der
     Quote-Operator verwendet werden, um eine Substantivform der
     Ableitung zu erhalten.

     Hat `derivabbrev' den Wert `true', werden symbolische Ableitungen
     mit einem tiefgestelltem Index angezeigt.  Ansonsten werden
     Ableitungen als `dy/dy' angezeigt.

     Beispiele:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

       1. The derivatives of any indexed objects in <expr> will have the
          variables <x_i> appended as additional arguments.  Then all
          the derivative indices will be sorted.

       2. The <x_i> may be integers from 1 up to the value of the
          variable `dimension' [default value: 4].  This will cause the
          differentiation to be carried out with respect to the
          <x_i>'th member of the list `coordinates' which should be set
          to a list of the names of the coordinates, e.g., `[x, y, z,
          t]'.  If `coordinates' is bound to an atomic variable, then
          that variable subscripted by <x_i> will be used for the
          variable of differentiation.  This permits an array of
          coordinate names or subscripted names like `X[1]', `X[2]',
          ... to be used.  If `coordinates' has not been assigned a
          value, then the variables will be treated as in (1) above.


 -- Auswertungsschalter: diff
     `diff' ist ein Auswertungsschalter fr die Funktion `ev'.  Das
     Kommando `ev(expr), diff' bewirkt, dass alle Ableitungen ausgefhrt
     werden, die im Ausdruck <expr> enhalten sind.  Siehe auch die
     Funktion `ev'.


 -- Funktion: dscalar (<f>)
     Wendet den d'Alembert-Operator auf eine skalare Funktion <f> an.
     Der d'Alembert-Operator ist die Verallgemeinerung des Gradienten
     auf den vierdimensionalen Minkowski-Raum.

     Das Kommando `load(ctensor)' ldt die Funktion.


 -- Funktion: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Funktion: gradef (<a>, <x>, <expr>)
     Definiert eine partielle Ableitung der Funktion <f> oder Variablen
     <a>.

     Das Kommando `gradef(<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)'
     definiert die partielle Ableitung `d<f>/d<x_i>' als <g_i>.  <g_i>
     ist ein Ausdruck.  <g_i> kann ein Funktionsaufruf sein, aber nicht
     der Name einer Funktion.  Die Anzahl der partiellen Ableitungen
     <m> kann kleiner sein als die Anzahl der Argumente <n>.

     `gradef(<a>, <x>, <expr>)' definierte die Ableitung der Variablen
     <a> in Bezug auf die Variable <x> als <expr>.  Wie mit der
     Funktion `depends' wird <a> als abhngig von <x> deklariert.  Die
     Abhngigkeit wird in die Liste `dependencies' eingetragen.  Siehe
     auch `depends'.

     Bis auf das erste Argument werden die Argumente der Funktion
     `gradef' ausgewertet.  `gradef' gibt die Funktion oder Variable
     zurck, fr die eine partielle Ableitung definiert wurde.

     `gradef' kann die Ableitungen von vorhandenen Maxima-Funktionen neu
     definieren.  Zum Beispiel definiert `gradef(sin(x), sqrt (1 -
     sin(x)^2))' eine neue Ableitung der Sinusfunktion.

     `gradef' kann keine partiellen Ableitungen fr indizierte
     Funktionen definieren.

     `printprops([<f_1>, ..., <f_n>], gradef)' zeigt die mit `gradef'
     definierten partiellen Ableitungen der Funktionen <f_1>, ...,
     <f_n> an und `printprops([<a_n>, ..., <a_n>], atomgrad)' zeigt die
     mit `gradef' definierten partiellen Ableitungen der Variablen
     <a_n>, ..., <a_n> an.

     `gradefs' ist eine Informationsliste, die die Funktionen enthlt,
     fr die mit `gradef' eine Ableitung definierte wurde.  Die Liste
     enthlt keine Variablen, fr die Ableitungen definiert wurden.


 -- Systemvariable: gradefs
     Standardwert: `[]'

     `gradefs' ist eine Liste der Funktionen, fr die eine Ableitung
     definiert wurde.



File: maxima.info,  Node: Integration,  Next: Differentialgleichungen,  Prev: Funktionen und Variablen der Differentiation,  Up: Analysis

16.3 Integration
================

* Menu:

* Einfhrung in die Integration::
* Funktionen und Variablen der Integration::
* Einfhrung in QUADPACK::
* Funktionen und Variablen fr QUADPACK::


File: maxima.info,  Node: Einfhrung in die Integration,  Next: Funktionen und Variablen der Integration,  Prev: Integration,  Up: Integration

   Integration

16.3.1 Einfhrung in die Integration
------------------------------------

Maxima hat verschiedene Routinen um Integrale zu behandeln.  Die
Funktion `integrate' nutzt diese.  Maxima hat ein Paket `antid', welches
Integrale mit einer unbekannten Funktion, deren Ableitung bekannt ist,
integrieren kann.  Fr die numerische Berechnung von Integralen hat
Maxima das Paket `QUADPACK' mit Funktionen wie `quad_qag' oder
`quad_qags'.  Die Funktionen `laplace' und `specint' finden die
Laplacetransformation.


File: maxima.info,  Node: Funktionen und Variablen der Integration,  Next: Einfhrung in QUADPACK,  Prev: Einfhrung in die Integration,  Up: Integration

16.3.2 Funktionen und Variablen der Integration
-----------------------------------------------

 -- Funktion: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Fhrt eine Substitution der Integrationsvariablen, die als
     <f(x,y)=0> angegeben wird, fr die Variable <x> in allen
     Integralen durch, die in <expr> enthalten sind.  Die neue Variable
     ist <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Ein Ausdruck mit einem Integral in einer Substantivform
     `'integrate' wie im obigen Beispiel kann mit der Funktion `ev' und
     dem Auswertungsschalter `nouns' ausgewertet werden.  Das Beispiel
     von oben kann zum Beispiel mit `ev(%o3, nouns)' ausgewertet werden.

     Mit `changevar' knnen auch die Indizes einer Summe oder eines
     Produktes substituiert werden.  Dabei muss beachtet werden, dass
     nur lineare Verschiebungen, wie zum Beispiel `i = j + ...', eine
     korrekte Substitution fr Summen und Produkte sind.

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Funktion: dblint (<f>, <r>, <s>, <a>, <b>)
     Eine Routine, um ein bestimmtes doppeltes Integral mit der
     Simpsonschen Regel numerisch zu berechnen.

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     Die Funktion <f> muss eine Funktion von zwei Variablen sein.  <r>
     und <s> mssen Funktionen einer Variablen sein.  <a> und <b> sind
     Gleitkommazahlen.  Die Optionsvariablen `dblint_x' und `dblint_y'
     kontrollieren die Anzahl der Unterteilungen des
     Integrationsintervalls fr den Simpsonschen Algorithmus.  Der
     Standardwert ist jeweils 10.

     Das Kommando `demo(dblint)' zeigt ein Beispiel.

     Die numerischen Funktionen des Pakets `QUADPACK' sind gegenber
     `dblint' zu bevorzugen.


 -- Funktion: defint (<expr>, <x>, <a>, <b>)
     Sucht das bestimmte Integral eines Ausdrucks <expr> fr die
     Integrationsvariable <x> in den Grenzen <a> und <b>.  Diese
     Funktion wird ausgefhrt, wenn ein bestimmtes Integral mit der
     Funktion `integrate' gesucht wird.

     `defint' gibt einen symbolischen Ausdruck als Ergebnis zurck.
     Ist das Integral divergent generiert Maxima eine Fehlermeldung.
     Kann `defint' keine Lsung finden, wird eine Substantivform
     zurckgegeben.


 -- Option variable: erfflag
     Standardwert: `true'

     Hat `erfflag' den Wert `false', werden von der Funktion `risch'
     keine Fehlerfunktion `erf' in die Lsung eingefhrt.


 -- Funktion: ilt (<expr>, <s>, <t>)
     Berechnet die Inverse Laplace-Transformation des Ausdrucks <expr>
     fr die Variable <s> und den Parameter <t>.  <expr> muss eine
     rationale Funktion sein, in deren Nenner nur lineare und
     quadratische Faktoren auftreten.  Mit den Funktionen `laplace' und
     `ilt' sowie den Funktionen `solve' oder `linsolve' knnen lineare
     Differentialgleichungen oder Systeme von linearen
     Differentialgleichungen gelst werden.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Optionsvariable: intanalysis
     Standardwert: `true'

     Hat `intanalysis' den Wert `true', sucht Maxima nach Polen in einem
     Integranden.  Existieren solche, wird der Cauchysche Hauptwert des
     Integrals bestimmt.  Hat `intanalysis' den Wert `false', wird die
     Integration unter der Annahme ausgefhrt, dass das Integral keine
     Pole im Integrationsbereich hat.

     Siehe auch `ldefint'.

     Beispiele:

     Maxima kann die folgende Integral lsen, wenn `intanalysis' den
     Wert `false' hat.

          (%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                          1
                                         /
                                         [       1
          (%o1)                          I  ----------- dx
                                         ]  sqrt(x) + 1
                                         /
                                          0

          (%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
          (%o2)                            2 - 2 log(2)

          (%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
          The number 1 isn't in the domain of atanh
           -- an error. To debug this try: debugmode(true);

          (%i4) intanalysis:false$
          (%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                                %pi
          (%o5)                                 ---
                                                 2


 -- Funktion: integrate (<expr>, <x>)
 -- Funktion: integrate (<expr>, <x>, <a>, <b>)
     Sucht die symbolische Lsung des Integrals fr den Ausdruck <expr>
     fr die Integrationsvariable <x>.  `integrate(<expr>, <x>' ist das
     unbestimmte Integral.  `integrate (<expr>, <x>, <a>, <b>)' sucht
     die Lsung des bestimmten Integrals in den Integrationsgrenzen <a>
     und <b>.  Die Integrationsgrenzen sollten die Integrationsvariable
     <x> nicht enthalten.  Fr die Integrationsgrenzen muss nicht gelten
     <a> < <b>.  Sind die Integrationsgrenzen gleich, dann ist das
     Ergebnis der Integration Null.

     Fr die numerische Lsung von Integrale siehe die Funktion
     `quad_gag' und verwandte Funktionen.  Residuen eines Integranden
     knnen mit der Funktion `residue' berechnet werden.  Einen
     alternativen Algorithmus fr das Berechnen von Integralen mit
     einer unbekannten Funktion bietet die Funktion `antid'.

     Findet `integrate' keine Lsung wird eine Substantivform oder ein
     Ausdruck mit einer oder mehreren Substantivformen zurckgegeben.

     Soll das Integral nicht sofort berechnet werden, kann die
     Substantivform des Integrals angegeben werden, zum Beispiel
     `'integrate(<expr>, <x>)'.  Die Berechnung des Integrals ist dann
     mit Funktion `ev' und dem Auswertungsschalter `nouns' mglich.

     Die Abhngigkeit der Funktionen im Integranden von Parametern im
     Integranden muss explizit zum Beispiel mit `f(x)' angegeben
     werden.  `integrate' beachtet keine Abhngigkeit der mit den
     Funktion `depends' definiert werden.

     Bentigt `integrate' Informationen zu einem Parameter, die nicht
     aus Maximas Datenbank abgeleitet werden knnen, wird der Nutzer
     nach den fehlenden Informationen gefragt.

     `integrate' ist standardmig nicht als linear deklariert.  Siehe
     `declare'  und `linear'.

     Nur in einigen speziellen Fllen versucht `integrate' eine
     partielle Integration anzuwenden.

     Beispiele:

        * Elementare unbestimmte und bestimme Integrale.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Gebrauch von `assume' und interaktive Fragen.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Substitution der Integrationsvariablen.  In diesem Beispiel
          werden zwei verschiedene Substitutionen vorgenommen.  Zuerst
          wird eine Ableitung der Funktion mit der Funktion `gradef'
          definiert.  Die andere nutzt die Ableitung `diff(r(x))' einer
          unbekannten Funktion `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * Die Lsung enthlt eine Substantivform fr das Integral einer
          rationalen Funktion.  Siehe auch `integrate_use_rootsof' fr
          Informationen zu Integralen von rationalen Funktionen.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definition einer Funktion als ein Integral.  Die rechte Seite
          einer Funktionsdefinition wird nicht ausgewertet.  Daher
          enthlt die Funktionsdefinition das Integral in einer
          Substantivform.  Der Quote-Quote-Operator `''' erzwingt die
          Auswertung der Substantivform.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- Optionsvariable: integration_constant
     Standardwert: `%c'

     Wird eine symbolische Integrationskonstante fr die Lsung eines
     Integrals bentigt, erzeugt Maxima diese durch Verkettung des
     Symbols `integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen `integration_counter' ist.

     Der Optionsvariablen `integration_constant' kann ein beliebiges
     Symbol zugewiesen werden.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3


 -- Systemvariable: integration_constant_counter
     Standardwert: 0

     Wird eine symbolische Integrationskonstante fr die Lsung eines
     Integrals bentigt, erzeugt Maxima diese durch Verkettung des
     Symbols `integration_constant' mit einer laufenden Nummer, die der
     Wert der Optionsvariablen `integration_counter' ist.

     Der Wert der Systemvariablen `integration_constant_counter' wird
     vor der Erzeugung der Integrationskonstanten erhht.

     Beispiele:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o3)                     -- = x + %c3
                                    3
          (%i4) reset (integration_constant_counter);
          (%o4)            [integration_constant_counter]
          (%i5) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o5)                     -- = x + %c1
                                    3


 -- Optionsvariable: integrate_use_rootsof
     Standardwert: `false'

     Hat `integrate_use_rootsof' den Wert `true' und der Nenner einer
     rationalen Funktion kann nicht faktorisiert werden, dann gibt
     `integrate' ein Integral zurck, das eine Summe ber die
     unbekannten Wurzeln des Nenners enthlt.

     Hat zum Beispiel `integrate_use_rootsof' den Wert `false', gibt
     `integrate' im Folgenden ein Lsung zurck, die eine Substantivform
     enthlt.

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Mit dem Wert `true' fr die Optionsvariable `integrate_use_rootsof'
     wird das ungelste Integral als eine Summe ber die Wurzeln des
     Nenners der rationalen Funktion zurckgegeben.

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     Alternativ kann der Nutzer die Wurzeln des Nenners separat
     berechnen und den Integranden mit Hilfe der Wurzeln ausdrcken.
     Zum Beispiel als `1/((x - a)*(x - b)*(x - c))' oder
     `1/((x^2-(a+b)*x + a*b)*(x - c))' ein kubisches Polynom mit drei
     Nullstellen im Nenner.  Auf diese Weise kann Maxima in einigen
     Fllen eine Lsung fr ein Integral finden.


 -- Funktion: laplace (<expr>, <t>, <s>)
     Sucht die Laplace-Transformation des Ausdrucks <expr> fr die
     Integrationsvariable <x> und den Parameter <s>.

     `laplace' findet die Laplace-Transformation fr Ausdrcke, die die
     Funktionen `delta', `exp', `log', `sin', `cos', `sinh', `cosh' und
     `erf' sowie Ausdrcke mit `derivative', `integrate', `sum' und
     `ilt' enthalten.  Kann `laplace' die Laplace-Transformation nicht
     finden, wird die Funktion `specint' aufgerufen.  `specint' kann
     die Laplace-Transformation fr eine Vielzahl von speziellen
     Funktion berechnen.

     Findet auch `specint' keine Lsung ist das Ergebnis eine
     Substantivform.

     `laplace' erkennt die Faltung von Funktionen der Form `integrate
     (f(x) * g(t - x), x, 0, t)'.  Andere Faltungen werden nicht
     erkannt.

     Funktionale Abhngigkeiten von Variablen mssen explizit angegeben
     werden.  `laplace' erkennt keine Abhngigkeiten die mit der
     Funktion `depends' definiert wurden.  Eine Funktion, die von den
     Variablen <x> abhngt, muss als `f(x)' im Ausdruck <expr>
     auftreten.

     Siehe auch `ilt',  fr die Inverse Laplace-Transformation.

     Beispiele:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s)
                  ,simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)


 -- Funktion: ldefint (<expr>, <x>, <a>, <b>)
     Sucht die Lsung des bestimmten Integrals fr den Integranden
     <expr>.  `ldefinit' bestimmt die Stammfunktion und sucht die
     Grenzwerte mit der Funktion `limit' an den Integrationsgrenzen <a>
     und <b>.  Kann ein Grenzwert nicht ermittelt werden, enthlt das
     Ergebnis die Substantivform des Grenzwertes.

     `ldefint' wird nicht von der Funktion `integrate' aufgerufen.
     Daher kann `ldefint' ein von `integrate' verschiedenes Ergebnis
     haben.  `ldefint' verwendet immer denselben Algorithmus um eine
     Lsung zu finden.  Dagegen wendet `integrate' verschiedene
     Algorithmen an, um nach einer Lsung zu suchen.


 -- Funktion: residue (<expr>, <z>, <z_0>)
     Berechnet das Residuum fr den Ausdruck <expr>, wenn die Variable
     <z> gegen den Wert <z_0> geht.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Funktion: risch (<expr>, <x>)
     Nutzt den transzendenten Risch-Algorithmus fr die Integration des
     Ausdruck <expr> und der Integrationsvariable <x>.  Der algebraische
     Risch-Algorithmus ist nicht implementiert.  Der transzendente
     Risch-Algorithmus behandelt Integranden mit Exponential- und
     Logarithmusfunktionen.  Der Risch-Algorithmus wird von `integrate'
     aufgerufen, wenn `integrate' keine Stammfunktion finden kann.

     Hat `erfflag' den Wert `false', werden von der Funktion `risch'
     keine Fehlerfunktionen `erf' in die Lsung eingefhrt.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Funktion: tldefint (<expr>, <x>, <a>, <b>)
     Entspricht der Funktion `ldefint' mit dem Wert `true' fr die
     Optionsvariable `tlimswitch'.



File: maxima.info,  Node: Einfhrung in QUADPACK,  Next: Funktionen und Variablen fr QUADPACK,  Prev: Funktionen und Variablen der Integration,  Up: Integration

16.3.3 Einfhrung in QUADPACK
-----------------------------

QUADPACK ist eine Sammlung von Funktionen fr die numerische Berechnung
von eindimensionalen bestimmten Integralen.  QUADPACK hat den Ursprung
in einem Projekt von R. Piessens (1), E. de Doncker (2), C. Ueberhuber
(3), und D. Kahaner (4).

   Die QUADPACK Bibliothek, die in Maxima enthalten ist, ist eine
automatische bersetzung des Fortran Quellcodes mit dem Programm
`f2cl', wie er in der SLATEC Common Mathematical Library, Version 4.1
(5) vorliegt.  Die SLATEC Bibliothek datiert auf Juli 1993.  Die
QUADPACK Funktionen wurden bereits einige Jahre frher programmiert.
Es gibt eine weitere Version von QUADPACK bei Netlib (6). Es ist jedoch
unklar worin sich diese von der SLATEC Version unterscheidet.

   Alle in Maxima enthaltenen QUADPACK-Funktionen versuchen automatisch
ein bestimmtes Integral numerisch innerhalb eine spezifierten
Genauigkeit zu berechnen.  Die bersetzung nach Lisp enthlt einige
weitere nicht-automatische Funktionen, die jedoch nicht als Maxima
Funktionen zur Verfgung stehen.

   Weitere Informationen ber QUADPACK knnen in dem QUADPACK-Buch (7)
nachgelesen werden.

bersicht
.........

`quad_qag'
     Integration einer allgemeinen Funktion ber ein endliches
     Intervall.  `quad_qag' implementiert eine globalen adaptiven
     Integrator auf Grundlage der Strategie von Aind (Piessens, 1973).
     Es kann aus 6 verschiedenen Paaren von
     Gau-Kronrad-Quadraturformeln ausgewhlt werden.  Die Formeln
     hheren Grades sind fr stark oszillierende Integranden geeignet.

`quad_qags'
     Integration einer allgemeinen Funktion ber ein endliches
     Intervall.  Die Funktion `quad_qags' implementiert die Strategie
     einer globalen adaptiven Unterteilung des Integrationsintervalls
     mit Extrapolation (de Doncker, 1978).  Zustzlich wird versucht,
     die Konvergenz der Integralapproximation mit Hilfe des
     Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.  Dies fhrt zum
     Beispiel bei Integranden mit Singularitten, deren Lage und Typ
     unbekannt sind, zu einer Effizienzsteigerung.

`quad_qagi'
     Integration einer allgemeinen Funktion ber ein unendliches oder
     halb-unendliches Intervall.  Das Intervall wird auf ein endliches
     Intervall transformiert.  Das transformierte Integrationsproblem
     wird dann mit einer geringfgig modifizierten Algorithmus wie in
     `quad_qags' gelst.

`quad_qawo'
     Berechnung von Integralen mit den trigonometrischen
     Gewichtsfunktionen cos(omega x) f(x) oder sin(omega x) f(x) ber
     ein endliches Intervall, wobei omega eine Konstante ist.  Der
     Algorithmus zur Integration basiert auf eine modifizierte
     Clenshaw-Curtis-Technik.  `quad_qawo' wendet eine adaptive
     Unterteilung des Integrationsintervalls mit Extrapolation an, die
     vergleichbar mit dem Algorithmus von `quad_qags' ist.  Zustzlich
     wird versucht, die Konvergenz der Integralapproximation mit Hilfe
     des Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.

`quad_qawf'
     Berechnet die Sinus- oder Kosinus-Fouriertransformation ber ein
     halb-unendliches Intervall.  Dabei wird die global adaptive Routine
     `quad_qawo' sukzessive auf endliche Teilintervalle angewendet.  Zur
     Konvergenzbeschleunigung der resultierenden alternierenden Reihe
     wird dann der Epsilon-Algorithmus (Wynn, 1956) verwendet.

`quad_qaws'
     Integration von w(x) f(x) ber ein endliches Intervall [a, b],
     wobei w eine Funktion der Form (x - a)^alpha (b - x)^beta v(x) ist
     und v(x) ist 1 oder log(x - a) oder log(b - x) oder log(x - a)
     log(b - x), und alpha > -1 und beta > -1.  `quad_qaws' ist
     speziell fr die effiziente Berechnung von Integralen ber
     endliche Intervalle mit algebraischen oder
     algebraisch-logarithmischen Endpunktsingularitt konzipiert.  Eine
     globale adaptive Strategie mit Unterteilung des
     Integrationsintervalls wird angewendet.  Auf Teilintervalle, die
     keinen Endpunkt des Integrationsintervalls enthalten, kommt ein
     Gau-Kronrod-Formelpaar zur Anwendung.  Auf Randintervallen kommen
     modifizierte Clenshaw-Curtis-Formeln zur Anwendung.

`quad_qawc'
     Berechnet den Cauchyschen Hauptwert von f(x)(x - c) ber ein
     endliches Intervall (a, b) und dem Wert c.  Es wird eine
     modifizierte Clenshaw-Curtis-Formel angewendet, wenn c im
     Teilbereich enthalten ist, andernfalls wird eine globale adaptive
     Strategie mit einem Gau-Kronrod-Formelpaar angewendet.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut fr Mathematik, T.U.  Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) `http://www.netlib.org/slatec'

   (6) `http://www.netlib.org/quadpack'

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Funktionen und Variablen fr QUADPACK,  Prev: Einfhrung in QUADPACK,  Up: Integration

16.3.4 Funktionen und Variablen fr QUADPACK
--------------------------------------------

 -- Funktion: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>,
          <epsabs>, <limit>])
 -- Funktion: quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])
     Integration einer allgemeinen Funktion ber ein endliches
     Intervall.  `quad_qag' implementiert eine globalen adaptiven
     Integrator auf Grundlage der Strategie von Aind (Piessens, 1973).
     Es kann aus 6 verschiedenen Paaren von
     Gau-Kronrad-Quadraturformeln ausgewhlt werden.  Die Formeln
     hheren Grades sind fr stark oszillierende Integranden geeignet.

     `quad_qag' berechnet das Integral

     integrate (f(x), x, a, b)

     Die Funktion <f(x)> mit der abhngigen Variablen <x> wird im
     Integrationsintervall <a> und <b> integriert.  <key> whlt den Grad
     der Gau-Kronrod-Quadratorformel aus und kann Werte von 1 bis 6
     annehmen.  Ein grerer Grad ist geeignet fr stark oszillierende
     Integranden.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die numerische Integration wird adaptiv ausgefhrt.  Der
     Integrationsbereich wird solange geteilt, bis die gewnschte
     Genauigkeit erreicht wird.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsrel>
          Gewnschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    <epsabs>
          Gewnschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    <limit>
          Die maximale Zahl an Teilinterallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9


 -- Funktion: quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Funktion: quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Integration einer allgemeinen Funktion ber ein endliches
     Intervall.  `quad_qags' implementiert die Strategie einer globalen
     adaptiven Unterteilung des Integrationsintervalls mit
     Extrapolation (de Doncker, 1978).  Zustzlich wird versucht, die
     Konvergenz der Integralapproximation mit Hilfe des
     Epsilon-Algorithmus (Wynn, 1956) zu beschleunigen.  Dies fhrt zum
     Beispiel bei Integranden mit Singularitten, deren Lage und Typ
     unbekannt sind, zu einer Effizienzsteigerung.

     `quad_qags' berechnet das Integral

     integrate (f(x), x, a, b)

     Die Funktion <f(x)> mit der abhngigen Variablen <x> wird im
     Integrationsintervall <a> und <b> integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsrel>
          Gewnschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    <epsabs>
          Gewnschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    <limit>
          Die maximale Zahl an Teilinterallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     `quad_qags' ist genauer und effiziener als `quad_qag' fr den
     obigen Integranden.


 -- Funktion: quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- Funktion: quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Integration einer allgemeinen Funktion ber ein unendliches oder
     halb-unendliches Intervall.  Das Intervall wird auf ein endliches
     Intervall transformiert.  Das transformierte Integrationsproblem
     wird dann mit einer geringfgig modifizierten Algorithmus wie in
     `quad_qags' gelst.

     `quad_qagi' evaluates one of the following integrals

     `quad_qagi' berechnet die folgenden Integrale

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, minf, inf)

     Die Funktion <f(x)> mit der abhngigen Variablen <x> wird ber
     einen unendlichen Bereich integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Eine der Grenzen des Integrationsbereiches kann unendlich sein.
     Ist dies nicht der Fall gibt `quad_qagi' eine Substantivform
     zurck.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsrel>
          Gewnschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    <epsabs>
          Gewnschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    <limit>
          Die maximale Zahl an Teilinterallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Funktion: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>,
          <epsabs>, <limit>])
 -- Funktion: quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
     Berechnet den Cauchyschen Hauptwert von f(x)(x - c) ber ein
     endliches Intervall (a, b) und dem Wert c.  Es wird eine
     modifizierte Clenshaw-Curtis-Formel angewendet, wenn c im
     Teilbereich enthalten ist, andernfalls wird eine globale adaptive
     Strategie mit einem Gau-Kronrod-Formelpaar angewendet.

     `quad_qawc' berechnet den Cauchyschen Hauptwert von

     integrate (f(x)/(x - c), x, a, b)

     Die Funktion `<f(x)>/(<x> - <c>)', die von der Variablen <x>
     abhngt, wird in den Grenzen <a> und <b> integriert.

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsrel>
          Gewnschter relativer Fehler der Approximation.  Der
          Standardwert ist `1.0e-8'.

    <epsabs>
          Gewnschter absoluter Fehler der Approximation.  Der
          Standardwert ist `0'.

    <limit>
          Die maximale Zahl an Teilinterallen des adaptiven
          Algorithmus.  Der Standardwert ist `200'.

     `quad_qag' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                           x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Funktion: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
 -- Funktion: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
     Berechnet die Sinus- oder Kosinus-Fouriertransformation ber ein
     halb-unendliches Intervall.  Dabei wird die global adaptive Routine
     `quad_qawo' sukzessive auf endliche Teilintervalle angewendet.  Zur
     Konvergenzbeschleunigung der resultierenden alternierenden Reihe
     wird dann der Epsilon-Algorithmus (Wynn, 1956) verwendet.

     `quad_qawf' berechnet das Integral

     integrate (f(x)*w(x), x, a, inf)

     Die Gewichtsfunktion w wird mit dem Schlsselwort <trig>
     ausgewhlt:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsabs>
          Gewnschter absoluter Fehler der Nherung.  Der Standardwert
          ist `1.0e-10'.

    <limit>
          `(<limit> - <limlst>)/2' ist die maxima Zahl an
          Teilintervallen des adaptiven Algorithmus.  Der Standardwert
          ist `200'.

    <maxp1>
          Die maximale Anzahl an Chebyshev-Gewichten.  Der Wert muss
          grer als 0 sein.  Der Standardwert ist `100'.

    <limlst>
          Obere Grenze fr die Anzahl an Zyklen.  Der Wert muss grer
          oder gleich 3 sein.  Der Standardwert ist 10.

     `quad_qawf' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Funktion: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
 -- Funktion: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>,
          [<epsrel>, <epsabs>, <limit>, <maxp1>, <limlst>])
     Berechnung von Integralen mit den trigonometrischen
     Gewichtsfunktionen cos(omega x) f(x) oder sin(omega x) f(x) ber
     ein endliches Intervall, wobei omega eine Konstante ist.  Der
     Algorithmus basiert auf eine modifizierte Clenshaw-Curtis-Technik.
     `quad_qawo' wendet eine adaptive Unterteilung des
     Integrationsintervalls mit Extrapolation an, die vergleichbar mit
     dem Algorithmus von `quad_qags' ist.  Zustzlich wird versucht, die
     Konvergenz der Integralapproximation mit Hilfe des
     Epsilon-Algorithmus zu beschleunigen.

     `quad_qawo' berechnet das Integral

     integrate (f(x)*w(x), x, a, b)

     Die Gewichtsfunktion w wird mit dem Schlsselwort <trig>
     ausgewhlt:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsrel>
          Gewnschter relativer Fehler der Nherung.  Der Standardwert
          is `1.0e-8'

    <epsabs>
          Gewnschter absoluter Fehler der Nherung.  Der Standardwert
          ist `0'.

    <limit>
          `<limit>/2' ist die maxima Zahl an Teilintervallen des
          adaptiven Algorithmus.  Der Standardwert ist `200'.

    <maxp1>
          Die maximale Anzahl an Chebyshev-Gewichten.  Der Wert muss
          grer als 0 sein.  Der Standardwert ist `100'.

    <limlst>
          Obere Grenze fr die Anzahl an Zyklen.  Der Wert muss grer
          oder gleich 3 sein.  Der Standardwert ist 10.

     `quad_qawo' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                          x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Funktion: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>,
          <wfun>, [<epsrel>, <epsabs>, <limit>])
 -- Funktion: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
     Integration von w(x) f(x) ber ein endliches Intervall [a, b],
     wobei w eine Funktion der Form (x - a)^alpha (b - x)^beta v(x) ist
     und v(x) ist 1 oder log(x - a) oder log(b - x) oder log(x - a)
     log(b - x), und alpha > -1 und beta > -1.  `quad_qaws' ist
     speziell fr die effiziente Berechnung von Integralen ber
     endliche Intervalle mit algebraischen oder
     algebraisch-logarithmischen Endpunktsingularitt konzipiert.  Eine
     globale adaptive Strategie mit Unterteilung des
     Integrationsintervalls wird angewendet.  Auf Teilintervalle, die
     keinen Endpunkt des Integrationsintervalls enthalten, kommt ein
     Gau-Kronrod-Formelpaar zur Anwendung.  Auf Randintervallen kommen
     modifizierte Clenshaw-Curtis-Formeln zur Anwendung.

     `quad_qaws' berechnet das Integral

     integrate (f(x)*w(x), x, a, b)

     Die Gewichtsfunktion wird mit dem Schlsselwort <wfun> ausgewhlt:

    `1'
          w(x) = (x - a)^alpha (b - x)^beta

    `2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)

    `4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     Der Integrand kann eine Maxima-Funktion, eine Lisp-Funktion, ein
     Operator, ein Maxima-Lambda-Ausdruck oder ein allgemeiner
     Maxima-Ausdruck sein.

     Die Schlsselwortargumente sind optional und knnen in belieger
     Reihenfolge angegeben werden.  Sie haben die Form `key=val'.  Die
     Schlsselwortargumente sind:

    <epsrel>
          Gewnschter relativer Fehler der Nherung.  Der Standardwert
          is `1.0e-8'

    <epsabs>
          Gewnschter absoluter Fehler der Nherung.  Der Standardwert
          ist `0'.

    <limit>
          Maximale Anzahl der Teilintervalle des adaptiven Algorithmus.
          Der Standardwert ist `200'.

     `quad_qaws' gibt eine Liste mit vier Elementen zurck:

        * eine numerische Nherung des Integrals,

        * geschtzer absoluter Fehler der Nherung,

        * Anzahl der Auswertungen des Integranden,

        * ein Fehlercode.

     Der Fehlercode kann die folgenden Werte annehmen:

    `0'
          wenn kein Fehler aufgetreten ist,

    `1'
          wenn zuviele Teilintervalle notwendig wurden,

    `2'
          wenn bemiger Rundungfehle aufgetreten sind,

    `3'
          wenn ein extrem schlechtes Verhalten des Integranden vorliegt,

    `6'
          wenn die Eingabe ungltig ist.

     Beispiele:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Differentialgleichungen,  Next: Einfhrung in Differentialgleichungen,  Prev: Integration,  Up: Analysis

16.4 Differentialgleichungen
============================

* Menu:

* Einfhrung in Differentialgleichungen::
* Funktionen und Variablen fr Differentialgleichungen::


File: maxima.info,  Node: Einfhrung in Differentialgleichungen,  Next: Funktionen und Variablen fr Differentialgleichungen,  Prev: Differentialgleichungen,  Up: Differentialgleichungen

16.4.1 Einfhrung in Differentialgleichungen
--------------------------------------------

This section describes the functions available in Maxima to obtain
analytic solutions for some specific types of first and second-order
equations. To obtain a numerical solution for a system of differential
equations, see the additional package `dynamics'. For graphical
representations in phase space, see the additional package `plotdf'.


File: maxima.info,  Node: Funktionen und Variablen fr Differentialgleichungen,  Prev: Einfhrung in Differentialgleichungen,  Up: Differentialgleichungen

16.4.2 Funktionen und Variablen fr Differentialgleichungen
-----------------------------------------------------------

 -- Funktion: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)
     Solves a boundary value problem for a second order differential
     equation.  Here: <solution> is a general solution to the equation,
     as found by `ode2'; <xval1> specifies the value of the independent
     variable in a first point, in the form `<x> = <x1>', and <yval1>
     gives the value of the dependent variable in that point, in the
     form `<y> = <y1>'. The expressions <xval2> and <yval2> give the
     values for these variables at a second point, using the same form.

     See `ode2' for an example of its usage.


 -- Funktion: desolve (<eqn>, <x>)
 -- Funktion: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     The function `desolve' solves systems of linear ordinary
     differential equations using Laplace transform.  Here the <eqn>'s
     are differential equations in the dependent variables <x_1>, ...,
     <x_n>.  The functional dependence of <x_1>, ..., <x_n> on an
     independent variable, for instance <x>, must be explicitly
     indicated in the variables and its derivatives. For example, this
     would not be the correct way to define two equations:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     The correct way would be:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     The call to the function `desolve' would then be
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     If initial conditions at `x=0' are known, they can be supplied
     before calling `desolve' by using `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     If `desolve' cannot obtain a solution, it returns `false'.


 -- Funktion: ic1 (<solution>, <xval>, <yval>)
     Solves initial value problems for first order differential
     equations.  Here <solution> is a general solution to the equation,
     as found by `ode2', <xval> gives an initial value for the
     independent variable in the form `<x> = <x0>', and <yval> gives the
     initial value for the dependent variable in the form `<y> = <y0>'.

     See `ode2' for an example of its usage.


 -- Funktion: ic2 (<solution>, <xval>, <yval>, <dval>)
     Solves initial value problems for second-order differential
     equations.  Here <solution> is a general solution to the equation,
     as found by `ode2', <xval> gives the initial value for the
     independent variable in the form `<x> = <x0>', <yval> gives the
     initial value of the dependent variable in the form `<y> = <y0>',
     and <dval> gives the initial value for the first derivative of the
     dependent variable with respect to independent variable, in the
     form `diff(<y>,<x>) = <dy0>' (`diff' does not have to be quoted).

     See `ode2' for an example of its usage.


 -- Funktion: ode2 (<eqn>, <dvar>, <ivar>)
     The function `ode2' solves an ordinary differential equation (ODE)
     of first or second order. It takes three arguments: an ODE given by
     <eqn>, the dependent variable <dvar>, and the independent variable
     <ivar>. When successful, it returns either an explicit or implicit
     solution for the dependent variable. `%c' is used to represent the
     integration constant in the case of first-order equations, and
     `%k1' and `%k2' the constants for second-order equations. The
     dependence of the dependent variable on the independent variable
     does not have to be written explicitly, as in the case of
     `desolve', but the independent variable must always be given as the
     third argument.

     If `ode2' cannot obtain a solution for whatever reason, it returns
     `false', after perhaps printing out an error message. The methods
     implemented for first order equations in the order in which they
     are tested are: linear, separable, exact - perhaps requiring an
     integrating factor, homogeneous, Bernoulli's equation, and a
     generalized homogeneous method. The types of second-order
     equations which can be solved are: constant coefficients, exact,
     linear homogeneous with non-constant coefficients which can be
     transformed to constant coefficients, the Euler or
     equi-dimensional equation, equations solvable by the method of
     variation of parameters, and equations which are free of either the
     independent or of the dependent variable so that they can be
     reduced to two first order linear equations to be solved
     sequentially.

     In the course of solving ODE's, several variables are set purely
     for informational purposes: `method' denotes the method of solution
     used (e.g., `linear'), `intfactor' denotes any integrating factor
     used, `odeindex' denotes the index for Bernoulli's method or for
     the generalized homogeneous method, and `yp' denotes the
     particular solution for the variation of parameters technique.

     In order to solve initial value problems (IVP) functions `ic1' and
     `ic2' are available for first and second order equations, and to
     solve second-order boundary value problems (BVP) the function `bc2'
     can be used.

     Example:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Polynome,  Next: Gleichungen,  Prev: Analysis,  Up: Top

17 Polynome
***********

* Menu:

* Introduction to Polynomials::
* Functions and Variables for Polynomials::


File: maxima.info,  Node: Introduction to Polynomials,  Next: Functions and Variables for Polynomials,  Prev: Polynome,  Up: Polynome

17.1 Introduction to Polynomials
================================

Polynome werden in einer allgemeinen Darstellung oder in einer
kanonischen Darstellung (CRE - Cannonical Rational Expressions)
gespeichert.  Die CRE-Darstellung ist die Standardform fr Operationen
mit Polynomen und wird intern von Funktionen wie `factor'  oder
`ratsimp'  verwendet.

   Ausdrcke in einer CRE-Form sind besonders fr die Darstellung von
Polynomen und rationalen Funktionen geeignet.  Die CRE-Form nimmt eine
Ordnung der Variablen an.  Polynome werden rekursiv als eine Liste
definiert, die als ersten Eintrag den Namen der Variablen und als
nchste Eintrge die Exponenten und Koeffizienten der Variablen
enthalten.  Der Koeffizient kann eine Zahl oder wiederum ein Polynom
sein.  Zum Beispiel hat das Polynom `3*x^2-1' die Darstellung `(X 2 3 0
-1)' und das Polynom `2*x*y+x-3' die Darstellung `(Y 1 (X 1 2) 0 (X 1 1
0 -3))', wenn `y' die Hauptvariable des Polynoms ist.  Ist <x> die
Hauptvariable des Polynoms, dann ist die Darstellung `(X 1 (Y 1 2 0 1)
0 -3)'.

   Die Ordnung der Variablen ist in der Regel umgekehrt alphabetisch.
Die Variablen mssen keine Atome sein.  Alle Ausdrcke, die nicht die
Operatoren `+', `-', `*', `/' oder `^' enthalten, werden in einer
CRE-Darstellung als "Variable" angenommen.  Zum Beispiel sind `x',
`sqrt(x)' und `sin(x+1)' die CRE-Variablen des Ausdrucks
`x+sin(x+1)+2*SQRT(x)+1'.  Wird vom Nutzer keine abweichende Ordnung der
Variablen mit der Funktion `ratvars'  definiert, nimmt Maxima eine
alphabetische Ordnung der Variablen an.

   Im Allgemeinen werden rationale Funktionen in einer CRE-Form
dargestellt, die keinen gemeinsamen Faktor im Zhler und Nenner haben.
Die interne Darstellung ist ein Paar von Polynomen, die jeweils den
Zhler und den Nenner darstellen.  Diesem Paar geht eine Liste mit der
Ordnung der Variablen im Ausdruck voraus.  Ein Ausdruck in einer
CRE-Form oder der CRE-Formen enthlt, wird in der Ausgabe mit dem
Symbol `/R/' gekennzeichnet.  Mit der Funktion `rat'  knnen allgemeine
Ausdrcke in eine CRE-Form transformiert werden.

   Fr die Darstellung von Taylor-Polynomen der Funktion `taylor'  wird
eine erweiterte CRE-Form verwendet.  In dieser Darstellung knnen die
Exponenten von Polynomen auch rationale Zahlen sein.  Weiterhin knnen
die Koeffizienten rationale Funktionen sein.  Die erweiterte CRE-Form
enthlt auch Informationen ber den Grad des Polynoms.  In der Ausgabe
wird die erweiterte CRE-Form mit dem Symbol `/T/' bezeichnet.


File: maxima.info,  Node: Functions and Variables for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynome

17.2 Functions and Variables for Polynomials
============================================

 -- Optionsvariable: algebraic
     Standardwert: `false'

     `algebraic' muss den Wert `true' haben, damit algebraische ganze
     Zahlen vereinfacht werden.

 -- Optionsvariable: berlefact
     Standardwert: `true'

     Hat `berlefact' den Wert `false', dann wird der
     Kronecker-Algorithmus fr die Faktorisierung genutzt.  Ansonsten
     wird der Berlekamp-Algorithmus genutzt.  Das ist der Standard.

 -- Funktion: bezout (<p1>, <p2>, <x>)
     Die Rckgabe ist die Sylvestermatrix der zwei Polynome <p1> und
     <p2> mit der unabhngigen Variablen <x>.  Die Determinante der
     Sylvestermatrix ist die Resultante der Polynome.  Die Resultante
     kann auch sofort mit der Funktion `resultant'  berechnet werden.

     Beispiele:

          (%i1) bezout(a*x+b, c*x^2+d, x);
                                   [ b c  - a d ]
          (%o1)                    [            ]
                                   [  a     b   ]
          (%i2) determinant(%);
                                      2      2
          (%o2)                      a  d + b  c
          (%i3) resultant(a*x+b, c*x^2+d, x);
                                      2      2
          (%o3)                      a  d + b  c

 -- Funktion: bothcoef (<expr>, <x>)
     Gibt eine Liste zurck, deren erstes Element der Koeffizient der
     Variablen <x> im Ausdruck <expr> und deren zweites Element der
     verbleibende Teil des Ausdrucks <expr> ist.  Das Ergebnis ist also
     `[A,B]' und es gilt `<expr> = A * <x> + B'.

     Siehe auch die Funktion `coeff'.

     Beispiele:

          (%i1) bothcoeff(a*x+2,x);
          (%o1)                        [a, 2]
          (%i2) bothcoeff(x^2+a*x+2,x);
                                          2
          (%o2)                      [a, x  + 2]

     Definition einer Funktion `islinear', die die Funktion `bothcoeff'
     nutzt, um den linearen Anteil eines Ausdrucks zu ermitteln.

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- Funktion: coeff (<expr>, <x>, <n>)
 -- Funktion: coeff (<expr>, <x>)
     Gibt den Koeffizienten von `<x>^<n>' im Ausdruck <expr> zurck,
     wobei <expr> ein Polynom ist.

     Das Kommando `coeff(<expr>, <x>^<n>)' ist quivalent zu
     `coeff(<expr>, <x>, <n>)'.  Das Kommando `coeff(<expr>, <x>, 0)'
     gibt den Rest des Ausdrucks <expr> zurck, der frei von der
     Variablen <x> ist.  Wenn nicht angegeben, wird <n> als 1
     angenommen.

     <x> kann auch eine indizierte Variable oder ein Teilausdruck von
     <expr> sein.

     `coeff' wendet weder die Funktion `expand' noch die Funktion
     `factor' an, um einen Ausdruck zu expandieren oder zu
     faktorisieren.  Daher kann es zu anderen Ergebnissen kommen, wenn
     zuvor diese Funktionen angewendet werden.

     Wird `coeff' auf Listen, Matrizen oder Gleichungen angewendet,
     wird die Funktion auf die Elemente bzw. beide Seiten der Gleichung
     angewendet.

     Siehe auch die Funktion `bothcoef'.

     Beispiele:

     `coeff' gibt den Koeffizient `<x>^<n>' des Ausdruckes <expr>
     zurck.

          (%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                          3
          (%o1)                          b

     `coeff(<expr>, <x>^<n>)' ist quivalent zu `coeff(<expr>, <x>,
     <n>)'.

          (%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
          (%o1)                         - c
                                           3
          (%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
          (%o2)                         - c
                                           3

     `coeff(<expr>, <x>, 0)' gibt den Rest des Ausdrucksw <expr>
     zurck, der frei von der Variablen <x> ist.

          (%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                                      3  3
          (%o1)                      c  u  + a u

     <x> kann eine einfache Variable, eine indizierte Variable oder ein
     Teilausdruck des Ausdrucks <expr> sein.

          (%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
          (%o1)                        - 2 %pi
          (%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
          (%o2)                        - 2 %pi
          (%i3) coeff (sin(1+x)*sin(x) + sin(1+x)^3*sin(x)^3, sin(1+x)^3);
                                          3
          (%o3)                        sin (x)
          (%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
          (%o4)                         c - d

     `coeff' wendet die Funktionen `expand' und `factor' nicht an.

          (%i1) coeff (c*(a + b)^3, a);
          (%o1)                           0
          (%i2) expand (c*(a + b)^3);
                           3          2        2        3
          (%o2)           b  c + 3 a b  c + 3 a  b c + a  c
          (%i3) coeff (%, a);
                                          2
          (%o3)                        3 b  c
          (%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
          (%o4)                           0
          (%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                            3
          (%o5)                      (b + a)  c
          (%i6) coeff (%, (a + b)^3);
          (%o6)                           c

     `coeff' wird bei Listen und Matrizen auf die Elemente und bei
     Gleichungen auf die beiden Seiten angewendet.

          (%i1) coeff ([4*a, -3*a, 2*a], a);
          (%o1)                      [4, - 3, 2]
          (%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                                    [  a    b  ]
          (%o2)                     [          ]
                                    [ - c  - d ]
          (%i3) coeff (a*u - b*v = 7*u + 3*v, u);
          (%o3)                         a = 7

     Maxima kennt keine Funktion, um eine Liste der Koeffizienten eines
     Polynoms zurckzugeben.  Die folgende Definition der Funktion
     `coeff_list' liefert das gewnschte Ergebnis.  Neben der Funktion
     `coeff' kommt die Funktion `hipow'  zum Einsatz, um den hchsten
     Koeffizienten zu ermitteln.  Die Funktionen `cons'  und `reverse'
     werden verwendet, um die Koeffizienten einer Liste hinzufgen und
     um die Liste zu invertieren.

          coeff_list(a,x) :=
             block([liste],
                liste:[],
                for i:0 thru hipow(a,x) do
                (
                  liste : cons(coeff(a,x,i),liste)
                ),
                reverse(liste)
             )$

          (%i1) coeff_list(2*x^4+3*x^2+1,x);
          (%o1)                    [1, 0, 3, 0, 2]

 -- Funktion: content (<p_1>, <x_1>, ..., <x_n>)
     Gibt eine Liste zurck, deren erstes Element der grte gemeinsame
     Teiler der Koeffizienten des Polynoms <p_1> in der Variablen <x_n>
     ist und dessen zweites Element das durch den grten gemeinsamen
     Teiler dividierte Polynom ist.  Die anderen Variablen <x_1>, ...,
     <x_n-1> haben dieselbe Bedeutung wie fr die Funktion `ratvars'.

     Beispiel:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- Funktion: denom (<expr>)
     Gibt den Nenner des rationalen Ausdrucks <expr> zurck.

     Beispiel:

          (%i1) denom(x^2/(x+1));
          (%o1)                         x + 1

 -- Funktion: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Berechnet den Quotienten und den Rest der Division des Polynom
     <p_1> durch das Polynom <p_2> fr die Variable <x_n>.  Die anderen
     Variablen <x_1>, ..., <x_n-1> haben dieselbe Bedeutung wie fr die
     Funktion `ratvars'.    Das Ergebnis ist eine Liste, wobei das
     erste Element der Quotient und das zweite Element der Rest ist.

     Siehe auch die Funktionen `quotient'  und `remainder',  die jeweils
     den Quotienten und den Rest der Polynomdivision zurckgegeben.

     Beispiele:

     Im zweiten Beispiel ist `y' die Hauptvariable des Ausdrucks.

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Ein Beispiel fr zwei Polynome in zwei Variablen.

          (%i1) poly1 : sum(x^k*y^(6-k), k, 1, 5);
                            5    2  4    3  3    4  2    5
          (%o1)          x y  + x  y  + x  y  + x  y  + x  y
          (%i2) poly2 : sum(2*k*x^k*y^(3-k), k, 1, 3);
                                    2      2        3
          (%o2)                2 x y  + 4 x  y + 6 x
          (%i3) divide(poly1, poly2, x);
                        3        2      2          5       2  4
                     4 y  + 3 x y  + 9 x  y  23 x y  + 16 x  y
          (%o3)     [----------------------, ------------------]
                               54                    27
          (%i4) expand(first(%)*poly2 + second(%));
                            5    2  4    3  3    4  2    5
          (%o4)          x y  + x  y  + x  y  + x  y  + x  y

 -- Optionsvariable: dontfactor
     Standardwert: `[]'

     Der Optionsvariablen `dontfactor' kann eine Liste mit den Variablen
     zugewiesen werden, bezglich der ein Ausdruck nicht faktorisiert
     werden soll.  Weiterhin wird nicht bezglich von Variablen
     faktorisiert, die gem der kanonischen Ordnung der Variablen von
     geringerer Bedeutung sind, als die Variablen in der Liste
     `dontfactor'.

 -- Funktion: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Wendet ein Subresultanten-Verfahren an, um die Variablen <x_1>,
     ..., <x_k> aus den Gleichungen <eqn_1>, ..., <eqn_n> zu
     eliminieren.  Die Rckgabe ist ein Gleichungssystem mit `<n> - <k>'
     Gleichungen, wobei die <k>-Variablen <x_1>, ..., <x_k> eliminiert
     sind.

     Beispiel:

          (%i1) eqn1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) eqn2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) eqn3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate([eqn1, eqn2, eqn3], [y,z]);
                        2      4      3       2
          (%o4)       [x  (45 x  + 3 x  + 11 x  + 81 x + 124)]

 -- Funktion: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Gibt eine Liste zurck, deren erstes Element der grte gemeinsame
     Teiler der Polynome <p_1>, ..., <p_n> ist und deren weitere
     Elemente die durch den grten gemeinsamen Teiler dividierten
     Polynome sind.  Der grte gemeinsame Teiler wird immer mit dem
     `ezgcd'-Algorithmus bestimmt.

     Siehe auch die Funktionen `gcd',  `gcdex'  und `gcdivide'.

     Beispiel:

          (%i1) poly1 : 6*x^3-17*x^2+14*x-3;
                                  3       2
          (%o1)                6 x  - 17 x  + 14 x - 3
          (%i2) poly2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                              4       3       2
          (%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
          (%i3) poly3 : -8*x^3+14*x^2-x-3;
                                    3       2
          (%o3)                - 8 x  + 14 x  - x - 3
          (%i4) ezgcd(poly1, poly2, poly3);
                             2               3      2           2
          (%o4) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]

 -- Optionsvariable: facexpand
     Standardwert: `true'

     `facexpand' kontrolliert, ob die irreduziblen Faktoren der
     Faktorisierung mit `factor'  in einer expandierten oder in einer
     rekursiven (CRE-Form) vorliegen.  Der Standard ist, das die
     Faktoren expandiert werden.

 -- Funktion: factor (<expr>)
 -- Funktion: factor (<expr>, <p>)
     Factors the expression <expr>, containing any number of variables
     or functions, into factors irreducible over the integers.  `factor
     (<expr>, <p>)' factors <expr> over the field of rationals with an
     element adjoined whose minimum polynomial is <p>.

     `factor' uses `ifactors' function for factoring integers.

     `factorflag' if `false' suppresses the factoring of integer factors
     of rational expressions.

     `dontfactor' may be set to a list of variables with respect to
     which factoring is not to occur.  (It is initially empty).
     Factoring also will not take place with respect to any variables
     which are less important (using the variable ordering assumed for
     CRE form) than those on the `dontfactor' list.

     `savefactors' if `true' causes the factors of an expression which
     is a product of factors to be saved by certain functions in order
     to speed up later factorizations of expressions containing some of
     the same factors.

     `berlefact' if `false' then the Kronecker factoring algorithm will
     be used otherwise the Berlekamp algorithm, which is the default,
     will be used.

     `intfaclim' if `true' maxima will give up factorization of
     integers if no factor is found after trial divisions and Pollard's
     rho method.  If set to `false' (this is the case when the user
     calls `factor' explicitly), complete factorization of the integer
     will be attempted.  The user's setting of `intfaclim' is used for
     internal calls to `factor'.  Thus, `intfaclim' may be reset to
     prevent Maxima from taking an inordinately long time factoring
     large integers.

     Examples:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

 -- Optionsvariable: factorflag
     Standardwert: `false'

     Hat `factorflag' den Wert `false', wird die Faktorisierung von
     ganzen Zahlen unterdrckt, die im Nenner auftreten.

     Beispiel:

          (%i1) factorflag:false;
          (%o1)                         false
          (%i2) factor(1/6*(x^2+2*x+1));
                                             2
                                      (x + 1)
          (%o2)                       --------
                                         6
          (%i3) factorflag:true;
          (%o3)                         true
          (%i4) factor(1/6*(x^2+2*x+1));
                                             2
                                      (x + 1)
          (%o4)                       --------
                                        2 3

 -- Funktion: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranges the sum <expr> into a sum of terms of the form  `f
     (<x_1>, <x_2>, ...)*g' where `g' is a product of  expressions not
     containing any <x_i> and `f' is factored.

 -- Function: factorsum (<expr>)
     Tries to group terms in factors of <expr> which are sums into
     groups of  terms such that their sum is factorable.  `factorsum'
     can recover the  result of `expand ((x + y)^2 + (z + w)^2)' but it
     can't recover  `expand ((x + 1)^2 + (x + y)^2)' because the terms
     have variables in  common.

     Example:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- Function: fasttimes (<p_1>, <p_2>)
     Returns the product of the polynomials <p_1> and <p_2> by using a
     special algorithm for multiplication of polynomials.  `p_1' and
     `p_2' should be multivariate, dense, and nearly the same size.
     Classical multiplication is of order `n_1 n_2' where `n_1' is the
     degree of `p_1' and `n_2' is the degree of `p_2'.   `fasttimes' is
     of order `max (n_1, n_2)^1.585'.

 -- Function: fullratsimp (<expr>)
     `fullratsimp' repeatedly applies `ratsimp' followed by non-rational
     simplification to an expression until no further change occurs,
     and returns  the result.

     When non-rational expressions are involved, one call to `ratsimp'
     followed as is usual by non-rational ("general") simplification
     may not be  sufficient to return a simplified result.  Sometimes,
     more than one such call  may be necessary.  `fullratsimp' makes
     this process convenient.

     `fullratsimp (<expr>, <x_1>, ..., <x_n>)' takes one or more
     arguments similar to `ratsimp' and `rat'.

     Example:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- Function: fullratsubst (<a>, <b>, <c>)
     is the same as `ratsubst' except that it calls itself recursively
     on its  result until that result stops changing.  This function is
     useful when the  replacement expression and the replaced
     expression have one or more variables  in common.

     `fullratsubst' will also accept its arguments in the format of
     `lratsubst'.  That is, the first argument may be a single
     substitution  equation or a list of such equations, while the
     second argument is the  expression being processed.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

     `subst' can carry out multiple substitutions.  `lratsubst' is
     analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

     If only one substitution is desired, then a single equation may be
     given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

     `fullratsubst' is equivalent to `ratsubst' except that it recurses
     until its result stops changing.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

     `fullratsubst' also accepts a list of equations or a single
     equation as first argument.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

     `fullratsubst' may cause an indefinite recursion.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- Funktion: gcd (<p_1>, <p_2>, <x_1>, ...)
 -- Optionsvariable: gcd
     Gibt den grten gemeinsamen Teiler der Polynome <p_1> und <p_2>
     zurck.  Die Argumente <x_1>, ... sind optional und haben dieselbe
     Bedeutung wie fr die Funktion `ratvars'.    Die Optionsvariable
     `gcd' kontrolliert, welcher Algorithmus verwendet wird und kann die
     folgenden Werte annehmen:

    `ez'
          ezgcd-Alogrithmus

    `subres'
          Subresultanten-Algorithmus

    `red'
          Reduzierter modularer Algorithmus

    `spmod'
          Modularer Algorithmus

    `false'
          kein Algorithmus, die Rckgabe ist immer 1

     Siehe auch die Funktionen `ezgcd',  `gcdex'  und `gcdivide'.


 -- Funktion: gcdex (<p_1>, <p_2>)
 -- Funktion: gcdex (<p_1>, <p_2>, <x>)
     Wendet den erweiterten Euklidischen Algorithmus fr die beiden
     Polynome <p_1> und <p_2> an und gibt eine Liste `[s, t, u]' mit den
     Parametern <u>, <s> und <t> als Ergebnis zurck.  Der Parameter
     <u> ist der grte gemeinsame Teiler der Polynome.  Die Parameter
     <s> und <t> sind die Bezoutkoeffizienten, so dass gilt `u = s *
     p_1 + t * p_2'.

     Die Rckgabe der Funktion `gcdex' ist in der CRE-Form.

     Siehe auch die Funktionen `ezgcd',  `gcd'  und `gcdivide'.

     Beispiel:

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Im folgenden Beispiel ist die unabhngige Variable explizit als <x>
     angegeben.  Ohne diese Angabe ist <y> die unabhngige Variable.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1

 -- Function: gcfactor (<n>)
     Factors the Gaussian integer <n> over the Gaussian integers, i.e.,
     numbers of the form `<a> + <b> `%i'' where <a> and  <b> are
     rational integers (i.e.,  ordinary integers).  Factors are
     normalized by making <a> and <b> non-negative.


 -- Function: gfactor (<expr>)
     Factors the polynomial <expr> over the Gaussian integers (that is,
     the integers with the imaginary unit `%i' adjoined).  This is like
     `factor (<expr>, <a>^2+1)' where <a> is `%i'.

     Example:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)

 -- Function: gfactorsum (<expr>)
     is similar to `factorsum' but applies `gfactor' instead of
     `factor'.

 -- Function: hipow (<expr>, <x>)
     Gibt den grten Exponenten des Arguments <x> zurck, der im
     Ausdruck <expr> auftritt.  Treten symbolische Exponenten auf, wird
     ein Ausdruck mit `max' zurckgegeben.  Ist das Argument <x> nicht
     im Ausdruck vorhanden, ist die Rckgabe 0.

     Die Funktion `hipow' betrachtet keine quivalenten Ausdrcke.
     Daher knnen die Ausdrcke `expand(<expr>)' und <expr> ein
     verschiedenes Ergebnis haben.

     Siehe auch die Funktionen `lopow'  und `coeff'.

     Beispiele:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0
          (%i1) hipow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       max(2, a)

 -- Option variable: intfaclim
     Default value: true

     If `true', maxima will give up factorization of integers if no
     factor is found after trial divisions and Pollard's rho method and
     factorization will not be complete.

     When `intfaclim' is `false' (this is the case when the user calls
     `factor' explicitly), complete factorization will be attempted.
     `intfaclim' is set to `false' when factors are computed in
     `divisors', `divsum' and `totient'.

     Internal calls to `factor' respect the user-specified value of
     `intfaclim'.  Setting `intfaclim' to `true' may reduce the time
     spent factoring large integers.

 -- Option variable: keepfloat
     Default value: `false'

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.

     Note that the function `solve' and those functions calling it
     (`eigenvalues', for example) currently ignore this flag, converting
     floating point numbers anyway.

     Examples:

          (%i1) rat(x/2.0);

          `rat' replaced 0.5 by 1/2 = 0.5
                                                 x
          (%o1)/R/                               -
                                                 2
          (%i2) rat(x/2.0), keepfloat;

          (%o2)/R/                             0.5 x

     `solve' ignores `keepfloat':

          (%i3) solve(1.0-x,x), keepfloat;

          `rat' replaced 1.0 by 1/1 = 1.0
          (%o3)                               [x = 1]

 -- Funktion: lopow (<expr>, <x>)
     Gibt den kleinsten Exponenten von <x> zurck, der im Ausdruck
     <expr> auftritt.  Treten symbolische Exponententen auf, wird ein
     Ausdruck mit `min' zurckgegeben.  Ist das Argument <x> nicht im
     Ausdruck enthalten, ist die Rckgabe 0.

     Die Funktion `lopow' betrachtet keine quivalenten Ausdrcke.
     Daher knnen die Ausdrcke `expand(<expr>)' und <expr> ein
     verschiedenes Ergebnis haben.

     Siehe auch die Funktionen `hipow'  und `coeff'.

     Beispiele:

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- Function: lratsubst (<L>, <expr>)
     is analogous to `subst (<L>, <expr>)' except that it uses
     `ratsubst' instead of `subst'.

     The first argument of `lratsubst' is an equation or a list of
     equations identical in format to that accepted by `subst'.  The
     substitutions are made in the order given by the list of equations,
     that is, from left to right.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

     `subst' can carry out multiple substitutions.  `lratsubst' is
     analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

     If only one substitution is desired, then a single equation may be
     given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- Option variable: modulus
     Default value: `false'

     When `modulus' is a positive number <p>, operations on rational
     numbers (as returned by `rat' and related functions) are carried
     out modulo <p>, using the so-called "balanced" modulus system in
     which `<n> modulo <p>' is defined as an integer <k> in
     `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' when <p> is odd, or
     `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' when <p> is even, such that
     `<a> <p> + <k>' equals <n> for some integer <a>.

     If <expr> is already in canonical rational expression (CRE) form
     when `modulus' is reset, then you may need to re-rat <expr>, e.g.,
     `expr: rat (ratdisrep (expr))', in order to get correct results.

     Typically `modulus' is set to a prime number.  If `modulus' is set
     to a positive non-prime integer, this setting is accepted, but a
     warning message is displayed.  Maxima will allow zero or a
     negative integer to be assigned to `modulus', although it is not
     clear if that has any useful consequences.

 -- Function: num (<expr>)
     Returns the numerator of <expr> if it is a ratio.  If <expr> is
     not a ratio, <expr> is returned.

     `num' evaluates its argument.


 -- Function: partfrac (<expr>, <var>)
     Expands the expression <expr> in partial fractions with respect to
     the main variable <var>.  `partfrac' does a complete partial
     fraction decomposition.  The algorithm employed is based on the
     fact that the denominators of the partial fraction expansion (the
     factors of the original denominator) are relatively prime.  The
     numerators can be written as linear combinations of denominators,
     and the expansion falls out.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- Function: polydecomp (<p>, <x>)
     Decomposes the polynomial <p> in the variable <x> into the
     functional composition of polynomials in <x>.  `polydecomp'
     returns a list `[<p_1>, ..., <p_n>]' such that

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
            ...))

     is equal to <p>.  The degree of <p_i> is greater than 1 for <i>
     less than <n>.

     Such a decomposition is not unique.

     Examples:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     The following function composes `L = [e_1, ..., e_n]' as functions
     in `x'; it is the inverse of polydecomp:

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-express above example using `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note that though `compose (polydecomp (<p>, <x>), <x>)' always
     returns <p> (unexpanded), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' does not necessarily return `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- Funktion: polymod (<p>)
 -- Function: polymod (<p>, <m>)
     Konvertiert das Polynom <p> in eine modulare Darstellung bezglich
     dem aktuellen Modul.  Das Modul ist der Wert der Variablen
     `modulus'.

     `polymod(<p>, <m>' konvertiert das Polynom bezglich dem Modul
     <m>, anstatt dem aktuellen Modul `modulus'.

     Siehe `modulus'.

 -- Function: powers (<expr>, <x>)
     Gives the powers of <x> occuring in <expr>.

     `load (powers)' loads this function.


 -- Funktion: quotient (<p_1>, <p_2>)
 -- Funktion: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Berechnet den Quotienten der Polynome <p_1> und <p_2> fr die
     Variable <x_n>.  Die anderen Variablen <x_1>, ..., <x_n-1> haben
     dieselbe Bedeutung wie fr die Funktion `ratvars'.

     `quotient' gibt das erste Element des Ergebnisses der Funktion
     `divide'  zurck.

     Siehe auch die Funktion `remainder'.

     Beispiel:

          (%i1) poly1 : x^3-2*x^2-5*x+7;
                                  3      2
          (%o1)                  x  - 2 x  - 5 x + 7
          (%i2) poly2 : x-1;
          (%o2)                         x - 1
          (%i3) quotient(poly1, poly2, x);
                                      2
          (%o3)                      x  - x - 6

 -- Function: rat (<expr>)
 -- Function: rat (<expr>, <x_1>, ..., <x_n>)
     Converts <expr> to canonical rational expression (CRE) form by
     expanding and combining all terms over a common denominator and
     cancelling out the greatest common divisor of the numerator and
     denominator, as well as converting floating point numbers to
     rational numbers within a tolerance of `ratepsilon'.  The
     variables are ordered according to the <x_1>, ..., <x_n>, if
     specified, as in `ratvars'.

     `rat' does not generally simplify functions other than addition
     `+', subtraction `-', multiplication `*', division `/', and
     exponentiation to an integer power, whereas `ratsimp' does handle
     those cases.  Note that atoms (numbers and variables) in CRE form
     are not the same as they are in the general form.  For example,
     `rat(x)- x' yields `rat(0)' which has a different internal
     representation than 0.

     When `ratfac' is `true', `rat' yields a partially factored form
     for CRE.  During rational operations the expression is maintained
     as fully factored as possible without an actual call to the factor
     package.  This should always save space and may save some time in
     some computations.  The numerator and denominator are still made
     relatively prime (e.g.  `rat ((x^2 - 1)^4/(x + 1)^2)' yields `(x -
     1)^4 (x + 1)^2)', but the factors within each part may not be
     relatively prime.

     `ratprint' if `false' suppresses the printout of the message
     informing the user of the conversion of floating point numbers to
     rational numbers.

     `keepfloat' if `true' prevents floating point numbers from being
     converted to rational numbers.

     See also `ratexpand' and  `ratsimp'.

     Examples:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
                (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- Option variable: ratalgdenom
     Default value: `true'

     When `ratalgdenom' is `true', allows rationalization of
     denominators with respect to radicals to take effect.
     `ratalgdenom' has an effect only when canonical rational
     expressions (CRE) are used in algebraic mode.

 -- Function: ratcoef (<expr>, <x>, <n>)
 -- Function: ratcoef (<expr>, <x>)
     Returns the coefficient of the expression `<x>^<n>' in the
     expression <expr>.  If omitted, <n> is assumed to be 1.

     The return value is free (except possibly in a non-rational sense)
     of the variables in <x>.  If no coefficient of this type exists, 0
     is returned.

     `ratcoef' expands and rationally simplifies its first argument and
     thus it may produce answers different from those of `coeff' which
     is purely syntactic.  Thus `ratcoef ((x + 1)/y + x, x)' returns
     `(y + 1)/y' whereas `coeff' returns 1.

     `ratcoef (<expr>, <x>, 0)', viewing <expr> as a sum, returns a sum
     of those terms which do not contain <x>.  Therefore if <x> occurs
     to any negative powers, `ratcoef' should not be used.

     Since <expr> is rationally simplified before it is examined,
     coefficients may not appear quite the way they were envisioned.

     Example:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- Function: ratdenom (<expr>)
     Returns the denominator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `denom' is similar, but returns an ordinary expression instead of
     a CRE.  Also, `denom' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratdenom' are not considered ratios by `denom'.


 -- Option variable: ratdenomdivide
     Default value: `true'

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     Examples:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- Function: ratdiff (<expr>, <x>)
     Differentiates the rational expression <expr> with respect to <x>.
     <expr> must be a ratio of polynomials or a polynomial in <x>.  The
     argument <x> may be a variable or a subexpression of <expr>.

     The result is equivalent to `diff', although perhaps in a
     different form.  `ratdiff' may be faster than `diff', for rational
     expressions.

     `ratdiff' returns a canonical rational expression (CRE) if `expr'
     is a CRE.  Otherwise, `ratdiff' returns a general expression.

     `ratdiff' considers only the dependence of <expr> on <x>, and
     ignores any dependencies established by `depends'.

     Example:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- Function: ratdisrep (<expr>)
     Returns its argument as a general expression.  If <expr> is a
     general expression, it is returned unchanged.

     Typically `ratdisrep' is called to convert a canonical rational
     expression (CRE) into a general expression.  This is sometimes
     convenient if one wishes to stop the "contagion", or use rational
     functions in non-rational contexts.

     See also `totaldisrep'.

 -- Function: ratexpand (<expr>)
 -- Option variable: ratexpand
     Expands <expr> by multiplying out products of sums and
     exponentiated sums, combining fractions over a common denominator,
     cancelling the greatest common divisor of the numerator and
     denominator, then splitting the numerator (if a sum) into its
     respective terms divided by the denominator.

     The return value of `ratexpand' is a general expression, even if
     <expr> is a canonical rational expression (CRE).

     The switch `ratexpand' if `true' will cause CRE expressions to be
     fully expanded when they are converted back to general form or
     displayed, while if it is `false' then they will be put into a
     recursive form.  See also `ratsimp'.

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.

     Examples:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- Option variable: ratfac
     Default value: `false'

     When `ratfac' is `true', canonical rational expressions (CRE) are
     manipulated in a partially factored form.

     During rational operations the expression is maintained as fully
     factored as possible without calling `factor'.  This should always
     save space and may save time in some computations.  The numerator
     and denominator are made relatively prime, for example `rat ((x^2
     - 1)^4/(x + 1)^2)' yields `(x - 1)^4 (x + 1)^2)', but the factors
     within each part may not be relatively prime.

     In the `ctensr' (Component Tensor Manipulation) package, Ricci,
     Einstein, Riemann, and Weyl tensors and the scalar curvature are
     factored automatically when `ratfac' is `true'.  `ratfac' should
     only be set for cases where the tensorial components are known to
     consist of few terms.

     The `ratfac' and `ratweight' schemes are incompatible and may not
     both be used at the same time.


 -- Function: ratnumer (<expr>)
     Returns the numerator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `num' is similar, but returns an ordinary expression instead of a
     CRE.  Also, `num' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratnumer' are not considered ratios by `num'.


 -- Function: ratp (<expr>)
     Returns `true' if <expr> is a canonical rational expression (CRE)
     or extended CRE, otherwise `false'.

     CRE are created by `rat' and related functions.  Extended CRE are
     created by `taylor' and related functions.

 -- Option variable: ratprint
     Default value: `true'

     When `ratprint' is `true', a message informing the user of the
     conversion of floating point numbers to rational numbers is
     displayed.

 -- Function: ratsimp (<expr>)
 -- Function: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifies the expression <expr> and all of its subexpressions,
     including the arguments to non-rational functions.  The result is
     returned as the quotient of two polynomials in a recursive form,
     that is, the coefficients of the main variable are polynomials in
     the other variables.  Variables may include non-rational functions
     (e.g., `sin (x^2 + 1)') and the arguments to any such functions
     are also rationally simplified.

     `ratsimp (<expr>, <x_1>, ..., <x_n>)' enables rational
     simplification with the specification of variable ordering as in
     `ratvars'.

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.

     See also `ratexpand'.  Note that `ratsimp' is affected by some of
     the flags which affect `ratexpand'.

     Examples:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- Option variable: ratsimpexpons
     Default value: `false'

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.


 -- Optionsvariable: radsubstflag
     Standardwert: `false'

     Hat `radsubstflag' den Wert `true', wird verhindert, dass die
     Funktion `ratsubst' zum Beispiel `u' fr `sqrt(x)' in `x'
     substituiert.

 -- Function: ratsubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c> and returns the resulting
     expression.  <b> may be a sum, product, power, etc.

     `ratsubst' knows something of the meaning of expressions whereas
     `subst' does a purely syntactic substitution.  Thus `subst (a, x +
     y, x + y + z)' returns `x + y + z' whereas `ratsubst' returns `z +
     a'.

     When `radsubstflag' is `true', `ratsubst' makes substitutions for
     radicals in expressions which don't explicitly contain them.

     Examples:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- Function: ratvars (<x_1>, ..., <x_n>)
 -- Function: ratvars ()
 -- System variable: ratvars
     Declares main variables <x_1>, ..., <x_n> for rational expressions.
     <x_n>, if present in a rational expression, is considered the main
     variable.  Otherwise, <x_[n-1]> is considered the main variable if
     present, and so on through the preceding variables to <x_1>, which
     is considered the main variable only if none of the succeeding
     variables are present.

     If a variable in a rational expression is not present in the
     `ratvars' list, it is given a lower priority than <x_1>.

     The arguments to `ratvars' can be either variables or non-rational
     functions such as `sin(x)'.

     The variable `ratvars' is a list of the arguments of the function
     `ratvars' when it was called most recently.  Each call to the
     function `ratvars' resets the list.  `ratvars ()' clears the list.

 -- Function: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Function: ratweight ()
     Assigns a weight <w_i> to the variable <x_i>.  This causes a term
     to be replaced by 0 if its weight exceeds the value of the
     variable `ratwtlvl' (default yields no truncation).  The weight of
     a term is the sum of the products of the weight of a variable in
     the term times its power.  For example, the weight of `3 x_1^2
     x_2' is `2 w_1 + w_2'.  Truncation according to `ratwtlvl' is
     carried out only when multiplying or exponentiating canonical
     rational expressions (CRE).

     `ratweight ()' returns the cumulative list of weight assignments.

     Note: The `ratfac' and `ratweight' schemes are incompatible and
     may not both be used at the same time.

     Examples:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- System variable: ratweights
     Default value: `[]'

     `ratweights' is the list of weights assigned by `ratweight'.  The
     list is cumulative: each call to `ratweight' places additional
     items in the list.

     `kill (ratweights)' and `save (ratweights)' both work as expected.

 -- Option variable: ratwtlvl
     Default value: `false'

     `ratwtlvl' is used in combination with the `ratweight' function to
     control the truncation of canonical rational expressions (CRE).
     For the default value of `false', no truncation occurs.

 -- Funktion: remainder (<p_1>, <p_2>)
 -- Funktion: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Berechnet den Rest der Polynomdivision von <p_1> und <p_2> fr die
     Variable <x_n>.  Die anderen Variablen <x_1>, ..., <x_n-1> haben
     dieselbe Bedeutung wie fr die Funktion `ratvars'.

     `remainder' gibt das zweite Element des Ergebnisses der Funktion
     `divide'  zurck.

     Siehe auch die Funktion `quotient'.

     Beispiel:

          (%i1) poly1 : x^3-2*x^2-5*x+7;
                                  3      2
          (%o1)                  x  - 2 x  - 5 x + 7
          (%i2) poly2 : x^2+1;
                                        2
          (%o2)                        x  + 1
          (%i3) remainder(poly1, poly2, x);
          (%o3)                        9 - 6 x

 -- Funktion: resultant (<p_1>, <p_2>, <x>)
 -- Optionsvariable: resultant
     Berechnet die Resultante der Polynome <p_1> und <p_2> und
     eliminiert die unabhngige Variable <x>.  Die Resultante ist die
     Determinate der Sylvestermatrix fr die beiden Polynome.  Das
     Ergebnis ist Null, wenn die beiden Polynome <p_1> und <p_2> einen
     gemeinsamen Faktor haben.

     Knnen die Polynome <p_1> oder <p_2> faktorisiert werden, kann es
     von Vorteil sein, die Faktorisierung zuvor auszufhren.

     Die Optionsvariable `resultant' kontrolliert, welcher Algorithmus
     fr die Berechnung der Resultante von Maxima genutzt wird.  Die
     mglichen Werte sind:

    `subres'
          Subresultanten-Algorithmus

    `mod'
          Modularer Resultanten-Algorithmus

    `red'
          Reduzierter Subresultanten-Algorithmus

     Die Funktion `bezout'  berechnet die Sylvestermatrix der Polynome
     <p_1> und <p_2>.  Die Determinate der Sylvestermatrix ist die
     Resultante.

     Beispiele:

          (%i1) resultant(2*x^2+3*x+1, 2*x^2+x+1, x);
          (%o1)                           8
          (%i2) resultant(x+1, x+1, x);
          (%o2)                           0
          (%i3) resultant((x+1)*x, (x+1), x);
          (%o3)                           0
          (%i4) resultant(a*x^2+b*x+1, c*x + 2, x);
                                   2
          (%o4)                   c  - 2 b c + 4 a

          (%i5) bezout(a*x^2+b*x+1, c*x+2, x);
                                  [ 2 a  2 b - c ]
          (%o5)                   [              ]
                                  [  c      2    ]
          (%i6) determinant(%);
          (%o6)                   4 a - (2 b - c) c

 -- Option variable: savefactors
     Default value: `false'

     When `savefactors' is `true', causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.

 -- Function: showratvars (<expr>)
     Returns a list of the canonical rational expression (CRE)
     variables in expression `expr'.

     See also `ratvars'.

 -- Function: sqfr (<expr>)
     is similar to `factor' except that the polynomial factors are
     "square-free."  That is, they have factors only of degree one.
     This algorithm, which is also used by the first stage of `factor',
     utilizes the fact that a polynomial has in common with its n'th
     derivative all its factors of degree greater than n.  Thus by
     taking greatest common divisors with the polynomial of the
     derivatives with respect to each variable in the polynomial, all
     factors of degree greater than 1 can be found.

     Example:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)

 -- Funktion: tellrat (<p_1>, ..., <p_n>)
 -- Funktion: tellrat ()
     Adds to the ring of algebraic integers known to Maxima the
     elements which are  the solutions of the polynomials <p_1>, ...,
     <p_n>.  Each argument  <p_i> is a polynomial with integer
     coefficients.

     `tellrat (<x>)' effectively means substitute 0 for <x> in
     rational functions.

     `tellrat ()' returns a list of the current substitutions.

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.

     Maxima initially knows about the imaginary unit `%i' and all roots
     of  integers.

     There is a command `untellrat' which takes kernels and removes
     `tellrat' properties.

     When `tellrat''ing a multivariate polynomial, e.g.,  `tellrat (x^2
     - y^2)', there would be an ambiguity as to whether to  substitute
     `<y>^2' for `<x>^2' or vice versa.  Maxima  picks a particular
     ordering, but if the user wants to specify which, e.g.   `tellrat
     (y^2 = x^2)' provides a syntax which says replace  `<y>^2' by
     `<x>^2'.

     Beispiele:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- Funktion: totaldisrep (<expr>)
     Konvertiert alle Teilausdrcke im Ausdruck <expr> von der CRE-Form
     in die allgemeine Form und gibt das Ergebnis zurck.  Ist <expr>
     selbst eine CRE-Form, dann entspricht `totaldisrep' der Funktion
     `ratdisrep'.

     `totaldisrep' ist insbesondere hilfreich, wenn Gleichungen, Listen
     oder Matrizen in eine allgmeine Form zu konvertieren sind.


 -- Funktion: untellrat (<x_1>, ..., <x_n>)
     Entfernt Eigenschaften von den Symbolen <x_1>, ..., <x_n>, die mit
     der Funktion `tellrat' zugewiesen wurden.



File: maxima.info,  Node: Gleichungen,  Next: Lineare Algebra,  Prev: Polynome,  Up: Top

18 Gleichungen
**************

* Menu:

* Funktionen und Variablen fr Gleichungen::


File: maxima.info,  Node: Funktionen und Variablen fr Gleichungen,  Prev: Gleichungen,  Up: Gleichungen

18.1 Funktionen und Variablen fr Gleichungen
=============================================

 -- Optionsvariable: %rnum
     Standardwert: 0

     Wenn notwendig, erzeugen die Funktionen `solve' und `algsys'
     Parameter, die in die Lsungen eingesetzt werden.  Die Parameter
     haben den Namen `%r<<num>>'.  `%rnum' enthlt die Nummer <num>,
     die an den Prfix `%r' angehngt wird.  Maxima erhht `%rnum'
     automatisch.  Siehe auch die Systemvariable `%rnum_list'  fr eine
     Liste der Parameter einer Lsung.

 -- Systemvariable: %rnum_list
     Standardwert: `[]'

     `%rnum_list' ist die Liste der Parameter, die von `solve' und
     `algsys' in Lsungen eingesetzt werden.  Die Parameter werden der
     Liste `%rnum_list' hinzugefgt, in der Reihenfolge in der sie
     erzeugt werden.

          (%i1) solve ([x + y = 3], [x,y]);
          (%o1)              [[x = 3 - %r1, y = %r1]]
          (%i2) %rnum_list;
          (%o2)                       [%r1]
          (%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
          (%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
          (%i4) %rnum_list;
          (%o4)                     [%r2, %r3]
          (%i5) for i : 1 thru length (%rnum_list) do
                  sol : subst (t[i], %rnum_list[i], sol)$
          (%i6) sol;
          (%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                               2      1           2       1

 -- Optionsvariable: algexact
     Standardwert: `false'

     `algexact' kontrolliert die Funktion `algsys' folgendermaen:

        * Hat `algexact' den Wert `true', wird von der Funktion `algsys'
          stets `solve' aufgerufen.  Findet `solve' keine Lsung, wird
          die Funktion `realroots' aufgerufen.

        * Hat `algexact' den Wert `false', wird die Funktion `solve' fr
          Gleichungen aufgerufen, die von mehr als einer Variablen
          abhngen oder fr quadratische oder kubische Gleichungen.

     Der Wert `true' fr `algexact' garantiert nicht, dass `algsys' nur
     exakte Lsungen findet.  Findet `algsys' keine exakten Lsungen,
     versucht die Funktion Nherungslsungen zu finden.

 -- Optionsvariable: algepsilon
     Standardwert: 10^8

     Kontrolliert die Genauigkeit einer numerischen Lsung der Funktion
     `algsys'.


 -- Funktion: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Funktion: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Lst ein Gleichungsystem mit den Polynomen <expr_1>, ..., <expr_m>
     oder den Gleichungen <eqn_1>, ..., <eqn_m> fr die Variablen
     <x_1>, ..., <x_n>.  Werden Polynome <expr_i> als Argument
     bergeben, werden diese als Gleichungen <x_i = 0> interpretiert.
     Die Anzahl der Gleichungen und Variablen kann verschieden sein.

     `algsys' gibt eine Liste mit den Lsungen zurck.  Jede Lsung ist
     wiederum eine Liste mit den Lsungen fr die einzelnen Variablen
     <x_i>.  Kann `algsys' keine Lsung finden, wird eine leere Liste
     `[]' zurckgegeben.

     Haben die Lsungen freie Parameter setzt `algsys' die Symbole
     `%r1', `%r2', ... in die Lsungen ein.  Die Parameter werden der
     Liste `%rnum_list' hinzugefgt.  Siehe `%rnum_list'.

     Die Funktion `algsys' verwendet die folgenden Schritte, um
     Lsungen eines Gleichungsystems zu finden:

       1. Die Gleichungen werden faktorisiert und in Teilsysteme
          aufgeteilt.

       2. Fr jedes Teilsystem <S_i> werden eine Gleichung <E> und eine
          Variable <x> ausgewhlt, die den niedrigsten von Null
          verschiedenen Grad hat.  Dann wird die Resultante der
          Gleichungen <E> und <E_j> fr die Variable <x> sowie allen
          verbleibenden Gleichungen <E_j> des Teilsystems <S_i>
          berechnet.  Dieses Verfahren eliminiert die Variable <x> und
          hat ein neues Teilsystem <S_i'> als Ergebnis.  Der
          Algorithmus wiederholt nun den 1. Schritt.

       3. Besteht das Teilsystem nur noch aus einer Gleichung, hat
          diese Gleichung mehrere Variablen und enthlt diese keine
          Gleitkommazahlen, dann wird `solve' aufgerufen, um eine
          exakte Lsung zu finden.

          Es kann sein, dass `solve' keine Lsung oder einen sehr groen
          Ausdruck als Lsung findet.

          Auch fr Gleichungen, die nur eine Variable enthalten und die
          entweder linear, quadratisch oder quartisch sind sowie keine
          Gleitkommazahlen enthalten, wird `solve' aufgerufen, um eine
          exakte Lsung zu finden.  Trifft dies nicht zu, wird die
          Funktion `realroots' aufgerufen, wenn der Schalter `realonly'
          den Wert `true' hat.  Ansonsten wird die Funktion `allroots'
          aufgerufen.  Die Funktion `realroots' sucht reelle Lsung der
          Gleichung, whrend die Funktion `allroots' auch komplex
          Lsungen sucht.

          Die Genauigkeit einer numerischen Lsung wird von der
          Optionsvariablen `algepsilon' kontrolliert.

          Hat die Optionsvariable `algexact' den Wert `true', wird
          immer die Funktion `solve' aufgerufen.

       4. Zuletzt werden die erhaltenen Lsungen in das betrachtete
          Teilsystem eingesetzt und der Lsungsalgorithmus mit dem 1.
          Schritt fortgesetzt.

     Tritt beim Lsen des Gleichungssystems eine Gleichung auf, die von
     mehreren Variablen abhngt und Gleitkommazahlen enthlt, dann wird
     der Algorithmus mit der Meldung "`algsys' cannot solve - system
     too complicated."  abgebrochen.  Ein Nherung mit Gleitkommazahlen
     kann in vorgehenden Schritten auftreten, wenn keine exakten
     Lsungen auffindbar sind.

     Ist das Argument der Funktion `allroots' kein Polynom, gibt Maxima
     eine Fehlermeldung.  Die Lsungen eines Gleichungssystems knnen
     sehr groe Ausdrcke sein.  Obwohl die Lsung reell ist, kann die
     imaginre Einheit `%i' in den Lsungen enthalten sein.  Fr die
     weitere Bearbeitung der Lsungen knnen die Funktionen `pickapart'
     oder `reval' ntzlich sein.

     Beispiele:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3

 -- Funktion: allroots (<expr>)
 -- Funktion: allroots (<eqn>)
     Berechnet numerische Nherungen der reellen und komplexen Wurzeln
     des Polynoms <expr> oder der Polynomgleichung <eqn> mit einer
     Variable.

     Hat der Schalter `polyfactor' den Wert `true', wird das Polynom
     ber die reellen oder komplexen Zahlen faktorisiert.

     Fr den Fall mehrfacher Wurzeln kann `allroots' ungenaue Ergebnisse
     liefern.  Ist das Polynom reell, kann `allroots (%i*<p>)') genauere
     Approximationen liefern als `allroots (<p>)', da `allroots' in
     diesem Fall einen anderen Algorithmus verwendet.

     Der Zhler des Arguments der Funktion `allroots' muss nach
     Anwendung der Funktion `rat' ein Polynom sein und darf im Nenner
     hchstens eine komplexe Zahl enthalten.  Ist das Argument der
     Funktion `allroots' kein Polynom, gibt Maxima eine Fehlermeldung.
     Hat die Optionsvariable `polyfactor' den Wert `true', wird ein
     quivalenter, faktorisierter Ausdruck zurckgegeben, der die
     Nherungen fr die Nullstellen enthlt.

     Fr komplexe Polynome wird ein Algorithmus von Jenkins und Traub
     verwendet (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  Fr
     reelle Polynome wird ein Algorithmus von Jenkins verwendet
     (Algorithm 493, ACM TOMS,vol. 1, (1975), p.178).

     Beispiele:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)

 -- Funktion: bfallroots (<expr>)
 -- Funktion: bfallroots (<eqn>)
     Berechnet numerische Nherungen der reellen und komplexen Wurzeln
     des Polynoms <expr> oder der Polynomgleichung <eqn> mit einer
     Variable.

     `bfallroots' entspricht in jeder Hinsicht der Funktion `allroots'
     mit dem Unterschied, dass `bfallroots' die Nherungen mit groen
     Gleitkommazahlen berechnet.  Siehe `allroots'.


 -- Optionsvariable: backsubst
     Standardwert: `true'

     Hat `backsubst' den Wert `false', werden die Lsungen der Funktion
     `linsolve' nicht rcksubstituiert.  Dies kann hilfreich sein, wenn
     die Rcksubstitution zu sehr groen Ausdrcken fhrt.

          (%i1) eq1 : x + y + z = 6$
          (%i2) eq2 : x - y + z = 2$
          (%i3) eq3 : x + y - z = 0$
          (%i4) backsubst : false$
          (%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o5)             [x = z - y, y = 2, z = 3]
          (%i6) backsubst : true$
          (%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o7)               [x = 1, y = 2, z = 3]

 -- Optionsvariable: breakup
     Standardwert: `true'

     Haben die Optionsvariablen `programmode' und `breakup' den Wert
     `true', werden Zwischenmarken fr gemeinsame Terme in Lsungen von
     kubischen und quartischen Gleichungen erzeugt.

     Beispiele:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]

 -- Funktion: dimension (<eqn>)
 -- Funktion: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' ist ein Paket fr die Dimensionsanalysis.  `load(dimen)'
     ldt dieses Paket.  `demo(dimen)' zeigt eine kleine Demonstration.

 -- Optionsvariable: dispflag
     Standardwert: `true'

     Hat `dispflag' den Wert `false', werden Ausgaben der Funktion
     `solve' unterdrckt, die erzeugt werden, wenn die Optionsvariable
     `programmmode' den Wert `false' hat.

 -- Funktion: funcsolve (<eqn>, <g>(<t>))
     Das Argument ist eine Gleichung <eqn>, die ein Polynom erster
     Ordnung in den Funktionen `<g>(<t>)' und `<g>(<t+1>)' ist.
     `funcsolve' sucht die rationale Funktion `<g>(<t>)', die Lsung
     der Gleichung <eqn> ist.

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
                (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Warnung: Die Funktion ist nur sehr rudimentr implementiert.
     Offensichtliche Verallgemeinerungen fehlen.

 -- Optionsvariable: globalsolve
     Standardwert: `false'

     Hat `globalsolve' den Wert `true', werden den unbekannten Variablen
     eines linearen Gleichungssystems die Werte der Lsung der
     Funktionen `linsolve' und `solve' zugewiesen.

     Hat `globalsolve' den Wert `false', werden den unbekannten
     Variablen eines linearen Gleichungssystems keine Werte zugewiesen.
     Die Lsungen werden als Gleichungen mit den unbekannten Variablen
     ausgedrckt.

     Fr andere als lineare Gleichungssysteme wird der Wert von
     `globalsolve' ignoriert.  `algsys' ignoriert `globalsolve' immer.

     Beispiele:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y

 -- Funktion: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' ist ein Paket zur Lsung von Integralgleichungen der Form
     `p(x) = q( x, p(x), 'integrate(w(x,u,p(x),p(u)),u,a(x),b(x)) )'
     (zweiter Art, `secondkind') und
     `'integrate(w(x,u,p(u)),u,a(x),b(x)) = f(x)' (erster Art,
     `firstkind').  `load ("inteqn")' ldt dieses Paket.

     <ie> ist die Integralgleichung; <unk> ist die unbekannte Funktion
     einschlielich angegebener Abhngigkeit; <tech> ist die Technik,
     die zur Lsung angewendet werden soll (<tech> = `first' bedeutet,
     dass die verfgbaren Lsungstechniken der Reihe nach angewandt
     werden und das Ergebnis der ersten erfolgreichen Lsung wird
     zurckgegeben; <tech> = `all' bedeutet, dass alle Techniken
     angewandt werden); <n> ist die maximale Anzahl an Termen, die fr
     `taylor', `neumann', `firstkindseries' oder `fredseries' verwendet
     werden (es ist ebenso die maximale Tiefe der Rekursion fr die
     Differentiationsmethode); <guess> ist der Startwert fr `neumann'
     oder `firstkindseries'.

     Standardwerte fr den 2ten bis 5ten Parameter sind:

     <unk>: `<p>(<x>)', wobei <p> die als erste im Integranden
     aufgefundene Funktion ist, die fr Maxima unbekannt ist, und <x>
     ist die Variable, die im Falle einer `secondkind'-Gleichung als
     Argument des ersten <p> auerhalb des Integrals vorgefunden wird,
     oder im Falle einer `firstkind'-Gleichung die einzige andere
     Variable neben der Integrationsvariable.  Wenn der Versuch, <x> zu
     finden, fehlschlgt, wird der Nutzer gefragt, eine unabhngige
     Variable anzugeben.

     <tech>: `first'

     <n>: 1

     <guess>: `none', was bewirkt, dass `neumann' und `firstkindseries'
     `<f>(<x>)' als Startwert verwenden.

     Siehe share/integequations/inteqn.usg fr weitere Informationen.

 -- Optionsvariable: ieqnprint
     Standardwert: `true'

     `ieqnprint' regelt die Darstellung des Ergebnisses, das durch den
     Befehl `ieqn' zurckgegeben wird.  Wenn `ieqnprint' `true' ist,
     ist die von der `ieqn'-Funktion zurckgegebene Liste von der Form

     [<solution>, <technique used>, <nterms>, <flag>]

     wobei <flag> nicht vorkommt, wenn die Lsung exakt ist.

     Andernfalls ist `approximate' bzw. `incomplete' das Wort, das sich
     auf eine nicht exakte bzw. nicht geschlossene Form der Lsung
     bezieht.  Wird eine Reihenmethode angewandt, gibt <nterms> die
     Anzahl der verwendeten Terme (die kleiner als das in `ieqn'
     angegebene <n> sein kann, wenn ein Fehler die Erzeugung weiterer
     Terme verhindert).

 -- Funktion: lhs (<expr>)
     Gibt die linke Seite, das ist das erste Argument, des Ausdrucks
     <expr> zurck, wenn der Operator von <expr> einer der relationalen
     Operatoren `< <= = # equal notequal >= >', einer der
     Zuweisungsoperatoren `:= ::= : ::' oder ein nutzerdefinierter
     binrer Infixoperator ist, der mit der Funktion deklariert durch
     `infix' deklariert wurde.

     Wenn <expr> ein Atom ist oder sein Operator ein anderer als oben
     aufgelistet, gibt `lhs' den Ausdruck <expr> zurck.  Siehe auch
     `rhs'.

     Beispiele:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
                 lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa

 -- Funktion: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Lst das Gleichungssystem mit den Gleichungen oder Polynomen
     [<expr_1>, ..., <expr_m>] und den Variablen [<x_1>, ..., <x_n>].
     Jede Gleichung muss ein Polynom in den angegebenen Variablen sein.

     Hat `globalsolve' den Wert `true', werden die Lsungen des
     Gleichungssystems den angegebenen Variablen zugewiesen.

     Hat `backsubst' den Wert `false', fhrt `linsolve' keine
     Rcksubstitutionen aus.  Dies kann hilfreich sein, wenn die
     Rcksubstitution zu sehr groen Ausdrcken fhrt.

     Hat `linsolve_params' den Wert `true', setzt `linsolve' fr ein
     unterbestimmtes Gleichungssystem freie Parameter in die Lsungen
     ein, die mit `%r'-Symbolen bezeichnet werden.  Siehe auch `%rnum'
     und `%rnum_list'.

     Hat `programmode' den Wert `false', gibt `linsolve' die Lsungen
     mit Hilfe von Zwischenmarken `%t' aus.  Die Zwischenmarken werden
     als Liste zurckgegeben.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]

 -- Optionsvariable: linsolvewarn
     Standardwert: `true'

     Hat `linsolvewarn' den Wert `true', gibt `linsolve' gegebenenfalls
     die Meldung "Dependent equations eliminated" aus.

 -- Optionsvariable: linsolve_params
     Standardwert: `true'

     Hat `linsolve_params' den Wert `true', setzt `linsolve' fr ein
     unterbestimmtes Gleichungssystem freie Parameter in die Lsungen
     ein, die mit `%r'-Symbolen bezeichnet werden.  Siehe auch `%rnum'
     und `%rnum_list'.


 -- Systemvariable: multiplicities
     Standardwert: `not_set_yet'

     `multiplicities' ist die Liste der Vielfachheiten der Lsungen,
     die von `solve', `realroots' oder `allroots' zurckgegeben werden.

 -- Funktion: nroots (<p>, <low>, <high>)
     Gibt die Anzahl der reellen Wurzeln des reellen univariaten
     Polynoms <p> im halboffenen Intervall `(<low>, <high>]' zurck.
     Die Grenzen des Intervalls knnen auch negativ unendlich `minf'
     oder positiv unendlich `inf' sein.

     `nroots' verwendet die Methode der Sturm-Sequenzen.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4

 -- Funktion: nthroot (<p>, <n>)
     Das Argument <p> ist ein Polynom mit ganzzahligen Koeffizienten
     und das Argument <n> eine positive ganze Zahl.  `nthroot' gibt ein
     Polynom q ber den ganzen Zahlen zurck, so dass q^n = p gilt.
     Existiert kein derartiges Polynom <q> gibt Maxima eine
     Fehlermeldung.  Diese Funktion ist wesentlich schneller als
     `factor' oder `sqfr'.

 -- Optionsvariable: polyfactor
     Standardwert: `false'

     Hat die Optionsvariable `polyfactor' den Wert `true', werden die
     Lsungen der Funktionen `allroots' und `bfallroots' ber die
     reellen Zahlen, fr reelle Polynome, und die komplexen Zahlen, fr
     komplexe Polynome, faktorisiert.

     Siehe `allroots'  fr ein Beispiel.

 -- Optionsvariable: programmode
     Standardwert: `true'

     Hat `programmode' den Wert `true', geben die Funktionen `solve',
     `realroots', `allroots', `bfallroots' und `linsolve' die Lsungen
     als Elemente einer Liste zurck.

     Hat `programmode' den Wert `false', werden die Lsungen der oben
     genannten Funktionen Zwischenmarken `%t' zugewiesen.  Die Rckgabe
     der Funktionen ist in diesem Fall eine Liste der Zwischenmarken.

 -- Optionsvariable: realonly
     Standardwert: `false'

     Hat `realonly' den Wert `true', gibt `algsys' nur Lsungen zurck,
     die nicht die imaginre Einheit `%i' enthalten.

 -- Funktion: realroots (<expr>, <bound>)
 -- Funktion: realroots (<eqn>, <bound>)
 -- Funktion: realroots (<expr>)
 -- Funktion: realroots (<eqn>)
     Computes rational approximations of the real roots of the
     polynomial <expr> or polynomial equation <eqn> of one variable, to
     within a tolerance of <bound>.  Coefficients of <expr> or <eqn>
     must be literal numbers; symbol constants such as `%pi' are
     rejected.

     `realroots' assigns the multiplicities of the roots it finds to
     the global variable `multiplicities'.

     `realroots' constructs a Sturm sequence to bracket each root, and
     then applies bisection to refine the approximations.  All
     coefficients are converted to rational equivalents before
     searching for roots, and computations are carried out by exact
     rational arithmetic.  Even if some coefficients are floating-point
     numbers, the results are rational (unless coerced to floats by the
     `float' or `numer' flags).

     When <bound> is less than 1, all integer roots are found exactly.
     When <bound> is unspecified, it is assumed equal to the global
     variable `rootsepsilon'.

     When the global variable `programmode' is `true', `realroots'
     returns a list of the form `[x = <x_1>, x = <x_2>, ...]'.  When
     `programmode' is `false', `realroots' creates intermediate
     expression labels `%t1', `%t2', ..., assigns the results to them,
     and returns the list of labels.

     Examples:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]

 -- Funktion: rhs (<expr>)
     Gibt die rechte Seite, das ist das zweite Argument, des Ausdrucks
     <expr> zurck, wenn der Operator von <expr> einer der relationalen
     Operatoren `< <= = # equal notequal >= >', einer der
     Zuweisungsoperatoren `:= ::= : ::' oder ein nutzerdefinierter
     binrer Infixoperator ist, der mit der Funktion `infix' deklariert
     wurde.

     Wenn <expr> ein Atom ist oder sein Operator ein anderer als oben
     aufgelistet, hat `rhs' das Ergebnis 0.  Siehe auch `lhs'.

     Beispiele:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
                 rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb

 -- Optionsvariable: rootsepsilon
     Standardwert: 1.0e-7

     `rootsepsilon' ist die Toleranz, die den Vertrauensbereich fr die
     von der Funktion `realroots' gefundenen Wurzeln festsetzt.

 -- Funktion: solve (<expr>, <x>)
 -- Funktion: solve (<expr>)
 -- Funktion: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Lst eine algebraische Gleichung <expr> nach der Variable <x> auf.
     Wenn <expr> keine Gleichung ist, wird die Gleichung `<expr> = 0'
     angenommen.  <x> kann eine Funktion wie zum Beispiel `f(x)') sein
     oder ein allgemeiner Ausdruck.  Ausgenommen sind Summen und
     Produkte.  Hat die Gleichung nur eine Variable, braucht diese
     nicht angegeben zu werden.  <expr> kann ein rationaler Ausdruck
     sein und trigonometrische Funktionen, Exponentialfunktionen und
     andere Funktionen enthalten.  Zur Lsung wird die folgende Methode
     verwendet:

     Sei <E> ein Ausdruck und <X> die Variable.  Ist <E> linear in <X>,
     dann kann die Gleichung sofort nach der Variablen `X' aufgelst
     werden.  Hat <E> die Form `A*X^N + B', dann ist das Ergebnis
     `(-B/A)^1/N)' mal die `N'-te Einheitswurzel.

     Ist <E> nicht linear in <X>, wird der grte gemeinsame Teiler <N>
     der Exponenten der Variable <X> bestimmt.  Die Exponenten der
     Variablen werden durch <N> dividiert und die Multiplizitt der
     Lsungen mit <N> multipliziert.  `solve' wird erneut fr den
     Ausdruck aufgerufen.  Kann <E> faktorisiert werden, wird `solve'
     fr jeden Faktor aufgerufen.  Zuletzt prft `solve', ob einer der
     Algorithmen fr quadratische, kubische oder quartische Gleichungen
     angewendet werden kann.

     Ist <E> ein Polynom in einer Funktion `F(X)' mit <X> als der
     Variablen, wird zunchst die Lsung des Polynoms fr `F(X)'
     gesucht.  Ist <C> eine solche Lsung, kann die Gleichung `F(X)=C'
     gelst werden, wenn die Umkehrfunktion zu `F(X)' bekannt ist.

     Haben die Optionsvariablen `programmode' und `breakup' den Wert
     `true', werden Zwischenmarken fr gemeinsame Terme in Lsungen von
     kubischen und quartischen Gleichungen erzeugt.

     `multiplicities' ist eine Liste mit den Vielfachheiten der
     einzelnen Lsungen.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' lst ein
     Gleichungssystem mit den Polynomen <eqn_1>, ..., <eqn_n> fr die
     Variablen <x_1>, ..., <x_n>.  Die Polynome knnen linear oder
     nichtlinear sein.  Um das System zu lsen, werden die Funktionen
     `linsolve' oder `algsys' aufgerufen.  Das Ergebnis ist eine Liste
     mit den Lsungen.  Ist die Anzahl der Gleichungen gleich der
     Anzahl der Variablen des Systems, kann die Liste mit den Variablen
     entfallen.

     Wenn `programmode' `false' ist, zeigt `solve' die Lsungen mit
     Hilfe von Zwischenmarken (`%t') an und gibt die Liste der Marken
     zurck.

     Hat `programmode' den Wert `false', werden die Lsungen
     Zwischenmarken `%t' zugewiesen.  Die Rckgabe ist in diesem Fall
     eine Liste der Zwischenmarken.

     Hat `globalsolve' den Wert `true', werden den unbekannten Variablen
     eines linearen Gleichungssystems die Werte der Lsung der
     Funktionen `linsolve' und `solve' zugewiesen.

     Beispiele:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

     Die Symbole `%r' bezeichnen freie Konstanten einer Lsung.

          (%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

          solve: dependent equations eliminated: (2)
          (%o1)                      [[x = 1 - %r1, y = %r1]]

     Siehe `algsys'  and `%rnum_list'  fr mehr Informationen.

 -- Optionsvariable: solvedecomposes
     Standardwert: `true'

     Hat `solvedecomposes' den Wert `true', ruft `solve' die Funktion
     `polydecomp' auf, um Polynome zu lsen.

 -- Optionsvariable: solveexplicit
     Standardwert: `false'

     Hat `solveexplicit' den Wert `true', gibt `solve' keine impliziten
     Lsungen der Form `F(x) = 0' zurck.

 -- Optionsvariable: solvefactors
     Standardwert: `true'

     Hat `solvefactors' den Wert `false', versucht `solve' nicht, den
     Ausdruck zu faktorisieren.

 -- Optionsvariable: solvenullwarn
     Standardwert: `true'

     Hat `solvenullwarn' den Wert `true', gibt `solve' eine Warnmeldung
     aus, wenn keine Gleichungen oder keine Variablen als Argument
     bergeben wurden.

 -- Optionsvariable: solveradcan
     Standardwert: `false'

     Hat `solveradcan' den Wert `true', ruft `solve' die Funktion
     `radcan' auf, um Ausdrcke zu vereinfachen.

 -- Optionsvariable: solvetrigwarn
     Standardwert: `true'

     Hat `solvetrigwarn' den Wert `true', gibt `solve' eine Warnung
     aus, wenn inverse trigonometrische Funktionen genutzt werden, um
     Lsungen zu finden.  In diesem Fall knnen Lsungen verloren gehen.



Local Variables:
coding: iso-8859-1
End:
