@c -----------------------------------------------------------------------------
@c File     : stringproc.de.texi
@c License  : GNU General Public License (GPL)
@c Language : German
@c Original : stringproc.texi
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in die Verarbeitung von Zeichenketten::
* Ein- und Ausgabe::
* Buchstaben::
* Verarbeitung von Zeichenketten::
* Oktette und Werkzeuge f@"ur die Kryptographie::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in die Verarbeitung von Zeichenketten, Ein- und Ausgabe, stringproc, stringproc
@section Einf@"uhrung in die Verarbeitung von Zeichenketten
@c -----------------------------------------------------------------------------

@code{stringproc.lisp} enlarges Maximas capabilities of working with strings 
and adds some useful functions for file in/output.

For questions and bugs please mail to volkervannek at gmail dot com .

In Maxima a string is easily constructed by typing "text".
@mref{stringp} tests for strings.

@example
(%i1) m: "text";
(%o1)                         text
(%i2) stringp(m);
(%o2)                         true
@end example

Characters are represented as strings of length 1.
These are not Lisp characters.
Tests can be done with @mref{charp} (respectively @mref{lcharp}@w{}
and conversion from Lisp to Maxima characters with @mref{cunlisp}).

@example
(%i1) c: "e";
(%o1)                           e
(%i2) [charp(c),lcharp(c)];
(%o2)                     [true, false]
(%i3) supcase(c);
(%o3)                           E
(%i4) charp(%);
(%o4)                         true
@end example

All functions in @code{stringproc.lisp} that return characters, return 
Maxima characters.  Due to the fact, that the introduced characters are strings 
of length 1, you can use a lot of string functions also for characters.
As seen, @mref{supcase} is one example.

It is important to know, that the first character in a Maxima string is at 
position 1.  This is designed due to the fact that the first element in a 
Maxima list is at position 1 too.  See definitions of @mref{charat} and
@mref{charlist} for examples.

In applications string functions are often used when working with files.
You will find some useful stream and print functions in @code{stringproc.lisp}.
The following example shows some of the here introduced functions at work.

Example: 

@mref{openw} returns an output stream to a file, @code{printf} then allows
formatted writing to this file.  See @mref{printf} for details.

@example
(%i1) s: openw("E:/file.txt");
(%o1)                    #<output stream E:/file.txt>
(%i2) for n:0 thru 10 do printf( s, "~d ", fib(n) );
(%o2)                                done
(%i3) printf( s, "~%~d ~f ~a ~a ~f ~e ~a~%", 
              42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
(%o3)                                false
(%i4) close(s);
(%o4)                                true
@end example

After closing the stream you can open it again, this time with input direction.
@mref{readline} returns the entire line as one string.  The @code{stringproc}
package now offers a lot of functions for manipulating strings.  Tokenizing can 
be done by @mref{split} or @mrefdot{tokens}

@example
(%i5) s: openr("E:/file.txt");
(%o5)                     #<input stream E:/file.txt>
(%i6) readline(s);
(%o6)                     0 1 1 2 3 5 8 13 21 34 55 
(%i7) line: readline(s);
(%o7)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
(%i8) list: tokens(line);
(%o8)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
(%i9) map( parse_string, list );
(%o9)            [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
(%i10) float(%);
(%o10) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01,
                                                     0.01, 0.01]
(%i11) readline(s);
(%o11)                               false
(%i12) close(s)$
@end example

@code{readline} returns @code{false} when the end of file occurs.

@c -----------------------------------------------------------------------------
@node Ein- und Ausgabe, Buchstaben, Einf@"uhrung in die Verarbeitung von Zeichenketten, stringproc
@section Ein- und Ausgabe
@c -----------------------------------------------------------------------------

Example: 

@example
(%i1) s: openw("E:/file.txt");
(%o1)                     #<output stream E:/file.txt>
(%i2) control: 
"~2tAn atom: ~20t~a~%~2tand a list: ~20t~@{~r ~@}~%~2t\
and an integer: ~20t~d~%"$
(%i3) printf( s,control, 'true,[1,2,3],42 )$
(%o3)                                false
(%i4) close(s);
(%o4)                                true
(%i5) s: openr("E:/file.txt");
(%o5)                     #<input stream E:/file.txt>
(%i6) while stringp( tmp:readline(s) ) do print(tmp)$
  An atom:          true 
  and a list:       one two three  
  and an integer:   42 
(%i7) close(s)$
@end example

@c -----------------------------------------------------------------------------
@anchor{close}
@deffn {Function} close (@var{stream}) 

Closes @var{stream} and returns @code{true} if @var{stream} had been open.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{flength}
@deffn {Funktion} flength (@var{stream})

@var{stream} muss ein ge@"offneter Datenstrom in eine oder aus einer Datei sein. 
@code{flength} gibt dann die Anzahl der Bytes zur@"uck, die sich momentan in 
dieser Datei befinden.

Beispiel: Siehe @ref{writebyte} .
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Funktion} flush_output (@var{stream}) 

Leert den Inhalt des Dateiausgabestroms @var{stream} in die Datei.

Beispiel: Siehe @ref{writebyte} .

@end deffn

@c -----------------------------------------------------------------------------
@anchor{fposition}
@deffn  {Function} fposition (@var{stream})
@deffnx {Function} fposition (@var{stream}, @var{pos})

Returns the current position in @var{stream}, if @var{pos} is not used. 
If @var{pos} is used, @code{fposition} sets the position in @var{stream}.
@var{stream} has to be a stream from or to a file and 
@var{pos} has to be a positive number where the first element in @var{stream} 
is in position 1.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{freshline}
@deffn  {Function} freshline () 
@deffnx {Function} freshline (@var{stream})

Writes a new line (to @var{stream}), if the position is not at the beginning of 
a line.  See also @mrefdot{newline}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{get_output_stream_string}
@deffn {Funktion} get_output_stream_string (@var{stream})

Gibt Buchstaben, aktuell in dem ge@"offneten Datenstrom @var{stream} 
enthalten sind, in einer Zeichenkette zur@"uck. Die zur@"uck gegebenen 
Buchstaben werden dabei aus dem Datenstrom entfernt. @var{stream} muss durch 
@code{make_string_output_stream} erzeugt worden sein.

Beispiel: Siehe @ref{make_string_output_stream} .
@end deffn

@c -----------------------------------------------------------------------------
@anchor{make_string_input_stream}
@deffn {Funktion} make_string_input_stream (@var{string})
@deffnx {Funktion} make_string_input_stream (@var{string}, @var{start})
@deffnx {Funktion} make_string_input_stream (@var{string}, @var{start}, @var{end})

Gibt einen Datenstrom zur@"uck, der Teile der Zeichenkette @var{string} 
und ein Dateiende enth@"alt. 
Ohne optionale Argumente enth@"alt der Strom die gesamte Zeichenkette 
und ist vor dem ersten Buchstaben positioniert. Mit den optionalen Argumenten 
@var{start} und @var{end} l@"asst sich der Abschnitt der Zeichenkette festlegen, 
den der Datenstrom enth@"alt. Der erste Buchstabe befindet sich dabei an der 
Position 1.
 
@example
(%i1) istream : make_string_input_stream("text", 1, 4);
(%o1)              #<string-input stream from "text">
(%i2) (while (c : readchar(istream)) # false do sprint(c), newline())$
t e x 
(%i3) close(istream)$
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{make_string_output_stream}
@deffn {Funktion} make_string_output_stream ()

Gibt einen Datenstrom zur@"uck, der Buchstaben aufnehmen kann. Die aktuell  
im Strom enthaltenden Buchstaben k@"onnen mit @ref{get_output_stream_string} 
entnommen werden.
 
@example
(%i1) ostream : make_string_output_stream();
(%o1)               #<string-output stream 09622ea0>
(%i2) printf(ostream, "foo")$

(%i3) printf(ostream, "bar")$

(%i4) string : get_output_stream_string(ostream);
(%o4)                            foobar
(%i5) printf(ostream, "baz")$

(%i6) string : get_output_stream_string(ostream);
(%o6)                              baz
(%i7) close(ostream)$
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{newline}
@deffn  {Function} newline () 
@deffnx {Function} newline (@var{stream})

Writes a new line (to @var{stream}).  See @mref{sprint} for an example of using
@code{newline()}.  Note that there are some cases, where @code{newline()} does 
not work as expected.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{opena}
@deffn {Funktion} opena (@var{file})

Gibt einen Dateiausgabestrom f@"ur Buchstaben zur@"uck. 
Sollte die Textdatei @var{file} nicht existieren, wird sie erzeugt. 
Wird eine bereits vorhandene Datei ge@"offnet, werden alle Ausgaben in die 
Datei am Ende hinzu gef@"ugt.

@ref{Functions and Variables for binary input and output, , opena_binary} 
ist die entsprechende Funktion f@"ur die Ausgabe in eine Bin@"ardatei.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{openr}
@deffn {Funktion} openr (@var{file})

Gibt einen Dateieingabestrom f@"ur Buchstaben aus einer Textdatei zur@"uck. 
Voraussetzung ist, dass die Datei @var{file} bereits existiert. 

@ref{Functions and Variables for binary input and output, , openr_binary} 
ist die entsprechende Funktion f@"ur die Eingabe aus einer Bin@"ardatei.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{openw}
@deffn {Funktion} openw (@var{file})

Gibt einen Dateiausgabestrom f@"ur Buchstaben zur@"uck. 
Sollte die Textdatei @var{file} nicht existieren, wird sie erzeugt. 
Wird eine bereits vorhandene Datei ge@"offnet, wird sie destruktiv ver@"andert. 

@ref{Functions and Variables for binary input and output, , openw_binary} 
ist die entsprechende Funktion f@"ur die Ausgabe in eine Bin@"ardatei.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{printf}
@deffn  {Function} printf (@var{dest}, @var{string})
@deffnx {Function} printf (@var{dest}, @var{string}, @var{expr_1}, @dots{}, @var{expr_n})

Erzeugt eine formatierte Ausgabe. Der Zielparameter @var{dest} gibt an, wo die 
Ausgabe erfolgen soll. M@"oglich sind hier ein Ausgabestrom oder die globalen 
Variablen @code{true} und @code{false}. @code{true} bewirkt eine Ausgabe im Terminal. 
Der R@"uckgabewert von @code{printf} ist in diesem Fall @code{false}. 
@code{false} als Zielparameter bewirkt die Ausgabe im R@"uckgabewert. 

Die Buchstaben des Kontrollparameters @var{string} werden der Reihe nach ausgegeben, 
wobei jedoch eine Tilde eine Direktive einleitet. Die Direktiven verwenden 
dann im Allgemeinen die nachstehenden Parameter @var{expr_1}, @dots{}, @var{expr_n}, 
um die Ausgabe zu erzeugen. Der Buchstabe nach der Tilde gibt dabei an, 
welche Art der Formatierung gew@"unscht ist. 

@code{printf} stellt die Common Lisp Funktion @code{format} in Maxima zur Verf@"ugung. 
Das folgende Beispiel zeigt die grunds@"atzliche Beziehung zwischen diesen 
beiden Funktionen.

@example
(%i1) printf(true, "R~dD~d~%", 2, 2);
R2D2
(%o1)                                false
(%i2) :lisp (format t "R~dD~d~%" 2 2)
R2D2
NIL
@end example

Die folgende Beschreibung und die Beispiele beschr@"anken sich auf eine grobe 
Skizze der Verwendungsm@"oglichkeiten von @code{printf}.  
Die Lisp Funktion @code{format} ist in vielen Referenzb@"uchern ausf@"uhrlich 
beschrieben. Eine hilfreiche Quelle ist z.B. das frei verf@"ugbare Online-Manual 
"Common Lisp the Language" von Guy L. Steele. Siehe dort das Kapitel 22.3.3. 

@example
   ~%       new line
   ~&       fresh line
   ~t       tab
   ~$       monetary
   ~d       decimal integer
   ~b       binary integer
   ~o       octal integer
   ~x       hexadecimal integer
   ~br      base-b integer
   ~r       spell an integer
   ~p       plural
   ~f       floating point
   ~e       scientific notation
   ~g       ~f or ~e, depending upon magnitude
   ~h       bigfloat
   ~a       uses Maxima function string
   ~s       like ~a, but output enclosed in "double quotes"
   ~~       ~
   ~<       justification, ~> terminates
   ~(       case conversion, ~) terminates 
   ~[       selection, ~] terminates 
   ~@{       iteration, ~@} terminates
@end example

Die Direktive ~h f@"ur Gleitkommazahlen mit beliebiger Genauigkeit 
entspricht nicht dem Lisp-Standard und wird daher unten n@"aher beschrieben. 

Die Direktive ~* wird nicht unterst@"utzt.

Ist @var{dest} ein Datenstrom oder @code{true}, gibt @code{printf} 
@code{false} zur@"uck. Andernfalls ist der R@"uckgabewert eine Zeichenkette.

@example
(%i1) printf( false, "~a ~a ~4f ~a ~@@r", 
              "String",sym,bound,sqrt(12),144), bound = 1.234;
(%o1)                 String sym 1.23 2*sqrt(3) CXLIV
(%i2) printf( false,"~@{~a ~@}",["one",2,"THREE"] );
(%o2)                          one 2 THREE 
(%i3) printf( true,"~@{~@{~9,1f ~@}~%~@}",mat ),
          mat = args(matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]))$
      1.1       2.0       3.3 
      4.0       5.0       6.0 
      7.0       8.9       9.0 
(%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
(%i5) printf( false, control, n,n, if n = 1 then 1 else 2 ), n = 2;
(%o5)                    Two birds are singing.
@end example

Die Direktive ~h wurde f@"ur Gleitkommazahlen mit beliebiger Genauigkeit 
eingef@"uhrt.

@example
~w,d,e,x,o,p@@H
 w : width
 d : decimal digits behind floating point
 e : minimal exponent digits
 x : preferred exponent
 o : overflow character
 p : padding character
 @@ : display sign for positive numbers
@end example

@example
(%i1) fpprec : 1000$
(%i2) printf(true, "|~h|~%", 2.b0^-64)$
|0.0000000000000000000542101086242752217003726400434970855712890625|
(%i3) fpprec : 26$
(%i4) printf(true, "|~h|~%", sqrt(2))$
|1.4142135623730950488016887|
(%i5) fpprec : 24$
(%i6) printf(true, "|~h|~%", sqrt(2))$
|1.41421356237309504880169|
(%i7) printf(true, "|~28h|~%", sqrt(2))$
|   1.41421356237309504880169|
(%i8) printf(true, "|~28,,,,,'*h|~%", sqrt(2))$
|***1.41421356237309504880169|
(%i9) printf(true, "|~,18h|~%", sqrt(2))$
|1.414213562373095049|
(%i10) printf(true, "|~,,,-3h|~%", sqrt(2))$
|1414.21356237309504880169b-3|
(%i11) printf(true, "|~,,2,-3h|~%", sqrt(2))$
|1414.21356237309504880169b-03|
(%i12) printf(true, "|~20h|~%", sqrt(2))$
|1.41421356237309504880169|
(%i13) printf(true, "|~20,,,,'+h|~%", sqrt(2))$
|++++++++++++++++++++|
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{readbyte}
@deffn {Funktion} readbyte (@var{stream}) 

Entfernt das erste Byte aus dem bin@"aren Eingabestrom @var{stream} und gibt es 
zur@"uck. 
Ist das Ende der Datei (EOF) erreicht, wird @code{false} zur@"uck gegeben.

Beispiel: Die ersten 16 Byte aus einer mit AES in OpenSSL verschl@"usselten 
Datei werden gelesen und ausgewertet. 

@example
(%i1) ibase: obase: 16.$

(%i2) in: openr_binary("msg.bin");
(%o2)                       #<input stream msg.bin>
(%i3) (L:[],  thru 16. do push(readbyte(in), L),  L:reverse(L));
(%o3) [53, 61, 6C, 74, 65, 64, 5F, 5F, 88, 56, 0DE, 8A, 74, 0FD, 0AD, 0F0]
(%i4) close(in);
(%o4)                                true
(%i5) map(ascii, rest(L,-8));
(%o5)                      [S, a, l, t, e, d, _, _]
(%i6) salt: octets_to_number(rest(L,8));
(%o6)                          8856de8a74fdadf0
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{readchar}
@deffn {Funktion} readchar (@var{stream})

Entfernt und gibt den ersten Buchstaben in @var{stream} zur@"uck. 
Falls das Ende des Streams erreicht sein sollte, gibt @code{readchar} 
@code{false} zur@"uck.

Beispiel: Siehe @ref{make_string_input_stream}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{readline}
@deffn {Function} readline (@var{stream})

Returns a string containing the characters from the current position in 
@var{stream} up to the end of the line or @code{false} if the end of the file 
is encountered.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sprint}
@deffn {Funktion} sprint (@var{expr_1}, @dots{}, @var{expr_n})

Wertet ihre Argumente der Reihe nach von links nach rechts aus und gibt sie dann 
auf einer Linie aus. Zeilenbegrenzungen werden dabei au@ss{}er Acht gelassen. 
An die ausgegebenen Ausdr@"ucke wird jeweils rechts ein Leerzeichen angef@"ugt. 

Die Funktion @code{newline()} kann verwendet werden, um zwischenliegende 
Zeilenumbr@"uche zu erzeugen.

Beispiel:

@example
(%i1) for n:0 thru 19 do sprint( fib(n) )$
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181
(%i2) for n:0 thru 22 do ( 
         sprint(fib(n)), if mod(n,10)=9 then newline() )$
0 1 1 2 3 5 8 13 21 34 
55 89 144 233 377 610 987 1597 2584 4181 
6765 10946 17711 
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{writebyte}
@deffn {Funktion} writebyte (@var{byte}, @var{stream}) 

Schreibt das Byte @var{byte} in den bin@"aren Ausgabestrom @var{stream}. 
@code{writebyte} gibt @code{byte} zur@"uck.

Beispiel: Es werden Bytes in eine Bin@"ardatei geschrieben. 
In diesem Beispiel entsprechen s@"amtliche Bytes druckbaren Zeichen, 
die mit Hilfe von @code{printfile} ausgegeben werden k@"onnen. 
Die Bytes verbleiben so lange im Datenstrom, bis die Funktionen @code{flush_output} 
oder @code{close} aufgerufen werden.

@example
(%i1) ibase: obase: 16.$

(%i2) bytes: map(cint, charlist("GNU/Linux"));
(%o2)                [47, 4E, 55, 2F, 4C, 69, 6E, 75, 78]
(%i3) out: openw_binary("test.bin");
(%o3)                      #<output stream test.bin>
(%i4) for i thru 3 do writebyte(bytes[i], out);
(%o4)                                done
(%i5) printfile("test.bin")$

(%i6) flength(out);
(%o6)                                  0
(%i7) flush_output(out);
(%o7)                                true
(%i8) flength(out);
(%o8)                                  3
(%i9) printfile("test.bin")$
GNU
(%i0A) for b in rest(bytes,3) do writebyte(b, out);
(%o0A)                               done
(%i0B) close(out);
(%o0B)                               true
(%i0C) printfile("test.bin")$
GNU/Linux
@end example

@end deffn

@c -----------------------------------------------------------------------------
@node Buchstaben, Verarbeitung von Zeichenketten, Ein- und Ausgabe, stringproc
@section Buchstaben
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{alphacharp}
@deffn {Function} alphacharp (@var{char})

Returns @code{true} if @var{char} is an alphabetic character.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{alphanumericp}
@deffn {Function} alphanumericp (@var{char})

Returns @code{true} if @var{char} is an alphabetic character or a digit.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ascii}
@deffn {Function} ascii (@var{int})

Returns the character corresponding to the ASCII number @var{int}.
( -1 < int < 256 )

Examples:

@example
(%i1) for n from 0 thru 255 do ( 
   tmp: ascii(n), if alphacharp(tmp) then sprint(tmp),
      if n=96 then newline() )$
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
a b c d e f g h i j k l m n o p q r s t u v w x y z
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cequal}
@deffn {Function} cequal (@var{char_1}, @var{char_2})

Returns @code{true} if @var{char_1} and @var{char_2} are the same.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cequalignore}
@deffn {Function} cequalignore (@var{char_1}, @var{char_2})

Like @mref{cequal} but ignores case.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cgreaterp}
@deffn {Function} cgreaterp (@var{char_1}, @var{char_2})

Returns @code{true} if the ASCII number of @var{char_1} is greater than the 
number of @var{char_2}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cgreaterpignore}
@deffn {Function} cgreaterpignore (@var{char_1}, @var{char_2})

Like @mref{cgreaterp} but ignores case.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{charp}
@deffn {Function} charp (@var{obj})

Returns @code{true} if @var{obj} is a Maxima character.
See introduction for example.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cint}
@deffn {Function} cint (@var{char})

Returns the ASCII number of @var{char}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{clessp}
@deffn {Function} clessp (@var{char_1}, @var{char_2})

Returns @code{true} if the ASCII number of @var{char_1} is less than the number 
of @var{char_2}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{clesspignore}
@deffn {Function} clesspignore (@var{char_1}, @var{char_2})

Like @mref{clessp} but ignores case.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{constituent}
@deffn {Function} constituent (@var{char})

Returns @code{true} if @var{char} is a graphic character and not the space 
character.  A graphic character is a character one can see, plus the space 
character.  (@code{constituent} is defined by Paul Graham, ANSI Common Lisp, 
1996, page 67.)

Example:

@example
(%i1) for n from 0 thru 255 do ( 
tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @@ A B
C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
d e f g h i j k l m n o p q r s t u v w x y z @{ | @} ~
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cunlisp}
@deffn {Function} cunlisp (@var{lisp_char})

Converts a Lisp character into a Maxima character.
(You won't need it.)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{digitcharp}
@deffn {Function} digitcharp (@var{char})

Returns @code{true} if @var{char} is a digit.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lcharp}
@deffn {Function} lcharp (@var{obj})

Returns @code{true} if @var{obj} is a Lisp character.
(You won't need it.)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lowercasep}
@deffn {Function} lowercasep (@var{char})

Returns @code{true} if @var{char} is a lowercase character.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{newline_variable}
@defvr {Variable} newline

The newline character.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{space}
@defvr {Variable} space

The space character.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{tab}
@defvr {Variable} tab

The tab character.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{uppercasep}
@deffn {Function} uppercasep (@var{char})

Returns @code{true} if @var{char} is an uppercase character.
@end deffn

@c -----------------------------------------------------------------------------
@node Verarbeitung von Zeichenketten, Oktette und Werkzeuge f@"ur die Kryptographie, Buchstaben, stringproc
@section Verarbeitung von Zeichenketten
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{charat}
@deffn {Funktion} charat (@var{string}, @var{n})

Gibt den @var{n}-ten Buchstaben in @var{string} zur@"uck.
Den ersten Buchstaben in @var{string} erh@"alt man mit @var{n} = 1. 

Beispiel:

@example
(%i1) charat("Lisp", 1);
(%o1)                           L
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{charlist}
@deffn {Funktion} charlist (@var{string})

Gibt eine Liste mit allen Buchstaben in @var{string} zur@"uck.

Beispiel:

@example
(%i1) charlist("Lisp");
(%o1)                     [L, i, s, p]
(%i2) %[1];
(%o2)                           L
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{eval_string}
@deffn {Function} eval_string (@var{str})

Parse the string @var{str} as a Maxima expression and evaluate it.  The string
@var{str} may or may not have a terminator (dollar sign @code{$} or semicolon 
@code{;}).  Only the first expression is parsed and evaluated, if there is more 
than one.

Complain if @var{str} is not a string.

See also @mrefdot{parse_string}

Examples:

@example
(%i1) eval_string ("foo: 42; bar: foo^2 + baz");
(%o1)                       42
(%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
(%o2)                   baz + 1764
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parse_string}
@deffn {Function} parse_string (@var{str})

Parse the string @var{str} as a Maxima expression (do not evaluate it).  The 
string @var{str} may or may not have a terminator (dollar sign @code{$} or 
semicolon @code{;}).  Only the first expression is parsed, if there is more 
than one.

Complain if @var{str} is not a string.

See also @mrefdot{eval_string}

Examples:

@example
(%i1) parse_string ("foo: 42; bar: foo^2 + baz");
(%o1)                    foo : 42
(%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                   2
(%o2)          (foo : 42, bar : foo  + baz)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{scopy}
@deffn {Function} scopy (@var{string})

Returns a copy of @var{string} as a new string.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sdowncase}
@deffn  {Function} sdowncase (@var{string}) 
@deffnx {Function} sdowncase (@var{string}, @var{start}) 
@deffnx {Function} sdowncase (@var{string}, @var{start}, @var{end})

Like @mrefcomma{supcase} but uppercase characters are converted to lowercase.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sequal}
@deffn {Function} sequal (@var{string_1}, @var{string_2})

Returns @code{true} if @var{string_1} and @var{string_2} are the same length 
and contain the same characters.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sequalignore}
@deffn {Function} sequalignore (@var{string_1}, @var{string_2})

Like @mref{sequal} but ignores case.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sexplode}
@deffn {Function} sexplode (@var{string})

@code{sexplode} is an alias for function @mrefdot{charlist}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{simplode}
@deffn  {Function} simplode (@var{list})  
@deffnx {Function} simplode (@var{list}, @var{delim})

@code{simplode} takes a list of expressions and concatenates them into a string.
If no delimiter @var{delim} is specified, @code{simplode} uses no delimiter.
@var{delim} can be any string.

Examples:

@example
(%i1) simplode(["xx[",3,"]:",expand((x+y)^3)]);
(%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i2) simplode( sexplode("stars")," * " );
(%o2)                   s * t * a * r * s
(%i3) simplode( ["One","more","coffee."]," " );
(%o3)                   One more coffee.
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sinsert}
@deffn {Function} sinsert (@var{seq}, @var{string}, @var{pos})

Returns a string that is a concatenation of @code{substring (@var{string}, 
1, @var{pos} - 1)}, the string @var{seq} and @code{substring (@var{string}, 
@var{pos})}.  Note that the first character in @var{string} is in position 1.

Examples:

@example
(%i1) s: "A submarine."$
(%i2) concat( substring(s,1,3),"yellow ",substring(s,3) );
(%o2)                  A yellow submarine.
(%i3) sinsert("hollow ",s,3);
(%o3)                  A hollow submarine.
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sinvertcase}
@deffn  {Function} sinvertcase (@var{string})  
@deffnx {Function} sinvertcase (@var{string}, @var{start})  
@deffnx {Function} sinvertcase (@var{string}, @var{start}, @var{end})

Returns @var{string} except that each character from position @var{start} to 
@var{end} is inverted.  If @var{end} is not given, all characters from 
@var{start} to the end of @var{string} are replaced.

Examples:

@example
(%i1) sinvertcase("sInvertCase");
(%o1)                      SiNVERTcASE
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{slength}
@deffn {Function} slength (@var{string})

Returns the number of characters in @var{string}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{smake}
@deffn {Function} smake (@var{num}, @var{char})

Returns a new string with a number of @var{num} characters @var{char}.

Example:

@example
(%i1) smake(3,"w");
(%o1)                          www
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{smismatch}
@deffn  {Function} smismatch (@var{string_1}, @var{string_2}) 
@deffnx {Function} smismatch (@var{string_1}, @var{string_2}, @var{test})

Returns the position of the first character of @var{string_1} at which 
@var{string_1} and @var{string_2} differ or @code{false}.  Default test function
for matching is @mrefdot{sequal}  If @code{smismatch} should ignore case, use 
@mref{sequalignore} as test.

Example:

@example
(%i1) smismatch("seven","seventh");
(%o1)                           6
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{split}
@deffn  {Function} split (@var{string})  
@deffnx {Function} split (@var{string}, @var{delim})  
@deffnx {Function} split (@var{string}, @var{delim}, @var{multiple})

Returns the list of all tokens in @var{string}.
Each token is an unparsed string.
@code{split} uses @var{delim} as delimiter.
If @var{delim} is not given, the space character is the default delimiter.
@var{multiple} is a boolean variable with @code{true} by default.
Multiple delimiters are read as one.
This is useful if tabs are saved as multiple space characters.
If @var{multiple} is set to @code{false}, each delimiter is noted.

Examples:

@example
(%i1) split("1.2   2.3   3.4   4.5");
(%o1)                 [1.2, 2.3, 3.4, 4.5]
(%i2) split("first;;third;fourth",";",false);
(%o2)               [first, , third, fourth]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sposition}
@deffn {Function} sposition (@var{char}, @var{string})

Returns the position of the first character in @var{string} which matches 
@var{char}.  The first character in @var{string} is in position 1.
For matching characters ignoring case see @mrefdot{ssearch}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sremove}
@deffn  {Function} sremove (@var{seq}, @var{string})  
@deffnx {Function} sremove (@var{seq}, @var{string}, @var{test})  
@deffnx {Function} sremove (@var{seq}, @var{string}, @var{test}, @var{start})  
@deffnx {Function} sremove (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})
 
Returns a string like @var{string} but without all substrings matching 
@var{seq}.  Default test function for matching is @mrefdot{sequal}  If 
@code{sremove} should ignore case while searching for @var{seq}, use 
@mref{sequalignore} as test.  Use @var{start} and @var{end} to limit searching.
Note that the first character in @var{string} is in position 1.

Examples:

@example
(%i1) sremove("n't","I don't like coffee.");
(%o1)                   I do like coffee.
(%i2) sremove ("DO ",%,'sequalignore);
(%o2)                    I like coffee.
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sremovefirst}
@deffn  {Function} sremovefirst (@var{seq}, @var{string})  
@deffnx {Function} sremovefirst (@var{seq}, @var{string}, @var{test})  
@deffnx {Function} sremovefirst (@var{seq}, @var{string}, @var{test}, @var{start})  
@deffnx {Function} sremovefirst (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})

Like @code{sremove} except that only the first substring that matches @code{seq}
is removed.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sreverse}
@deffn {Function} sreverse (@var{string}) 

Returns a string with all the characters of @var{string} in reverse order.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ssearch}
@deffn  {Function} ssearch (@var{seq}, @var{string})  
@deffnx {Function} ssearch (@var{seq}, @var{string}, @var{test})  
@deffnx {Function} ssearch (@var{seq}, @var{string}, @var{test}, @var{start})  
@deffnx {Function} ssearch (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})

Returns the position of the first substring of @var{string} that matches the 
string @var{seq}.  Default test function for matching is @mrefdot{sequal}  If
@code{ssearch} should ignore case, use @mref{sequalignore} as test.  Use
@var{start} and @var{end} to limit searching.  Note that the first character in 
@var{string} is in position 1.

Example:

@example
(%i1) ssearch("~s","~@{~S ~@}~%",'sequalignore);
(%o1)                                  4
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ssort}
@deffn  {Function} ssort (@var{string}) 
@deffnx {Function} ssort (@var{string}, @var{test}) 

Returns a string that contains all characters from @var{string} in an order such
there are no two successive characters @var{c} and @var{d} such that
@code{test (@var{c}, @var{d})} is @code{false} and @code{test (@var{d}, 
@var{c})} is @code{true}.  Default test function for sorting is
@mrefdot{clessp}  The set of test functions is @code{@{@mrefcomma{clessp}@w{}
@mrefcomma{clesspignore} @mrefcomma{cgreaterp} @mrefcomma{cgreaterpignore}@w{}
@mrefcomma{cequal} @mref{cequalignore}@}}.

Example:

@example
(%i1) ssort("I don't like Mondays.");
(%o1)                    '.IMaddeiklnnoosty
(%i2) ssort("I don't like Mondays.",'cgreaterpignore);
(%o2)                 ytsoonnMlkIiedda.'   
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ssubst}
@deffn  {Function} ssubst (@var{new}, @var{old}, @var{string}) 
@deffnx {Function} ssubst (@var{new}, @var{old}, @var{string}, @var{test}) 
@deffnx {Function} ssubst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}) 
@deffnx {Function} ssubst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}, @var{end}) 

Returns a string like @var{string} except that all substrings matching @var{old}
are replaced by @var{new}.  @var{old} and @var{new} need not to be of the same 
length.  Default test function for matching is @mrefdot{sequal}  If
@code{ssubst} should ignore case while searching for old, use 
@mref{sequalignore} as test.  Use @var{start} and @var{end} to limit searching.
Note that the first character in @var{string} is in position 1.

Examples:

@example
(%i1) ssubst("like","hate","I hate Thai food. I hate green tea.");
(%o1)          I like Thai food. I like green tea.
(%i2) ssubst("Indian","thai",%,'sequalignore,8,12);
(%o2)         I like Indian food. I like green tea.
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{ssubstfirst}
@deffn  {Function} ssubstfirst (@var{new}, @var{old}, @var{string}) 
@deffnx {Function} ssubstfirst (@var{new}, @var{old}, @var{string}, @var{test}) 
@deffnx {Function} ssubstfirst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}) 
@deffnx {Function} ssubstfirst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}, @var{end}) 

Like @mref{subst} except that only the first substring that matches @var{old}
is replaced.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{strim}
@deffn {Function} strim (@var{seq},@var{string}) 

Returns a string like @var{string}, but with all characters that appear in 
@var{seq} removed from both ends.

Examples:

@example
(%i1) "/* comment */"$
(%i2) strim(" /*",%);
(%o2)                        comment
(%i3) slength(%);
(%o3)                           7
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{striml}
@deffn {Function} striml (@var{seq}, @var{string}) 

Like @mref{strim} except that only the left end of @var{string} is trimmed.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{strimr}
@deffn {Function} strimr (@var{seq}, @var{string}) 

Like @mref{strim} except that only the right end of string is trimmed.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{stringp}
@deffn {Function} stringp (@var{obj})

Returns @code{true} if @var{obj} is a string.
See introduction for example.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{substring}
@deffn  {Function} substring (@var{string}, @var{start})
@deffnx {Function} substring (@var{string}, @var{start}, @var{end}) 

Returns the substring of @var{string} beginning at position @var{start} and 
ending at position @var{end}.  The character at position @var{end} is not 
included.  If @var{end} is not given, the substring contains the rest of the 
string.  Note that the first character in @var{string} is in position 1.

Examples:

@example
(%i1) substring("substring",4);
(%o1)                        string
(%i2) substring(%,4,6);
(%o2)                          in
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{supcase}
@deffn  {Function} supcase (@var{string}) 
@deffnx {Function} supcase (@var{string}, @var{start}) 
@deffnx {Function} supcase (@var{string}, @var{start}, @var{end}) 

Returns @var{string} except that lowercase characters from position @var{start} 
to @var{end} are replaced by the corresponding uppercase ones.  If @var{end} is 
not given, all lowercase characters from @var{start} to the end of @var{string} 
are replaced.

Example:

@example
(%i1) supcase("english",1,2);
(%o1)                        English
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{tokens}
@deffn  {Function} tokens (@var{string}) 
@deffnx {Function} tokens (@var{string}, @var{test}) 

Returns a list of tokens, which have been extracted from @var{string}.
The tokens are substrings whose characters satisfy a certain test function.
If @var{test} is not given, @var{constituent} is used as the default test.
@code{@{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp@}} is the set of test functions. 
(The Lisp-version of @code{tokens} is written by Paul Graham. ANSI Common Lisp, 1996, page 67.)

Examples:

@example
(%i1) tokens("24 October 2005");
(%o1)                  [24, October, 2005]
(%i2) tokens("05-10-24",'digitcharp);
(%o2)                     [05, 10, 24]
(%i3) map(parse_string,%);
(%o3)                      [5, 10, 24]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Oktette und Werkzeuge f@"ur die Kryptographie,  , Verarbeitung von Zeichenketten, stringproc
@section Oktette und Werkzeuge f@"ur die Kryptographie
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{base64}
@deffn {Funktion} base64 (@var{arg})

Gibt eine Base64-Darstellung von @var{arg} zur@"uck. 
Das Argument @var{arg} kann eine Zeichenkette, eine nicht-negative Ganzzahl 
oder eine Liste von Oktetten sein.

Beispiel:

@example
(%i1) base64: base64("foo bar baz");
(%o1)                          Zm9vIGJhciBiYXo=
(%i2) string: base64_decode(base64);
(%o2)                            foo bar baz
(%i3) obase: 16.$
(%i4) integer: base64_decode(base64, 'number);
(%o4)                       666f6f206261722062617a
(%i5) octets: base64_decode(base64, 'list);
(%o5)            [66, 6F, 6F, 20, 62, 61, 72, 20, 62, 61, 7A]
(%i6) ibase: 16.$
(%i7) base64(octets);
(%o7)                          Zm9vIGJhciBiYXo=
@end example

Sind in @var{arg} Umlaute oder Eszett enthalten (bzw. Oktette gr@"o@ss{}er 
als 127), ist das Ergebnis von der verwendeten Plattform abh@"angig. 
Es wird aber durch eine Anwendung von @ref{base64_decode} in jedem Fall 
wieder in die urspr@"ungliche Zeichenkette zur@"uck verwandelt.

@end deffn

@c -----------------------------------------------------------------------------
@anchor{base64_decode}
@deffn {Funktion} base64_decode (@var{base64-string})
@deffnx {Funktion} base64_decode (@var{base64-string}, @var{return-type}) 

Dekodiert die Base64-kodierte Zeichenkette @var{base64-string} standardm@"a@ss{}ig 
wieder zur@"uck in die urspr@"ungliche Zeichenkette.

Das optionale Argument @var{return-type} erlaubt es @code{base64_decode}, 
alternativ hierzu auch die entsprechende Ganzzahl oder Liste von Oktetten 
zur@"uck zu geben.

Beispiel: Siehe @ref{base64}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{crc24sum}
@deffn {Funktion} crc24sum (@var{octets})
@deffnx {Funktion} crc24sum (@var{octets}, @var{return-type}) 

Gibt standardm@"a@ss{}ig die @code{CRC24}-Pr@"ufsumme einer Oktett-Liste als 
Zeichenkette zur@"uck.

Das optionale Argument @var{return-type} erlaubt es @code{crc24sum}, 
alternativ hierzu auch die entsprechende Ganzzahl oder Liste von Oktetten 
zur@"uck zu geben.

Beispiel:
@example
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM
wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi
rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe
vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam
/spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH
WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=
=WmeC
-----END PGP SIGNATURE-----
@end example

@example
(%i1) ibase : obase : 16.$
(%i2) sig64 : sconcat(
 "iQEcBAEBAgAGBQJVdCTzAAoJEG/1Mgf2DWAqCSYH/AhVFwhu1D89C3/QFcgVvZTM",
 "wnOYzBUURJAL/cT+IngkLEpp3hEbREcugWp+Tm6aw3R4CdJ7G3FLxExBH/5KnDHi",
 "rBQu+I7+3ySK2hpryQ6Wx5J9uZSa4YmfsNteR8up0zGkaulJeWkS4pjiRM+auWVe",
 "vajlKZCIK52P080DG7Q2dpshh4fgTeNwqCuCiBhQ73t8g1IaLdhDN6EzJVjGIzam",
 "/spqT/sTo6sw8yDOJjvU+Qvn6/mSMjC/YxjhRMaQt9EMrR1AZ4ukBF5uG1S7mXOH",
 "WdiwkSPZ3gnIBhM9SuC076gLWZUNs6NqTeE3UzMjDAFhH3jYk1T7mysCvdtIkms=" )$
(%i3) octets: base64_decode(sig64, 'list)$
(%i4) crc24: crc24sum(octets, 'list);
(%o4)                          [5A, 67, 82]
(%i5) base64(crc24);
(%o5)                              WmeC
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{md5sum}
@deffn {Funktion} md5sum (@var{arg})
@deffnx {Funktion} md5sum (@var{arg}, @var{return-type}) 

Gibt die @code{md5}-Pr@"ufsumme einer Zeichenkette, einer nicht-negativen Ganzzahl 
oder einer Liste von Oktetten zur@"uck. Der standardm@"a@ss{}ige R@"uckgabewert 
ist eine Zeichenkette mit 32 hexadezimalen Zeichen.

Das optionale Argument @var{return-type} erlaubt es @code{md5sum}, 
alternativ hierzu auch die entsprechende Ganzzahl oder Liste von Oktetten 
zur@"uck zu geben.

Beispiel:

@example
(%i1) ibase: obase: 16.$
(%i2) msg: "foo bar baz"$
(%i3) string: md5sum(msg);
(%o3)                  ab07acbb1e496801937adfa772424bf7
(%i4) integer: md5sum(msg, 'number);
(%o4)                 0ab07acbb1e496801937adfa772424bf7
(%i5) octets: md5sum(msg, 'list);
(%o5)        [0AB,7,0AC,0BB,1E,49,68,1,93,7A,0DF,0A7,72,42,4B,0F7]
(%i6) sdowncase( printf(false, "~@{~2,'0x~^:~@}", octets) );
(%o6)           ab:07:ac:bb:1e:49:68:01:93:7a:df:a7:72:42:4b:f7
@end example

Sind in @var{arg} Umlaute oder andere Nicht-ASCII-Zeichen enthalten (bzw. Oktette 
gr@"o@ss{}er als 127), ist das Ergebnis von der verwendeten Plattform abh@"angig. 

@end deffn

@c -----------------------------------------------------------------------------
@anchor{number_to_octets}
@deffn {Funktion} number_to_octets (@var{number})

Gibt eine Oktett-Darstellung der nicht-negativen Ganzzahl @var{number} in Form 
einer Liste zur@"uck. 

Beispiel:

@example
(%i1) ibase : obase : 16.$
(%i2) octets: [0ca,0fe,0ba,0be]$
(%i3) number: octets_to_number(octets);
(%o3)                            0cafebabe
(%i4) number_to_octets(number);
(%o4)                      [0CA, 0FE, 0BA, 0BE]
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{octets_to_number}
@deffn {Funktion} octets_to_number (@var{octets})

F@"ugt die in der Liste @var{octets} enthaltenden Oktette zu einer Zahl zusammen 
und gibt diese zur@"uck. 

Beispiel: Siehe @ref{number_to_octets}.

@end deffn

@c -----------------------------------------------------------------------------
@anchor{octets_to_oid}
@deffn {Funktion} octets_to_oid (@var{octets})

Berechnet eine Objektkennung (OID) aus einer Liste von Oktetten.

Beispiel: RSA encryption OID

@example
(%i1) ibase : obase : 16.$
(%i2) oid: octets_to_oid([2A,86,48,86,0F7,0D,1,1,1]);
(%o2)                      1.2.840.113549.1.1.1
(%i3) oid_to_octets(oid);
(%o3)               [2A, 86, 48, 86, 0F7, 0D, 1, 1, 1]
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{oid_to_octets}
@deffn {Funktion} oid_to_octets (@var{oid-string})

Verwandelt eine Objektkennung (OID) in eine Liste von Oktetten.

Beispiel: Siehe @ref{octets_to_oid}.

@end deffn

@c -----------------------------------------------------------------------------
@anchor{sha1sum}
@deffn {Funktion} sha1sum (@var{arg})
@deffnx {Funktion} sha1sum (@var{arg}, @var{return-type}) 

Gibt den @code{SHA1}-Fingerabdruck einer Zeichenkette, einer nicht-negativen Ganzzahl 
oder einer Liste von Oktetten zur@"uck. Der standardm@"a@ss{}ige R@"uckgabewert 
ist eine Zeichenkette mit 40 hexadezimalen Zeichen.

Das optionale Argument @var{return-type} erlaubt es @code{sha1sum}, 
alternativ hierzu auch die entsprechende Ganzzahl oder Liste von Oktetten 
zur@"uck zu geben.

Beispiel:

@example
(%i1) ibase: obase: 16.$
(%i2) msg: "foo bar baz"$
(%i3) string: sha1sum(msg);
(%o3)              c7567e8b39e2428e38bf9c9226ac68de4c67dc39
(%i4) integer: sha1sum(msg, 'number);
(%o4)             0c7567e8b39e2428e38bf9c9226ac68de4c67dc39
(%i5) octets: sha1sum(msg, 'list);
(%o5)  [0C7,56,7E,8B,39,0E2,42,8E,38,0BF,9C,92,26,0AC,68,0DE,4C,67,0DC,39]
(%i6) sdowncase( printf(false, "~@{~2,'0x~^:~@}", octets) );
(%o6)     c7:56:7e:8b:39:e2:42:8e:38:bf:9c:92:26:ac:68:de:4c:67:dc:39
@end example

Sind in @var{arg} Umlaute oder andere Nicht-ASCII-Zeichen enthalten (bzw. Oktette 
gr@"o@ss{}er als 127), ist der @code{SHA1}-Fingerabdruck von der verwendeten 
Plattform abh@"angig. 

@end deffn

@c -----------------------------------------------------------------------------
@anchor{sha256sum}
@deffn {Funktion} sha256sum (@var{arg})
@deffnx {Funktion} sha256sum (@var{arg}, @var{return-type}) 

Gibt den @code{SHA256}-Fingerabdruck einer Zeichenkette, einer nicht-negativen 
Ganzzahl oder einer Liste von Oktetten zur@"uck. Der standardm@"a@ss{}ige 
R@"uckgabewert ist eine Zeichenkette mit 64 hexadezimalen Zeichen.

Das optionale Argument @var{return-type} erlaubt es @code{sha256sum}, 
alternativ hierzu auch die entsprechende Ganzzahl oder Liste von Oktetten 
zur@"uck zu geben (siehe @ref{sha1sum}).

Beispiel:

@example
(%i1) string: sha256sum("foo bar baz");
(%o1)  dbd318c1c462aee872f41109a4dfd3048871a03dedd0fe0e757ced57dad6f2d7
@end example

Sind in @var{arg} Umlaute oder andere Nicht-ASCII-Zeichen enthalten (bzw. Oktette 
gr@"o@ss{}er als 127), ist der @code{SHA256}-Fingerabdruck von der verwendeten 
Plattform abh@"angig. 

@end deffn


@c --- End of file stringproc.de.texi ------------------------------------------

