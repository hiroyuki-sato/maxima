<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Affine</TITLE>
<link href="maxima_28.html" rel=Next>
<link href="maxima_26.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_26.html">previous</A>, <A HREF="maxima_28.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC87" HREF="maxima_toc.html#TOC87">Affine</A></H1>



<H2><A NAME="SEC88" HREF="maxima_toc.html#TOC88">Definitions for Affine</A></H2>
<P>
<DL>
<DT><U>Function:</U> <B>FAST_LINSOLVE</B> <I>(eqns,variables)</I>
<DD><A NAME="IDX699"></A>
Solves the linear system of equations
EQNS for the variables VARIABLES  and returns a result suitable to
SUBLIS.  The function is faster than linsolve for system of equations which
are sparse.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>GROBNER_BASIS</B> <I>(eqns)</I>
<DD><A NAME="IDX700"></A>
Takes as argument a macsyma list of equations
and returns a grobner basis for them.  The function POLYSIMP may now
be used to simplify other functions relative to the equations.

</P>
<P>
GROBNER_BASIS([3*X^2+1,Y*X])$

</P>
<P>
POLYSIMP(Y^2*X+X^3*9+2)==&#62; -3*x+2

</P>
<P>
Polysimp(f)==&#62; 0 if and only if f is in the ideal generated by the EQNS  ie.
if and only if f is a polynomial combination of the elements of EQNS.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SET_UP_DOT_SIMPLIFICATIONS</B> <I>(eqns,[check-thru-degree])</I>
<DD><A NAME="IDX701"></A>
The eqns are
polynomial equations in non commutative variables.
The value of CURRENT_VARIABLES is the 
list of variables used for computing degrees.  The equations must be
homogeneous, in order for the procedure to terminate.  

</P>
<P>
If you have checked overlapping simplifications in DOT_SIMPLIFICATIONS
above the degree of f, then the following is true:
DOTSIMP(f)==&#62; 0 if and only if f is in the ideal generated by the EQNS  ie.
if and only if f is a polynomial combination of the elements of EQNS.

</P>
<P>
The degree is that returned by NC_DEGREE.   This in turn is influenced by
the weights of individual variables.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DECLARE_WEIGHT</B> <I>(var1,wt1,var2,wt2,...)</I>
<DD><A NAME="IDX702"></A>
Assigns VAR1 weight WT1, VAR2 weight wt2..
These are the weights used in computing NC_DEGREE.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NC_DEGREE</B> <I>(poly)</I>
<DD><A NAME="IDX703"></A>
Degree of a non commutative polynomial.  See DECLARE_WEIGHTS.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DOTSIMP</B> <I>(f)</I>
<DD><A NAME="IDX704"></A>
==&#62; 0 if and only if f is in the ideal generated by the EQNS  ie.
if and only if f is a polynomial combination of the elements of EQNS.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FAST_CENTRAL_ELEMENTS</B> <I>(variables,degree)</I>
<DD><A NAME="IDX705"></A>
if SET_UP_DOT_SIMPLIFICATIONS has been previously done, finds the central polynomials
in the variables in the given degree, 
For example:

<PRE>
set_up_dot_simplifications([y.x+x.y],3);
fast_central_elements([x,y],2);
[y.y,x.x];
</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CHECK_OVERLAPS</B> <I>(degree,add-to-simps)</I>
<DD><A NAME="IDX706"></A>
checks the overlaps thru degree,
making sure that you have sufficient simplification rules in each
degree, for dotsimp to work correctly.  This process can be speeded
up if you know before hand what the dimension of the space of monomials is.
If it is of finite global dimension, then HILBERT should be used.  If you
don't know the monomial dimensions, do not specify a RANK_FUNCTIION.
An optional third argument RESET, false says don't bother to query
about resetting things.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MONO</B> <I>(vari,n)</I>
<DD><A NAME="IDX707"></A>
VARI is a list of variables.   Returns the list of independent
monomials relative to the current dot_simplifications, in degree N

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MONOMIAL_DIMENSIONS</B> <I>(n)</I>
<DD><A NAME="IDX708"></A>

</P>
<P>
Compute the hilbert series through degreen n for the current algebra.

</P>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EXTRACT_LINEAR_EQUATIONS</B> <I>(List_nc_polys,monoms)</I>
<DD><A NAME="IDX709"></A>

</P>
<P>
Makes a list of the coefficients of the polynomials in list_nc_polys
of the monoms.  MONOMS is a list of noncommutative monomials.   The
coefficients should be scalars.   Use LIST_NC_MONOMIALS to build the list of
monoms.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LIST_NC_MONOMIALS</B> <I>(polys_or_list)</I>
<DD><A NAME="IDX710"></A>

</P>
<P>
returns a list of the non commutative monomials occurring in a polynomial
or a collection of polynomials.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PCOEFF</B> <I>(poly monom [variables-to-exclude-from-cof (list-variables monom)])</I>
<DD><A NAME="IDX711"></A>

</P>

<P>
This function is called from lisp level, and uses internal poly format.

<PRE>

CL-MAXIMA&#62;&#62;(setq me (st-rat #$x^2*u+y+1$))
(#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))

CL-MAXIMA&#62;&#62;(pcoeff me (st-rat #$x^2$))
(#:U 1 1)
</PRE>

<P>

</P>
<P>
Rule: if a variable appears in monom it must be to the exact power,
and if it is in variables to exclude it may not appear unless it was
in monom to the exact power.  (pcoeff pol 1 ..) will exclude variables
like substituting them to be zero.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NEW-DISREP</B> <I>(poly)</I>
<DD><A NAME="IDX712"></A>

</P>
<P>
From lisp this returns the general maxima format for an arg which is
in st-rat form:

</P>

<PRE>
(displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))

       2
Y + U X  + 1

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CREATE_LIST</B> <I>(form,var1,list1,var2,list2,...)</I>
<DD><A NAME="IDX713"></A>

</P>
<P>
Create a list by evaluating FORM with VAR1 bound to
each element of LIST1, and for each such binding bind VAR2
to each element of LIST2,...
The number of elements in the result will be
length(list1)*length(list2)*...
Each VARn must actually be a symbol--it will not be evaluated.
The LISTn args will be evaluated once at the beginning of the
iteration.  

</P>


<PRE>

(C82) create_list1(x^i,i,[1,3,7]);
(D82) [X,X^3,X^7]
</PRE>

<P>

</P>
<P>
With a double iteration:

<PRE>
(C79) create_list([i,j],i,[a,b],j,[e,f,h]);
(D79) [[A,E],[A,F],[A,H],[B,E],[B,F],[B,H]]
</PRE>

<P>
Instead of LISTn two args maybe supplied each of which should
evaluate to a number.   These will be the inclusive lower and
upper bounds for the iteration.   

</P>

<PRE>
(C81) create_list([i,j],i,[1,2,3],j,1,i);
(D81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]
</PRE>

<P>
Note that the limits or list for the j variable can
depend on the current value of i.

</P>

</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>ALL_DOTSIMP_DENOMS</B>
<DD><A NAME="IDX714"></A>

</P>
<P>
if its value is FALSE the denominators encountered in getting
dotsimps will not be collected.   To collect the denoms

<PRE>
ALL_DOTSIMP_DENOMS:[];
</PRE>

<P>
and they will be nconc'd onto the end of the list.

</P>

</DL>

<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_26.html">previous</A>, <A HREF="maxima_28.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
