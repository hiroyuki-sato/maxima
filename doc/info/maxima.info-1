This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introduction to Maxima,  Prev: (dir),  Up: (dir)

Maxima Manual
*************

Maxima is a computer algebra system, implemented in Lisp.

   Maxima is derived from the Macsyma system, developed at MIT in the
years 1968 through 1982 as part of Project MAC.  MIT turned over a copy
of the Macsyma source code to the Department of Energy in 1982; that
version is now known as DOE Macsyma.  A copy of DOE Macsyma was
maintained by Professor William F. Schelter of the University of Texas
from 1982 until his death in 2001.  In 1998, Schelter obtained
permission from the Department of Energy to release the DOE Macsyma
source code under the GNU Public License, and in 2000 he initiated the
Maxima project at SourceForge to maintain and develop DOE Macsyma, now
called Maxima.

* Menu:

Maxima infrastructure

* Introduction to Maxima::      Sample Maxima sessions.
* Bug Detection and Reporting:: Finding and reporting bugs in Maxima.
* Help::                        Asking for help from within a Maxima session.
* Command Line::                Maxima command line syntax.
* Operators::                   Operators used in Maxima expressions.
* Expressions::                 Expressions in Maxima.
* Simplification::              Simplifying expressions.
* Plotting::                    2D and 3D graphical output.
* Input and Output::            File input and output.
* Floating Point::              Low level numerical routines.
* Contexts::                    Sets of assumed facts.

Support for specific areas of mathematics

* Polynomials::                 Standard forms for polynomials, and
                                functions operating on them.
* Constants::                   Numerical constants.
* Logarithms::                  Manipulation of expressions involving
                                logarithms.
* Trigonometric::               Manipulating expressions with trig and
                                inverse trig functions.
* Special Functions::           Special functions
* Elliptic Functions::          Elliptic Functions and Integrals
* Limits::                      Limits of expressions.
* Differentiation::             Differential calculus.
* Integration::                 Integral calculus.
* Equations::                   Defining and solving equations.
* Differential Equations::      Defining and solving differential equations.
* Numerical::                   Numerical integration, Fourier
                                transforms, etc.
* Arrays::                      Creating and working with arrays.
* Matrices and Linear Algebra:: Matrix operations.
* Affine::
* itensor::                     Indicial Tensor Manipulation.
* ctensor::                     Component Tensor Manipulation.
* atensor::                     Algebraic Tensor Manipulation.
* Series::                      Taylor and power series.
* Number Theory::               Number theory.
* Symmetries::
* Groups::                      Abstract algebra.

Advanced facilities and programming

* Runtime Environment::         Customization of the Maxima environment.
* Miscellaneous Options::       Options with a global effect on Maxima.
* Rules and Patterns::          User defined pattern matching and
                                simplification rules.
* Lists::                       Manipulation of lists.
* Sets::                        Manipulation of sets.
* Function Definition::         Defining functions.
* Program Flow::                Defining Maxima programs.
* Debugging::                   Debugging Maxima programs.

Additional packages

* augmented_lagrangian::        augmented_lagrangian package.
* bode::                        Bode gain and phase plots.
* descriptive::                 Descriptive statistics.
* diag::                        Jordan matrices.
* distrib::                     Probability distributions.
* draw::                        A Maxima-Gnuplot interface.
* dynamics::                    Graphics for dynamical systems and fractals.
* eval_string::                 Maxima expressions as strings.
* f90::                         Maxima to fortran translator.
* ggf::                         Generating function of sequences.
* grobner::                     Functions for working with Groebner bases.
* impdiff::                     Implicit derivatives.
* implicit_plot::               Implicit plots package.
* interpol::                    Interpolation package.
* lbfgs::                       L-BFGS unconstrained minimization package.
* lindstedt::                   Lindstedt package.
* linearalgebra::               Functions for linear algebra.
* lsquares::                    Least squares.
* makeOrders::                  Polynomial utility.
* mnewton::                     Newton's method.
* numericalio::                 Reading and writing files.
* opsubst::                     Substitutions utility.
* orthopoly::                   Orthogonal polynomials.
* plotdf::                      Direction fields plots.
* romberg::                     Romberg method for numerical integration.
* simplex::                     Linear programming.
* simplification::              Simplification rules and functions.
* solve_rec::                   Linear recurrences.
* stats::                       Statistical inference package.
* stirling::                    Stirling formula.
* stringproc::                  String processing.
* unit::                        Units and dimensions package.
* zeilberger::                  Functions for hypergeometric summation.


Index

* Function and Variable Index:: Index.

 --- The Detailed Node Listing ---

Introduction

* Introduction to Maxima::

Help

* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::

Command Line

* Introduction to Command Line::
* Definitions for Command Line::

Operators

* nary::
* nofix::
* postfix::
* prefix::
* Arithmetic operators::
* Relational operators::
* General operators::

Expressions

* Introduction to Expressions::
* Assignment::
* Complex::
* Inequality::
* Syntax::
* Definitions for Expressions::

Simplification

* Definitions for Simplification::

Plotting

* Definitions for Plotting::

Input and Output

* Comments::
* Files::
* Definitions for Input and Output::

Floating Point

* Definitions for Floating Point::

Contexts

* Definitions for Contexts::

Polynomials

* Introduction to Polynomials::
* Definitions for Polynomials::

Constants

* Definitions for Constants::

Logarithms

* Definitions for Logarithms::

Trigonometric

* Introduction to Trigonometric::
* Definitions for Trigonometric::

Special Functions

* Introduction to Special Functions::
* Definitions for Special Functions::

Elliptic Functions

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::

Limits

* Definitions for Limits::

Differentiation

* Definitions for Differentiation::

Integration

* Introduction to Integration::
* Definitions for Integration::

Equations

* Definitions for Equations::

Differential Equations

* Introduction to Differential Equations::
* Definitions for Differential Equations::

Numerical

* Introduction to Numerical::
* Fourier packages::
* Definitions for Numerical::
* Definitions for Fourier Series::

Arrays

* Definitions for Arrays::

Matrices and Linear Algebra

* Introduction to Matrices and Linear Algebra::
* Dot::
* Vectors::
* eigen::
* Definitions for Matrices and Linear Algebra::

Affine

* Definitions for Affine::

itensor

* Introduction to itensor::
* Definitions for itensor::

ctensor

* Introduction to ctensor::
* Definitions for ctensor::

atensor

* Introduction to atensor::
* Definitions for atensor::

Series

* Introduction to Series::
* Definitions for Series::

Number Theory

* Definitions for Number Theory::

Symmetries

* Definitions for Symmetries::

Groups

* Definitions for Groups::

Runtime Environment

* Introduction for Runtime Environment::
* Interrupts::
* Definitions for Runtime Environment::

Miscellaneous Options

* Introduction to Miscellaneous Options::
* Share::
* Definitions for Miscellaneous Options::

Rules and Patterns

* Introduction to Rules and Patterns::
* Definitions for Rules and Patterns::

Lists

* Introduction to Lists::
* Definitions for Lists::

Sets

* Introduction to Sets::
* Definitions for Sets::

Function Definition

* Introduction to Function Definition::
* Function::
* Macros::
* Definitions for Function Definition::

Program Flow

* Introduction to Program Flow::
* Definitions for Program Flow::

Debugging

* Definitions for Debugging::


augmented_lagrangian

* Definitions for augmented_lagrangian::

bode

* Definitions for bode::

descriptive

* Introduction to descriptive::
* Definitions for data manipulation::
* Definitions for descriptive statistics::
* Definitions for specific multivariate descriptive statistics::
* Definitions for statistical graphs::

diag

* Definitions for diag::

distrib

* Introduction to distrib::
* Definitions for continuous distributions::
* Definitions for discrete distributions::

draw

* Introduction to draw::
* Definitions for draw::

dynamics

* Introduction to dynamics::
* Definitions for dynamics::

eval_string

* Definitions for eval_string::

f90

* Definitions for f90::

ggf

* Definitions for ggf::

grobner

* Introduction to grobner::
* Definitions for grobner::

impdiff

* Definitions for impdiff::

implicit_plot

* Definitions for implicit_plot::

interpol

* Introduction to interpol::
* Definitions for interpol::

lbfgs

* Introduction to lbfgs::
* Definitions for lbfgs::

lindstedt

* Definitions for lindstedt::

linearalgebra

* Introduction to linearalgebra::
* Definitions for linearalgebra::

lsquares

* Definitions for lsquares::

makeOrders

* Definitions for makeOrders::

mnewton

* Definitions for mnewton::

numericalio

* Introduction to numericalio::
* Definitions for numericalio::

opsubst

* Definitions for opsubst::

orthopoly

* Introduction to orthogonal polynomials::
* Definitions for orthogonal polynomials::

plotdf

* Introduction to plotdf::
* Definitions for plotdf::

romberg

* Definitions for romberg::

simplex

* Introduction to simplex::
* Definitions for simplex::

simplification

* Introduction to simplification::
* Definitions for simplification::

solve_rec

* Introduction to solve_rec::
* Definitions for solve_rec::

stats

* Introduction to stats::
* Definitions for inference_result::
* Definitions for stats::
* Definitions for special distributions::

stirling

* Definitions for stirling::

stringproc

* Introduction to string processing::
* Definitions for input and output::
* Definitions for characters::
* Definitions for strings::

unit

* Introduction to Units::
* Definitions for Units::

zeilberger

* Introduction to zeilberger::
* Definitions for zeilberger::


File: maxima.info,  Node: Introduction to Maxima,  Next: Bug Detection and Reporting,  Prev: Top,  Up: Top

1 Introduction to Maxima
************************

Start Maxima with the command "maxima".  Maxima will display version
information and a prompt.  End each Maxima command with a semicolon.
End the session with the command "quit();".  Here's a sample session:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima can search the info pages.  Use the `describe' command to show
all the commands and variables containing a string, and optionally their
documentation. The question mark `?' is an abbreviation for `describe':

     (%i1) ? integ

      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 6 5

     Info from file /usr/local/info/maxima.info:
      - Function: integerp (<expr>)
          Returns `true' if <expr> is an integer, otherwise `false'.


      - Function: askinteger (expr, integer)
      - Function: askinteger (expr)
      - Function: askinteger (expr, even)
      - Function: askinteger (expr, odd)
          `askinteger (expr, integer)' attempts to determine from the
          `assume' database whether `expr' is an integer.  `askinteger' will
          ask the user if it cannot tell otherwise, and attempt to install
          the information in the database if possible.  `askinteger (expr)'
          is equivalent to `askinteger (expr, integer)'.

          `askinteger (expr, even)' and `askinteger (expr, odd)' likewise
          attempt to determine if `expr' is an even integer or odd integer,
          respectively.

     (%o1)                         false

   To use a result in later calculations, you can assign it to a
variable or refer to it by its automatically supplied label.  In
addition, `%' refers to the most recent calculated result:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima knows about complex numbers and numerical constants:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima can do differential and integral calculus:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima can solve linear systems and cubic equations:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima can solve nonlinear sets of equations.  Note that if you don't
want a result printed, you can finish your command with `$' instead of
`;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima can generate plots of one or more functions:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Bug Detection and Reporting,  Next: Help,  Prev: Introduction to Maxima,  Up: Top

2 Bug Detection and Reporting
*****************************

* Menu:

* Definitions for Bug Detection and Reporting::


File: maxima.info,  Node: Definitions for Bug Detection and Reporting,  Up: Bug Detection and Reporting

2.1 Definitions for Bug Detection and Reporting
===============================================

 -- Function: run_testsuite ()
 -- Function: run_testsuite (<boolean>)
 -- Function: run_testsuite (<boolean>, <boolean>)
 -- Function: run_testsuite (<boolean>, <boolean>, <list>)
     Run the Maxima test suite. Tests producing the desired answer are
     considered "passes," as are tests that do not produce the desired
     answer, but are marked as known bugs.

     `run_testsuite ()' displays only tests that do not pass.

     `run_testsuite (true)' displays tests that are marked as known
     bugs, as well as failures.

     `run_testsuite (true, true)' displays all tests.

     If the optional third argument is given, a subset of the tests is
     run.  The subset of the tests to run is given as a list of the
     names of the tests.  The complete set of tests is specified by
     `testsuite_files'.

     `run_testsuite' changes the Maxima environment.  Typically a test
     script executes `kill' to establish a known environment (namely
     one without user-defined functions and variables) and then defines
     functions and variables appropriate to the test.

     `run_testsuite' returns `done'.

 -- Option variable: testsuite_files
     `testsuite_files' is the set of tests to be run by
     `run_testsuite'.  It is a list of names of the files containing
     the tests to run.  If some of the tests in a file are known to
     fail, then instead of listing the name of the file, a list
     containing the file name and the test numbers that fail is used.

     For example, this is a part of the default set of tests:

           ["rtest13s", ["rtest14", 57, 63]]

     This specifies the testsuite consists of the files "rtest13s" and
     "rtest14", but "rtest14" contains two tests that are known to
     fail: 57 and 63.

 -- Function: bug_report ()
     Prints out Maxima and Lisp version numbers, and gives a link to
     the Maxima project bug report web page.  The version information
     is the same as reported by `build_info'.

     When a bug is reported, it is helpful to copy the Maxima and Lisp
     version information into the bug report.

     `bug_report' returns an empty string `""'.

 -- Function: build_info ()
     Prints out a summary of the parameters of the Maxima build.

     `build_info' returns an empty string `""'.


File: maxima.info,  Node: Help,  Next: Command Line,  Prev: Bug Detection and Reporting,  Up: Top

3 Help
******

* Menu:

* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::


File: maxima.info,  Node: Lisp and Maxima,  Next: Garbage Collection,  Prev: Help,  Up: Help

3.1 Lisp and Maxima
===================

Maxima is written in Lisp, and it is easy to access Lisp functions and
variables from Maxima and vice versa.  Lisp and Maxima symbols are
distinguished by a naming convention.  A Lisp symbol which begins with
a dollar sign `$' corresponds to a Maxima symbol without the dollar
sign.  A Maxima symbol which begins with a question mark `?'
corresponds to a Lisp symbol without the question mark.  For example,
the Maxima symbol `foo' corresponds to the Lisp symbol `$foo', while
the Maxima symbol `?foo' corresponds to the Lisp symbol `foo', Note
that `?foo' is written without a space between `?' and `foo'; otherwise
it might be mistaken for `describe ("foo")'.

   Hyphen `-', asterisk `*', or other special characters in Lisp symbols
must be escaped by backslash `\' where they appear in Maxima code.  For
example, the Lisp identifier `*foo-bar*' is written `?\*foo\-bar\*' in
Maxima.

   Lisp code may be executed from within a Maxima session.  A single
line of Lisp (containing one or more forms) may be executed by the
special command `:lisp'. For example,

     (%i1) :lisp (foo $x $y)

calls the Lisp function `foo' with Maxima variables `x' and `y' as
arguments.  The `:lisp' construct can appear at the interactive prompt
or in a file processed by `batch' or `demo', but not in a file
processed by `load', `batchload', `translate_file', or `compile_file'.

   The function `to_lisp()' opens an interactive Lisp session.
Entering `(to-maxima)' closes the Lisp session and returns to Maxima.

   Lisp functions and variables which are to be visible in Maxima as
functions and variables with ordinary names (no special punctuation)
must have Lisp names beginning with the dollar sign `$'.

   Maxima is case-sensitive, distinguishing between lowercase and
uppercase letters in identifiers, while Lisp is not.  There are some
rules governing the translation of names between Lisp and Maxima.

  1. A Lisp identifier not enclosed in vertical bars corresponds to a
     Maxima identifier in lowercase.  Whether the Lisp identifier is
     uppercase, lowercase, or mixed case, is ignored.  E.g., Lisp
     `$foo', `$FOO', and `$Foo' all correspond to Maxima `foo'.

  2. A Lisp identifier which is all uppercase or all lowercase and
     enclosed in vertical bars corresponds to a Maxima identifier with
     case reversed.  That is, uppercase is changed to lowercase and
     lowercase to uppercase.  E.g., Lisp `|$FOO|' and `|$foo|'
     correspond to Maxima `foo' and `FOO', respectively.

  3. A Lisp identifier which is mixed uppercase and lowercase and
     enclosed in vertical bars corresponds to a Maxima identifier with
     the same case.  E.g., Lisp `|$Foo|' corresponds to Maxima `Foo'.

   The `#$' Lisp macro allows the use of Maxima expressions in Lisp
code.  `#$<expr>$' expands to a Lisp expression equivalent to the
Maxima expression <expr>.

     (msetq $foo #$[x, y]$)

This has the same effect as entering

     (%i1) foo: [x, y];

The Lisp function `displa' prints an expression in Maxima format.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Functions defined in Maxima are not ordinary Lisp functions.  The
Lisp function `mfuncall' calls a Maxima function.  For example:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Some Lisp functions are shadowed in the Maxima package, namely the
following.

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', and `gcd'.


File: maxima.info,  Node: Garbage Collection,  Next: Documentation,  Prev: Lisp and Maxima,  Up: Help

3.2 Garbage Collection
======================

Symbolic computation tends to create a good deal of garbage, and
effective handling of this can be crucial to successful completion of
some programs.

   Under GCL, on UNIX systems where the mprotect system call is
available (including SUN OS 4.0 and some variants of BSD) a stratified
garbage collection is available.   This limits the collection to pages
which have been recently written to.    See the GCL documentation under
ALLOCATE and GBC.   At the Lisp level doing (setq si::*notify-gbc* t)
will help you determine which areas might need more space.


File: maxima.info,  Node: Documentation,  Next: Definitions for Help,  Prev: Garbage Collection,  Up: Help

3.3 Documentation
=================

The Maxima on-line user's manual can be viewed in different forms.
From the Maxima interactive prompt, the user's manual is viewed as
plain text by the `?' command (i.e., the `describe' function).  The
user's manual is viewed as `info' hypertext by the `info' viewer program
and as a web page by any ordinary web browser.

   `example' displays examples for many Maxima functions.  For example,

     (%i1) example (integrate);

   yields

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   and additional output.


File: maxima.info,  Node: Definitions for Help,  Prev: Documentation,  Up: Help

3.4 Definitions for Help
========================

 -- Function: demo (<filename>)
     Evaluates Maxima expressions in <filename> and displays the
     results.  `demo' pauses after evaluating each expression and
     continues after the user enters a carriage return.  (If running in
     Xmaxima, `demo' may need to see a semicolon `;' followed by a
     carriage return.)

     `demo' searches the list of directories `file_search_demo' to find
     `filename'.  If the file has the suffix `dem', the suffix may be
     omitted.  See also `file_search'.

     `demo' evaluates its argument.  `demo' returns the name of the
     demonstration file.

     Example:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)


 -- Function: describe (<string>)
 -- Function: describe (<string>, exact)
 -- Function: describe (<string>, inexact)
     `describe(<string>)' is equivalent to `describe(<string>, exact)'.

     `describe(<string>, exact)' finds an item with title equal
     (case-insensitive) to <string>, if there is any such item.

     `describe(<string>, inexact)' finds all documented items which
     contain <string> in their titles.  If there is more than one such
     item, Maxima asks the user to select an item or items to display.

     At the interactive prompt, `? foo' (with a space between `?' and
     `foo') is equivalent to `describe("foo", exact)', and `?? foo' is
     equivalent to `describe("foo", inexact)'.

     `describe("", inexact)' yields a list of all topics documented in
     the on-line manual.

     `describe' quotes its argument.  `describe' returns `true' if some
     documentation is found, otherwise `false'.

     See also *Note Documentation::.

     Example:

          (%i1) ?? integ
           0: (maxima.info)Introduction to Elliptic Functions and Integrals.
           1: Definitions for Elliptic Integrals.
           2: Integration.
           3: Introduction to Integration.
           4: Definitions for Integration.
           5: askinteger :Definitions for Simplification.
           6: integerp :Definitions for Miscellaneous Options.
           7: integrate :Definitions for Integration.
           8: integrate_use_rootsof :Definitions for Integration.
           9: integration_constant_counter :Definitions for Integration.
          Enter space-separated numbers, `all' or `none': 7 8

          Info from file /use/local/maxima/doc/info/maxima.info:
           - Function: integrate (expr, var)
           - Function: integrate (expr, var, a, b)
               Attempts to symbolically compute the integral of `expr' with
               respect to `var'.  `integrate (expr, var)' is an indefinite
               integral, while `integrate (expr, var, a, b)' is a definite
               integral, [...]

     In this example, items 7 and 8 were selected.  All or none of the
     items could have been selected by entering `all' or `none', which
     can be abbreviated `a' or `n', respectively.


 -- Function: example (<topic>)
 -- Function: example ()
     `example (<topic>)' displays some examples of <topic>, which is a
     symbol (not a string).  Most topics are function names.  `example
     ()' returns the list of all recognized topics.

     The name of the file containing the examples is given by the
     global variable `manual_demo', which defaults to `"manual.demo"'.

     `example' quotes its argument.  `example' returns `done' unless
     there is an error or there is no argument, in which case `example'
     returns the list of all recognized topics.

     Examples:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Command Line,  Next: Operators,  Prev: Help,  Up: Top

4 Command Line
**************

* Menu:

* Introduction to Command Line::
* Definitions for Command Line::


File: maxima.info,  Node: Introduction to Command Line,  Next: Definitions for Command Line,  Prev: Command Line,  Up: Command Line

4.1 Introduction to Command Line
================================

 -- Operator: '
     The single quote operator `'' prevents evaluation.

     Applied to a symbol, the single quote prevents evaluation of the
     symbol.

     Applied to a function call, the single quote prevents evaluation
     of the function call, although the arguments of the function are
     still evaluated (if evaluation is not otherwise prevented).  The
     result is the noun form of the function call.

     Applied to a parenthesized expression, the single quote prevents
     evaluation of all symbols and function calls in the expression.
     E.g., `'(f(x))' means do not evaluate the expression `f(x)'.
     `'f(x)' (with the single quote applied to `f' instead of `f(x)')
     means return the noun form of `f' applied to `[x]'.

     The single quote does not prevent simplification.

     When the global flag `noundisp' is `true', nouns display with a
     single quote.  This switch is always `true' when displaying
     function definitions.

     See also the quote-quote operator `''' and `nouns'.

     Examples:

     Applied to a symbol, the single quote prevents evaluation of the
     symbol.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Applied to a function call, the single quote prevents evaluation
     of the function call.  The result is the noun form of the function
     call.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Applied to a parenthesized expression, the single quote prevents
     evaluation of all symbols and function calls in the expression.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     The single quote does not prevent simplification.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operator: "
     The quote-quote operator `''' (two single quote marks) modifies
     evaluation in input expressions.

     Applied to a general expression <expr>, quote-quote causes the
     value of <expr> to be substituted for <expr> in the input
     expression.

     Applied to the operator of an expression, quote-quote changes the
     operator from a noun to a verb (if it is not already a verb).

     The quote-quote operator is applied by the input parser; it is not
     stored as part of a parsed input expression.  The quote-quote
     operator is always applied as soon as it is parsed, and cannot be
     quoted.  Thus quote-quote causes evaluation when evaluation is
     otherwise suppressed, such as in function definitions, lambda
     expressions, and expressions quoted by single quote `''.

     Quote-quote is recognized by `batch' and `load'.

     See also the single-quote operator `'' and `nouns'.

     Examples:

     Applied to a general expression <expr>, quote-quote causes the
     value of <expr> to be substituted for <expr> in the input
     expression.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Applied to the operator of an expression, quote-quote changes the
     operator from a noun to a verb (if it is not already a verb).

          (%i1) sin (1);
          (%o1)                        sin(1)
          (%i2) ''sin (1);
          (%o2)                    0.8414709848079
          (%i3) declare (foo, noun);
          (%o3)                         done
          (%i4) foo (x) := x - 1729;
          (%o4)                 ''foo(x) := x - 1729
          (%i5) foo (100);
          (%o5)                       foo(100)
          (%i6) ''foo (100);
          (%o6)                        - 1629

     The quote-quote operator is applied by the input parser; it is not
     stored as part of a parsed input expression.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     Quote-quote causes evaluation when evaluation is otherwise
     suppressed, such as in function definitions, lambda expressions,
     and expressions quoted by single quote `''.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1



File: maxima.info,  Node: Definitions for Command Line,  Prev: Introduction to Command Line,  Up: Command Line

4.2 Definitions for Command Line
================================

 -- Function: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provides an alternate name for a (user or system) function,
     variable, array, etc.  Any even number of arguments may be used.


 -- Option variable: debugmode
     Default value: `false'

     When a Maxima error occurs, Maxima will start the debugger if
     `debugmode' is `true'.  The user may enter commands to examine the
     call stack, set breakpoints, step through Maxima code, and so on.
     See `debugging' for a list of debugger commands.

     Enabling `debugmode' will not catch Lisp errors.


 -- Function: ev (<expr>, <arg_1>, ..., <arg_n>)
     Evaluates the expression <expr> in the environment specified by
     the arguments <arg_1>, ..., <arg_n>.  The arguments are switches
     (Boolean flags), assignments, equations, and functions.  `ev'
     returns the result (another expression) of the evaluation.

     The evaluation is carried out in steps, as follows.

       1. First the environment is set up by scanning the arguments
          which may be any or all of the following.

             * `simp' causes <expr> to be simplified regardless of the
               setting of the switch `simp' which inhibits
               simplification if `false'.

             * `noeval' supresses the evaluation phase of `ev' (see
               step (4) below).  This is useful in conjunction with the
               other switches and in causing <expr> to be resimplified
               without being reevaluated.

             * `nouns' causes the evaluation of noun forms (typically
               unevaluated functions such as `'integrate' or `'diff')
               in <expr>.

             * `expand' causes expansion.

             * `expand (<m>, <n>)' causes expansion, setting the values
               of `maxposex' and `maxnegex' to <m> and <n> respectively.

             * `detout' causes any matrix inverses computed in <expr>
               to have their determinant kept outside of the inverse
               rather than dividing through each element.

             * `diff' causes all differentiations indicated in <expr>
               to be performed.

             * `derivlist (<x>, <y>, <z>, ...)' causes only
               differentiations with respect to the indicated variables.

             * `float' causes non-integral rational numbers to be
               converted to floating point.

             * `numer' causes some mathematical functions (including
               exponentiation) with numerical arguments to be evaluated
               in floating point.  It causes variables in <expr> which
               have been given numervals to be replaced by their
               values.  It also sets the `float' switch on.

             * `pred' causes predicates (expressions which evaluate to
               `true' or `false') to be evaluated.

             * `eval' causes an extra post-evaluation of <expr> to
               occur. (See step (5) below.)  `eval' may occur multiple
               times.  For each instance of `eval', the expression is
               evaluated again.

             * `A' where `A' is an atom declared to be an evaluation
               flag (see `evflag') causes `A' to be bound to `true'
               during the evaluation of <expr>.

             * `V: expression' (or alternately `V=expression') causes
               `V' to be bound to the value of `expression' during the
               evaluation of <expr>.  Note that if `V' is a Maxima
               option, then `expression' is used for its value during
               the evaluation of <expr>.  If more than one argument to
               `ev' is of this type then the binding is done in
               parallel.  If `V' is a non-atomic expression then a
               substitution rather than a binding is performed.

             * `F' where `F', a function name, has been declared to be
               an evaluation function (see `evfun') causes `F' to be
               applied to <expr>.

             * Any other function names (e.g., `sum') cause evaluation
               of occurrences of those names in <expr> as though they
               were verbs.

             * In addition a function occurring in <expr> (say `F(x)')
               may be defined locally for the purpose of this
               evaluation of <expr> by giving `F(x) := expression' as
               an argument to `ev'.

             * If an atom not mentioned above or a subscripted variable
               or subscripted expression was given as an argument, it
               is evaluated and if the result is an equation or
               assignment then the indicated binding or substitution is
               performed.  If the result is a list then the members of
               the list are treated as if they were additional arguments
               given to `ev'. This permits a list of equations to be
               given (e.g. `[X=1, Y=A**2]') or a list of names of
               equations (e.g., `[%t1, %t2]' where `%t1' and `%t2' are
               equations) such as that returned by `solve'.

          The arguments of `ev' may be given in any order with the
          exception of substitution equations which are handled in
          sequence, left to right, and evaluation functions which are
          composed, e.g., `ev (<expr>, ratsimp, realpart)' is handled
          as `realpart (ratsimp (<expr>))'.

          The `simp', `numer', `float', and `pred' switches may also be
          set locally in a block, or globally in Maxima so that they
          will remain in effect until being reset.

          If <expr> is a canonical rational expression (CRE), then the
          expression returned by `ev' is also a CRE, provided the
          `numer' and `float' switches are not both `true'.

       2. During step (1), a list is made of the non-subscripted
          variables appearing on the left side of equations in the
          arguments or in the value of some arguments if the value is
          an equation.  The variables (subscripted variables which do
          not have associated array functions as well as
          non-subscripted variables) in the expression <expr> are
          replaced by their global values, except for those appearing
          in this list.  Usually, <expr> is just a label or `%' (as in
          `%i2' in the example below), so this step simply retrieves
          the expression named by the label, so that `ev' may work on
          it.

       3. If any substitutions are indicated by the arguments, they are
          carried out now.

       4. The resulting expression is then re-evaluated (unless one of
          the arguments was `noeval') and simplified according to the
          arguments.  Note that any function calls in <expr> will be
          carried out after the variables in it are evaluated and that
          `ev(F(x))' thus may behave like `F(ev(x))'.

       5. For each instance of `eval' in the arguments, steps (3) and
          (4) are repeated.

     Examples

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     An alternate top level syntax has been provided for `ev', whereby
     one may just type in its arguments, without the `ev()'.  That is,
     one may write simply

          <expr>, <arg_1>, ..., <arg_n>

     This is not permitted as part of another expression, e.g., in
     functions, blocks, etc.

     Notice the parallel binding process in the following example.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Property: evflag
     When a symbol <x> has the `evflag' property, the expressions
     `ev(<expr>, <x>)' and `<expr>, <x>' (at the interactive prompt)
     are equivalent to `ev(<expr>, <x> = true)'.  That is, <x> is bound
     to `true' while <expr> is evaluated.

     The expression `declare(<x>, evflag)' gives the `evflag' property
     to the variable <x>.

     The flags which have the `evflag' property by default are the
     following: `algebraic', `cauchysum', `demoivre', `dotscrules',
     `%emode', `%enumer', `exponentialize', `exptisolate', `factorflag',
     `float', `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', and `trigexpand'.

     Examples:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES


 -- Property: evfun
     When a function <F> has the `evfun' property, the expressions
     `ev(<expr>, <F>)' and `<expr>, <F>' (at the interactive prompt)
     are equivalent to `<F>(ev(<expr>))'.

     If two or more `evfun' functions <F>, <G>, etc., are specified,
     the functions are applied in the order that they are specified.

     The expression `declare(<F>, evfun)' gives the `evfun' property to
     the function <F>.

     The functions which have the `evfun' property by default are the
     following: `bfloat', `factor', `fullratsimp', `logcontract',
     `polarform', `radcan', `ratexpand', `ratsimp', `rectform',
     `rootscontract', `trigexpand', and `trigreduce'.

     Examples:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))


 -- Option variable: infeval
     Enables "infinite evaluation" mode.  `ev' repeatedly evaluates an
     expression until it stops changing.  To prevent a variable, say
     `X', from being evaluated away in this mode, simply include `X='X'
     as an argument to `ev'.  Of course expressions such as `ev (X,
     X=X+1, infeval)' will generate an infinite loop.


 -- Function: kill (<a_1>, ..., <a_n>)
 -- Function: kill (labels)
 -- Function: kill (inlabels, outlabels, linelabels)
 -- Function: kill (<n>)
 -- Function: kill ([<m>, <n>])
 -- Function: kill (values, functions, arrays, ...)
 -- Function: kill (all)
 -- Function: kill (allbut (<a_1>, ..., <a_n>))
     Removes all bindings (value, function, array, or rule) from the
     arguments <a_1>, ..., <a_n>.  An argument <a_k> may be a symbol or
     a single array element.  When <a_k> is a single array element,
     `kill' unbinds that element without affecting any other elements
     of the array.

     Several special arguments are recognized.  Different kinds of
     arguments may be combined, e.g., `kill (inlabels, functions,
     allbut (foo, bar))'.

     `kill (labels)' unbinds all input, output, and intermediate
     expression labels created so far.  `kill (inlabels)' unbinds only
     input labels which begin with the current value of `inchar'.
     Likewise, `kill (outlabels)' unbinds only output labels which
     begin with the current value of `outchar', and `kill (linelabels)'
     unbinds only intermediate expression labels which begin with the
     current value of `linechar'.

     `kill (<n>)', where <n> is an integer, unbinds the <n> most recent
     input and output labels.

     `kill ([<m>, <n>])' unbinds input and output labels <m> through
     <n>.

     `kill (<infolist>)', where <infolist> is any item in `infolists'
     (such as `values', `functions', or `arrays') unbinds all items in
     <infolist>.  See also `infolists'.

     `kill (all)' unbinds all items on all infolists.  `kill (all)'
     does not reset global variables to their default values; see
     `reset' on this point.

     `kill (allbut (<a_1>, ..., <a_n>))' unbinds all items on all
     infolists except for <a_1>, ..., <a_n>.  `kill (allbut
     (<infolist>))' unbinds all items except for the ones on <infolist>,
     where <infolist> is `values', `functions', `arrays', etc.

     The memory taken up by a bound property is not released until all
     symbols are unbound from it.  In particular, to release the memory
     taken up by the value of a symbol, one unbinds the output label
     which shows the bound value, as well as unbinding the symbol
     itself.

     `kill' quotes its arguments.  The quote-quote operator `'''
     defeats quotation.

     `kill (<symbol>)' unbinds all properties of <symbol>.  In
     contrast, `remvalue', `remfunction', `remarray', and `remrule'
     unbind a specific property.

     `kill' always returns `done', even if an argument has no binding.


 -- Function: labels (<symbol>)
 -- System variable: labels
     Returns the list of input, output, or intermediate expression
     labels which begin with <symbol>.  Typically <symbol> is the value
     of `inchar', `outchar', or `linechar'.  The label character may be
     given with or without a percent sign, so, for example, `i' and
     `%i' yield the same result.

     If no labels begin with <symbol>, `labels' returns an empty list.

     The function `labels' quotes its argument.  The quote-quote
     operator `''' defeats quotation.  For example, `labels (''inchar)'
     returns the input labels which begin with the current input label
     character.

     The variable `labels' is the list of input, output, and
     intermediate expression labels, including all previous labels if
     `inchar', `outchar', or `linechar' were redefined.

     By default, Maxima displays the result of each user input
     expression, giving the result an output label.  The output display
     is suppressed by terminating the input with `$' (dollar sign)
     instead of `;' (semicolon).  An output label is constructed and
     bound to the result, but not displayed, and the label may be
     referenced in the same way as displayed output labels.  See also
     `%', `%%', and `%th'.

     Intermediate expression labels can be generated by some functions.
     The flag `programmode' controls whether `solve' and some other
     functions generate intermediate expression labels instead of
     returning a list of expressions.  Some other functions, such as
     `ldisplay', always generate intermediate expression labels.

     See also `inchar', `outchar', `linechar', and `infolists'.


 -- System variable: linenum
     The line number of the current pair of input and output
     expressions.


 -- System variable: myoptions
     Default value: `[]'

     `myoptions' is the list of all options ever reset by the user,
     whether or not they get reset to their default value.


 -- Option variable: nolabels
     Default value: `false'

     When `nolabels' is `true', input and output result labels (`%i'
     and `%o', respectively) are displayed, but the labels are not
     bound to results, and the labels are not appended to the `labels'
     list.  Since labels are not bound to results, garbage collection
     can recover the memory taken up by the results.

     Otherwise input and output result labels are bound to results, and
     the labels are appended to the `labels' list.

     Intermediate expression labels (`%t') are not affected by
     `nolabels'; whether `nolabels' is `true' or `false', intermediate
     expression labels are bound and appended to the `labels' list.

     See also `batch', `load', and `labels'.


 -- Option variable: optionset
     Default value: `false'

     When `optionset' is `true', Maxima prints out a message whenever a
     Maxima option is reset.  This is useful if the user is doubtful of
     the spelling of some option and wants to make sure that the
     variable he assigned a value to was truly an option variable.


 -- Function: playback ()
 -- Function: playback (<n>)
 -- Function: playback ([<m>, <n>])
 -- Function: playback ([<m>])
 -- Function: playback (input)
 -- Function: playback (slow)
 -- Function: playback (time)
 -- Function: playback (grind)
     Displays input, output, and intermediate expressions, without
     recomputing them.  `playback' only displays the expressions bound
     to labels; any other output (such as text printed by `print' or
     `describe', or error messages) is not displayed.  See also
     `labels'.

     `playback' quotes its arguments.  The quote-quote operator `'''
     defeats quotation.  `playback' always returns `done'.

     `playback ()' (with no arguments) displays all input, output, and
     intermediate expressions generated so far.  An output expression
     is displayed even if it was suppressed by the `$' terminator when
     it was originally computed.

     `playback (<n>)' displays the most recent <n> expressions.  Each
     input, output, and intermediate expression counts as one.

     `playback ([<m>, <n>])' displays input, output, and intermediate
     expressions with numbers from <m> through <n>, inclusive.

     `playback ([<m>])' is equivalent to `playback ([<m>, <m>])'; this
     usually prints one pair of input and output expressions.

     `playback (input)' displays all input expressions generated so far.

     `playback (slow)' pauses between expressions and waits for the
     user to press `enter'.  This behavior is similar to `demo'.
     `playback (slow)' is useful in conjunction with `save' or
     `stringout' when creating a secondary-storage file in order to
     pick out useful expressions.

     `playback (time)' displays the computation time for each
     expression.

     `playback (grind)' displays input expressions in the same format
     as the `grind' function.  Output expressions are not affected by
     the `grind' option.  See `grind'.

     Arguments may be combined, e.g., `playback ([5, 10], grind, time,
     slow)'.


 -- Function: printprops (<a>, <i>)
 -- Function: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Function: printprops (all, <i>)
     Displays the property with the indicator <i> associated with the
     atom <a>. <a> may also be a list of atoms or the atom `all' in
     which case all of the atoms with the given property will be used.
     For example, `printprops ([f, g], atvalue)'.  `printprops' is for
     properties that cannot otherwise be displayed, i.e. for `atvalue',
     `atomgrad', `gradef', and `matchdeclare'.


 -- Option variable: prompt
     Default value: `_'

     `prompt' is the prompt symbol of the `demo' function, `playback
     (slow)' mode, and the Maxima break loop (as invoked by `break').


 -- Function: quit ()
     Terminates the Maxima session.  Note that the function must be
     invoked as `quit();' or `quit()$', not `quit' by itself.

     To stop a lengthy computation, type `control-C'.  The default
     action is to return to the Maxima prompt.  If `*debugger-hook*' is
     `nil', `control-C' opens the Lisp debugger.  See also `debugging'.


 -- Function: remfunction (<f_1>, ..., <f_n>)
 -- Function: remfunction (all)
     Unbinds the function definitions of the symbols <f_1>, ..., <f_n>.
     The arguments may be the names of ordinary functions (created by
     `:=' or `define') or macro functions (created by `::=').

     `remfunction (all)' unbinds all function definitions.

     `remfunction' quotes its arguments.

     `remfunction' returns a list of the symbols for which the function
     definition was unbound.  `false' is returned in place of any
     symbol for which there is no function definition.


 -- Function: reset ()
     Resets many global variables and options, and some other
     variables, to their default values.

     `reset' processes the variables on the Lisp list
     `*variable-initial-values*'.  The Lisp macro `defmvar' puts
     variables on this list (among other actions).  Many, but not all,
     global variables and options are defined by `defmvar', and some
     variables defined by `defmvar' are not global variables or options.


 -- Option variable: showtime
     Default value: `false'

     When `showtime' is `true', the computation time and elapsed time is
     printed with each output expression.

     The computation time is always recorded, so `time' and `playback'
     can display the computation time even when `showtime' is `false'.

     See also `timer'.


 -- Function: sstatus (<feature>, <package>)
     Sets the status of <feature> in <package>.  After `sstatus
     (<feature>, <package>)' is executed, `status (<feature>,
     <package>)' returns `true'.  This can be useful for package
     writers, to keep track of what features they have loaded in.


 -- Function: to_lisp ()
     Enters the Lisp system under Maxima. `(to-maxima)' returns to
     Maxima.


 -- System variable: values
     Initial value: `[]'

     `values' is a list of all bound user variables (not Maxima options
     or switches).  The list comprises symbols bound by `:' , `::', or
     `:='.



File: maxima.info,  Node: Operators,  Next: Expressions,  Prev: Command Line,  Up: Top

5 Operators
***********

* Menu:

* nary::
* nofix::
* postfix::
* prefix::
* Arithmetic operators::
* Relational operators::
* General operators::


File: maxima.info,  Node: nary,  Next: nofix,  Prev: Operators,  Up: Operators

5.1 nary
========

An `nary' operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the operator,
e.g. A+B or A+B+C.  The `nary("x")' function is a syntax extension
function to declare x to be an `nary' operator.  Functions may be
declared to be `nary'.  If `declare(j,nary);' is done, this tells the
simplifier to simplify, e.g. `j(j(a,b),j(c,d))' to `j(a, b, c, d)'.

   See also `syntax'.


File: maxima.info,  Node: nofix,  Next: postfix,  Prev: nary,  Up: Operators

5.2 nofix
=========

`nofix' operators are used to denote functions of no arguments.  The
mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a Maxima break, "exit" is behaving similar to a
`nofix' operator.  The function `nofix("x")' is a syntax extension
function which declares x to be a `nofix' operator.

   See also `syntax'.


File: maxima.info,  Node: postfix,  Next: prefix,  Prev: nofix,  Up: Operators

5.3 postfix
===========

`postfix' operators like the `prefix' variety denote functions of a
single argument, but in this case the argument immediately precedes an
occurrence of the operator in the input string, e.g. 3! .  The
`postfix("x")' function is a syntax extension function to declare x to
be a `postfix' operator.

   See also `syntax'.


File: maxima.info,  Node: prefix,  Next: Arithmetic operators,  Prev: postfix,  Up: Operators

5.4 prefix
==========

A `prefix' operator is one which signifies a function of one argument,
which argument immediately follows an occurrence of the operator.
`prefix("x")' is a syntax extension function to declare x to be a
`prefix' operator.

   See also `syntax'.


File: maxima.info,  Node: Arithmetic operators,  Next: Relational operators,  Prev: prefix,  Up: Operators

5.5 Arithmetic operators
========================

 -- Operator: +
 -- Operator: -
 -- Operator: *
 -- Operator: /
 -- Operator: ^
     The symbols `+' `*' `/' and `^' represent addition,
     multiplication, division, and exponentiation, respectively.  The
     name of these operators are `"+"' `"*"' `"//"' and `"^"', which
     may appear where the name of a function or operator is required.

     The symbols `+' and `-' represent unary addition and negation,
     respectively, and the names of these operators are `"+"' and
     `"-"', respectively.

     Subtraction `a - b' is represented within Maxima as addition, `a +
     (- b)'.  Expressions such as `a + (- b)' are displayed as
     subtraction.  Maxima recognizes `"-"' only as the name of the
     unary negation operator, and not as the name of the binary
     subtraction operator.

     Division `a / b' is represented within Maxima as multiplication,
     `a * b^(- 1)'.  Expressions such as `a * b^(- 1)' are displayed as
     division.  Maxima recognizes `"//"' as the name of the division
     operator.

     Addition and multiplication are n-ary, commutative operators.
     Division and exponentiation are binary, noncommutative operators.

     Maxima sorts the operands of commutative operators to construct a
     canonical representation.  For internal storage, the ordering is
     determined by `orderlessp'.  For display, the ordering for
     addition is determined by `ordergreatp', and for multiplication,
     it is the same as the internal ordering.

     Arithmetic computations are carried out on literal numbers
     (integers, rationals, ordinary floats, and bigfloats).  Except for
     exponentiation, all arithmetic operations on numbers are
     simplified to numbers.  Exponentiation is simplified to a number
     if either operand is an ordinary float or bigfloat or if the
     result is an exact integer or rational; otherwise an
     exponentiation may be simplified to `sqrt' or another
     exponentiation or left unchanged.

     Floating-point contagion applies to arithmetic computations: if
     any operand is a bigfloat, the result is a bigfloat; otherwise, if
     any operand is an ordinary float, the result is an ordinary float;
     otherwise, the operands are rationals or integers and the result
     is a rational or integer.

     Arithmetic computations are a simplification, not an evaluation.
     Thus arithmetic is carried out in quoted (but simplified)
     expressions.

     Arithmetic operations are applied element-by-element to lists when
     the global flag `listarith' is `true', and always applied
     element-by-element to matrices.  When one operand is a list or
     matrix and another is an operand of some other type, the other
     operand is combined with each of the elements of the list or
     matrix.

     Examples:

     Addition and multiplication are n-ary, commutative operators.
     Maxima sorts the operands to construct a canonical representation.
     The names of these operators are `"+"' and `"*"'.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Division and exponentiation are binary, noncommutative operators.
     The names of these operators are `"//"' and `"^"'.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[//, ^], [[a, b], [a, b]]]
          (%i3) [apply ("//", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Subtraction and division are represented internally in terms of
     addition and multiplication, respectively.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Computations are carried out on literal numbers.  Floating-point
     contagion applies.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Arithmetic computations are a simplification, not an evaluation.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     Arithmetic is carried out element-by-element for lists (depending
     on `listarith') and matrices.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]


 -- Operator: **
     Exponentiation operator.  Maxima recognizes `**' as the same
     operator as `^' in input, and it is displayed as `^' in
     1-dimensional output, or by placing the exponent as a superscript
     in 2-dimensional output.

     The `fortran' function displays the exponentiation operator as
     `**', whether it was input as `**' or `^'.

     Examples:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done



File: maxima.info,  Node: Relational operators,  Next: General operators,  Prev: Arithmetic operators,  Up: Operators

5.6 Relational operators
========================

 -- Operator: <
 -- Operator: <=
 -- Operator: >=
 -- Operator: >


File: maxima.info,  Node: General operators,  Prev: Relational operators,  Up: Operators

5.7 General operators
=====================

 -- Operator: ^^
     Noncommutative exponentiation operator.  `^^' is the
     exponentiation operator corresponding to noncommutative
     multiplication `.', just as the ordinary exponentiation operator
     `^' corresponds to commutative multiplication `*'.

     Noncommutative exponentiation is displayed by `^^' in
     1-dimensional output, and by placing the exponent as a superscript
     within angle brackets `< >' in 2-dimensional output.

     Examples:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3


 -- Operator: !
     The factorial operator.  For any complex number `x' (including
     integer, rational, and real numbers) except for negative integers,
     `x!' is defined as `gamma(x+1)'.

     For an integer `x', `x!' simplifies to the product of the integers
     from 1 to `x' inclusive.  `0!' simplifies to 1.  For a floating
     point number `x', `x!' simplifies to the value of `gamma (x+1)'.
     For `x' equal to `n/2' where `n' is an odd integer, `x!'
     simplifies to a rational factor times `sqrt (%pi)' (since `gamma
     (1/2)' is equal to `sqrt (%pi)').  If `x' is anything else, `x!'
     is not simplified.

     The variables `factlim', `minfactorial', and `factcomb' control
     the simplification of expressions containing factorials.

     The functions `gamma', `bffac', and `cbffac' are varieties of the
     gamma function.  `makegamma' substitutes `gamma' for factorials
     and related functions.

     See also `binomial'.

     The factorial of an integer, half-integer, or floating point
     argument is simplified unless the operand is greater than
     `factlim'.

          (%i1) factlim : 10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
                      105 sqrt(%pi)
          (%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
                           16

     The factorial of a complex number, known constant, or general
     expression is not simplified.  Even so it may be possible simplify
     the factorial after evaluating the operand.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357,
                                                         1.227580202486819]

     The factorial of an unbound symbol is not simplified.

          (%i1) kill (foo);
          (%o1)                         done
          (%i2) foo!;
          (%o2)                         foo!

     Factorials are simplified, not evaluated.  Thus `x!' may be
     replaced even in a quoted expression.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]


 -- Operator: !!
     The double factorial operator.

     For an integer, float, or rational number `n', `n!!' evaluates to
     the product `n (n-2) (n-4) (n-6) ... (n - 2 (k-1))' where `k' is
     equal to `entier (n/2)', that is, the largest integer less than or
     equal to `n/2'.  Note that this definition does not coincide with
     other published definitions for arguments which are not integers.

     For an even (or odd) integer `n', `n!!' evaluates to the product of
     all the consecutive even (or odd) integers from 2 (or 1) through
     `n' inclusive.

     For an argument `n' which is not an integer, float, or rational,
     `n!!' yields a noun form `genfact (n, n/2, 2)'.


 -- Operator: #
     Represents the negation of syntactic equality `='.

     Note that because of the rules for evaluation of predicate
     expressions (in particular because `not <expr>' causes evaluation
     of <expr>), `not <a> = <b>' is equivalent to `is(<a> # <b>)',
     instead of `<a> # <b>'.

     Examples:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true


 -- Operator: .
     The dot operator, for matrix (non-commutative) multiplication.
     When "." is used in this way, spaces should be left on both sides
     of it, e.g. A . B.  This distinguishes it plainly from a decimal
     point in a floating point number.

     See also `dot', `dot0nscsimp', `dot0simp', `dot1simp', `dotassoc',
     `dotconstrules', `dotdistrib', `dotexptsimp', `dotident', and
     `dotscrules'.


 -- Operator: :
     The assignment operator.  E.g. A:3 sets the variable A to 3.


 -- Operator: ::
     Assignment operator.  :: assigns the value of the expression on
     its right to the value of the quantity on its left, which must
     evaluate to an atomic variable or subscripted variable.


 -- Operator: ::=
     Macro function definition operator.  `::=' defines a function
     (called a "macro" for historical reasons) which quotes its
     arguments, and the expression which it returns (called the "macro
     expansion") is evaluated in the context from which the macro was
     called.  A macro function is otherwise the same as an ordinary
     function.

     `macroexpand' returns a macro expansion (without evaluating it).
     `macroexpand (foo (x))' followed by `''%' is equivalent to `foo
     (x)' when `foo' is a macro function.

     `::=' puts the name of the new macro function onto the global list
     `macros'.  `kill', `remove', and `remfunction' unbind macro
     function definitions and remove names from `macros'.

     `fundef' or `dispfun' return a macro function definition or assign
     it to a label, respectively.

     Macro functions commonly contain `buildq' and `splice' expressions
     to construct an expression, which is then evaluated.

     Examples

     A macro function quotes its arguments, so message (1) shows `y -
     z', not the value of `y - z'.  The macro expansion (the quoted
     expression `'(print ("(2) x is equal to", x))' is evaluated in the
     context from which the macro was called, printing message (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
          (%o4) printq1(x) ::= block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                          %pi

     An ordinary function evaluates is arguments, so message (1) shows
     the value of `y - z'.  The return value is not evaluated, so
     message (2) is not printed until the explicit evaluation `''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x is equal to", x), '(print ("(2) x is equal to", x)));
          (%o4) printe1(x) := block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)              print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                          %pi

     `macroexpand' returns a macro expansion.  `macroexpand (foo (x))'
     followed by `''%' is equivalent to `foo (x)' when `foo' is a macro
     function.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x));
          (%o4)    g(x) ::= buildq([x], print("x is equal to", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                     1234 - 1729 w


 -- Operator: :=
     The function definition operator.  `<f>(<x_1>, ..., <x_n>) :=
     <expr>' defines a function named <f> with arguments <x_1>, ...,
     <x_n> and function body <expr>.  `:=' never evaluates the function
     body (unless explicitly evaluated by quote-quote `''').  The
     function so defined may be an ordinary Maxima function (with
     arguments enclosed in parentheses) or an array function (with
     arguments enclosed in square brackets).

     When the last or only function argument <x_n> is a list of one
     element, the function defined by `:=' accepts a variable number of
     arguments.  Actual arguments are assigned one-to-one to formal
     arguments <x_1>, ..., <x_(n - 1)>, and any further actual
     arguments, if present, are assigned to <x_n> as a list.

     All function definitions appear in the same namespace; defining a
     function `f' within another function `g' does not limit the scope
     of `f' to `g'.

     If some formal argument <x_k> is a quoted symbol, the function
     defined by `:=' does not evaluate the corresponding actual
     argument.  Otherwise all actual arguments are evaluated.

     See also `define' and `::='.

     Examples:

     `:=' never evaluates the function body (unless explicitly
     evaluated by quote-quote).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     The function defined by `:=' may be an ordinary Maxima function or
     an array function.

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     When the last or only function argument <x_n> is a list of one
     element, the function defined by `:=' accepts a variable number of
     arguments.

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a


 -- Operator: =
     The equation operator.

     An expression `<a> = <b>', by itself, represents an unevaluated
     equation, which might or might not hold.  Unevaluated equations
     may appear as arguments to `solve' and `algsys' or some other
     functions.

     The function `is' evaluates `=' to a Boolean value.  `is(<a> =
     <b>)' evaluates `<a> = <b>' to `true' when <a> and <b> are
     identical. That is, <a> and <b> are atoms which are identical, or
     they are not atoms and their operators are identical and their
     arguments are identical.  Otherwise, `is(<a> = <b>)' evaluates to
     `false'; it never evaluates to `unknown'.  When `is(<a> = <b>)' is
     `true', <a> and <b> are said to be syntactically equal, in
     contrast to equivalent expressions, for which `is(equal(<a>,
     <b>))' is `true'.  Expressions can be equivalent and not
     syntactically equal.

     The negation of `=' is represented by `#'.  As with `=', an
     expression `<a> # <b>', by itself, is not evaluated.  `is(<a> #
     <b>)' evaluates `<a> # <b>' to `true' or `false'.

     In addition to `is', some other operators evaluate `=' and `#' to
     `true' or `false', namely `if', `and', `or', and `not'.

     Note that because of the rules for evaluation of predicate
     expressions (in particular because `not <expr>' causes evaluation
     of <expr>), `not <a> = <b>' is equivalent to `is(<a> # <b>)',
     instead of `<a> # <b>'.

     `rhs' and `lhs' return the right-hand and left-hand sides,
     respectively, of an equation or inequation.

     See also `equal' and `notequal'.

     Examples:

     An expression `<a> = <b>', by itself, represents an unevaluated
     equation, which might or might not hold.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     `is(<a> = <b>)' evaluates `<a> = <b>' to `true' when <a> and <b>
     are syntactically equal (that is, identical).  Expressions can be
     equivalent and not syntactically equal.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Some operators evaluate `=' and `#' to `true' or `false'.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Because `not <expr>' causes evaluation of <expr>, `not <a> = <b>'
     is equivalent to `is(<a> # <b>)'.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true


 -- Operator: and
     The logical conjunction operator.  `and' is an n-ary infix
     operator; its operands are Boolean expressions, and its result is
     a Boolean value.

     `and' forces evaluation (like `is') of one or more operands, and
     may force evaluation of all operands.

     Operands are evaluated in the order in which they appear.  `and'
     evaluates only as many of its operands as necessary to determine
     the result.  If any operand is `false', the result is `false' and
     no further operands are evaluated.

     The global flag `prederror' governs the behavior of `and' when an
     evaluated operand cannot be determined to be `true' or `false'.
     `and' prints an error message when `prederror' is `true'.
     Otherwise, operands which do not evaluate to `true' or `false' are
     accepted, and the result is a Boolean expression.

     `and' is not commutative: `a and b' might not be equal to `b and
     a' due to the treatment of indeterminate operands.


 -- Operator: or
     The logical disjunction operator.  `or' is an n-ary infix operator;
     its operands are Boolean expressions, and its result is a Boolean
     value.

     `or' forces evaluation (like `is') of one or more operands, and
     may force evaluation of all operands.

     Operands are evaluated in the order in which they appear.  `or'
     evaluates only as many of its operands as necessary to determine
     the result.  If any operand is `true', the result is `true' and no
     further operands are evaluated.

     The global flag `prederror' governs the behavior of `or' when an
     evaluated operand cannot be determined to be `true' or `false'.
     `or' prints an error message when `prederror' is `true'.
     Otherwise, operands which do not evaluate to `true' or `false' are
     accepted, and the result is a Boolean expression.

     `or' is not commutative: `a or b' might not be equal to `b or a'
     due to the treatment of indeterminate operands.


 -- Operator: not
     The logical negation operator.  `not' is a prefix operator; its
     operand is a Boolean expression, and its result is a Boolean value.

     `not' forces evaluation (like `is') of its operand.

     The global flag `prederror' governs the behavior of `not' when its
     operand cannot be determined to be `true' or `false'.  `not'
     prints an error message when `prederror' is `true'.  Otherwise,
     operands which do not evaluate to `true' or `false' are accepted,
     and the result is a Boolean expression.


 -- Function: abs (<expr>)
     Returns the absolute value <expr>.  If <expr> is complex, returns
     the complex modulus of <expr>.


 -- Keyword: additive
     If `declare(f,additive)' has been executed, then:

     (1) If `f' is univariate, whenever the simplifier encounters `f'
     applied to a sum, `f' will be distributed over that sum.  I.e.
     `f(y+x)' will simplify to `f(y)+f(x)'.

     (2) If `f' is a function of 2 or more arguments, additivity is
     defined as additivity in the first argument to `f', as in the case
     of `sum' or `integrate', i.e. `f(h(x)+g(x),x)' will simplify to
     `f(h(x),x)+f(g(x),x)'.  This simplification does not occur when
     `f' is applied to expressions of the form
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Keyword: allbut
     works with the `part' commands (i.e. `part', `inpart', `substpart',
     `substinpart', `dpart', and `lpart').  For example,

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     while

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     `allbut' is also recognized by `kill'.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     `kill(allbut(<a_1>, <a_2>, ...))' has the effect of `kill(all)'
     except that it does not kill the symbols <a_1>, <a_2>, ... .


 -- Declaration: antisymmetric
     If `declare(h,antisymmetric)' is done, this tells the simplifier
     that `h' is antisymmetric.  E.g. `h(x,z,y)' will simplify to `-
     h(x, y, z)'.  That is, it will give (-1)^n times the result given
     by `symmetric' or `commutative', where n is the number of
     interchanges of two arguments necessary to convert it to that form.


 -- Function: cabs (<expr>)
     Returns the complex absolute value (the complex modulus) of <expr>.


 -- Function: ceiling (<x>)
     When <x> is a real number, return the least integer that is
     greater than or equal to <x>.

     If <x> is a constant expression (`10 * %pi', for example),
     `ceiling' evaluates <x> using big floating point numbers, and
     applies `ceiling' to the resulting big float. Because `ceiling'
     uses floating point evaluation, it's possible, although unlikely,
     that `ceiling' could return an erroneous value for constant
     inputs. To guard against errors, the floating point evaluation is
     done using three values for `fpprec'.

     For non-constant inputs, `ceiling' tries to return a simplified
     value.  Here are examples of the simplifications that `ceiling'
     knows about:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     The function `ceiling' does not automatically map over lists or
     matrices.  Finally, for all inputs that are manifestly complex,
     `ceiling' returns a noun form.

     If the range of a function is a subset of the integers, it can be
     declared to be `integervalued'. Both the `ceiling' and `floor'
     functions can use this information; for example:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Function: charfun (<p>)
     Return 0 when the predicate <p> evaluates to `false'; return 1
     when the predicate evaluates to `true'.  When the predicate
     evaluates to something other than `true' or `false' (unknown),
     return a noun form.

     Examples:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]


 -- Declaration: commutative
     If `declare(h,commutative)' is done, this tells the simplifier
     that `h' is a commutative function.  E.g. `h(x,z,y)' will simplify
     to `h(x, y, z)'.  This is the same as `symmetric'.


 -- Function: compare (<x>, <y>)
     Return a comparison operator <op> (`<', `<=', `>', `>=', `=', or
     `#') such that `is (<x> <op> <y>)' evaluates to true; when either
     <x> or <y> depends on `%i' and `<x> # <y>', return `notcomparable';
     when there is no such operator or Maxima isn't able to determine
     the operator, return `unknown'.

     Examples:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     The function `compare' doesn't try to determine whether the real
     domains of its arguments are nonempty; thus

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

     The real domain of `acos (x^2 + 1)' is empty.


 -- Function: entier (<x>)
     Returns the largest integer less than or equal to <x> where <x> is
     numeric.  `fix' (as in `fixnum') is a synonym for this, so
     `fix(<x>)' is precisely the same.


 -- Function: equal (<a>, <b>)
     Represents equivalence, that is, equal value.

     By itself, `equal' does not evaluate or simplify.  The function
     `is' attempts to evaluate `equal' to a Boolean value.
     `is(equal(<a>, <b>))' returns `true' (or `false') if and only if
     <a> and <b> are equal (or not equal) for all possible values of
     their variables, as determined by evaluating `ratsimp(<a> - <b>)';
     if `ratsimp' returns 0, the two expressions are considered
     equivalent.  Two expressions may be equivalent even if they are
     not syntactically equal (i.e., identical).

     When `is' fails to reduce `equal' to `true' or `false', the result
     is governed by the global flag `prederror'.  When `prederror' is
     `true', `is' complains with an error message.  Otherwise, `is'
     returns `unknown'.

     In addition to `is', some other operators evaluate `equal' and
     `notequal' to `true' or `false', namely `if', `and', `or', and
     `not'.

     The negation of `equal' is `notequal'.

     Examples:

     By itself, `equal' does not evaluate or simplify.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     The function `is' attempts to evaluate `equal' to a Boolean value.
     `is(equal(<a>, <b>))' returns `true' when `ratsimp(<a> - <b>)'
     returns 0.  Two expressions may be equivalent even if they are not
     syntactically equal (i.e., identical).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     When `is' fails to reduce `equal' to `true' or `false', the result
     is governed by the global flag `prederror'.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Some operators evaluate `equal' and `notequal' to `true' or
     `false'.

          (%i4) if equal (y, y - 1) then FOO else BAR;
          (%o4)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Because `not <expr>' causes evaluation of <expr>, `not equal(<a>,
     <b>)' is equivalent to `is(notequal(<a>, <b>))'.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true


 -- Function: floor (<x>)
     When <x> is a real number, return the largest integer that is less
     than or equal to <x>.

     If <x> is a constant expression (`10 * %pi', for example), `floor'
     evaluates <x> using big floating point numbers, and applies floor
     to the resulting big float. Because floor uses floating point
     evaluation, it's possible, although unlikely, that `floor' could
     return  an erroneous value for constant inputs.  To guard against
     errors, the floating point evaluation is done using three values
     for `fpprec'.

     For non-constant inputs, `floor' tries to return a simplified
     value.  Here are examples of the simplifications that `floor'
     knows about:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     The function `floor' does not automatically map over lists or
     matrices.  Finally, for all inputs that are manifestly complex,
     `floor' returns a noun form.

     If the range of a function is a subset of the integers, it can be
     declared to be `integervalued'. Both the `ceiling' and `floor'
     functions can use this information; for example:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1


 -- Function: notequal (<a>, <b>)
     Represents the negation of `equal(<a>, <b>)'.

     Examples:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true


 -- Operator: eval
     As an argument in a call to `ev (<expr>)', `eval' causes an extra
     evaluation of <expr>.  See `ev'.


 -- Function: evenp (<expr>)
     Returns `true' if <expr> is an even integer.  `false' is returned
     in all other cases.


 -- Function: fix (<x>)
     A synonym for `entier (<x>)'.


 -- Function: fullmap (<f>, <expr_1>, ...)
     Similar to `map', but `fullmap' keeps mapping down all
     subexpressions until the main operators are no longer the same.

     `fullmap' is used by the Maxima simplifier for certain matrix
     manipulations; thus, Maxima sometimes generates an error message
     concerning `fullmap' even though `fullmap' was not explicitly
     called by the user.

     Examples:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Function: fullmapl (<f>, <list_1>, ...)
     Similar to `fullmap', but `fullmapl' only maps onto lists and
     matrices.

     Example:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Function: is (<expr>)
     Attempts to determine whether the predicate <expr> is provable
     from the facts in the `assume' database.

     If the predicate is provably `true' or `false', `is' returns
     `true' or `false', respectively.  Otherwise, the return value is
     governed by the global flag `prederror'.  When `prederror' is
     `true', `is' complains with an error message.  Otherwise, `is'
     returns `unknown'.

     `ev(<expr>, pred)' (which can be written  `<expr>, pred' at the
     interactive prompt) is equivalent to `is(<expr>)'.

     See also `assume', `facts', and `maybe'.

     Examples:

     `is' causes evaluation of predicates.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' attempts to derive predicates from the `assume' database.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     If `is' can neither prove nor disprove a predicate from the
     `assume' database, the global flag `prederror' governs the
     behavior of `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown


 -- Function: maybe (<expr>)
     Attempts to determine whether the predicate <expr> is provable
     from the facts in the `assume' database.

     If the predicate is provably `true' or `false', `maybe' returns
     `true' or `false', respectively.  Otherwise, `maybe' returns
     `unknown'.

     `maybe' is functionally equivalent to `is' with `prederror: false',
     but the result is computed without actually assigning a value to
     `prederror'.

     See also `assume', `facts', and `is'.

     Examples:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Function: isqrt (<x>)
     Returns the "integer square root" of the absolute value of <x>,
     which is an integer.


 -- Function: lmax (<L>)
     When <L> is a list or a set, return `apply ('max, args (<L>))'.
     When <L> isn't a list or a set, signal an error.


 -- Function: lmin (<L>)
     When <L> is a list or a set, return `apply ('min, args (<L>))'.
     When <L> isn't a list or a set, signal an error.


 -- Function: max (<x_1>, ..., <x_n>)
     Return a simplified value for the maximum of the expressions <x_1>
     through <x_n>.  When `get (trylevel, maxmin)', is 2 or greater,
     `max' uses the simplification `max (e, -e) --> |e|'.  When `get
     (trylevel, maxmin)' is 3 or greater, <max> tries to eliminate
     expressions that are between two other arguments; for example,
     `max (x, 2*x, 3*x) --> max (x, 3*x)'. To set the value of
     `trylevel' to 2, use `put (trylevel, 2, maxmin)'.


 -- Function: min (<x_1>, ..., <x_n>)
     Return a simplified value for the minimum of the expressions `x_1'
     through `x_n'.  When `get (trylevel, maxmin)', is 2 or greater,
     `min' uses the simplification `min (e, -e) --> -|e|'.  When `get
     (trylevel, maxmin)' is 3 or greater, `min' tries to eliminate
     expressions that are between two other arguments; for example,
     `min (x, 2*x, 3*x) --> min (x, 3*x)'. To set the value of
     `trylevel' to 2, use `put (trylevel, 2, maxmin)'.


 -- Function: polymod (<p>)
 -- Function: polymod (<p>, <m>)
     Converts the polynomial <p> to a modular representation with
     respect to the current modulus which is the value of the variable
     `modulus'.

     `polymod (<p>, <m>)' specifies a modulus <m> to be used instead of
     the current value of `modulus'.

     See `modulus'.


 -- Function: mod (<x>, <y>)
     If <x> and <y> are real numbers and <y> is nonzero, return `<x> -
     <y> * floor(<x> / <y>)'.  Further for all real <x>, we have `mod
     (<x>, 0) = <x>'. For a discussion of the definition `mod (<x>, 0)
     = <x>', see Section 3.4, of "Concrete Mathematics," by Graham,
     Knuth, and Patashnik. The function `mod (<x>, 1)' is a sawtooth
     function with period 1 with `mod (1, 1) = 0' and `mod (0, 1) = 0'.

     To find the principal argument (a number in the interval `(-%pi,
     %pi]') of a complex number, use the function `<x> |-> %pi - mod
     (%pi - <x>, 2*%pi)', where <x> is an argument.

     When <x> and <y> are constant expressions (`10 * %pi', for
     example), `mod' uses the same big float evaluation scheme that
     `floor' and `ceiling' uses.  Again, it's possible, although
     unlikely, that `mod' could return an erroneous value in such cases.

     For nonnumerical arguments <x> or <y>, `mod' knows several
     simplification rules:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0


 -- Function: oddp (<expr>)
     is `true' if <expr> is an odd integer.  `false' is returned in all
     other cases.


 -- Operator: pred
     As an argument in a call to `ev (<expr>)', `pred' causes
     predicates (expressions which evaluate to `true' or `false') to be
     evaluated.  See `ev'.


 -- Function: make_random_state (<n>)
 -- Function: make_random_state (<s>)
 -- Function: make_random_state (true)
 -- Function: make_random_state (false)
     A random state object represents the state of the random number
     generator.  The state comprises 627 32-bit words.

     `make_random_state (<n>)' returns a new random state object
     created from an integer seed value equal to <n> modulo 2^32.  <n>
     may be negative.

     `make_random_state (<s>)' returns a copy of the random state <s>.

     `make_random_state (true)' returns a new random state object,
     using the current computer clock time as the seed.

     `make_random_state (false)' returns a copy of the current state of
     the random number generator.


 -- Function: set_random_state (<s>)
     Copies <s> to the random number generator state.

     `set_random_state' always returns `done'.


 -- Function: random (<x>)
     Returns a pseudorandom number. If <x> is an integer, `random
     (<x>)' returns an integer from 0 through `<x> - 1' inclusive. If
     <x> is a floating point number, `random (<x>)' returns a
     nonnegative floating point number less than <x>.  `random'
     complains with an error if <x> is neither an integer nor a float,
     or if <x> is not positive.

     The functions `make_random_state' and `set_random_state' maintain
     the state of the random number generator.

     The Maxima random number generator is an implementation of the
     Mersenne twister MT 19937.

     Examples:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Function: rationalize (<expr>)
     Convert all double floats and big floats in the Maxima expression
     <expr> to their exact rational equivalents. If you are not
     familiar with the binary representation of floating point numbers,
     you might be surprised that `rationalize (0.1)' does not equal
     1/10.  This behavior isn't special to Maxima - the number 1/10 has
     a repeating, not a terminating, binary representation.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     Example use:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf));
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then error("The input to 'unitfrac' must be a rational number"
                                               1
          ), while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                   1
                                           ceiling(-)
                                                   r
          reverse(uf))
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37


 -- Function: sign (<expr>)
     Attempts to determine the sign of <expr> on the basis of the facts
     in the current data base.  It returns one of the following
     answers: `pos' (positive), `neg' (negative), `zero', `pz'
     (positive or zero), `nz' (negative or zero), `pn' (positive or
     negative), or `pnz' (positive, negative, or zero, i.e. nothing
     known).


 -- Function: signum (<x>)
     For numeric <x>, returns 0 if <x> is 0, otherwise returns -1 or +1
     as <x> is less than or greater than 0, respectively.

     If <x> is not numeric then a simplified but equivalent form is
     returned.  For example, `signum(-x)' gives `-signum(x)'.


 -- Function: sort (<L>, <P>)
 -- Function: sort (<L>)
     Sorts a list <L> according to a predicate `P' of two arguments,
     such that `<P> (<L>[k], <L>[k + 1])' is `true' for any two
     successive elements.  The predicate may be specified as the name
     of a function or binary infix operator, or as a `lambda'
     expression.  If specified as the name of an operator, the name is
     enclosed in "double quotes".

     The sorted list is returned as a new object; the argument <L> is
     not modified.  To construct the return value, `sort' makes a
     shallow copy of the elements of <L>.

     If the predicate <P> is not a total order on the elements of <L>,
     then `sort' might run to completion without error, but the result
     is undefined.  `sort' complains if the predicate evaluates to
     something other than `true' or `false'.

     `sort (<L>)' is equivalent to `sort (<L>, orderlessp)'.  That is,
     the default sorting order is ascending, as determined by
     `orderlessp'.  All Maxima atoms and expressions are comparable
     under `orderlessp', although there are isolated examples of
     expressions for which `orderlessp' is not transitive; this is a
     bug.

     Examples:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c, 19 - 3 * x], ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list : [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a), reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]


 -- Function: sqrt (<x>)
     The square root of <x>. It is represented internally by
     `<x>^(1/2)'.  See also `rootscontract'.

     `radexpand' if `true' will cause nth roots of factors of a product
     which are powers of n to be pulled outside of the radical, e.g.
     `sqrt(16*x^2)' will become `4*x' only if `radexpand' is `true'.


 -- Option variable: sqrtdispflag
     Default value: `true'

     When `sqrtdispflag' is `false', causes `sqrt' to display with
     exponent 1/2.


 -- Function: sublis (<list>, <expr>)
     Makes multiple parallel substitutions into an expression.

     The variable `sublis_apply_lambda' controls simplification after
     `sublis'.

     Example:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)


 -- Function: sublist (<list>, <p>)
     Returns the list of elements of <list> for which the predicate `p'
     returns `true'.

     Example:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Option variable: sublis_apply_lambda
     Default value: `true' - controls whether `lambda''s substituted
     are applied in simplification after `sublis' is used or whether
     you have to do an `ev' to get things to apply. `true' means do the
     application.


 -- Function: subst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <b> must be an atom or a complete
     subexpression of <c>.  For example, `x+y+z' is a complete
     subexpression of `2*(x+y+z)/w' while `x+y' is not. When <b> does
     not have these characteristics, one may sometimes use `substpart'
     or `ratsubst' (see below).  Alternatively, if <b> is of the form
     `e/f' then one could use `subst (a*f, e, c)' while if <b> is of
     the form `e^(1/f)' then one could use `subst (a^f, e, c)'.  The
     `subst' command also discerns the `x^y' in `x^-y' so that `subst
     (a, sqrt(x), 1/sqrt(x))' yields `1/a'.  <a> and <b> may also be
     operators of an expression enclosed in double-quotes `"' or they
     may be function names.  If one wishes to substitute for the
     independent variable in derivative forms then the `at' function
     (see below) should be used.

     `subst' is an alias for `substitute'.

     `subst (<eq_1>, <expr>)' or `subst ([<eq_1>, ..., <eq_k>], <expr>)'
     are other permissible forms.  The <eq_i> are equations indicating
     substitutions to be made.  For each equation, the right side will
     be substituted for the left in the expression <expr>.

     `exptsubst' if `true' permits substitutions like `y' for `%e^x' in
     `%e^(a*x)' to take place.

     When `opsubst' is `false', `subst' will not attempt to substitute
     into the operator of an expression.  E.g. `(opsubst: false, subst
     (x^2, r, r+r[0]))' will work.

     Examples:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     For further examples, do `example (subst)'.


 -- Function: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Similar to `substpart', but `substinpart' works on the internal
     representation of <expr>.

     Examples:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     If the last argument to a part function is a list of indices then
     several subexpressions are picked out, each one corresponding to an
     index of the list.  Thus

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     `piece' holds the value of the last expression selected when using
     the part functions.  It is set during the execution of the
     function and thus may be referred to in the function itself as
     shown below.  If `partswitch' is set to `true' then `end' is
     returned when a selected part of an expression doesn't exist,
     otherwise an error message is given.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Also, setting the option `inflag' to `true' and calling `part' or
     `substpart' is the same as calling `inpart' or `substinpart'.


 -- Function: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substitutes <x> for the subexpression picked out by the rest of
     the arguments as in `part'.  It returns the new value of <expr>.
     <x> may be some operator to be substituted for an operator of
     <expr>.  In some cases <x> needs to be enclosed in double-quotes
     `"' (e.g.  `substpart ("+", a*b, 0)' yields `b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f(b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Also, setting the option `inflag' to `true' and calling `part' or
     `substpart' is the same as calling `inpart' or `substinpart'.


 -- Function: subvarp (<expr>)
     Returns `true' if <expr> is a subscripted variable, for example
     `a[i]'.


 -- Function: symbolp (<expr>)
     Returns `true' if <expr> is a symbol, else `false'.  In effect,
     `symbolp(x)' is equivalent to the predicate `atom(x) and not
     numberp(x)'.

     See also *Note Identifiers::.


 -- Function: unorder ()
     Disables the aliasing created by the last use of the ordering
     commands `ordergreat' and `orderless'. `ordergreat' and
     `orderless' may not be used more than one time each without
     calling `unorder'.  See also `ordergreat' and `orderless'.

     Examples:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a


 -- Function: vectorpotential (<givencurl>)
     Returns the vector potential of a given curl vector, in the
     current coordinate system.  `potentialzeroloc' has a similar role
     as for `potential', but the order of the left-hand sides of the
     equations must be a cyclic permutation of the coordinate variables.


 -- Function: xthru (<expr>)
     Combines all terms of <expr> (which should be a sum) over a common
     denominator without expanding products and exponentiated sums as
     `ratsimp' does.  `xthru' cancels common factors in the numerator
     and denominator of rational expressions but only if the factors are
     explicit.

     Sometimes it is better to use `xthru' before `ratsimp'ing an
     expression in order to cause explicit factors of the gcd of the
     numerator and denominator to be canceled thus simplifying the
     expression to be `ratsimp'ed.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


 -- Function: zeroequiv (<expr>, <v>)
     Tests whether the expression <expr> in the variable <v> is
     equivalent to zero, returning `true', `false', or `dontknow'.

     `zeroequiv' has these restrictions:
       1. Do not use functions that Maxima does not know how to
          differentiate and evaluate.

       2. If the expression has poles on the real line, there may be
          errors in the result (but this is unlikely to occur).

       3. If the expression contains functions which are not solutions
          to first order differential equations (e.g.  Bessel
          functions) there may be incorrect results.

       4. The algorithm uses evaluation at randomly chosen points for
          carefully selected subexpressions.  This is always a somewhat
          hazardous business, although the algorithm tries to minimize
          the potential for error.

     For example `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' returns
     `true' and `zeroequiv (%e^x + x, x)' returns `false'.  On the
     other hand `zeroequiv (log(a*b) - log(a) - log(b), a)' returns
     `dontknow' because of the presence of an extra parameter `b'.



File: maxima.info,  Node: Expressions,  Next: Simplification,  Prev: Operators,  Up: Top

6 Expressions
*************

* Menu:

* Introduction to Expressions::
* Assignment::
* Complex::
* Nouns and Verbs::
* Identifiers::
* Strings::
* Inequality::
* Syntax::
* Definitions for Expressions::


File: maxima.info,  Node: Introduction to Expressions,  Next: Assignment,  Prev: Expressions,  Up: Expressions

6.1 Introduction to Expressions
===============================

There are a number of reserved words which cannot be used as variable
names.   Their use would cause a possibly cryptic syntax error.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Most things in Maxima are expressions.   A sequence of expressions
can be made into an expression by separating them by commas and putting
parentheses around them.   This is similar to the C comma expression.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Even loops in Maxima are expressions, although the value they return
is the not too useful `done'.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   whereas what you really want is probably to include a third term in
the comma expression which actually gives back the value.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Assignment,  Next: Complex,  Prev: Introduction to Expressions,  Up: Expressions

6.2 Assignment
==============

There are two assignment operators in Maxima, `:' and `::'.  E.g., `a:
3' sets the variable `a' to 3. `::' assigns the value of the expression
on its right to the value of the quantity on its left, which must
evaluate to an atomic variable or subscripted variable.


File: maxima.info,  Node: Complex,  Next: Nouns and Verbs,  Prev: Assignment,  Up: Expressions

6.3 Complex
===========

A complex expression is specified in Maxima by adding the real part of
the expression to `%i' times the imaginary part.  Thus the roots of the
equation `x^2 - 4*x + 13 = 0' are `2 + 3*%i' and `2 - 3*%i'.  Note that
simplification of products of complex expressions can be effected by
expanding the product.  Simplification of quotients, roots, and other
functions of complex expressions can usually be accomplished by using
the `realpart', `imagpart', `rectform', `polarform', `abs', `carg'
functions.


File: maxima.info,  Node: Nouns and Verbs,  Next: Identifiers,  Prev: Complex,  Up: Expressions

6.4 Nouns and Verbs
===================

Maxima distinguishes between operators which are "nouns" and operators
which are "verbs".  A verb is an operator which can be executed.  A
noun is an operator which appears as a symbol in an expression, without
being executed.  By default, function names are verbs.  A verb can be
changed into a noun by quoting the function name or applying the
`nounify' function.  A noun can be changed into a verb by applying the
`verbify' function.  The evaluation flag `nouns' causes `ev' to
evaluate nouns in an expression.

   The verb form is distinguished by a leading dollar sign `$' on the
corresponding Lisp symbol.  In contrast, the noun form is distinguished
by a leading percent sign `%' on the corresponding Lisp symbol.  Some
nouns have special display properties, such as `'integrate' and
`'derivative' (returned by `diff'), but most do not.  By default, the
noun and verb forms of a function are identical when displayed.  The
global flag `noundisp' causes Maxima to display nouns with a leading
quote mark `''.

   See also `noun', `nouns', `nounify', and `verbify'.

   Examples:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identifiers,  Next: Strings,  Prev: Nouns and Verbs,  Up: Expressions

6.5 Identifiers
===============

Maxima identifiers may comprise alphabetic characters, plus the
numerals 0 through 9, plus any special character preceded by the
backslash `\' character.

   A numeral may be the first character of an identifier if it is
preceded by a backslash.  Numerals which are the second or later
characters need not be preceded by a backslash.

   Characters may be declared alphabetic by the `declare' function.  If
so declared, they need not be preceded by a backslash in an identifier.
The alphabetic characters are initially `A' through `Z', `a' through
`z', `%', and `_'.

   Maxima is case-sensitive. The identifiers `foo', `FOO', and `Foo'
are distinct.  See *Note Lisp and Maxima:: for more on this point.

   A Maxima identifier is a Lisp symbol which begins with a dollar sign
`$'.  Any other Lisp symbol is preceded by a question mark `?' when it
appears in Maxima.  See *Note Lisp and Maxima:: for more on this point.

   Examples:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Strings,  Next: Inequality,  Prev: Identifiers,  Up: Expressions

6.6 Strings
===========

Strings (quoted character sequences) are enclosed in double quote marks
`"' for input, and displayed with or without the quote marks, depending
on the global variable `stringdisp'.

   Strings may contain any characters, including embedded tab, newline,
and carriage return characters.  The sequence `\"' is recognized as a
literal double quote, and `\\' as a literal backslash.  When backslash
appears at the end of a line, the backslash and the line termination
(either newline or carriage return and newline) are ignored, so that
the string continues with the next line.  No other special combinations
of backslash with another character are recognized; when backslash
appears before any character other than `"', `\', or a line
termination, the backslash is ignored.  There is no way to represent a
special character (such as tab, newline, or carriage return) except by
embedding the literal character in the string.

   There is no character type in Maxima; a single character is
represented as a one-character string.

   Maxima strings are implemented as Lisp symbols, not Lisp strings;
that may change in a future version of Maxima.  Maxima can display Lisp
strings and Lisp characters, although some other operations (for
example, equality tests) may fail.

   The `stringproc' add-on package contains many functions for working
with strings.

   Examples:

     (%i1) s_1 : "This is a Maxima string.";
     (%o1)               This is a Maxima string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)               This is a Maxima string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)              "This is a Maxima string."


File: maxima.info,  Node: Inequality,  Next: Syntax,  Prev: Strings,  Up: Expressions

6.7 Inequality
==============

Maxima has the inequality operators `<', `<=', `>=', `>', `#', and
`notequal'.  See `if' for a description of conditional expressions.


File: maxima.info,  Node: Syntax,  Next: Definitions for Expressions,  Prev: Inequality,  Up: Expressions

6.8 Syntax
==========

It is possible to define new operators with specified precedence, to
undefine existing operators, or to redefine the precedence of existing
operators.  An operator may be unary prefix or unary postfix, binary
infix, n-ary infix, matchfix, or nofix.  "Matchfix" means a pair of
symbols which enclose their argument or arguments, and "nofix" means an
operator which takes no arguments.  As examples of the different types
of operators, there are the following.

unary prefix
     negation `- a'

unary postfix
     factorial `a!'

binary infix
     exponentiation `a^b'

n-ary infix
     addition `a + b'

matchfix
     list construction `[a, b]'

   (There are no built-in nofix operators; for an example of such an
operator, see `nofix'.)

   The mechanism to define a new operator is straightforward.  It is
only necessary to declare a function as an operator; the operator
function might or might not be defined.

   An example of user-defined operators is the following.  Note that
the explicit function call `"dd" (a)' is equivalent to `dd a', likewise
`"<-" (a, b)' is equivalent to `a <- b'.  Note also that the functions
`"dd"' and `"<-"' are undefined in this example.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   The Maxima functions which define new operators are summarized in
this table, stating the default left and right binding powers (lbp and
rbp, respectively).  (Binding power determines operator precedence.
However, since left and right binding powers can differ, binding power
is somewhat more complicated than precedence.)  Some of the operation
definition functions take additional arguments; see the function
descriptions for details.

`prefix'
     rbp=180

`postfix'
     lbp=180

`infix'
     lbp=180, rbp=180

`nary'
     lbp=180, rbp=180

`matchfix'
     (binding power not applicable)

`nofix'
     (binding power not applicable)

   For comparison, here are some built-in operators and their left and
right binding powers.

     Operator   lbp     rbp

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   `remove' and `kill' remove operator properties from an atom.
`remove ("<a>", op)' removes only the operator properties of <a>.
`kill ("<a>")' removes all properties of <a>, including the operator
properties.  Note that the name of the operator must be enclosed in
quotation marks.

     (%i1) infix ("@");
     (%o1)                           @
     (%i2) "@" (a, b) := a^b;
                                          b
     (%o2)                      a @ b := a
     (%i3) 5 @ 3;
     (%o3)                          125
     (%i4) remove ("@", op);
     (%o4)                         done
     (%i5) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i5) "@" (5, 3);
     (%o5)                          125
     (%i6) infix ("@");
     (%o6)                           @
     (%i7) 5 @ 3;
     (%o7)                          125
     (%i8) kill ("@");
     (%o8)                         done
     (%i9) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i9) "@" (5, 3);
     (%o9)                        @(5, 3)


File: maxima.info,  Node: Definitions for Expressions,  Prev: Syntax,  Up: Expressions

6.9 Definitions for Expressions
===============================

 -- Function: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Function: at (<expr>, <eqn>)
     Evaluates the expression <expr> with the variables assuming the
     values as specified for them in the list of equations `[<eqn_1>,
     ..., <eqn_n>]' or the single equation <eqn>.

     If a subexpression depends on any of the variables for which a
     value is specified but there is no atvalue specified and it can't
     be otherwise evaluated, then a noun form of the `at' is returned
     which displays in a two-dimensional form.

     `at' carries out multiple substitutions in series, not parallel.

     See also `atvalue'.  For other functions which carry out
     substitutions, see also `subst' and `ev'.

     Examples:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Function: box (<expr>)
 -- Function: box (<expr>, <a>)
     Returns <expr> enclosed in a box.  The return value is an
     expression with `box' as the operator and <expr> as the argument.
     A box is drawn on the display when `display2d' is `true'.

     `box (<expr>, <a>)' encloses <expr> in a box labelled by the
     symbol <a>.  The label is truncated if it is longer than the width
     of the box.

     `box' evaluates its argument.  However, a boxed expression does
     not evaluate to its content, so boxed expressions are effectively
     excluded from computations.

     `boxchar' is the character used to draw the box in `box' and in
     the `dpart' and `lpart' functions.

     Examples:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------


 -- Option variable: boxchar
     Default value: `"'

     `boxchar' is the character used to draw the box in the `box' and
     in the `dpart' and `lpart' functions.

     All boxes in an expression are drawn with the current value of
     `boxchar'; the drawing character is not stored with the box
     expression.


 -- Function: carg (<z>)
     Returns the complex argument of <z>.  The complex argument is an
     angle `theta' in `(-%pi, %pi]' such that `r exp (theta %i) = <z>'
     where `r' is the magnitude of <z>.

     `carg' is a computational function, not a simplifying function.

     `carg' ignores the declaration `declare (<x>, complex)', and
     treats <x> as a real variable.  This is a bug.  See also `abs'
     (complex magnitude), `polarform', `rectform', `realpart', and
     `imagpart'.

     Examples:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Special operator: constant
     `declare (<a>, constant)' declares <a> to be a constant.  See
     `declare'.


 -- Function: constantp (<expr>)
     Returns `true' if <expr> is a constant expression, otherwise
     returns `false'.

     An expression is considered a constant expression if its arguments
     are numbers (including rational numbers, as displayed with `/R/'),
     symbolic constants such as `%pi', `%e', and `%i', variables bound
     to a constant or declared constant by `declare', or functions
     whose arguments are constant.

     `constantp' evaluates its arguments.

     Examples:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)


 -- Function: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Assigns the atom or list of atoms <a_i> the property or list of
     properties <p_i>.  When <a_i> and/or <p_i> are lists, each of the
     atoms gets all of the properties.

     `declare' quotes its arguments.  `declare' always returns `done'.

     As noted in the description for each declaration flag, for some
     flags `featurep(<object>, <feature>)' returns `true' if <object>
     has been declared to have <feature>.  However, `featurep' does not
     recognize some flags; this is a bug.

     See also `features'.

     `declare' recognizes the following properties:

    `evfun'
          Makes <a_i> known to `ev' so that the function named by <a_i>
          is applied when <a_i> appears as a flag argument of `ev'.
          See `evfun'.

    `evflag'
          Makes <a_i> known to the `ev' function so that <a_i> is bound
          to `true' during the execution of `ev' when <a_i> appears as
          a flag argument of `ev'.  See `evflag'.

    `bindtest'
          Tells Maxima to trigger an error when <a_i> is evaluated
          unbound.

    `noun'
          Tells Maxima to parse <a_i> as a noun.  The effect of this is
          to replace instances of <a_i> with `'<a_i>' or
          `nounify(<a_i>)', depending on the context.

    `constant'
          Tells Maxima to consider <a_i> a symbolic constant.

    `scalar'
          Tells Maxima to consider <a_i> a scalar variable.

    `nonscalar'
          Tells Maxima to consider <a_i> a nonscalar variable.  The
          usual application is to declare a variable as a symbolic
          vector or matrix.

    `mainvar'
          Tells Maxima to consider <a_i> a "main variable" (`mainvar').
          `ordergreatp' determines the ordering of atoms as follows:

          (main variables) > (other variables) > (scalar variables) >
          (constants) > (numbers)

    `alphabetic'
          Tells Maxima to recognize all characters in <a_i> (which must
          be a string) as alphabetic characters.

    `feature'
          Tells Maxima to recognize <a_i> as the name of a feature.
          Other atoms may then be declared to have the <a_i> property.

    `rassociative', `lassociative'
          Tells Maxima to recognize <a_i> as a right-associative or
          left-associative function.

    `nary'
          Tells Maxima to recognize <a_i> as an n-ary function.

          The `nary' declaration is not the same as calling the `nary'
          function.  The sole effect of `declare(foo, nary)' is to
          instruct the Maxima simplifier to flatten nested expressions,
          for example, to simplify `foo(x, foo(y, z))' to `foo(x, y,
          z)'.

    `symmetric', `antisymmetric', `commutative'
          Tells Maxima to recognize <a_i> as a symmetric or
          antisymmetric function.  `commutative' is the same as
          `symmetric'.

    `oddfun', `evenfun'
          Tells Maxima to recognize <a_i> as an odd or even function.

    `outative'
          Tells Maxima to simplify <a_i> expressions by pulling
          constant factors out of the first argument.

          When <a_i> has one argument, a factor is considered constant
          if it is a literal or declared constant.

          When <a_i> has two or more arguments, a factor is considered
          constant if the second argument is a symbol and the factor is
          free of the second argument.

    `multiplicative'
          Tells Maxima to simplify <a_i> expressions by the
          substitution `<a_i>(x * y * z * ...)' `-->' `<a_i>(x) *
          <a_i>(y) * <a_i>(z) * ...'.  The substitution is carried out
          on the first argument only.

    `additive'
          Tells Maxima to simplify <a_i> expressions by the
          substitution `<a_i>(x + y + z + ...)' `-->' `<a_i>(x) +
          <a_i>(y) + <a_i>(z) + ...'.  The substitution is carried out
          on the first argument only.

    `linear'
          Equivalent to declaring <a_i> both `outative' and `additive'.

    `integer', `noninteger'
          Tells Maxima to recognize <a_i> as an integer or noninteger
          variable.

    `even', `odd'
          Tells Maxima to recognize <a_i> as an even or odd integer
          variable.

    `rational', `irrational'
          Tells Maxima to recognize <a_i> as a rational or irrational
          real variable.

    `real', `imaginary', `complex'
          Tells Maxima to recognize <a_i> as a real, pure imaginary, or
          complex variable.

    `increasing', `decreasing'
          Tells Maxima to recognize <a_i> as an increasing or
          decreasing function.

    `posfun'
          Tells Maxima to recognize <a_i> as a positive function.

    `integervalued'
          Tells Maxima to recognize <a_i> as an integer-valued function.


     Examples:

     `evfun' and `evflag' declarations.
          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     `bindtest' declaration.
          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     `noun' declaration.
          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     `constant', `scalar', `nonscalar', and `mainvar' declarations.

     `alphabetic' declaration.
          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     `feature' declaration.
          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     `rassociative' and `lassociative' declarations.

     `nary' declaration.
          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     `symmetric' and `antisymmetric' declarations.
          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     `oddfun' and `evenfun' declarations.
          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     `outative' declaration.
          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     `multiplicative' declaration.
          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     `additive' declaration.
          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     `linear' declaration.
          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1


 -- Function: disolate (<expr>, <x_1>, ..., <x_n>)
     is similar to `isolate (<expr>, <x>)' except that it enables the
     user to isolate more than one variable simultaneously.  This might
     be useful, for example, if one were attempting to change variables
     in a multiple integration, and that variable change involved two
     or more of the integration variables.  This function is autoloaded
     from `simplification/disol.mac'.  A demo is available by
     `demo("disol")$'.


 -- Function: dispform (<expr>)
     Returns the external representation of <expr> with respect to its
     main operator.  This should be useful in conjunction with `part'
     which also deals with the external representation.  Suppose <expr>
     is -A .  Then the internal representation of <expr> is "*"(-1,A),
     while the external representation is "-"(A). `dispform (<expr>,
     all)' converts the entire expression (not just the top-level) to
     external format.  For example, if `expr: sin (sqrt (x))', then
     `freeof (sqrt, expr)' and `freeof (sqrt, dispform (expr))' give
     `true', while `freeof (sqrt, dispform (expr, all))' gives `false'.


 -- Function: distrib (<expr>)
     Distributes sums over products.  It differs from `expand' in that
     it works at only the top level of an expression, i.e., it doesn't
     recurse and it is faster than `expand'.  It differs from
     `multthru' in that it expands all sums at that level.

     Examples:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Function: dpart (<expr>, <n_1>, ..., <n_k>)
     Selects the same subexpression as `part', but instead of just
     returning that subexpression as its value, it returns the whole
     expression with the selected subexpression displayed inside a box.
     The box is actually part of the expression.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Function: exp (<x>)
     Represents the exponential function.  Instances of `exp (<x>)' in
     input are simplified to `%e^<x>'; `exp' does not appear in
     simplified expressions.

     `demoivre' if `true' causes `%e^(a + b %i)' to simplify to `%e^(a
     (cos(b) + %i sin(b)))' if `b' is free of `%i'. See `demoivre'.

     `%emode', when `true', causes `%e^(%pi %i x)' to be simplified.
     See `%emode'.

     `%enumer', when `true' causes `%e' to be replaced by 2.718...
     whenever `numer' is `true'. See `%enumer'.


 -- Option variable: %emode
     Default value: `true'

     When `%emode' is `true', `%e^(%pi %i x)' is simplified as follows.

     `%e^(%pi %i x)' simplifies to `cos (%pi x) + %i sin (%pi x)' if
     `x' is an integer or a multiple of 1/2, 1/3, 1/4, or 1/6, and then
     further simplified.

     For other numerical `x', `%e^(%pi %i x)' simplifies to `%e^(%pi %i
     y)' where `y' is `x - 2 k' for some integer `k' such that `abs(y)
     < 1'.

     When `%emode' is `false', no special simplification of `%e^(%pi %i
     x)' is carried out.


 -- Option variable: %enumer
     Default value: `false'

     When `%enumer' is `true', `%e' is replaced by its numeric value
     2.718...  whenever `numer' is `true'.

     When `%enumer' is `false', this substitution is carried out only
     if the exponent in `%e^x' evaluates to a number.

     See also `ev' and `numer'.


 -- Option variable: exptisolate
     Default value: `false'

     `exptisolate', when `true', causes `isolate (expr, var)' to
     examine exponents of atoms (such as `%e') which contain `var'.


 -- Option variable: exptsubst
     Default value: `false'

     `exptsubst', when `true', permits substitutions such as `y' for
     `%e^x' in `%e^(a x)'.


 -- Function: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Returns `true' if no subexpression of
     <expr> is equal to <x_1> or if <x_1> occurs only as a dummy
     variable in <expr>, and returns `false' otherwise.

     `freeof (<x_1>, ..., <x_n>, <expr>)' is equivalent to `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     The arguments <x_1>, ..., <x_n> may be names of functions and
     variables, subscripted names, operators (enclosed in double
     quotes), or general expressions.  `freeof' evaluates its arguments.

     `freeof' operates only on <expr> as it stands (after
     simplification and evaluation) and does not attempt to determine
     if some equivalent expression would give a different result.  In
     particular, simplification may yield an equivalent but different
     expression which comprises some different elements than the
     original form of <expr>.

     A variable is a dummy variable in an expression if it has no
     binding outside of the expression.  Dummy variables recognized by
     `freeof' are the index of a sum or product, the limit variable in
     `limit', the integration variable in the definite integral form of
     `integrate', the original variable in `laplace', formal variables
     in `at' expressions, and arguments in `lambda' expressions.  Local
     variables in `block' are not recognized by `freeof' as dummy
     variables; this is a bug.

     The indefinite form of `integrate' is not free of its variable of
     integration.

        * Arguments are names of functions, variables, subscripted
          names, operators, and expressions.  `freeof (a, b, expr)' is
          equivalent to `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' evaluates its arguments.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' does not consider equivalent expressions.
          Simplification may yield an equivalent but different
          expression.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * A summation or definite integral is free of its dummy
          variable.  An indefinite integral is not free of its variable
          of integration.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Function: genfact (<x>, <y>, <z>)
     Returns the generalized factorial, defined as `x (x-z) (x - 2 z)
     ... (x - (y - 1) z)'.  Thus, for integral <x>, `genfact (x, x, 1)
     = x!' and `genfact (x, x/2, 2) = x!!'.


 -- Function: imagpart (<expr>)
     Returns the imaginary part of the expression <expr>.

     `imagpart' is a computational function, not a simplifying function.

     See also `abs', `carg', `polarform', `rectform', and `realpart'.


 -- Function: infix (<op>)
 -- Function: infix (<op>, <lbp>, <rbp>)
 -- Function: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declares <op> to be an infix operator.  An infix operator is a
     function of two arguments, with the name of the function written
     between the arguments.  For example, the subtraction operator `-'
     is an infix operator.

     `infix (<op>)' declares <op> to be an infix operator with default
     binding powers (left and right both equal to 180) and parts of
     speech (left and right both equal to `any').

     `infix (<op>, <lbp>, <rbp>)' declares <op> to be an infix operator
     with stated left and right binding powers and default parts of
     speech (left and right both equal to `any').

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declares <op>
     to be an infix operator with stated left and right binding powers
     and parts of speech.

     The precedence of <op> with respect to other operators derives
     from the left and right binding powers of the operators in
     question.  If the left and right binding powers of <op> are both
     greater the left and right binding powers of some other operator,
     then <op> takes precedence over the other operator.  If the
     binding powers are not both greater or less, some more complicated
     relation holds.

     The associativity of <op> depends on its binding powers.  Greater
     left binding power (<lbp>) implies an instance of <op> is
     evaluated before other operators to its left in an expression,
     while greater right binding power (<rbp>) implies  an instance of
     <op> is evaluated before other operators to its right in an
     expression.  Thus greater <lbp> makes <op> right-associative,
     while greater <rbp> makes <op> left-associative.  If <lbp> is
     equal to <rbp>, <op> is left-associative.

     See also `Syntax'.

     Examples:

        * If the left and right binding powers of <op> are both greater
          the left and right binding powers of some other operator,
          then <op> takes precedence over the other operator.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) :lisp (get '$+ 'lbp)
          100
          (%i2) :lisp (get '$+ 'rbp)
          100
          (%i2) infix ("@", 101, 101)$
          (%i3) 1 + a@b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("@", 99, 99)$
          (%i5) 1 + a@b + 2;
          (%o5)                       (a+1,b+2)

        * Greater <lbp> makes <op> right-associative, while greater
          <rbp> makes <op> left-associative.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) infix ("@", 100, 99)$
          (%i3) foo @ bar @ baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("@", 100, 101)$
          (%i5) foo @ bar @ baz;
          (%o5)                    ((foo,bar),baz)


 -- Option variable: inflag
     Default value: `false'

     When `inflag' is `true', functions for part extraction inspect the
     internal form of `expr'.

     Note that the simplifier re-orders expressions.  Thus `first (x +
     y)' returns `x' if `inflag' is `true' and `y' if `inflag' is
     `false'.  (`first (y + x)' gives the same results.)

     Also, setting `inflag' to `true' and calling `part' or `substpart'
     is the same as calling `inpart' or `substinpart'.

     Functions affected by the setting of `inflag' are: `part',
     `substpart', `first', `rest', `last', `length', the `for' ... `in'
     construct, `map', `fullmap', `maplist', `reveal' and `pickapart'.


 -- Function: inpart (<expr>, <n_1>, ..., <n_k>)
     is similar to `part' but works on the internal representation of
     the expression rather than the displayed form and thus may be
     faster since no formatting is done.  Care should be taken with
     respect to the order of subexpressions in sums and products (since
     the order of variables in the internal form is often different
     from that in the displayed form) and in dealing with unary minus,
     subtraction, and division (since these operators are removed from
     the expression). `part (x+y, 0)' or `inpart (x+y, 0)' yield `+',
     though in order to refer to the operator it must be enclosed in
     "s.  For example `... if inpart (%o9,0) = "+" then ...'.

     Examples:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Function: isolate (<expr>, <x>)
     Returns <expr> with subexpressions which are sums and which do not
     contain var replaced by intermediate expression labels (these
     being atomic symbols like `%t1', `%t2', ...).  This is often useful
     to avoid unnecessary expansion of subexpressions which don't
     contain the variable of interest.  Since the intermediate labels
     are bound to the subexpressions they can all be substituted back
     by evaluating the expression in which they occur.

     `exptisolate' (default value: `false') if `true' will cause
     `isolate' to examine exponents of atoms (like `%e') which contain
     var.

     `isolate_wrt_times' if `true', then `isolate' will also isolate
     with respect to products. See `isolate_wrt_times'.

     Do `example (isolate)' for examples.


 -- Option variable: isolate_wrt_times
     Default value: `false'

     When `isolate_wrt_times' is `true', `isolate' will also isolate
     with respect to products.  E.g. compare both settings of the
     switch on

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Option variable: listconstvars
     Default value: `false'

     When `listconstvars' is `true', it will cause `listofvars' to
     include `%e', `%pi', `%i', and any variables declared constant in
     the list it returns if they appear in the expression `listofvars'
     is called on.  The default is to omit these.


 -- Option variable: listdummyvars
     Default value: `true'

     When `listdummyvars' is `false', "dummy variables" in the
     expression will not be included in the list returned by
     `listofvars'.  (The meaning of "dummy variables" is as given in
     `freeof'.  "Dummy variables" are mathematical things like the
     index of a sum or product, the limit variable, and the definite
     integration variable.)  Example:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Function: listofvars (<expr>)
     Returns a list of the variables in <expr>.

     `listconstvars' if `true' causes `listofvars' to include `%e',
     `%pi', `%i', and any variables declared constant in the list it
     returns if they appear in <expr>.  The default is to omit these.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Function: lfreeof (<list>, <expr>)
     For each member <m> of list, calls `freeof (<m>, <expr>)'.  It
     returns `false' if any call to `freeof' does and `true' otherwise.

 -- Function: lopow (<expr>, <x>)
     Returns the lowest exponent of <x> which explicitly appears in
     <expr>.  Thus

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Function: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     is similar to `dpart' but uses a labelled box. A labelled box is
     similar to the one produced by `dpart' but it has a name in the
     top line.


 -- Function: multthru (<expr>)
 -- Function: multthru (<expr_1>, <expr_2>)
     Multiplies a factor (which should be a sum) of <expr> by the other
     factors of <expr>.  That is, <expr> is `<f_1> <f_2> ... <f_n>'
     where at least one factor, say <f_i>, is a sum of terms.  Each
     term in that sum is multiplied by the other factors in the
     product.  (Namely all the factors except <f_i>).  `multthru' does
     not expand exponentiated sums.  This function is the fastest way
     to distribute products (commutative or noncommutative) over sums.
     Since quotients are represented as products `multthru' can be used
     to divide sums by products as well.

     `multthru (<expr_1>, <expr_2>)' multiplies each term in <expr_2>
     (which should be a sum or an equation) by <expr_1>.  If <expr_1>
     is not itself a sum then this form is equivalent to `multthru
     (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Function: nounify (<f>)
     Returns the noun form of the function name <f>.  This is needed if
     one wishes to refer to the name of a verb function as if it were a
     noun.  Note that some verb functions will return their noun forms
     if they can't be evaluated for certain arguments.  This is also
     the form returned if a function call is preceded by a quote.


 -- Function: nterms (<expr>)
     Returns the number of terms that <expr> would have if it were
     fully expanded out and no cancellations or combination of terms
     occurred.  Note that expressions like `sin (<expr>)', `sqrt
     (<expr>)', `exp (<expr>)', etc.  count as just one term regardless
     of how many terms <expr> has (if it is a sum).


 -- Function: op (<expr>)
     Returns the main operator of the expression <expr>.  `op (<expr>)'
     is equivalent to `part (<expr>, 0)'.

     `op' returns a string if the main operator is a built-in or
     user-defined prefix, binary or n-ary infix, postfix, matchfix, or
     nofix operator.  Otherwise, if <expr> is a subscripted function
     expression, `op' returns the subscripted function; in this case
     the return value is not an atom.  Otherwise, <expr> is an array
     function or ordinary function expression, and `op' returns a
     symbol.

     `op' observes the value of the global flag `inflag'.

     `op' evaluates it argument.

     See also `args'.

     Examples:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G


 -- Function: operatorp (<expr>, <op>)
 -- Function: operatorp (<expr>, [<op_1>, ..., <op_n>])
     `operatorp (<expr>, <op>)' returns `true' if <op> is equal to the
     operator of <expr>.

     `operatorp (<expr>, [<op_1>, ..., <op_n>])' returns `true' if some
     element <op_1>, ..., <op_n> is equal to the operator of <expr>.


 -- Function: optimize (<expr>)
     Returns an expression that produces the same value and side
     effects as <expr> but does so more efficiently by avoiding the
     recomputation of common subexpressions.  `optimize' also has the
     side effect of "collapsing" its argument so that all common
     subexpressions are shared.  Do `example (optimize)' for examples.


 -- Option variable: optimprefix
     Default value: `%'

     `optimprefix' is the prefix used for generated symbols by the
     `optimize' command.


 -- Function: ordergreat (<v_1>, ..., <v_n>)
     Sets up aliases for the variables <v_1>, ..., <v_n> such that
     <v_1> > <v_2> > ...  > <v_n>, and <v_n> > any other variable not
     mentioned as an argument.

     See also `orderless'.


 -- Function: ordergreatp (<expr_1>, <expr_2>)
     Returns `true' if <expr_2> precedes <expr_1> in the ordering set
     up with the `ordergreat' function.


 -- Function: orderless (<v_1>, ..., <v_n>)
     Sets up aliases for the variables <v_1>, ..., <v_n> such that
     <v_1> < <v_2> < ...  < <v_n>, and <v_n> < any other variable not
     mentioned as an argument.

     Thus the complete ordering scale is: numerical constants <
     declared constants < declared scalars < first argument to
     `orderless' < ...  < last argument to `orderless' < variables
     which begin with A < ...  < variables which begin with Z < last
     argument to `ordergreat' <  ... < first argument to `ordergreat' <
     declared `mainvar's.

     See also `ordergreat' and `mainvar'.


 -- Function: orderlessp (<expr_1>, <expr_2>)
     Returns `true' if <expr_1> precedes <expr_2> in the ordering set
     up by the `orderless' command.


 -- Function: part (<expr>, <n_1>, ..., <n_k>)
     Returns parts of the displayed form of `expr'. It obtains the part
     of `expr' as specified by the indices <n_1>, ..., <n_k>.  First
     part <n_1> of `expr' is obtained, then part <n_2> of that, etc.
     The result is part <n_k> of ... part <n_2> of part <n_1> of `expr'.

     `part' can be used to obtain an element of a list, a row of a
     matrix, etc.

     If the last argument to a part function is a list of indices then
     several subexpressions are picked out, each one corresponding to an
     index of the list.  Thus `part (x + y + z, [1, 3])' is `z+x'.

     `piece' holds the last expression selected when using the part
     functions.  It is set during the execution of the function and thus
     may be referred to in the function itself as shown below.

     If `partswitch' is set to `true' then `end' is returned when a
     selected part of an expression doesn't exist, otherwise an error
     message is given.

     Example: `part (z+2*y, 2, 1)' yields 2.

     `example (part)' displays additional examples.


 -- Function: partition (<expr>, <x>)
     Returns a list of two expressions.  They are (1) the factors of
     <expr> (if it is a product), the terms of <expr> (if it is a sum),
     or the list (if it is a list) which don't contain var and, (2) the
     factors, terms, or list which do.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Option variable: partswitch
     Default value: `false'

     When `partswitch' is `true', `end' is returned when a selected
     part of an expression doesn't exist, otherwise an error message is
     given.


 -- Function: pickapart (<expr>, <n>)
     Assigns intermediate expression labels to subexpressions of <expr>
     at depth <n>, an integer.  Subexpressions at greater or lesser
     depths are not assigned labels.  `pickapart' returns an expression
     in terms of intermediate expressions equivalent to the original
     expression <expr>.

     See also `part', `dpart', `lpart', `inpart', and `reveal'.

     Examples:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- System variable: piece
     Holds the last expression selected when using the `part' functions.
     It is set during the execution of the function and thus may be
     referred to in the function itself.


 -- Function: polarform (<expr>)
     Returns an expression `r %e^(%i theta)' equivalent to <expr>, such
     that `r' and `theta' are purely real.


 -- Function: powers (<expr>, <x>)
     Gives the powers of <x> occuring in <expr>.

     `load (powers)' loads this function.


 -- Function: product (<expr>, <i>, <i_0>, <i_1>)
     Represents a product of the values of <expr> as the index <i>
     varies from <i_0> to <i_1>.  The noun form `'product' is displayed
     as an uppercase letter pi.

     `product' evaluates <expr> and lower and upper limits <i_0> and
     <i_1>, `product' quotes (does not evaluate) the index <i>.

     If the upper and lower limits differ by an integer, <expr> is
     evaluated for each value of the index <i>, and the result is an
     explicit product.

     Otherwise, the range of the index is indefinite.  Some rules are
     applied to simplify the product.  When the global variable
     `simpproduct' is `true', additional rules are applied.  In some
     cases, simplification yields a result which is not a product;
     otherwise, the result is a noun form `'product'.

     See also `nouns' and `evflag'.

     Examples:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Function: realpart (<expr>)
     Returns the real part of <expr>. `realpart' and `imagpart' will
     work on expressions involving trigonometic and hyperbolic
     functions, as well as square root, logarithm, and exponentiation.


 -- Function: rectform (<expr>)
     Returns an expression `a + b %i' equivalent to <expr>, such that
     <a> and <b> are purely real.


 -- Function: rembox (<expr>, unlabelled)
 -- Function: rembox (<expr>, <label>)
 -- Function: rembox (<expr>)
     Removes boxes from <expr>.

     `rembox (<expr>, unlabelled)' removes all unlabelled boxes from
     <expr>.

     `rembox (<expr>, <label>)' removes only boxes bearing <label>.

     `rembox (<expr>)' removes all boxes, labelled and unlabelled.

     Boxes are drawn by the `box', `dpart', and `lpart' functions.

     Examples:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Function: sum (<expr>, <i>, <i_0>, <i_1>)
     Represents a summation of the values of <expr> as the index <i>
     varies from <i_0> to <i_1>.  The noun form `'sum' is displayed as
     an uppercase letter sigma.

     `sum' evaluates its summand <expr> and lower and upper limits
     <i_0> and <i_1>, `sum' quotes (does not evaluate) the index <i>.

     If the upper and lower limits differ by an integer, the summand
     <expr> is evaluated for each value of the summation index <i>, and
     the result is an explicit sum.

     Otherwise, the range of the index is indefinite.  Some rules are
     applied to simplify the summation.  When the global variable
     `simpsum' is `true', additional rules are applied.  In some cases,
     simplification yields a result which is not a summation;
     otherwise, the result is a noun form `'sum'.

     When the `evflag' (evaluation flag) `cauchysum' is `true', a
     product of summations is expressed as a Cauchy product, in which
     the index of the inner summation is a function of the index of the
     outer one, rather than varying independently.

     The global variable `genindex' is the alphabetic prefix used to
     generate the next index of summation, when an automatically
     generated index is needed.

     `gensumnum' is the numeric suffix used to generate the next index
     of summation, when an automatically generated index is needed.
     When `gensumnum' is `false', an automatically-generated index is
     only `genindex' with no numeric suffix.

     See also `sumcontract', `intosum', `bashindices', `niceindices',
     `nouns', `evflag', and `zeilberger'.

     Examples:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Function: lsum (<expr>, <x>, <L>)
     Represents the sum of <expr> for each element <x> in <L>.

     A noun form `'lsum' is returned if the argument <L> does not
     evaluate to a list.

     Examples:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Function: verbify (<f>)
     Returns the verb form of the function name <f>.

     See also `verb', `noun', and `nounify'.

     Examples:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplification,  Next: Plotting,  Prev: Expressions,  Up: Top

7 Simplification
****************

* Menu:

* Definitions for Simplification::


File: maxima.info,  Node: Definitions for Simplification,  Prev: Simplification,  Up: Simplification

7.1 Definitions for Simplification
==================================

 -- System variable: askexp
     When `asksign' is called, `askexp' is the expression `asksign' is
     testing.

     At one time, it was possible for a user to inspect `askexp' by
     entering a Maxima break with control-A.

 -- Function: askinteger (<expr>, integer)
 -- Function: askinteger (<expr>)
 -- Function: askinteger (<expr>, even)
 -- Function: askinteger (<expr>, odd)
     `askinteger (<expr>, integer)' attempts to determine from the
     `assume' database whether <expr> is an integer.  `askinteger'
     prompts the user if it cannot tell otherwise, and attempt to
     install the information in the database if possible.  `askinteger
     (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

     `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
     likewise attempt to determine if <expr> is an even integer or odd
     integer, respectively.


 -- Function: asksign (<expr>)
     First attempts to determine whether the specified expression is
     positive, negative, or zero.  If it cannot, it asks the user the
     necessary questions to complete its deduction.  The user's answer
     is recorded in the data base for the duration of the current
     computation. The return value of `asksign' is one of `pos', `neg',
     or `zero'.


 -- Function: demoivre (<expr>)
 -- Option variable: demoivre
     The function `demoivre (expr)' converts one expression without
     setting the global variable `demoivre'.

     When the variable `demoivre' is `true', complex exponentials are
     converted into equivalent expressions in terms of circular
     functions: `exp (a + b*%i)' simplifies to `%e^a * (cos(b) +
     %i*sin(b))' if `b' is free of `%i'.  `a' and `b' are not expanded.

     The default value of `demoivre' is `false'.

     `exponentialize' converts circular and hyperbolic functions to
     exponential form.  `demoivre' and `exponentialize' cannot both be
     true at the same time.


 -- Option variable: domain
     Default value: `real'

     When `domain' is set to `complex', `sqrt (x^2)' will remain `sqrt
     (x^2)' instead of returning `abs(x)'.


 -- Function: expand (<expr>)
 -- Function: expand (<expr>, <p>, <n>)
     Expand expression <expr>.  Products of sums and exponentiated sums
     are multiplied out, numerators of rational expressions which are
     sums are split into their respective terms, and multiplication
     (commutative and non-commutative) are distributed over addition at
     all levels of <expr>.

     For polynomials one should usually use `ratexpand' which uses a
     more efficient algorithm.

     `maxnegex' and `maxposex' control the maximum negative and
     positive exponents, respectively, which will expand.

     `expand (<expr>, <p>, <n>)' expands <expr>, using <p> for
     `maxposex' and <n> for `maxnegex'.  This is useful in order to
     expand part but not all of an expression.

     `expon' - the exponent of the largest negative power which is
     automatically expanded (independent of calls to `expand').  For
     example if `expon' is 4 then `(x+1)^(-5)' will not be
     automatically expanded.

     `expop' - the highest positive exponent which is automatically
     expanded.  Thus `(x+1)^3', when typed, will be automatically
     expanded only if `expop' is greater than or equal to 3.  If it is
     desired to have `(x+1)^n' expanded where `n' is greater than
     `expop' then executing `expand ((x+1)^n)' will work only if
     `maxposex' is not less than `n'.

     The `expand' flag used with `ev' causes expansion.

     The file `simplification/facexp.mac' contains several related
     functions (in particular `facsum', `factorfacsum' and
     `collectterms', which are autoloaded) and variables
     (`nextlayerfactor' and `facsum_combine') that provide the user
     with the ability to structure expressions by controlled expansion.
     Brief function descriptions are available in
     `simplification/facexp.usg'.  A demo is available by doing
     `demo("facexp")'.


 -- Function: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expands expression `expr' with respect to the variables <x_1>,
     ..., <x_n>.  All products involving the variables appear
     explicitly.  The form returned will be free of products of sums of
     expressions that are not free of the variables.   <x_1>, ..., <x_n>
     may be variables, operators, or expressions.

     By default, denominators are not expanded, but this can be
     controlled by means of the switch `expandwrt_denom'.

     This function is autoloaded from `simplification/stopex.mac'.


 -- Option variable: expandwrt_denom
     Default value: `false'

     `expandwrt_denom' controls the treatment of rational expressions
     by `expandwrt'.  If `true', then both the numerator and
     denominator of the expression will be expanded according to the
     arguments of `expandwrt', but if `expandwrt_denom' is `false',
     then only the numerator will be expanded in that way.


 -- Function: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     is similar to `expandwrt', but treats expressions that are
     products somewhat differently.  `expandwrt_factored' expands only
     on those factors of `expr' that contain the variables <x_1>, ...,
     <x_n>.

     This function is autoloaded from `simplification/stopex.mac'.


 -- Option variable: expon
     Default value: 0

     `expon' is the exponent of the largest negative power which is
     automatically expanded (independent of calls to `expand').  For
     example, if `expon' is 4 then `(x+1)^(-5)' will not be
     automatically expanded.


 -- Function: exponentialize (<expr>)
 -- Option variable: exponentialize
     The function `exponentialize (expr)' converts circular and
     hyperbolic functions in <expr> to exponentials, without setting
     the global variable `exponentialize'.

     When the variable `exponentialize' is `true', all circular and
     hyperbolic functions are converted to exponential form.  The
     default value is `false'.

     `demoivre' converts complex exponentials into circular functions.
     `exponentialize' and `demoivre' cannot both be true at the same
     time.


 -- Option variable: expop
     Default value: 0

     `expop' is the highest positive exponent which is automatically
     expanded.  Thus `(x + 1)^3', when typed, will be automatically
     expanded only if `expop' is greater than or equal to 3.  If it is
     desired to have `(x + 1)^n' expanded where `n' is greater than
     `expop' then executing `expand ((x + 1)^n)' will work only if
     `maxposex' is not less than n.


 -- Option variable: factlim
     Default value: -1

     `factlim' specifies the highest factorial which is automatically
     expanded.  If it is -1 then all integers are expanded.


 -- Function: intosum (<expr>)
     Moves multiplicative factors outside a summation to inside.  If
     the index is used in the outside expression, then the function
     tries to find a reasonable index, the same as it does for
     `sumcontract'.  This is essentially the reverse idea of the
     `outative' property of summations, but note that it does not
     remove this property, it only bypasses it.

     In some cases, a `scanmap (multthru, <expr>)' may be necessary
     before the `intosum'.


 -- Declaration: lassociative
     `declare (g, lassociative)' tells the Maxima simplifier that `g'
     is left-associative.  E.g., `g (g (a, b), g (c, d))' will simplify
     to `g (g (g (a, b), c), d)'.


 -- Declaration: linear
     One of Maxima's operator properties.  For univariate `f' so
     declared, "expansion" `f(x + y)' yields `f(x) + f(y)', `f(a*x)'
     yields `a*f(x)' takes place where `a' is a "constant".  For
     functions of two or more arguments, "linearity" is defined to be
     as in the case of `sum' or `integrate', i.e., `f (a*x + b, x)'
     yields `a*f(x,x) + b*f(1,x)' for `a' and `b' free of `x'.

     `linear' is equivalent to `additive' and `outative'.  See also
     `opproperties'.


 -- Declaration: mainvar
     You may declare variables to be `mainvar'.  The ordering scale for
     atoms is essentially: numbers < constants (e.g., `%e', `%pi') <
     scalars < other variables < mainvars.  E.g., compare `expand
     ((X+Y)^4)' with `(declare (x, mainvar), expand ((x+y)^4))'.
     (Note: Care should be taken if you elect to use the above feature.
     E.g., if you subtract an expression in which `x' is a `mainvar'
     from one in which `x' isn't a `mainvar', resimplification e.g.
     with `ev (expr, simp)' may be necessary if cancellation is to
     occur.  Also, if you save an expression in which `x' is a
     `mainvar', you probably should also save `x'.)


 -- Option variable: maxapplydepth
     Default value: 10000

     `maxapplydepth' is the maximum depth to which `apply1' and
     `apply2' will delve.


 -- Option variable: maxapplyheight
     Default value: 10000

     `maxapplyheight' is the maximum height to which `applyb1' will
     reach before giving up.


 -- Option variable: maxnegex
     Default value: 1000

     `maxnegex' is the largest negative exponent which will be expanded
     by the `expand' command (see also `maxposex').


 -- Option variable: maxposex
     Default value: 1000

     `maxposex' is the largest exponent which will be expanded with the
     `expand' command (see also `maxnegex').


 -- Declaration: multiplicative
     `declare (f, multiplicative)' tells the Maxima simplifier that `f'
     is multiplicative.

       1. If `f' is univariate, whenever the simplifier encounters `f'
          applied to a product, `f' distributes over that product.
          E.g., `f(x*y)' simplifies to `f(x)*f(y)'.

       2. If `f' is a function of 2 or more arguments, multiplicativity
          is defined as multiplicativity in the first argument to `f',
          e.g., `f (g(x) * h(x), x)' simplifies to `f (g(x) ,x) * f
          (h(x), x)'.

     This simplification does not occur when `f' is applied to
     expressions of the form `product (x[i], i, m, n)'.


 -- Option variable: negdistrib
     Default value: `true'

     When `negdistrib' is `true', -1 distributes over an expression.
     E.g., `-(x + y)' becomes `- y - x'.  Setting it to `false' will
     allow `- (x + y)' to be displayed like that.  This is sometimes
     useful but be very careful: like the `simp' flag, this is one flag
     you do not want to set to `false' as a matter of course or
     necessarily for other than local use in your Maxima.


 -- Option variable: negsumdispflag
     Default value: `true'

     When `negsumdispflag' is `true', `x - y' displays as `x - y'
     instead of as `- y + x'.  Setting it to `false' causes the special
     check in display for the difference of two expressions to not be
     done.  One application is that thus `a + %i*b' and `a - %i*b' may
     both be displayed the same way.


 -- Special symbol: noeval
     `noeval' suppresses the evaluation phase of `ev'.  This is useful
     in conjunction with other switches and in causing expressions to
     be resimplified without being reevaluated.


 -- Declaration: noun
     `noun' is one of the options of the `declare' command.  It makes a
     function so declared a "noun", meaning that it won't be evaluated
     automatically.


 -- Option variable: noundisp
     Default value: `false'

     When `noundisp' is `true', nouns display with a single quote.
     This switch is always `true' when displaying function definitions.


 -- Special symbol: nouns
     `nouns' is an `evflag'. When used as an option to the `ev' command,
     `nouns' converts all "noun" forms occurring in the expression
     being `ev''d to "verbs", i.e., evaluates them.  See also `noun',
     `nounify', `verb', and `verbify'.


 -- Special symbol: numer
     `numer' causes some mathematical functions (including
     exponentiation) with numerical arguments to be evaluated in
     floating point. It causes variables in `expr' which have been
     given numerals to be replaced by their values.  It also sets the
     `float' switch on.


 -- Function: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declares the variables `x_1', ..., <x_n> to have numeric values
     equal to `expr_1', ..., `expr_n'.  The numeric value is evaluated
     and substituted for the variable in any expressions in which the
     variable occurs if the `numer' flag is `true'. See also `ev'.

     The expressions `expr_1', ..., `expr_n' can be any expressions,
     not necessarily numeric.

 -- System variable: opproperties
     `opproperties' is the list of the special operator properties
     recognized by the Maxima simplifier: `linear', `additive',
     `multiplicative', `outative', `evenfun', `oddfun', `commutative',
     `symmetric', `antisymmetric', `nary', `lassociative',
     `rassociative'.


 -- Option variable: opsubst
     Default value: `true'

     When `opsubst' is `false', `subst' does not attempt to substitute
     into the operator of an expression.  E.g., `(opsubst: false, subst
     (x^2, r, r+r[0]))' will work.


 -- Declaration: outative
     `declare (f, outative)' tells the Maxima simplifier that constant
     factors in the argument of `f' can be pulled out.

       1. If `f' is univariate, whenever the simplifier encounters `f'
          applied to a product, that product will be partitioned into
          factors that are constant and factors that are not and the
          constant factors will be pulled out.  E.g., `f(a*x)' will
          simplify to `a*f(x)' where `a' is a constant.  Non-atomic
          constant factors will not be pulled out.

       2. If `f' is a function of 2 or more arguments, outativity is
          defined as in the case of `sum' or `integrate', i.e., `f
          (a*g(x), x)' will simplify to `a * f(g(x), x)' for `a' free
          of `x'.

     `sum', `integrate', and `limit' are all `outative'.


 -- Declaration: posfun
     `declare (f, posfun)' declares `f' to be a positive function.  `is
     (f(x) > 0)' yields `true'.


 -- Function: radcan (<expr>)
     Simplifies <expr>, which can contain logs, exponentials, and
     radicals, by converting it into a form which is canonical over a
     large class of expressions and a given ordering of variables; that
     is, all functionally equivalent forms are mapped into a unique
     form.  For a somewhat larger class of expressions, `radcan'
     produces a regular form.  Two equivalent expressions in this class
     do not necessarily have the same appearance, but their difference
     can be simplified by `radcan' to zero.

     For some expressions `radcan' is quite time consuming.  This is
     the cost of exploring certain relationships among the components of
     the expression for simplifications based on factoring and
     partial-fraction expansions of exponents.

     When `%e_to_numlog' is `true', `%e^(r*log(expr))' simplifies to
     `expr^r' if `r' is a rational number.

     When `radexpand' is `false', certain transformations are inhibited.
     `radcan (sqrt (1-x))' remains `sqrt (1-x)' and is not simplified
     to `%i sqrt (x-1)'.  `radcan (sqrt (x^2 - 2*x + 11))' remains
     `sqrt (x^2 - 2*x + 1)' and is not simplified to `x - 1'.

     `example (radcan)' displays some examples.


 -- Option variable: radexpand
     Default value: `true'

     `radexpand' controls some simplifications of radicals.

     When `radexpand' is `all', causes nth roots of factors of a
     product which are powers of n to be pulled outside of the radical.
     E.g. if `radexpand' is `all', `sqrt (16*x^2)' simplifies to `4*x'.

     More particularly, consider `sqrt (x^2)'.
        * If `radexpand' is `all' or `assume (x > 0)' has been executed,
          `sqrt(x^2)' simplifies to `x'.

        * If `radexpand' is `true' and `domain' is `real' (its default),
          `sqrt(x^2)' simplifies to `abs(x)'.

        * If `radexpand' is `false', or `radexpand' is `true' and
          `domain' is `complex', `sqrt(x^2)' is not simplified.

     Note that `domain' only matters when `radexpand' is `true'.


 -- Option variable: radsubstflag
     Default value: `false'

     `radsubstflag', if `true', permits `ratsubst' to make
     substitutions such as `u' for `sqrt (x)' in `x'.


 -- Declaration: rassociative
     `declare (g, rassociative)' tells the Maxima simplifier that `g'
     is right-associative.  E.g., `g(g(a, b), g(c, d))' simplifies to
     `g(a, g(b, g(c, d)))'.


 -- Function: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Sequential Comparative Simplification (method due to Stoute).
     `scsimp' attempts to simplify <expr> according to the rules
     <rule_1>, ..., <rule_n>.  If a smaller expression is obtained, the
     process repeats.  Otherwise after all simplifications are tried,
     it returns the original answer.

     `example (scsimp)' displays some examples.


 -- Option variable: simpsum
     Default value: `false'

     When `simpsum' is `true', the result of a `sum' is simplified.
     This simplification may sometimes be able to produce a closed
     form.  If `simpsum' is `false' or if the quoted form `'sum' is
     used, the value is a sum noun form which is a representation of
     the sigma notation used in mathematics.


 -- Function: sumcontract (<expr>)
     Combines all sums of an addition that have upper and lower bounds
     that differ by constants. The result is an expression containing
     one summation for each set of such summations added to all
     appropriate extra terms that had to be extracted to form this sum.
     `sumcontract' combines all compatible sums and uses one of the
     indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.

     It may be necessary to do an `intosum (<expr>)' before the
     `sumcontract'.


 -- Option variable: sumexpand
     Default value: `false'

     When `sumexpand' is `true', products of sums and exponentiated
     sums simplify to nested sums.

     See also `cauchysum'.

     Examples:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Option variable: sumsplitfact
     Default value: `true'

     When `sumsplitfact' is `false', `minfactorial' is applied after a
     `factcomb'.


 -- Declaration: symmetric
     `declare (h, symmetric)' tells the Maxima simplifier that `h' is a
     symmetric function.  E.g., `h (x, z, y)' simplifies to `h (x, y,
     z)'.

     `commutative' is synonymous with `symmetric'.


 -- Function: unknown (<expr>)
     Returns `true' if and only if <expr> contains an operator or
     function not recognized by the Maxima simplifier.



File: maxima.info,  Node: Plotting,  Next: Input and Output,  Prev: Simplification,  Up: Top

8 Plotting
**********

* Menu:

* Definitions for Plotting::


File: maxima.info,  Node: Definitions for Plotting,  Prev: Plotting,  Up: Plotting

8.1 Definitions for Plotting
============================

 -- Function: contour_plot (<expr>, <x_range>, <y_range>, <options>,
          ...)
     Plots the contours (curves of equal value) of <expr> over the
     region <x_range> by <y_range>.  Any additional arguments are
     treated the same as in `plot3d'.

     `contour_plot' only works when the plot format is `gnuplot' or
     `gnuplot_pipes'.

     See also `implicit_plot'.

     Examples:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4]);
          (%o1)
          (%i2) contour_plot (sin(y) * cos(x)^2, [x, -4, 4], [y, -4, 4]);
          (%o2)
          (%i3) F(x, y) := x^3 + y^2;
                                             3    2
          (%o3)                  F(x, y) := x  + y
          (%i4) contour_plot (F, [u, -4, 4], [v, -4, 4]);
          (%o4)
          (%i5) contour_plot (F, [u, -4, 4], [v, -4, 4], [gnuplot_preamble, "set size ratio -1"]);
          (%o5)
          (%i6) set_plot_option ([gnuplot_preamble, "set cntrparam levels 12"])$

          (%i7) contour_plot (F, [u, -4, 4], [v, -4, 4]);


 -- Option variable: in_netmath
     Default value: `false'

     When `in_netmath' is `true', `plot3d' prints OpenMath output to
     the console if `plot_format' is `openmath'; otherwise `in_netmath'
     (even if `true') has no effect.  `in_netmath' has no effect on
     `plot2d'.


 -- Function: plot2d (<expr>, <x_range>, ..., <options>, ...)
 -- Function: plot2d ([<expr_1>, ..., <expr_n>], ..., <options>, ...)
 -- Function: plot2d ([<expr_1>, ..., <expr_n>], <x_range>,...,
          <options>, ...)
     Where <expr>, <expr_1>, ..., <expr_n> can be either expressions,
     or Maxima or Lisp functions or operators, or a list with the any
     of the forms: `[discrete, [<x1>, ..., <xn>], [<y1>, ..., <yn>]]',
     `[discrete, [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]' or
     `[parametric, <x_expr>, <y_expr>, <t_range>]'.

     Displays a plot of one or more expressions as a function of one
     variable.

     `plot2d' plots one expression <expr> or several expressions
     `[<name_1>, ..., <name_n>]'. The expressions that are not of the
     parametic or discrete types should all depend only on one variable
     <var> and it will be mandatory the use of <x_range> to name that
     variable and gives its minimum and maximum values, using the
     syntax: `[<variable>, <min>, <max>]'. The plot will show the
     horizontal axis bound by the values of <min> and <max>.

     A expression to be plotted can also be given in the discrete or
     parametric forms. Namely, as a list starting with the word
     "discrete" or "parametric". The keyword <discrete> must be
     followed by two lists of values, both with the same length, which
     are the horizontal and vertical coordinates of a set of points;
     alternatively, the coordinates of each point can be put into a
     list with two values, and all the coordinates of the points should
     be inside another list. The keyword <parametric> must be followed
     by two expressions <x_expr> and <y_expr>, and a range of the form
     `[<param>, <min>, <max>]'. The two expressions must depend only on
     the parameter <param>, and the plot will show the path traced out
     by the point with coordinates (<x_expr>, <y_expr>) as <param>
     increases from <min> to <max>.

     The range of the vertical axis is not mandatory. It is one more of
     the options for the command, with the syntax: `[y, <min>, <max>]'.
     If that option is used, the plot will show that entire range, even
     if the expressions do not reach all that range. Otherwise, if a
     vertical range is not specified by `set_plot_option', the
     boundaries of the vertical axis will be set up automatically.

     All other options should also be lists, starting with the name of
     the option. The option <xlabel> can be used to give a label for the
     horizontal axis; if that option is not used, the horizontal axis
     will be labeled with the name of the variable specified in
     <x_range>, or with the expression <x_expr> in the case of just one
     parametric expresssion, or it will be left blank otherwise.

     A label for the vertical axis can be given with the <ylabel>
     option. If there is only one expression to be plotted and the
     <ylabel> option was not used, the vertical axis will be labeled
     with that expression, unless it is too large, or with the
     expression <y_expr> if the expression is parametric, or with the
     text "discrete data" if the expression is discrete.

     The options `[logx]' and `[logy]' do not need any parameters. They
     will make the horizontal and vertical axes be scaled
     logarithmically.

     If there are several expressions to be plotted, a legend will be
     written to identiy each of the expressions. The labels that should
     be used in that legend can be given with the option <legend>. If
     that option is not used, Maxima will create labels from the
     expressions.

     By default, the expressions are plotted as a set of line segments
     joining adjacent points within a set of points which is either
     given in the <discrete> form, or calculated automatically from the
     expression given, using an algorithm that atomatically adapts the
     steps among points using as an intial estimate of the total number
     of points the value set with the <nticks> option. The option
     <style> can be used to make one of the expressions to be
     represented as a set of isolated points, or as points and line
     segments.

     There are several global options stored in the list <plot_options>
     which can be modified with the function `set_plot_option'; any of
     those global options can be overriden with options given in the
     <plot2d> command.

     A function to be plotted may be specified as the name of a Maxima
     or Lisp function or operator, a Maxima lambda expression, or a
     general Maxima expression.  If specified as a name or a lambda
     expression, the function must be a function of one argument.

     Examples:

     Plots of common functions.

          (%i1) plot2d (sin(x), [x, -5, 5])$

          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Plotting functions by name.

          (%i3) F(x) := x^2 $

          (%i4) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i5) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i6) plot2d (F, [u, -1, 1])$

          (%i7) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     We can plot a circle using a parametric plot with a parameter <t>.
     It is not necessary to give a range for the horizontal range,
     since the range of the parameter <t> determines the domain.
     However, since the graph's horizontal and vertical axes lengths
     are in the 4 to 3 proportion, we will use the <xrange> option to
     obtain the same scaling in both axes:

          (%i8) plot2d ([parametric, cos(t), sin(t), [t,-%pi,%pi], [nticks,80]],
                     [x, -4/3, 4/3])$

     If we repeat that plot with only 8 points and extending the range
     of the parameter to give two turns, we will obtain the plot of a
     star:

          (%i9) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                  [nticks, 8]], [x, -2, 2], [y, -1.5, 1.5])$

     Combination of an ordinary plot of a cubic polynomial with a
     parametric plot of a circle:

          (%i10) plot2d ([x^3+2, [parametric, cos(t), sin(t), [t, -5, 5],
                  [nticks, 80]]], [x, -3, 3])$

     Example of a logarithmic plot:
          (%i11) plot2d (exp(3*s), [s, -2, 2], [logy])$

     To show some examples of discrete plots, we will start by entering
     the coordinates of 5 points, in the two different ways that can be
     used:

          (%i12) xx:[10, 20, 30, 40, 50]$
          (%i13) yy:[.6, .9, 1.1, 1.3, 1.4]$
          (%i14) xy:[[10,.6], [20,.9], [30,1.1], [40,1.3], [50,1.4]]$

     To plot those data points, joined with line segments, we use:
          (%i15) plot2d([discrete,xx,yy])$

     We will now show the plot with only points, and illustrating the
     use of the second way of giving the points coordinates:

          (%i16) plot2d([discrete, xy], [style, points])$

     The plot of the data points can be shown together with a plot of
     the theoretical function that predicts the data:

          (%i17) plot2d([[discrete,xy], 2*%pi*sqrt(l/980)], [l,0,50],
                 [style, [points,5,2,6], [lines,1,1]], [legend,"experiment","theory"],
                 [xlabel,"pendulum's length (cm)"], [ylabel,"period (s)"])$

     The meaning of the three numbers after the "points" style option
     are: 5: radius of the points, 2: color used (red), 6: type of
     objects used (solid squares). The two numbers after the "lines"
     style option give the thickness of the line (1 point) and the
     color (1 corresponds to blue).

     See also `plot_options', which describes plotting options and has
     more examples.


 -- Function: xgraph_curves (<list>)
     graphs the list of `point sets' given in list by using xgraph. If
     the program xgraph is not installed, this command will fail.

     A point set may be of the form

          [x0, y0, x1, y1, x2, y2, ...]
     or
          [[x0, y0], [x1, y1], ...]
     A point set may also contain symbols which give labels or other
     information.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     graph the three point sets as three curves.

          pt_set: append (["NoLines: True", "LargePixels: true"],
                                    [x0, y0, x1, y1, ...]);

     would make the point set (and subsequent ones), have no lines
     between points, and to use large pixels.  See the man page on
     xgraph for more options to specify.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     would make there be a "label" of "x^2+y" for this particular point
     set.    The `"' at the beginning is what tells xgraph this is a
     label.

          pt_set: append ([concat ("TitleText: Sample Data")], [x0, ...])$

     would make the main title of the plot be "Sample Data" instead of
     "Maxima Plot".

     To make a bar graph with bars which are 0.2 units wide, and to
     plot two possibly different such bar graphs:
          (%i1) xgraph_curves ([append (["BarGraph: true", "NoLines: true",
                "BarWidth: .2"], create_list ([i - .2, i^2], i, 1, 3)),
                append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
                create_list ([i + .2, .7*i^2], i, 1, 3))]);

     A temporary file `xgraph-out' is used.


 -- System variable: plot_options
     Elements of this list state the default options for plotting.  If
     an option is present in a `plot2d' or `plot3d' call, that value
     takes precedence over the default option.  Otherwise, the value in
     `plot_options' is used.  Default options are assigned by
     `set_plot_option'.

     Each element of `plot_options' is a list of two or more items.
     The first item is the name of an option, and the remainder
     comprises the value or values assigned to the option.  In some
     cases the, the assigned value is a list, which may comprise
     several items.

     The plot options which are recognized by `plot2d' and `plot3d' are
     the following:

        * Option: `plot_format'

          Determines which graphic interface is used by `plot2d' and
          `plot3d'.

             * Value: `gnuplot' default on Windows

               Gnuplot is the most advanced plotting package among the
               packages available in Maxima. It requires an external
               gnuplot installation.

             * Value: `gnuplot_pipes' default on non-Windows platforms

               Similar to the `gnuplot' format except that
               communication with gnuplot is done through a pipe. It
               should be used to plot on screen, for plotting to files
               it is better to use the `gnuplot' format.

             * Value: `mgnuplot'

               Mgnuplot is a Tk-based wrapper around gnuplot. It is
               included in the Maxima distribution. Mgnuplot offers a
               rudimentary GUI for gnuplot, but has fewer overall
               features than the plain gnuplot interface. Mgnuplot
               requires an external gnuplot installation and Tcl/Tk.

             * Value: `openmath'

               Openmath is a Tcl/Tk GUI plotting program. This format
               is provided by Xmaxima, which is distributed together
               with Maxima; in order to use this format you should
               install the package Xmaxima, and it will work not only
               from Xmaxima itself, but also from the command line and
               other GUI's for Maxima.

        * Option: `run_viewer'

          Controls whether or not the appropriate viewer for the plot
          format should be run.

             * Default value: `true'

               Execute the viewer program.

             * Value: `false'

               Do not execute the viewer program.

        * Option: `y'

          The vertical range of the plot.

          Example:

               [y, - 3, 3]
          Sets the vertical range to [-3, 3].

        * Option: `plot_realpart'

          When `plot_realpart' is `true', the real part of a complex
          value <x> is plotted; this is equivalent to plotting
          `realpart(<x>)' instead of <x>.  Otherwise, only values with
          imaginary part equal to 0 are plotted, and complex values are
          ignored.

          Example:

               plot2d (log(x), [x, -5, 5], [plot_realpart, false]);
               plot2d (log(x), [x, -5, 5], [plot_realpart, true]);
          The default value is `false'.

        * Option: `nticks'

          In plot2d, it is gives the initial number of points used by
          the adaptive plotting routine for plotting functions. It is
          also the number of points that will be shown in a parametric
          plot.

          Example:

               [nticks, 20]
          The default for `nticks' is 10.

        * Option: `adapt_depth'

          The maximum number of splittings used by the adaptive
          plotting routine.

          Example:

               [adapt_depth, 5]
          The default for `adapt_depth' is 10.

        * Option: `xlabel'

          The label for the horizontal axis in a 2d plot.

          Example:
               [xlabel, "Time in seconds"]

        * Option: `ylabel'

          The label of the vertical axis in a 2d plot.

          Example:
               [ylabel, "Temperature"]

        * Option: `logx'

          It makes the horizontal axis of a 2d plot to be rendered in a
          logarithmic scale. It does not need any aditional parameters.

        * Option: `logy'

          It makes the vertical axis of a 2d plot to be rendered in a
          logarithmic scale. It does not need any aditional parameters.

        * Option: `legend'

          The labels for the various expressions in a 2d plot with
          several expressions. If there are more expressions than the
          number of labels given, they will be repeated. If legend is
          followed by the word _false_, the legend will not be shown.
          By default, the names of the expressions or functions will be
          used for the legend, or the words discrete1, discrete2, ...,
          for discrete sets of points.

          Example:
               [legend, "Set 1", "Set 2", "Set 3"]

        * Option: `box'

          Currently, this option can only be followed by the word
          _false_, and it will be used to supress the box around the
          plot.

        * Option: `style'

          The styles that will be used for the various functions or
          sets of data in a 2d plot. The word <style> must be followed
          by one or more styles. If there are more functions and data
          sets than the styles given, the styles will be repeated. Each
          style can be either <lines> for line segments, <points> for
          isolated points, <linespoints> for segments and points, or
          <dots> for small isolated dots. Gnuplot accepts also an
          <impulses> style.

          Each of the styles can be enclosed inside a list with some
          aditional parameters. <lines> accepts one or two numbers: the
          width of the line and an integer that identifies a color. The
          default color codes are: 1: blue, 2: red, 3: magenta, 4:
          orange, 5: brown, 6: lime and 7: aqua.

          <points> accepts one two or three parameters; the first
          parameter is the radius of the points, the second parameter
          is an integer that selects the color, using the same code
          used for <lines> and the third parameter is currently used
          only by Gnuplot and it corresponds to several objects instead
          of points. The default types of objects are: 1: filled
          circles, 2: open circles, 3: plus signs, 4: x, 5: *, 6: filled
          squares, 7: open squares, 8: filled triangles, 9: open
          triangles, 10: filled inverted triangles, 11: open inverted
          triangles, 12: filled lozenges and 13: open lozenges.

          <linesdots> accepts up to four parameters: line width, points
          radius, color and type of object to replace the points.

          Example:
               [style,[lines,2,3],[points,1,4,3]]

          This will plot the first (and third, fifth, etc) expression
          with magenta line segments of width 2, and the second (and
          fourth, sixth, etc) expression with orange plus signs of size
          1 (orange circles in the case of Openmath).

          The default for the style option is <lines> with a width of
          1, and different colors.

        * Option: `grid'

          Sets the number of grid points to use in the x- and
          y-directions for three-dimensional plotting.

          Example:
               [grid, 50, 50]
          sets the grid to 50 by 50 points. The default grid is 30 by
          30.

        * Option: `transform_xy'

          Allows transformations to be applied to three-dimensional
          plots.

          Example:
               [transform_xy, false]
          The default `transform_xy' is `false'. If it is not `false',
          it should be the output of

               make_transform([x,y,z], f1(x,y,z), f2(x,y,z), f3(x,y,z))$
          The `polar_xy' transformation is built in. It gives the same
          transformation as
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

     Gnuplot options:

     There are several plot options specific to gnuplot.  Some of these
     options are raw gnuplot commands, specified as strings. Refer to
     the gnuplot documentation for more details.

        * Option: `gnuplot_term'

          Sets the output terminal type for gnuplot.
             * Default value: `default'

               Gnuplot output is displayed in a separate graphical
               window.

             * Value: `dumb'

               Gnuplot output is displayed in the Maxima console by an
               "ASCII art" approximation to graphics.

             * Value: `ps'

               Gnuplot generates commands in the PostScript page
               description language.  If the option `gnuplot_out_file'
               is set to <filename>, gnuplot writes the PostScript
               commands to <filename>.  Otherwise, it is saved as
               `maxplot.ps' file.

             * Value: any other valid gnuplot term specification

               Gnuplot can generate output in many other graphical
               formats such as png, jpeg, svg etc.  To create plot in
               all these formats the `gnuplot_term' can be set to any
               supported gnuplot term name (symbol) or even full
               gnuplot term specification with any valid options
               (string).  For example `[gnuplot_term,png]' creates
               output in PNG (Portable Network Graphics) format while
               `[gnuplot_term,"png size 1000,1000"]' creates PNG of
               1000x1000 pixels size.  If the option `gnuplot_out_file'
               is set to <filename>, gnuplot writes the output to
               <filename>. Otherwise, it is saved as `maxplot.<term>'
               file, where <term> is gnuplot terminal name.

        * Option: `gnuplot_out_file'

          Write gnuplot output to a file.

             * Default value: `false'

               No output file specified.

             * Value: <filename>

               Example: `[gnuplot_out_file, "myplot.ps"]' This example
               sends PostScript output to the file `myplot.ps' when
               used in conjunction with the PostScript gnuplot terminal.

        * Option: `gnuplot_pm3d'

          Controls the usage PM3D mode, which has advanced 3D features.
          PM3D is only available in gnuplot versions after 3.7. The
          default value for `gnuplot_pm3d' is `false'.

          Example:

               [gnuplot_pm3d, true]

        * Option: `gnuplot_preamble'

          Inserts gnuplot commands before the plot is drawn. Any valid
          gnuplot commands may be used. Multiple commands should be
          separated with a semi-colon. The example shown produces a log
          scale plot. The default value for `gnuplot_preamble' is the
          empty string `""'.

          Example:

               [gnuplot_preamble, "set log y"]

        * Option: `gnuplot_curve_titles'

          Controls the titles given in the plot key. The default value
          is `[default]', which automatically sets the title of each
          curve to the function plotted. If not `[default]',
          `gnuplot_curve_titles' should contain a list of strings, each
          of which is `"title '<title_string>'"'.  (To disable the plot
          key, add `"set nokey"' to `gnuplot_preamble'.)

          Example:

               [gnuplot_curve_titles,
               ["title 'My first function'", "title 'My second function'"]]

        * Option: `gnuplot_curve_styles'

          A list of strings controlling the appearance of curves, i.e.,
          color, width, dashing, etc., to be sent to the gnuplot plot
          command. The default value is `["with lines 3", "with lines
          1", "with lines 2", "with lines 5", "with lines 4", "with
          lines 6", "with lines 7"]', which cycles through different
          colors. See the gnuplot documentation for `plot' for more
          information.

          Example:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Option: `gnuplot_default_term_command'

          The gnuplot command to set the terminal type for the default
          terminal. The default value is `set term windows "Verdana"
          15' in Windows systems, and `set term x11 font
          "Helvetica,16"' in X11 windows systems.

          Example:

               [gnuplot_default_term_command, "set term x11"]

        * Option: `gnuplot_dumb_term_command'

          The gnuplot command to set the terminal type for the dumb
          terminal. The default value is `"set term dumb 79 22"', which
          makes the text output 79 characters by 22 characters.

          Example:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Option: `gnuplot_ps_term_command'

          The gnuplot command to set the terminal type for the
          PostScript terminal. The default value is `"set size 1.5,
          1.5;set term postscript eps enhanced color solid 24"', which
          sets the size to 1.5 times gnuplot's default, and the font
          size to 24, among other things. See the gnuplot documentation
          for `set term postscript' for more information.

          Example:

          All the figures in the examples for the <plot2d> function in
          this manual were obtained from Postscript files that were
          generated after setting `gnuplot_ps_term_command' as:

               [gnuplot_ps_term_command,
               "set size 1.3, 1.3; set term postscript eps color solid lw 2.5 30"]


     Examples:

        * Saves a plot of `sin(x)' to the file `sin.eps'.

          (%i1) plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps],
                                  [gnuplot_out_file, "sin.eps"])$

        * Uses the y option to chop off singularities and the
          gnuplot_preamble option to put the key at the bottom of the
          plot instead of the top.

          (%i2) plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10],
                               [gnuplot_preamble, "set key bottom"])$

        * Uses a very complicated `gnuplot_preamble' to produce fancy
          x-axis labels.  (Note that the `gnuplot_preamble' string must
          be entered without any line breaks.)

          (%i3) my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, \
          '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0, \
          'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$

          (%i4) plot2d([cos(x), sin(x), tan(x), cot(x)],
                 [x, -2*%pi, 2.1*%pi], [y, -2, 2],
                 [gnuplot_preamble, my_preamble]);

        * Uses a very complicated `gnuplot_preamble' to produce fancy
          x-axis labels, and produces PostScript output that takes
          advantage of the advanced text formatting available in
          gnuplot.  (Note that the `gnuplot_preamble' string must be
          entered without any line breaks.)

          (%i5) my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' \
          -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, \
          '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, \
          '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' \
          6.283)"$

          (%i6) plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble],
              [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * A three-dimensional plot using the gnuplot pm3d terminal.

          (%i7) plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [grid, 50, 50], [gnuplot_pm3d, true])$

        * A three-dimensional plot without a mesh and with contours
          projected on the bottom plane.

          (%i8) my_preamble: "set pm3d at s;unset surface;set contour;\
          set cntrparam levels 20;unset key"$
          (%i9) plot3d(atan(-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [grid, 50, 50], [gnuplot_pm3d, true],
              [gnuplot_preamble, my_preamble])$

        * A plot where the z-axis is represented by color only.  (Note
          that the `gnuplot_preamble' string must be entered without
          any line breaks.)

          (%i10) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"],
              [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Function: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <options>, ...)
 -- Function: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Function: plot3d (<name>, <x_range>, <y_range>, ..., <options>, ...)
 -- Function: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Function: plot3d ([<name_1>, <name_2>, <name_3>], <x_range>,
          <y_range>, ..., <options>, ...)
     Displays a plot of one or three expressions as functions of two
     variables.

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2]);

     plots `z = 2^(-u^2+v^2)' with `u' and `v' varying in [-3,3] and
     [-2,2] respectively, and with <u> on the x axis, and `v' on the y
     axis.

     The same graph can be plotted using openmath (if Xmaxima is
     installed):

          (%i2)  plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2],
                         [plot_format, openmath]);

     in this case the mouse can be used to rotate the plot to look at
     the surface from different sides.

     An example of the third pattern of arguments is

          (%i3) plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)),
             y*sin(x/2)], [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     which plots a Moebius band, parametrized by the three expressions
     given as the first argument to `plot3d'.  An additional optional
     argument `['grid, 50, 15]' gives the grid number of rectangles in
     the x direction and y direction.

     The function to be plotted may be specified as the name of a
     Maxima or Lisp function or operator, a Maxima lambda expression,
     or a general Maxima expression.  In the form `plot3d (<f>, ...)'
     where <f> is the name of a function or a lambda expression, the
     function must be a function of two arguments.  In the form `plot3d
     ([<f_1>, <f_2>, <f_3>], ...)' where <f_1>, <f_2>, and <f_3> are
     names of functions or lambda expressions, each function must be a
     function of three arguments.

     This example shows a plot of the real part of `z^1/3'.

          (%i4) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                ['grid, 12, 80], ['transform_xy, polar_to_xy]);

     Other examples are the Klein bottle:

          (%i5) expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0) - 10.0$
          (%i6) expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y)
                + 3.0)$
          (%i7) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$

          (%i8) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                [y, -%pi, %pi], ['grid, 40, 40]);

     and a torus:

          (%i9) expr_1: cos(y)*(10.0+6*cos(x))$
          (%i10) expr_2: sin(y)*(10.0+6*cos(x))$
          (%i11) expr_3: -6*sin(x)$
          (%i12) plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi],
                 [y, 0, 2*%pi], ['grid, 40, 40]);

     Sometimes it is necessary to define a function to plot the
     expression. All the arguments to plot3d are evaluated before being
     passed to plot3d, and so trying to make an expression which does
     just what is needed may be difficult, and it is just easier to
     make a function.

          (%i13) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                 [1, 2, 3, 3])$
          (%i14) f(x, y) := float (M [?round(x), ?round(y)])$
          (%i15) plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     See `plot_options' for more examples.


 -- Function: make_transform (<vars>, <fx>, <fy>, <fz>)
     Returns a function suitable for the transform function in plot3d.
     Use with the plot option `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     is a transformation to polar coordinates.

 -- Function: set_plot_option (<option>)
     Assigns one of the global variables for plotting.  <option> is
     specified as a list of two or more elements, in which the first
     element is one of the keywords on the `plot_options' list.

     `set_plot_option' evaluates its argument and returns the complete
     list `plot_options' (after modifying one of its elements).

     See also `plot_options', `plot2d', and `plot3d'.

     Examples:

     Modify the `grid' and `x' values.  When a `plot_options' keyword
     has an assigned value, quote it to prevent evaluation.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


8.1.1 Functions for working with the gnuplot_pipes format
---------------------------------------------------------

 -- Function: gnuplot_start ()
     Opens the pipe to gnuplot used for plotting with the
     `gnuplot_pipes' format. Is is not necessary to manually open the
     pipe before plotting.


 -- Function: gnuplot_close ()
     Closes the pipe to gnuplot which is used with the `gnuplot_pipes'
     format.


 -- Function: gnuplot_restart ()
     Closes the pipe to gnuplot which is used with the `gnuplot_pipes'
     format and opens a new pipe.


 -- Function: gnuplot_replot ()
 -- Function: gnuplot_replot (<s>)
     Updates the gnuplot window. If `gnuplot_replot' is called with a
     gnuplot command in a string <s>, then `s' is sent to gnuplot
     before reploting the window.


 -- Function: gnuplot_reset ()
     Resets the state of gnuplot used with the `gnuplot_pipes' format.
     To update the gnuplot window call `gnuplot_replot' after
     `gnuplot_reset'.



File: maxima.info,  Node: Input and Output,  Next: Floating Point,  Prev: Plotting,  Up: Top

9 Input and Output
******************

* Menu:

* Comments::
* Files::
* Definitions for Input and Output::


File: maxima.info,  Node: Comments,  Next: Files,  Prev: Input and Output,  Up: Input and Output

9.1 Comments
============

A comment in Maxima input is any text between `/*' and `*/'.

   The Maxima parser treats a comment as whitespace for the purpose of
finding tokens in the input stream; a token always ends at a comment.
An input such as `a/* foo */b' contains two tokens, `a' and `b', and
not a single token `ab'.  Comments are otherwise ignored by Maxima;
neither the content nor the location of comments is stored in parsed
input expressions.

   Comments can be nested to arbitrary depth.  The `/*' and `*/'
delimiters form matching pairs.  There must be the same number of `/*'
as there are `*/'.

   Examples:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to arbitrary depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Files,  Next: Definitions for Input and Output,  Prev: Comments,  Up: Input and Output

9.2 Files
=========

A file is simply an area on a particular storage device which contains
data or text.  Files on the disks are figuratively grouped into
"directories".  A directory is just a list of files.  Commands which
deal with files are: `save', `load', `loadfile', `stringout', `batch',
`demo', `writefile', `closefile', and `appendfile'.

