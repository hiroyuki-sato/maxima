This is maxima.info, produced by makeinfo version 4.6 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introduction to MAXIMA,  Prev: (dir),  Up: (dir)



MAXIMA is a fairly complete computer algebra system.

   This system MAXIMA is a COMMON LISP implementation due to William F.
Schelter, and is based on the original implementation of Macsyma at
MIT, as distributed by the Department of Energy.  I now have permission
from DOE to make derivative copies, and in particular to distribute it
under the GNU public license.  See the file COPYING included in the
distribution.   Thus these files may now be redistributed under the
terms of GNU public license.

* Menu:

MAXIMA infrastructure

* Introduction to MAXIMA::      Sample MAXIMA sessions.
* Help::                        Asking for help from within a MAXIMA session.
* Command Line::                MAXIMA command line syntax.
* Operators::                   Operators used in MAXIMA expressions.
* Expressions::                 Expressions in MAXIMA.
* Simplification::              Simplifying expressions.
* Plotting::                    2D and 3D graphical output.
* Input and Output::            File input and output.
* Floating Point::              Low level numerical routines.
* Contexts::                    Sets of assumed facts.

Support for specific areas of mathematics

* Polynomials::                 Standard forms for polynomials, and
                                functions operating on them.
* Constants::                   Numerical constants.
* Logarithms::                  Manipulation of expressions involving
                                logarithms.
* Trigonometric::               Manipulating expressions with trig and
                                inverse trig functions.
* Special Functions::           Special functions
* Orthogonal Polynomials::      Orthogonal Polynomials and Special functions
* Elliptic Functions::          Elliptic Functions and Integrals
* Limits::                      Limits of expressions.
* Differentiation::             Differential calculus.
* Integration::                 Integral calculus.
* Equations::                   Defining and solving equations.
* Differential Equations::      Defining and solving differential equations.
* Numerical::                   Numerical integration, Fourier
                                transforms, etc.
* Statistics::                  Statistical functions.
* Arrays and Tables::           Creating and working with arrays.
* Matrices and Linear Algebra:: Matrix operations.
* Affine::
* Tensor::                      Indicial Tensor Manipulation package.
* Ctensor::                     Component Tensor Manipulation.
* Series::                      Taylor and power series.
* Number Theory::               Number theory.
* Symmetries::
* Groups::                      Abstract algebra.

Advanced facilities and programming

* Runtime Environment::         Customization of the MAXIMA environment.
* Miscellaneous Options::       Options with a global effect on MAXIMA.
* Rules and Patterns::          User defined pattern matching and
                                simplification rules.
* Lists::                       Manipulation of Lisp lists.
* Function Definition::         Defining functions.
* Program Flow::                Defining MAXIMA programs.
* Debugging::                   Debugging MAXIMA programs.

Index

* Function and Variable Index:: Index.

 --- The Detailed Node Listing ---

Introduction

* Introduction to MAXIMA::

Help

* Introduction to Help::
* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::

Command Line

* Introduction to Command Line::
* Definitions for Command Line::

Operators

* NARY::
* NOFIX::
* OPERATOR::
* POSTFIX::
* PREFIX::
* Definitions for Operators::

Expressions

* Introduction to Expressions::
* ASSIGNMENT::
* COMPLEX::
* INEQUALITY::
* SYNTAX::
* Definitions for Expressions::

Simplification

* Definitions for Simplification::

Plotting

* Definitions for Plotting::

Input and Output

* Introduction to Input and Output::
* FILES::
* PLAYBACK::
* Definitions for Input and Output::

Floating Point

* Definitions for Floating Point::

Contexts

* Definitions for Contexts::

Polynomials

* Introduction to Polynomials::
* Definitions for Polynomials::

Constants

* Definitions for Constants::

Logarithms

* Definitions for Logarithms::

Trigonometric

* Introduction to Trigonometric::
* Definitions for Trigonometric::

Special Functions

* Introduction to Special Functions::
* GAMALG::
* SPECINT::
* Definitions for Special Functions::

Orthogonal Polynomials

* Introduction to Orthogonal Polynomials::
* Definitions for Orthogonal Polynomials::

Elliptic Functions

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::

Limits

* Definitions for Limits::

Differentiation

* Definitions for Differentiation::

Integration

* Introduction to Integration::
* Definitions for Integration::

Equations

* Definitions for Equations::

Differential Equations

* Definitions for Differential Equations::

Numerical

* Introduction to Numerical::
* DCADRE::
* ELLIPT::
* FOURIER::
* NDIFFQ::
* Definitions for Numerical::

Statistics

* Definitions for Statistics::

Arrays and Tables

* Definitions for Arrays and Tables::

Matrices and Linear Algebra

* Introduction to Matrices and Linear Algebra::
* DOT::
* VECTORS::
* Definitions for Matrices and Linear Algebra::

Affine

* Definitions for Affine::

Tensor

* Introduction to Tensor::
* Definitions for Tensor::

Ctensor

* Introduction to Ctensor::
* Definitions for Ctensor::

Series

* Introduction to Series::
* Definitions for Series::

Number Theory

* Definitions for Number Theory::

Symmetries

* Definitions for Symmetries::

Groups

* Definitions for Groups::

Runtime Environment

* Introduction for Runtime Environment::
* INTERRUPTS::
* Definitions for Runtime Environment::

Miscellaneous Options

* Introduction to Miscellaneous Options::
* SHARE::
* Definitions for Miscellaneous Options::

Rules and Patterns

* Introduction to Rules and Patterns::
* Definitions for Rules and Patterns::

Lists

* Introduction to Lists::
* Definitions for Lists::

Function Definition

* Introduction to Function Definition::
* FUNCTION::
* MACROS::
* OPTIMIZATION::
* Definitions for Function Definition::

Program Flow

* Introduction to Program Flow::
* Definitions for Program Flow::

Debugging

* Definitions for Debugging::


File: maxima.info,  Node: Introduction to MAXIMA,  Next: Help,  Prev: Top,  Up: Top

Introduction to MAXIMA
**********************

Start MAXIMA with the command "maxima".  MAXIMA will display version
information and a prompt.  End each MAXIMA command with a semicolon.
End the session with the command "quit();".  Here's a sample session:

     sonia$ maxima
     GCL (GNU Common Lisp)  Version(2.3) Tue Mar 21 14:15:15 CST 2000
     Licensed under GNU Library General Public License
     Contains Enhancements by W. Schelter
     Maxima 5.4 Tue Mar 21 14:14:45 CST 2000 (enhancements by W. Schelter)
     Licensed under the GNU Public License (see file COPYING)
     (C1) factor(10!);
     
                                        8  4  2
     (D1)                              2  3  5  7
     (C2) expand((x+y)^6);
     
                6        5       2  4       3  3       4  2      5      6
     (D2)      y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (C3) factor(x^6-1);
     
                                          2            2
     (D3)               (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (C4) quit();
     
     sonia$

   MAXIMA can search the info pages.  Use the `describe' command to show
all the commands and variables containing a string, and optionally their
documentation:

     (C1) describe(factor);
     
     
      0: DONTFACTOR :(maxima.info)Definitions for Matrices and ..
      1: EXPANDWRT_FACTORED :Definitions for Simplification.
      2: FACTOR :Definitions for Polynomials.
      3: FACTORFLAG :Definitions for Polynomials.
      4: FACTORIAL :Definitions for Number Theory.
      5: FACTOROUT :Definitions for Polynomials.
      6: FACTORSUM :Definitions for Polynomials.
      7: GCFACTOR :Definitions for Polynomials.
      8: GFACTOR :Definitions for Polynomials.
      9: GFACTORSUM :Definitions for Polynomials.
      10: MINFACTORIAL :Definitions for Number Theory.
      11: NUMFACTOR :Definitions for Special Functions.
      12: SAVEFACTORS :Definitions for Polynomials.
      13: SCALEFACTORS :Definitions for Miscellaneous Options.
      14: SOLVEFACTORS :Definitions for Equations.
     Enter n, all, none, or multiple choices eg 1 3 : 2 8;
     
     Info from file /d/linux/local/lib/maxima-5.4/info/maxima.info:
      - Function: FACTOR (EXP)
          factors the expression exp, containing any number of variables or
          functions, into factors irreducible over the integers.
          FACTOR(exp, p) factors exp over the field of integers with an
          element adjoined whose minimum polynomial is p.  FACTORFLAG[FALSE]
          if FALSE suppresses the factoring of integer factors of rational
          expressions.  DONTFACTOR may be set to a list of variables with
          respect to which factoring is not to occur.  (It is initially
          empty).  Factoring also will not take place with respect to any
          variables which are less important (using the variable ordering
          assumed for CRE form) than those on the DONTFACTOR list.
          SAVEFACTORS[FALSE] if TRUE causes the factors of an expression
          which is a product of factors to be saved by certain functions in
          order to speed up later factorizations of expressions containing
          some of the same factors.  BERLEFACT[TRUE] if FALSE then the
          Kronecker factoring algorithm will be used otherwise the Berlekamp
          algorithm, which is the default, will be used.  INTFACLIM[1000] is
          the largest divisor which will be tried when factoring a bignum
          integer.  If set to FALSE (this is the case when the user calls
          FACTOR explicitly), or if the integer is a fixnum (i.e.  fits in
          one machine word), complete factorization of the integer will be
          attempted.  The user's setting of INTFACLIM is used for internal
          calls to FACTOR. Thus, INTFACLIM may be reset to prevent MACSYMA
          from taking an inordinately long time factoring large integers.
          NEWFAC[FALSE] may be set to true to use the new factoring routines.
          Do EXAMPLE(FACTOR); for examples.
     
     
      - Function: GFACTOR (EXP)
          factors the polynomial exp over the Gaussian integers (i.  e.
          with SQRT(-1) = %I adjoined).  This is like FACTOR(exp,A**2+1)
          where A is %I.
               (C1)  GFACTOR(X**4-1);
               (D1)        (X - 1) (X + 1) (X + %I) (X - %I)
     (D1) 				     FALSE

   To use a result in later calculations, you can assign it to a
variable or refer to it by its automatically supplied label.  In
addition, `%' refers to the most recent calculated result:

     (C2) u:expand((x+y)^6);
     
                6        5       2  4       3  3       4  2      5      6
     (D2)     y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (C3) diff(u,x);
     
                     5         4       2  3       3  2       4        5
     (D3)        6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (C4) factor(d3);
     
                                                5
     (D4)                             6 (y + x)

   MAXIMA knows about complex numbers and numerical constants:

     (C6) cos(%pi);
     
     (D6)                                  - 1
     
     (C7) %e^(%i*%pi);
     
     (D7)                                  - 1

   MAXIMA can do differential and integral calculus:

     (C8) u:expand((x+y)^6);
     
                6        5       2  4       3  3       4  2      5      6
     (D8)     y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (C9) diff(%,x);
     
                     5         4       2  3       3  2       4        5
     (D9)        6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (C10) integrate(1/(1+x^3),x);
     
                                              2 x - 1
                            2            ATAN(-------)
                       LOG(x  - x + 1)        SQRT(3)    LOG(x + 1)
     (D10)           - --------------- + ------------- + ----------
                              6             SQRT(3)          3

   MAXIMA can solve linear systems and cubic equations:

     (C11) linsolve( [ 3*x + 4*y = 7, 2*x + a*y = 13], [x,y]);
     
                                    7 a - 52        25
     (D11)                     [x = --------, y = -------]
                                    3 a - 8       3 a - 8
     (C12) solve( x^3 - 3*x^2 + 5*x = 15, x);
     
     (D12)              [x = - SQRT(5) %I, x = SQRT(5) %I, x = 3]

   MAXIMA can solve nonlinear sets of equations.  Note that if you don't
want a result printed, you can finish your command with `$' instead of
`;'.

     (C13) eq1: x^2 + 3*x*y + y^2 = 0$
     
     (C14) eq2: 3*x + y = 1$
     
     (C15) solve([eq1, eq2]);
     
                   3 SQRT(5) + 7      SQRT(5) + 3
     (D15) [[y = - -------------, x = -----------],
                         2                 2
     
                                         3 SQRT(5) - 7        SQRT(5) - 3
                                    [y = -------------, x = - -----------]]
                                               2                   2

   Under the X window system, MAXIMA can generate plots of one or more
functions:

     (C13) plot2d(sin(x)/x,[x,-20,20]);
     
     
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (D13)                                  0
     (C14) plot2d([atan(x), erf(x), tanh(x)], [x,-5,5]);
     
     
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (D14)                                  0
     (C15) plot3d(sin(sqrt(x^2+y^2))/sqrt(x^2+y^2),[x,-12,12],[y,-12,12]);
     
     (D15)                                  0

   Moving the cursor to the top left corner of the plot window will pop
up a menu that will, among other things, let you generate a PostScript
file of the plot.  (By default, the file is placed in your home
directory.)  You can rotate a 3D plot.


File: maxima.info,  Node: Help,  Next: Command Line,  Prev: Introduction to MAXIMA,  Up: Top

Help
****

* Menu:

* Introduction to Help::
* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::


File: maxima.info,  Node: Introduction to Help,  Next: Lisp and Maxima,  Prev: Help,  Up: Help

Introduction to Help
====================

The most useful online help command is DESCRIBE which obtains help on
all commands containing a particular string.  Here by command we mean a
built in operator such as INTEGRATE or FACTOR etc.   As a typing short
cut you may type `? fact' in lieu of `describe("fact")'
     (C3) ? inte;
     
     
      0: (maxima.info)Integration.
      1: Introduction to Integration.
      2: Definitions for Integration.
      3: INTERRUPTS.
      4: ASKINTEGER :Definitions for Simplification.
      5: DISPLAY_FORMAT_INTERNAL :Definitions for Input and Output.
      6: INTEGERP :Definitions for Miscellaneous Options.
      7: INTEGRATE :Definitions for Integration.
      8: INTEGRATION_CONSTANT_COUNTER :Definitions for Integration.
      9: INTERPOLATE :Definitions for Numerical.
     Enter n, all, none, or multiple choices eg 1 3 : 7 8;
     
     Info from file /d/linux2/local/share/info/maxima.info:
      - Function: INTEGRATE (EXP, VAR)
          integrates exp with respect to var or returns an integral
          expression (the noun form) if it cannot perform the integration
          (see note 1 below).  Roughly speaking three stages are used:
     ...
   In the above the user said he wanted items 7 and 8.  Note the `;'
following the two numbers.  He might have typed `all' to see help on
all the items.


File: maxima.info,  Node: Lisp and Maxima,  Next: Garbage Collection,  Prev: Introduction to Help,  Up: Help

Lisp and Maxima
===============

All of Maxima is of course written in lisp.  There is a naming
convention for functions and variables:  All symbols which begin with a
"$" sign at lisp level, are read with the "$" sign stripped off at
Macsyma level.  For example, there are two lisp functions TRANSLATE and
$TRANSLATE.   If at macsyma level you enter TRANSLATE(FOO); the
function which is called is the $translate function.  To access the
other function you must prefix with a "?".   Note you may not put a
space after the `?' since that would indicate you were looking for help!

     (C1) ?TRANSLATE(FOO);

   Of course, this may well not do what you wanted it to do since it is
a completely different function.

   To enter a lisp command you may use
     (C1) :lisp (foo 1 2)
   or to get a lisp prompt use `to_lisp();', or alternately type
`Ctrl-c' to enter into a debug break.  This will cause a lisp break
loop to be entered.  You could now evaluate $d2 and view the value of
the line label D2, in its internal lisp format.   Typing `:q' will quit
to top level, if you are in a debug break.  If you had exited maxima
with `to_lisp();' then you should type
     MAXIMA>(run)
   at the lisp prompt, to restart the Maxima session.

   If you intend to write lisp functions to be called at macsyma level
you should name them by names beginning with a "$".   Note that all
symbols typed at lisp level are automatically read in upper case,
unless you do something like `|$odeSolve|' to force the case to be
respected.   Maxima interprets symbols as mixed case, if the symbol has
already been read before or at the time it was first read there was not
an already existing symbol with the same letters but upper case only.
Thus if you type
     (C1) Integrate;
     (D1) INTEGRATE
     (C2) Integ;
     (D2) Integ
   The symbol `Integrate' already existed in upper case since it is a
Maxima primitive, but INTEG, does not already exist, so the Integ is
permitted.   This may seem a little bizarre, but we wish to keep old
maxima code working, which assumes that Maxima primitives may be in
upper or lower case.   An advantage of this system is that if you type
in lower case, you will immediately see which are the maxima keywords
and functions.

   To enter Maxima forms at lisp level, you may use the `#$' macro.
                               (setq $foo #$[x,y]$)

   This will have the same effect as entering

     (C1)FOO:[X,Y];

except that foo will not appear in the VALUES list.  In order to view
foo in macsyma printed format you may type

     (displa $foo)

   In this documentation when we wish to refer to a macsyma symbol we
shall generally omit the $ just as you would when typing at macsyma
level.  This will cause confusion when we also wish to refer to a lisp
symbol.  In this case we shall usually try to use lower case for the
lisp symbol and upper case for the macsyma symbol.  For example LIST
for $list and list for the lisp symbol whose printname is "list".

   Since functions defined using the MAXIMA language are not ordinary
lisp functions, you must use mfuncall to call them.  For example:

     (D2)                        FOO(X, Y) := X + Y + 3

then at lisp level

     CL-MAXIMA>>(mfuncall '$foo 4 5)
     12

   A number of lisp functions are shadowed in the maxima package.  This
is because their use within maxima is not compatible with the
definition as a system function.  For example typep behaves differently
common lisp than it did in Maclisp.  If you want to refer to the zeta
lisp typep while in the maxima package you should use global:typep (or
cl:typep for common lisp).  Thus


       (macsyma:typep '(1 2)) ==> 'list
       (lisp:typep '(1 2))==> error (lisp:type-of '(1 2))==> 'cons

   To see which symbols are shadowed look in "src/maxima-package.lisp"
or do a describe of the package at lisp level.


File: maxima.info,  Node: Garbage Collection,  Next: Documentation,  Prev: Lisp and Maxima,  Up: Help

Garbage Collection
==================

Symbolic computation tends to create a good deal of garbage, and
effective handling of this can be crucial to successful completion of
some programs.

   Under GCL, on UNIX systems where the mprotect system call is
available (including SUN OS 4.0 and some variants of BSD) a stratified
garbage collection is available.   This limits the collection to pages
which have been recently written to.    See the GCL documentation under
ALLOCATE and GBC.   At the lisp level doing (setq si::*notify-gbc* t)
will help you determine which areas might need more space.


File: maxima.info,  Node: Documentation,  Next: Definitions for Help,  Prev: Garbage Collection,  Up: Help

Documentation
=============

The source for the documentation is in `.texi' texinfo format.  From
this format we can produce the info files used by the online commands
`? ' and `describe'.   Also `html' and `pdf' files can be produced.

   Additionally there are examples so that you may do
     example(integrate);
     (C4) example(integrate);
     (C5) test(f):=BLOCK([u],u:INTEGRATE(f,x),RATSIMP(f-DIFF(u,x)));
     (D5) test(f) := BLOCK([u], u :
              INTEGRATE(f, x), RATSIMP(f - DIFF(u, x)));
     (C6) test(SIN(x));
     (D6) 						       0
     (C7) test(1/(x+1));
     (D7) 						       0
     (C8) test(1/(x^2+1));
     (D8) 						       0
     (C9) INTEGRATE(SIN(X)^3,X);


File: maxima.info,  Node: Definitions for Help,  Prev: Documentation,  Up: Help

Definitions for Help
====================

 - Function: DEMO (file)
     this is the same as BATCH but pauses after each command line and
     continues when a space is typed (you may need to type `;' followed
     by a newline, if running under xmaxima).   The demo files have
     suffix `.dem'


 - Function: DESCRIBE (cmd)
     This command prints documentation on all commands which contain
     the substring "cmd".   Thus
          (C1) describe("integ");
           0: (maxima.info)Integration.
           1: Introduction to Integration.
           2: Definitions for Integration.
           3: ASKINTEGER :Definitions for Simplification.
          ..
          Enter n, all, none, or multiple choices eg 1 3 : 2 3;
          Info from file /d/linux2/local/share/info/maxima.info:
          Definitions for Integration
          ===========================
          
           - Function: CHANGEVAR (EXP,F(X,Y),Y,X)
          ...
     *note Introduction to Help::


 - Function: EXAMPLE (command)
     will start up a demonstration of how command works on some
     expressions.  After each command line it will pause and wait for a
     space to be typed, as in the DEMO command.

     The name of the file containing the examples is given by the
     variable manual_demo, which defaults to "maxima.demo".



File: maxima.info,  Node: Command Line,  Next: Operators,  Prev: Help,  Up: Top

Command Line
************

* Menu:

* Introduction to Command Line::
* Definitions for Command Line::


File: maxima.info,  Node: Introduction to Command Line,  Next: Definitions for Command Line,  Prev: Command Line,  Up: Command Line

Introduction to Command Line
============================

 - Function: %TH (i)
     is the ith previous computation.  That is, if the next expression
     to be computed is D(j) this is D(j-i).  This is useful in BATCH
     files or for referring to a group of D expressions.  For example,
     if SUM is initialized to 0 then FOR I:1 THRU 10 DO SUM:SUM+%TH(I)
     will set SUM to the sum of the last ten D expressions.


 - operator: "'"
     - (single quote) has the effect of preventing evaluation.  E.g.
     '(F(X)) means do not evaluate the expression F(X).  'F(X) means
     return the noun form of F applied to [X].


 - operator: """
     - (two single quotes) causes an extra evaluation to occur.  E.g.
     "c4; will re-execute line C4.  "(F(X)) means evaluate the
     expression F(X) an extra time.  "F(X) means return the verb form
     of F applied to [X].



File: maxima.info,  Node: Definitions for Command Line,  Prev: Introduction to Command Line,  Up: Command Line

Definitions for Command Line
============================

 - Function: ALIAS (newname1, oldname1, newname2, oldname2, ...)
     provides an alternate name for a (user or system) function,
     variable, array, etc.  Any even number of arguments may be used.


 - Function: DEBUG ()
     LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG(); make available to
     the user debugging features used by systems programmers.  These
     tools are powerful, and although some conventions are different
     from the usual macsyma level it is felt their use is very
     intuitive.  [Some printout may be verbose for slow terminals,
     there are switches for controlling this.]  These commands were
     designed for the user who must debug translated macsyma code, as
     such they are a boon.  See MACDOC;TRDEBG USAGE for more
     information.


 - Variable: DEBUGMODE
     default: [FALSE] - causes MACSYMA to enter a MACSYMA break loop
     whenever a MACSYMA error occurs if it is TRUE and to terminate
     that mode if it is FALSE.  If it is set to ALL then the user may
     examine BACKTRACE for the list of functions currently entered.


 - Function: DEBUGPRINTMODE ()
     LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG(); make available to
     the user debugging features used by systems programmers.  These
     tools are powerful, and although some conventions are different
     from the usual macsyma level it is felt their use is very
     intuitive.  [Some printout may be verbose for slow terminals,
     there are switches for controlling this.]  These commands were
     designed for the user who must debug translated macsyma code, as
     such they are a boon.  See MACDOC;TRDEBG USAGE for more
     information.


 - Function: EV (exp, arg1, ..., argn)
     is one of MACSYMA's most powerful and versatile commands. It
     evaluates the expression exp in the environment specified by the
     argi.  This is done in steps, as follows:
        *     (1) First the environment is set up by scanning the argi
          which may be as follows: SIMP causes exp to be simplified
          regardless of the setting of the switch SIMP which inhibits
          simplification if FALSE.  NOEVAL supresses the evaluation
          phase of EV (see step (4) below).  This is useful in
          conjunction with the other switches and in causing exp to be
          resimplified without being reevaluated.  EXPAND causes
          expansion.  EXPAND(m,n) causes expansion, setting the values
          of MAXPOSEX and MAXNEGEX to m and n respectively.  DETOUT
          causes any matrix inverses computed in exp to have their
          determinant kept outside of the inverse rather than dividing
          through each element.  DIFF causes all differentiations
          indicated in exp to be performed.  DERIVLIST(var1,...,vark)
          causes only differentiations with respect to the indicated
          variables.  FLOAT causes non-integral rational numbers to be
          converted to floating point.  NUMER causes some mathematical
          functions (including exponentiation) with numerical arguments
          to be evaluated in floating point.  It causes variables in
          exp which have been given numervals to be replaced by their
          values.  It also sets the FLOAT switch on.  PRED causes
          predicates (expressions which evaluate to TRUE or FALSE) to
          be evaluated.  EVAL causes an extra post-evaluation of exp to
          occur. (See step (5) below.)  E where E is an atom declared
          to be an EVFLAG causes E to be bound to TRUE during the
          evaluation of exp.  V:expression (or alternately
          V=expression) causes V to be bound to the value of expression
          during the evaluation of exp.  Note that if V is a MACSYMA
          option, then expression is used for its value during the
          evaluation of exp.  If more than one argument to EV is of
          this type then the binding is done in parallel.  If V is a
          non-atomic expression then a substitution rather than a
          binding is performed.  E where E, a function name, has been
          declared to be an EVFUN causes E to be applied to exp.  Any
          other function names (e.g.  SUM) cause evaluation of
          occurrences of those names in exp as though they were verbs.
          In addition a function occurring in exp (say F(args)) may be
          defined locally for the purpose of this evaluation of exp by
          giving F(args):=body as an argument to EV.  If an atom not
          mentioned above or a subscripted variable or subscripted
          expression was given as an argument, it is evaluated and if
          the result is an equation or assignment then the indicated
          binding or substitution is performed.  If the result is a
          list then the members of the list are treated as if they were
          additional arguments given to EV. This permits a list of
          equations to be given (e.g. [X=1, Y=A**2] ) or a list of
          names of equations (e.g.  [E1,E2] where E1 and E2 are
          equations) such as that returned by SOLVE.  The argi of EV
          may be given in any order with the exception of substitution
          equations which are handled in sequence, left to right, and
          EVFUNS which are composed, e.g. EV(exp,RATSIMP,REALPART) is
          handled as REALPART(RATSIMP(exp)).  The SIMP, NUMER, FLOAT,
          and PRED switches may also be set locally in a block, or
          globally at the "top level" in MACSYMA so that they will
          remain in effect until being reset.  If exp is in CRE form
          then EV will return a result in CRE form provided the NUMER
          and FLOAT switches are not both TRUE.

        *     (2) During step (1), a list is made of the non-subscripted
          variables appearing on the left side of equations in the argi
          or in the value of some argi if the value is an equation.
          The variables (both subscripted variables which do not have
          associated array functions, and non-subscripted variables) in
          the expression exp are replaced by their global values,
          except for those appearing in this list.  Usually, exp is
          just a label or % (as in (C2) below), so this step simply
          retrieves the expression named by the label, so that EV may
          work on it.

        *     (3) If any substitutions are indicated by the argi, they
          are carried out now.

        *     (4) The resulting expression is then re-evaluated (unless
          one of the argi was NOEVAL) and simplified according the the
          argi.  Note that any function calls in exp will be carried
          out after the variables in it are evaluated and that EV(F(X))
          thus may behave like F(EV(X)).

        *     (5) If one of the argi was EVAL, steps (3) and (4) are
          repeated.

                               Examples
          
          (C1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
                                  d                 2
          (D1)  COS(Y) + SIN(X) + -- SIN(W) + (W + 1)
                                  dW
          (C2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
                              2
          (D2)      COS(W) + W  + 2 W + COS(1) + 1.90929742

     An alternate top level syntax has been provided for EV, whereby one
     may just type in its arguments, without the EV().  That is, one may
     write simply
          exp, arg1, ...,argn.

     This is not permitted as part of another expression, i.e. in
     functions, blocks, etc.

          (C4) X+Y,X:A+Y,Y:2;
          (D4)                Y + A + 2
          (Notice the parallel binding process)
          (C5) 2*X-3*Y=3$
          (C6) -3*X+2*Y=-4$
          (C7) SOLVE([D5,D6]);
          SOLUTION
                                          1
          (E7)                     Y =  - -
                                          5
                                    6
          (E8)                  X = -
                                    5
          (D8)               [E7, E8]
          (C9) D6,D8;
          (D9)               - 4 =  - 4
          (C10) X+1/X > GAMMA(1/2);
                              1
          (D10)           X + - > SQRT(%PI)
                              X
          (C11) %,NUMER,X=1/2;
          (D11)            2.5 > 1.7724539
          (C12) %,PRED;
          (D12)                  TRUE


 - Variable: EVFLAG
     default: [] - the list of things known to the EV function.  An
     item will be bound to TRUE during the execution of EV if it is
     mentioned in the call to EV, e.g. EV(%,numer);.  Initial evflags
     are

          FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE,
          KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
          RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER,
          RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER,
          PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
          EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM,
          NUMER_PBRANCH, M1PBRANCH, DOTSCRULES, and LOGEXPAND.


 - Variable: EVFUN
     - the list of functions known to the EV function which will get
     applied if their name is mentioned.  Initial evfuns are FACTOR,
     TRIGEXPAND, TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, RADCAN,
     LOGCONTRACT, RECTFORM, and POLARFORM.


 - special symbol: INFEVAL
     leads to an "infinite evaluation" mode.  EV repeatedly evaluates
     an expression until it stops changing.  To prevent a variable, say
     X, from being evaluated away in this mode, simply include X='X as
     an argument to EV.  Of course expressions such as
     EV(X,X=X+1,INFEVAL); will generate an infinite loop.  CAVEAT
     EVALUATOR.


 - Function: KILL (arg1, arg2, ...)
     eliminates its arguments from the MACSYMA system.  If argi is a
     variable (including a single array element), function, or array,
     the designated item with all of its properties is removed from
     core.  If argi=LABELS then all input, intermediate, and output
     lines to date (but not other named items) are eliminated. If
     argi=CLABELS then only input lines will be eliminated; if
     argi=ELABELS then only intermediate E-lines will be eliminated; if
     argi=DLABELS only the output lines will be eliminated.  If argi is
     the name of any of the other information lists (the elements of
     the MACSYMA variable INFOLISTS), then every item in that class
     (and its properties) is KILLed and if argi=ALL then every item on
     every information list previously defined as well as LABELS is
     KILLed.  If argi=a number (say n), then the last n lines (i.e. the
     lines with the last n line numbers) are deleted.  If argi is of
     the form [m,n] then all lines with numbers between m and n
     inclusive are killed. Note that KILL(VALUES) or KILL(variable)
     will not free the storage occupied unless the labels which are
     pointing to the same expressions are also KILLed.  Thus if a large
     expression was assigned to X on line C7 one should do KILL(D7) as
     well as KILL(X) to release the storage occupied.
     KILL(ALLBUT(name1,...,namek) will do a KILL(ALL) except it will not
     KILL the names specified.  (Note: namei means a name such as U, V,
     F, G, not an infolist such as FUNCTIONS.)      KILL removes all
     properties from the given argument thus KILL(VALUES) will kill all
     properties associated with every item on the VALUES list whereas
     the REMOVE set of functions
     (REMVALUE,REMFUNCTION,REMARRAY,REMRULE) remove a specific property.
     Also the latter print out a list of names or FALSE if the specific
     argument doesn't exist whereas KILL always has value "DONE" even if
     the named item doesn't exist.      Note that killing expressions
     will not help the problem which occurs on MC indicated by "NO CORE
     - FASLOAD" which results when either too many FASL files have been
     loaded in or when allocation level has gotten too high.  In either
     of these cases, no amount of killing will cause the size of these
     spaces to decrease.  Killing expressions only causes some spaces
     to get emptied out but not made smaller.


 - Function: LABELS (char)
     takes a char C, D, or E as arg and generates a list of all
     C-labels, D-labels, or E- labels, respectively.  If you've
     generated many E- labels via SOLVE, then
          FIRST(REST(LABELS(C)))
     reminds you what the last C-label was.  LABELS will take as arg
     any symbolic name, so if you have reset INCHAR, OUTCHAR, or
     LINECHAR, it will return the list of labels whose first character
     matches the first character of the arg you give to LABELS.  The
     variable, LABELS, default: [], is a list of C, D, and E lines
     which are bound.


 - Variable: LASTTIME
     - the time to compute the last expression in milliseconds
     presented as a list of "time" and "gctime".


 - Variable: LINENUM
     - the line number of the last expression.


 - Variable: MYOPTIONS
     default: [] - all options ever reset by the user (whether or not
     they get reset to their default value).


 - Variable: NOLABELS
     default: [FALSE] - if TRUE then no labels will be bound except for
     E lines generated by the solve functions.  This is most useful in
     the "BATCH" mode where it eliminates the need to do KILL(LABELS)
     in order to free up storage.


 - Variable: OPTIONSET
     default: [FALSE] - if TRUE, MACSYMA will print out a message
     whenever a MACSYMA option is reset.  This is useful if the user is
     doubtful of the spelling of some option and wants to make sure
     that the variable he assigned a value to was truly an option
     variable.


 - Function: PLAYBACK (arg)
     "plays back" input and output lines.  If arg=n (a number) the last
     n expressions (Ci, Di, and Ei count as 1 each) are "played-back",
     while if arg is omitted, all lines are.  If arg=INPUT then only
     input lines are played back. If arg=[m,n] then all lines with
     numbers from m to n inclusive are played-back.  If m=n then [m] is
     sufficient for arg.  Arg=SLOW places PLAYBACK in a slow-mode
     similar to DEMO's (as opposed to the "fast" BATCH).  This is
     useful in conjunction with SAVE or STRINGOUT when creating a
     secondary-storage file in order to pick out useful expressions.
     If arg=TIME then the computation times are displayed as well as
     the expressions.  If arg=GCTIME or TOTALTIME, then a complete
     breakdown of computation times are displayed, as with
     SHOWTIME:ALL;.  Arg=STRING strings-out (see STRING function) all
     input lines when playing back rather than displaying them.  If
     ARG=GRIND "grind" mode can also be turned on (for processing input
     lines) (see GRIND).  One may include any number of options as in
     PLAYBACK([5,10],20,TIME,SLOW).


 - Function: PRINTPROPS (a, i)
     will display the property with the indicator i associated with the
     atom a. a may also be a list of atoms or the atom ALL in which
     case all of the atoms with the given property will be used.  For
     example, PRINTPROPS([F,G],ATVALUE).  PRINTPROPS is for properties
     that cannot otherwise be displayed, i.e. for ATVALUE, ATOMGRAD,
     GRADEF, and MATCHDECLARE.


 - Variable: PROMPT
     default: [_] is the prompt symbol of the DEMO function,
     PLAYBACK(SLOW) mode, and (MACSYMA-BREAK).


 - Function: QUIT ()
     kills the current MACSYMA but doesn't affect the user's other
     jobs;  equivalent to exiting to DCL and stopping the MACSYMA
     process.  One may "quit" to MACSYMA top-level by typing Control-C
     Control-G; Control-C gets NIL's interrupt prompt, at which one
     types either Control-G or just G.  Typing X at the Interrupt
     prompt will cause a quit in a computation started within a
     MACSYMA-BREAK without disrupting the suspended main computation.


 - Function: REMFUNCTION (f1, f2, ...)
     removes the user defined functions f1,f2,... from MACSYMA.  If
     there is only one argument of ALL then all functions are removed.


 - Function: RESET ()
     causes all MACSYMA options to be set to their default values.
     (Please note that this does not include features of terminals such
     as LINEL which can only be changed by assignment as they are not
     considered to be computational features of MACSYMA.)


 - Function: RESTORE (file-specification)
     reinitializes all quantities filed away by a use of the SAVE or
     STORE functions, in a prior MACSYMA session, from the file given
     by file-specification without bringing them into core.


 - Variable: SHOWTIME
     default: [FALSE] - if TRUE then the computation time will be
     printed automatically with each output expression.  By setting
     SHOWTIME:ALL, in addition to the cpu time MACSYMA now also prints
     out (when not zero) the amount of time spent in garbage collection
     (gc) in the course of a computation.  This time is of course
     included in the time printed out as "time=" .  (It should be noted
     that since the "time=" time only includes computation time and not
     any intermediate display time or time it takes to load in
     out-of-core files, and since it is difficult to ascribe
     "responsibility" for gc's, the gctime printed will include all
     gctime incurred in the course of the computation and hence may in
     rare cases even be larger than "time=").


 - Function: SSTATUS (feature,package)
     - meaning SET STATUS.  It can be used to SSTATUS( FEATURE,
     HACK_PACKAGE) so that STATUS( FEATURE, HACK_PACKAGE) will then
     return TRUE.  This can be useful for package writers, to keep
     track of what FEATURES they have loaded in.


 - Function: TOBREAK ()
     causes the MACSYMA break which was left by typing TOPLEVEL; to be
     re-entered.  If TOBREAK is given any argument whatsoever, then the
     break will be exited, which is equivalent to typing TOBREAK()
     immediately followed by EXIT;.


 - Function: TOPLEVEL ()
     During a break one may type TOPLEVEL;.  This will cause top-level
     MACSYMA to be entered recursively.  Labels will now be bound as
     usual.  Everything will be identical to the previous top-level
     state except that the computation which was interrupted is saved.
     The function TOBREAK() will cause the break which was left by
     typing TOPLEVEL; to be re-entered.  If TOBREAK is given any
     argument whatsoever, then the break will be exited, which is
     equivalent to typing TOBREAK() immediately followed by EXIT;.


 - Function: TO_LISP ()
     enters the LISP system under MACSYMA.  This is useful on those
     systems where control-uparrow is not available for this function.


 - Variable: TTYINTFUN
     default: [FALSE] - Governs the function which will be run whenever
     the User-interrupt-character is typed.  To use this feature, one
     sets TTYINTFUN (default FALSE meaning feature not in use) to a
     function of no arguments.  Then whenever (e.g.) ^U (control-U) is
     typed, this function is run.  E.g. suppose you have a FOR statement
     loop which increments I, and you want an easy way of checking on
     the value of I while the FOR statement is running.  You can do:
     TTYINTFUN:PRINTI$ PRINTI():=PRINT(I)$ , then whenever you type
     (e.g.)  ^U you get the check you want.


 - Variable: TTYINTNUM
     default: [21] (the ascii value of Control-U (^U), U being the 21st
     letter of the alphabet).  This controls what character becomes the
     User-interrupt-character.  ^U was chosen for it mnemonic value.
     Most users should not reset TTYINTNUM unless they are already
     using ^U for something else.


 - Variable: VALUES
     default:[] - all bound atoms, i.e. user variables, not MACSYMA
     Options or Switches, (set up by : , :: , or functional binding).



File: maxima.info,  Node: Operators,  Next: Expressions,  Prev: Command Line,  Up: Top

Operators
*********

* Menu:

* NARY::
* NOFIX::
* OPERATOR::
* POSTFIX::
* PREFIX::
* Definitions for Operators::


File: maxima.info,  Node: NARY,  Next: NOFIX,  Prev: Operators,  Up: Operators

NARY
====

- An NARY operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the operator,
e.g. A+B or A+B+C.  The NARY("x") function is a syntax extension
function to declare x to be an NARY operator.  Do DESCRIBE(SYNTAX); for
more details.  Functions may be DECLAREd to be NARY.  If
DECLARE(J,NARY); is done, this tells the simplifier to simplify, e.g.
J(J(A,B),J(C,D)) to J(A, B, C, D).


File: maxima.info,  Node: NOFIX,  Next: OPERATOR,  Prev: NARY,  Up: Operators

NOFIX
=====

- NOFIX operators are used to denote functions of no arguments.  The
mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a MACSYMA break, "exit" is behaving similar to a
NOFIX operator.  The function NOFIX("x") is a syntax extension function
which declares x to be a NOFIX operator.  Do DESCRIBE(SYNTAX); for more
details.


File: maxima.info,  Node: OPERATOR,  Next: POSTFIX,  Prev: NOFIX,  Up: Operators

OPERATOR
========

- See OPERATORS


File: maxima.info,  Node: POSTFIX,  Next: PREFIX,  Prev: OPERATOR,  Up: Operators

POSTFIX
=======

- POSTFIX operators like the PREFIX variety denote functions of a
single argument, but in this case the argument immediately precedes an
occurrence of the operator in the input string, e.g. 3! .  The
POSTFIX("x") function is a syntax extension function to declare x to be
a POSTFIX operator.  Do DESCRIBE(SYNTAX); for details.


File: maxima.info,  Node: PREFIX,  Next: Definitions for Operators,  Prev: POSTFIX,  Up: Operators

PREFIX
======

- A PREFIX operator is one which signifies a function of one argument,
which argument immediately follows an occurrence of the operator.
PREFIX("x") is a syntax extension function to declare x to be a PREFIX
operator.  Do DESCRIBE(SYNTAX); for more details.


File: maxima.info,  Node: Definitions for Operators,  Prev: PREFIX,  Up: Operators

Definitions for Operators
=========================

 - operator: "!"
     The factorial operator, which is the product of all the integers
     from 1 up to its argument.  Thus 5! = 1*2*3*4*5 = 120.  The value
     of /the option FACTLIM (default: [-1]) gives the highest factorial
     which is automatically expanded.  If it is -1 then all integers
     are expanded.  See also the FACTORIAL, MINFACTORIAL, and FACTCOMB
     commands.


 - operator: "!!"
     Stands for double factorial which is defined as the product of all
     the consecutive odd (or even) integers from 1 (or 2) to the odd
     (or even) argument.  Thus 8!! is 2*4*6*8 = 384.


 - operator: "#"
     The logical operator "Not equals".


 - operator: "."
     The dot operator, for matrix (non-commutative) multiplication.
     When "." is used in this way, spaces should be left on both sides
     of it, e.g. A . B.  This distinguishes it plainly from a decimal
     point in a floating point number.  Do APROPOS(DOT); for a list of
     the switches which affect the dot operator.
     DESCRIBE(switch-name); will explain them.


 - operator: ":"
     The assignment operator.  E.g. A:3 sets the variable A to 3.


 - operator: "::"
     Assignment operator.  :: assigns the value of the expression on
     its right to the value of the quantity on its left, which must
     evaluate to an atomic variable or subscripted variable.


 - operator: "::="
     The "::=" is used instead of ":=" to indicate that what follows is
     a macro definition, rather than an ordinary functional definition.
     See DESCRIBE(MACROS).


 - operator: ":="
     The function definition operator.  E.g. F(X):=SIN(X) defines a
     function F.


 - operator: "="
     denotes an equation to MACSYMA.  To the pattern matcher in MACSYMA
     it denotes a total relation that holds between two expressions if
     and only if the expressions are syntactically identical.


 - Function: ABS (exp)
     returns the absolute value exp.  If exp is complex, returns the
     complex modulus of exp.


 - special symbol: ADDITIVE
     - If DECLARE(F,ADDITIVE) has been executed, then: (1) If F is
     univariate, whenever the simplifier encounters F applied to a sum,
     F will be distributed over that sum.  I.e. F(Y+X); will simplify
     to F(Y)+F(X).  (2) If F is a function of 2 or more arguments,
     additivity is defined as additivity in the first argument to F, as
     in the case of 'SUM or 'INTEGRATE, i.e. F(H(X)+G(X),X); will
     simplify to F(H(X),X)+F(G(X),X).  This simplification does not
     occur when F is applied to expressions of the form
     SUM(X[I],I,lower-limit,upper-limit).


 - keyword: ALLBUT
     works with the PART commands (i.e. PART, INPART, SUBSTPART,
     SUBSTINPART, DPART, and LPART).  For example,

          if EXPR is E+D+C+B+A,
          then PART(EXPR,[2,5]);
          ==> D+A

     while
          PART(EXPR,ALLBUT(2,5))==>E+C+B

     It also works with the KILL command,
          KILL(ALLBUT(name1,...,namek))

     will do a KILL(ALL) except it will not KILL the names specified.
     Note: namei means a name such as function name such as U, F, FOO,
     or G, not an infolist such as FUNCTIONS.


 - declaration: ANTISYMMETRIC
     - If DECLARE(H,ANTISYMMETRIC); is done, this tells the simplifier
     that H is antisymmetric.  E.g. H(X,Z,Y) will simplify to - H(X, Y,
     Z).  That is, it will give (-1)^n times the result given by
     SYMMETRIC or COMMUTATIVE, where n is the number of interchanges of
     two arguments necessary to convert it to that form.


 - Function: CABS (exp)
     returns the complex absolute value (the complex modulus) of exp.


 - declaration: COMMUTATIVE
     - If DECLARE(H,COMMUTATIVE); is done, this tells the simplifier
     that H is a commutative function.  E.g. H(X,Z,Y) will simplify to
     H(X, Y, Z).  This is the same as SYMMETRIC.


 - Function: ENTIER (X)
     largest integer <= X where X is numeric.  FIX (as in FIXnum) is a
     synonym for this, so FIX(X); is precisely the same.


 - Function: EQUAL (expr1,expr2)
     used with an "IS", returns TRUE (or FALSE) if and only if expr1
     and expr2 are equal (or not equal) for all possible values of
     their variables (as determined by RATSIMP).  Thus
     IS(EQUAL((X+1)**2,X**2+2*X+1)) returns TRUE whereas if X is unbound
     IS((X+1)**2=X**2+2*X+1) returns FALSE.  Note also that IS(RAT(0)=0)
     gives FALSE but IS(EQUAL(RAT(0),0)) gives TRUE.  If a determination
     can't be made with EQUAL then a simplified but equivalent form is
     returned whereas = always causes either TRUE or FALSE to be
     returned.  All variables occurring in exp are presumed to be real
     valued.  EV(exp,PRED) is equivalent to IS(exp).
          (C1) IS(X**2 >= 2*X-1);
          (D1)                               TRUE
          (C2) ASSUME(A>1);
          (D2)                               DONE
          (C3) IS(LOG(LOG(A+1)+1)>0 AND A^2+1>2*A);
          (D3)                               TRUE

 - Function: EVAL
     causes an extra post-evaluation of exp to occur.


 - Function: EVENP (exp)
     is TRUE if exp is an even integer.  FALSE is returned in all other
     cases.


 - Function: FIX (x)
     a synonym for ENTIER(X) - largest integer <= X where X is numeric.


 - Function: FULLMAP (fn, exp1, ...)
     is similar to MAP but it will keep mapping down all subexpressions
     until the main operators are no longer the same.  The user should
     be aware that FULLMAP is used by the MACSYMA simplifier for
     certain matrix manipulations; thus, the user might see an error
     message concerning FULLMAP even though FULLMAP was not explicitly
     called by the user.
          (C1) A+B*C$
          (C2) FULLMAP(G,%);
          (D2)              G(B) G(C) + G(A)
          (C3)  MAP(G,D1);
          (D3)                G(B C) + G(A)

 - Function: FULLMAPL (fn, list1, ...)
     is similar to FULLMAP but it only maps onto lists and matrices
          (C1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);
          (D1)                      [[A + 3, 4], [4, 3.5]]

 - Function: IS (exp)
     attempts to determine whether exp (which must evaluate to a
     predicate) is provable from the facts in the current data base.  IS
     returns TRUE if the predicate is true for all values of its
     variables consistent with the data base and returns FALSE if it is
     false for all such values.  Otherwise, its action depends on the
     setting of the switch PREDERROR (default: TRUE). IS errs out if
     the value of PREDERROR is TRUE and returns UNKNOWN if PREDERROR is
     FALSE.


 - Function: ISQRT (X)
     takes one integer argument and returns the "integer SQRT" of its
     absolute value.


 - Function: MAX (X1, X2, ...)
     yields the maximum of its arguments (or returns a simplified form
     if some of its arguments are non-numeric).


 - Function: MIN (X1, X2, ...)
     yields the minimum of its arguments (or returns a simplified form
     if some of its arguments are non-numeric).


 - Function: MOD (poly)
     converts the polynomial poly to a modular representation with
     respect to the current modulus which is the value of the variable
     MODULUS.  MOD(poly,m) specifies a MODULUS m to be used for
     converting poly, if it is desired to override the current global
     value of MODULUS.  See DESCRIBE(MODULUS); .


 - Function: ODDP (exp)
     is TRUE if exp is an odd integer.  FALSE is returned in all other
     cases.


 - operator: PRED
     (EVFLAG) causes predicates (expressions which evaluate to TRUE or
     FALSE) to be evaluated.


 - Function: RANDOM (X)
     returns a random integer between 0 and X-1.  If no argument is
     given then a random integer between -2^(29) and 2^(29) -1 is
     returned.  If X is FALSE then the random sequence is restarted from
     the beginning.  Note that the range of the returned result when no
     argument is given differs in NIL MACSYMA from that of PDP-10 and
     Multics MACSYMA, which is -2^(35) to 2^(35) -1.  This range is the
     range of the FIXNUM datatype of the underlying LISP.


 - Function: SIGN (exp)
     attempts to determine the sign of its specified expression on the
     basis of the facts in the current data base.  It returns one of
     the following answers: POS (positive), NEG (negative), ZERO, PZ
     (positive or zero), NZ (negative or zero), PN (positive or
     negative), or PNZ (positive, negative, or zero, i.e. nothing
     known).


 - Function: SIGNUM (X)
     if X<0 then -1 else if X>0 then 1 else 0.  If X is not numeric
     then a simplified but equivalent form is returned. For example,
     SIGNUM(-X) gives -SIGNUM(X).


 - Function: SORT (list,optional-predicate)
     sorts the list using a suitable optional-predicate of two
     arguments (such as "<" or ORDERLESSP).  If the optional-predicate
     is not given, then MACSYMA's built-in ordering predicate is used.


 - Function: SQRT (X)
     the square root of X. It is represented internally by X^(1/2).
     Also see ROOTSCONTRACT.  RADEXPAND[TRUE] - if TRUE will cause nth
     roots of factors of a product which are powers of n to be pulled
     outside of the radical, e.g.  SQRT(16*X^2) will become 4*X only if
     RADEXPAND is TRUE.


 - Variable: SQRTDISPFLAG
     default: [TRUE] - if FALSE causes SQRT to display with exponent
     1/2.


 - Function: SUBLIS (list,expr)
     allows multiple substitutions into an expression in parallel.
     Sample syntax:
                  SUBLIS([A=B,B=A],SIN(A)+COS(B));
                   => SIN(B) + COS(A)
     The variable SUBLIS_APPLY_LAMBDA[TRUE] controls simplification
     after SUBLIS.  For full documentation, see the file SHARE2;SUBLIS
     INFO.


 - Function: SUBLIST (L,F)
     returns the list of elements of the list L for which the function
     F returns TRUE.  E.g., SUBLIST([1,2,3,4],EVENP); returns [2,4].


 - Variable: SUBLIS_APPLY_LAMBDA
     default:[TRUE] - controls whether LAMBDA's substituted are applied
     in simplification after SUBLIS is used or whether you have to do
     an EV to get things to apply. TRUE means do the application.


 - Function: SUBST (a, b, c)
     substitutes a for b in c.  b must be an atom, or a complete
     subexpression of c.  For example, X+Y+Z is a complete
     subexpression of 2*(X+Y+Z)/W while X+Y is not. When b does not have
     these characteristics, one may sometimes use SUBSTPART or RATSUBST
     (see below).  Alternatively, if b is of the form e/f then one could
     use SUBST(a*f,e,c) while if b is of the form e**(1/f) then one
     could use SUBST(a**f,e,c).  The SUBST command also discerns the
     X^Y in X^-Y so that SUBST(A,SQRT(X),1/SQRT(X)) yields 1/A.  a and
     b may also be operators of an expression enclosed in "s or they
     may be function names.  If one wishes to substitute for the
     independent variable in derivative forms then the AT function (see
     below) should be used.  Note:  SUBST is an alias for SUBSTITUTE.
     SUBST(eq1,exp) or SUBST([eq1,...,eqk],exp) are other permissible
     forms.  The eqi are equations indicating substitutions to be made.
     For each equation, the right side will be substituted for the left
     in the expression exp.  EXPTSUBST[FALSE] if TRUE permits
     substitutions like Y for %E**X in %E**(A*X) to take place.
     OPSUBST[TRUE] if FALSE, SUBST will not attempt to substitute into
     the operator of an expression.  E.g. (OPSUBST:FALSE,
     SUBST(X^2,R,R+R[0])); will work.
          (C1) SUBST(A,X+Y,X+(X+Y)**2+Y);
                                           2
          (D1)                    Y + X + A
          (C2) SUBST(-%I,%I,A+B*%I);
          (D2)                             A - %I B

     (Note that C2 is one way of obtaining the complex conjugate of an
     analytic expression.)  For further examples, do EXAMPLE(SUBST);


 - Function: SUBSTINPART (x, exp, n1, ...)
     is like SUBSTPART but works on the internal representation of exp.
          (C1) X.'DIFF(F(X),X,2);
                                             2
                                            d
          (D1)                         X . (--- F(X))
                                              2
                                            dX
          (C2) SUBSTINPART(D**2,%,2);
                                                2
          (D2)                             X . D
          (C3) SUBSTINPART(F1,F[1](X+1),0);
          (D3)                            F1(X + 1)
                        Additional Information
          If the last argument to a part function is a list of indices then
          several subexpressions are picked out, each one corresponding to an
          index of the list.  Thus
               (C1) PART(X+Y+Z,[1,3]);
               (D1) Z+X
          PIECE holds the value of the last expression selected when using the
          part functions.  It is set during the execution of the function and
          thus may be referred to in the function itself as shown below.
          If PARTSWITCH[FALSE] is set to TRUE then END is returned when a
          selected part of an expression doesn't exist, otherwise an error
          message is given.
          (C1)  27*Y**3+54*X*Y**2+36*X**2*Y+Y+8*X**3+X+1;
                      3         2       2            3
          (D1)    27 Y  + 54 X Y  + 36 X  Y + Y + 8 X  + X + 1
          (C2)  PART(D1,2,[1,3]);
                            2
          (D2)          54 Y
          (C3)  SQRT(PIECE/54);
          (D3)            Y
          (C4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);
                                    3
          (D4)           (3 Y + 2 X) + Y + X + 1
          (C5) 1/X+Y/X-1/Z;
                                           1   Y   1
          (D5)                           - - + - + -
                                           Z   X   X
          (C6) SUBSTPART(XTHRU(PIECE),%,[2,3]);
                                          Y + 1   1
          (D6)                            ----- - -
                                            X     Z
     Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART
     is the same as calling INPART/SUBSTINPART.


 - Function: SUBSTPART (x, exp, n1, ..., nk)
     substitutes x for the subexpression picked out by the rest of the
     arguments as in PART.  It returns the new value of exp.  x may be
     some operator to be substituted for an operator of exp.  In some
     cases it needs to be enclosed in "s (e.g.  SUBSTPART("+",A*B,0);
     -> B + A ).
          (C1) 1/(X**2+2);
                                              1
          (D1)                              ------
                                             2
                                            X  + 2
          (C2) SUBSTPART(3/2,%,2,1,2);
                                              1
          (D2)                             --------
                                            3/2
                                           X    + 2
          (C3) A*X+F(B,Y);
          (D3)                          A X + F(B, Y)
          (C4) SUBSTPART("+",%,1,0);
          (D4)                         X + F(B, Y) + A
     Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART
     is the same as calling INPART/SUBSTINPART.


 - Function: SUBVARP (exp)
     is TRUE if exp is a subscripted variable, for example A[I].


 - Function: SYMBOLP (exp)
     returns TRUE if "exp" is a "symbol" or "name", else FALSE.  I.e.,
     in effect, SYMBOLP(X):=ATOM(X) AND NOT NUMBERP(X)$ .


 - Function: UNORDER ()
     stops the aliasing created by the last use of the ordering
     commands ORDERGREAT and ORDERLESS.  ORDERGREAT and ORDERLESS may
     not be used more than one time each without calling UNORDER.  Do
     DESCRIBE(ORDERGREAT); and DESCRIBE(ORDERLESS);, and also do
     EXAMPLE(UNORDER); for specifics.


 - Function: VECTORPOTENTIAL (givencurl)
     Returns the vector potential of a given curl vector, in the
     current coordinate system.  POTENTIALZEROLOC has a similar role as
     for POTENTIAL, but the order of the left-hand sides of the
     equations must be a cyclic permutation of the coordinate variables.


 - Function: XTHRU (exp)
     combines all terms of exp (which should be a sum) over a common
     denominator without expanding products and exponentiated sums as
     RATSIMP does.  XTHRU cancels common factors in the numerator and
     denominator of rational expressions but only if the factors are
     explicit.  Sometimes it is better to use XTHRU before RATSIMPing an
     expression in order to cause explicit factors of the gcd of the
     numerator and denominator to be canceled thus simplifying the
     expression to be RATSIMPed.
          (C1) ((X+2)**20-2*Y)/(X+Y)**20+(X+Y)**-19-X/(X+Y)**20;
                                                          20
                               1           X       (X + 2)   - 2 Y
          (D1)             --------- - --------- + ---------------
                                  19          20             20
                           (Y + X)     (Y + X)        (Y + X)
          (C2) XTHRU(%);
                                               20
                                        (X + 2)   - Y
          (D2)                          -------------
                                                 20
                                          (Y + X)

 - Function: ZEROEQUIV (exp,var)
     tests whether the expression exp in the variable var is equivalent
     to zero.  It returns either TRUE, FALSE, or DONTKNOW.  For example
     ZEROEQUIV(SIN(2*X) - 2*SIN(X)*COS(X),X) returns TRUE and
     ZEROEQUIV(%E^X+X,X) returns FALSE.  On the other hand
     ZEROEQUIV(LOG(A*B) - LOG(A) - LOG(B),A) will return DONTKNOW
     because of the presence of an extra parameter.  The restrictions
     are: (1) Do not use functions that MACSYMA does not know how to
     differentiate and evaluate.  (2) If the expression has poles on
     the real line, there may be errors in the result (but this is
     unlikely to occur).  (3) If the expression contains functions
     which are not solutions to first order differential equations
     (e.g.  Bessel functions) there may be incorrect results.  (4) The
     algorithm uses evaluation at randomly chosen points for carefully
     selected subexpressions.  This is always a somewhat hazardous
     business, although the algorithm tries to minimize the potential
     for error.



File: maxima.info,  Node: Expressions,  Next: Simplification,  Prev: Operators,  Up: Top

Expressions
***********

* Menu:

* Introduction to Expressions::
* ASSIGNMENT::
* COMPLEX::
* INEQUALITY::
* SYNTAX::
* Definitions for Expressions::


File: maxima.info,  Node: Introduction to Expressions,  Next: ASSIGNMENT,  Prev: Expressions,  Up: Expressions

Introduction to Expressions
===========================

There are a number of reserved words which cannot be used as variable
names.   Their use would cause a possibly cryptic syntax error.

     INTEGRATE            NEXT           FROM                 DIFF
     IN                   AT             LIMIT                SUM
     FOR                  AND            ELSEIF               THEN
     ELSE                 DO             OR                   IF
     UNLESS               PRODUCT        WHILE                THRU
     STEP

   Most things in MAXIMA are expressions.   A sequence of expressions
can be made into an expression by separating them by commas and putting
parentheses around them.   This is similar to the C comma expression.

     (C29) x:3$
     (C30) joe:(x:x+1,x:x*x);
     (D30) 16
     (C31) joe:(if (x >17) then 2 else 4);
     (D31) 4
     (C32) joe:(if (x >17) then x:2 else joe:4,joe+x);
     (D32) 20

   Even loops in maxima are expressions, although the value they return
is the not too useful `DONE'

     (C33) joe:(x:1,for i from 1 thru 10 do (x:x*i));
     (D33) DONE
   whereas what you really want is probably to include a third term in
the comma expression which actually gives back the value.

     (C34) joe:(x:1,for i from 1 thru 10 do (x:x*i),x);
     (D34) 3628800


File: maxima.info,  Node: ASSIGNMENT,  Next: COMPLEX,  Prev: Introduction to Expressions,  Up: Expressions

ASSIGNMENT
==========

- There are two assignment operators in MACSYMA, : and :: .  E.g. A:3
sets the variable A to 3.  :: assigns the value of the expression on
its right to the value of the quantity on its left, which must evaluate
to an atomic variable or subscripted variable.


File: maxima.info,  Node: COMPLEX,  Next: INEQUALITY,  Prev: ASSIGNMENT,  Up: Expressions

COMPLEX
=======

- A complex expression is specified in MACSYMA by adding the real part
of the expression to %I times the imaginary part.  Thus the roots of
the equation X^2-4*X+13=0 are 2+3*%I and 2-3*%I.  Note that
simplification of products of complex expressions can be effected by
expanding the product.  Simplification of quotients, roots, and other
functions of complex expressions can usually be accomplished by using
the REALPART, IMAGPART, RECTFORM, POLARFORM, ABS, CARG functions.


File: maxima.info,  Node: INEQUALITY,  Next: SYNTAX,  Prev: COMPLEX,  Up: Expressions

INEQUALITY
==========

- MACSYMA has the usual inequality operators: less than:  < greater
than:  > greater than or equal to:  >= less than or equal to:  <=


File: maxima.info,  Node: SYNTAX,  Next: Definitions for Expressions,  Prev: INEQUALITY,  Up: Expressions

SYNTAX
======

- It is possible to add new operators to MACSYMA (infix, prefix,
postfix, unary, or matchfix with given precedences), to remove existing
operators, or to redefine the precedence of existing operators.  While
MACSYMA's syntax should be adequate for most ordinary applications, it
is possible to define new operators or eliminate predefined ones that
get in the user's way.  The extension mechanism is rather
straightforward and should be evident from the examples below.
     (C1) PREFIX("DDX")$
     (C2) DDX Y$
          /* means                   "DDX"(Y) */
     (C3) INFIX("<-")$
     (C4) A<-DDX Y$
         /* means               "<-"(A,"DDX"(Y)) */
   For each of the types of operator except SPECIAL, there is a
corresponding creation function that will give the lexeme specified the
corresponding parsing properties.  Thus "PREFIX("DDX")" will make "DDX"
a prefix operator just like "-" or "NOT".  Of course, certain extension
functions require additional information such as the matching keyword
for a matchfix operator.  In addition, binding powers and parts of
speech must be specified for all keywords defined.  This is done by
passing additional arguments to the extension functions.  If a user
does not specify these additional parameters, MACSYMA will assign
default values.  The six extension functions with binding powers and
parts of speech defaults (enclosed in brackets) are summarized below.
PREFIX(operator, rbp[180], rpos[ANY], pos[ANY]) POSTFIX(operator,
lbp[180], lpos[ANY], pos[ANY]) INFIX(operator, lbp[180], rbp[180],
lpos[ANY], rpos[ANY],pos[ANY]) NARY(operator, bp[180], argpos[ANY],
pos[ANY]) NOFIX(operator, pos[ANY]) MATCHFIX(operator, match,
argpos[ANY], pos[ANY])     The defaults have been provided so that a
user who does not wish to concern himself with parts of speech or
binding powers may simply omit those arguments to the extension
functions.  Thus the following are all equivalent.
PREFIX("DDX",180,ANY,ANY)$ PREFIX("DDX",180)$ PREFIX("DDX")$     It is
also possible to remove the syntax properties of an operator by using
the functions REMOVE or KILL.  Specifically, "REMOVE("DDX",OP)" or
"KILL("DDX")" will return "DDX" to operand status; but in the second
case all the other properties of "DDX" will also be removed.


     (C20) PREFIX("DDX",180,ANY,ANY)$
     
     (C21) DDXYZ;
     
     (D21) 				    DDX YZ
     
     (C26) "ddx"(u):=u+4;
     
     (D26) 			        DDX u := u + 4
     (C27) ddx 8;
     
     (D27) 				      12


File: maxima.info,  Node: Definitions for Expressions,  Prev: SYNTAX,  Up: Expressions

Definitions for Expressions
===========================

 - Function: AT (exp, list)
     will evaluate exp (which may be any expression) with the variables
     assuming the values as specified for them in the list of equations
     or the single equation similar to that given to the ATVALUE
     function.  If a subexpression depends on any of the variables in
     list but it hasn't had an atvalue specified and it can't be
     evaluated then a noun form of the AT will be returned which will
     display in a two-dimensional form.  Do EXAMPLE(AT); for an example.


 - Function: BOX (expr)
     returns expr enclosed in a box.  The box is actually part of the
     expression.
          BOX(expr,label)
     encloses expr in a labelled box.  label is a name which will be
     truncated in display if it is too long.      BOXCHAR["] - is the
     character used to draw the box in this and in the DPART and LPART
     functions.


 - Variable: BOXCHAR
     default: ["] is the character used to draw the box in the BOX and
     in the DPART and LPART functions.


 - special operator: CONSTANT
     - makes ai a constant as is %PI.


 - Function: CONSTANTP (exp)
     is TRUE if exp is a constant (i.e.  composed of numbers and %PI,
     %E, %I or any variables bound to a constant or DECLAREd constant)
     else FALSE.  Any function whose arguments are constant is also
     considered to be a constant.


 - Function: CONTRACT (exp)
     carries out all possible contractions in exp, which may be any
     well-formed combination of sums and products.  This function uses
     the information given to the DEFCON function.  Since all tensors
     are considered to be symmetric in all indices, the indices are
     sorted into alphabetical order.  Also all dummy indices are
     renamed using the symbols !1,!2,... to permit the expression to be
     simplified as much as possible by reducing equivalent terms to a
     canonical form.  For best results exp should be fully expanded.
     RATEXPAND is the fastest way to expand products and powers of sums
     if there are no variables in the denominators of the terms.  The
     GCD switch should be FALSE if gcd cancellations are unnecessary.


 - Function: DECLARE (a1, f1, a2, f2, ...)
     gives the atom ai the flag fi.  The ai's and fi's may also be
     lists of atoms and flags respectively in which case each of the
     atoms gets all of the properties.  The possible flags and their
     meanings are:

     CONSTANT - makes ai a constant as is %PI.

     MAINVAR - makes ai a MAINVAR.  The ordering scale for atoms:
     numbers < constants (e.g. %E,%PI) < scalars < other variables <
     mainvars.

     SCALAR - makes ai a scalar.

     NONSCALAR - makes ai behave as does a list or matrix with respect
     to the dot operator.

     NOUN - makes the function ai a noun so that it won't be evaluated
     automatically.

     EVFUN - makes ai known to the EV function so that it will get
     applied if its name is mentioned.  Initial evfuns are
          FACTOR, TRIGEXPAND,
          TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, and RADCAN

     EVFLAG - makes ai known to the EV function so that it will be
     bound to TRUE during the execution of EV if it is mentioned.
     Initial evflags are
          FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE,
          KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
          RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER,
          RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER,
          PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
          EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM,
          NUMER_PBRANCH, M1PBRANCH, DOTSCRULES, and LOGEXPAND

     BINDTEST - causes ai to signal an error if it ever is used in a
     computation unbound.  DECLARE([var1, var2, ...], BINDTEST) causes
     MACSYMA to give an error message whenever any of the vari occur
     unbound in a computation.  MACSYMA currently recognizes and uses
     the following features of objects:
          EVEN, ODD, INTEGER, RATIONAL, IRRATIONAL, REAL, IMAGINARY,
          and COMPLEX
     he useful features of functions include:
           INCREASING,
          DECREASING, ODDFUN (odd function), EVENFUN (even function),
          COMMUTATIVE (or SYMMETRIC), ANTISYMMETRIC, LASSOCIATIVE and
          RASSOCIATIVE
     DECLARE(F,INCREASING) is in all respects equivalent to

          ASSUME(KIND(F,INCREASING))
     The ai and fi may also be lists of objects or features.  The
     command
          FEATUREP(object,feature)
     may be used to determine if an object has been DECLAREd to have
     "feature".  See DESCRIBE(FEATURES); .


 - Function: DISOLATE (exp, var1, var2, ..., varN)
     is similar to ISOLATE(exp, var) (Do DESCRIBE(ISOLATE);) except
     that it enables the user to isolate more than one variable
     simultaneously.  This might be useful, for example, if one were
     attempting to change variables in a multiple integration, and that
     variable change involved two or more of the integration variables.
     This function is autoloaded from `simplification/disol.mac'.  A
     demo is available by `demo("disol")$'.


 - Function: DISPFORM (exp)
     returns the external representation of exp (wrt its main
     operator).  This should be useful in conjunction with PART which
     also deals with the external representation.  Suppose EXP is -A .
     Then the internal representation of EXP is "*"(-1,A), while the
     external representation is "-"(A). DISPFORM(exp,ALL) converts the
     entire expression (not just the top-level) to external format.  For
     example, if EXP:SIN(SQRT(X)), then FREEOF(SQRT,EXP) and
     FREEOF(SQRT,DISPFORM(EXP)) give TRUE, while
     FREEOF(SQRT,DISPFORM(EXP,ALL)) gives FALSE.


 - Function: DISTRIB (exp)
     distributes sums over products.  It differs from EXPAND in that it
     works at only the top level of an expression, i.e. it doesn't
     recurse and it is faster than EXPAND.  It differs from MULTTHRU in
     that it expands all sums at that level. For example,
     DISTRIB((A+B)*(C+D)) -> A C + A D + B C + B D MULTTHRU
     ((A+B)*(C+D)) -> (A + B) C + (A + B) D DISTRIB (1/((A+B)*(C+D)))
     ->  1/ ((A+B) *(C+D)) EXPAND(1/((A+B)*(C+D)),1,0) -> 1/(A C + A D
     + B C + B D)


 - Function: DPART (exp, n1, ..., nk)
     selects the same subexpression as PART, but instead of just
     returning that subexpression as its value, it returns the whole
     expression with the selected subexpression displayed inside a box.
     The box is actually part of the expression.
          (C1) DPART(X+Y/Z**2,1,2,1);
                                 Y
          (D1)                  ---- + X
                                   2
                               *****
                               * Z *
                               *****

 - Function: EXP (X)
     the exponential function.  It is represented internally as %E^X.
     DEMOIVRE[FALSE] - if TRUE will cause %E^(A+B*%I) to become
     %E^A*(COS(B)+%I*SIN(B)) if B is free of %I.  A and B are not
     expanded.    %EMODE[TRUE] - when TRUE %E^(%PI*%I*X) will be
     simplified as follows: it will become COS(%PI*X)+%I*SIN(%PI*X) if
     X is an integer or a multiple of 1/2, 1/3, 1/4, or 1/6 and thus
     will simplify further.  For other numerical X it will become
     %E^(%PI*%I*Y) where Y is X-2*k for some integer k such that
     ABS(Y)<1.  If %EMODE is FALSE no simplification of %E^(%PI*%I*X)
     will take place.    %ENUMER[FALSE] - when TRUE will cause %E to be
     converted into 2.718...  whenever NUMER is TRUE.  The default is
     that this conversion will take place only if the exponent in %E^X
     evaluates to a number.


 - Variable: EXPTISOLATE
     default: [FALSE] if TRUE will cause ISOLATE(expr,var); to examine
     exponents of atoms (like %E) which contain var.


 - Variable: EXPTSUBST
     default: [FALSE] if TRUE permits substitutions such as Y for %E**X
     in %E**(A*X) to take place.


 - Function: FREEOF (x1, x2, ..., exp)
     yields TRUE if the xi do not occur in exp and FALSE otherwise.
     The xi are atoms or they may be subscripted names, functions (e.g.
     SIN(X) ), or operators enclosed in "s.  If 'var' is a "dummy
     variable" of 'exp', then FREEOF(var,exp); will return TRUE.
     "Dummy variables" are mathematical things like the index of a sum
     or product, the limit variable, and the definite integration
     variable.  Example: FREEOF(I,'SUM(F(I),I,0,N)); returns TRUE.  Do
     EXAMPLE(FREEOF); for more examples.


 - Function: GENFACT (X, Y, Z)
     is the generalized factorial of X which is:
     X*(X-Z)*(X-2*Z)*...*(X-(Y-1)*Z).  Thus, for integral X,
     GENFACT(X,X,1)=X!  and GENFACT(X,X/2,2)=X!!


 - Function: IMAGPART (exp)
     returns the imaginary part of the expression exp.


 - Function: INDICES (exp)
     returns a list of two elements.  The first is a list of the free
     indices in exp (those that occur only once); the second is the
     list of dummy indices in exp (those that occur exactly twice).


 - Function: INFIX (op)
     - INFIX operators are used to denote functions of two arguments,
     one given before the operator and one after, e.g. A^2 .  The
     INFIX("x") function is a syntax extention function to declare x to
     be an INFIX operator.  Do DESCRIBE(SYNTAX); for more details.


 - Variable: INFLAG
     default: [FALSE] if set to TRUE, the functions for part extraction
     will look at the internal form of exp.  Note that the simplifier
     re-orders expressions.  Thus FIRST(X+Y) will be X if INFLAG is
     TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same
     results).  Also, setting INFLAG to TRUE and calling PART/SUBSTPART
     is the same as calling INPART/SUBSTINPART.  Functions affected by
     the setting of INFLAG are: PART, SUBSTPART, FIRST, REST, LAST,
     LENGTH, the FOR ... IN construct, MAP, FULLMAP, MAPLIST, REVEAL
     and PICKAPART.


 - Function: INPART (exp, n1, ..., nk)
     is similar to PART but works on the internal representation of the
     expression rather than the displayed form and thus may be faster
     since no formatting is done.  Care should be taken with respect to
     the order of subexpressions in sums and products (since the order
     of variables in the internal form is often different from that in
     the displayed form) and in dealing with unary minus, subtraction,
     and division (since these operators are removed from the
     expression). PART(X+Y,0) or INPART(X+Y,0) yield +, though in order
     to refer to the operator it must be enclosed in "s.  For example
     ...IF INPART(D9,0)="+" THEN ...
          (C1)  X+Y+W*Z;
          (D1)                  W Z + Y + X
          (C2)  INPART(D1,3,2);
          (D2)                  Z
          (C3)  PART(D1,1,2);
          (D3)                  Z
          (C4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
                                                G(X + 1)
          (D4)                      LIMIT   F(X)
                                    X ->0-
          (C5) INPART(%,1,2);
          (D5)                            G(X + 1)

 - Function: ISOLATE (exp, var)
     returns exp with subexpressions which are sums and which do not
     contain var replaced by intermediate expression labels (these
     being atomic symbols like E1, E2, ...).  This is often useful to
     avoid unnecessary expansion of subexpressions which don't contain
     the variable of interest.  Since the intermediate labels are bound
     to the subexpressions they can all be substituted back by
     evaluating the expression in which they occur.  EXPTISOLATE[FALSE]
     if TRUE will cause ISOLATE to examine exponents of atoms (like %E)
     which contain var.  ISOLATE_WRT_TIMES[FALSE] if TRUE, then ISOLATE
     will also isolate wrt products.  E.g. compare both settings of the
     switch on ISOLATE(EXPAND((A+B+C)^2),C); .  Do EXAMPLE(ISOLATE);
     for examples.


 - Variable: ISOLATE_WRT_TIMES
     default: [FALSE] - if set to TRUE, then ISOLATE will also isolate
     wrt products.  E.g. compare both settings of the switch on
     ISOLATE(EXPAND((A+B+C)^2),C); .


 - Variable: LISTCONSTVARS
     default: [FALSE] - if TRUE will cause LISTOFVARS to include %E,
     %PI, %I, and any variables declared constant in the list it
     returns if they appear in the expression LISTOFVARS is called on.
     The default is to omit these.


 - Variable: LISTDUMMYVARS
     default: [TRUE] - if FALSE, "dummy variables" in the expression
     will not be included in the list returned by LISTOFVARS.  (The
     meaning of "dummy variables" is as given in DESCRIBE(FREEOF):
     "Dummy variables" are mathematical things like the index of a sum
     or product, the limit variable, and the definite integration
     variable.)  Example: LISTOFVARS('SUM(F(I),I,0,N)); gives [I,N] if
     LISTDUMMYVARS is TRUE, and [N] if LISTDUMMYVARS is FALSE.


 - Function: LISTOFVARS (exp)
     yields a list of the variables in exp.  LISTCONSTVARS[FALSE] if
     TRUE will cause LISTOFVARS to include %E, %PI, %I, and any
     variables declared constant in the list it returns if they appear
     in exp.  The default is to omit these.
          (C1) LISTOFVARS(F(X[1]+Y)/G**(2+A));
          (D1)                            [X[1], Y, A, G]

 - Function: LFREEOF (list, exp)
     For each member m of list, calls FREEOF(m,exp).  It returns false
     if any call to FREEOF does and true otherwise.

 - Function: LOPOW (exp, v)
     the lowest exponent of v which explicitly appears in exp.  Thus

          LOPOW((X+Y)**2+(X+Y)**A,X+Y) ==> MIN(A,2)
     .


 - Function: LPART (label, expr, n1, ..., nk)
     is similar to DPART but uses a labelled box. A labelled box is
     similar to the one produced by DPART but it has a name in the top
     line.


 - Function: MULTTHRU (exp)
     multiplies a factor (which should be a sum) of exp by the other
     factors of exp.  That is exp is f1*f2*...*fn where at least one
     factor, say fi, is a sum of terms.  Each term in that sum is
     multiplied by the other factors in the product.  (Namely all the
     factors except fi).  MULTTHRU does not expand exponentiated sums.
     This function is the fastest way to distribute products
     (commutative or noncommutative) over sums.  Since quotients are
     represented as products MULTTHRU can be used to divide sums by
     products as well.  MULTTHRU(exp1, exp2) multiplies each term in
     exp2 (which should be a sum or an equation) by exp1.  If exp1 is
     not itself a sum then this form is equivalent to
     MULTTHRU(exp1*exp2).
          (C1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;
                         1        X         F(X)
          (D1)       - ----- + -------- - --------
                       X - Y          2          3
                               (X - Y)    (X - Y)
          (C2) MULTTHRU((X-Y)**3,%);
                              2
          (D2)       - (X - Y)  + X (X - Y) - F(X)
          (C3) RATEXPAND(D2);
                                     2
          (D3)                    - Y  + X Y - F(X)
          (C4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);
                                   10  2              2  2
                          (B  + A )   S  + 2 A B S + A  B
          (D4)            --------------------------------
                                             2
                                        A B S
          (C5) MULTTHRU(%);
                                                    10
                                  2   A B   (B  + A)
          (D5)                    - + --- + -------
                                  S    2      A B
                                      S
          (notice that (B+A)**10 is not expanded)
          (C6) MULTTHRU(A.(B+C.(D+E)+F));
          (D6)                A . F + A . (C . (E + D)) + A . B
          (compare with similar example under EXPAND)

 - Function: NOUNIFY (f)
     returns the noun form of the function name f.  This is needed if
     one wishes to refer to the name of a verb function as if it were a
     noun.  Note that some verb functions will return their noun forms
     if they can't be evaluated for certain arguments.  This is also
     the form returned if a function call is preceded by a quote.


 - Function: NTERMS (exp)
     gives the number of terms that exp would have if it were fully
     expanded out and no cancellations or combination of terms
     occurred. Note that expressions like SIN(E), SQRT(E), EXP(E), etc.
     count as just one term regardless of how many terms E has (if it
     is a sum).


 - Function: OP (exp)
     Returns the operator of the expression, and functions the same way
     as PART(exp,0).  It observes the setting of the INPART flag.  It
     may not return the same value as the commercial Macsyma.


 - Function: OPERATORP (exp, ool)
     Uses OP to get the operator of the expression and either compares
     it to ool, if it is a operator, or checks if it is a member of ool
     if it is a list.


 - Function: OPTIMIZE (exp)
     returns an expression that produces the same value and side
     effects as exp but does so more efficiently by avoiding the
     recomputation of common subexpressions.  OPTIMIZE also has the side
     effect of "collapsing" its argument so that all common
     subexpressions are shared.  Do EXAMPLE(OPTIMIZE); for examples.


 - Variable: OPTIMPREFIX
     default: [%] - The prefix used for generated symbols by the
     OPTIMIZE command.


 - Function: ORDERGREAT (V1, ..., Vn)
     sets up aliases for the variables V1, ..., Vn such that V1 > V2 >
     ...  > Vn > any other variable not mentioned as an argument.  See
     also ORDERLESS.  Caveat:  do EXAMPLE(ORDERGREAT); for some
     specifics.


 - Function: ORDERGREATP (exp1,exp2)
     returns TRUE if exp2 precedes exp1 in the ordering set up with the
     ORDERGREAT function (see DESCRIBE(ORDERGREAT);).


 - Function: ORDERLESS (V1, ..., Vn)
     sets up aliases for the variables V1, ..., Vn such that V1 < V2 <
     ...  < Vn < any other variable not mentioned as an argument.  Thus
     the complete ordering scale is: numerical constants < declared
     constants < declared scalars < first argument to ORDERLESS < ...
     < last argument to ORDERLESS < variables which begin with A < ...
     < variables which begin with Z < last argument to ORDERGREAT <
     ... < first argument to ORDERGREAT < declared MAINVARs.  Caveat: do
     EXAMPLE(ORDERLESS); for some specifics.  For another ordering
     scheme, see DESCRIBE(MAINVAR);.


 - Function: ORDERLESSP (exp1,exp2)
     returns TRUE if exp1 precedes exp2 in the ordering set up by the
     ORDERLESS command (see DESCRIBE(ORDERLESS);).


 - Function: PART (exp, n1, ..., nk)
     deals with the displayed form of exp. It obtains the part of exp
     as specified by the indices n1,...,nk.  First part n1 of exp is
     obtained, then part n2 of that, etc.  The result is part nk of ...
     part n2 of part n1 of exp.  Thus PART(Z+2*Y,2,1) yields 2.  PART
     can be used to obtain an element of a list, a row of a matrix, etc.
     If the last argument to a Part function is a list of indices then
     several subexpressions are picked out, each one corresponding to an
     index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.  PIECE holds
     the last expression selected when using the Part functions.  It is
     set during the execution of the function and thus may be referred
     to in the function itself as shown below.  If PARTSWITCH[FALSE] is
     set to TRUE then END is returned when a selected part of an
     expression doesn't exist, otherwise an error message is given.
     For examples, do EXAMPLE(PART);


 - Function: PARTITION (exp, var)
     returns a list of two expressions.  They are (1) the factors of
     exp (if it is a product), the terms of exp (if it is a sum), or
     the list (if it is a list) which don't contain var and, (2) the
     factors, terms, or list which do.
          (C1) PARTITION(2*A*X*F(X),X);
          (D1)                 [ 2 A , X F(X) ]
          (C2) PARTITION(A+B,X);
          (D2)                 [ A + B , 0 ]
          (C3) PARTITION([A,B,F(A),C],A);
          (D3)                [[B,C],[A,F(A)]]

 - Variable: PARTSWITCH
     default: [FALSE] - if set to TRUE then END is returned when a
     selected part of an expression doesn't exist, otherwise an error
     message is given.


 - Function: PICKAPART (exp,depth)
     will assign E labels to all subexpressions of exp down to the
     specified integer depth.  This is useful for dealing with large
     expressions and for automatically assigning parts of an expression
     to a variable without having to use the part functions.
          (C1) EXP:(A+B)/2+SIN(X^2)/3-LOG(1+SQRT(X+1));
                                                           2
                                                      SIN(X )   B + A
          (D1)               - LOG(SQRT(X + 1) + 1) + ------- + -----
                                                         3        2
          (C2) PICKAPART(%,1);
          (E2)                    - LOG(SQRT(X + 1) + 1)
                                              2
                                         SIN(X )
          (E3)                           -------
                                            3
                                          B + A
          (E4)                            -----
                                            2
          (D4)                         E4 + E3 + E2

 - Variable: PIECE
     - holds the last expression selected when using the Part
     functions.  It is set during the execution of the function and thus
     may be referred to in the function itself.


 - Function: POWERS (expr, var)
     gives the powers of var occuring in expr.  To use it, do
     LOAD(POWERS);.  For details on usage, do PRINTFILE("powers.usg");.


 - Function: PRODUCT (exp, ind, lo, hi)
     gives the product of the values of exp as the index ind varies
     from lo to hi.  The evaluation is similar to that of SUM.  No
     simplification of products is available at this time.  If hi is
     one less than lo, we have an "empty product" and PRODUCT returns 1
     rather than erring out.  Also see DESCRIBE(PRODHACK).
          (C1)  PRODUCT(X+I*(I+1)/2,I,1,4);
          (D1)             (X + 1) (X + 3) (X + 6) (X + 10)

 - Function: REALPART (exp)
     gives the real part of exp. REALPART and IMAGPART will work on
     expressions involving trigonometic and hyperbolic functions, as
     well as SQRT, LOG, and exponentiation.


 - Function: RECTFORM (exp)
     returns an expression of the form A + B*%I, where A and B are
     purely real.


 - Function: REMBOX (expr, arg)
     removes boxes from expr according to arg.  If arg is UNLABELED
     then all unlabelled boxes are removed.  If arg is the name of some
     label then only boxes with that label are removed.  If arg is
     omitted then all boxes labelled and unlabelled are removed.


 - Function: SUM (exp, ind, lo, hi)
     performs a summation of the values of exp as the index ind varies
     from lo to hi.  If the upper and lower limits differ by an integer
     then each term in the sum is evaluated and added together.
     Otherwise, if the SIMPSUM [FALSE] is TRUE the result is
     simplified.  This simplification may sometimes be able to produce a
     closed form.  If SIMPSUM is FALSE or if 'SUM is used, the value is
     a sum noun form which is a representation of the sigma notation
     used in mathematics.  If hi is one less than lo, we have an "empty
     sum" and SUM returns 0 rather than erring out.  Sums may be
     differentiated, added, subtracted, or multiplied with some
     automatic simplification being performed.  Also see
     DESCRIBE(SUMHACK).  CAUCHYSUM[FALSE] when TRUE causes the Cauchy
     product to be used when multiplying sums together rather than the
     usual product.  In the Cauchy product the index of the inner
     summation is a function of the index of the outer one rather than
     varying independently.  GENINDEX[I] is the alphabetic prefix used
     to generate the next variable of summation.  GENSUMNUM[0] is the
     numeric suffix used to generate the next variable of summation.
     If it is set to FALSE then the index will consist only of GENINDEX
     with no numeric suffix.  Do EXAMPLE(SUM); for examples.  See also
     SUMCONTRACT, INTOSUM, BASHINDICES, and NICEINDICES.


 - Function: LSUM (exp, ind, list)
     performs the sum of EXP for each element IND of the LIST.
          (C10) lsum(x^i,i,[1,2,7]);
          
                                      7    2
          (D10)                      x  + x  + x
     If the last element LIST argument does not evaluate, or does not
     evaluate to a Maxima list then the answer is left in noun form
          (C13) lsum(i^2,i,rootsof(x^3-1));
          
                               ====
                               \      2
          (D13)                 >    i
                               /
                               ====
                                             3
                               i in ROOTSOF(x  - 1)


 - special symbol: VERB
     - the opposite of "noun", i.e. a function form which "does
     something" ("action" - for most functions the usual case).  E.g.
     INTEGRATE integrates a function, unless it is DECLAREd to be a
     "noun", in which case it represents the INTEGRAL of the function.
     See NOUN, NOUNIFY, and VERBIFY.


 - Function: VERBIFY (f)
     returns the function name f in its verb form (See also VERB, NOUN,
     and NOUNIFY).



File: maxima.info,  Node: Simplification,  Next: Plotting,  Prev: Expressions,  Up: Top

Simplification
**************

* Menu:

* Definitions for Simplification::


File: maxima.info,  Node: Definitions for Simplification,  Prev: Simplification,  Up: Simplification

Definitions for Simplification
==============================

* Menu:

 - Function: APPLY_NOUNS (exp)
     causes the application of noun forms in an expression.  E.g.
     EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This gives the
     same result as EV(EXP,NOUNS); except that it can be faster and use
     less storage.  It also can be used in translated code, where EV
     may cause problems.  Note that it is called APPLY_NOUNS, not
     EV_NOUNS, because what it does is to APPLY the rules corresponding
     to the noun-form operators, which is not evaluation.


 - Variable: ASKEXP
     default: [] contains the expression upon which ASKSIGN is called.
     A user may enter a MACSYMA break with ^A and inspect this
     expression in order to answer questions asked by ASKSIGN.

 - Function: ASKINTEGER (exp,<optional-arg>)
     exp is any valid macsyma expression and optional-arg is
     EVEN,ODD,INTEGER and defaults to INTEGER if not given.  This
     function attempts to determine from the data-base whether exp is
     EVEN, ODD or just an INTEGER.  It will ask the user if it cannot
     tell otherwise and attempt to install the information in the
     data-base if possible.


 - Function: ASKSIGN (exp)
     first attempts to determine whether the specified expression is
     positive, negative, or zero.  If it cannot, it asks the user the
     necessary questions to complete its deduction.  The user's answer
     is recorded in the data base for the duration of the current
     computation (one "C-line"). The value of ASKSIGN is one of POS,
     NEG, or ZERO.


 - Variable: DEMOIVRE
     default: [FALSE] if TRUE will cause
          %E^(A+B*%I) ==> %E^A*(COS(B)+%I*SIN(B))
     if B is free of %I.  A and B are not expanded.  DEMOIVRE:TRUE; is
     the way to reverse the effect of EXPONENTIALIZE:TRUE;

     DEMOIVRE(exp) will cause the conversion without setting the switch
     or having to re-evaluate the expression with EV.


 - Variable: DOMAIN
     default: [REAL] - if set to COMPLEX, SQRT(X^2) will remain
     SQRT(X^2) instead of returning ABS(X).  The notion of a "domain" of
     simplification is still in its infancy, and controls little more
     than this at the moment.


 - Function: EXPAND (exp)
     will cause products of sums and exponentiated sums to be
     multiplied out, numerators of rational expressions which are sums
     to be split into their respective terms, and multiplication
     (commutative and non-commutative) to be distributed over addition
     at all levels of exp.  For polynomials one should usually use
     RATEXPAND which uses a more efficient algorithm (see
     DESCRIBE(RATEXPAND);).  MAXNEGEX[1000] and MAXPOSEX[1000] control
     the maximum negative and positive exponents, respectively, which
     will expand.  EXPAND(exp,p,n) expands exp, using p for MAXPOSEX
     and n for MAXNEGEX.  This is useful in order to expand part but
     not all of an expression.  EXPON[0] - the exponent of the largest
     negative power which is automatically expanded (independent of
     calls to EXPAND).  For example if EXPON is 4 then (X+1)^(-5) will
     not be automatically expanded.  EXPOP[0] - the highest positive
     exponent which is automatically expanded.  Thus (X+1)^3, when
     typed, will be automatically expanded only if EXPOP is greater
     than or equal to 3.  If it is desired to have (X+1)^N expanded
     where N is greater than EXPOP then executing EXPAND((X+1)^N) will
     work only if MAXPOSEX is not less than N.  The EXPAND flag used
     with EV (see EV) causes expansion.

     The file `simplification/facexp.mac' contains several related
     functions (in particular FACSUM, FACTORFACSUM and COLLECTTERMS,
     which are autoloaded) and variables (NEXTLAYERFACTOR and
     FACSUM_COMBINE) that provide the user with the ability to structure
     expressions by controlled expansion.  Brief function descriptions
     are available in `simplification/facexp.usg'.  A demo is available
     by doing `demo("facexp")$'.


 - Function: EXPANDWRT (exp,var1,var2,...)
     expands exp with respect to the vari.  All products involving the
     vari appear explicitly.  The form returned will be free of
     products of sums of expressions that are not free of the vari.
     The vari may be variables, operators, or expressions.  By default,
     denominators are not expanded, but this can be controlled by means
     of the switch EXPANDWRT_DENOM.  This function is autoloaded from
     `simplification/stopex.mac'.


 - Variable: EXPANDWRT_DENOM
     default:[FALSE] controls the treatment of rational expressions by
     EXPANDWRT.  If TRUE, then both the numerator and denominator of
     the expression will be expanded according to the arguments of
     EXPANDWRT, but if EXPANDWRT_DENOM is FALSE, then only the
     numerator will be expanded in that way.


 - Function: EXPANDWRT_FACTORED (exp, var1, var2, ..., varN)
     is similar to EXPANDWRT, but treats expressions that are products
     somewhat differently.  EXPANDWRT_FACTORED will perform the
     required expansion only on those factors of exp that contain the
     variables in its argument list argument list.  This function is
     autoloaded from `simplification/stopex.mac'.


 - Variable: EXPON
     default: [0] - the exponent of the largest negative power which is
     automatically expanded (independent of calls to EXPAND).  For
     example if EXPON is 4 then (X+1)^(-5) will not be automatically
     expanded.


 - Variable: EXPONENTIALIZE
     default: [FALSE] if TRUE will cause all circular and hyperbolic
     functions to be converted to exponential form.  (Setting
     DEMOIVRE:TRUE; will reverse the effect.)  EXPONENTIALIZE(exp) will
     cause the conversion to exponential form of an expression without
     setting the switch or having to re-evaluate the expression with EV.


 - Variable: EXPOP
     default: [0] - the highest positive exponent which is
     automatically expanded.  Thus (X+1)^3, when typed, will be
     automatically expanded only if EXPOP is greater than or equal to 3.
     If it is desired to have (X+1)^n expanded where n is greater than
     EXPOP then executing EXPAND((X+1)^n) will work only if MAXPOSEX is
     not less than n.


 - Variable: FACTLIM
     default: [-1] gives the highest factorial which is automatically
     expanded.  If it is -1 then all integers are expanded.


 - Function: INTOSUM (expr)
     will take all things that a summation is multiplied by, and put
     them inside the summation. If the index is used in the outside
     expression, then the function tries to find a reasonable index,
     the same as it does for SUMCONTRACT.  This is essentially the
     reverse idea of the OUTATIVE property of summations, but note that
     it does not remove this property, it only bypasses it.  In some
     cases, a SCANMAP(MULTTHRU,expr) may be necessary before the
     INTOSUM.


 - declaration: LASSOCIATIVE
     - If DECLARE(G,LASSOCIATIVE); is done, this tells the simplifier
     that G is left-associative.  E.g.  G(G(A,B),G(C,D)) will simplify
     to G(G(G(A,B),C),D).


 - declaration: LINEAR
     - One of MACSYMA's OPPROPERTIES.  For univariate f so declared,
     "expansion" F(X+Y) -> F(X)+F(Y), F(A*X) -> A*F(X) takes place
     where A is a "constant".  For functions F of >=2 args, "linearity"
     is defined to be as in the case of 'SUM or 'INTEGRATE, i.e.
     F(A*X+B,X) -> A*F(X,X)+B*F(1,X) for A,B FREEOF X.  (LINEAR is just
     ADDITIVE + OUTATIVE.)


 - declaration: MAINVAR
     - You may DECLARE variables to be MAINVAR.  The ordering scale for
     atoms is essentially: numbers < constants (e.g. %E,%PI) < scalars
     < other variables < mainvars.  E.g. compare EXPAND((X+Y)^4); with
     (DECLARE(X,MAINVAR), EXPAND((X+Y)^4)); .  (Note: Care should be
     taken if you elect to use the above feature.  E.g. if you subtract
     an expression in which X is a MAINVAR from one in which X isn't a
     MAINVAR, resimplification e.g. with EV(expression,SIMP) may be
     necessary if cancellation is to occur.  Also, if you SAVE an
     expression in which X is a MAINVAR, you probably should also SAVE
     X.)


 - Variable: MAXAPPLYDEPTH
     default: [10000] - the maximum depth to which APPLY1 and APPLY2
     will delve.


 - Variable: MAXAPPLYHEIGHT
     default: [10000] - the maximum height to which APPLYB1 will reach
     before giving up.


 - Variable: MAXNEGEX
     default: [1000] - the largest negative exponent which will be
     expanded by the EXPAND command (see also MAXPOSEX).


 - Variable: MAXPOSEX
     default: [1000] - the largest exponent which will be expanded with
     the EXPAND command (see also MAXNEGEX).


 - declaration: MULTIPLICATIVE
     - If DECLARE(F,MULTIPLICATIVE) has been executed, then: (1) If F
     is univariate, whenever the simplifier encounters F applied to a
     product, F will be distributed over that product.  I.e. F(X*Y);
     will simplify to F(X)*F(Y).  (2) If F is a function of 2 or more
     arguments, multiplicativity is defined as multiplicativity in the
     first argument to F, i.e.  F(G(X)*H(X),X); will simplify to
     F(G(X),X)*F(H(X),X).  This simplification does not occur when F is
     applied to expressions of the form
     PRODUCT(X[I],I,lower-limit,upper-limit).


 - Variable: NEGDISTRIB
     default: [TRUE] - when TRUE allows -1 to be distributed over an
     expression.  E.g. -(X+Y) becomes -Y-X.  Setting it to FALSE will
     allow -(X+Y) to be displayed like that.  This is sometimes useful
     but be very careful: like the SIMP flag, this is one flag you do
     not want to set to FALSE as a matter of course or necessarily for
     other than local use in your MACSYMA.


 - Variable: NEGSUMDISPFLAG
     default: [TRUE] - when TRUE, X-Y displays as X-Y instead of as
     -Y+X.  Setting it to FALSE causes the special check in display for
     the difference of two expressions to not be done.  One application
     is that thus A+%I*B and A-%I*B may both be displayed the same way.


 - special symbol: NOEVAL
     - suppresses the evaluation phase of EV.  This is useful in
     conjunction with other switches and in causing expressions to be
     resimplified without being reevaluated.


 - declaration: NOUN
     - One of the options of the DECLARE command.  It makes a function
     so DECLAREd a "noun", meaning that it won't be evaluated
     automatically.


 - Variable: NOUNDISP
     default: [FALSE] - if TRUE will cause NOUNs to display with a
     single quote.  This switch is always TRUE when displaying function
     definitions.


 - special symbol: NOUNS
     (EVFLAG) when used as an option to the EV command, converts all
     "noun" forms occurring in the expression being EV'd to "verbs",
     i.e.  evaluates them.  See also NOUN, NOUNIFY, VERB, and VERBIFY.


 - special symbol: NUMER
     causes some mathematical functions (including exponentiation) with
     numerical arguments to be evaluated in floating point. It causes
     variables in exp which have been given numervals to be replaced by
     their values.  It also sets the FLOAT switch on.


 - Function: NUMERVAL (var1, exp1, var2, exp2, ...)
     declares vari to have a numerval of expi which is evaluated and
     substituted for the variable in any expressions in which the
     variable occurs if the NUMER flag is TRUE. (see the EV function).


 - Variable: OPPROPERTIES
     - the list of the special operator-properties handled by the
     MACSYMA simplifier: LINEAR, ADDITIVE, MULTIPLICATIVE, OUTATIVE,
     EVENFUN, ODDFUN, COMMUTATIVE, SYMMETRIC, ANTISYMMETRIC, NARY,
     LASSOCIATIVE, and RASSOCIATIVE.


 - Variable: OPSUBST
     default:[TRUE] - if FALSE, SUBST will not attempt to substitute
     into the operator of an expression.  E.g. (OPSUBST:FALSE,
     SUBST(X^2,R,R+R[0])); will work.


 - declaration: OUTATIVE
     - If DECLARE(F,OUTATIVE) has been executed, then: (1) If F is
     univariate, whenever the simplifier encounters F applied to a
     product, that product will be partitioned into factors that are
     constant and factors that are not and the constant factors will be
     pulled out.  I.e. F(A*X); will simplify to A*F(X) where A is a
     constant.  Non-atomic constant factors will not be pulled out.
     (2) If F is a function of 2 or more arguments, outativity is
     defined as in the case of 'SUM or 'INTEGRATE, i.e. F(A*G(X),X);
     will simplify to A*F(G(X),X) for A free-of X.  Initially, 'SUM,
     'INTEGRATE, and 'LIMIT are declared to be OUTATIVE.


 - declaration: POSFUN
     - POSitive FUNction, e.g. DECLARE(F,POSFUN); IS(F(X)>0); -> TRUE.


 - Variable: PRODHACK
     default: [FALSE] - if set to TRUE then PRODUCT(F(I),I,3,1); will
     yield 1/F(2), by the identity PRODUCT(F(I),I,A,B) =
     1/PRODUCT(F(I),I,B+1,A-1) when A>B.


 - Function: RADCAN (exp)
     simplifies exp, which can contain logs, exponentials, and
     radicals, by converting it into a form which is canonical over a
     large class of expressions and a given ordering of variables; that
     is, all functionally equivalent forms are mapped into a unique
     form.  For a somewhat larger class of expressions, RADCAN produces
     a regular form.  Two equivalent expressions in this class will not
     necessarily have the same appearance, but their difference will be
     simplified by RADCAN to zero.  For some expressions RADCAN can be
     quite time consuming.  This is the cost of exploring certain
     relationships among the components of the expression for
     simplifications based on factoring and partial-fraction expansions
     of exponents.  %E_TO_NUMLOG (default: [FALSE]) - when set to TRUE,
     for "r" some rational number, and "x" some expression,
     %E^(r*LOG(x)) will be simplified into x^r .  RADEXPAND[TRUE] when
     set to FALSE will inhibit certain transformations:
     RADCAN(SQRT(1-X)) will remain SQRT(1-X) and will not become %I
     SQRT(X-1).  RADCAN(SQRT(X^2-2*X+1)) will remain SQRT(X^2-2*X + 1)
     and will not be transformed to X- 1.  Do EXAMPLE(RADCAN); for
     examples.


 - Variable: RADEXPAND
     default: [TRUE] - if set to ALL will cause nth roots of factors of
     a product which are powers of n to be pulled outside of the
     radical.  E.g. if RADEXPAND is ALL, SQRT(16*X^2) will become 4*X .
     More particularly, consider SQRT(X^2).  (a) If RADEXPAND is ALL or
     ASSUME(X>0) has been done, SQRT(X^2) will become X.  (b) If
     RADEXPAND is TRUE and DOMAIN is REAL (its default), SQRT(X^2) will
     become ABS(X).  (c) If RADEXPAND is FALSE, or RADEXPAND is TRUE
     and DOMAIN is COMPLEX, SQRT(X^2) will be returned.  (The notion of
     DOMAIN with settings of REAL or COMPLEX is still in its infancy.
     Note that its setting here only matters when RADEXPAND is TRUE.)


 - Variable: RADPRODEXPAND
     - this switch has been renamed RADEXPAND.


 - Variable: RADSUBSTFLAG
     default: [FALSE] - if TRUE permits RATSUBST to make substitutions
     such as U for SQRT(X) in X.


 - declaration: RASSOCIATIVE
     - If DECLARE(G,RASSOCIATIVE); is done, this tells the simplifier
     that G is right-associative.  E.g.  G(G(A,B),G(C,D)) will simplify
     to G(A,G(B,G(C,D))).


 - Function: SCSIMP (exp,rule1, rule2,...,rulen)
     Sequential Comparative Simplification [Stoute]) takes an
     expression (its first argument) and a set of identities, or rules
     (its other arguments) and tries simplifying.  If a smaller
     expression is obtained, the process repeats.  Otherwise after all
     simplifications are tried, it returns the original answer.  For
     examples, try EXAMPLE(SCSIMP); .


 - Function: SIMP
     causes exp to be simplified regardless of the setting of the
     switch SIMP which inhibits simplification if FALSE.


 - Variable: SIMPSUM
     default: [FALSE] - if TRUE, the result of a SUM is simplified.
     This simplification may sometimes be able to produce a closed
     form.  If SIMPSUM is FALSE or if 'SUM is used, the value is a sum
     noun form which is a representation of the sigma notation used in
     mathematics.


 - Function: SUMCONTRACT (expr)
     will combine all sums of an addition that have upper and lower
     bounds that differ by constants. The result will be an expression
     containing one summation for each set of such summations added to
     all appropriate extra terms that had to be extracted to form this
     sum.  SUMCONTRACT will combine all compatible sums and use one of
     the indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.  It may be
     necessary to do an INTOSUM(expr) before the SUMCONTRACT.


 - Variable: SUMEXPAND
     default: [FALSE] if TRUE, products of sums and exponentiated sums
     are converted into nested sums. For example:
                  SUMEXPAND:TRUE$
                  SUM(F(I),I,0,M)*SUM(G(J),J,0,N); ->
                                  'SUM('SUM(F(I1)*G(I2),I2,0,N),I1,0,M)
                  SUM(F(I),I,0,M)^2; -> 'SUM('SUM(F(I3)*F(I4),I4,0,M),I3,0,M)

     If FALSE, they are left alone.  See also CAUCHYSUM.


 - Variable: SUMHACK
     default: [FALSE] - if set to TRUE then SUM(F(I),I,3,1); will yield
     -F(2), by the identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1)
     when A>B.


 - Variable: SUMSPLITFACT
     default: [TRUE] - if set to FALSE will cause MINFACTORIAL to be
     applied after a FACTCOMB.


 - declaration: SYMMETRIC
     - If DECLARE(H,SYMMETRIC); is done, this tells the simplifier that
     H is a symmetric function.  E.g. H(X,Z,Y) will simplify to H(X, Y,
     Z).  This is the same as COMMUTATIVE.


 - Function: UNKNOWN (exp)
     returns TRUE iff exp contains an operator or function not known to
     the built-in simplifier.



File: maxima.info,  Node: Plotting,  Next: Input and Output,  Prev: Simplification,  Up: Top

Plotting
********

* Menu:

* Definitions for Plotting::


File: maxima.info,  Node: Definitions for Plotting,  Prev: Plotting,  Up: Plotting

Definitions for Plotting
========================

 - Variable: IN_NETMATH [FALSE]
     If not nil, then plot2d will output a representation of the plot
     which is suitable for openplot functions.

 - Function: OPENPLOT_CURVES list rest-options
     Takes a list of curves such as
          [[x1,y1,x2,y2,...],[u1,v1,u2,v2,...],..]
          or
           [[[x1,y1],[x2,y2],...],.. ]
     and plots them.  This is similar to xgraph_curves, but uses the
     open plot routines.  Addtional symbol arguments may be given such
     as ` "{xrange -3 4}" ' The following plots two curves, using big
     points, labeling the first one `jim' and the second one `jane'.
          openplot_curves([["{plotpoints 1} {pointsize 6} {label jim}
                {text {xaxislabel {joe is nice}}}"] ,
                [1,2,3,4,5,6,7,8],
                ["{label jane} {color pink } "], [3,1,4,2,5,7]]);

     Some other special keywords are xfun, color, plotpoints,
     linecolors, pointsize, nolines, bargraph, labelposition,
     xaxislabel, and yaxislabel.


 - Function: PLOT2D (expr,range,...,options,..)
 - Function: PLOT2D ([expr1,expr2,..,exprn],xrange,...,options,..)
 - Function: PLOT2D (parametric_expr)
 - Function: PLOT2D ([..,expr,..,parametric_expr,..],xrange,...,options)
     EXPR is an expression to be plotted on y axis as a function of 1
     variable.  RANGE is of the form [var,min,max] and expr is assumed
     to be an expression to be plotted against VAR.  In the second form
     of the function a list of expressions may be given to plot against
     VAR.   Truncation in the y direction will be performed, for the
     default y range.   It may be specified as an option or using
     SET_PLOT_OPTION.

          (C1) plot2d(sin(x),[x,-5,5]);
          (C2) plot2d(sec(x),[x,-2,2],[y,-20,20],[nticks,200]);

     Anywhere there may be an EXPR you may also use a parametric
     expression: PARAMETRIC_EXPR is a Maxima list of the form
     `[parametric, xexpr, yexpr, trange, ..options]' Here XEXPR and
     YEXPR are functions of 1 variable VAR which is the first element
     of the range TRANGE.  The plot is of the path traced out by the
     pair `[XEXPR, YEXPR]' as VAR varies in TRANGE.  In the following
     example, we plot a circle, then we do the plot with only a few
     points used, so that we get a star, and finally we plot this
     together with an ordinary function of X.

          (C1) plot2d([parametric,cos(t),sin(t),[t,-%pi*2,%pi*2]]);
          (C2) plot2d([parametric,cos(t),sin(t),[t,-%pi*2,%pi*2],
                  [nticks,8]]);
          (C3) plot2d([x^3+2,[parametric,cos(t),sin(t),[t,-5,5]]],
                  [x,-3,3]);


 - Function: xgraph_curves (list)
     graphs the list of `point sets' given in list by using xgraph.

     A point set may be of the form

          [x0,y0,x1,y1,x2,y2,...] or
          [[x0,y0],[x1,y1],....]
     A point set may also contain symbols which give labels or other
     information.

           xgraph_curves([pt_set1,pt_set2,pt_set3]);
     would graph the three point sets as three curves.

          pt_set:append(["NoLines: True","LargePixels: true"],
                  [x0,y0,x1,y1,...])

     would make the point set [and subsequent ones], have no lines
     between points, and to use large pixels.  See the man page on
     xgraph for more options to specify.

          pt_set:append([concat("\"","x^2+y")],[x0,y0,x1,y1,...])

     would make there be a "label" of "x^2+y" for this particular point
     set.    The `"' at the beginning is what tells xgraph this is a
     label.

          pt_set:append([concat("TitleText: Sample Data")],[x0,...])

     would make the main title of the plot be "Sample Data" instead of
     "Maxima PLot".

     To make a bar graph with bars which are .2 units wide, and to plot
     two possibly different such bar graphs:
          xgraph_curves(
                 [append(["BarGraph: true","NoLines: true","BarWidth: .2"],
                         create_list([i-.2,i^2],i,1,3)),
                  append(["BarGraph: true","NoLines: true","BarWidth: .2"],
                     create_list([i+.2,.7*i^2],i,1,3))
          ]);

     A temporary file `xgraph-out' is used.


 - Variable: PLOT_OPTIONS
     Members of this list indicate defaults for plotting.  They may be
     altered using SET_PLOT_OPTION

          [X, - 3, 3]
          [Y, - 3, 3]

     are the x range and y range respectively.

     [TRANSFORM_XY, FALSE] if not false, should be the output of

          make_transform([x,y,z], [f1(x,y,z),f2(x,y,z),f3(x,y,z)])
     which produces a transformation from 3 space to 3 space, which
     will be applied to the graph.   A built in one is polar_xy which
     gives the same as

          make_transform([r,th,z],[r*cos(th),r*sin(th),z])

     [RUN_VIEWER,TRUE] if not false, means run the viewer software -
     don't just output a data file.

     [GRID,30,30] means plot3d should divide the x range into 30
     intervals and similarly the y range.

     [COLOUR_Z,false] applies to colouring done with plot_format ps.

     [PLOT_FORMAT,OPENMATH] is for plot3d and currently  OPENMATH,
     GNUPLOT, PS, and GEOMVIEW are supported.

     There are good quality public domain viewers for these formats.
     They are openmath, izic, gnuplot, ghostview, and geomview.

     The Openmath viewer is in the distribution, and is based on tcl/tk.
     The executable is `maxima/bin/omplotdata'.  The viewer lets you
     zoom in, slide around, and rotate (if 3 dimensional).  This format
     is also the one used by netmath, for making plots with Netmath.
     (see `http://www.ma.utexas.edu/users/wfs/netmath.html')

     geomview is from the Geometry Center at the University of
     Minnesota, and is available from
     `http://www.geom.umn.edu/software/download/geomview.html' or by
     anonymous ftp from
     `ftp://ftp.geom.umn.edu/pub/software/geomview/'.  It is currently
     not quite as pretty as izic, but provides excellent support for
     multiple objects and multiple lights.

     gnuplot is everywhere as is ghostview.   We also provide mgnuplot,
     a tcl interface for gnuplot, which lets you rotate the plots using
     the mouse and a scale.

     izic is available by ftp from zenon.inria.fr.  Contact one of

     {fournier,kajler,mourrain}@sophia.inria.fr.

     It has beautiful colour gouraud shading, and very fast wireframe.
     It runs on X windows.


 - Function: PLOT3D (expr,xrange,yrange,...,options,..)
 - Function: PLOT3D ([expr1,expr2,expr3],xrange,yrange,...,options,..)
          plot3d(2^(-u^2+v^2),[u,-5,5],[v,-7,7]);
     would plot z = 2^(-u^2+v^2) with u and v varying in [-5,5] and
     [-7,7] respectively, and with u on the x axis, and v on the y axis.

     An example of the second pattern of arguments is
          plot3d([cos(x)*(3+y*cos(x/2)),sin(x)*(3+y*cos(x/2)),y*sin(x/2)],
             [x,-%pi,%pi],[y,-1,1],['grid,50,15])

     which will plot a moebius band, parametrized by the 3 expressions
     given as the first argument to plot3d.  An additional optional
     argument [grid,50,15] gives the grid number of rectangles in the x
     direction and y direction.

          /* REal part of z ^ 1/3 */
           plot3d(r^.33*cos(th/3),[r,0,1],[th,0,6*%pi],
               ['grid,12,80],['PLOT_FORMAT,ps],
               ['TRANSFORM_XY,POLAR_TO_XY],['VIEW_DIRECTION,1,1,1.4],
               ['COLOUR_Z,true])

     Here the View_direction indicates the direction from which we take
     a projection.  We actually do this from infinitely far away, but
     parallel to the line from view_direction to the origin.  This is
     currently only used in 'ps' plot_format, since the other viewers
     allow interactive rotating of the object.

     Another example is a moebius band:
          plot3d([cos(x)*(3+y*cos(x/2)),
                    sin(x)*(3+y*cos(x/2)),y*sin(x/2)],
                     [x,-%pi,%pi],[y,-1,1],['grid,50,15]);

     or a klein bottle:

          plot3d([5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0) - 10.0,
                    -5*sin(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0),
                     5*(-sin(x/2)*cos(y)+cos(x/2)*sin(2*y))],
                     [x,-%pi,%pi],[y,-%pi,%pi],['grid,40,40])

     or a torus
          plot3d([cos(y)*(10.0+6*cos(x)),
                     sin(y)*(10.0+6*cos(x)),
                     -6*sin(x)], [x,0,2*%pi],[y,0,2*%pi],
                      ['grid,40,40])
     We can output to gnplot too:

           plot3d(2^(x^2-y^2),[x,-1,1],[y,-2,2],[plot_format,gnuplot])

     Sometimes you may need to define a function to plot the
     expression.  All the arguments to plot3d are evaluated before
     being passed to plot3d, and so trying to make an expression which
     does just what you want may be difficult, and it is just easier to
     make a function.
          M:MATRIX([1,2,3,4],[1,2,3,2],[1,2,3,4],[1,2,3,3])$
          f(x,y):=float(M[?round(x),?round(y)]);
          plot3d(f,[x,1,4],[y,1,4],['grid,4,4]);


 - Function: PLOT2D_PS (expr,range)
     writes to pstream a sequence of postscript commands which plot
     EXPR for RANGE.  EXPR should be an expression of 1 variable.
     RANGE should be of the form [variable,min,max] over which to plot
     expr.  see CLOSEPS.


 - Function: CLOSEPS ()
     This should usually becalled at the end of a sequence of plotting
     commands.   It closes the current output stream PSTREAM, and sets
     it to nil.   It also may be called at the start of a plot, to
     ensure pstream is closed if it was open.    All commands which
     write to pstream, open it if necessary.   CLOSEPS is separate from
     the other plotting commands, since we may want to plot 2 ranges or
     superimpose several plots, and so must keep the stream open.

 - Function: SET_PLOT_OPTION (option)
     option is of the format of one of the elements of the PLOT_OPTIONS
     list.  Thus
          SET_PLOT_OPTION([grid,30,40])
     would change the default grid used by plot3d.   Note that if the
     symbol grid has a value, then you should quote it here:
          SET_PLOT_OPTION(['grid,30,40])
     so that the value will not be substituted.

 - Function: PSDRAW_CURVE (ptlist)
     Draws a curve connecting the points in PTLIST.   The latter may be
     of the form [x0,y0,x1,y1,...] or [[x0,y0],[x1,y1],...]  The
     function JOIN is handy for taking a list of x's and a list of y's
     and splicing them together.  PSDRAW_CURVE simply invokes the more
     primitive function PSCURVE.   Here is the definition:

          (defun $psdraw_curve (lis)
            (p "newpath")
            ($pscurve lis)
            (p "stroke"))

     ?DRAW2D  may also be used to produce a list
           points1:?draw2d(1/x,[.05,10],.03)


 - Function: PSCOM (com)
     COM will be inserted in the poscript file eg
            pscom("4.5 72 mul 5.5 72 mul translate  14 14 scale");



File: maxima.info,  Node: Input and Output,  Next: Floating Point,  Prev: Plotting,  Up: Top

Input and Output
****************

* Menu:

* Introduction to Input and Output::
* FILES::
* PLAYBACK::
* Definitions for Input and Output::


File: maxima.info,  Node: Introduction to Input and Output,  Next: FILES,  Prev: Input and Output,  Up: Input and Output

Introduction to Input and Output
================================


File: maxima.info,  Node: FILES,  Next: PLAYBACK,  Prev: Introduction to Input and Output,  Up: Input and Output

FILES
=====

- A file is simply an area on a particular storage device which
contains data or text.  The only storage devices which are used on the
MC machine are disks and tapes.  Files on the disks are figuratively
grouped into "directories".  A directory is just a list of all the
files stored under a given user name.  Do DESCRIBE(FILEOP); for details
of how you may inspect your files using MACSYMA.  Other commands which
deal with files are: SAVE, FASSAVE, STORE, LOAD, LOADFILE, RESTORE,
UNSTORE, STRINGOUT, BATCH, BATCON, DEMO, WRITEFILE, CLOSEFILE, DELFILE,
REMFILE, and APPENDFILE.


File: maxima.info,  Node: PLAYBACK,  Next: Definitions for Input and Output,  Prev: FILES,  Up: Input and Output

PLAYBACK
========

It is possible to play back the input lines in a temporary scroll down
window, and so not lose ones current work.  This can be done by typing
Function  E.  A numeric argument tells it the line number to start at,
otherwise it will go back about 40 lines.


File: maxima.info,  Node: Definitions for Input and Output,  Prev: PLAYBACK,  Up: Input and Output

Definitions for Input and Output
================================

 - Variable: %
     The last D-line computed by MACSYMA (whether or not it was printed
     out).  (See also %%.)


 - Variable: %%
     The value of the last computation performed while in a
     (MACSYMA-BREAK).  Also may be used in compound statements in the
     nth statement to refer to the value of the (n-1)th statement.  E.g.
     F(N):=(INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%)); is in essence
     equivalent to F(N):=BLOCK([%%], %%:INTEGRATE(X^N,X),
     SUBST(3,X,%%)-SUBST(2,X,%%)); This will also work for communicating
     between the (n-1)th and nth (non-atomic) BLOCK statements.


 - Variable: %EDISPFLAG
     default: [FALSE] - if TRUE, MACSYMA displays %E to a negative
     exponent as a quotient, i.e. %E^-X as 1/%E^X.


 - Function: %TH (i)
     is the ith previous computation.  That is, if the next expression
     to be computed is D(j) this is D(j-i).  This is useful in BATCH
     files or for referring to a group of D expressions.  For example,
     if SUM is initialized to 0 then FOR I:1 THRU 10 DO SUM:SUM+%TH(I)
     will set SUM to the sum of the last ten D expressions.


 - special symbol: "?"
     - As prefix to a function or variable name, signifies that the
     function or variable is a LISP token, not a MACSYMA token.  Two
     question marks typed together, ??, will flush the current MACSYMA
     command line.


 - Variable: ABSBOXCHAR
     default: [!] is the character used to draw absolute value signs
     around expressions which are more than a single line high.

 - Function: APPENDFILE (filename1, filename2, DSK, directory)
     is like WRITEFILE(DSK,directory) but appends to the file whose
     name is specified by the first two arguments.  A subsequent
     CLOSEFILE will delete the original file and rename the appended
     file.


 - Function: BACKUP ()
     To "back up" and see what you did, see PLAYBACK.


 - Function: BATCH (file-specification)
     reads in and evaluates MACSYMA command lines from a file - A
     facility for executing command lines stored on a disk file rather
     than in the usual on-line mode. This facility has several uses,
     namely to provide a reservoir for working command lines, for
     giving error-free demonstrations, or helping in organizing one's
     thinking in complex problem-solving situations where modifications
     may be done via a text editor.  A batch file consists of a set of
     MACSYMA command lines, each with its terminating ; or $, which may
     be further separated by spaces, carriage- returns, form-feeds, and
     the like.  The BATCH function calls for reading in the command
     lines from the file one at a time, echoing them on the user
     console, and executing them in turn.  Control is returned to the
     user console only when serious errors occur or when the end of the
     file is met.  Of course, the user may quit out of the
     file-processing by typing control-G at any point.  BATCH files may
     be created using a text editor or by use of the STRINGOUT command.
     Do DESCRIBE(STRINGOUT) for details DESCRIBE(FILE); and
     DESCRIBE(FILES); have additional information on how the file
     argument is interpreted, and files in general.


 - Variable: BATCHKILL
     default: [FALSE] if TRUE then the effect of all previous BATCH
     files is nullified because a KILL(ALL) and a RESET() will be done
     automatically when the next one is read in.  If BATCHKILL is bound
     to any other atom then a KILL of the value of BATCHKILL will be
     done.


 - Function: BATCHLOAD (file-specification)
     Batches in the file silently without terminal output or labels.


 - Function: BATCON (argument)
     continues BATCHing in a file which was interrupted.


 - Variable: BATCOUNT
     default: [0] may be set to the number of the last expression
     BATCHed in from a file.  Thus BATCON(BATCOUNT-1) will resume
     BATCHing from the expression before the last BATCHed in from
     before.


 - Variable: BOTHCASES
     default: [TRUE] if TRUE will cause MAXIMA to retain lower case
     text as well as upper case. Note, however, that the names of any
     MAXIMA special variables or functions are in upper case.   The
     default is now TRUE since it makes code more readable, allowing
     users to have names like SeriesSolve.

     Because of this we make the system variables and functions all
     upper case, and users may enter them however they like (in upper
     or lower).  But all other variables and functions are case
     sensitive.  When you print out your program using for example
     grind(fundef(f)) then you will see that the symbols like 'IF',
     'SIN',... all appear in upper case whereas non system symbols
     appear in the case which you used.

     This is implemented as follows: If the symbol is being encountered
     for the first time, if the upper case version is in the package
     and has a nontrivial function or property list, then the upper
     case symbol is used, and it is recorded on the mixed case one,
     that the upper case should be used in future.  If a symbol is
     already in the package then it is just used.

     In effect this means that most old programs should continue to
     work, and that new ones may write sIn, Sin, SIN, sin etc and they
     will all be interpreted as SIN.   However if they write MySin this
     will be different from MYSIN, because MYSIN is not a system
     function or variable.

          SeriesSolve(f,x):=
             if (f = sin) ...
          
          and this is read as
          
          SeriesSolve(f,x):=
             IF (f = SIN) ...


 - Variable: CHANGE_FILEDEFAULTS
     default: [TRUE] on PDP10 systems, and FALSE elsewhere.  Controls
     whether the user doing a LOADFILE or BATCH has his file defaults
     changed to the file LOADFILEd or BATCHed.  The TRUE setting is for
     people who like DDT-style file defaulting.  The FALSE setting is
     for people who like the conventions of other operating systems,
     who like LISP-style file defaulting, or who write packages which
     do LOADFILEs or BATCHes which should not interfere with their
     user's file defaults.


 - Function: CLOSEFILE (filename1, filename2)
     closes a file opened by WRITEFILE and gives it the name filename1
     filename2.  (On a Lisp Machine one need only say CLOSEFILE();.)
     Thus to save a file consisting of the display of all input and
     output during some part of a session with MACSYMA the user issues
     a WRITEFILE, transacts with MACSYMA, then issues a CLOSEFILE.  The
     user can also issue the PLAYBACK function after a WRITEFILE to
     save the display of previous transactions.  (Note that what is
     saved this way is a copy of the display of expressions not the
     expressions themselves).  To save the actual expression in internal
     form the SAVE function may be used.  The expression can then be
     brought back into MACSYMA via the LOADFILE function.  To save the
     expression in a linear form which may then be BATCHed in later, the
     STRINGOUT function is used.


 - Function: COLLAPSE (expression)
     collapses" its argument by causing all of its common (i.e. equal)
     subexpressions to share (i.e. use the same cells), thereby saving
     space.  (COLLAPSE is a subroutine used by the OPTIMIZE command.)
     Thus, calling COLLAPSE may be useful before using FASSAVE or after
     loading in a SAVE file.  You can collapse several expressions
     together by using COLLAPSE([expr1,...,exprN])$.  Similarly, you can
     collapse the elements of the array A by doing
     COLLAPSE(LISTARRAY('A))$.


 - Function: CONCAT (arg1, arg2, ...)
     evaluates its arguments and returns the concatenation of their
     values resulting in a name or a quoted string the type being given
     by that of the first argument.  Thus if X is bound to 1 and D is
     unbound then CONCAT(X,2)="12" and CONCAT(D,X+1)=D2.


 - Function: SCONCAT (arg1, arg2, ...)
     evaluates its arguments and concatenates them into a string.
     Unlike CONCAT, the arguments do NOT need to be atoms.    The
     result is a Common Lisp String.
          (C5) sconcat("xx[",3,"]:",expand((x+y)^3));
          (D5) 			 xx[3]:Y^3+3*X*Y^2+3*X^2*Y+X^3
     The resulting string could be used in conjunction with print.

 - Variable: CURSORDISP
     default: [TRUE] If TRUE, causes expressions to be drawn by the
     displayer in logical sequence.  This only works with a console
     which can do cursor movement.  If FALSE, expressions are simply
     printed line by line.  CURSORDISP is FALSE when a WRITEFILE is in
     effect.


 - Variable: DIREC
     - The value of this variable is the default file directory for
     SAVE, STORE, FASSAVE, and STRINGOUT.  It is initialized to the
     user's login name, if he has a disk directory, and to one of the
     USERSi directories otherwise.  DIREC determines to what directory
     disk files will be written.


 - Function: DISP (expr1,expr2, ...)
     is like DISPLAY but only the value of the arguments are displayed
     rather than equations.  This is useful for complicated arguments
     which don't have names or where only the value of the argument is
     of interest and not the name.


 - Function: DISPCON (tensor1,tensor2,...)
     displays the contraction properties of the tensori as were given
     to DEFCON.  DISPCON(ALL) displays all the contraction properties
     which were defined.


 - Function: DISPLAY (expr1, expr2, ...)
     displays equations whose left side is expri unevaluated, and whose
     right side is the value of the expression centered on the line.
     This function is useful in blocks and FOR statements in order to
     have intermediate results displayed.  The arguments to DISPLAY are
     usually atoms, subscripted variables, or function calls.  (see the
     DISP function)

          (C1) DISPLAY(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (D1)                            DONE

 - Variable: DISPLAY2D
     default: [TRUE] - if set to FALSE will cause the standard display
     to be a string (1-dimensional) form rather than a display
     (2-dimensional) form.  This may be of benefit for users on printing
     consoles who would like to conserve paper.


 - Variable: DISPLAY_FORMAT_INTERNAL
     default: [FALSE] - if set to TRUE will cause expressions to be
     displayed without being transformed in ways that hide the internal
     mathematical representation.  The display then corresponds to what
     the INPART command returns rather than the PART command.  Examples:
          User     PART       INPART
          a-b;      A - B     A + (- 1) B
                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   SQRT(X)    X
                    4 X        4
          X*4/3;    ---        - X
                     3         3

 - Function: DISPTERMS (expr)
     displays its argument in parts one below the other.  That is,
     first the operator of 'expr' is displayed, then each term in a
     sum, or factor in a product, or part of a more general expression
     is displayed separately.  This is useful if expr is too large to be
     otherwise displayed.  For example if P1, P2, ...  are very large
     expressions then the display program may run out of storage space
     in trying to display P1+P2+...  all at once.  However,
     DISPTERMS(P1+P2+...) will display P1, then below it P2, etc.  When
     not using DISPTERMS, if an exponential expression is too wide to be
     displayed as A**B it will appear as EXPT(A,B) (or as NCEXPT(A,B) in
     the case of A^^B).


 - Variable: DSKALL
     default: [] If TRUE will cause values, functions, arrays, and
     rules to be written periodically onto the disk in addition to
     labelled expressions.  TRUE is the default value whereas if DSKALL
     is FALSE then only labelled expresions will be written.


 - Variable: ERROR_SIZE
     default: [20 for a display terminal, 10 for others].  controls the
     size of error messages.  For example, let
     U:(C^D^E+B+A)/(COS(X-1)+1); .  U has an error size of 24.  So if
     ERROR_SIZE has value < 24 then
          (C1) ERROR("The function", FOO,"doesn't like", U,"as input.");
          prints as:
          The function FOO doesn't like ERREXP1 as input.
          If ERROR_SIZE>24 then as:
                                           E
                                          D
                                         C   + B + A
          The function FOO doesn't like -------------- as input.
                                        COS(X - 1) + 1

     Expressions larger than ERROR_SIZE are replaced by symbols, and the
     symbols are set to the expressions.  The symbols are taken from the
     user-settable list
          ERROR_SYMS:[ERREXP1,ERREXP2,ERREXP3]
     .  The default value of this switch might change depending on user
     experience.  If you find the defaults either too big or two small
     for your tastes, send mail to MACSYMA.


 - Variable: ERROR_SYMS
     default: [ERREXP1,ERREXP2,ERREXP3] - In error messages,
     expressions larger than ERROR_SIZE are replaced by symbols, and the
     symbols are set to the expressions.  The symbols are taken from the
     list ERROR_SYMS, and are initially ERREXP1, ERREXP2, ERREXP3, etc.
     After an error message is printed, e.g. "The function FOO doesn't
     like ERREXP1 as input.", the user can type ERREXP1; to see the
     expression.  ERROR_SYMS may be set by the user to a different set
     of symbols, if desired.


 - Function: EXPT (A,B)
     if an exponential expression is too wide to be displayed as A^B it
     will appear as EXPT(A,B) (or as NCEXPT(A,B) in the case of A^^B).


 - Variable: EXPTDISPFLAG
     default: [TRUE] - if TRUE, MACSYMA displays expressions with
     negative exponents using quotients e.g., X**(-1) as 1/X.


 - Function: FASSAVE (args)
     is similar to SAVE but produces a FASL file in which the sharing
     of subexpressions which are shared in core is preserved in the
     file created.  Hence, expressions which have common subexpressions
     will consume less space when loaded back from a file created by
     FASSAVE rather than by SAVE.  Files created with FASSAVE are
     reloaded using LOADFILE, just as files created with SAVE.  FASSAVE
     returns a list of the form [<name of file>,<size of file in
     blocks>,...] where ...  are the things saved.  Warnings are
     printed out in the case of large files.  FASSAVE may be used while
     a WRITEFILE is in progress.


 - Function: FILEDEFAULTS ()
     returns the current default filename, in whatever format is used
     by the specific Macsyma implementation.  (See DESCRIBE(FILE) for
     what that format is.)  This is the file specification used by
     LOADFILE, BATCH, and a number of other file-accessing commands.
     FILEDEFAULTS('file) - sets the current filedefaults to "file".  The
     argument to FILEDEFAULTS is evaulated as it is anticipated that the
     command will be used mainly in programs.  The "file" need not be a
     real file, so one can use this function e.g. if one's real purpose
     is to set only the "device" field to something, where one does not
     care about the settings of the other fields.


 - Variable: FILENAME
     default: [] - The value of this variable is the first name of the
     files which are generated by the automatic disk storage scheme.
     The default value is the first three characters of the user's login
     name concatenated with the lowest unused integer, e.g. ECR1.


 - Function: FILENAME_MERGE ("filename1","filename2",...)
     ; merges together filenames.  What this means is that it returns
     "filename1" except that missing components come from the
     corresponding components of "filename2", and if they are missing
     there, then from "filename3".


 - Variable: FILENUM
     default: [0] - The default second file name for files generated by
     SAVE, STRINGOUT, or FASSAVE if no file names are specified by the
     user.  It is an integer, and is incremented by one each time a new
     file is written.


 - Variable: FILE_SEARCH
     - this is a list of files naming directories to search by LOAD and
     a number of other functions.  The default value of this is a list
     of the various SHARE directories used by Macsyma.
     FILE_SEARCH("filename"); searches on those directories and devices
     specified by the FILE_SEARCH_LISP, FILE_SEARCH_MAXIMA and
     FILE_SEARCH_DEMO variables, and returns the name of the first file
     it finds.  This function is invoked by the LOAD function, which is
     why LOAD("FFT") finds and loads share/fft.mac.  You may add a path
     to the appropriate list.   Note that the format of the paths
     allows specifying multiple extensions and multiple paths.
          "/home/wfs/###.{o,lisp,mac,mc}"
          "/home/{wfs,joe}/###.{o,lisp,mac,mc}"
     The '###' is replaced by the actual filename passed.  File_SEARCH
     first checks if the actual name passed exists, before substituting
     it in the various patterns.


 - Variable: FILE_STRING_PRINT
     default: [FALSE] on MC, [TRUE] elsewhere.  If TRUE, filenames are
     output as strings; if FALSE, as lists.  For example, the message
     when an out of core file is loaded into MACSYMA (e.g. the LIMIT
     package), appears on MC in list format as   LIMIT FASL DSK MACSYM
     being loaded and in string format as:   DSK:MACSYM;LIMIT FASL
     being loaded The string format is like the top level (DDT) file
     specifications.


 - Function: FILE_TYPE ("filename")
     ; returns FASL, LISP, or MACSYMA, depending on what kind of file
     it is.  FASL means a compiled Lisp file, which normally has an
     extension of .VAS in NIL.


 - Function: GRIND (arg)
     prints out arg in a more readable format than the STRING command.
     It returns a D-line as value.  The GRIND switch, default: [FALSE],
     if TRUE will cause the STRING, STRINGOUT, and PLAYBACK commands to
     use "grind" mode instead of "string" mode.  For PLAYBACK, "grind"
     mode can also be turned on (for processing input lines) by
     specifying GRIND as an option.


 - Variable: IBASE
     default: [10] - the base for inputting numbers.


 - Variable: INCHAR
     default: [C] - the alphabetic prefix of the names of expressions
     typed by the user.


 - Function: LDISP (expr1,expr2,...)
     is like DISP but also generates intermediate labels.


 - Function: LDISPLAY (expr1,expr2,...)
     is like DISPLAY but also generates intermediate labels.


 - Variable: LINECHAR
     default: [E] - the alphabetic prefix of the names of intermediate
     displayed expressions.


 - Variable: LINEDISP
     default: [TRUE] - Allows the use of line graphics in the drawing
     of equations on those systems which support them (e.g. the Lisp
     Machine).  This can be disabled by setting LINEDISP to FALSE.  It
     is automatically disabled during WRITEFILE.


 - Variable: LINEL
     default: [] - the number of characters which are printed on a
     line. It is initially set by MACSYMA to the line length of the
     type of terminal being used (as far as is known) but may be reset
     at any time by the user.  The user may have to reset it in DDT
     with :TCTYP as well.


 - Function: LOAD ("filename")
     ; takes one argument, a filename represented as a "string" (i.e.
     inside quotation marks), or as list (e.g. inside square brackets),
     and locates and loads in the indicated file.  If no directory is
     specified, it then searches the SHAREi directories and any other
     directories listed in the FILE_SEARCH variable and loads the
     indicated file. LOAD("EIGEN") will load the eigen package without
     the need for the user to be aware of the details of whether the
     package was compiled, translated, saved, or fassaved, i.e. LOAD
     will work on both LOADFILEable and BATCHable files.  Note: LOAD
     will use BATCHLOAD if it finds the file is BATCHable (which means
     that it will BATCH the file in "silently" without terminal output
     or labels).  Other MACSYMA commands to load in files are:
     LOADFILE, RESTORE, BATCH, and DEMO.  Do DESCRIBE(command); for
     details.  LOADFILE and RESTORE work for files written with SAVE;
     BATCH and DEMO for those files written with STRINGOUT or created
     as lists of commands with a text editor.  If load can't find the
     file, check the value FILE_SEARCH to make sure that it contains an
     appropriate template.

          (C4) load("eigen");
          MACSYMA BUG: Unknown file type NIL
          
          Error: macsyma error
          Error signalled by MEVAL1.
          Broken at $LOAD.  Type :H for Help.
          MAXIMA>>:q
          
          By examining the file system we find the file is actually in
          /public/maxima/share/eigen.mc.   So we add that to the file_search
          path.   This can be done at start up (see init.lsp) or,
          else it can be done and then the system resaved
          once it has been customized for local directories and pathnames.
          At lisp level we would do
          (in-package "MAXIMA")
          (setq $file_search ($append (list '(mlist)
                  "/tmp/foo.mac" "/tmp/foo.mc") $file_search))
          and at maxima level:
          
          (C5) file_search:append(["/public/maxima/share/foo.mc"],
                  file_search)$
          (C6) load("eigen");
          
          batching /usr/public/maxima/share/eigen.mc
          (D6) 		        #/public/maxima/share/eigen.mc
          (C7) eigenvalues(matrix([a,b],[c,d]));
          	       2		    2
                 - SQRT(D  - 2 A D + 4 B C + A ) + D + A
          (D7) [[---------------------------------------,
          			  2
          
          				      2			   2
          				SQRT(D  - 2 A D + 4 B C + A ) + D + A
          				-------------------------------------], [1, 1]]
          						  2

 - Function: LOADFILE (filename)
     loads a file as designated by its arguments.  This function may be
     used to bring back quantities that were stored from a prior
     MACSYMA session by use of the SAVE or STORE functions.   Specify
     the pathname as on your operating system.  For unix this would be
     "/home/wfs/foo.mc" for example.


 - Variable: LOADPRINT
     default: [TRUE] - governs the printing of messages accompanying
     loading of files.  The following options are available: TRUE means
     always print the message; 'LOADFILE means print only when the
     LOADFILE command is used; 'AUTOLOAD means print only when a file
     is automatically loaded in (e.g. the integration file SIN FASL);
     FALSE means never print the loading message.


 - Function: NOSTRING (arg)
     displays all input lines when playing back rather than STRINGing
     them.  If arg is GRIND then the display will be in a more readable
     format.  One may include any number of options as in
     PLAYBACK([5,10],20,TIME,SLOW).


 - Variable: OBASE
     default: [10] the base for display of numbers.


 - Variable: OUTCHAR
     default: [D] - the alphabetic prefix of the names of outputted
     expressions.


 - Variable: PACKAGEFILE
     default:[FALSE] - Package designers who use SAVE, FASSAVE, or
     TRANSLATE to create packages (files) for others to use may want to
     set PACKAGEFILE:TRUE$ to prevent information from being added to
     MACSYMA's information-lists (e.g. VALUES, FUNCTIONS) except where
     necessary when the file is loaded in.  In this way, the contents
     of the package will not get in the user's way when he adds his own
     data.  Note that this will not solve the problem of possible name
     conflicts.  Also note that the flag simply affects what is output
     to the package file.  Setting the flag to TRUE is also useful for
     creating MACSYMA init files.


 - Variable: PARSEWINDOW
     default:[10] - the maximum number of "lexical tokens" that are
     printed out on each side of the error-point when a syntax
     (parsing) error occurs.  This option is especially useful on slow
     terminals.  Setting it to -1 causes the entire input string to be
     printed out when an error occurs.


 - Variable: PFEFORMAT
     default: [FALSE] - if TRUE will cause rational numbers to display
     in a linear form and denominators which are integers to display as
     rational number multipliers.


 - Function: PRINT (exp1, exp2, ...)
     evaluates and displays its arguments one after the other "on a
     line" starting at the leftmost position.  If expi is unbound or is
     preceded by a single quote or is enclosed in "s then it is printed
     literally.  For example, PRINT("THE VALUE OF X IS ",X).  The value
     returned by PRINT is the value of its last argument.  No
     intermediate lines are generated.  (For "printing" files, see the
     PRINTFILE function.)


 - Function: SPRINT (exp1, exp2, ...)
     evaluates and displays its arguments one after the other "on a
     line" starting at the leftmost position.  The numbers are printed
     with the '-' right next to the number, and it disregards line
     length.

 - Function: TCL_OUTPUT (LIST INDEX &optional-skip)
     prints a TCL list based on LIST extracting the INDEX slot.  Here
     skip defaults to 2, meaning that every other element will be
     printed if the argument is of the form a list of numbers, rathter
     than a list of lists.  For example:
          TCL_OUTPUT([x1,y1,x2,y2,x3,y3],1) --> {x1 x2 x3 }
          TCL_OUTPUT([x1,y1,x2,y2,x3,y3],2) --> {y1 y2 y3 }
          TCL_OUTPUT([1,2,3,4,5,6],1,3) --> {1 4}
          TCL_OUTPUT([1,2,3,4,5,6],2,3) --> {2 5}

 - Function: READ (string1, ...)
     prints its arguments, then reads in and evaluates one expression.
     For example: A:READ("ENTER THE NUMBER OF VALUES").


 - Function: READONLY (string1,...)
     prints its arguments, then reads in an expression (which in
     contrast to READ is not evaluated).


 - Function: REVEAL (exp,depth)
     will display exp to the specified integer depth with the length of
     each part indicated.  Sums will be displayed as Sum(n) and
     products as Product(n) where n is the number of subparts of the
     sum or product.  Exponentials will be displayed as Expt.
          (C1) INTEGRATE(1/(X^3+2),X)$
          (C2) REVEAL(%,2);
          (D2)                    Negterm + Quotient + Quotient
          (C3) REVEAL(D1,3);
                                               ATAN         LOG
          (D3)                 - Quotient + ---------- + ----------
                                            Product(2)   Product(2)

 - Variable: RMXCHAR
     default: []] - The character used to display the (right) delimiter
     of a matrix (see also LMXCHAR).


 - Function: SAVE (filename,arg1, arg2,...,argi)
     saves quantities described by its arguments on disk and keeps them
     in core also.  The arg's are the expressions to be SAVEd.  ALL is
     the simplest, but note that saving ALL will save the entire
     contents of your MACSYMA, which in the case of a large computation
     may result in a large file.  VALUES, FUNCTIONS, or any other items
     on the INFOLISTS (do DESCRIBE(INFOLISTS); for the list) may be
     SAVEd, as may functions and variables by name.  C and D lines may
     also be saved, but it is better to give them explicit names, which
     may be done in the command line, e.g.  SAVE(RES1=D15); Files saved
     with SAVE should be reloaded with LOADFILE.  SAVE returns the
     pathname where the items were saved.


 - Variable: SAVEDEF
     default: [TRUE] - if TRUE will cause the MACSYMA version of a user
     function to remain when the function is TRANSLATEd.  This permits
     the definition to be displayed by DISPFUN and allows the function
     to be edited.  If SAVEDEF is FALSE, the names of translated
     functions are removed from the FUNCTIONS list.


 - Function: SHOW (exp)
     will display exp with the indexed objects in it shown having
     covariant indices as subscripts,contravariant indices as
     superscripts.  The derivative indices will be displayed as
     subscripts, separated from the covariant indices by a comma.


 - Function: SHOWRATVARS (exp)
     returns a list of the RATVARS (CRE variables) of exp.


 - Variable: STARDISP
     default: [FALSE] - if TRUE will cause multiplication to be
     displayed explicitly with an * between operands.


 - Function: STRING (expr)
     converts expr to MACSYMA's linear notation (similar to FORTRAN's)
     just as if it had been typed in and puts expr into the buffer for
     possible editing (in which case expr is usually Ci) The STRING'ed
     expression should not be used in a computation.


 - Function: STRINGOUT (args)
     will output an expression to a file in a linear format.  Such
     files are then used by the BATCH or DEMO commands.
     STRINGOUT(file-specification, A1, A2, ...)  outputs to a file
     given by file-specification ([filename1,filename2,DSK, directory])
     the values given by A1,A2,..  in a MACSYMA readable format.  The
     file-specification may be omitted, in which case the default values
     will be used. The Ai are usually C labels or may be INPUT meaning
     the value of all C labels.  Another option is to make ai FUNCTIONS
     which will cause all of the user's function definitions to be
     strungout (i.e. all those retrieved by DISPFUN(ALL)).  Likewise
     the ai may be VALUES, and all the variables to which the user has
     assigned values will be strungout.  ai may also be a list [m,n]
     which means to stringout all labels in the range m through n
     inclusive.  This function may be used to create a file of FORTRAN
     statements by doing some simple editing on the strungout
     expressions.  If the GRIND switch is set to TRUE, then STRINGOUT
     will use GRIND format instead of STRING format.  Note: a STRINGOUT
     may be done while a WRITEFILE is in progress.


 - Function: TEX (expr)
 - Function: TEX (expr,filename)
 - Function: TEX (label,filename)
     In the case of a label, a left-equation-number will be produced.
     in case a file-name is supplied, the output will be appended to the
     file.

          (C1) integrate(1/(1+x^3),x);
          
          					 2 x - 1
          		       2	    ATAN(-------)
          		  LOG(x  - x + 1)	 SQRT(3)    LOG(x + 1)
          (D1) 	        - --------------- + ------------- + ----------
          			 6	       SQRT(3)	        3
          (C2) tex(d1);
          
          $$-{{\log \left(x^{2}-x+1\right)}\over{6}}
            +{{\arctan {{2\>x-1}\over{\sqrt{3}}}}\over{\sqrt{3}}}
            +{{\log \left(x+1\right)}\over{3}}\leqno{\tt (D1)}$$
          (D2) 				     (D1)
          (C6) tex(integrate(sin(x),x));
          
          $$-\cos x$$
          (D6) 				     FALSE
          (C7) tex(d1,"/tmp/jo.tex");
          
          (D7) 				     (D1)
     where the last expression will be appended to the file
     `/tmp/jo.tex'

 - Function: SYSTEM (command)
     Execute COMMAND as a subprocess.  The command will be passed to the
     default shell for execution.   System is not supported by all
     operating systems, but generally exists in the unix environment.
     if hist is a list of frequencies which you wish to plot as a bar
     graph using xgraph.
          (C1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));
     In order to make the plot be done in the background (returning
     control to maxima) and remove the temporary file after it is done
     do:
          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")

 - Variable: TTYOFF
     default: [FALSE] - if TRUE stops printing output to the console.


 - macro: WITH_STDOUT (file,stmt1,stmt2,...)
     Opens file and then evaluates stmt1, stmt2, ....  Any printing to
     standard output goes to the file instead of the terminal.  It
     always returns FALSE.   Note the binding of display2d to be false,
     otherwise the printing will have things like "- 3" instead of "-3".

          mygnuplot(f,var,range,number_ticks):=
           block([numer:true,display2d:false],
           with_stdout("/tmp/gnu",
             for x:range[1] thru range[2] step
                          (range[2]-range[1])/number_ticks
                do (print(x,at(f,var=x)))),
           system("echo \"set data style lines; set title '",
                  f,"' ;plot '/tmp/gnu'
          ;pause 10 \" | gnuplot"));
          
          (C8) with_stdout("/home/wfs/joe",
                n:10,
                for i:8 thru n
                  do(print("factorial(",i,") gives ",i!)));
          (D8) 				     FALSE
          (C9) system("cat /home/wfs/joe");
          factorial( 8 ) gives  40320
          factorial( 9 ) gives  362880
          factorial( 10 ) gives  3628800
          (D9) 				       0


 - Function: WRITEFILE (DSK, directory)
     opens up a file for writing.  On a Lisp Machine one uses
     WRITEFILE("filename").  All interaction between the user and
     MACSYMA is then recorded in this file, just as it is on the
     console.  Such a file is a transcript of the session, and is not
     reloadable or batchable into MACSYMA again.  (See also CLOSEFILE.)



File: maxima.info,  Node: Floating Point,  Next: Contexts,  Prev: Input and Output,  Up: Top

Floating Point
**************

* Menu:

* Definitions for Floating Point::


File: maxima.info,  Node: Definitions for Floating Point,  Prev: Floating Point,  Up: Floating Point

Definitions for Floating Point
==============================

 - Function: BFFAC (exp,n)
     BFLOAT version of the Factorial (shifted Gamma) function.  The 2nd
     argument is how many digits to retain and return, it's a good idea
     to request a couple of extra.  This function is available by doing
     LOAD(BFFAC); .

 - Variable: ALGEPSILON
     The default value is 10^-8.  The value of ALGEPSILON is used by
     ALGSYS.

 - Function: BFLOAT (X)
     converts all numbers and functions of numbers to bigfloat numbers.
     Setting FPPREC[16] to N, sets the bigfloat precision to N digits.
     If FLOAT2BF[FALSE] is FALSE a warning message is printed when a
     floating point number is converted into a bigfloat number (since
     this may lead to loss of precision).


 - Function: BFLOATP (exp)
     is TRUE if exp is a bigfloat number else FALSE.


 - Function: BFPSI (n,z,fpprec)
     gives polygammas of real arg and integer order.  For digamma,
     BFPSI0(z,fpprec) is more direct.  Note -BFPSI0(1,fpprec) provides
     BFLOATed %GAMMA.  To use this do LOAD(BFFAC);


 - Variable: BFTORAT
     default: [FALSE] controls the conversion of bfloats to rational
     numbers.  If
          BFTORAT:FALSE
     RATEPSILON will be used to control the conversion (this results in
     relatively small rational numbers).  If
          BFTORAT:TRUE
     , the rational number generated will accurately represent the
     bfloat.


 - Variable: BFTRUNC
     default: [TRUE] causes trailing zeroes in non-zero bigfloat
     numbers not to be displayed.  Thus, if BFTRUNC:FALSE, BFLOAT(1);
     displays as 1.000000000000000B0. Otherwise, this is displayed as
     1.0B0.


 - Function: CBFAC (z,fpprec)
     a factorial for complex bfloats.  It may be used by doing
     LOAD(BFAC); For more details see share2/bfac.usg.


 - Function: FLOAT (exp)
     converts integers, rational numbers and bigfloats in exp to
     floating point numbers.  It is also an EVFLAG, FLOAT causes
     non-integral rational numbers and bigfloat numbers to be converted
     to floating point.


 - Variable: FLOAT2BF
     default: [FALSE] if FALSE, a warning message is printed when a
     floating point number is converted into a bigfloat number (since
     this may lead to loss of precision).


 - Function: FLOATDEFUNK
     - is a utility for making floating point functions from
     mathematical expression. It will take the input expression and
     FLOAT it, then OPTIMIZE it, and then insert MODE_DECLAREations for
     all the variables.  This is THE way to use ROMBERG, PLOT2,
     INTERPOLATE, etc. e.g.  EXP:some-hairy-macsyma-expression;

          FLOATDEFUNK('F,['X],EXP);
     will define the function F(X) for you.  (Do
     PRINTFILE(MCOMPI,DOC,MAXDOC); for more details.)


 - Function: FLOATNUMP (exp)
     is TRUE if exp is a floating point number else FALSE.


 - Variable: FPPREC
     default: [16] - Floating Point PRECision.  Can be set to an
     integer representing the desired precision.


 - Variable: FPPRINTPREC
     default: [0] - The number of digits to print when printing a
     bigfloat number, making it possible to compute with a large number
     of digits of precision, but have the answer printed out with a
     smaller number of digits.  If FPPRINTPREC is 0 (the default), or >=
     FPPREC, then the value of FPPREC controls the number of digits used
     for printing.  However, if FPPRINTPREC has a value between 2 and
     FPPREC-1, then it controls the number of digits used.  (The minimal
     number of digits used is 2, one to the left of the point and one to
     the right.  The value 1 for FPPRINTPREC is illegal.)

 - Function: ?ROUND (x,&optional-divisor)
     round the floating point X to the nearest integer.   The argument
     must be a regular system float, not a bigfloat.   The ? beginning
     the name indicates this is normal common lisp function.

          (C3) ?round(-2.8);
          (D3) 				      - 3

 - Function: ?TRUNCATE (x,&optional-divisor)
     truncate the floating point X towards 0, to become an integer.
     The argument must be a regular system float, not a bigfloat.  The
     ? beginning the name indicates this is normal common lisp function.

     (C4) ?truncate(-2.8);
     (D4) 				      - 2
     (C5) ?truncate(2.4);
     (D5) 				       2
     (C6) ?truncate(2.8);
     (D6) 				       2

 - Variable: ZUNDERFLOW
     default: [TRUE] - if FALSE, an error will be signaled if floating
     point underflow occurs.  Currently in NIL Macsyma, all
     floating-point underflow, floating-point overflow, and
     division-by-zero errors signal errors, and this switch is ignored.



File: maxima.info,  Node: Contexts,  Next: Polynomials,  Prev: Floating Point,  Up: Top

Contexts
********

* Menu:

* Definitions for Contexts::


File: maxima.info,  Node: Definitions for Contexts,  Prev: Contexts,  Up: Contexts

Definitions for Contexts
========================

 - Function: ACTIVATE (cont1, cont2, ...)
     causes the specified contexts conti to be activated.  The facts in
     these contexts are used in making deductions and retrieving
     information.  The facts in these contexts are not listed when
     FACTS(); is done.  The variable ACTIVECONTEXTS is the list of
     contexts which are active by way of the ACTIVATE function.


 - Variable: ACTIVECONTEXTS
     default: [] is a list of the contexts which are active by way of
     the ACTIVATE function, as opposed to being active because they are
     subcontexts of the current context.


 - Function: ASSUME (pred1, pred2, ...)
     First checks the specified predicates for redundancy and
     consistency with the current data base.  If the predicates are
     consistent and non-redundant, they are added to the data base; if
     inconsistent or redundant, no action is taken.  ASSUME returns a
     list whose entries are the predicates added to the data base and
     the atoms REDUNDANT or INCONSISTENT where applicable.


 - Variable: ASSUMESCALAR
     default: [TRUE] - helps govern whether expressions `exp' for which

          NONSCALARP(exp) is FALSE

     are assumed to behave like scalars for certain transformations as
     follows: Let `exp' represent any non-list/non-matrix, and
     `[1,2,3]' any list or matrix.
          exp.[1,2,3]; ==>
           [exp,2*exp,3*exp]
     if ASSUMESCALAR is TRUE or SCALARP(exp) is TRUE or CONSTANTP(exp)
     is TRUE.  If ASSUMESCALAR is TRUE, such expressions will behave
     like scalars only for the commutative operators, but not for ".".
     If ASSUMESCALAR is FALSE, such expressions will behave like
     non-scalars.  If ASSUMESCALAR is ALL, such expressions will behave
     like scalars for all the operators listed above.

 - Variable: ASSUME_POS
     default:[FALSE] - When using INTEGRATE, etc. one often introduces
     parameters which are real and positive or one's calculations can
     often be constructed so that this is true.  There is a switch
     ASSUME_POS (default FALSE) such that if set to TRUE, MACSYMA will
     assume one's parameters are positive.  The intention here is to
     cut down on the number of questions MACSYMA needs to ask.
     Obviously, ASSUME information or any contextual information
     present will take precedence.  The user can control what is
     considered to be a parameter for this purpose.  Parameters by
     default are those which satisfy SYMBOLP(x) OR SUBVARP(x).  The
     user can change this by setting the option ASSUME_POS_PRED
     [default FALSE] to the name of a predicate function of one
     argument.  E.g. if you want only symbols to be parameters, you can
     do ASSUME_POS:TRUE$ ASSUME_POS_PRED:'SYMBOLP$ SIGN(A); -> POS,
     SIGN(A[1]); -> PNZ.

 - Variable: ASSUME_POS_PRED
     default:[FALSE] - may be set to one argument to control what will
     be considered a parameter for the "assumptions" that INTEGRATE
     will make... see ASSUME and ASSUME_POS .

 - Variable: CONTEXT
     default: INITIAL. Whenever a user assumes a new fact, it is placed
     in the context named as the current value of the variable CONTEXT.
     Similarly, FORGET references the current value of CONTEXT.  To
     change contexts, simply bind CONTEXT to the desired context.  If
     the specified context does not exist it will be created by an
     invisible call to NEWCONTEXT.  The context specified by the value
     of CONTEXT is automatically activated.  (Do DESCRIBE(CONTEXTS);
     for a general description of the CONTEXT mechanism.)


 - Variable: CONTEXTS
     default: [INITIAL,GLOBAL] is a list of the contexts which
     currently exist, including the currently active context.  The
     context mechanism makes it possible for a user to bind together
     and name a selected portion of his data base, called a context.
     Once this is done, the user can have MACSYMA assume or forget
     large numbers of facts merely by activating or deactivating their
     context.  Any symbolic atom can be a context, and the facts
     contained in that context will be retained in storage until the
     user destroys them individually by using FORGET or destroys them
     as a whole by using KILL to destroy the context to which they
     belong.      Contexts exist in a formal hierarchy, with the root
     always being the context GLOBAL, which contains information about
     MACSYMA that some functions need.  When in a given context, all
     the facts in that context are "active" (meaning that they are used
     in deductions and retrievals) as are all the facts in any context
     which is an inferior of that context.  When a fresh MACSYMA is
     started up, the user is in a context called INITIAL, which has
     GLOBAL as a subcontext.  The functions which deal with contexts
     are: FACTS, NEWCONTEXT, SUPCONTEXT, KILLCONTEXT, ACTIVATE,
     DEACTIVATE, ASSUME, and FORGET.


 - Function: DEACTIVATE (cont1, cont2, ...)
     causes the specified contexts conti to be deactivated.


 - Function: FACTS (item)
     If 'item' is the name of a context then FACTS returns a list of
     the facts in the specified context.  If no argument is given, it
     lists the current context.  If 'item' is not the name of a context
     then it returns a list of the facts known about 'item' in the
     current context.  Facts that are active, but in a different
     context, are not listed.


 - declaration: FEATURES
     - MACSYMA has built-in properties which are handled by the data
     base.  These are called FEATURES.  One can do DECLARE(N,INTEGER),
     etc.  One can also DECLARE one's own FEATURES by e.g.  DECLARE(
     INCREASING, FEATURE); which will then allow one to say DECLARE(F,
     INCREASING);.  One can then check if F is INCREASING by using the
     predicate FEATUREP via FEATUREP(F, INCREASING).  There is an
     infolist FEATURES which is a list of known FEATURES.  At present
     known FEATURES are: INTEGER, NONINTEGER, EVEN, ODD, RATIONAL,
     IRRATIONAL, REAL, IMAGINARY, COMPLEX, ANALYTIC, INCREASING,
     DECREASING, ODDFUN, EVENFUN, POSFUN, COMMUTATIVE, LASSOCIATIVE,
     RASSOCIATIVE, SYMMETRIC, and ANTISYMMETRIC.  [Note: system
     "features" may be checked with STATUS(FEATURE, ...); See
     DESCRIBE(STATUS); or DESCRIBE(FEATURE); for details.]


 - Function: FORGET (pred1, pred2, ...)
     removes relations established by ASSUME.  The predicates may be
     expressions equivalent to (but not necessarily identical to) those
     previously ASSUMEd.  FORGET(list) is also a legal form.


 - Function: KILLCONTEXT (context1,context2,...,contextn)
     kills the specified contexts.  If one of them is the current
     context, the new current context will become the first available
     subcontext of the current context which has not been killed.  If
     the first available unkilled context is GLOBAL then INITIAL is
     used instead.  If the INITIAL context is killed, a new INITIAL is
     created, which is empty of facts.  KILLCONTEXT doesn't allow the
     user to kill a context which is currently active, either because
     it is a subcontext of the current context, or by use of the
     function ACTIVATE.


 - Function: NEWCONTEXT (name)
     creates a new (empty) context, called name, which has GLOBAL as
     its only subcontext.  The new context created will become the
     currently active context.


 - Function: SUPCONTEXT (name,context)
     will create a new context (called name) whose subcontext is
     context.  If context is not specified, the current context will be
     assumed.  If it is specified, context must exist.



File: maxima.info,  Node: Polynomials,  Next: Constants,  Prev: Contexts,  Up: Top

Polynomials
***********

* Menu:

* Introduction to Polynomials::
* Definitions for Polynomials::


File: maxima.info,  Node: Introduction to Polynomials,  Next: Definitions for Polynomials,  Prev: Polynomials,  Up: Polynomials

Introduction to Polynomials
===========================

Polynomials are stored in maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

   Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC[FALSE] is set to TRUE).  In this CRE form an
ordering of variables (from most to least main) is assumed for each
expression.  Polynomials are represented recursively by a list
consisting of the main variable followed by a series of pairs of
expressions, one for each term of the polynomial.  The first member of
each pair is the exponent of the main variable in that term and the
second member is the coefficient of that term which could be a number or
a polynomial in another variable again represented in this form.  Thus
the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that
of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main
variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
variable. "Main"-ness is usually determined by reverse alphabetical
order.  The "variables" of a CRE expression needn't be atomic.  In fact
any subexpression whose main operator is not + - * / or ^ with integer
power will be considered a "variable" of the expression (in CRE form) in
which it occurs.  For example the CRE variables of the expression
X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
not specify an ordering of variables by using the RATVARS function
MACSYMA will choose an alphabetic one.  In general, CRE's represent
rational expressions, that is, ratios of polynomials, where the
numerator and denominator have no common factors, and the denominator is
positive.  The internal form is essentially a pair of polynomials (the
numerator and denominator) preceded by the variable ordering list.  If
an expression to be displayed is in CRE form or if it contains any
subexpressions in CRE form, the symbol /R/ will follow the line label.
See the RAT function for converting an expression to CRE form.  An
extended CRE form is used for the representation of Taylor series.  The
notion of a rational expression is extended so that the exponents of the
variables can be positive or negative rational numbers rather than just
positive integers and the coefficients can themselves be rational
expressions as described above rather than just polynomials.  These are
represented internally by a recursive polynomial form which is similar
to and is a generalization of CRE form, but carries additional
information such as the degree of truncation.  As with CRE form, the
symbol /T/ follows the line label of such expressions.


File: maxima.info,  Node: Definitions for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynomials

Definitions for Polynomials
===========================

 - Variable: ALGEBRAIC
     default: [FALSE] must be set to TRUE in order for the
     simplification of algebraic integers to take effect.

 - Variable: BERLEFACT
     default: [TRUE] if FALSE then the Kronecker factoring algorithm
     will be used otherwise the Berlekamp algorithm, which is the
     default, will be used.


 - Function: BEZOUT (p1, p2, var)
     an alternative to the RESULTANT command.  It returns a matrix.
     DETERMINANT of this matrix is the desired resultant.


 - Function: BOTHCOEF (exp, var)
     returns a list whose first member is the coefficient of var in exp
     (as found by RATCOEF if exp is in CRE form otherwise by COEFF) and
     whose second member is the remaining part of exp.  That is, [A,B]
     where exp=A*var+B.
          (C1) ISLINEAR(EXP,VAR):=BLOCK([C],
                  C:BOTHCOEF(RAT(EXP,VAR),VAR),
                  IS(FREEOF(VAR,C) AND C[1]#0))$
          (C2) ISLINEAR((R**2-(X-R)**2)/X,X);
          (D2)                              TRUE

 - Function: COEFF (exp, v, n)
     obtains the coefficient of v**n in exp.  n may be omitted if it is
     1.  v may be an atom, or complete subexpression of exp e.g., X,
     SIN(X), A[I+1], X+Y, etc. (In the last case the expression (X+Y)
     should occur in exp).  Sometimes it may be necessary to expand or
     factor exp in order to make v^n explicit.  This is not done
     automatically by COEFF.
          (C1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));
          (D1)                         2 A + 1 = 5
          (C2) COEFF(Y+X*%E**X+1,X,0);
          (D2)                            Y + 1

 - Function: COMBINE (exp)
     simplifies the sum exp by combining terms with the same
     denominator into a single term.


 - Function: CONTENT (p1, var1, ..., varn)
     returns a list whose first element is the greatest common divisor
     of the coefficients of the terms of the polynomial p1 in the
     variable varn (this is the content) and whose second element is
     the polynomial p1 divided by the content.
          (C1) CONTENT(2*X*Y+4*X**2*Y**2,Y);
          (D1)            [2*X, 2*X*Y**2+Y].

 - Function: DENOM (exp)
     returns the denominator of the rational expression exp.


 - Function: DIVIDE (p1, p2, var1, ..., varn)
     computes the quotient and remainder of the polynomial p1 divided
     by the polynomial p2, in a main polynomial variable, varn.  The
     other variables are as in the RATVARS function.  The result is a
     list whose first element is the quotient and whose second element
     is the remainder.
          (C1) DIVIDE(X+Y,X-Y,X);
          (D1)                        [1, 2 Y]
          (C2) DIVIDE(X+Y,X-Y);
          (D2)                      [ - 1, 2 X]

     (Note that Y is the main variable in C2)


 - Function: ELIMINATE ([eq1,eq2,...,eqn],[v1,v2,...,vk])
     eliminates variables from equations (or expressions assumed equal
     to zero) by taking successive resultants. This returns a list of
     n-k expressions with the k variables v1,...,vk eliminated.  First
     v1 is eliminated yielding n-1 expressions, then v2 is, etc.  If
     k=n then a single expression in a list is returned free of the
     variables v1,...,vk.  In this case SOLVE is called to solve the
     last resultant for the last variable.  Example:
          (C1) EXP1:2*X^2+Y*X+Z;
                                              2
          (D1)                   Z + X Y + 2 X
          (C2) EXP2:3*X+5*Y-Z-1;
          (D2)                - Z + 5 Y + 3 X - 1
          (C3) EXP3:Z^2+X-Y^2+5;
                                 2    2
          (D3)                  Z  - Y  + X + 5
          (C4) ELIMINATE([EXP3,EXP2,EXP1],[Y,Z]);
                      8         7         6          5          4
          (D3) [7425 X  - 1170 X  + 1299 X  + 12076 X  + 22887 X
                                         3         2
                                 - 5154 X  - 1291 X  + 7688 X + 15376]

 - Function: EZGCD (p1, p2, ...)
     gives a list whose first element is the g.c.d of the polynomials
     p1,p2,...  and whose remaining elements are the polynomials
     divided by the g.c.d.  This always uses the EZGCD algorithm.


 - Variable: FACEXPAND
     default: [TRUE] controls whether the irreducible factors returned
     by FACTOR are in expanded (the default) or recursive (normal CRE)
     form.


 - Function: FACTCOMB (exp)
     tries to combine the coefficients of factorials in exp with the
     factorials themselves by converting, for example, (N+1)*N!  into
     (N+1)!.  SUMSPLITFACT[TRUE] if set to FALSE will cause
     MINFACTORIAL to be applied after a FACTCOMB.
          (C1) (N+1)^B*N!^B;
                                                B   B
          (D1)                           (N + 1)  N!
          (C2) FACTCOMB(%);

 - Function: FACTOR (exp)
     factors the expression exp, containing any number of variables or
     functions, into factors irreducible over the integers.
     FACTOR(exp, p) factors exp over the field of integers with an
     element adjoined whose minimum polynomial is p.  FACTORFLAG[FALSE]
     if FALSE suppresses the factoring of integer factors of rational
     expressions.  DONTFACTOR may be set to a list of variables with
     respect to which factoring is not to occur.  (It is initially
     empty).  Factoring also will not take place with respect to any
     variables which are less important (using the variable ordering
     assumed for CRE form) than those on the DONTFACTOR list.
     SAVEFACTORS[FALSE] if TRUE causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.  BERLEFACT[TRUE] if FALSE then the
     Kronecker factoring algorithm will be used otherwise the Berlekamp
     algorithm, which is the default, will be used.  INTFACLIM[1000] is
     the largest divisor which will be tried when factoring a bignum
     integer.  If set to FALSE (this is the case when the user calls
     FACTOR explicitly), or if the integer is a fixnum (i.e.  fits in
     one machine word), complete factorization of the integer will be
     attempted.  The user's setting of INTFACLIM is used for internal
     calls to FACTOR. Thus, INTFACLIM may be reset to prevent MACSYMA
     from taking an inordinately long time factoring large integers.
     NEWFAC[FALSE] may be set to true to use the new factoring routines.
     Do EXAMPLE(FACTOR); for examples.


 - Variable: FACTORFLAG
     default: [FALSE] if FALSE suppresses the factoring of integer
     factors of rational expressions.


 - Function: FACTOROUT (exp,var1,var2,...)
     rearranges the sum exp into a sum of terms of the form
     f(var1,var2,...)*g where g is a product of expressions not
     containing the vari's and f is factored.


 - Function: FACTORSUM (exp)
     tries to group terms in factors of exp which are sums into groups
     of terms such that their sum is factorable.  It can recover the
     result of EXPAND((X+Y)^2+(Z+W)^2) but it can't recover
     EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.
          (C1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;
                2      2                            2      2
          (D1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X
                               2        2    2            2
                  + 2 U V X + U  X + A W  + V  + 2 U V + U
          (C2) FACTORSUM(%);
                                             2          2
          (D2)                 (X + 1) (A (Z + W)  + (V + U) )

 - Function: FASTTIMES (p1, p2)
     multiplies the polynomials p1 and p2 by using a special algorithm
     for multiplication of polynomials.  They should be multivariate,
     dense, and nearly the same size.  Classical multiplication is of
     order N*M where N and M are the degrees.  FASTTIMES is of order
     MAX(N,M)**1.585.


 - Function: FULLRATSIMP (exp)
     When non-rational expressions are involved, one call to RATSIMP
     followed as is usual by non-rational ("general") simplification
     may not be sufficient to return a simplified result.  Sometimes,
     more than one such call may be necessary.  The command FULLRATSIMP
     makes this process convenient.  FULLRATSIMP repeatedly applies
     RATSIMP followed by non-rational simplification to an expression
     until no further change occurs.  For example, consider For the
     expression  EXP:   (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1) .
     RATSIMP(EXP); gives (X^(2*A)-2*X^A+1)/(X^A-1) .  FULLRATSIMP(EXP);
     gives   X^A-1 .  The problem may be seen by looking at RAT(EXP);
     which gives  ((X^(A/2))^4-2*(X^(A/2))^2+1)/(X^A-1) .
     FULLRATSIMP(exp,var1,...,varn) takes one or more arguments similar
     to RATSIMP and RAT.


 - Function: FULLRATSUBST (a,b,c)
     is the same as RATSUBST except that it calls itself recursively on
     its result until that result stops changing.  This function is
     useful when the replacement expression and the replaced expression
     have one or more variables in common.  FULLRATSUBST will also
     accept its arguments in the format of LRATSUBST.  That is, the
     first argument may be a single substitution equation or a list of
     such equations, while the second argument is the expression being
     processed.  There is a demo available by DEMO("lrats.dem"); .


 - Function: GCD (p1, p2, var1, ...)
     computes the greatest common divisor of p1 and p2.  The flag
     GCD[SPMOD] determines which algorithm is employed.  Setting GCD to
     EZ, EEZ, SUBRES, RED, or SPMOD selects the EZGCD, New EEZ GCD,
     subresultant PRS, reduced, or modular algorithm, respectively.  If
     GCD:FALSE then GCD(p1,p2,var) will always return 1 for all var.
     Many functions (e.g.  RATSIMP, FACTOR, etc.) cause gcd's to be
     taken implicitly.  For homogeneous polynomials it is recommended
     that GCD:SUBRES be used.  To take the gcd when an algebraic is
     present, e.g. GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , ALGEBRAIC must be
     TRUE and GCD must not be EZ.  SUBRES is a new algorithm, and people
     who have been using the RED setting should probably change it to
     SUBRES.  The GCD flag, default: [SPMOD], if FALSE will also
     prevent the greatest common divisor from being taken when
     expressions are converted to CRE form.  This will sometimes speed
     the calculation if gcds are not required.


 - Function: GCDEX (f,g)
 - Function: GCDEX (f,g,var)
     returns a list containing [a,b,u] where u is the gcd of f and g,
     and u = a*f + b*g.   The arguments f and g should b univariate
     polynomials, or else polynomials in VAR a supplied main variable
     since we need to be in a principal ideal domain for this to work.
     The gcd means the gcd regarding f and g as univariate polynomials
     with coefficients being rational functions in the other variables.

     The algorithm is simply the euclidean algorithm, where we have a
     sequence of `lis[i]:[a[i],b[i],r[i]] ..' which are all
     perpendicular to `[f,g,-1]' and the next one is built as if `q =
     quotient(r[i]/r[i+1])' then `lis[i+2]:lis[i]-q*lis[i+1]', and it
     terminates at `lis[i+1]' when the remainder `r[i+2]' is zero.
          (C1) gcdex(x^2+1,x^3+4);
          
                                        2
                                       x  + 4 x - 1  x + 4
          (D1)/R/                   [- ------------, -----, 1]
                                            17        17
          
          (C2) d1.[x^2+1,x^3+4,-1];
          (D2)                                   0

     note that the gcd in the following is `1' since we work in
     `k(y)[x]', not the  `y+1' we would expect in `k[y,x] '

          (C4) gcdex(x*(y+1),y^2-1,x);
          
                                                1
          (D4)                            [0, ------, 1]
                                               2
                                              y  - 1


 - Function: GCFACTOR (n)
     factors the gaussian integer n over the gaussians, i.e.  numbers
     of the form a + b i where a and b are rational integers (i.e.
     ordinary integers).  Factors are normalized by making a and b
     non-negative.


 - Function: GFACTOR (exp)
     factors the polynomial exp over the Gaussian integers (i.  e.
     with SQRT(-1) = %I adjoined).  This is like FACTOR(exp,A**2+1)
     where A is %I.
          (C1)  GFACTOR(X**4-1);
          (D1)        (X - 1) (X + 1) (X + %I) (X - %I)

 - Function: GFACTORSUM (exp)
     is similar to FACTORSUM but applies GFACTOR instead of FACTOR.


 - Function: HIPOW (exp, v)
     the highest explicit exponent of v in exp.  Sometimes it may be
     necessary to expand exp since this is not done automatically by
     HIPOW.  Thus HIPOW(Y**3*X**2+X*Y**4,X) is 2.


 - Variable: INTFACLIM
     default: [1000] is the largest divisor which will be tried when
     factoring a bignum integer.  If set to FALSE (this is the case
     when the user calls FACTOR explicitly), or if the integer is a
     fixnum (i.e. fits in one machine word), complete factorization of
     the integer will be attempted.  The user's setting of INTFACLIM is
     used for internal calls to FACTOR. Thus, INTFACLIM may be reset to
     prevent MACSYMA from taking an inordinately long time factoring
     large integers.


 - Variable: KEEPFLOAT
     default: [FALSE] - if set to TRUE will prevent floating point
     numbers from being rationalized when expressions which contain
     them are converted to CRE form.


 - Function: LRATSUBST (list,exp)
     is analogous to SUBST(list_of_equations,exp) except that it uses
     RATSUBST instead of SUBST.  The first argument of LRATSUBST must
     be an equation or a list of equations identical in format to that
     accepted by SUBST (see DESCRIBE(SUBST);).  The substitutions are
     made in the order given by the list of equations, that is, from
     left to right.  A demo is available by doing DEMO("lrats.dem"); .


 - Variable: MODULUS
     default: [FALSE] - if set to a positive prime p, then all
     arithmetic in the rational function routines will be done modulo p.
     That is all integers will be reduced to less than p/2 in absolute
     value (if p=2 then all integers are reduced to 1 or 0).  This is
     the so called "balanced" modulus system, e.g. N MOD 5 = -2, -1, 0,
     1, or 2.  Warning: If EXP is already in CRE form when you reset
     MODULUS, then you may need to re-rat EXP, e.g.
     EXP:RAT(RATDISREP(EXP)), in order to get correct results. (If
     MODULUS is set to a positive non-prime integer, this setting will
     be accepted, but a warning will be given.)


 - Variable: NEWFAC
     default: [FALSE], if TRUE then FACTOR will use the new factoring
     routines.


 - Function: NUM (exp)
     obtains the numerator, exp1, of the rational expression exp =
     exp1/exp2.


 - Function: QUOTIENT (p1, p2, var1, ...)
     computes the quotient of the polynomial p1 divided by the
     polynomial p2.


 - Function: RAT (exp, v1, ..., vn)
     converts exp to CRE form by expanding and combining all terms over
     a common denominator and cancelling out the greatest common
     divisor of the numerator and denominator as well as converting
     floating point numbers to rational numbers within a tolerance of
     RATEPSILON[2.0E-8].  The variables are ordered according to the
     v1,...,vn as in RATVARS, if these are specified.  RAT does not
     generally simplify functions other than + , - , * , / , and
     exponentiation to an integer power whereas RATSIMP does handle
     these cases.  Note that atoms (numbers and names) in CRE form are
     not the same as they are in the general form.  Thus RAT(X)- X
     results in RAT(0) which has a different internal representation
     than 0.  RATFAC[FALSE] when TRUE invokes a partially factored form
     for CRE rational expressions.  During rational operations the
     expression is maintained as fully factored as possible without an
     actual call to the factor package.  This should always save space
     and may save some time in some computations.  The numerator and
     denominator are still made relatively prime (e.g.  RAT((X^2
     -1)^4/(X+1)^2); yields (X-1)^4*(X+1)^2), but the factors within
     each part may not be relatively prime.  RATPRINT[TRUE] if FALSE
     suppresses the printout of the message informing the user of the
     conversion of floating point numbers to rational numbers.
     KEEPFLOAT[FALSE] if TRUE prevents floating point numbers from being
     converted to rational numbers.  (Also see the RATEXPAND and
     RATSIMP functions.)
          (C1) ((X-2*Y)**4/(X**2-4*Y**2)**2+1)*(Y+A)*(2*Y+X)
                  /(4*Y**2+X**2);
                                                     4
                                            (X - 2 Y)
                        (Y + A) (2 Y + X) (------------ + 1)
                                             2      2 2
                                           (X  - 4 Y )
          (D1)          ------------------------------------
                                        2    2
                                     4 Y  + X
          (C2) RAT(%,Y,A,X);
                                      2 A + 2 Y
          (D2)/R/                     ---------
                                       X + 2 Y

 - Variable: RATALGDENOM
     default: [TRUE] - if TRUE allows rationalization of denominators
     wrt.  radicals to take effect.  To do this one must use CRE form
     in algebraic mode.


 - Function: RATCOEF (exp, v, n)
     returns the coefficient, C, of the expression v**n in the
     expression exp.  n may be omitted if it is 1.  C will be free
     (except possibly in a non-rational sense) of the variables in v.
     If no coefficient of this type exists, zero will be returned.
     RATCOEF expands and rationally simplifies its first argument and
     thus it may produce answers different from those of COEFF which is
     purely syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y
     whereas COEFF returns 1.  RATCOEF(exp,v,0), viewing exp as a sum,
     gives a sum of those terms which do not contain v.  Therefore if v
     occurs to any negative powers, RATCOEF should not be used.  Since
     exp is rationally simplified before it is examined, coefficients
     may not appear quite the way they were envisioned.
          (C1) S:A*X+B*X+5$
          (C2) RATCOEF(S,A+B);
          (D2)               X

 - Function: RATDENOM (exp)
     obtains the denominator of the rational expression exp.  If exp is
     in general form then the DENOM function should be used instead,
     unless one wishes to get a CRE result.


 - Variable: RATDENOMDIVIDE
     default: [TRUE] - if FALSE will stop the splitting up of the terms
     of the numerator of RATEXPANDed expressions from occurring.


 - Function: RATDIFF (exp, var)
     differentiates the rational expression exp (which must be a ratio
     of polynomials or a polynomial in the variable var) with respect
     to var.  For rational expressions this is much faster than DIFF.
     The result is left in CRE form.  However, RATDIFF should not be
     used on factored CRE forms; use DIFF instead for such expressions.
          (C1) (4*X**3+10*X-11)/(X**5+5);
                                                   3
                                                4 X  + 10 X - 11
          (D1)                                  ----------------
                                                      5
                                                     X
          (C2) MODULUS:3$
          (C3) MOD(D1);
                                          2
                                         X  + X - 1
          (D3)                      --------------------
                                     4    3    2
                                    X  + X  + X  + X + 1
          (C4) RATDIFF(D1,X);
                                    5    4    3
                                   X  - X  - X  + X - 1
          (D4)                ------------------------------
                               8    7    5    4    3
                              X  - X  + X  - X  + X  - X + 1

 - Function: RATDISREP (exp)
     changes its argument from CRE form to general form.  This is
     sometimes convenient if one wishes to stop the "contagion", or use
     rational functions in non-rational contexts.  Most CRE functions
     will work on either CRE or non-CRE expressions, but the answers may
     take different forms.  If RATDISREP is given a non-CRE for an
     argument, it returns its argument unchanged.  See also TOTALDISREP.


 - Variable: RATEPSILON
     default: [2.0E-8] - the tolerance used in the conversion of
     floating point numbers to rational numbers.


 - Function: RATEXPAND (exp)
     expands exp by multiplying out products of sums and exponentiated
     sums, combining fractions over a common denominator, cancelling
     the greatest common divisor of the numerator and denominator, then
     splitting the numerator (if a sum) into its respective terms
     divided by the denominator.  This is accomplished by converting
     exp to CRE form and then back to general form.  The switch
     RATEXPAND, default: [FALSE], if TRUE will cause CRE expressions to
     be fully expanded when they are converted back to general form or
     displayed, while if it is FALSE then they will be put into a
     recursive form. (see RATSIMP) RATDENOMDIVIDE[TRUE] - if FALSE will
     stop the splitting up of the terms of the numerator of RATEXPANDed
     expressions from occurring.  KEEPFLOAT[FALSE] if set to TRUE will
     prevent floating point numbers from being rationalized when
     expressions which contain them are converted to CRE form.
          (C1) RATEXPAND((2*X-3*Y)**3);
                          3         2       2        3
          (D1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X
          (C2) (X-1)/(X+1)**2+1/(X-1);
                                        X - 1       1
          (D2)                         -------- + -----
                                              2   X - 1
                                       (X + 1)
          (C3) EXPAND(D2);
                                   X              1           1
          (D3)                ------------ - ------------ + -----
                               2              2             X - 1
                              X  + 2 X + 1   X  + 2 X + 1
          (C4) RATEXPAND(D2);
                                       2
                                    2 X                 2
          (D4)                 --------------- + ---------------
                                3    2            3    2
                               X  + X  - X - 1   X  + X  - X - 1

 - Variable: RATFAC
     default: [FALSE] - when TRUE invokes a partially factored form for
     CRE rational expressions.  During rational operations the
     expression is maintained as fully factored as possible without an
     actual call to the factor package.  This should always save space
     and may save some time in some computations.  The numerator and
     denominator are still made relatively prime, for example RAT((X^2
     -1)^4/(X+1)^2);  yields (X-1)^4*(X+1)^2), but the factors within
     each part may not be relatively prime.  In the CTENSR (Component
     Tensor Manipulation) Package, if RATFAC is TRUE, it causes the
     Ricci, Einstein, Riemann, and Weyl tensors and the Scalar
     Curvature to be factored automatically.  ** This should only be
     set for cases where the tensorial components are known to consist
     of few terms **.  Note: The RATFAC and RATWEIGHT schemes are
     incompatible and may not both be used at the same time.


 - Function: RATNUMER (exp)
     obtains the numerator of the rational expression exp.  If exp is
     in general form then the NUM function should be used instead,
     unless one wishes to get a CRE result.


 - Function: RATNUMP (exp)
     is TRUE if exp is a rational number (includes integers) else FALSE.


 - Function: RATP (exp)
     is TRUE if exp is in CRE or extended CRE form else FALSE.


 - Variable: RATPRINT
     default: [TRUE] - if FALSE suppresses the printout of the message
     informing the user of the conversion of floating point numbers to
     rational numbers.


 - Function: RATSIMP (exp)
     rationally" simplifies (similar to RATEXPAND) the expression exp
     and all of its subexpressions including the arguments to non-
     rational functions.  The result is returned as the quotient of two
     polynomials in a recursive form, i.e.  the coefficients of the
     main variable are polynomials in the other variables.  Variables
     may, as in RATEXPAND, include non-rational functions (e.g.
     SIN(X**2+1) ) but with RATSIMP, the arguments to non-rational
     functions are rationally simplified.  Note that RATSIMP is
     affected by some of the variables which affect RATEXPAND.
     RATSIMP(exp,v1,v2,...,vn) - enables rational simplification with
     the specification of variable ordering as in RATVARS.
     RATSIMPEXPONS[FALSE] - if TRUE will cause exponents of expressions
     to be RATSIMPed automatically during simplification.
          (C1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);
                                                     2          2
                              X          (LOG(X) + 1)  - LOG (X)
          (D1)          SIN(------) = %E
                             2
                            X  + X
          (C2) RATSIMP(%);
                                            1          2
          (D2)                        SIN(-----) = %E X
                                          X + 1
          (C3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));
                                 3/2
                          (X - 1)    - SQRT(X - 1) (X + 1)
          (D3)            --------------------------------
                              SQRT(X - 1) SQRT(X + 1)
          (C4) RATSIMP(%);
                                           2
          (D4)                      - -----------
                                      SQRT(X + 1)
          (C5)  X**(A+1/A),RATSIMPEXPONS:TRUE;
                              2
                             A  + 1
                             ------
                               A
          (D5)              X

 - Variable: RATSIMPEXPONS
     default: [FALSE] - if TRUE will cause exponents of expressions to
     be RATSIMPed automatically during simplification.


 - Function: RATSUBST (a, b, c)
     substitutes a for b in c.  b may be a sum, product, power, etc.
     RATSUBST knows something of the meaning of expressions whereas
     SUBST does a purely syntactic substitution.  Thus
     SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas RATSUBST would return Z+A.
     RADSUBSTFLAG[FALSE] if TRUE permits RATSUBST to make substitutions
     like U for SQRT(X) in X.  Do EXAMPLE(RATSUBST); for examples.


 - Function: RATVARS (var1, var2, ..., varn)
     forms its n arguments into a list in which the rightmost variable
     varn will be the main variable of future rational expressions in
     which it occurs, and the other variables will follow in sequence.
     If a variable is missing from the RATVARS list, it will be given
     lower priority than the leftmost variable var1. The arguments to
     RATVARS can be either variables or non-rational functions (e.g.
     SIN(X)).  The variable RATVARS is a list of the arguments which
     have been given to this function.


 - Function: RATWEIGHT (v1, w1, ..., vn, wn)
     assigns a weight of wi to the variable vi.  This causes a term to
     be replaced by 0 if its weight exceeds the value of the variable
     RATWTLVL [default is FALSE which means no truncation].  The weight
     of a term is the sum of the products of the weight of a variable
     in the term times its power.  Thus the weight of 3*v1**2*v2 is
     2*w1+w2.  This truncation occurs only when multiplying or
     exponentiating CRE forms of expressions.
          (C5) RATWEIGHT(A,1,B,1);
          (D5)                         [[B, 1], [A, 1]]
          (C6) EXP1:RAT(A+B+1)$
          (C7) %**2;
                                2                  2
          (D7)/R/              B  + (2 A + 2) B + A  + 2 A + 1
          (C8) RATWTLVL:1$
          (C9) EXP1**2;
          (D9)/R/                       2 B + 2 A + 1
     Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
     both be used at the same time.


 - Variable: RATWEIGHTS
     - a list of weight assignments (set up by the RATWEIGHT function),
     RATWEIGHTS; or RATWEIGHT(); will show you the list.

          KILL(...,RATWEIGHTS)
     and
          SAVE(...,RATWEIGHTS);
     both work.


 - Variable: RATWEYL
     default: [] - one of the switches controlling the simplification
     of components of the Weyl conformal tensor; if TRUE, then the
     components will be rationally simplified; if FACRAT is TRUE then
     the results will be factored as well.


 - Variable: RATWTLVL
     default: [FALSE] - used in combination with the RATWEIGHT function
     to control the truncation of rational (CRE form) expressions (for
     the default value of FALSE, no truncation occurs).


 - Function: REMAINDER (p1, p2, var1, ...)
     computes the remainder of the polynomial p1 divided by the
     polynomial p2.


 - Function: RESULTANT (p1, p2, var)
     computes the resultant of the two polynomials p1 and p2,
     eliminating the variable var.  The resultant is a determinant of
     the coefficients of var in p1 and p2 which equals zero if and only
     if p1 and p2 have a non-constant factor in common.  If p1 or p2
     can be factored, it may be desirable to call FACTOR before calling
     RESULTANT.  RESULTANT[SUBRES] - controls which algorithm will be
     used to compute the resultant.  SUBRES for subresultant prs [the
     default], MOD for modular resultant algorithm, and RED for reduced
     prs.  On most problems SUBRES should be best.  On some large
     degree univariate or bivariate problems MOD may be better.
     Another alternative is the BEZOUT command which takes the same
     arguments as RESULTANT and returns a matrix.  DETERMINANT of this
     matrix is the desired resultant.


 - Variable: SAVEFACTORS
     default: [FALSE] - if TRUE causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.


 - Function: SQFR (exp)
     is similar to FACTOR except that the polynomial factors are
     "square-free." That is, they have factors only of degree one.  This
     algorithm, which is also used by the first stage of FACTOR,
     utilizes the fact that a polynomial has in common with its nth
     derivative all its factors of degree > n.  Thus by taking gcds
     with the polynomial of the derivatives with respect to each
     variable in the polynomial, all factors of degree > 1 can be found.
          (C1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);
                                       2               2
          (D1)                       (X  - 1) (2 X + 1)

 - Function: TELLRAT (poly)
     adds to the ring of algebraic integers known to MACSYMA, the
     element which is the solution of the polynomial with integer
     coefficients.  MACSYMA initially knows about %I and all roots of
     integers. TELLRAT(X); means substitute 0 for X in rational
     functions.  There is a command UNTELLRAT which takes kernels and
     removes TELLRAT properties.  When TELLRATing a multivariate
     polynomial, e.g. TELLRAT(X^2-Y^2);, there would be an ambiguity as
     to whether to substitute Y^2 for X^2 or vice versa.  The system
     will pick a particular ordering, but if the user wants to specify
     which, e.g.  TELLRAT(Y^2=X^2); provides a syntax which says
     replace Y^2 by X^2.  TELLRAT and UNTELLRAT both can take any
     number of arguments, and TELLRAT(); returns a list of the current
     substitutions.  Note: When you TELLRAT reducible polynomials, you
     want to be careful not to attempt to rationalize a denominator
     with a zero divisor.  E.g.  TELLRAT(W^3-1)$ ALGEBRAIC:TRUE$
     RAT(1/(W^2-W)); will give "quotient by zero".  This error can be
     avoided by setting RATALGDENOM:FALSE$.  ALGEBRAIC[FALSE] must be
     set to TRUE in order for the simplification of algebraic integers
     to take effect.  Do EXAMPLE(TELLRAT); for examples.


 - Function: TOTALDISREP (exp)
     converts every subexpression of exp from CRE to general form.  If
     exp is itself in CRE form then this is identical to RATDISREP but
     if not then RATDISREP would return exp unchanged while TOTALDISREP
     would "totally disrep" it.  This is useful for ratdisrepping
     expressions e.g., equations, lists, matrices, etc. which have some
     subexpressions in CRE form.


 - Function: UNTELLRAT (x)
     takes kernels and removes TELLRAT properties.



File: maxima.info,  Node: Constants,  Next: Logarithms,  Prev: Polynomials,  Up: Top

Constants
*********

* Menu:

* Definitions for Constants::


File: maxima.info,  Node: Definitions for Constants,  Prev: Constants,  Up: Constants

Definitions for Constants
=========================

 - Variable: E
     - The base of natural logarithms, e, is represented in MACSYMA as
     %E.


 - Variable: FALSE
     - the Boolean constant, false. (NIL in LISP)


 - Variable: MINF
     - real minus infinity.


 - Variable: PI
     - "pi" is represented in MACSYMA as %PI.


 - Variable: TRUE
     - the Boolean constant, true. (T in LISP)



File: maxima.info,  Node: Logarithms,  Next: Trigonometric,  Prev: Constants,  Up: Top

Logarithms
**********

* Menu:

* Definitions for Logarithms::


File: maxima.info,  Node: Definitions for Logarithms,  Prev: Logarithms,  Up: Logarithms

Definitions for Logarithms
==========================

 - Function: LOG (X)
     the natural logarithm.

     LOGEXPAND[TRUE] - causes LOG(A^B) to become B*LOG(A).  If it is set
     to ALL, LOG(A*B) will also simplify to LOG(A)+LOG(B).  If it is
     set to SUPER, then LOG(A/B) will also simplify to LOG(A)-LOG(B)
     for rational numbers a/b, a#1.  (LOG(1/B), for B integer, always
     simplifies.)  If it is set to FALSE, all of these simplifications
     will be turned off.

     LOGSIMP[TRUE] - if FALSE then no simplification of %E to a power
     containing LOG's is done.

     LOGNUMER[FALSE] - if TRUE then negative floating point arguments to
     LOG will always be converted to their absolute value before the
     log is taken.  If NUMER is also TRUE, then negative integer
     arguments to LOG will also be converted to their absolute value.

     LOGNEGINT[FALSE] - if TRUE implements the rule LOG(-n) ->
     LOG(n)+%i*%pi for n a positive integer.

     %E_TO_NUMLOG[FALSE] - when TRUE, "r" some rational number, and "x"
     some expression, %E^(r*LOG(x)) will be simplified into x^r .  It
     should be noted that the RADCAN command also does this
     transformation, and more complicated transformations of this ilk
     as well.  The LOGCONTRACT command "contracts" expressions
     containing LOG.


 - Variable: LOGABS
     default: [FALSE] - when doing indefinite integration where logs
     are generated, e.g. INTEGRATE(1/X,X), the answer is given in terms
     of LOG(ABS(...)) if LOGABS is TRUE, but in terms of LOG(...) if
     LOGABS is FALSE.  For definite integration, the LOGABS:TRUE
     setting is used, because here "evaluation" of the indefinite
     integral at the endpoints is often needed.


 - Variable: LOGARC
     default: [FALSE] - if TRUE will cause the inverse circular and
     hyperbolic functions to be converted into logarithmic form.
     LOGARC(exp) will cause this conversion for a particular expression
     without setting the switch or having to re-evaluate the expression
     with EV.


 - Variable: LOGCONCOEFFP
     default:[FALSE] - controls which coefficients are contracted when
     using LOGCONTRACT.  It may be set to the name of a predicate
     function of one argument.  E.g. if you like to generate SQRTs, you
     can do LOGCONCOEFFP:'LOGCONFUN$ LOGCONFUN(M):=FEATUREP(M,INTEGER)
     OR RATNUMP(M)$ .  Then LOGCONTRACT(1/2*LOG(X)); will give
     LOG(SQRT(X)).


 - Function: LOGCONTRACT (exp)
     recursively scans an exp, transforming subexpressions of the form
     a1*LOG(b1) + a2*LOG(b2) + c into LOG(RATSIMP(b1^a1 * b2^a2)) + c
          (C1) 2*(A*LOG(X) + 2*A*LOG(Y))$
          (C2) LOGCONTRACT(%);
                                                  2  4
          (D3)                             A LOG(X  Y )
     If you do DECLARE(N,INTEGER); then LOGCONTRACT(2*A*N*LOG(X)); gives
     A*LOG(X^(2*N)).  The coefficients that "contract" in this manner
     are those such as the 2 and the N here which satisfy
     FEATUREP(coeff,INTEGER).  The user can control which coefficients
     are contracted by setting the option LOGCONCOEFFP[FALSE] to the
     name of a predicate function of one argument.  E.g. if you like to
     generate SQRTs, you can do LOGCONCOEFFP:'LOGCONFUN$
     LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$ .  Then
     LOGCONTRACT(1/2*LOG(X)); will give LOG(SQRT(X)).


 - Variable: LOGEXPAND
     default: [TRUE] - causes LOG(A^B) to become B*LOG(A).  If it is
     set to ALL, LOG(A*B) will also simplify to LOG(A)+LOG(B).  If it
     is set to SUPER, then LOG(A/B) will also simplify to LOG(A)-LOG(B)
     for rational numbers a/b, a#1.  (LOG(1/B), for B integer, always
     simplifies.)  If it is set to FALSE, all of these simplifications
     will be turned off.


 - Variable: LOGNEGINT
     default: [FALSE] - if TRUE implements the rule LOG(-n) ->
     LOG(n)+%i*%pi   for n a positive integer.


 - Variable: LOGNUMER
     default: [FALSE] - if TRUE then negative floating point arguments
     to LOG will always be converted to their absolute value before the
     log is taken.  If NUMER is also TRUE, then negative integer
     arguments to LOG will also be converted to their absolute value.


 - Variable: LOGSIMP
     default: [TRUE] - if FALSE then no simplification of %E to a power
     containing LOG's is done.


 - Function: PLOG (X)
     the principal branch of the complex-valued natural logarithm with
     -%PI < CARG(X) <= +%PI .


 - Function: POLARFORM (exp)
     returns R*%E^(%I*THETA) where R and THETA are purely real.



File: maxima.info,  Node: Trigonometric,  Next: Special Functions,  Prev: Logarithms,  Up: Top

Trigonometric
*************

* Menu:

* Introduction to Trigonometric::
* Definitions for Trigonometric::


File: maxima.info,  Node: Introduction to Trigonometric,  Next: Definitions for Trigonometric,  Prev: Trigonometric,  Up: Trigonometric

Introduction to Trigonometric
=============================

- MACSYMA has many Trig functions defined.  Not all Trig identities are
programmed, but it is possible for the user to add many of them using
the pattern matching capabilities of the system.  The Trig functions
defined in MACSYMA are: ACOS, ACOSH, ACOT, ACOTH, ACSC, ACSCH, ASEC,
ASECH, ASIN, ASINH, ATAN, ATANH, COS, COSH, COT, COTH, CSC, CSCH, SEC,
SECH, SIN, SINH, TAN, and TANH.  There are a number of commands
especially for handling Trig functions, see TRIGEXPAND, TRIGREDUCE, and
the switch TRIGSIGN.  Two SHARE packages extend the simplification
rules built into MACSYMA, NTRIG and ATRIG1.  Do DESCRIBE(cmd) for
details.


File: maxima.info,  Node: Definitions for Trigonometric,  Prev: Introduction to Trigonometric,  Up: Trigonometric

Definitions for Trigonometric
=============================

 - Function: ACOS
     - Arc Cosine


 - Function: ACOSH
     - Hyperbolic Arc Cosine


 - Function: ACOT
     - Arc Cotangent


 - Function: ACOTH
     - Hyperbolic Arc Cotangent


 - Function: ACSC
     - Arc Cosecant


 - Function: ACSCH
     - Hyperbolic Arc Cosecant


 - Function: ASEC
     - Arc Secant


 - Function: ASECH
     - Hyperbolic Arc Secant


 - Function: ASIN
     - Arc Sine


 - Function: ASINH
     - Hyperbolic Arc Sine


 - Function: ATAN
     - Arc Tangent


 - Function: ATAN2 (Y,X)
     yields the value of ATAN(Y/X) in the interval -%PI to %PI.


 - Function: ATANH
     - Hyperbolic Arc Tangent


 - Function: ATRIG1
     - SHARE1;ATRIG1 FASL contains several additional simplification
     rules for inverse trig functions.  Together with rules already
     known to Macsyma, the following angles are fully implemented: 0,
     %PI/6, %PI/4, %PI/3, and %PI/2.  Corresponding angles in the other
     three quadrants are also available.  Do LOAD(ATRIG1); to use them.


 - Function: COS
     - Cosine


 - Function: COSH
     - Hyperbolic Cosine


 - Function: COT
     - Cotangent


 - Function: COTH
     - Hyperbolic Cotangent


 - Function: CSC
     - Cosecant


 - Function: CSCH
     - Hyperbolic Cosecant


 - Variable: HALFANGLES
     default: [FALSE] - if TRUE causes half-angles to be simplified
     away.


 - Function: SEC
     - Secant


 - Function: SECH
     - Hyperbolic Secant


 - Function: SIN
     - Sine


 - Function: SINH
     - Hyperbolic Sine


 - Function: TAN
     - Tangent


 - Function: TANH
     - Hyperbolic Tangent


 - Function: TRIGEXPAND (exp)
     expands trigonometric and hyperbolic functions of sums of angles
     and of multiple angles occurring in exp.  For best results, exp
     should be expanded.  To enhance user control of simplification,
     this function expands only one level at a time, expanding sums of
     angles or multiple angles.  To obtain full expansion into sines
     and cosines immediately, set the switch TRIGEXPAND:TRUE.
     TRIGEXPAND default: [FALSE] - if TRUE causes expansion of all
     expressions containing SINs and COSs occurring subsequently.
     HALFANGLES[FALSE] - if TRUE causes half-angles to be simplified
     away.  TRIGEXPANDPLUS[TRUE] - controls the "sum" rule for
     TRIGEXPAND, expansion of sums (e.g. SIN(X+Y)) will take place only
     if TRIGEXPANDPLUS is TRUE.  TRIGEXPANDTIMES[TRUE] - controls the
     "product" rule for TRIGEXPAND, expansion of products (e.g.
     SIN(2*X)) will take place only if TRIGEXPANDTIMES is TRUE.
          (C1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;
                                        2           2
          (D1)                     - SIN (X) + 3 COS (X) + X
          (C2) TRIGEXPAND(SIN(10*X+Y));
          (D2)               COS(10 X) SIN(Y) + SIN(10 X) COS(Y)

 - Variable: TRIGEXPANDPLUS
     default: [TRUE] - controls the "sum" rule for TRIGEXPAND.  Thus,
     when the TRIGEXPAND command is used or the TRIGEXPAND switch set
     to TRUE, expansion of sums (e.g. SIN(X+Y)) will take place only if
     TRIGEXPANDPLUS is TRUE.


 - Variable: TRIGEXPANDTIMES
     default: [TRUE] - controls the "product" rule for TRIGEXPAND.
     Thus, when the TRIGEXPAND command is used or the TRIGEXPAND switch
     set to TRUE, expansion of products (e.g. SIN(2*X)) will take place
     only if TRIGEXPANDTIMES is TRUE.


 - Variable: TRIGINVERSES
     default: [ALL] - controls the simplification of the composition of
     trig and hyperbolic functions with their inverse functions: If
     ALL, both e.g. ATAN(TAN(X)) and TAN(ATAN(X)) simplify to X.  If
     TRUE, the arcfunction(function(x)) simplification is turned off.
     If FALSE, both the arcfun(fun(x)) and fun(arcfun(x))
     simplifications are turned off.


 - Function: TRIGREDUCE (exp, var)
     combines products and powers of trigonometric and hyperbolic SINs
     and COSs of var into those of multiples of var.  It also tries to
     eliminate these functions when they occur in denominators.  If var
     is omitted then all variables in exp are used.  Also see the
     POISSIMP function (6.6).
          (C4) TRIGREDUCE(-SIN(X)^2+3*COS(X)^2+X);
          (D4)                        2 COS(2 X) + X + 1
          The trigonometric simplification routines will use declared
          information in some simple cases.  Declarations about variables are
          used as follows, e.g.
          (C5) DECLARE(J, INTEGER, E, EVEN, O, ODD)$
          (C6) SIN(X + (E + 1/2)*%PI)$
          (D6)                      COS(X)
          (C7) SIN(X + (O + 1/2) %PI);
          (D7)                     - COS(X)

 - Variable: TRIGSIGN
     default: [TRUE] - if TRUE permits simplification of negative
     arguments to trigonometric functions. E.g., SIN(-X) will become
     -SIN(X) only if TRIGSIGN is TRUE.


 - Function: TRIGSIMP (expr)
     employs the identities sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 to simplify expressions containing tan, sec, etc. to
     sin, cos, sinh, cosh so that further simplification may be
     obtained by using TRIGREDUCE on the result.  Some examples may be
     seen by doing DEMO("trgsmp.dem"); .  See also the TRIGSUM function.


 - Function: TRIGRAT (trigexp)
     gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; trigexp is a rational fraction of several sin, cos or
     tan, the arguments of them are linear forms in some variables (or
     kernels) and %pi/n (n integer) with integer coefficients. The
     result is a simplifyed fraction with numerator and denominator
     linear in sin and cos.  Thus TRIGRAT linearize always when it is
     possible.(written by D. Lazard).

          (c1) trigrat(sin(3*a)/sin(a+%pi/3));
          
          (d1) 		        sqrt(3) sin(2 a) + cos(2 a) - 1

     Here is another example (for which the function was intended); see
     [Davenport, Siret, Tournier, Calcul Formel, Masson (or in english,
     Addison-Wesley), section 1.5.5, Morley theorem). Timings are on
     VAX 780.

          (c4)   c:%pi/3-a-b;
          
          					   %pi
          (d4) 				 - b - a + ---
          					    3
          
          (c5)   bc:sin(a)*sin(3*c)/sin(a+b);
          
          			     sin(a) sin(3 b + 3 a)
          (d5) 			     ---------------------
          				  sin(b + a)
          
          (c6)   ba:bc,c=a,a=c$
          
          (c7)   ac2:ba^2+bc^2-2*bc*ba*cos(b);
          
          	2       2
               sin (a) sin (3 b + 3 a)
          (d7) -----------------------
          	      2
          	   sin (b + a)
          
          					%pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
          					 3
           - --------------------------------------------------------
          			   %pi
          		   sin(a - ---) sin(b + a)
          			    3
          
                2	        2	  %pi
             sin (3 a) sin (b + a - ---)
          			   3
           + ---------------------------
          	     2	   %pi
          	  sin (a - ---)
          		    3
          
          (c9)   trigrat(ac2);
          Totaltime= 65866 msec.  GCtime= 7716 msec.
          
          (d9)
          - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
          
          - 2 sqrt(3) sin(4 b + 2 a)
          
          + 2 cos(4 b + 2 a) - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
          
          + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
          
          + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
          
          + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
          
             - 9)/4


File: maxima.info,  Node: Special Functions,  Next: Orthogonal Polynomials,  Prev: Trigonometric,  Up: Top

Special Functions
*****************

* Menu:

* Introduction to Special Functions::
* GAMALG::
* SPECINT::
* Definitions for Special Functions::


File: maxima.info,  Node: Introduction to Special Functions,  Next: GAMALG,  Prev: Special Functions,  Up: Special Functions

Introduction to Special Functions
=================================

 - %J:
     [index](expr) - Bessel Funct 1st Kind (in SPECINT)


 - %K: [index](expr)
     Bessel Funct 2nd Kind (in SPECINT)

     Constant, in ODE2



File: maxima.info,  Node: GAMALG,  Next: SPECINT,  Prev: Introduction to Special Functions,  Up: Special Functions

GAMALG
======

- A Dirac gamma matrix algebra program which takes traces of and does
manipulations on gamma matrices in n dimensions.  It may be loaded into
MACSYMA by LOADFILE("gam"); A preliminary manual is contained in the
file SHARE;GAM USAGE and may be printed using
PRINTFILE(GAM,USAGE,SHARE);


File: maxima.info,  Node: SPECINT,  Next: Definitions for Special Functions,  Prev: GAMALG,  Up: Special Functions

SPECINT
=======

- The Hypergeometric Special Functions Package HYPGEO is still under
development.  At the moment it will find the Laplace Transform or
rather, the integral from 0 to INF of some special functions or
combinations of them.  The factor, EXP(-P*var) must be explicitly
stated.  The syntax is as follows: SPECINT(EXP(-P*var)*expr,var); where
var is the variable of integration and expr may be any expression
containing special functions (at your own risk).  Special function
notation follows:
     %J[index](expr)         Bessel Funct 1st Kind
     %K[index](expr)           "     "    2nd Kind
     %IBES[     ](    )      Modified Bessel Funct 1st Kind
     %HE[     ](  )          Hermite Poly
     %P[  ]( )               Legendre Funct
     %Q[  ]( )               Legendre of second kind
     HSTRUVE[ ]( )           Struve H Function
     LSTRUVE[ ]( )             "    L Function
     %F[ ]([],[],expr)       Hypergeometric Function
     GAMMA()
     GAMMAGREEK()
     GAMMAINCOMPLETE()
     SLOMMEL
     %M[]()                  Whittaker Funct 1st Kind
     %W[]()                     "       "    2nd  "

For a better feeling for what it can do, do DEMO(HYPGEO,DEMO,SHARE1); .


File: maxima.info,  Node: Definitions for Special Functions,  Prev: SPECINT,  Up: Special Functions

Definitions for Special Functions
=================================

 - Function: AIRY (X)
     returns the Airy function Ai of real argument X.  The file
     SHARE1;AIRY FASL contains routines to evaluate the Airy functions
     Ai(X), Bi(X), and their derivatives dAi(X), dBi(X).  Ai and Bi
     satisfy the AIRY eqn diff(y(x),x,2)-x*y(x)=0.  Read SHARE1;AIRY
     USAGE for details.


 - Function: ASYMP
     - A preliminary version of a program to find the asymptotic
     behavior of Feynman diagrams has been installed on the SHARE1;
     directory.  For further information, see the file SHARE1;ASYMP
     USAGE.  (For Asymptotic Analysis functions, see ASYMPA.)


 - Function: ASYMPA
     - Asymptotic Analysis - The file SHARE1;ASYMPA > contains
     simplification functions for asymptotic analysis, including the
     big-O and little-o functions that are widely used in complexity
     analysis and numerical analysis.  Do BATCH("asympa.mc"); .  (For
     asymptotic behavior of Feynman diagrams, see ASYMP.)


 - Function: BESSEL (Z,A)
     returns the Bessel function J for complex Z and real A > 0.0 .
     Also an array BESSELARRAY is set up such that BESSELARRAY[I] =
     J[I+A- ENTIER(A)](Z).


 - Function: BESSEL_J [v](z)
     The Bessel function of the first kind of order v and argument z.
     It is defined by
          		       INF
          		       ====	  k  - v - 2 k  v + 2 k
          		       \     (- 1)  2	       z
           		        >    --------------------------
          		       /        k! GAMMA(v + k + 1)
          		       ====
          		       k = 0


 - Function: BESSEL_Y [v](z)
     The Bessel function of the second kind of order v and argument z.
     It is defined by
                             COS(%PI v) BESSEL_J (z) - BESSEL_J   (z)
                                                v              - v
                             ----------------------------------------
                                            SIN(%PI v)

     when v is not an integer.  When v is an integer n, the limit as v
     approaches n is taken.


 - Function: BESSEL_I [v](z)
     The modified Bessel function of the first kind of order v and
     argument z.    It is defined by

          			   INF
          			   ====	  - v - 2 k  v + 2 k
          			   \	 2	    z
          (D1) 			    >	 -------------------
          			   /	 k! GAMMA(v + k + 1)
          			   ====
          			   k = 0


 - Function: BESSEL_K [v](z)
     The modified Bessel function of the second kind of order v and
     argument z.  It is defined by

          		%PI CSC(%PI v) (BESSEL_I   (z) - BESSEL_I (z))
          					- v		 v
          (D3) 	        ----------------------------------------------
          				      2
     when v is not an integer.  If v is an integer n, then the limit as
     v approaches n is taken.

 - Variable: BESSELEXPAND
     default: FALSE  Controls expansion of the Bessel functions when
     the order half of an  odd integer.  In this case, the Bessel
     functions can be expanded in  terms of other elementary functions.
     When BESSELEXPAND is true, the  Bessel function is expanded.

          (C1) bessel_j[3/2](z);
          
          (D1)                            BESSEL_J   (z)
                                                  3/2
          (C2) besselexpand:true;
          
          (D2)                                 TRUE
          (C3) bessel_j[3/2](z);
          
                                                   COS(z)   SIN(z)
                                  SQRT(2) SQRT(z) (------ - ------)
                                                     z         2
                                                              z
          (D3)                  - ---------------------------------
                                              SQRT(%PI)

 - Function: BETA (X, Y)
     same as GAMMA(X)*GAMMA(Y)/GAMMA(X+Y).


 - Function: GAMMA (X)
     the gamma function. GAMMA(I)=(I-1)!  for I a positive integer.
     For the Euler-Mascheroni constant, see %GAMMA.  See also the
     MAKEGAMMA function.  The variable GAMMALIM[1000000] (which see)
     controls simplification of the gamma function.


 - Variable: GAMMALIM
     default: [1000000] controls simplification of the gamma function
     for integral and rational number arguments.  If the absolute value
     of the argument is not greater than GAMMALIM, then simplification
     will occur.  Note that the FACTLIM switch controls simplification
     of the result of GAMMA of an integer argument as well.


 - Function: INTOPOIS (A)
     converts A into a Poisson encoding.


 - Function: MAKEFACT (exp)
     transforms occurrences of binomial,gamma, and beta functions in
     exp to factorials.


 - Function: MAKEGAMMA (exp)
     transforms occurrences of binomial,factorial, and beta functions
     in exp to gamma functions.


 - Function: NUMFACTOR (exp)
     gives the numerical factor multiplying the expression exp which
     should be a single term.  If the gcd of all the terms in a sum is
     desired the CONTENT function may be used.
          (C1) GAMMA(7/2);
          (D1)               15 SQRT(%PI)
                             ------------
                                  8
          (C2) NUMFACTOR(%);
                              15
          (D2)                --
                               8

 - Function: OUTOFPOIS (A)
     converts A from Poisson encoding to general representation.  If A
     is not in Poisson form, it will make the conversion, i.e.  it will
     look like the result of OUTOFPOIS(INTOPOIS(A)).  This function is
     thus a canonical simplifier for sums of powers of SIN's and COS's
     of a particular type.


 - Function: POISDIFF (A, B)
     differentiates A with respect to B.  B must occur only in the trig
     arguments or only in the coefficients.


 - Function: POISEXPT (A, B)
     B a positive integer) is functionally identical to INTOPOIS(A**B).


 - Function: POISINT (A, B)
     integrates in a similarly restricted sense (to POISDIFF).
     Non-periodic terms in B are dropped if B is in the trig arguments.


 - Variable: POISLIM
     default: [5] - determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].


 - Function: POISMAP (series, sinfn, cosfn)
     will map the functions sinfn on the sine terms and cosfn on the
     cosine terms of the poisson series given.  sinfn and cosfn are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.


 - Function: POISPLUS (A, B)
     is functionally identical to INTOPOIS(A+B).


 - Function: POISSIMP (A)
     converts A into a Poisson series for A in general representation.


 - special symbol: POISSON
     - The Symbol /P/ follows the line label of Poisson series
     expressions.


 - Function: POISSUBST (A, B, C)
     substitutes A for B in C.  C is a Poisson series.  (1) Where B is
     a variable U, V, W, X, Y, or Z then A must be an expression linear
     in those variables (e.g. 6*U+4*V).  (2) Where B is other than
     those variables, then A must also be free of those variables, and
     furthermore, free of sines or cosines.  POISSUBST(A, B, C, D, N)
     is a special type of substitution which operates on A and B as in
     type (1) above, but where D is a Poisson series, expands COS(D)
     and SIN(D) to order N so as to provide the result of substituting
     A+D for B in C.  The idea is that D is an expansion in terms of a
     small parameter.  For example, POISSUBST(U,V,COS(V),E,3) results
     in COS(U)*(1-E^2/2) - SIN(U)*(E-E^3/6).


 - Function: POISTIMES (A, B)
     is functionally identical to INTOPOIS(A*B).


 - Function: POISTRIM ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the U,
     V,..., Z in a term.  Terms for which POISTRIM is TRUE (for the
     coefficients of that term) are eliminated during multiplication.


 - Function: PRINTPOIS (A)
     prints a Poisson series in a readable format.  In common with
     OUTOFPOIS, it will convert A into a Poisson encoding first, if
     necessary.


 - Function: PSI (X)
     derivative of LOG(GAMMA(X)).  At this time, MACSYMA does not have
     numerical evaluation capabilities for PSI.  For information on the
     PSI[N](X) notation, see POLYGAMMA.



File: maxima.info,  Node: Orthogonal Polynomials,  Next: Elliptic Functions,  Prev: Special Functions,  Up: Top

Orthogonal Polynomials
**********************

* Menu:

* Introduction to Orthogonal Polynomials::
* Definitions for Orthogonal Polynomials::


File: maxima.info,  Node: Introduction to Orthogonal Polynomials,  Next: Definitions for Orthogonal Polynomials,  Up: Orthogonal Polynomials

Introduction to Orthogonal Polynomials
======================================

The specfun package, located in the share directory,  contains Maxima
code for the evaluation of all orthogonal polynomials listed in Chapter
22 of Abramowitz and Stegun. These include Chebyshev, Laguerre,
Hermite, Jacobi, Legendre, and ultraspherical (Gegenbauer) polynomials.
Additionally, specfun contains code for spherical Bessel, spherical
Hankel, and spherical harmonic functions.

   The following table lists each  function in specfun, its Maxima
name, restrictions on its arguments ( m  and  n  must be integers), and
a reference to the algorithm specfun uses to evaluate it.  With few
exceptions, specfun follows the conventions of Abramowitz and Stegun.
Before you use specfun, check that specfun's conventions match your
expectations.

   A&S refers to Abramowitz and Stegun, _Handbook of Mathematical
Functions_ (10th printing, December 1972), G&R to Gradshteyn and Ryzhik,
_Table of Integrals, Series, and Products_ (1980 corrected and enlarged
edition), and Merzbacher to _Quantum Mechanics_ (2ed, 1970).

_Function_         _Maxima Name_      _Restrictions_     _Reference(s)_
Chebyshev T        chebyshev_t(n, x)  n > -1             A&S 22.5.31
Chebyshev U        chebyshev_u(n, x)  n > -1             A&S 22.5.32
generalized        gen_laguerre(n,a,x)n > -1             A&S page 789
Laguerre                                                 
Laguerre           laguerre(n,x)      n > -1             A&S 22.5.67
Hermite            hermite(n,x)        n > -1            A&S 22.4.40,
                                                         22.5.41
Jacobi             jacobi_p(n,a,b,x)   n > -1, a, b >    A&S page 789
                                      -1                 
associated         assoc_legendre_p(n,m,x)n > -1             A&S 22.5.37,
Legendre P                                               8.6.6, 8.2.5
associated         assoc_legendre_q(n,m,x)n > -1, m > -1     G & R 8.706
Legendre Q                                               
Legendre P         legendre_p(n,m,x)  n > -1             A&S 22.5.35
Legendre Q         legendre_q(n,m,x)  n > -1             A&S 8.6.19
spherical Hankel   spherical_hankel1(n,n > -1             A&S 10.1.36
1st                x)                                    
spherical Hankel   spherical_hankel2(n,n > -1             A&S 10.1.17
2nd                x)                                    
spherical Bessel   spherical_bessel_j(n,x)n > -1             A&S 10.1.8,
J                                                        10.1.15
spherical Bessel   spherical_bessel_y(n,x)n > -1             A&S 10.1.9,
Y                                                        10.1.15
spherical          spherical_harmonic(n,m,x,y)n > -1, |m| <= n   Merzbacher 9.64
harmonic                                                 
ultraspherical     ultraspherical(n,a,x) n > -1            A&S 22.5.27
(Gegenbauer)                                             

   The specfun package is primarily intended for symbolic computation.
It is hoped  that it gives accurate floating point results as well;
however, no claims are made  that the algorithms are well suited for
numerical evaluation.  Some effort, however, has been made to provide
good numerical performance.  When all arguments, except for the order,
are floats (but not bfloats), many functions in specfun call a float
modedeclared version of the Jacobi function.  This  greatly speeds
floating point evaluation of the orthogonal polynomials.

   specfun handles most domain errors  by returning an unevaluated
function.  No attempt has been made to define simplification rules
(based on recursion relations) for unevaluated functions.  Users should
be aware that it is possible for an expression involving sums of
unevaluated special functions to vanish, yet Maxima is unable to reduce
it to zero.  Be careful.

   To access functions in specfun, you must first load specfun.o.
Alternatively, you may append autoload statements to your init.lsp file
(located in your working directory). To autoload  the hermite function,
for example, append
        (defprop |$hermite| #"specfun.o" autoload)
        (add2lnc '|$hermite| $props)
   to your init.lsp file.  An example use of specfun is
     (c1) load("specfun.o")$
     (c2) [hermite(0,x),hermite(1,x),hermite(2,x)];
     (d2) [1,2*x,-2*(1-2*x^2)]
     (c3) diff(hermite(n,x),x);
     (d3) 2*n*hermite(n-1,x)

   When using the compiled version of specfun, be especially careful to
use the correct number of function arguments; calling them with too
few arguments may generate a fatal error messages.  For example
     (c1) load("specfun")$
     /* chebyshev_t requires two arguments. */
     (c2) chebyshev_t(8);
     Error: Caught fatal error [memory may be damaged]
     Fast links are on: do (si::use-fast-links nil) for debugging
     Error signalled by MMAPCAR.
     Broken at SIMPLIFY.  Type :H for Help.
   Maxima code translated into Lisp handles such errors more gracefully.
If specfun.LISP is installed on your machine, the same computation
results in  a clear error message.  For example
     (c1) load("specfun.LISP")$
     (c2) chebyshev_t(8);
     Error: Expected 2 args but received 1 args
     Fast links are on: do (si::use-fast-links nil) for debugging
     Error signalled by MACSYMA-TOP-LEVEL.
     Broken at |$CHEBYSHEV_T|.  Type :H for Help.
   Generally, compiled code runs faster than translated code; however,
translated code may be better for program development.

   For some functions, when the order is symbolic but has been declared
to be an integer, specfun will return a series representation.  (The
series representation is not used by specfun for any computations.) You
may use this feature to find symbolic values for special values
orthogonal polynomials.  An example:
     (c1) load("specfun")$
     (c2) legendre_p(n,1);
     (d2)        legendre_p(n, 1)
     /* Declare n to be an integer; now legendre_p(n,1) evaluates to 1. */
     (c3) declare(n,integer)$
     (c4) legendre_p(n,1);
     (d4)        1
     (c5) ultraspherical(n,3/2,1);
     (d4)         (n+1)*gamma (n+3) / (2*gamma (n+2))
   Although the preceding example doesn't show it, two terms of the sum
are added outside the summation.  Removing these two terms avoids
errors associated with  0^0 terms in a sum that should evaluate to 1,
but evaluate to 0 in a Maxima summation. Because the sum index runs
from 1 to n - 1, the lower sum index will exceed the upper sum index
when  n = 0; setting sumhack to true provides a fix. For example:

     (c1) load("specfun.o")$
     (c2) declare(n,integer)$
     (c3) e : legendre_p(n,x)$
     (c4) ev(e,sum,n=0);
     Lower bound to SUM: 1
     is greater than the upper bound: - 1
      -- an error.  Quitting.  To debug this try DEBUGMODE(TRUE);)
     (c5) ev(e,sum,n=0),sumhack : true;
     (d5)         1

   Most  functions in specfun have a gradef property; derivatives with
respect to the order or other function parameters aren't unevaluated.

   The specfun package and its documentation were written by Barton
Willis of the University of Nebraska at Kearney. It is released under
the terms of the General Public License (GPL).  Send bug reports and
comments on this package to willisb@unk.edu.  In your  report, please
include Maxima and specfun version information.  The specfun version
may be found using get:
      (c2) get('specfun,'version);
      (d2)          110


File: maxima.info,  Node: Definitions for Orthogonal Polynomials,  Prev: Introduction to Orthogonal Polynomials,  Up: Orthogonal Polynomials

Definitions for Orthogonal Polynomials
======================================

 - Function: ASSOC_LEGENDRE_P (n, m, x)
     [specfun package] return the associated Legendre function of the
     first kind for  integers  n > -1  and  m > -1.  When  | m | > n
     and  n >= 0, we have   assoc_legendre_p (n, m, x) = 0.  Reference:
     A&S 22.5.37 page 779,  A&S 8.6.6 (second equation) page 334, and
     A&S 8.2.5 page 333.  To access this function, load("specfun").
     See *Note ASSOC_LEGENDRE_Q::, *Note LEGENDRE_P::, and *Note
     LEGENDRE_Q::.

 - Function: ASSOC_LEGENDRE_Q (n, m, x)
     [specfun package] return the associated Legendre function of the
     second kind for  integers  n > -1  and  m > -1.

     Reference: Gradshteyn and Ryzhik  8.706 page 1000.

     To access this function, load("specfun").

     See also ASSOC_LEGENDRE_P, LEGENDRE_P, and LEGENDRE_Q.

 - Function: CHEBYSHEV_T (n, x)
     [specfun package] return the Chebyshev function of the first kind
     for  integers  n > -1.

     Reference: A&S 22.5.31 page 778 and A&S 6.1.22 page 256.

     To access this function, load("specfun").

     See also CHEBYSHEV_U.


 - Function: CHEBYSHEV_U (n, x)
     [specfun package] return the Chebyshev function of the second kind
     for integers  n > -1.

     Reference: A&S, 22.8.3 page 783  and A&S 6.1.22 page 256.

     To access this function, load("specfun").

     See also CHEBYSHEV_T.


 - Function: GEN_LAGUERRE (n, a, x)
     [specfun package] return the generalized Laguerre polynomial for
     integers  n > -1.

     To access this function, load("specfun").

     Reference: table on page 789 in A&S.

 - Function: HERMITE (n,x)
     [specfun package] return the Hermite polynomial for integers  n >
     -1.

     To access this function, load("specfun").

     Reference:  A&S 22.5.40 and 22.5.41, page 779.


 - Function: JACOBI_P (n, a, b, x)
     [specfun package] return the Jacobi polynomial for integers  n >
     -1  and  a  and  b  symbolic or  a > -1  and b > -1.  (The Jacobi
     polynomials are actually defined for all  a  and  b ; however, the
     Jacobi polynomial weight  (1-x)^a(1+x)^b isn't integrable for  a
     <= -1 or  b <= -1. )

     When a, b, and  x  are floats (but not bfloats) specfun calls a
     special modedeclared version of jacobi_p.  For numerical values,
     the modedeclared version is much faster than the other version.
     Many  functions in specfun are computed as a special case of the
     Jacobi polynomials; they also enjoy the  speed boost from the
     modedeclared version of  jacobi.

     If  n  has been declared to be an integer, jacobi_p (n, a, b, x)
     returns a summation representation for the Jacobi function.
     Because Maxima simplifies 0^0  to  0  in a sum, two terms of the
     sum are added outside the summation.

     To access this function, load("specfun").

     Reference:  table on page 789 in A&S.


 - Function: LAGUERRE (n, x)
     [specfun package] return the Laguerre polynomial for integers  n >
     -1.

     Reference: A&S 22.5.16, page 778 and A&S page 789.

     To access this function, load("specfun").

     See also GEN_LAGUERRE.


 - Function: LEGENDRE_P (n, x)
     [specfun package] return the Legendre polynomial of the first kind
     for  integers  n > -1.

     Reference: A&S 22.5.35 page 779.

     To access this function, load("specfun").

     See *Note LEGENDRE_Q::.


 - Function: LEGENDRE_Q (n, x)
     [specfun package] return the Legendre polynomial of the first kind
     for  integers  n > -1.

     Reference: A&S 8.6.19 page 334.

     To access this function, load("specfun").

     See also LEGENDRE_P.


 - Function: SPHERICAL_BESSEL_J (n, x)
     [specfun package] return the spherical Bessel function of the
     first kind for  integers  n > -1.

     Reference: A&S 10.1.8 page 437 and A&S 10.1.15 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL1, SPHERICAL_HANKEL2, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_BESSEL_Y (n, x)
     [specfun package] return the spherical Bessel function of the
     second kind for  integers  n > -1.

     Reference: A&S 10.1.9 page 437 and 10.1.15 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL1, SPHERICAL_HANKEL2, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_HANKEL1 (n,x)
     [specfun package] return the spherical hankel function  of the
     first kind for  integers  n > -1.

     Reference: A&S 10.1.36 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL2, SPHERICAL_BESSEL_J, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_HANKEL2 (n,x)
     [specfun package] return the spherical hankel function  of the
     second kind for  integers  n > -1.

     Reference:  A&S 10.1.17 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL1, SPHERICAL_BESSEL_J, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_HARMONIC (n, m, x, y)
     [specfun package] return the spherical harmonic function for
     integers  n > -1 and  | m | <= n .

     Reference:  Merzbacher 9.64.

     To access this function, load("specfun").

     See also ASSOC_LEGENDRE_P


 - Function: ULTRASPHERICAL (n,a,x)
     [specfun package] return the ultraspherical polynomials for
     integers  n > -1.  The ultraspherical polynomials are also known
     as Gegenbauer polynomials.

     Reference: A&S 22.5.27

     To access this function, load("specfun").

     See also JACOBI_P.



File: maxima.info,  Node: Elliptic Functions,  Next: Limits,  Prev: Orthogonal Polynomials,  Up: Top

Elliptic Functions
******************

* Menu:

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::


File: maxima.info,  Node: Introduction to Elliptic Functions and Integrals,  Next: Definitions for Elliptic Functions,  Up: Top

Introduction to Elliptic Functions and Integrals
================================================

Maxima includes support for Jacobian elliptic functions and for
complete and incomplete elliptic integrals.  This includes symbolic
manipulation of these functions and numerical evaluation as well.
Definitions of these functions and many of their properties can by
found in Abramowitz and Stegun, Chapter 16-17.  As much as possible, we
use the definitions and relationships given there.

   In particular, all elliptic functions and integrals use the parameter
m instead of the modulus k or the modular angle \alpha.  This is one
area where we differ from Abramowitz and Stegun who use the modular
angle for the elliptic functions.  The following relationships are true:
m = k^2 and k = \sin(\alpha)

   The elliptic functions and integrals are primarily intended to
support symbolic computation.  Therefore, most of derivatives of the
functions and integrals are known.  However, if floating-point values
are given, a floating-point result is returned.

   Support for most of the other properties of elliptic functions and
integrals other than derivatives has not yet been written.

   Some examples of elliptic functions:
     (C1) jacobi_sn(u,m);
     (D1)                            JACOBI_SN(u, m)
     (C2) jacobi_sn(u,1);
     (D2)                                TANH(u)
     (C3) jacobi_sn(u,0);
     (D3)                                SIN(u)
     (C4) diff(jacobi_sn(u,m),u);
     (D4)                    JACOBI_CN(u, m) JACOBI_DN(u, m)
     (C5) diff(jacobi_sn(u,m),m);
     (D5) JACOBI_CN(u, m) JACOBI_DN(u, m)
     
           ELLIPTIC_E(ASIN(JACOBI_SN(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m
     
                 2
        JACOBI_CN (u, m) JACOBI_SN(u, m)
      + --------------------------------
                   2 (1 - m)

   Some examples of elliptic integrals:
     (C1) elliptic_f(phi,m);
     (D1)                          ELLIPTIC_F(PHI, m)
     (C2) elliptic_f(phi,0);
     (D2)                                  PHI
     (C3) elliptic_f(phi,1);
                                           PHI   %PI
     (D3)                          LOG(TAN(--- + ---))
                                            2     4
     (C4) elliptic_e(phi,1);
     (D4)                               SIN(PHI)
     (C5) elliptic_e(phi,0);
     (D5)                                  PHI
     (C6) elliptic_kc(1/2);
                                                 1
     (D6)                            ELLIPTIC_KC(-)
                                                 2
     (C7) makegamma(%);
                                             2 1
                                        GAMMA (-)
                                               4
     (D7)                              -----------
                                       4 SQRT(%PI)
     (C8) diff(elliptic_f(phi,m),phi);
                                            1
     (D8)                         ---------------------
                                                2
                                  SQRT(1 - m SIN (PHI))
     (C9) diff(elliptic_f(phi,m),m);
           ELLIPTIC_E(PHI, m) - (1 - m) ELLIPTIC_F(PHI, m)
     (D9) (-----------------------------------------------
                                  m
     
                                 COS(PHI) SIN(PHI)
                             - ---------------------)/(2 (1 - m))
                                             2
                               SQRT(1 - m SIN (PHI))

   Support for elliptic functions and integrals was written by Raymond
Toy.  It is placed under the terms of the General Public License (GPL)
that governs the distribution of Maxima.


File: maxima.info,  Node: Definitions for Elliptic Functions,  Next: Definitions for Elliptic Integrals,  Prev: Introduction to Elliptic Functions and Integrals,  Up: Top

Definitions for Elliptic Functions
==================================

 - Function: JACOBI_SN (u, m)
     The Jacobian elliptic function sn(u,m).

 - Function: JACOBI_CN (u, m)
     The Jacobian elliptic function cn(u,m).

 - Function: JACOBI_DN (u, m)
     The Jacobian elliptic function dn(u,m).

 - Function: JACOBI_NS (u, m)
     The Jacobian elliptic function ns(u,m) = 1/sn(u,m).

 - Function: JACOBI_SC (u, m)
     The Jacobian elliptic function sc(u,m) = sn(u,m)/cn(u,m).

 - Function: JACOBI_SD (u, m)
     The Jacobian elliptic function sd(u,m) = sn(u,m)/dn(u,m).

 - Function: JACOBI_NC (u, m)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 - Function: JACOBI_CS (u, m)
     The Jacobian elliptic function cs(u,m) = cn(u,m)/sn(u,m).

 - Function: JACOBI_CD (u, m)
     The Jacobian elliptic function cd(u,m) = cn(u,m)/dn(u,m).

 - Function: JACOBI_ND (u, m)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 - Function: JACOBI_DS (u, m)
     The Jacobian elliptic function ds(u,m) = dn(u,m)/sn(u,m).

 - Function: JACOBI_DC (u, m)
     The Jacobian elliptic function dc(u,m) = dn(u,m)/cn(u,m).

 - Function: INVERSE_JACOBI_SN (u, m)
     The inverse of the Jacobian elliptic function sn(u,m).

 - Function: INVERSE_JACOBI_CN (u, m)
     The inverse of the Jacobian elliptic function cn(u,m).

 - Function: INVERSE_JACOBI_DN (u, m)
     The inverse of the Jacobian elliptic function dn(u,m).

 - Function: INVERSE_JACOBI_NS (u, m)
     The inverse of the Jacobian elliptic function ns(u,m).

 - Function: INVERSE_JACOBI_SC (u, m)
     The inverse of the Jacobian elliptic function sc(u,m).

 - Function: INVERSE_JACOBI_SD (u, m)
     The inverse of the Jacobian elliptic function sd(u,m).

 - Function: INVERSE_JACOBI_NC (u, m)
     The inverse of the Jacobian elliptic function nc(u,m).

 - Function: INVERSE_JACOBI_CS (u, m)
     The inverse of the Jacobian elliptic function cs(u,m).

 - Function: INVERSE_JACOBI_CD (u, m)
     The inverse of the Jacobian elliptic function cd(u,m).

 - Function: INVERSE_JACOBI_ND (u, m)
     The inverse of the Jacobian elliptic function nc(u,m).

 - Function: INVERSE_JACOBI_DS (u, m)
     The inverse of the Jacobian elliptic function ds(u,m).

 - Function: INVERSE_JACOBI_DC (u, m)
     The inverse of the Jacobian elliptic function dc(u,m).


File: maxima.info,  Node: Definitions for Elliptic Integrals,  Prev: Definitions for Elliptic Functions,  Up: Top

Definitions for Elliptic Integrals
==================================

 - Function: ELLIPTIC_F (phi, m)
     The incomplete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *Note ELLIPTIC_E::, *Note ELLIPTIC_KC::

 - Function: ELLIPTIC_E (phi, m)
     The incomplete elliptic integral of the second kind, defined as
     ELLIPTIC_E(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi) See
     also *Note ELLIPTIC_E::, *Note ELLIPTIC_EC::

 - Function: ELLIPTIC_EU (u, m)
     The incomplete elliptic integral of the second kind, defined as
     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     where tau = sn(u,m)

     This is related to ELLIPTIC_E by ELLIPTIC_EU(u, m) =
     ELLIPTIC_E(asin(sn(u,m)),m) See also *Note ELLIPTIC_E::.

 - Function: ELLIPTIC_PI (n, phi, m)
     The incomplete elliptic integral of the third kind, defined as
     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Only the derivative with respect to phi is known by MAXIMA.

 - Function: ELLIPTIC_KC (m)
     The complete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use MAKEGAMMA to evaluate them.

 - Function: ELLIPTIC_EC (m)
     The complete elliptic integral of the second kind, defined as

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use MAKEGAMMA to evaluate them.


File: maxima.info,  Node: Limits,  Next: Differentiation,  Prev: Elliptic Functions,  Up: Top

Limits
******

* Menu:

* Definitions for Limits::


File: maxima.info,  Node: Definitions for Limits,  Prev: Limits,  Up: Limits

Definitions for Limits
======================

 - Variable: LHOSPITALLIM
     default: [4] - the maximum number of times L'Hospital's rule is
     used in LIMIT.  This prevents infinite looping in cases like
     LIMIT(COT(X)/CSC(X),X,0).


 - Function: LIMIT (exp, var, val, dir)
     finds the limit of exp as the real variable var approaches the
     value val from the direction dir.  Dir may have the value PLUS for
     a limit from above, MINUS for a limit from below, or may be
     omitted (implying a two-sided limit is to be computed).  For the
     method see Wang, P., "Evaluation of Definite Integrals by Symbolic
     Manipulation" - Ph.D. Thesis - MAC TR-92 October 1971.  LIMIT uses
     the following special symbols: INF (positive infinity) and MINF
     (negative infinity).  On output it may also use UND (undefined),
     IND (indefinite but bounded) and INFINITY (complex infinity).
     LHOSPITALLIM[4] is the maximum number of times L'Hospital's rule
     is used in LIMIT.  This prevents infinite looping in cases like
     LIMIT(COT(X)/CSC(X),X,0).  TLIMSWITCH[FALSE] when true will cause
     the limit package to use Taylor series when possible.
     LIMSUBST[FALSE] prevents LIMIT from attempting substitutions on
     unknown forms.  This is to avoid bugs like
     LIMIT(F(N)/F(N+1),N,INF); giving 1.  Setting LIMSUBST to TRUE will
     allow such substitutions.  Since LIMIT is often called upon to
     simplify constant expressions, for example, INF-1, LIMIT may be
     used in such cases with only one argument, e.g. LIMIT(INF-1); Do
     EXAMPLE(LIMIT); for examples.


 - Function: TLIMIT (exp,var,val,dir)
     is just the function LIMIT with TLIMSWITCH set to TRUE.


 - Variable: TLIMSWITCH
     default: [FALSE] - if true will cause the limit package to use
     Taylor series when possible.



File: maxima.info,  Node: Differentiation,  Next: Integration,  Prev: Limits,  Up: Top

Differentiation
***************

* Menu:

* Definitions for Differentiation::


File: maxima.info,  Node: Definitions for Differentiation,  Prev: Differentiation,  Up: Differentiation

Definitions for Differentiation
===============================

 - Function: ANTID (G,X,U(X))
     A routine for evaluating integrals of expressions involving an
     arbitrary unspecified function and its derivatives.  It may be used
     by LOAD(ANTID); , after which, the function ANTIDIFF may be used.
     E.g.  ANTIDIFF(G,X,U(X)); where G is the expression involving U(X)
     (U(X) arbitrary) and its derivatives, whose integral with respect
     to X is desired.  The functions NONZEROANDFREEOF and LINEAR are
     also defined, as well as ANTID.  ANTID is the same as ANTIDIFF
     except that it returns a list of two parts, the first part is the
     integrated part of the expression and the second part of the list
     is the non-integrable remainder.


 - Function: ANTIDIFF -
     See ANTID.


 - property: ATOMGRAD
     - the atomic gradient property of an expression.  May be set by
     GRADEF.


 - Function: ATVALUE (form, list, value)
     enables the user to assign the boundary value value to form at the
     points specified by list.
          (C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2)$
              The form must be a function, f(v1,v2,...), or a derivative,
     DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in which the functional
     arguments explicitly appear (ni is the order of differentiation
     with respect vi).      The list of equations determine the
     "boundary" at which the value is given; list may be a list of
     equations, as above, or a single equation, vi = expr.      The
     symbols @1, @2,... will be used to represent the functional
     variables v1,v2,... when atvalues are displayed.
     PRINTPROPS([f1, f2,...], ATVALUE) will display the atvalues of the
     functions f1,f2,... as specified in previously given uses of the
     ATVALUE function. If the list contains just one element then the
     element can be given without being in a list.  If a first argument
     of ALL is given then atvalues for all functions which have them
     will be displayed.  Do EXAMPLE(ATVALUE); for an example.


 - Function: CARTAN -
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     present implementation is due to F.B. Estabrook and H.D. Wahlquist.
     The program is self-explanatory and can be accessed by doing
     batch("cartan"); which will give a description with examples.


 - Function: DEL (v)
     This is the differential of the variable v.  This commonly occurs
     when DIFF is called without the dependent variable being given.
     Then the differential of the expression is computed.  For example:
          (C1) diff(x);
          
          (D1) 				    DEL(x)
          (C2) diff(x^2);
          
          (D2) 				  2 x DEL(x)
          (C3) diff(sin(x^2));
          
          				       2
          (D3) 			      2 x COS(x ) DEL(x)


 - Function: DELTA (t)
     This is the Dirac Delta function.  Currently only LAPLACE knows
     about the DELTA function:
          (C1) LAPLACE(DELTA(T-A)*SIN(B*T),T,S);
          Is A positive, negative or zero?
          POS;
                                                    - A S
          (D1)                           SIN(A B) %E

 - Variable: DEPENDENCIES
     default: [] - the list of atoms which have functional dependencies
     (set up by the DEPENDS or GRADEF functions).  The command
     DEPENDENCIES has been replaced by the DEPENDS command.  Do
     DESCRIBE(DEPENDS);


 - Function: DEPENDS (funlist1,varlist1,funlist2,varlist2,...)
     declares functional dependencies for variables to be used by DIFF.

          DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T)
     informs DIFF that F and G depend on X and Y, that R and S depend
     on U,V, and W, and that U depends on T.  The arguments to DEPENDS
     are evaluated.  The variables in each funlist are declared to
     depend on all the variables in the next varlist.  A funlist can
     contain the name of an atomic variable or array.  In the latter
     case, it is assumed that all the elements of the array depend on
     all the variables in the succeeding varlist.  Initially, DIFF(F,X)
     is 0; executing DEPENDS(F,X) causes future differentiations of F
     with respect to X to give dF/dX or Y (if DERIVABBREV:TRUE).
          (C1) DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T);
          (D1)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
          (C2) DEPENDENCIES;
          (D2)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
          (C3) DIFF(R.S,U);
                                         dR           dS
          (D3)                           -- . S + R . --
                                         dU           dU
     Since MACSYMA knows the chain rule for symbolic derivatives, it
     takes advantage of the given dependencies as follows:
          (C4) DIFF(R.S,T);
                                     dR dU             dS dU
          (D4)                      (-- --) . S + R . (-- --)
                                     dU dT             dU dT
          If we set
          (C5) DERIVABBREV:TRUE;
          (D5)                                 TRUE
          then re-executing the command C4, we obtain
          (C6) ''C4;
          (D6)                      (R  U ) . S + R . (S  U )
                                      U  T              U  T
     To eliminate a previously declared dependency, the REMOVE command
     can be used.  For example, to say that R no longer depends on U as
     declared in C1, the user can type
          REMOVE(R,DEPENDENCY)
     This will eliminate all dependencies that may have been declared
     for R.
          (C7) REMOVE(R,DEPENDENCY);
          (D7)                                 DONE
          (C8) ''C4;
          (D8)                             R . (S  U )
                                            U    T
     CAVEAT: DIFF is the only MACSYMA command which uses DEPENDENCIES
     information.  The arguments to INTEGRATE, LAPLACE, etc. must be
     given their dependencies explicitly in the command, e.g.,
     INTEGRATE(F(X),X).


 - Variable: DERIVABBREV
     default: [FALSE] if TRUE will cause derivatives to display as
     subscripts.


 - Function: DERIVDEGREE (exp, dv, iv)
     finds the highest degree of the derivative of the dependent
     variable dv with respect to the independent variable iv occuring
     in exp.
          (C1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X**2$
          (C2) DERIVDEGREE(%,Y,X);
          (D2)                           2

 - Function: DERIVLIST (var1,...,vark)
     causes only differentiations with respect to the indicated
     variables, within the EV command.


 - Variable: DERIVSUBST
     default: [FALSE] - controls non-syntactic substitutions such as
          SUBST(X,'DIFF(Y,T),'DIFF(Y,T,2));
     If DERIVSUBST is set to true, this gives 'DIFF(X,T).


 - Function: DIFF (exp, v1, n1, v2, n2, ...)
     DIFF differentiates exp with respect to each vi, ni times.  If
     just the first derivative with respect to one variable is desired
     then the form DIFF(exp,v) may be used.  If the noun form of the
     function is required (as, for example, when writing a differential
     equation), 'DIFF should be used and this will display in a two
     dimensional format.  DERIVABBREV[FALSE] if TRUE will cause
     derivatives to display as subscripts.  DIFF(exp) gives the "total
     differential", that is, the sum of the derivatives of exp with
     respect to each of its variables times the function DEL of the
     variable.  No further simplification of DEL is offered.
          (C1) DIFF(EXP(F(X)),X,2);
                                       2
                                F(X)  d             F(X)  d         2
          (D1)                %E     (--- F(X)) + %E     (-- (F(X)))
                                        2                 dX
                                      dX
          (C2) DERIVABBREV:TRUE$
          (C3) 'INTEGRATE(F(X,Y),Y,G(X),H(X));
                                          H(X)
                                         /
                                         [
          (D3)                           I     F(X, Y) dY
                                         ]
                                         /
                                          G(X)
          (C4) DIFF(%,X);
                      H(X)
                     /
                     [
          (D4)       I     F(X, Y)  dY + F(X, H(X)) H(X)  - F(X, G(X)) G(X)
                     ]            X                     X                  X
                     /
                      G(X)
     For the tensor package, the following modifications have been
     incorporated: 1) the derivatives of any indexed objects in exp
     will have the variables vi appended as additional arguments.  Then
     all the derivative indices will be sorted.  2) the vi may be
     integers from 1 up to the value of the variable DIMENSION[default
     value: 4].  This will cause the differentiation to be carried out
     wrt the vith member of the list COORDINATES which should be set to
     a list of the names of the coordinates, e.g., [x,y,z,t]. If
     COORDINATES is bound to an atomic variable, then that variable
     subscripted by vi will be used for the variable of
     differentiation.  This permits an array of coordinate names or
     subscripted names like X[1], X[2],... to be used.  If COORDINATES
     has not been assigned a value, then the variables will be treated
     as in 1) above.


 - special symbol: DIFF
     [flag] for ev causes all differentiations indicated in exp to be
     performed.

 - Function: DSCALAR (function)
     applies the scalar d'Alembertian to the scalar function.
          (C41) DEPENDENCIES(FIELD(R));
          (D41)                           [FIELD(R)]
          (C42) DSCALAR(FIELD);
          (D43)
              -M
            %E  ((FIELD  N - FIELD  M + 2 FIELD   ) R + 4 FIELD )
                       R  R       R  R         R R             R
          
          - -----------------------------------------------------
                                       2 R

 - Function: EXPRESS (expression)
     The result uses the noun form of any derivatives arising from
     expansion of the vector differential operators.  To force
     evaluation of these derivatives, the built-in EV function can be
     used together with the DIFF evflag, after using the built-in
     DEPENDS function to establish any new implicit dependencies.


 - Function: GENDIFF
     Sometimes DIFF(E,X,N) can be reduced even though N is symbolic.
          batch("gendif")$
     and you can try, for example,

          DIFF(%E^(A*X),X,Q)
     by using GENDIFF rather than DIFF.  Unevaluable items come out
     quoted.  Some items are in terms of "GENFACT", which see.


 - Function: GRADEF (f(x1, ..., xn), g1, ..., gn)
     defines the derivatives of the function f with respect to its n
     arguments.  That is, df/dxi = gi, etc.  If fewer than n gradients,
     say i, are given, then they refer to the first i arguments of f.
     The xi are merely dummy variables as in function definition
     headers and are used to indicate the ith argument of f.  All
     arguments to GRADEF except the first are evaluated so that if g is
     a defined function then it is invoked and the result is used.
     Gradients are needed when, for example, a function is not known
     explicitly but its first derivatives are and it is desired to
     obtain higher order derivatives.  GRADEF may also be used to
     redefine the derivatives of MACSYMA's predefined functions (e.g.
     GRADEF(SIN(X),SQRT(1-SIN(X)**2)) ).  It is not permissible to use
     GRADEF on subscripted functions.  GRADEFS is a list of the
     functions which have been given gradients by use of the GRADEF
     command (i.e. GRADEF(f(x1, ..., xn), g1, ..., gn)).
     PRINTPROPS([f1,f2,...],GRADEF) may be used to display the gradefs
     of the functions f1,f2,..  GRADEF(a,v,exp) may be used to state
     that the derivative of the atomic variable a with respect to v is
     exp.  This automatically does a DEPENDS(a,v).
     PRINTPROPS([a1,a2,...],ATOMGRAD) may be used to display the atomic
     gradient properties of a1,a2,...


 - Variable: GRADEFS
     default: [] - a list of the functions which have been given
     gradients by use of the GRADEF command (i.e. GRADEF(f(x1, ..., xn),
     g1, ..., gn).)


 - Function: LAPLACE (exp, ovar, lvar)
     takes the Laplace transform of exp with respect to the variable
     ovar and transform parameter lvar.  Exp may only involve the
     functions EXP, LOG, SIN, COS, SINH, COSH, and ERF.  It may also be
     a linear, constant coefficient differential equation in which case
     ATVALUE of the dependent variable will be used.  These may be
     supplied either before or after the transform is taken.  Since the
     initial conditions must be specified at zero, if one has boundary
     conditions imposed elsewhere he can impose these on the general
     solution and eliminate the constants by solving the general
     solution for them and substituting their values back. Exp may also
     involve convolution integrals.  Functional relationships must be
     explicitly represented in order for LAPLACE to work properly. That
     is, if F depends on X and Y it must be written as F(X,Y) wherever
     F occurs as in LAPLACE('DIFF(F(X,Y),X),X,S).  LAPLACE is not
     affected by DEPENDENCIES set up with the DEPENDS command.
          (C1) LAPLACE(%E**(2*T+A)*SIN(T)*T,T,S);
                               A
                           2 %E  (S - 2)
          (D1)            ---------------
                                  2     2
                          ((S - 2)  + 1)

 - Function: UNDIFF (exp)
     returns an expression equivalent to exp but with all derivatives
     of indexed objects replaced by the noun form of the DIFF function
     with arguments which would yield that indexed object if the
     differentiation were carried out.  This is useful when it is
     desired to replace a differentiated indexed object with some
     function definition and then carry out the differentiation by
     saying EV(...,DIFF).



File: maxima.info,  Node: Integration,  Next: Equations,  Prev: Differentiation,  Up: Top

Integration
***********

* Menu:

* Introduction to Integration::
* Definitions for Integration::


File: maxima.info,  Node: Introduction to Integration,  Next: Definitions for Integration,  Prev: Integration,  Up: Integration

Introduction to Integration
===========================

MACSYMA has several routines for handling integration.  The INTEGRATE
command makes use of most of them.  There is also the ANTID package,
which handles an unspecified function (and its derivatives, of course).
For numerical uses, there is the ROMBERG function.  There is also an
adaptave integrator which uses the Newton-Cotes 8 panel quadrature
rule, called QUANC8.  Hypergeometric Functions are being worked on, do
DESCRIBE(SPECINT); for details.  Generally speaking, MACSYMA only
handles integrals which are integrable in terms of the "elementary
functions" (rational functions, trigonometrics, logs, exponentials,
radicals, etc.) and a few extensions (error function, dilogarithm).  It
does not handle integrals in terms of unknown functions such as g(x)
and h(x).

