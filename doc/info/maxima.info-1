This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introduction to Maxima,  Prev: (dir),  Up: (dir)

Maxima Manual
*************

Maxima is a computer algebra system, implemented in Lisp.

   Maxima is derived from the Macsyma system, developed at MIT in the
years 1968 through 1982 as part of Project MAC.  MIT turned over a copy
of the Macsyma source code to the Department of Energy in 1982; that
version is now known as DOE Macsyma.  A copy of DOE Macsyma was
maintained by Professor William F. Schelter of the University of Texas
from 1982 until his death in 2001.  In 1998, Schelter obtained
permission from the Department of Energy to release the DOE Macsyma
source code under the GNU Public License, and in 2000 he initiated the
Maxima project at SourceForge to maintain and develop DOE Macsyma, now
called Maxima.

* Menu:

Maxima infrastructure

* Introduction to Maxima::      Sample Maxima sessions.
* Bug Detection and Reporting:: Finding and reporting bugs in Maxima.
* Help::                        Asking for help from within a Maxima session.
* Command Line::                Maxima command line syntax.
* Operators::                   Operators used in Maxima expressions.
* Expressions::                 Expressions in Maxima.
* Simplification::              Simplifying expressions.
* Plotting::                    2D and 3D graphical output.
* Input and Output::            File input and output.
* Floating Point::              Low level numerical routines.
* Contexts::                    Sets of assumed facts.

Support for specific areas of mathematics

* Polynomials::                 Standard forms for polynomials, and
                                functions operating on them.
* Constants::                   Numerical constants.
* Logarithms::                  Manipulation of expressions involving
                                logarithms.
* Trigonometric::               Manipulating expressions with trig and
                                inverse trig functions.
* Special Functions::           Special functions
* Orthogonal Polynomials::      Orthogonal Polynomials and Special functions
* Elliptic Functions::          Elliptic Functions and Integrals
* Limits::                      Limits of expressions.
* Differentiation::             Differential calculus.
* Integration::                 Integral calculus.
* Equations::                   Defining and solving equations.
* Differential Equations::      Defining and solving differential equations.
* Numerical::                   Numerical integration, Fourier
                                transforms, etc.
* Statistics::                  Statistical functions.
* Arrays and Tables::           Creating and working with arrays.
* Matrices and Linear Algebra:: Matrix operations.
* Affine::
* itensor::                     Indicial Tensor Manipulation.
* ctensor::                     Component Tensor Manipulation.
* atensor::                     Algebraic Tensor Manipulation.
* Series::                      Taylor and power series.
* Number Theory::               Number theory.
* Symmetries::
* Groups::                      Abstract algebra.

Advanced facilities and programming

* Runtime Environment::         Customization of the Maxima environment.
* Miscellaneous Options::       Options with a global effect on Maxima.
* Rules and Patterns::          User defined pattern matching and
                                simplification rules.
* Lists::                       Manipulation of lists.
* Sets::                        Manipulation of sets.
* Function Definition::         Defining functions.
* Program Flow::                Defining Maxima programs.
* Debugging::                   Debugging Maxima programs.

Index

* Function and Variable Index:: Index.

 --- The Detailed Node Listing ---

Introduction

* Introduction to Maxima::

Help

* Introduction to Help::
* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::

Command Line

* Introduction to Command Line::
* Definitions for Command Line::

Operators

* nary::
* nofix::
* operator::
* postfix::
* prefix::
* Definitions for Operators::

Expressions

* Introduction to Expressions::
* Assignment::
* Complex::
* Inequality::
* Syntax::
* Definitions for Expressions::

Simplification

* Definitions for Simplification::

Plotting

* Definitions for Plotting::

Input and Output

* Introduction to Input and Output::
* Files::
* Definitions for Input and Output::

Floating Point

* Definitions for Floating Point::

Contexts

* Definitions for Contexts::

Polynomials

* Introduction to Polynomials::
* Definitions for Polynomials::

Constants

* Definitions for Constants::

Logarithms

* Definitions for Logarithms::

Trigonometric

* Introduction to Trigonometric::
* Definitions for Trigonometric::

Special Functions

* Introduction to Special Functions::
* specint::
* Definitions for Special Functions::

Orthogonal Polynomials

* Introduction to Orthogonal Polynomials::
* Definitions for Orthogonal Polynomials::

Elliptic Functions

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::

Limits

* Definitions for Limits::

Differentiation

* Definitions for Differentiation::

Integration

* Introduction to Integration::
* Definitions for Integration::

Equations

* Definitions for Equations::

Differential Equations

* Definitions for Differential Equations::

Numerical

* Introduction to Numerical::
* Fourier packages::
* Definitions for Numerical::
* Definitions for Fourier Series::

Statistics

* Definitions for Statistics::

Arrays and Tables

* Definitions for Arrays and Tables::

Matrices and Linear Algebra

* Introduction to Matrices and Linear Algebra::
* Dot::
* Vectors::
* eigen::
* Definitions for Matrices and Linear Algebra::

Affine

* Definitions for Affine::

itensor

* Introduction to itensor::
* Definitions for itensor::

ctensor

* Introduction to ctensor::
* Definitions for ctensor::

atensor

* Introduction to atensor::
* Definitions for atensor::

Series

* Introduction to Series::
* Definitions for Series::

Number Theory

* Definitions for Number Theory::

Symmetries

* Definitions for Symmetries::

Groups

* Definitions for Groups::

Runtime Environment

* Introduction for Runtime Environment::
* Interrupts::
* Definitions for Runtime Environment::

Miscellaneous Options

* Introduction to Miscellaneous Options::
* Share::
* Definitions for Miscellaneous Options::

Rules and Patterns

* Introduction to Rules and Patterns::
* Definitions for Rules and Patterns::

Lists

* Introduction to Lists::
* Definitions for Lists::

Sets

* Introduction to Sets::
* Definitions for Sets::

Function Definition

* Introduction to Function Definition::
* Function::
* Macros::
* Definitions for Function Definition::

Program Flow

* Introduction to Program Flow::
* Definitions for Program Flow::

Debugging

* Definitions for Debugging::


File: maxima.info,  Node: Introduction to Maxima,  Next: Bug Detection and Reporting,  Prev: Top,  Up: Top

1 Introduction to Maxima
************************

Start Maxima with the command "maxima".  Maxima will display version
information and a prompt.  End each Maxima command with a semicolon.
End the session with the command "quit();".  Here's a sample session:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima can search the info pages.  Use the `describe' command to show
all the commands and variables containing a string, and optionally their
documentation. The question mark `?' is an abbreviation for `describe':

     (%i1) ? integ

      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 6 5

     Info from file /usr/local/info/maxima.info:
      - Function: integerp (<expr>)
          Returns `true' if <expr> is an integer, otherwise `false'.


      - Function: askinteger (expr, integer)
      - Function: askinteger (expr)
      - Function: askinteger (expr, even)
      - Function: askinteger (expr, odd)
          `askinteger (expr, integer)' attempts to determine from the
          `assume' database whether `expr' is an integer.  `askinteger' will
          ask the user if it cannot tell otherwise, and attempt to install
          the information in the database if possible.  `askinteger (expr)'
          is equivalent to `askinteger (expr, integer)'.

          `askinteger (expr, even)' and `askinteger (expr, odd)' likewise
          attempt to determine if `expr' is an even integer or odd integer,
          respectively.

     (%o1)                         false

   To use a result in later calculations, you can assign it to a
variable or refer to it by its automatically supplied label.  In
addition, `%' refers to the most recent calculated result:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima knows about complex numbers and numerical constants:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima can do differential and integral calculus:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima can solve linear systems and cubic equations:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima can solve nonlinear sets of equations.  Note that if you don't
want a result printed, you can finish your command with `$' instead of
`;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima can generate plots of one or more functions:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Bug Detection and Reporting,  Next: Help,  Prev: Introduction to Maxima,  Up: Top

2 Bug Detection and Reporting
*****************************

* Menu:

* Introduction to Bug Detection and Reporting::
* Definitions for Bug Detection and Reporting::


File: maxima.info,  Node: Introduction to Bug Detection and Reporting,  Next: Definitions for Bug Detection and Reporting,  Up: Bug Detection and Reporting

2.1 Introduction to Bug Detection and Reporting
===============================================

Like all large programs, Maxima contains both known and unknown bugs.
This chapter describes the built-in facilities for running the Maxima
test suite as well as reporting new bugs.


File: maxima.info,  Node: Definitions for Bug Detection and Reporting,  Prev: Introduction to Bug Detection and Reporting,  Up: Bug Detection and Reporting

2.2 Definitions for Bug Detection and Reporting
===============================================

 -- Function: run_testsuite ()
 -- Function: run_testsuite (boolean)
 -- Function: run_testsuite (boolean, boolean)
     Run the Maxima test suite. Tests producing the desired answer are
     considered "passes," as are tests that do not produce the desired
     answer, but are marked as known bugs.

     `run_testsuite ()' displays only tests that do not pass.

     `run_testsuite (true)' displays tests that are marked as known
     bugs, as well as failures.

     `run_testsuite (true, true)' displays all tests.

     `run_testsuite' changes the Maxima environment.  Typically a test
     script executes `kill' to establish a known environment (namely
     one without user-defined functions and variables) and then defines
     functions and variables appropriate to the test.

     `run_testsuite' returns `done'.

 -- Function: bug_report ()
     Prints out Maxima and Lisp version numbers, and gives a link to
     the Maxima project bug report web page.  The version information
     is the same as reported by `build_info'.

     When a bug is reported, it is helpful to copy the Maxima and Lisp
     version information into the bug report.

     `bug_report' returns an empty string `""'.

 -- Function: build_info ()
     Prints out a summary of the parameters of the Maxima build.

     `build_info' returns an empty string `""'.


File: maxima.info,  Node: Help,  Next: Command Line,  Prev: Bug Detection and Reporting,  Up: Top

3 Help
******

* Menu:

* Introduction to Help::
* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::


File: maxima.info,  Node: Introduction to Help,  Next: Lisp and Maxima,  Prev: Help,  Up: Help

3.1 Introduction to Help
========================

The primary on-line help function is `describe', which is typically
invoked by the question mark `?' at the interactive prompt.  `? foo'
(with a space between `?' and `foo') is equivalent to `describe
("foo")', where `foo' is the name or part of the name of a function or
topic; `describe' then finds all documented items which contain the
string `foo' in their titles.  If there is more than one such item,
Maxima asks the user to select an item or items to display.

     (%i1) ? integ
      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 7 8

     Info from file /use/local/maxima/doc/info/maxima.info:
      - Function: integrate (expr, var)
      - Function: integrate (expr, var, a, b)
          Attempts to symbolically compute the integral of `expr' with
          respect to `var'.  `integrate (expr, var)' is an indefinite
          integral, while `integrate (expr, var, a, b)' is a definite
          integral, [...]

   In this example, items 7 and 8 were selected.  All or none of the
items could have been selected by entering `all' or `none', which can
be abbreviated `a' or `n', respectively.


File: maxima.info,  Node: Lisp and Maxima,  Next: Garbage Collection,  Prev: Introduction to Help,  Up: Help

3.2 Lisp and Maxima
===================

Maxima is written in Lisp, and it is easy to access Lisp functions and
variables from Maxima and vice versa.  Lisp and Maxima symbols are
distinguished by a naming convention.  A Lisp symbol which begins with
a dollar sign `$' corresponds to a Maxima symbol without the dollar
sign.  A Maxima symbol which begins with a question mark `?'
corresponds to a Lisp symbol without the question mark.  For example,
the Maxima symbol `foo' corresponds to the Lisp symbol `$foo', while
the Maxima symbol `?foo' corresponds to the Lisp symbol `foo', Note
that `?foo' is written without a space between `?' and `foo'; otherwise
it might be mistaken for `describe ("foo")'.

   Hyphen `-', asterisk `*', or other special characters in Lisp symbols
must be escaped by backslash `\' where they appear in Maxima code.  For
example, the Lisp identifier `*foo-bar*' is written `?\*foo\-bar\*' in
Maxima.

   Lisp code may be executed from within a Maxima session.  A single
line of Lisp (containing one or more forms) may be executed by the
special command `:lisp'. For example,

     (%i1) :lisp (foo $x $y)

calls the Lisp function `foo' with Maxima variables `x' and `y' as
arguments.  The `:lisp' construct can appear at the interactive prompt
or in a file processed by `batch' or `demo', but not in a file
processed by `load', `batchload', `translate_file', or `compile_file'.

   The function `to_lisp()' opens an interactive Lisp session.
Entering `(to-maxima)' closes the Lisp session and returns to Maxima.

   Lisp functions and variables which are to be visible in Maxima as
functions and variables with ordinary names (no special punctuation)
must have Lisp names beginning with the dollar sign `$'.

   Maxima is case-sensitive, distinguishing between lowercase and
uppercase letters in identifiers, while Lisp is not.  There are some
rules governing the translation of names between Lisp and Maxima.

  1. A Lisp identifier not enclosed in vertical bars corresponds to a
     Maxima identifier in lowercase.  Whether the Lisp identifier is
     uppercase, lowercase, or mixed case, is ignored.  E.g., Lisp
     `$foo', `$FOO', and `$Foo' all correspond to Maxima `foo'.

  2. A Lisp identifier which is all uppercase or all lowercase and
     enclosed in vertical bars corresponds to a Maxima identifier with
     case reversed.  That is, uppercase is changed to lowercase and
     lowercase to uppercase.  E.g., Lisp `|$FOO|' and `|$foo|'
     correspond to Maxima `foo' and `FOO', respectively.

  3. A Lisp identifier which is mixed uppercase and lowercase and
     enclosed in vertical bars corresponds to a Maxima identifier with
     the same case.  E.g., Lisp `|$Foo|' corresponds to Maxima `Foo'.

   The `#$' Lisp macro allows the use of Maxima expressions in Lisp
code.  `#$<expr>$' expands to a Lisp expression equivalent to the
Maxima expression <expr>.

     (msetq $foo #$[x, y]$)

This has the same effect as entering

     (%i1) foo: [x, y];

The Lisp function `displa' prints an expression in Maxima format.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Functions defined in Maxima are not ordinary Lisp functions.  The
Lisp function `mfuncall' calls a Maxima function.  For example:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Some Lisp functions are shadowed in the Maxima package, namely the
following.

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', and `gcd'.


File: maxima.info,  Node: Garbage Collection,  Next: Documentation,  Prev: Lisp and Maxima,  Up: Help

3.3 Garbage Collection
======================

Symbolic computation tends to create a good deal of garbage, and
effective handling of this can be crucial to successful completion of
some programs.

   Under GCL, on UNIX systems where the mprotect system call is
available (including SUN OS 4.0 and some variants of BSD) a stratified
garbage collection is available.   This limits the collection to pages
which have been recently written to.    See the GCL documentation under
ALLOCATE and GBC.   At the Lisp level doing (setq si::*notify-gbc* t)
will help you determine which areas might need more space.


File: maxima.info,  Node: Documentation,  Next: Definitions for Help,  Prev: Garbage Collection,  Up: Help

3.4 Documentation
=================

The Maxima on-line user's manual can be viewed in different forms.
From the Maxima interactive prompt, the user's manual is viewed as
plain text by the `?' command (i.e., the `describe' function).  The
user's manual is viewed as `info' hypertext by the `info' viewer program
and as a web page by any ordinary web browser.

   `example' displays examples for many Maxima functions.  For example,

     (%i1) example (integrate);

   yields

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   and additional output.


File: maxima.info,  Node: Definitions for Help,  Prev: Documentation,  Up: Help

3.5 Definitions for Help
========================

 -- Function: demo (<filename>)
     Evaluates Maxima expressions in <filename> and displays the
     results.  `demo' pauses after evaluating each expression and
     continues after the user enters a carriage return.  (If running in
     Xmaxima, `demo' may need to see a semicolon `;' followed by a
     carriage return.)

     `demo' searches the list of directories `file_search_demo' to find
     `filename'.  If the file has the suffix `dem', the suffix may be
     omitted.  See also `file_search'.

     `demo' evaluates its argument.  `demo' returns the name of the
     demonstration file.

     Example:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)


 -- Function: describe (<string>)
     Finds all documented items which contain <string> in their titles.
     If there is more than one such item, Maxima asks the user to select
     an item or items to display.  At the interactive prompt, `? foo'
     (with a space between `?' and `foo') is equivalent to `describe
     ("foo")'.

     `describe ("")' yields a list of all topics documented in the
     on-line manual.

     `describe' quotes its argument. `describe' always returns `false'.

     Example:

          (%i1) ? integ
           0: (maxima.info)Introduction to Elliptic Functions and Integrals.
           1: Definitions for Elliptic Integrals.
           2: Integration.
           3: Introduction to Integration.
           4: Definitions for Integration.
           5: askinteger :Definitions for Simplification.
           6: integerp :Definitions for Miscellaneous Options.
           7: integrate :Definitions for Integration.
           8: integrate_use_rootsof :Definitions for Integration.
           9: integration_constant_counter :Definitions for Integration.
          Enter space-separated numbers, `all' or `none': 7 8

          Info from file /use/local/maxima/doc/info/maxima.info:
           - Function: integrate (expr, var)
           - Function: integrate (expr, var, a, b)
               Attempts to symbolically compute the integral of `expr' with
               respect to `var'.  `integrate (expr, var)' is an indefinite
               integral, while `integrate (expr, var, a, b)' is a definite
               integral, [...]

     In this example, items 7 and 8 were selected.  All or none of the
     items could have been selected by entering `all' or `none', which
     can be abbreviated `a' or `n', respectively.

     *note Introduction to Help::


 -- Function: example (<topic>)
 -- Function: example ()
     `example (<topic>)' displays some examples of <topic>, which is a
     symbol (not a string).  Most topics are function names.  `example
     ()' returns the list of all recognized topics.

     The name of the file containing the examples is given by the
     global variable `manual_demo', which defaults to `"manual.demo"'.

     `example' quotes its argument.  `example' returns `done' unless
     there is an error or there is no argument, in which case `example'
     returns the list of all recognized topics.

     Examples:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Command Line,  Next: Operators,  Prev: Help,  Up: Top

4 Command Line
**************

* Menu:

* Introduction to Command Line::
* Definitions for Command Line::


File: maxima.info,  Node: Introduction to Command Line,  Next: Definitions for Command Line,  Prev: Command Line,  Up: Command Line

4.1 Introduction to Command Line
================================

 -- Operator: "'"
     The single quote operator `'' prevents evaluation.

     Applied to a symbol, the single quote prevents evaluation of the
     symbol.

     Applied to a function call, the single quote prevents evaluation
     of the function call, although the arguments of the function are
     still evaluated (if evaluation is not otherwise prevented).  The
     result is the noun form of the function call.

     Applied to a parenthesized expression, the single quote prevents
     evaluation of all symbols and function calls in the expression.
     E.g., `'(f(x))' means do not evaluate the expression `f(x)'.
     `'f(x)' (with the single quote applied to `f' instead of `f(x)')
     means return the noun form of `f' applied to `[x]'.

     The single quote does not prevent simplification.

     When the global flag `noundisp' is `true', nouns display with a
     single quote.  This switch is always `true' when displaying
     function definitions.

     See also the quote-quote operator `''' and `nouns'.

     Examples:

     Applied to a symbol, the single quote prevents evaluation of the
     symbol.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Applied to a function call, the single quote prevents evaluation
     of the function call.  The result is the noun form of the function
     call.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Applied to a parenthesized expression, the single quote prevents
     evaluation of all symbols and function calls in the expression.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     The single quote does not prevent simplification.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operator: "''"
     The `''' (double single quotes) operator causes an extra
     evaluation to occur.  E.g., `''%i4' will re-evaluate input line
     `%i4'.  `''(f(x))' means evaluate the expression `f(x)' an extra
     time.  `''f(x)' (with the double single quotes applied to `f'
     instead of `f(x)') means return the verb form of `f' applied to
     `[x]'.



File: maxima.info,  Node: Definitions for Command Line,  Prev: Introduction to Command Line,  Up: Command Line

4.2 Definitions for Command Line
================================

 -- Function: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provides an alternate name for a (user or system) function,
     variable, array, etc.  Any even number of arguments may be used.


 -- Option variable: debugmode
     Default value: `false'

     When a Maxima error occurs, Maxima will start the debugger if
     `debugmode' is `true'.  The user may enter commands to examine the
     call stack, set breakpoints, step through Maxima code, and so on.
     See `debugging' for a list of debugger commands.

     Enabling `debugmode' will not catch Lisp errors.


 -- Function: ev (<expr>, <arg_1>, ..., <arg_n>)
     Evaluates the expression <expr> in the environment specified by
     the arguments <arg_1>, ..., <arg_n>.  The arguments are switches
     (Boolean flags), assignments, equations, and functions.  `ev'
     returns the result (another expression) of the evaluation.

     The evaluation is carried out in steps, as follows.

       1. First the environment is set up by scanning the arguments
          which may be any or all of the following.

             * `simp' causes <expr> to be simplified regardless of the
               setting of the switch `simp' which inhibits
               simplification if `false'.

             * `noeval' supresses the evaluation phase of `ev' (see
               step (4) below).  This is useful in conjunction with the
               other switches and in causing <expr> to be resimplified
               without being reevaluated.

             * `nouns' causes the evaluation of noun forms (typically
               unevaluated functions such as `'integrate' or `'diff')
               in <expr>.

             * `expand' causes expansion.

             * `expand (m, n)' causes expansion, setting the values of
               `maxposex' and `maxnegex' to m and n respectively.

             * `detout' causes any matrix inverses computed in <expr>
               to have their determinant kept outside of the inverse
               rather than dividing through each element.

             * `diff' causes all differentiations indicated in <expr>
               to be performed.

             * `derivlist (x, y, z, ...)' causes only differentiations
               with respect to the indicated variables.

             * `float' causes non-integral rational numbers to be
               converted to floating point.

             * `numer' causes some mathematical functions (including
               exponentiation) with numerical arguments to be evaluated
               in floating point.  It causes variables in <expr> which
               have been given numervals to be replaced by their
               values.  It also sets the `float' switch on.

             * `pred' causes predicates (expressions which evaluate to
               `true' or `false') to be evaluated.

             * `eval' causes an extra post-evaluation of <expr> to
               occur. (See step (5) below.)

             * `A' where `A' is an atom declared to be an evaluation
               flag (see `evflag') causes `A' to be bound to `true'
               during the evaluation of <expr>.

             * `V: expression' (or alternately `V=expression') causes
               `V' to be bound to the value of `expression' during the
               evaluation of <expr>.  Note that if `V' is a Maxima
               option, then `expression' is used for its value during
               the evaluation of <expr>.  If more than one argument to
               `ev' is of this type then the binding is done in
               parallel.  If `V' is a non-atomic expression then a
               substitution rather than a binding is performed.

             * `F' where `F', a function name, has been declared to be
               an evaluation function (see `evfun') causes `F' to be
               applied to <expr>.

             * Any other function names (e.g., `sum') cause evaluation
               of occurrences of those names in <expr> as though they
               were verbs.

             * In addition a function occurring in <expr> (say `F(x)')
               may be defined locally for the purpose of this
               evaluation of <expr> by giving `F(x) := expression' as
               an argument to `ev'.

             * If an atom not mentioned above or a subscripted variable
               or subscripted expression was given as an argument, it
               is evaluated and if the result is an equation or
               assignment then the indicated binding or substitution is
               performed.  If the result is a list then the members of
               the list are treated as if they were additional arguments
               given to `ev'. This permits a list of equations to be
               given (e.g. `[X=1, Y=A**2]') or a list of names of
               equations (e.g., `[%t1, %t2]' where `%t1' and `%t2' are
               equations) such as that returned by `solve'.

          The arguments of `ev' may be given in any order with the
          exception of substitution equations which are handled in
          sequence, left to right, and evaluation functions which are
          composed, e.g., `ev (<expr>, ratsimp, realpart)' is handled
          as `realpart (ratsimp (<expr>))'.

          The `simp', `numer', `float', and `pred' switches may also be
          set locally in a block, or globally in Maxima so that they
          will remain in effect until being reset.

          If <expr> is a canonical rational expression (CRE), then the
          expression returned by `ev' is also a CRE, provided the
          `numer' and `float' switches are not both `true'.

       2. During step (1), a list is made of the non-subscripted
          variables appearing on the left side of equations in the
          arguments or in the value of some arguments if the value is
          an equation.  The variables (subscripted variables which do
          not have associated array functions as well as
          non-subscripted variables) in the expression <expr> are
          replaced by their global values, except for those appearing
          in this list.  Usually, <expr> is just a label or `%' (as in
          `%i2' in the example below), so this step simply retrieves
          the expression named by the label, so that `ev' may work on
          it.

       3. If any substitutions are indicated by the arguments, they are
          carried out now.

       4. The resulting expression is then re-evaluated (unless one of
          the arguments was `noeval') and simplified according to the
          arguments.  Note that any function calls in <expr> will be
          carried out after the variables in it are evaluated and that
          `ev(F(x))' thus may behave like `F(ev(x))'.

       5. If one of the arguments was `eval', steps (3) and (4) are
          repeated.

     Examples

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     An alternate top level syntax has been provided for `ev', whereby
     one may just type in its arguments, without the `ev()'.  That is,
     one may write simply

          <expr>, <arg_1>, ..., <arg_n>

     This is not permitted as part of another expression, e.g., in
     functions, blocks, etc.

     Notice the parallel binding process in the following example.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Property: evflag
     Some Boolean flags have the `evflag' property.  `ev' treats such
     flags specially.  A flag with the `evflag' property will be bound
     to `true' during the execution of `ev' if it is mentioned in the
     call to `ev'.  For example, `demoivre' and `ratfac' are bound to
     `true' during the call `ev (%, demoivre, ratfac)'.

     The flags which have the `evflag' property are: `algebraic',
     `cauchysum', `demoivre', `dotscrules', `%emode', `%enumer',
     `exponentialize', `exptisolate', `factorflag', `float',
     `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', and `trigexpand'.

     The construct `:lisp (putprop '|$foo| t 'evflag)' gives the
     `evflag' property to the variable `foo', so `foo' is bound to
     `true' during the call `ev (%, foo)'.  Equivalently, `ev (%,
     foo:true)' has the same effect.


 -- Property: evfun
     Some functions have the `evfun' property.  `ev' treats such
     functions specially.  A function with the `evfun' property will be
     applied during the execution of `ev' if it is mentioned in the
     call to `ev'.  For example, `ratsimp' and `radcan' will be applied
     during the call `ev (%, ratsimp, radcan)'.

     The functions which have the `evfun' property are: `bfloat',
     `factor', `fullratsimp', `logcontract', `polarform', `radcan',
     `ratexpand', `ratsimp', `rectform', `rootscontract', `trigexpand',
     and `trigreduce'.

     The construct `:lisp (putprop '|$foo| t 'evfun)' gives the `evfun'
     property to the function `foo', so that `foo' is applied during
     the call `ev (%, foo)'.  Equivalently, `foo (ev (%))' has the same
     effect.


 -- Option variable: infeval
     Enables "infinite evaluation" mode.  `ev' repeatedly evaluates an
     expression until it stops changing.  To prevent a variable, say
     `X', from being evaluated away in this mode, simply include `X='X'
     as an argument to `ev'.  Of course expressions such as `ev (X,
     X=X+1, infeval)' will generate an infinite loop.


 -- Function: kill (<symbol_1>, ..., <symbol_n>)
 -- Function: kill (labels)
 -- Function: kill (clabels, dlabels, elabels)
 -- Function: kill (<n>)
 -- Function: kill ([<m>, <n>])
 -- Function: kill (values, functions, arrays, ...)
 -- Function: kill (all)
 -- Function: kill (allbut (<symbol_1>, ..., <symbol_n>))
     Removes all bindings (value, function, array, or rule) from the
     arguments <symbol_1>, ..., <symbol_n>.  An argument may be a
     single array element or subscripted function.

     Several special arguments are recognized.  Different kinds of
     arguments may be combined, e.g., `kill (clabels, functions, allbut
     (foo, bar))'.

     `kill (labels)' unbinds all input, output, and intermediate
     expression labels created so far.  `kill (clabels)' unbinds only
     input labels which begin with the current value of `inchar'.
     Likewise, `kill (dlabels)' unbinds only output labels which begin
     with the current value of `outchar', and `kill (elabels)' unbinds
     only intermediate expression labels which begin with the current
     value of `linechar'.

     `kill (<n>)', where <n> is an integer, unbinds the <n> most recent
     input and output labels.

     `kill ([<m>, <n>])' unbinds input and output labels <m> through
     <n>.

     `kill (<infolist>)', where <infolist> is any item in `infolists'
     (such as `values', `functions', or `arrays') unbinds all items in
     `infolist'.  See also `infolists'.

     `kill (all)' unbinds all items on all infolists.  `kill (all)'
     does not reset global variables to their default values; see
     `reset' on this point.

     `kill (allbut (<symbol_1>, ..., <symbol_n>))' unbinds all items on
     all infolists except for <symbol_1>, ..., <symbol_n>.  `kill
     (allbut (<infolist>))' unbinds all items except for the ones on
     <infolist>, where <infolist> is `values', `functions', `arrays',
     etc.

     The memory taken up by a bound property is not released until all
     symbols are unbound from it.  In particular, to release the memory
     taken up by the value of a symbol, one unbinds the output label
     which shows the bound value, as well as unbinding the symbol
     itself.

     `kill' quotes its arguments.  The double single quotes operator,
     `''', defeats the quotation.

     `kill (<symbol>)' unbinds all properties of <symbol>.  In
     contrast, `remvalue', `remfunction', `remarray', and `remrule'
     unbind a specific property.

     `kill' always returns `done', even if an argument has no binding.


 -- Function: labels (<symbol>)
 -- System variable: labels
     Returns the list of input, output, or intermediate expression
     labels which begin with <symbol>.  Typically <symbol> is the value
     of `inchar', `outchar', or `linechar'.  The label character may be
     given with or without a percent sign, so, for example, `i' and
     `%i' yield the same result.

     If no labels begin with <symbol>, `labels' returns an empty list.

     The function `labels' quotes its argument.  The double single
     quotes operator `''' defeats quotation.  For example, `labels
     (''inchar)' returns the input labels which begin with the current
     input label character.

     The variable `labels' is the list of input, output, and
     intermediate expression labels, including all previous labels if
     `inchar', `outchar', or `linechar' were redefined.

     By default, Maxima displays the result of each user input
     expression, giving the result an output label.  The output display
     is suppressed by terminating the input with `$' (dollar sign)
     instead of `;' (semicolon).  An output label is generated, but not
     displayed, and the label may be referenced in the same way as
     displayed output labels.  See also `%', `%%', and `%th'.

     Intermediate expression labels can be generated by some functions.
     The flag `programmode' controls whether `solve' and some other
     functions generate intermediate expression labels instead of
     returning a list of expressions.  Some other functions, such as
     `ldisplay', always generate intermediate expression labels.

     `first (rest (labels (''inchar)))' returns the most recent input
     label.

     See also `inchar', `outchar', `linechar', and `infolists'.


 -- System variable: linenum
     The line number of the current pair of input and output
     expressions.


 -- System variable: myoptions
     Default value: `[]'

     `myoptions' is the list of all options ever reset by the user,
     whether or not they get reset to their default value.


 -- Option variable: nolabels
     Default value: `false'

     When `nolabels' is `true', input and output labels are generated
     but not appended to `labels', the list of all input and output
     labels.  `kill (labels)' kills the labels on the `labels' list,
     but does not kill any labels generated since `nolabels' was
     assigned `true'.  It seems likely this behavior is simply broken.

     See also `batch', `batchload', and `labels'.


 -- Option variable: optionset
     Default value: `false'

     When `optionset' is `true', Maxima prints out a message whenever a
     Maxima option is reset.  This is useful if the user is doubtful of
     the spelling of some option and wants to make sure that the
     variable he assigned a value to was truly an option variable.


 -- Function: playback ()
 -- Function: playback (<n>)
 -- Function: playback ([<m>, <n>])
 -- Function: playback ([<m>])
 -- Function: playback (input)
 -- Function: playback (slow)
 -- Function: playback (time)
 -- Function: playback (grind)
     Displays input, output, and intermediate expressions, without
     recomputing them.  `playback' only displays the expressions bound
     to labels; any other output (such as text printed by `print' or
     `describe', or error messages) is not displayed.  See also
     `labels'.

     `playback' quotes its arguments.  The double single quotes
     operator, `''', defeats quotation.  `playback' always returns
     `done'.

     `playback ()' (with no arguments) displays all input, output, and
     intermediate expressions generated so far.  An output expression
     is displayed even if it was suppressed by the `$' terminator when
     it was originally computed.

     `playback (<n>)' displays the most recent <n> expressions.  Each
     input, output, and intermediate expression counts as one.

     `playback ([<m>, <n>])' displays input, output, and intermediate
     expressions with numbers from <m> through <n>, inclusive.

     `playback ([<m>])' is equivalent to `playback ([<m>, <m>])'; this
     usually prints one pair of input and output expressions.

     `playback (input)' displays all input expressions generated so far.

     `playback (slow)' pauses between expressions and waits for the
     user to press `enter'.  This behavior is similar to `demo'.
     `playback (slow)' is useful in conjunction with `save' or
     `stringout' when creating a secondary-storage file in order to
     pick out useful expressions.

     `playback (time)' displays the computation time for each
     expression.

     `playback (grind)' displays input expressions in the same format
     as the `grind' function.  Output expressions are not affected by
     the `grind' option.  See `grind'.

     Arguments may be combined, e.g., `playback ([5, 10], grind, time,
     slow)'.


 -- Function: printprops (<a>, <i>)
 -- Function: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Function: printprops (all, <i>)
     Displays the property with the indicator <i> associated with the
     atom <a>. <a> may also be a list of atoms or the atom `all' in
     which case all of the atoms with the given property will be used.
     For example, `printprops ([f, g], atvalue)'.  `printprops' is for
     properties that cannot otherwise be displayed, i.e. for `atvalue',
     `atomgrad', `gradef', and `matchdeclare'.


 -- Option variable: prompt
     Default value: `_'

     `prompt' is the prompt symbol of the `demo' function, `playback
     (slow)' mode, and the Maxima break loop (as invoked by `break').


 -- Function: quit ()
     Terminates the Maxima session.  Note that the function must be
     invoked as `quit();' or `quit()$', not `quit' by itself.

     To stop a lengthy computation, type `control-C'.  The default
     action is to return to the Maxima prompt.  If `*debugger-hook*' is
     `nil', `control-C' opens the Lisp debugger.  See also `debugging'.


 -- Function: remfunction (<f_1>, ..., <f_n>)
 -- Function: remfunction (all)
     Removes the user defined functions <f_1>, ..., <f_n> from Maxima.
     `remfunction (all)' removes all functions.


 -- Function: reset ()
     Resets many global variables and options, and some other
     variables, to their default values.

     `reset' processes the variables on the Lisp list
     `*variable-initial-values*'.  The Lisp macro `defmvar' puts
     variables on this list (among other actions).  Many, but not all,
     global variables and options are defined by `defmvar', and some
     variables defined by `defmvar' are not global variables or options.


 -- Option variable: showtime
     Default value: `false'

     When `showtime' is `true', the computation time and elapsed time is
     printed with each output expression.

     See also `time', `timer', and `playback'.


 -- Function: sstatus (<feature>, <package>)
     Sets the status of <feature> in <package>.  After `sstatus
     (<feature>, <package>)' is executed, `status (<feature>,
     <package>)' returns `true'.  This can be useful for package
     writers, to keep track of what features they have loaded in.


 -- Function: to_lisp ()
     Enters the Lisp system under Maxima. `(to-maxima)' returns to
     Maxima.


 -- System variable: values
     Initial value: `[]'

     `values' is a list of all bound user variables (not Maxima options
     or switches).  The list comprises symbols bound by `:' , `::', or
     `:='.



File: maxima.info,  Node: Operators,  Next: Expressions,  Prev: Command Line,  Up: Top

5 Operators
***********

* Menu:

* nary::
* nofix::
* operator::
* postfix::
* prefix::
* Definitions for Operators::


File: maxima.info,  Node: nary,  Next: nofix,  Prev: Operators,  Up: Operators

5.1 nary
========

An `nary' operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the operator,
e.g. A+B or A+B+C.  The `nary("x")' function is a syntax extension
function to declare x to be an `nary' operator.  Functions may be
declared to be `nary'.  If `declare(j,nary);' is done, this tells the
simplifier to simplify, e.g. `j(j(a,b),j(c,d))' to `j(a, b, c, d)'.

   See also `syntax'.


File: maxima.info,  Node: nofix,  Next: operator,  Prev: nary,  Up: Operators

5.2 nofix
=========

`nofix' operators are used to denote functions of no arguments.  The
mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a Maxima break, "exit" is behaving similar to a
`nofix' operator.  The function `nofix("x")' is a syntax extension
function which declares x to be a `nofix' operator.

   See also `syntax'.


File: maxima.info,  Node: operator,  Next: postfix,  Prev: nofix,  Up: Operators

5.3 operator
============

See `operators'.


File: maxima.info,  Node: postfix,  Next: prefix,  Prev: operator,  Up: Operators

5.4 postfix
===========

`postfix' operators like the `prefix' variety denote functions of a
single argument, but in this case the argument immediately precedes an
occurrence of the operator in the input string, e.g. 3! .  The
`postfix("x")' function is a syntax extension function to declare x to
be a `postfix' operator.

   See also `syntax'.


File: maxima.info,  Node: prefix,  Next: Definitions for Operators,  Prev: postfix,  Up: Operators

5.5 prefix
==========

A `prefix' operator is one which signifies a function of one argument,
which argument immediately follows an occurrence of the operator.
`prefix("x")' is a syntax extension function to declare x to be a
`prefix' operator.

   See also `syntax'.


File: maxima.info,  Node: Definitions for Operators,  Prev: prefix,  Up: Operators

5.6 Definitions for Operators
=============================

 -- Operator: "!"
     The factorial operator.  For any complex number `x' (including
     integer, rational, and real numbers) except for negative integers,
     `x!' is defined as `gamma(x+1)'.

     For an integer `x', `x!' simplifies to the product of the integers
     from 1 to `x' inclusive.  `0!' simplifies to 1.  For a floating
     point number `x', `x!' simplifies to the value of `gamma (x+1)'.
     For `x' equal to `n/2' where `n' is an odd integer, `x!'
     simplifies to a rational factor times `sqrt (%pi)' (since `gamma
     (1/2)' is equal to `sqrt (%pi)').  If `x' is anything else, `x!'
     is not simplified.

     The variables `factlim', `minfactorial', and `factcomb' control
     the simplification of expressions containing factorials.

     The functions `gamma', `bffac', and `cbffac' are varieties of the
     gamma function.  `makegamma' substitutes `gamma' for factorials
     and related functions.

     See also `binomial'.

        * The factorial of an integer, half-integer, or floating point
          argument is simplified unless the operand is greater than
          `factlim'.

               (%i1) factlim: 10$
               (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
                         105 sqrt(%pi)
               (%o2) [1, -------------, 81.44668037931193, 40320, 20!]
                              16

        * The factorial of a complex number, known constant, or general
          expression is not simplified.  Even so it may be possible
          simplify the factorial after evaluating the operand.

               (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
               (%o1)    [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
               (%i2) ev (%, numer, %enumer);
               (%o2) [(%i + 1)!, 7.188082728976031, 4.260820476357003,

                                                         1.227580202486819]

        * The factorial of an unbound symbol is not simplified.

               (%i1) kill (foo)$
               (%i2) foo!;
               (%o2)                       foo!

        * Factorials are simplified, not evaluated.  Thus `x!' may be
          replaced even in a quoted expression.

               (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                         105 sqrt(%pi)
               (%o1) [1, -------------, 81.44668037931193, 40320, 20!]
                              16


 -- Operator: "!!"
     The double factorial operator.

     For an integer, float, or rational number `n', `n!!' evaluates to
     the product `n (n-2) (n-4) (n-6) ... (n - 2 (k-1))' where `k' is
     equal to `entier (n/2)', that is, the largest integer less than or
     equal to `n/2'.  Note that this definition does not coincide with
     other published definitions for arguments which are not integers.

     For an even (or odd) integer `n', `n!!' evaluates to the product of
     all the consecutive even (or odd) integers from 2 (or 1) through
     `n' inclusive.

     For an argument `n' which is not an integer, float, or rational,
     `n!!' yields a noun form `genfact (n, n/2, 2)'.


 -- Operator: "#"
     Represents the negation of syntactic equality `='.

     Note that because of the rules for evaluation of predicate
     expressions (in particular because `not <expr>' causes evaluation
     of <expr>), `not <a> = <b>' is not equivalent to `<a> # <b>' in
     some cases.

     Examples:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true


 -- Operator: "."
     The dot operator, for matrix (non-commutative) multiplication.
     When "." is used in this way, spaces should be left on both sides
     of it, e.g. A . B.  This distinguishes it plainly from a decimal
     point in a floating point number.

     See also `dot', `dot0nscsimp', `dot0simp', `dot1simp', `dotassoc',
     `dotconstrules', `dotdistrib', `dotexptsimp', `dotident', and
     `dotscrules'.


 -- Operator: ":"
     The assignment operator.  E.g. A:3 sets the variable A to 3.


 -- Operator: "::"
     Assignment operator.  :: assigns the value of the expression on
     its right to the value of the quantity on its left, which must
     evaluate to an atomic variable or subscripted variable.


 -- Operator: "::="
     The "::=" is used instead of ":=" to indicate that what follows is
     a macro definition, rather than an ordinary functional definition.
     See `macros'.


 -- Operator: ":="
     The function definition operator.  E.g. `f(x):=sin(x)' defines a
     function `f'.


 -- Operator: "="
     denotes an equation to Maxima.  To the pattern matcher in Maxima
     it denotes a total relation that holds between two expressions if
     and only if the expressions are syntactically identical.

     The negation of `=' is represented by `#'.  Note that because of
     the rules for evaluation of predicate expressions (in particular
     because `not <expr>' causes evaluation of <expr>), `not <a> = <b>'
     is not equivalent to `<a> # <b>' in some cases.


 -- Operator: and
     The logical conjunction operator.  `and' is an n-ary infix
     operator; its operands are Boolean expressions, and its result is
     a Boolean value.

     `and' forces evaluation (like `is') of one or more operands, and
     may force evaluation of all operands.

     Operands are evaluated in the order in which they appear.  `and'
     evaluates only as many of its operands as necessary to determine
     the result.  If any operand is `false', the result is `false' and
     no further operands are evaluated.

     The global flag `prederror' governs the behavior of `and' when an
     evaluated operand cannot be determined to be `true' or `false'.
     `and' prints an error message when `prederror' is `true'.
     Otherwise, `and' returns `unknown'.

     `and' is not commutative: `a and b' might not be equal to `b and
     a' due to the treatment of indeterminate operands.


 -- Operator: or
     The logical disjunction operator.  `or' is an n-ary infix operator;
     its operands are Boolean expressions, and its result is a Boolean
     value.

     `or' forces evaluation (like `is') of one or more operands, and
     may force evaluation of all operands.

     Operands are evaluated in the order in which they appear.  `or'
     evaluates only as many of its operands as necessary to determine
     the result.  If any operand is `true', the result is `true' and no
     further operands are evaluated.

     The global flag `prederror' governs the behavior of `or' when an
     evaluated operand cannot be determined to be `true' or `false'.
     `or' prints an error message when `prederror' is `true'.
     Otherwise, `or' returns `unknown'.

     `or' is not commutative: `a or b' might not be equal to `b or a'
     due to the treatment of indeterminate operands.


 -- Operator: not
     The logical negation operator.  `not' is a prefix operator; its
     operand is a Boolean expression, and its result is a Boolean value.

     `not' forces evaluation (like `is') of its operand.

     The global flag `prederror' governs the behavior of `not' when its
     operand cannot be determined to be `true' or `false'.  `not'
     prints an error message when `prederror' is `true'.  Otherwise,
     `not' returns `unknown'.


 -- Function: abs (<expr>)
     Returns the absolute value <expr>.  If <expr> is complex, returns
     the complex modulus of <expr>.


 -- Keyword: additive
     If `declare(f,additive)' has been executed, then:

     (1) If `f' is univariate, whenever the simplifier encounters `f'
     applied to a sum, `f' will be distributed over that sum.  I.e.
     `f(y+x)' will simplify to `f(y)+f(x)'.

     (2) If `f' is a function of 2 or more arguments, additivity is
     defined as additivity in the first argument to `f', as in the case
     of `sum' or `integrate', i.e. `f(h(x)+g(x),x)' will simplify to
     `f(h(x),x)+f(g(x),x)'.  This simplification does not occur when
     `f' is applied to expressions of the form
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Keyword: allbut
     works with the `part' commands (i.e. `part', `inpart', `substpart',
     `substinpart', `dpart', and `lpart').  For example,

          (%i1) expr: e+d+c+b+a$
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     while

          (%i3) part (expr, allbut (2, 5));
          (%o3)                       e + c + b

     It also works with the `kill' command,

          kill (allbut (name_1, ..., name_k))

     will do a `kill (all)' except it will not `kill' the names
     specified.  Note: `name_i' means a name such as function name such
     as `u', `f', `foo', or `g', not an infolist such as `functions'.


 -- Declaration: antisymmetric
     If `declare(h,antisymmetric)' is done, this tells the simplifier
     that `h' is antisymmetric.  E.g. `h(x,z,y)' will simplify to `-
     h(x, y, z)'.  That is, it will give (-1)^n times the result given
     by `symmetric' or `commutative', where n is the number of
     interchanges of two arguments necessary to convert it to that form.


 -- Function: cabs (<expr>)
     Returns the complex absolute value (the complex modulus) of <expr>.


 -- Declaration: commutative
     If `declare(h,commutative)' is done, this tells the simplifier
     that `h' is a commutative function.  E.g. `h(x,z,y)' will simplify
     to `h(x, y, z)'.  This is the same as `symmetric'.


 -- Function: entier (<x>)
     Returns the largest integer less than or equal to <x> where <x> is
     numeric.  `fix' (as in `fixnum') is a synonym for this, so
     `fix(<x>)' is precisely the same.


 -- Function: equal (<expr_1>, <expr_2>)
     Used with an `is', returns `true' (or `false') if and only if
     <expr_1> and <expr_2> are equal (or not equal) for all possible
     values of their variables (as determined by `ratsimp').  Thus `is
     (equal ((x + 1)^2, x^2 + 2*x + 1))' returns `true' whereas if `x'
     is unbound `is ((x + 1)^2 = x^2 + 2*x + 1)' returns `false'.  Note
     also that `is(rat(0)=0)' yields `false' but `is (equal (rat(0),
     0))' yields `true'.

     If a determination can't be made, then `is (equal (a, b))' returns
     a simplified but equivalent expression, whereas `is (a=b)' always
     returns either `true' or `false'.

     All variables occurring in <expr_1> and <expr_2> are presumed to
     be real valued.

     The negation of `equal' is `notequal'.  Note that because of the
     rules for evaluation of predicate expressions (in particular
     because `not <expr>' causes evaluation of <expr>), `notequal' is
     not equivalent to `not equal' in some cases.

     `ev (<expr>, pred)' is equivalent to `is (<expr>)'.

          (%i1) is (x^2 >= 2*x - 1);
          (%o1)                         true
          (%i2) assume (a > 1);
          (%o2)                        [a > 1]
          (%i3) is (log (log (a+1) + 1) > 0 and a^2 + 1 > 2*a);
          (%o3)                         true


 -- Function: notequal (<expr_1>, <expr_2>)
     Represents the negation of `equal (<expr_1>, <expr_2>)'.

     Note that because of the rules for evaluation of predicate
     expressions (in particular because `not <expr>' causes evaluation
     of <expr>), `notequal' is not equivalent to `not equal' in some
     cases.

     Examples:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          `macsyma' was unable to evaluate the predicate:
          equal(a, b)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) maybe (not equal (a, b));
          (%o6)                        unknown
          (%i7) assume (a > b);
          (%o7)                        [a > b]
          (%i8) equal (a, b);
          (%o8)                      equal(a, b)
          (%i9) maybe (equal (a, b));
          (%o9)                         false
          (%i10) notequal (a, b);
          (%o10)                   notequal(a, b)
          (%i11) not equal (a, b);
          (%o11)                        true
          (%i12) maybe (notequal (a, b));
          (%o12)                        true
          (%i13) maybe (not equal (a, b));
          (%o13)                        true


 -- Operator: eval
     As an argument in a call to `ev (<expr>)', `eval' causes an extra
     evaluation of <expr>.  See `ev'.


 -- Function: evenp (<expr>)
     Returns `true' if <expr> is an even integer.  `false' is returned
     in all other cases.


 -- Function: fix (<x>)
     A synonym for `entier (<x>)'.


 -- Function: fullmap (<f>, <expr_1>, ...)
     Similar to `map', but `fullmap' keeps mapping down all
     subexpressions until the main operators are no longer the same.

     `fullmap' is used by the Maxima simplifier for certain matrix
     manipulations; thus, Maxima sometimes generates an error message
     concerning `fullmap' even though `fullmap' was not explicitly
     called by the user.

          (%i1) a + b*c$
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Function: fullmapl (<f>, <list_1>, ...)
     Similar to `fullmap', but `fullmapl' only maps onto lists and
     matrices.

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Function: is (<expr>)
     Attempts to determine whether the predicate <expr> is provable
     from the facts in the `assume' database.

     If the predicate is provably `true' or `false', `is' returns
     `true' or `false', respectively.  Otherwise, the return value is
     controlled by the global flag `prederror'.  When `prederror' is
     `false', `is' returns `unknown' for a predicate which cannot be
     proven nor disproven, and reports an error otherwise.

     See also `assume', `facts', and `maybe'.

     Examples:

     `is' causes evaluation of predicates.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     `is' attempts to derive predicates from the `assume' database.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     If `is' can neither prove nor disprove a predicate from the
     `assume' database, the global flag `prederror' governs the
     behavior of `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          `macsyma' was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown


 -- Function: maybe (<expr>)
     Attempts to determine whether the predicate <expr> is provable
     from the facts in the `assume' database.

     If the predicate is provably `true' or `false', `maybe' returns
     `true' or `false', respectively.  Otherwise, `maybe' returns
     `unknown'.

     `maybe' is functionally equivalent to `is' with `prederror: false',
     but the result is computed without actually assigning a value to
     `prederror'.

     See also `assume', `facts', and `is'.

     Examples:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Function: isqrt (<x>)
     Returns the "integer square root" of the absolute value of <x>,
     which is an integer.


 -- Function: max (<x_1>, <x_2>, ...)
     Returns the maximum of its arguments (or returns a simplified form
     if some of its arguments are non-numeric).


 -- Function: min (<x_1>, <x_2>, ...)
     Returns the minimum of its arguments (or returns a simplified form
     if some of its arguments are non-numeric).


 -- Function: mod (<p>)
 -- Function: mod (<p>, <m>)
     Converts the polynomial <p> to a modular representation with
     respect to the current modulus which is the value of the variable
     `modulus'.

     `mod (<p>, <m>)' specifies a modulus <m> to be used instead of the
     current value of `modulus'.

     See `modulus'.


 -- Function: oddp (<expr>)
     is `true' if <expr> is an odd integer.  `false' is returned in all
     other cases.


 -- Operator: pred
     As an argument in a call to `ev (<expr>)', `pred' causes
     predicates (expressions which evaluate to `true' or `false') to be
     evaluated.  See `ev'.


 -- Function: make_random_state (<n>)
 -- Function: make_random_state (<s>)
 -- Function: make_random_state (true)
 -- Function: make_random_state (false)
     A random state object represents the state of the random number
     generator.  The state comprises 627 32-bit words.

     `make_random_state (<n>)' returns a new random state object
     created from an integer seed value equal to <n> modulo 2^32.  <n>
     may be negative.

     `make_random_state (<s>)' returns a copy of the random state <s>.

     `make_random_state (true)' returns a new random state object,
     using the current computer clock time as the seed.

     `make_random_state (false)' returns a copy of the current state of
     the random number generator.


 -- Function: set_random_state (<s>)
     Copies <s> to the random number generator state.

     `set_random_state' always returns `done'.


 -- Function: random (<x>)
     Returns a pseudorandom number. If <x> is an integer, `random
     (<x>)' returns an integer from 0 through `<x> - 1' inclusive. If
     <x> is a floating point number, `random (<x>)' returns a
     nonnegative floating point number less than <x>.  `random'
     complains with an error if <x> is neither an integer nor a float,
     or if <x> is not positive.

     The functions `make_random_state' and `set_random_state' maintain
     the state of the random number generator.

     The Maxima random number generator is an implementation of the
     Mersenne twister MT 19937.

     Examples:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Function: sign (<expr>)
     Attempts to determine the sign of <expr> on the basis of the facts
     in the current data base.  It returns one of the following
     answers: `pos' (positive), `neg' (negative), `zero', `pz'
     (positive or zero), `nz' (negative or zero), `pn' (positive or
     negative), or `pnz' (positive, negative, or zero, i.e. nothing
     known).


 -- Function: signum (<x>)
     For numeric <x>, returns 0 if <x> is 0, otherwise returns -1 or +1
     as <x> is less than or greater than 0, respectively.

     If <x> is not numeric then a simplified but equivalent form is
     returned.  For example, `signum(-x)' gives `-signum(x)'.


 -- Function: sort (<list>, <p>)
 -- Function: sort (<list>)
     Sorts <list> according to a predicate `p' of two arguments, such
     as `"<"' or `orderlessp'.

     `sort (<list>)' sorts <list> according to Maxima's built-in
     ordering.

     <list> may contain numeric or nonnumeric items, or both.


 -- Function: sqrt (<x>)
     The square root of <x>. It is represented internally by
     `<x>^(1/2)'.  See also `rootscontract'.

     `radexpand' if `true' will cause nth roots of factors of a product
     which are powers of n to be pulled outside of the radical, e.g.
     `sqrt(16*x^2)' will become `4*x' only if `radexpand' is `true'.


 -- Option variable: sqrtdispflag
     Default value: `true'

     When `sqrtdispflag' is `false', causes `sqrt' to display with
     exponent 1/2.


 -- Function: sublis (<list>, <expr>)
     Makes multiple parallel substitutions into an expression.

     The variable `sublis_apply_lambda' controls simplification after
     `sublis'.

     Example:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)


 -- Function: sublist (<list>, <p>)
     Returns the list of elements of <list> for which the predicate `p'
     returns `true'.

     Example:

          (%i1) L: [1, 2, 3, 4, 5, 6]$
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Option variable: sublis_apply_lambda
     Default value: `true' - controls whether `lambda''s substituted
     are applied in simplification after `sublis' is used or whether
     you have to do an `ev' to get things to apply. `true' means do the
     application.


 -- Function: subst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <b> must be an atom or a complete
     subexpression of <c>.  For example, `x+y+z' is a complete
     subexpression of `2*(x+y+z)/w' while `x+y' is not. When <b> does
     not have these characteristics, one may sometimes use `substpart'
     or `ratsubst' (see below).  Alternatively, if <b> is of the form
     `e/f' then one could use `subst (a*f, e, c)' while if <b> is of
     the form `e^(1/f)' then one could use `subst (a^f, e, c)'.  The
     `subst' command also discerns the `x^y' in `x^-y' so that `subst
     (a, sqrt(x), 1/sqrt(x))' yields `1/a'.  <a> and <b> may also be
     operators of an expression enclosed in double-quotes `"' or they
     may be function names.  If one wishes to substitute for the
     independent variable in derivative forms then the `at' function
     (see below) should be used.

     `subst' is an alias for `substitute'.

     `subst (<eq_1>, <expr>)' or `subst ([<eq_1>, ..., <eq_k>], <expr>)'
     are other permissible forms.  The <eq_i> are equations indicating
     substitutions to be made.  For each equation, the right side will
     be substituted for the left in the expression <expr>.

     `exptsubst' if `true' permits substitutions like `y' for `%e^x' in
     `%e^(a*x)' to take place.

     When `opsubst' is `false', `subst' will not attempt to substitute
     into the operator of an expression.  E.g. `(opsubst: false, subst
     (x^2, r, r+r[0]))' will work.

     Examples:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     For further examples, do `example (subst)'.


 -- Function: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Similar to `substpart', but `substinpart' works on the internal
     representation of <expr>.

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       D
          (%o1)                    x . --- (f(x))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x+1), 0);
          (%o3)                       f1(x + 1)

     If the last argument to a part function is a list of indices then
     several subexpressions are picked out, each one corresponding to an
     index of the list.  Thus

          (%i1) part (x+y+z, [1, 3]);
          (%o1)                         z + x

     `piece' holds the value of the last expression selected when using
     the part functions.  It is set during the execution of the
     function and thus may be referred to in the function itself as
     shown below.  If `partswitch' is set to `true' then `end' is
     returned when a selected part of an expression doesn't exist,
     otherwise an error message is given.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Also, setting the option `inflag' to `true' and calling `part' or
     `substpart' is the same as calling `inpart' or `substinpart'.


 -- Function: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substitutes <x> for the subexpression picked out by the rest of
     the arguments as in `part'.  It returns the new value of <expr>.
     <x> may be some operator to be substituted for an operator of
     <expr>.  In some cases <x> needs to be enclosed in double-quotes
     `"' (e.g.  `substpart ("+", a*b, 0)' yields `b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Also, setting the option `inflag' to `true' and calling `part' or
     `substpart' is the same as calling `inpart' or `substinpart'.


 -- Function: subvarp (<expr>)
     Returns `true' if <expr> is a subscripted variable, for example
     `a[i]'.


 -- Function: symbolp (<expr>)
     Returns `true' if <expr> is a symbol, else `false'.  In effect,
     `symbolp(x)' is equivalent to the predicate `atom(x) and not
     numberp(x)'.

     See also `Identifiers'.


 -- Function: unorder ()
     Disables the aliasing created by the last use of the ordering
     commands `ordergreat' and `orderless'. `ordergreat' and
     `orderless' may not be used more than one time each without
     calling `unorder'.  See also `ordergreat' and `orderless'.

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
                                       2
          (%o4)                       a  + b x
          (%i5) %th(1) - %th(3);
                                        2    2
          (%o5)                        a  - a
          (%i6) unorder();
          (%o6)                          [a]


 -- Function: vectorpotential (<givencurl>)
     Returns the vector potential of a given curl vector, in the
     current coordinate system.  `potentialzeroloc' has a similar role
     as for `potential', but the order of the left-hand sides of the
     equations must be a cyclic permutation of the coordinate variables.


 -- Function: xthru (<expr>)
     Combines all terms of <expr> (which should be a sum) over a common
     denominator without expanding products and exponentiated sums as
     `ratsimp' does.  `xthru' cancels common factors in the numerator
     and denominator of rational expressions but only if the factors are
     explicit.

     Sometimes it is better to use `xthru' before `ratsimp'ing an
     expression in order to cause explicit factors of the gcd of the
     numerator and denominator to be canceled thus simplifying the
     expression to be `ratsimp'ed.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


 -- Function: zeroequiv (<expr>, <v>)
     Tests whether the expression <expr> in the variable <v> is
     equivalent to zero, returning `true', `false', or `dontknow'.

     `zeroequiv' has these restrictions:
       1. Do not use functions that Maxima does not know how to
          differentiate and evaluate.

       2. If the expression has poles on the real line, there may be
          errors in the result (but this is unlikely to occur).

       3. If the expression contains functions which are not solutions
          to first order differential equations (e.g.  Bessel
          functions) there may be incorrect results.

       4. The algorithm uses evaluation at randomly chosen points for
          carefully selected subexpressions.  This is always a somewhat
          hazardous business, although the algorithm tries to minimize
          the potential for error.

     For example `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' returns
     `true' and `zeroequiv (%e^x + x, x)' returns `false'.  On the
     other hand `zeroequiv (log(a*b) - log(a) - log(b), a)' returns
     `dontknow' because of the presence of an extra parameter `b'.



File: maxima.info,  Node: Expressions,  Next: Simplification,  Prev: Operators,  Up: Top

6 Expressions
*************

* Menu:

* Introduction to Expressions::
* Assignment::
* Complex::
* Nouns and Verbs::
* Identifiers::
* Inequality::
* Syntax::
* Definitions for Expressions::


File: maxima.info,  Node: Introduction to Expressions,  Next: Assignment,  Prev: Expressions,  Up: Expressions

6.1 Introduction to Expressions
===============================

There are a number of reserved words which cannot be used as variable
names.   Their use would cause a possibly cryptic syntax error.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Most things in Maxima are expressions.   A sequence of expressions
can be made into an expression by separating them by commas and putting
parentheses around them.   This is similar to the C comma expression.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Even loops in Maxima are expressions, although the value they return
is the not too useful `done'.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   whereas what you really want is probably to include a third term in
the comma expression which actually gives back the value.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Assignment,  Next: Complex,  Prev: Introduction to Expressions,  Up: Expressions

6.2 Assignment
==============

There are two assignment operators in Maxima, `:' and `::'.  E.g., `a:
3' sets the variable `a' to 3. `::' assigns the value of the expression
on its right to the value of the quantity on its left, which must
evaluate to an atomic variable or subscripted variable.


File: maxima.info,  Node: Complex,  Next: Nouns and Verbs,  Prev: Assignment,  Up: Expressions

6.3 Complex
===========

A complex expression is specified in Maxima by adding the real part of
the expression to `%i' times the imaginary part.  Thus the roots of the
equation `x^2 - 4*x + 13 = 0' are `2 + 3*%i' and `2 - 3*%i'.  Note that
simplification of products of complex expressions can be effected by
expanding the product.  Simplification of quotients, roots, and other
functions of complex expressions can usually be accomplished by using
the `realpart', `imagpart', `rectform', `polarform', `abs', `carg'
functions.


File: maxima.info,  Node: Nouns and Verbs,  Next: Identifiers,  Prev: Complex,  Up: Expressions

6.4 Nouns and Verbs
===================

Maxima distinguishes between operators which are "nouns" and operators
which are "verbs".  A verb is an operator which can be executed.  A
noun is an operator which appears as a symbol in an expression, without
being executed.  By default, function names are verbs.  A verb can be
changed into a noun by quoting the function name or applying the
`nounify' function.  A noun can be changed into a verb by applying the
`verbify' function.  The evaluation flag `nouns' causes `ev' to
evaluate nouns in an expression.

   The verb form is distinguished by a leading dollar sign `$' on the
corresponding Lisp symbol.  In contrast, the noun form is distinguished
by a leading percent sign `%' on the corresponding Lisp symbol.  Some
nouns have special display properties, such as `'integrate' and
`'derivative' (returned by `diff'), but most do not.  By default, the
noun and verb forms of a function are identical when displayed.  The
global flag `noundisp' causes Maxima to display nouns with a leading
quote mark `''.

   See also `noun', `nouns', `nounify', and `verbify'.

   Examples:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identifiers,  Next: Inequality,  Prev: Nouns and Verbs,  Up: Expressions

6.5 Identifiers
===============

Maxima identifiers may comprise alphabetic characters, plus the
numerals 0 through 9, plus any special character preceded by the
backslash `\' character.

   A numeral may be the first character of an identifier if it is
preceded by a backslash.  Numerals which are the second or later
characters need not be preceded by a backslash.

   A special character may be declared alphabetic by the `declare'
function.  If so declared, it need not be preceded by a backslash in an
identifier.  The alphabetic characters are initially `A' through `Z',
`a' through `z', `%', and `_'.

   Maxima is case-sensitive. The identifiers `foo', `FOO', and `Foo'
are distinct.  See *Note Lisp and Maxima:: for more on this point.

   A Maxima identifier is a Lisp symbol which begins with a dollar sign
`$'.  Any other Lisp symbol is preceded by a question mark `?' when it
appears in Maxima.  See *Note Lisp and Maxima:: for more on this point.

   Examples:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Inequality,  Next: Syntax,  Prev: Identifiers,  Up: Expressions

6.6 Inequality
==============

Maxima has the inequality operators `<', `<=', `>=', `>', `#', and
`notequal'.  See `if' for a description of conditional expressions.


File: maxima.info,  Node: Syntax,  Next: Definitions for Expressions,  Prev: Inequality,  Up: Expressions

6.7 Syntax
==========

It is possible to define new operators with specified precedence, to
undefine existing operators, or to redefine the precedence of existing
operators.  An operator may be unary prefix or unary postfix, binary
infix, n-ary infix, matchfix, or nofix.  "Matchfix" means a pair of
symbols which enclose their argument or arguments, and "nofix" means an
operator which takes no arguments.  As examples of the different types
of operators, there are the following.

unary prefix
     negation `- a'

unary postfix
     factorial `a!'

binary infix
     exponentiation `a^b'

n-ary infix
     addition `a + b'

matchfix
     list construction `[a, b]'

   (There are no built-in nofix operators; for an example of such an
operator, see `nofix'.)

   The mechanism to define a new operator is straightforward.  It is
only necessary to declare a function as an operator; the operator
function might or might not be defined.

   An example of user-defined operators is the following.  Note that
the explicit function call `"dd" (a)' is equivalent to `dd a', likewise
`"<-" (a, b)' is equivalent to `a <- b'.  Note also that the functions
`"dd"' and `"<-"' are undefined in this example.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   The Maxima functions which define new operators are summarized in
this table, stating the default left and right binding powers (lbp and
rbp, respectively).  (Binding power determines operator precedence.
However, since left and right binding powers can differ, binding power
is somewhat more complicated than precedence.)  Some of the operation
definition functions take additional arguments; see the function
descriptions for details.

`prefix'
     rbp=180

`postfix'
     lbp=180

`infix'
     lbp=180, rbp=180

`nary'
     lbp=180, rbp=180

`matchfix'
     (binding power not applicable)

`nofix'
     (binding power not applicable)

   For comparison, here are some built-in operators and their left and
right binding powers.

     Operator   lbp     rbp

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   `remove' and `kill' remove operator properties from an atom.
`remove ("<a>", op)' removes only the operator properties of <a>.
`kill ("<a>")' removes all properties of <a>, including the operator
properties.  Note that the name of the operator must be enclosed in
quotation marks.

     (%i1) infix ("@");
     (%o1)                           @
     (%i2) "@" (a, b) := a^b;
                                          b
     (%o2)                      a @ b := a
     (%i3) 5 @ 3;
     (%o3)                          125
     (%i4) remove ("@", op);
     (%o4)                         done
     (%i5) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i5) "@" (5, 3);
     (%o5)                          125
     (%i6) infix ("@");
     (%o6)                           @
     (%i7) 5 @ 3;
     (%o7)                          125
     (%i8) kill ("@");
     (%o8)                         done
     (%i9) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i9) "@" (5, 3);
     (%o9)                        @(5, 3)


File: maxima.info,  Node: Definitions for Expressions,  Prev: Syntax,  Up: Expressions

6.8 Definitions for Expressions
===============================

 -- Function: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Function: at (<expr>, <eqn>)
     Evaluates the expression <expr> with the variables assuming the
     values as specified for them in the list of equations `[<eqn_1>,
     ..., <eqn_n>]' or the single equation <eqn>.

     If a subexpression depends on any of the variables for which a
     value is specified but there is no atvalue specified and it can't
     be otherwise evaluated, then a noun form of the `at' is returned
     which displays in a two-dimensional form.

     `at' carries out multiple substitutions in series, not parallel.

     See also `atvalue'.  For other functions which carry out
     substitutions, see also `subst' and `ev'.

     Examples:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Function: box (<expr>)
 -- Function: box (<expr>, <a>)
     Returns <expr> enclosed in a box.  The return value is an
     expression with `box' as the operator and <expr> as the argument.
     A box is drawn on the display when `display2d' is `true'.

     `box (<expr>, <a>)' encloses <expr> in a box labelled by the
     symbol <a>.  The label is truncated if it is longer than the width
     of the box.

     A boxed expression does not evaluate to its content, so boxed
     expressions are effectively excluded from computations.

     `boxchar' is the character used to draw the box in `box' and in
     the `dpart' and `lpart' functions.

     Examples:



 -- Option variable: boxchar
     Default value: `"'

     `boxchar' is the character used to draw the box in the `box' and
     in the `dpart' and `lpart' functions.

     All boxes in an expression are drawn with the current value of
     `boxchar'; the drawing character is not stored with the box
     expression.


 -- Function: carg (<z>)
     Returns the complex argument of <z>.  The complex argument is an
     angle `theta' in `(-%pi, %pi]' such that `r exp (theta %i) = <z>'
     where `r' is the magnitude of <z>.

     `carg' is a computational function, not a simplifying function.

     `carg' ignores the declaration `declare (<x>, complex)', and
     treats <x> as a real variable.  This is a bug.  See also `abs'
     (complex magnitude), `polarform', `rectform', `realpart', and
     `imagpart'.

     Examples:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Special operator: constant
     `declare (<a>, constant)' declares <a> to be a constant.  See
     `declare'.


 -- Function: constantp (<expr>)
     Returns `true' if <expr> is a constant expression, otherwise
     returns `false'.

     An expression is considered a constant expression if its arguments
     are numbers (including rational numbers, as displayed with `/R/'),
     symbolic constants such as `%pi', `%e', and `%i', variables bound
     to a constant or declared constant by `declare', or functions
     whose arguments are constant.

     `constantp' evaluates its arguments.

     Examples:



 -- Function: declare (<a_1>, <f_1>, <a_2>, <f_2>, ...)
     Assigns the atom <a_i> the flag <f_i>.  The <a_i>'s and <f_i>'s
     may also be lists of atoms and flags respectively in which case
     each of the atoms gets all of the properties.

     `declare' quotes its arguments.  `declare' always returns `done'.

     The possible flags and their meanings are:

     `constant' makes <a_i> a constant as is `%pi'.

     `mainvar' makes <a_i> a `mainvar'.  The ordering scale for atoms:
     numbers < constants (e.g. `%e', `%pi') < scalars < other variables
     < mainvars.

     `scalar' makes <a_i> a scalar.

     `nonscalar' makes <a_i> behave as does a list or matrix with
     respect to the dot operator.

     `noun' makes the function <a_i> a noun so that it won't be
     evaluated automatically.

     `evfun' makes <a_i> known to the `ev' function so that it will get
     applied if its name is mentioned.  See `evfun'.

     `evflag' makes <a_i> known to the `ev' function so that it will be
     bound to `true' during the execution of `ev' if it is mentioned.
     See `evflag'.

     `bindtest' causes <a_i> to signal an error if it ever is used in a
     computation unbound.

     Maxima currently recognizes and uses the following features of
     objects:

          even, odd, integer, rational, irrational, real, imaginary,
          and complex

     The useful features of functions include:

          increasing,
          decreasing, oddfun (odd function), evenfun (even function),
          commutative (or symmetric), antisymmetric, lassociative and
          rassociative

     The <a_i> and <f_i> may also be lists of objects or features.

     `featurep (<object>, <feature>)' determines if <object> has been
     declared to have <feature>.

     See also `features'.


 -- Function: disolate (<expr>, <x_1>, ..., <x_n>)
     is similar to `isolate (<expr>, <x>)' except that it enables the
     user to isolate more than one variable simultaneously.  This might
     be useful, for example, if one were attempting to change variables
     in a multiple integration, and that variable change involved two
     or more of the integration variables.  This function is autoloaded
     from `simplification/disol.mac'.  A demo is available by
     `demo("disol")$'.


 -- Function: dispform (<expr>)
     Returns the external representation of <expr> with respect to its
     main operator.  This should be useful in conjunction with `part'
     which also deals with the external representation.  Suppose <expr>
     is -A .  Then the internal representation of <expr> is "*"(-1,A),
     while the external representation is "-"(A). `dispform (<expr>,
     all)' converts the entire expression (not just the top-level) to
     external format.  For example, if `expr: sin (sqrt (x))', then
     `freeof (sqrt, expr)' and `freeof (sqrt, dispform (expr))' give
     `true', while `freeof (sqrt, dispform (expr, all))' gives `false'.


 -- Function: distrib (<expr>)
     Distributes sums over products.  It differs from `expand' in that
     it works at only the top level of an expression, i.e., it doesn't
     recurse and it is faster than `expand'.  It differs from
     `multthru' in that it expands all sums at that level.

     Examples:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Function: dpart (<expr>, <n_1>, ..., <n_k>)
     Selects the same subexpression as `part', but instead of just
     returning that subexpression as its value, it returns the whole
     expression with the selected subexpression displayed inside a box.
     The box is actually part of the expression.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Function: exp (<x>)
     Represents the exponential function.  Instances of `exp (<x>)' in
     input are simplified to `%e^<x>'; `exp' does not appear in
     simplified expressions.

     `demoivre' if `true' causes `%e^(a + b %i)' to simplify to `%e^(a
     (cos(b) + %i sin(b)))' if `b' is free of `%i'. See `demoivre'.

     `%emode', when `true', causes `%e^(%pi %i x)' to be simplified.
     See `%emode'.

     `%enumer', when `true' causes `%e' to be replaced by 2.718...
     whenever `numer' is `true'. See `%enumer'.


 -- Option variable: %emode
     Default value: `true'

     When `%emode' is `true', `%e^(%pi %i x)' is simplified as follows.

     `%e^(%pi %i x)' simplifies to `cos (%pi x) + %i sin (%pi x)' if
     `x' is an integer or a multiple of 1/2, 1/3, 1/4, or 1/6, and then
     further simplified.

     For other numerical `x', `%e^(%pi %i x)' simplifies to `%e^(%pi %i
     y)' where `y' is `x - 2 k' for some integer `k' such that `abs(y)
     < 1'.

     When `%emode' is `false', no special simplification of `%e^(%pi %i
     x)' is carried out.


 -- Option variable: %enumer
     Default value: `false'

     When `%enumer' is `true', `%e' is replaced by its numeric value
     2.718...  whenever `numer' is `true'.

     When `%enumer' is `false', this substitution is carried out only
     if the exponent in `%e^x' evaluates to a number.

     See also `ev' and `numer'.


 -- Option variable: exptisolate
     Default value: `false'

     `exptisolate', when `true', causes `isolate (expr, var)' to
     examine exponents of atoms (such as `%e') which contain `var'.


 -- Option variable: exptsubst
     Default value: `false'

     `exptsubst', when `true', permits substitutions such as `y' for
     `%e^x' in `%e^(a x)'.


 -- Function: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Returns `true' if no subexpression of
     <expr> is equal to <x_1> or if <x_1> occurs only as a dummy
     variable in <expr>, and returns `false' otherwise.

     `freeof (<x_1>, ..., <x_n>, <expr>)' is equivalent to `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     The arguments <x_1>, ..., <x_n> may be names of functions and
     variables, subscripted names, operators (enclosed in double
     quotes), or general expressions.  `freeof' evaluates its arguments.

     `freeof' operates only on <expr> as it stands (after
     simplification and evaluation) and does not attempt to determine
     if some equivalent expression would give a different result.  In
     particular, simplification may yield an equivalent but different
     expression which comprises some different elements than the
     original form of <expr>.

     A variable is a dummy variable in an expression if it has no
     binding outside of the expression.  Dummy variables recognized by
     `freeof' are the index of a sum or product, the limit variable in
     `limit', the integration variable in the definite integral form of
     `integrate', the original variable in `laplace', formal variables
     in `at' expressions, and arguments in `lambda' expressions.  Local
     variables in `block' are not recognized by `freeof' as dummy
     variables; this is a bug.

     The indefinite form of `integrate' is not free of its variable of
     integration.

        * Arguments are names of functions, variables, subscripted
          names, operators, and expressions.  `freeof (a, b, expr)' is
          equivalent to `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' evaluates its arguments.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' does not consider equivalent expressions.
          Simplification may yield an equivalent but different
          expression.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * A summation or definite integral is free of its dummy
          variable.  An indefinite integral is not free of its variable
          of integration.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Function: genfact (<x>, <y>, <z>)
     Returns the generalized factorial, defined as `x (x-z) (x - 2 z)
     ... (x - (y - 1) z)'.  Thus, for integral <x>, `genfact (x, x, 1)
     = x!' and `genfact (x, x/2, 2) = x!!'.


 -- Function: imagpart (<expr>)
     Returns the imaginary part of the expression <expr>.

     `imagpart' is a computational function, not a simplifying function.

     See also `abs', `carg', `polarform', `rectform', and `realpart'.


 -- Function: infix (<op>)
 -- Function: infix (<op>, <lbp>, <rbp>)
 -- Function: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declares <op> to be an infix operator.  An infix operator is a
     function of two arguments, with the name of the function written
     between the arguments.  For example, the subtraction operator `-'
     is an infix operator.

     `infix (<op>)' declares <op> to be an infix operator with default
     binding powers (left and right both equal to 180) and parts of
     speech (left and right both equal to `any').

     `infix (<op>, <lbp>, <rbp>)' declares <op> to be an infix operator
     with stated left and right binding powers and default parts of
     speech (left and right both equal to `any').

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declares <op>
     to be an infix operator with stated left and right binding powers
     and parts of speech.

     The precedence of <op> with respect to other operators derives
     from the left and right binding powers of the operators in
     question.  If the left and right binding powers of <op> are both
     greater the left and right binding powers of some other operator,
     then <op> takes precedence over the other operator.  If the
     binding powers are not both greater or less, some more complicated
     relation holds.

     The associativity of <op> depends on its binding powers.  Greater
     left binding power (<lbp>) implies an instance of <op> is
     evaluated before other operators to its left in an expression,
     while greater right binding power (<rbp>) implies  an instance of
     <op> is evaluated before other operators to its right in an
     expression.  Thus greater <lbp> makes <op> right-associative,
     while greater <rbp> makes <op> left-associative.  If <lbp> is
     equal to <rbp>, <op> is left-associative.

     See also `Syntax'.

     Examples:

        * If the left and right binding powers of <op> are both greater
          the left and right binding powers of some other operator,
          then <op> takes precedence over the other operator.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) :lisp (get '$+ 'lbp)
          100
          (%i2) :lisp (get '$+ 'rbp)
          100
          (%i2) infix ("@", 101, 101)$
          (%i3) 1 + a@b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("@", 99, 99)$
          (%i5) 1 + a@b + 2;
          (%o5)                       (a+1,b+2)

        * Greater <lbp> makes <op> right-associative, while greater
          <rbp> makes <op> left-associative.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) infix ("@", 100, 99)$
          (%i3) foo @ bar @ baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("@", 100, 101)$
          (%i5) foo @ bar @ baz;
          (%o5)                    ((foo,bar),baz)


 -- Option variable: inflag
     Default value: `false'

     When `inflag' is `true', functions for part extraction inspect the
     internal form of `expr'.

     Note that the simplifier re-orders expressions.  Thus `first (x +
     y)' returns `x' if `inflag' is `true' and `y' if `inflag' is
     `false'.  (`first (y + x)' gives the same results.)

     Also, setting `inflag' to `true' and calling `part' or `substpart'
     is the same as calling `inpart' or `substinpart'.

     Functions affected by the setting of `inflag' are: `part',
     `substpart', `first', `rest', `last', `length', the `for' ... `in'
     construct, `map', `fullmap', `maplist', `reveal' and `pickapart'.


 -- Function: inpart (<expr>, <n_1>, ..., <n_k>)
     is similar to `part' but works on the internal representation of
     the expression rather than the displayed form and thus may be
     faster since no formatting is done.  Care should be taken with
     respect to the order of subexpressions in sums and products (since
     the order of variables in the internal form is often different
     from that in the displayed form) and in dealing with unary minus,
     subtraction, and division (since these operators are removed from
     the expression). `part (x+y, 0)' or `inpart (x+y, 0)' yield `+',
     though in order to refer to the operator it must be enclosed in
     "s.  For example `... if inpart (%o9,0) = "+" then ...'.

     Examples:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Function: isolate (<expr>, <x>)
     Returns <expr> with subexpressions which are sums and which do not
     contain var replaced by intermediate expression labels (these
     being atomic symbols like `%t1', `%t2', ...).  This is often useful
     to avoid unnecessary expansion of subexpressions which don't
     contain the variable of interest.  Since the intermediate labels
     are bound to the subexpressions they can all be substituted back
     by evaluating the expression in which they occur.

     `exptisolate' (default value: `false') if `true' will cause
     `isolate' to examine exponents of atoms (like `%e') which contain
     var.

     `isolate_wrt_times' if `true', then `isolate' will also isolate wrt
     products. See `isolate_wrt_times'.

     Do `example (isolate)' for examples.


 -- Option variable: isolate_wrt_times
     Default value: `false'

     When `isolate_wrt_times' is `true', `isolate' will also isolate
     wrt products.  E.g. compare both settings of the switch on

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Option variable: listconstvars
     Default value: `false'

     When `listconstvars' is `true', it will cause `listofvars' to
     include `%e', `%pi', `%i', and any variables declared constant in
     the list it returns if they appear in the expression `listofvars'
     is called on.  The default is to omit these.


 -- Option variable: listdummyvars
     Default value: `true'

     When `listdummyvars' is `false', "dummy variables" in the
     expression will not be included in the list returned by
     `listofvars'.  (The meaning of "dummy variables" is as given in
     `freeof'.  "Dummy variables" are mathematical things like the
     index of a sum or product, the limit variable, and the definite
     integration variable.)  Example:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Function: listofvars (<expr>)
     Returns a list of the variables in <expr>.

     `listconstvars' if `true' causes `listofvars' to include `%e',
     `%pi', `%i', and any variables declared constant in the list it
     returns if they appear in <expr>.  The default is to omit these.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Function: lfreeof (<list>, <expr>)
     For each member <m> of list, calls `freeof (<m>, <expr>)'.  It
     returns `false' if any call to `freeof' does and `true' otherwise.

 -- Function: lopow (<expr>, <x>)
     Returns the lowest exponent of <x> which explicitly appears in
     <expr>.  Thus

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Function: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     is similar to `dpart' but uses a labelled box. A labelled box is
     similar to the one produced by `dpart' but it has a name in the
     top line.


 -- Function: multthru (<expr>)
 -- Function: multthru (<expr_1>, <expr_2>)
     Multiplies a factor (which should be a sum) of <expr> by the other
     factors of <expr>.  That is, <expr> is `<f_1> <f_2> ... <f_n>'
     where at least one factor, say <f_i>, is a sum of terms.  Each
     term in that sum is multiplied by the other factors in the
     product.  (Namely all the factors except <f_i>).  `multthru' does
     not expand exponentiated sums.  This function is the fastest way
     to distribute products (commutative or noncommutative) over sums.
     Since quotients are represented as products `multthru' can be used
     to divide sums by products as well.

     `multthru (<expr_1>, <expr_2>)' multiplies each term in <expr_2>
     (which should be a sum or an equation) by <expr_1>.  If <expr_1>
     is not itself a sum then this form is equivalent to `multthru
     (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Function: nounify (<f>)
     Returns the noun form of the function name <f>.  This is needed if
     one wishes to refer to the name of a verb function as if it were a
     noun.  Note that some verb functions will return their noun forms
     if they can't be evaluated for certain arguments.  This is also
     the form returned if a function call is preceded by a quote.


 -- Function: nterms (<expr>)
     Returns the number of terms that <expr> would have if it were
     fully expanded out and no cancellations or combination of terms
     occurred.  Note that expressions like `sin (<expr>)', `sqrt
     (<expr>)', `exp (<expr>)', etc.  count as just one term regardless
     of how many terms <expr> has (if it is a sum).


 -- Function: op (<expr>)
     Returns the main operator of the expression <expr>.  `op (<expr>)'
     is equivalent to `part (<expr>, 0)'.

     `op' returns a string if the main operator is a built-in or
     user-defined prefix, binary or n-ary infix, postfix, matchfix, or
     nofix operator.  Otherwise `op' returns a symbol.

     `op' observes the value of the global flag `inflag'.

     `op' evaluates it argument.

     See also `args'.

     Examples:

          (%i1) ?stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"


 -- Function: operatorp (<expr>, <op>)
 -- Function: operatorp (<expr>, [<op_1>, ..., <op_n>])
     `operatorp (<expr>, <op>)' returns `true' if <op> is equal to the
     operator of <expr>.

     `operatorp (<expr>, [<op_1>, ..., <op_n>])' returns `true' if some
     element <op_1>, ..., <op_n> is equal to the operator of <expr>.


 -- Function: optimize (<expr>)
     Returns an expression that produces the same value and side
     effects as <expr> but does so more efficiently by avoiding the
     recomputation of common subexpressions.  `optimize' also has the
     side effect of "collapsing" its argument so that all common
     subexpressions are shared.  Do `example (optimize)' for examples.


 -- Option variable: optimprefix
     Default value: `%'

     `optimprefix' is the prefix used for generated symbols by the
     `optimize' command.


 -- Function: ordergreat (<v_1>, ..., <v_n>)
     Sets up aliases for the variables <v_1>, ..., <v_n> such that
     <v_1> > <v_2> > ...  > <v_n>, and <v_n> > any other variable not
     mentioned as an argument.

     See also `orderless'.


 -- Function: ordergreatp (<expr_1>, <expr_2>)
     Returns `true' if <expr_2> precedes <expr_1> in the ordering set
     up with the `ordergreat' function.


 -- Function: orderless (<v_1>, ..., <v_n>)
     Sets up aliases for the variables <v_1>, ..., <v_n> such that
     <v_1> < <v_2> < ...  < <v_n>, and <v_n> < any other variable not
     mentioned as an argument.

     Thus the complete ordering scale is: numerical constants <
     declared constants < declared scalars < first argument to
     `orderless' < ...  < last argument to `orderless' < variables
     which begin with A < ...  < variables which begin with Z < last
     argument to `ordergreat' <  ... < first argument to `ordergreat' <
     declared `mainvar's.

     See also `ordergreat' and `mainvar'.


 -- Function: orderlessp (<expr_1>, <expr_2>)
     Returns `true' if <expr_1> precedes <expr_2> in the ordering set
     up by the `orderless' command.


 -- Function: part (<expr>, <n_1>, ..., <n_k>)
     Returns parts of the displayed form of `expr'. It obtains the part
     of `expr' as specified by the indices <n_1>, ..., <n_k>.  First
     part <n_1> of `expr' is obtained, then part <n_2> of that, etc.
     The result is part <n_k> of ... part <n_2> of part <n_1> of `expr'.

     `part' can be used to obtain an element of a list, a row of a
     matrix, etc.

     If the last argument to a part function is a list of indices then
     several subexpressions are picked out, each one corresponding to an
     index of the list.  Thus `part (x + y + z, [1, 3])' is `z+x'.

     `piece' holds the last expression selected when using the part
     functions.  It is set during the execution of the function and thus
     may be referred to in the function itself as shown below.

     If `partswitch' is set to `true' then `end' is returned when a
     selected part of an expression doesn't exist, otherwise an error
     message is given.

     Example: `part (z+2*y, 2, 1)' yields 2.

     `example (part)' displays additional examples.


 -- Function: partition (<expr>, <x>)
     Returns a list of two expressions.  They are (1) the factors of
     <expr> (if it is a product), the terms of <expr> (if it is a sum),
     or the list (if it is a list) which don't contain var and, (2) the
     factors, terms, or list which do.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Option variable: partswitch
     Default value: `false'

     When `partswitch' is `true', `end' is returned when a selected
     part of an expression doesn't exist, otherwise an error message is
     given.


 -- Function: pickapart (<expr>, <n>)
     Assigns intermediate expression labels to subexpressions of <expr>
     at depth <n>, an integer.  Subexpressions at greater or lesser
     depths are not assigned labels.  `pickapart' returns an expression
     in terms of intermediate expressions equivalent to the original
     expression <expr>.

     See also `part', `dpart', `lpart', `inpart', and `reveal'.

     Examples:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- System variable: piece
     Holds the last expression selected when using the `part' functions.
     It is set during the execution of the function and thus may be
     referred to in the function itself.


 -- Function: polarform (<expr>)
     Returns an expression `r %e^(%i theta)' equivalent to <expr>, such
     that `r' and `theta' are purely real.


 -- Function: powers (<expr>, <x>)
     Gives the powers of <x> occuring in <expr>.

     `load (powers)' loads this function.


 -- Function: product (<expr>, <i>, <i_0>, <i_1>)
     Returns the product of the values of `expr' as the index <i>
     varies from <i_0> to <i_1>.  The evaluation is similar to that of
     `sum'.

     If <i_1> is one less than <i_0>, the product is an "empty product"
     and `product' returns 1 rather than reporting an error.  See also
     `prodhack'.

     Maxima does not simplify products.

     Example:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)


 -- Function: realpart (<expr>)
     Returns the real part of <expr>. `realpart' and `imagpart' will
     work on expressions involving trigonometic and hyperbolic
     functions, as well as square root, logarithm, and exponentiation.


 -- Function: rectform (<expr>)
     Returns an expression `a + b %i' equivalent to <expr>, such that
     <a> and <b> are purely real.


 -- Function: rembox (<expr>, unlabelled)
 -- Function: rembox (<expr>, <label>)
 -- Function: rembox (<expr>)
     Removes boxes from <expr>.

     `rembox (<expr>, unlabelled)' removes all unlabelled boxes from
     <expr>.

     `rembox (<expr>, <label>)' removes only boxes bearing <label>.

     `rembox (<expr>)' removes all boxes, labelled and unlabelled.

     Boxes are drawn by the `box', `dpart', and `lpart' functions.

     Examples:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Function: sum (<expr>, <i>, <i_0>, <i_1>)
     Represents a summation of the values of <expr> as the index <i>
     varies from <i_0> to <i_1>.  Sums may be differentiated, added,
     subtracted, or multiplied with some automatic simplification being
     performed.  The noun form `'sum' is displayed in sigma notation.

     If the upper and lower limits differ by an integer, the summand
     <expr> is evaluated for each value of the summation index <i>, and
     the results are added together.

     Otherwise, if the `simpsum' is `true' the summation is simplified.
     Simplification may sometimes yield a closed form.  If the
     evaluation flag `simpsum' is `false' or simplification fails, the
     result is a noun form `'sum'.

     `sum' evaluates <i_0> and <i_1> and quotes <i>.  The summand
     <expr> is quoted under some circumstances, or evaluated to greater
     or lesser degree in others.

     If <i_1> is one less than <i_0>, the sum is a considered an "empty
     sum" and `sum' returns 0 rather than reporting an error.  See also
     `sumhack'.

     When the evaluation flag `cauchysum' is `true', the product of
     summations is expressed as a Cauchy product, in which the index of
     the inner summation is a function of the index of the outer one,
     rather than varying independently.

     The global variable `genindex' is the alphabetic prefix used to
     generate the next index of summation, when an automatically
     generated index is needed.

     `gensumnum' is the numeric suffix used to generate the next index
     of summation, when an automatically generated index is needed.
     When `gensumnum' is `false', an automatically-generated index is
     only `genindex' with no numeric suffix.

     See also `sumcontract', `intosum', `bashindices', `niceindices',
     `nouns', and `evflag'.

     Examples:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) ev (sum (2^i + i^2, i, 0, n), simpsum);
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o5)             2      + --------------- - 1
                                            6
          (%i6) ev (sum (1/3^i, i, 1, inf), simpsum);
                                          1
          (%o6)                           -
                                          2
          (%i7) ev (sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum);
                                            2
          (%o7)                        5 %pi


 -- Function: lsum (<expr>, <x>, <L>)
     Represents the sum of <expr> for each element <x> in <L>.

     A noun form `'lsum' is returned if the argument <L> does not
     evaluate to a list.

     Examples:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Function: verbify (<f>)
     Returns the verb form of the function name <f>.

     See also `verb', `noun', and `nounify'.

     Examples:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplification,  Next: Plotting,  Prev: Expressions,  Up: Top

7 Simplification
****************

* Menu:

* Definitions for Simplification::


File: maxima.info,  Node: Definitions for Simplification,  Prev: Simplification,  Up: Simplification

7.1 Definitions for Simplification
==================================

* Menu:

 -- System variable: askexp
     When `asksign' is called, `askexp' is the expression `asksign' is
     testing.

     At one time, it was possible for a user to inspect `askexp' by
     entering a Maxima break with control-A.

 -- Function: askinteger (<expr>, integer)
 -- Function: askinteger (<expr>)
 -- Function: askinteger (<expr>, even)
 -- Function: askinteger (<expr>, odd)
     `askinteger (<expr>, integer)' attempts to determine from the
     `assume' database whether <expr> is an integer.  `askinteger'
     prompts the user if it cannot tell otherwise, and attempt to
     install the information in the database if possible.  `askinteger
     (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

     `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
     likewise attempt to determine if <expr> is an even integer or odd
     integer, respectively.


 -- Function: asksign (<expr>)
     First attempts to determine whether the specified expression is
     positive, negative, or zero.  If it cannot, it asks the user the
     necessary questions to complete its deduction.  The user's answer
     is recorded in the data base for the duration of the current
     computation. The return value of `asksign' is one of `pos', `neg',
     or `zero'.


 -- Function: demoivre (<expr>)
 -- Option variable: demoivre
     The function `demoivre (expr)' converts one expression without
     setting the global variable `demoivre'.

     When the variable `demoivre' is `true', complex exponentials are
     converted into equivalent expressions in terms of circular
     functions: `exp (a + b*%i)' simplifies to `%e^a * (cos(b) +
     %i*sin(b))' if `b' is free of `%i'.  `a' and `b' are not expanded.

     The default value of `demoivre' is `false'.

     `exponentialize' converts circular and hyperbolic functions to
     exponential form.  `demoivre' and `exponentialize' cannot both be
     true at the same time.


 -- Option variable: domain
     Default value: `real'

     When `domain' is set to `complex', `sqrt (x^2)' will remain `sqrt
     (x^2)' instead of returning `abs(x)'.


 -- Function: expand (<expr>)
 -- Function: expand (<expr>, <p>, <n>)
     Expand expression <expr>.  Products of sums and exponentiated sums
     are multiplied out, numerators of rational expressions which are
     sums are split into their respective terms, and multiplication
     (commutative and non-commutative) are distributed over addition at
     all levels of <expr>.

     For polynomials one should usually use `ratexpand' which uses a
     more efficient algorithm.

     `maxnegex' and `maxposex' control the maximum negative and
     positive exponents, respectively, which will expand.

     `expand (<expr>, <p>, <n>)' expands <expr>, using <p> for
     `maxposex' and <n> for `maxnegex'.  This is useful in order to
     expand part but not all of an expression.

     `expon' - the exponent of the largest negative power which is
     automatically expanded (independent of calls to `expand').  For
     example if `expon' is 4 then `(x+1)^(-5)' will not be
     automatically expanded.

     `expop' - the highest positive exponent which is automatically
     expanded.  Thus `(x+1)^3', when typed, will be automatically
     expanded only if `expop' is greater than or equal to 3.  If it is
     desired to have `(x+1)^n' expanded where `n' is greater than
     `expop' then executing `expand ((x+1)^n)' will work only if
     `maxposex' is not less than `n'.

     The `expand' flag used with `ev' causes expansion.

     The file `simplification/facexp.mac' contains several related
     functions (in particular `facsum', `factorfacsum' and
     `collectterms', which are autoloaded) and variables
     (`nextlayerfactor' and `facsum_combine') that provide the user
     with the ability to structure expressions by controlled expansion.
     Brief function descriptions are available in
     `simplification/facexp.usg'.  A demo is available by doing
     `demo("facexp")'.


 -- Function: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expands expression `expr' with respect to the variables <x_1>,
     ..., <x_n>.  All products involving the variables appear
     explicitly.  The form returned will be free of products of sums of
     expressions that are not free of the variables.   <x_1>, ..., <x_n>
     may be variables, operators, or expressions.

     By default, denominators are not expanded, but this can be
     controlled by means of the switch `expandwrt_denom'.

     This function is autoloaded from `simplification/stopex.mac'.


 -- Option variable: expandwrt_denom
     Default value: `false'

     `expandwrt_denom' controls the treatment of rational expressions
     by `expandwrt'.  If `true', then both the numerator and
     denominator of the expression will be expanded according to the
     arguments of `expandwrt', but if `expandwrt_denom' is `false',
     then only the numerator will be expanded in that way.


 -- Function: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     is similar to `expandwrt', but treats expressions that are
     products somewhat differently.  `expandwrt_factored' expands only
     on those factors of `expr' that contain the variables <x_1>, ...,
     <x_n>.

     This function is autoloaded from `simplification/stopex.mac'.


 -- Option variable: expon
     Default value: 0

     `expon' is the exponent of the largest negative power which is
     automatically expanded (independent of calls to `expand').  For
     example, if `expon' is 4 then `(x+1)^(-5)' will not be
     automatically expanded.


 -- Function: exponentialize (<expr>)
 -- Option variable: exponentialize
     The function `exponentialize (expr)' converts circular and
     hyperbolic functions in <expr> to exponentials, without setting
     the global variable `exponentialize'.

     When the variable `exponentialize' is `true', all circular and
     hyperbolic functions are converted to exponential form.  The
     default value is `false'.

     `demoivre' converts complex exponentials into circular functions.
     `exponentialize' and `demoivre' cannot both be true at the same
     time.


 -- Option variable: expop
     Default value: 0

     `expop' is the highest positive exponent which is automatically
     expanded.  Thus `(x + 1)^3', when typed, will be automatically
     expanded only if `expop' is greater than or equal to 3.  If it is
     desired to have `(x + 1)^n' expanded where `n' is greater than
     `expop' then executing `expand ((x + 1)^n)' will work only if
     `maxposex' is not less than n.


 -- Option variable: factlim
     Default value: -1

     `factlim' specifies the highest factorial which is automatically
     expanded.  If it is -1 then all integers are expanded.


 -- Function: intosum (<expr>)
     Moves multiplicative factors outside a summation to inside.  If
     the index is used in the outside expression, then the function
     tries to find a reasonable index, the same as it does for
     `sumcontract'.  This is essentially the reverse idea of the
     `outative' property of summations, but note that it does not
     remove this property, it only bypasses it.

     In some cases, a `scanmap (multthru, <expr>)' may be necessary
     before the `intosum'.


 -- Declaration: lassociative
     `declare (g, lassociative)' tells the Maxima simplifier that `g'
     is left-associative.  E.g., `g (g (a, b), g (c, d))' will simplify
     to `g (g (g (a, b), c), d)'.


 -- Declaration: linear
     One of Maxima's operator properties.  For univariate `f' so
     declared, "expansion" `f(x + y)' yields `f(x) + f(y)', `f(a*x)'
     yields `a*f(x)' takes place where `a' is a "constant".  For
     functions of two or more arguments, "linearity" is defined to be
     as in the case of `sum' or `integrate', i.e., `f (a*x + b, x)'
     yields `a*f(x,x) + b*f(1,x)' for `a' and `b' free of `x'.

     `linear' is equivalent to `additive' and `outative'.  See also
     `opproperties'.


 -- Declaration: mainvar
     You may declare variables to be `mainvar'.  The ordering scale for
     atoms is essentially: numbers < constants (e.g., `%e', `%pi') <
     scalars < other variables < mainvars.  E.g., compare `expand
     ((X+Y)^4)' with `(declare (x, mainvar), expand ((x+y)^4))'.
     (Note: Care should be taken if you elect to use the above feature.
     E.g., if you subtract an expression in which `x' is a `mainvar'
     from one in which `x' isn't a `mainvar', resimplification e.g.
     with `ev (expr, simp)' may be necessary if cancellation is to
     occur.  Also, if you save an expression in which `x' is a
     `mainvar', you probably should also save `x'.)


 -- Option variable: maxapplydepth
     Default value: 10000

     `maxapplydepth' is the maximum depth to which `apply1' and
     `apply2' will delve.


 -- Option variable: maxapplyheight
     Default value: 10000

     `maxapplyheight' is the maximum height to which `applyb1' will
     reach before giving up.


 -- Option variable: maxnegex
     Default value: 1000

     `maxnegex' is the largest negative exponent which will be expanded
     by the `expand' command (see also `maxposex').


 -- Option variable: maxposex
     Default value: 1000

     `maxposex' is the largest exponent which will be expanded with the
     `expand' command (see also `maxnegex').


 -- Declaration: multiplicative
     `declare (f, multiplicative)' tells the Maxima simplifier that `f'
     is multiplicative.

       1. If `f' is univariate, whenever the simplifier encounters `f'
          applied to a product, `f' distributes over that product.
          E.g., `f(x*y)' simplifies to `f(x)*f(y)'.

       2. If `f' is a function of 2 or more arguments, multiplicativity
          is defined as multiplicativity in the first argument to `f',
          e.g., `f (g(x) * h(x), x)' simplifies to `f (g(x) ,x) * f
          (h(x), x)'.

     This simplification does not occur when `f' is applied to
     expressions of the form `product (x[i], i, m, n)'.


 -- Option variable: negdistrib
     Default value: `true'

     When `negdistrib' is `true', -1 distributes over an expression.
     E.g., `-(x + y)' becomes `- y - x'.  Setting it to `false' will
     allow `- (x + y)' to be displayed like that.  This is sometimes
     useful but be very careful: like the `simp' flag, this is one flag
     you do not want to set to `false' as a matter of course or
     necessarily for other than local use in your Maxima.


 -- Option variable: negsumdispflag
     Default value: `true'

     When `negsumdispflag' is `true', `x - y' displays as `x - y'
     instead of as `- y + x'.  Setting it to `false' causes the special
     check in display for the difference of two expressions to not be
     done.  One application is that thus `a + %i*b' and `a - %i*b' may
     both be displayed the same way.


 -- Special symbol: noeval
     `noeval' suppresses the evaluation phase of `ev'.  This is useful
     in conjunction with other switches and in causing expressions to
     be resimplified without being reevaluated.


 -- Declaration: noun
     `noun' is one of the options of the `declare' command.  It makes a
     function so declared a "noun", meaning that it won't be evaluated
     automatically.


 -- Option variable: noundisp
     Default value: `false'

     When `noundisp' is `true', nouns display with a single quote.
     This switch is always `true' when displaying function definitions.


 -- Special symbol: nouns
     `nouns' is an `evflag'. When used as an option to the `ev' command,
     `nouns' converts all "noun" forms occurring in the expression
     being `ev''d to "verbs", i.e., evaluates them.  See also `noun',
     `nounify', `verb', and `verbify'.


 -- Special symbol: numer
     `numer' causes some mathematical functions (including
     exponentiation) with numerical arguments to be evaluated in
     floating point. It causes variables in `expr' which have been
     given numervals to be replaced by their values.  It also sets the
     `float' switch on.


 -- Function: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declares the variables `x_1', ..., <x_n> to have numeric values
     equal to `expr_1', ..., `expr_n'.  The numeric value is evaluated
     and substituted for the variable in any expressions in which the
     variable occurs if the `numer' flag is `true'. See also `ev'.

     The expressions `expr_1', ..., `expr_n' can be any expressions,
     not necessarily numeric.

 -- System variable: opproperties
     `opproperties' is the list of the special operator properties
     recognized by the Maxima simplifier: `linear', `additive',
     `multiplicative', `outative', `evenfun', `oddfun', `commutative',
     `symmetric', `antisymmetric', `nary', `lassociative',
     `rassociative'.


 -- Option variable: opsubst
     Default value: `true'

     When `opsubst' is `false', `subst' does not attempt to substitute
     into the operator of an expression.  E.g., `(opsubst: false, subst
     (x^2, r, r+r[0]))' will work.


 -- Declaration: outative
     `declare (f, outative)' tells the Maxima simplifier that constant
     factors in the argument of `f' can be pulled out.

       1. If `f' is univariate, whenever the simplifier encounters `f'
          applied to a product, that product will be partitioned into
          factors that are constant and factors that are not and the
          constant factors will be pulled out.  E.g., `f(a*x)' will
          simplify to `a*f(x)' where `a' is a constant.  Non-atomic
          constant factors will not be pulled out.

       2. If `f' is a function of 2 or more arguments, outativity is
          defined as in the case of `sum' or `integrate', i.e., `f
          (a*g(x), x)' will simplify to `a * f(g(x), x)' for `a' free
          of `x'.

     `sum', `integrate', and `limit' are all `outative'.


 -- Declaration: posfun
     `declare (f, posfun)' declares `f' to be a positive function.  `is
     (f(x) > 0)' yields `true'.


 -- Option variable: prodhack
     Default value: `false'

     When `prodhack' is `true', the identity `product (f(i), i, a, b) =
     1/product (f(i), i, b+1, a-1)' is applied if `a' is greater than
     `b'.  For example, `product (f(i), i, 3, 1)' yields `1/f(2)'.


 -- Function: radcan (<expr>)
     Simplifies <expr>, which can contain logs, exponentials, and
     radicals, by converting it into a form which is canonical over a
     large class of expressions and a given ordering of variables; that
     is, all functionally equivalent forms are mapped into a unique
     form.  For a somewhat larger class of expressions, `radcan'
     produces a regular form.  Two equivalent expressions in this class
     do not necessarily have the same appearance, but their difference
     can be simplified by `radcan' to zero.

     For some expressions `radcan' is quite time consuming.  This is
     the cost of exploring certain relationships among the components of
     the expression for simplifications based on factoring and
     partial-fraction expansions of exponents.

     When `%e_to_numlog' is `true', `%e^(r*log(expr))' simplifies to
     `expr^r' if `r' is a rational number.

     When `radexpand' is `false', certain transformations are inhibited.
     `radcan (sqrt (1-x))' remains `sqrt (1-x)' and is not simplified
     to `%i sqrt (x-1)'.  `radcan (sqrt (x^2 - 2*x + 11))' remains
     `sqrt (x^2 - 2*x + 1)' and is not simplified to `x - 1'.

     `example (radcan)' displays some examples.


 -- Option variable: radexpand
     Default value: `true'

     `radexpand' controls some simplifications of radicals.

     When `radexpand' is `all', causes nth roots of factors of a
     product which are powers of n to be pulled outside of the radical.
     E.g. if `radexpand' is `all', `sqrt (16*x^2)' simplifies to `4*x'.

     More particularly, consider `sqrt (x^2)'.
        * If `radexpand' is `all' or `assume (x > 0)' has been executed,
          `sqrt(x^2)' simplifies to `x'.

        * If `radexpand' is `true' and `domain' is `real' (its default),
          `sqrt(x^2)' simplifies to `abs(x)'.

        * If `radexpand' is `false', or `radexpand' is `true' and
          `domain' is `complex', `sqrt(x^2)' is not simplified.

     Note that `domain' only matters when `radexpand' is `true'.


 -- Option variable: radsubstflag
     Default value: `false'

     `radsubstflag', if `true', permits `ratsubst' to make
     substitutions such as `u' for `sqrt (x)' in `x'.


 -- Declaration: rassociative
     `declare (g, rassociative)' tells the Maxima simplifier that `g'
     is right-associative.  E.g., `g(g(a, b), g(c, d))' simplifies to
     `g(a, g(b, g(c, d)))'.


 -- Function: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Sequential Comparative Simplification (method due to Stoute).
     `scsimp' attempts to simplify <expr> according to the rules
     <rule_1>, ..., <rule_n>.  If a smaller expression is obtained, the
     process repeats.  Otherwise after all simplifications are tried,
     it returns the original answer.

     `example (scsimp)' displays some examples.


 -- Option variable: simpsum
     Default value: `false'

     When `simpsum' is `true', the result of a `sum' is simplified.
     This simplification may sometimes be able to produce a closed
     form.  If `simpsum' is `false' or if the quoted form `'sum' is
     used, the value is a sum noun form which is a representation of
     the sigma notation used in mathematics.


 -- Function: sumcontract (<expr>)
     Combines all sums of an addition that have upper and lower bounds
     that differ by constants. The result is an expression containing
     one summation for each set of such summations added to all
     appropriate extra terms that had to be extracted to form this sum.
     `sumcontract' combines all compatible sums and uses one of the
     indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.

     It may be necessary to do an `intosum (<expr>)' before the
     `sumcontract'.


 -- Option variable: sumexpand
     Default value: `false'

     When `sumexpand' is `true', products of sums and exponentiated
     sums simplify to nested sums.

     See also `cauchysum'.

     Examples:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Option variable: sumhack
     Default value: `false'

     When `sumhack' is `true', the identity `sum (f(i), i, a, b) = -
     sum (f(i), i, b+1, a-1)' is applied if `a' is greater than `b'.
     For example, `(sumhack: true, sum (f(i), i, 3, 1))' yields `-f(2)'.


 -- Option variable: sumsplitfact
     Default value: `true'

     When `sumsplitfact' is `false', `minfactorial' is applied after a
     `factcomb'.


 -- Declaration: symmetric
     `declare (h, symmetric)' tells the Maxima simplifier that `h' is a
     symmetric function.  E.g., `h (x, z, y)' simplifies to `h (x, y,
     z)'.

     `commutative' is synonymous with `symmetric'.


 -- Function: unknown (<expr>)
     Returns `true' if and only if <expr> contains an operator or
     function not recognized by the Maxima simplifier.



File: maxima.info,  Node: Plotting,  Next: Input and Output,  Prev: Simplification,  Up: Top

8 Plotting
**********

* Menu:

* Definitions for Plotting::


File: maxima.info,  Node: Definitions for Plotting,  Prev: Plotting,  Up: Plotting

8.1 Definitions for Plotting
============================

 -- Option variable: in_netmath
     Default value: `false'

     When `in_netmath' is `true', `plot3d' prints OpenMath output to
     the console if `plot_format' is `openmath'; otherwise `in_netmath'
     (even if `true') has no effect.

     `in_netmath' has no effect on `plot2d'.


 -- Function: openplot_curves (<list>, <rest_options>)
     Takes a list of curves such as
          [[x1, y1, x2, y2, ...], [u1, v1, u2, v2, ...], ..]
     or
          [[[x1, y1], [x2, y2], ...], ...]
     and plots them.  This is similar to xgraph_curves, but uses the
     open plot routines.  Addtional symbol arguments may be given such
     as `"{xrange -3 4}"' The following plots two curves, using big
     points, labeling the first one `jim' and the second one `jane'.
          openplot_curves ([["{plotpoints 1} {pointsize 6} {label jim}
                {text {xaxislabel {joe is nice}}}"],
                [1, 2, 3, 4, 5, 6, 7, 8],
                ["{label jane} {color pink }"], [3, 1, 4, 2, 5, 7]]);

     Some other special keywords are `xfun', `color', `plotpoints',
     `linecolors', `pointsize', `nolines', `bargraph', `labelposition',
     `xaxislabel', and `yaxislabel'.


 -- Function: plot2d (<expr>, <range>, ..., <options>, ...)
 -- Function: plot2d (<parametric_expr>)
 -- Function: plot2d (<discrete_expr>)
 -- Function: plot2d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>)
 -- Function: plot2d ([<expr_1>, ..., <expr_n>], <x_range>)
 -- Function: plot2d (<expr>, <x_range>, <y_range>)
 -- Function: plot2d (<expr>, <x_range>)
     Displays a plot of one or more expressions as a function of one
     variable.

     In all cases, <expr> is an expression to be plotted on the
     vertical axis as a function of one variable.  <x_range>, the range
     of the horizontal axis, is a list of the form `[<variable>, <min>,
     <max>]', where <variable> is a variable which appears in <expr>.
     <y_range>, the range of the vertical axis, is a list of the form
     `[y, <min>, <max>]'.

     `plot2d (<expr>, <x_range>)' plots <expr> as a function of the
     variable named in <x_range>, over the range specified in <x_range>.
     If the vertical range is not otherwise specified by
     `set_plot_option', it is chosen automatically.  All options are
     assumed to have default values unless otherwise specified by
     `set_plot_option'.

     `plot2d (<expr>, <x_range>, <y_range>)' plots <expr> as a function
     of the variable named in <x_range>, over the range specified in
     <x_range>.  The vertical range is set to <y_range>.  All options
     are assumed to have default values unless otherwise specified by
     `set_plot_option'.

     `plot2d ([<expr_1>, ..., <expr_n>], <x_range>)' plots <expr_1>,
     ..., <expr_n> as a function of the variable named in <x_range>,
     over the range specified in <x_range>.  If the vertical range is
     not otherwise specified by `set_plot_option', it is chosen
     automatically.  All options are assumed to have default values
     unless otherwise specified by `set_plot_option'.

     `plot2d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>)' plots
     <expr_1>, ..., <expr_n> as a function of the variable named in
     <x_range>, over the range specified in <x_range>.  The vertical
     range is set to <y_range>.  All options are assumed to have
     default values unless otherwise specified by `set_plot_option'.

     Examples:

          (%i1) plot2d (sin(x), [x, -5, 5])$
          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Anywhere there may be an ordinary expression, there may be a
     parametric expression: <parametric_expr> is a list of the form
     `[parametric, <x_expr>, <y_expr>, <t_range>, <options>]'.  Here
     <x_expr> and <y_expr> are expressions of 1 variable <var> which is
     the first element of the range <trange>.  The plot is of the path
     traced out by the pair `[<x_expr>, <y_expr>]' as <var> varies in
     <trange>.

     In the following example, we plot a circle, then we do the plot
     with only a few points used, so that we get a star, and finally we
     plot this together with an ordinary function of X.

     Examples:

        * Plot a circle with a parametric plot.
               (%i1) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                       [nticks, 80]])$

        * Plot a star: join eight points on the circumference of a
          circle.
               (%i2) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                       [nticks, 8]])$

        * Plot a cubic polynomial with an ordinary plot and a circle
          with a parametric plot.
               (%i3) plot2d ([x^3 + 2, [parametric, cos(t), sin(t), [t, -5, 5],
                       [nticks, 80]]], [x, -3, 3])$

     Discrete expressions may also be used instead or ordinary or
     parametric expressions: <discrete_expr> is a list of the form
     `[discrete, <x_list>, <y_list>]' or `[discrete, <xy_list>]', where
     <xy_list> is a list of `[<x>,<y>]' pairs.

     Examples:

        * Create some lists.
               (%i1) xx:makelist(x,x,0,10)$
               (%i2) yy:makelist(exp(-x*1.0),x,0,10)$
               (%i3) xy:makelist([x,x*x],x,0,5)$

        * Plot with line segments.
               (%i4) plot2d([discrete,xx,yy])$

        * Plot with line segments, using a list of pairs.
               (%i5) plot2d([discrete,xy])$

        * Plot with points.
               (%i6) plot2d([discrete,xx,yy],[gnuplot_curve_styles,["with points"]])$

        * Plot the curve `cos(<x>)' using lines and (<xx>,<yy>) using
          points.
               plot2d([cos(x),[discrete,xx,yy]],[x,0,10],[gnuplot_curve_styles,["with lines","with points pointsize 3"]])$

     See also `plot_options', which describes plotting options and has
     more examples.


 -- Function: xgraph_curves (<list>)
     graphs the list of `point sets' given in list by using xgraph.

     A point set may be of the form

          [x0, y0, x1, y1, x2, y2, ...]
     or
          [[x0, y0], [x1, y1], ...]
     A point set may also contain symbols which give labels or other
     information.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     graph the three point sets as three curves.

          pt_set: append (["NoLines: True", "LargePixels: true"], [x0, y0, x1, y1, ...]);

     would make the point set [and subsequent ones], have no lines
     between points, and to use large pixels.  See the man page on
     xgraph for more options to specify.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     would make there be a "label" of "x^2+y" for this particular point
     set.    The `"' at the beginning is what tells xgraph this is a
     label.

          pt_set: append ([concat ("TitleText: Sample Data")], [x0, ...])$

     would make the main title of the plot be "Sample Data" instead of
     "Maxima Plot".

     To make a bar graph with bars which are 0.2 units wide, and to
     plot two possibly different such bar graphs:
          xgraph_curves ([append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
              create_list ([i - .2, i^2], i, 1, 3)),
              append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
              create_list ([i + .2, .7*i^2], i, 1, 3))]);
     A temporary file `xgraph-out' is used.


 -- System variable: plot_options
     Elements of this list state the default options for plotting.  If
     an option is present in a `plot2d' or `plot3d' call, that value
     takes precedence over the default option.  Otherwise, the value in
     `plot_options' is used.  Default options are assigned by
     `set_plot_option'.

     Each element of `plot_options' is a list of two or more items.
     The first item is the name of an option, and the remainder
     comprises the value or values assigned to the option.  In some
     cases the, the assigned value is a list, which may comprise
     several items.

     The plot options which are recognized by `plot2d' and `plot3d' are
     the following:

        * Option: `plot_format' determines which plotting package is
          used by `plot2d' and `plot3d'.

             * Default value: `gnuplot' Gnuplot is the default, and
               most advanced, plotting package. It requires an external
               gnuplot installation.

             * Value: `mgnuplot' Mgnuplot is a Tk-based wrapper around
               gnuplot. It is included in the Maxima distribution.
               Mgnuplot offers a rudimentary GUI for gnuplot, but has
               fewer overall features than the plain gnuplot interface.
               Mgnuplot requires an external gnuplot installation and
               Tcl/Tk.

             * Value: `openmath' Openmath is a Tcl/Tk GUI plotting
               program. It is included in the Maxima distribution.

             * Value: `ps' Generates simple PostScript files directly
               from Maxima. Much more sophisticated PostScript output
               can be generated from gnuplot, by leaving the option
               `plot_format' unspecified (to accept the default), and
               setting the option `gnuplot_term' to `ps'.

        * Option: `run_viewer' controls whether or not the appropriate
          viewer for the plot format should be run.

             * Default value: `true' Execute the viewer program.

             * Value: `false' Do not execute the viewer program.

        * `gnuplot_term' Sets the output terminal type for gnuplot.
             * Default value: `default' Gnuplot output is displayed in
               a separate graphical window.

             * Value: `dumb' Gnuplot output is displayed in the Maxima
               console by an "ASCII art" approximation to graphics.

             * Value: `ps' Gnuplot generates commands in the PostScript
               page description language.  If the option
               `gnuplot_out_file' is set to <filename>, gnuplot writes
               the PostScript commands to <filename>.  Otherwise, the
               commands are printed to the Maxima console.

        * Option: `gnuplot_out_file' Write gnuplot output to a file.

             * Default value: `false' No output file specified.

             * Value: <filename> Example: `[gnuplot_out_file,
               "myplot.ps"]' This example sends PostScript output to
               the file `myplot.ps' when used in conjunction with the
               PostScript gnuplot terminal.

        * Option: `x' The default horizontal range.
               [x, - 3, 3]
          Sets the horizontal range to [-3, 3].

        * Option: `y' The default vertical range.
               [y, - 3, 3]
          Sets the vertical range to [-3, 3].

        * Option: `t' The default range for the parameter in parametric
          plots.
               [t, 0, 10]
          Sets the parametric variable range to [0, 10].

        * Option: `nticks' Initial number of points used by the
          adaptive plotting routine.
               [nticks, 20]
          The default for `nticks' is 10.

        * Option: `adapt_depth' The maximum number of splittings used
          by the adaptive plotting routine.
               [adapt_depth, 5]
          The default for `adapt_depth' is 10.

        * Option: `grid' Sets the number of grid points to use in the
          x- and y-directions for three-dimensional plotting.
               [grid, 50, 50]
          sets the grid to 50 by 50 points. The default grid is 30 by
          30.

        * Option: `transform_xy' Allows transformations to be applied
          to three-dimensional plots.
               [transform_xy, false]
          The default `transform_xy' is `false'. If it is not `false',
          it should be the output of
               make_transform ([x, y, z], f1(x, y, z), f2(x, y, z), f3(x, y, z))$
          The `polar_xy' transformation is built in. It gives the same
          transformation as
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

        * Option: `colour_z' is specific to the `ps' plot format.
               [colour_z, true]
          The default value for `colour_z' is `false'.

        * Option: `view_direction' Specific to the `ps' plot format.
               [view_direction, 1, 1, 1]
          The default `view_direction' is [1, 1, 1].

     There are several plot options specific to gnuplot.  All of these
     options (except `gnuplot_pm3d') are raw gnuplot commands,
     specified as strings. Refer to the gnuplot documentation for more
     details.

        * Option: `gnuplot_pm3d' Controls the usage PM3D mode, which
          has advanced 3D features. PM3D is only available in gnuplot
          versions after 3.7. The default value for `gnuplot_pm3d' is
          `false'.

          Example:

               [gnuplot_pm3d, true]

        * Option: `gnuplot_preamble' Inserts gnuplot commands before
          the plot is drawn. Any valid gnuplot commands may be used.
          Multiple commands should be separated with a semi-colon. The
          example shown produces a log scale plot. The default value
          for `gnuplot_preamble' is the empty string `""'.

          Example:

               [gnuplot_preamble, "set log y"]

        * Option: `gnuplot_curve_titles' Controls the titles given in
          the plot key. The default value is `default', which
          automatically sets the title of each curve to the function
          plotted. If not `default', `gnuplot_curve_titles' should
          contain a list of strings. (To disable the plot key entirely,
          add `"set nokey"' to `gnuplot_preamble'.)

          Example:

               [gnuplot_curve_titles, ["my first function", "my second function"]]

        * Option: `gnuplot_curve_styles' A list of strings controlling
          the appearance of curves, i.e., color, width, dashing, etc.,
          to be sent to the gnuplot plot command. The default value is
          `["with lines 3", "with lines 1", "with lines 2", "with lines
          5", "with lines 4", "with lines 6", "with lines 7"]', which
          cycles through different colors. See the gnuplot
          documentation for `plot' for more information.

          Example:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Option: `gnuplot_default_term_command' The gnuplot command to
          set the terminal type for the default terminal. The default
          value is the empty string `""', i.e., use gnuplot's default.

          Example:

               [gnuplot_default_term_command, "set term x11"]

        * Option: `gnuplot_dumb_term_command' The gnuplot command to
          set the terminal type for the dumb terminal. The default
          value is `"set term dumb 79 22"', which makes the text output
          79 characters by 22 characters.

          Example:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Option: `gnuplot_ps_term_command' The gnuplot command to set
          the terminal type for the PostScript terminal. The default
          value is `"set size 1.5, 1.5;set term postscript eps enhanced
          color solid 24"', which sets the size to 1.5 times gnuplot's
          default, and the font size to 24, among other things. See the
          gnuplot documentation for `set term postscript' for more
          information.

          Example:

               [gnuplot_ps_term_command, "set term postscript eps enhanced color solid 18"]


     Examples:

        * Saves a plot of `sin(x)' to the file `sin.eps'.

          plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps], [gnuplot_out_file, "sin.eps"])$

        * Uses the y option to chop off singularities and the
          gnuplot_preamble option to put the key at the bottom of the
          plot instead of the top.

          plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10], [gnuplot_preamble, "set key bottom"])$

        * Uses a very complicated `gnuplot_preamble' to produce fancy
          x-axis labels.  (Note that the `gnuplot_preamble' string must
          be entered without any line breaks.)

          my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0,'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$
          plot2d ([cos(x), sin(x), tan(x), cot(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble]);

        * Uses a very complicated `gnuplot_preamble' to produce fancy
          x-axis labels, and produces PostScript output that takes
          advantage of the advanced text formatting available in
          gnuplot.  (Note that the `gnuplot_preamble' string must be
          entered without any line breaks.)

          my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' 6.283)"$
          plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi], [y, -2, 2],
              [gnuplot_preamble, my_preamble], [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * A three-dimensional plot using the gnuplot pm3d terminal.

          plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4], [grid, 50, 50], [gnuplot_pm3d, true])$

        * A three-dimensional plot without a mesh and with contours
          projected on the bottom plane.

          my_preamble: "set pm3d at s;unset surface;set contour;set cntrparam levels 20;unset key"$
          plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4], [grid, 50, 50],
              [gnuplot_pm3d, true], [gnuplot_preamble, my_preamble])$

        * A plot where the z-axis is represented by color only.  (Note
          that the `gnuplot_preamble' string must be entered without
          any line breaks.)

          plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"], [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Function: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Function: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>,
          <y_range>, ..., <options>, ...)
          plot3d (2^(-u^2 + v^2), [u, -5, 5], [v, -7, 7]);
     plots `z = 2^(-u^2+v^2)' with `u' and `v' varying in [-5,5] and
     [-7,7] respectively, and with <u> on the x axis, and `v' on the y
     axis.

     An example of the second pattern of arguments is
          plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)), y*sin(x/2)],
             [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     which plots a Moebius band, parametrized by the three expressions
     given as the first argument to `plot3d'.  An additional optional
     argument `['grid, 50, 15]' gives the grid number of rectangles in
     the x direction and y direction.

     This example shows a plot of the real part of `z^1/3'.

           plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
               ['grid, 12, 80], ['plot_format, ps],
               ['transform_xy, polar_to_xy], ['view_direction, 1, 1, 1.4],
               ['colour_z, true]);
     Here the `view_direction' option indicates the direction from
     which we take a projection.  We actually do this from infinitely
     far away, but parallel to the line from `view_direction' to the
     origin.  This is currently only used in `ps' plot_format, since
     the other viewers allow interactive rotating of the object.

     Another example is a Klein bottle:

          expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0) - 10.0;
          expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0);
          expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y));

          plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi], [y, -%pi, %pi], ['grid, 40, 40]);

     or a torus
          expr_1: cos(y)*(10.0+6*cos(x));
          expr_2: sin(y)*(10.0+6*cos(x));
          expr_3: -6*sin(x);

          plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi], [y, 0, 2*%pi], ['grid, 40, 40]);

     We can output to gnuplot too:

          plot3d (2^(x^2 - y^2), [x, -1, 1], [y, -2, 2], [plot_format, gnuplot]);

     Sometimes you may need to define a function to plot the
     expression.  All the arguments to plot3d are evaluated before
     being passed to plot3d, and so trying to make an expression which
     does just what you want may be difficult, and it is just easier to
     make a function.

          M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4], [1, 2, 3, 3])$
          f(x, y) := float (M [?round(x), ?round(y)])$
          plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     See `plot_options' for more examples.


 -- Function: make_transform (<vars>, <fx>, <fy>, <fz>)
     Returns a function suitable for the transform function in plot3d.
     Use with the plot option `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     is a transformation to polar coordinates.

 -- Function: plot2d_ps (<expr>, <range>)
     Writes to pstream a sequence of PostScript commands which plot
     <expr> over <range>.

     <expr> is an expression.  <range> is a list of the form `[<x>,
     <min>, <max>]' in which <x> is a variable which appears in <expr>.

     See also `closeps'.


 -- Function: closeps ()
     This should usually becalled at the end of a sequence of plotting
     commands.   It closes the current output stream <pstream>, and sets
     it to nil.   It also may be called at the start of a plot, to
     ensure pstream is closed if it was open.    All commands which
     write to pstream, open it if necessary.   `closeps' is separate
     from the other plotting commands, since we may want to plot 2
     ranges or superimpose several plots, and so must keep the stream
     open.

 -- Function: set_plot_option (<option>)
     Assigns one of the global variables for plotting.  <option> is
     specified as a list of two or more elements, in which the first
     element is one of the keywords on the `plot_options' list.

     `set_plot_option' evaluates its argument.  `set_plot_option'
     returns `plot_options' (after modifying one of its elements).

     See also `plot_options', `plot2d', and `plot3d'.

     Examples:

     Modify the `grid' and `x' values.  When a `plot_options' keyword
     has an assigned value, quote it to prevent evaluation.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [view_direction, 1, 1, 1], [colour_z, false],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [view_direction, 1, 1, 1], [colour_z, false],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


 -- Function: psdraw_curve (<ptlist>)
     Draws a curve connecting the points in <ptlist>.   The latter may
     be of the form `[x0, y0, x1, y1, ...]' or `[[x0, y0], [x1, y1],
     ...]'

     The function `join' is handy for taking a list of x's and a list
     of y's and splicing them together.

     <psdraw_curve> simply invokes the more primitive function
     <pscurve>.   Here is the definition:

          (defun $psdraw_curve (lis)
            (p "newpath")
            ($pscurve lis)
            (p "stroke"))


 -- Function: pscom (<cmd>)
     <cmd> is inserted in the PostScript file.  Example:
          pscom ("4.5 72 mul 5.5 72 mul translate 14 14 scale");



File: maxima.info,  Node: Input and Output,  Next: Floating Point,  Prev: Plotting,  Up: Top

9 Input and Output
******************

* Menu:

* Introduction to Input and Output::
* Files::
* Definitions for Input and Output::


File: maxima.info,  Node: Introduction to Input and Output,  Next: Files,  Prev: Input and Output,  Up: Input and Output

9.1 Introduction to Input and Output
====================================


File: maxima.info,  Node: Files,  Next: Definitions for Input and Output,  Prev: Introduction to Input and Output,  Up: Input and Output

9.2 Files
=========

A file is simply an area on a particular storage device which contains
data or text.  Files on the disks are figuratively grouped into
"directories".  A directory is just a list of files.  Commands which
deal with files are: `save', `load', `loadfile', `stringout', `batch',
`demo', `writefile', `closefile', and `appendfile'.


File: maxima.info,  Node: Definitions for Input and Output,  Prev: Files,  Up: Input and Output

9.3 Definitions for Input and Output
====================================

 -- System variable: _
     `_' is the most recent input expression (e.g., `%i1', `%i2',
     `%i3', ...).

     `_' is assigned the input before the input is simplified or
     evaluated.  However, the value of `_' is simplified (but not
     evaluated) when it is displayed.

     `_' is recognized by `batch', but not by `load'.

     See also `%'.

     Examples:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- System variable: %
     `%' is the output expression (e.g., `%o1', `%o2', `%o3', ...)
     most recently computed by Maxima, whether or not it was displayed.

     `%' is recognized by `batch', but not by `load'.

     See also `_', `%%', and `%th'.


 -- System variable: %%
     In a compound statement comprising two or more statements, `%%' is
     the value of the previous statement.  For example,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x), ev (prev, x=2) - ev (prev, x=1));

     yield the same result, namely `21/2'.

     A compound statement may comprise other compound statements.
     Whether a statement be simple or compound, `%%' is the value of
     the previous statement.  For example,

          block (block (a^n, %%*42), %%/6)

     yields `7*a^n'.

     Within a compound statement, the value of `%%' may be inspected at
     a break prompt, which is opened by executing the `break' function.
     For example, at the break prompt opened by

          block (a: 42, break ())$

     entering `%%;' yields `42'.

     At the first statement in a compound statement, or outside of a
     compound statement, `%%' is undefined.

     `%%' is recognized by both `batch' and `load'.

     See also `%'.


 -- Option variable: %edispflag
     Default value: `false'

     When `%edispflag' is `true', Maxima displays `%e' to a negative
     exponent as a quotient.  For example, `%e^-x' is displayed as
     `1/%e^x'.


 -- Function: %th (<i>)
     The value of the <i>'th previous output expression.  That is, if
     the next expression to be computed is the <n>'th output, `%th
     (<m>)' is the (<n> - <m>)'th output.

     `%th' is useful in `batch' files or for referring to a group of
     output expressions.  For example,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     sets `s' to the sum of the last ten output expressions.

     `%th' is recognized by `batch', but not by `load'.

     See also `%'.


 -- Special symbol: "?"
     As prefix to a function or variable name, `?' signifies that the
     name is a Lisp name, not a Maxima name.  For example, `?round'
     signifies the Lisp function `ROUND'.  See *Note Lisp and Maxima::
     for more on this point.

     The notation `? word' (a question mark followed a word, separated
     by whitespace) is equivalent to `describe ("word")'.


 -- Option variable: absboxchar
     Default value: `!'

     `absboxchar' is the character used to draw absolute value signs
     around expressions which are more than one line tall.


 -- Function: appendfile (<filename>)
     Appends a console transcript to <filename>.  `appendfile' is the
     same as `writefile', except that the transcript file, if it
     exists, is always appended.

     `closefile' closes the transcript file opened by `appendfile' or
     `writefile'.


 -- Function: batch (<filename>)
     Reads Maxima expressions from <filename> and evaluates them.
     `batch' searches for <filename> in the list `file_search_maxima'.
     See `file_search'.

     <filename> comprises a sequence of Maxima expressions, each
     terminated with `;' or `$'.  The special variable `%' and the
     function `%th' refer to previous results within the file.  The
     file may include `:lisp' constructs.  Spaces, tabs, and newlines
     in the file are ignored.  A suitable input file may be created by
     a text editor or by the `stringout' function.

     `batch' reads each input expression from <filename>, displays the
     input to the console, computes the corresponding output expression,
     and displays the output expression.  Input labels are assigned to
     the input expressions and output labels are assigned to the output
     expressions.  `batch' evaluates every input expression in the file
     unless there is an error.  If user input is requested (by
     `asksign' or `askinteger', for example) `batch' pauses to collect
     the requisite input and then continue.

     It may be possible to halt `batch' by typing `control-C' at the
     console.  The effect of `control-C' depends on the underlying Lisp
     implementation.

     `batch' has several uses, such as to provide a reservoir for
     working command lines, to give error-free demonstrations, or to
     help organize one's thinking in solving complex problems.

     `batch' evaluates its argument.  `batch' has no return value.

     See also `load', `batchload', and `demo'.


 -- Function: batchload (<filename>)
     Reads Maxima expressions from <filename> and evaluates them,
     without displaying the input or output expressions and without
     assigning labels to output expressions.  Printed output (such as
     produced by `print' or `describe') is displayed, however.

     The special variable `%' and the function `%th' refer to previous
     results from the interactive interpreter, not results within the
     file.  The file cannot include `:lisp' constructs.

     `batchload' returns the path of <filename>, as a string.
     `batchload' evaluates its argument.

     See also `batch' and `load'.


 -- Function: closefile ()
     Closes the transcript file opened by `writefile' or `appendfile'.


 -- Function: collapse (<expr>)
     Collapses <expr> by causing all of its common (i.e., equal)
     subexpressions to share (i.e., use the same cells), thereby saving
     space.  (`collapse' is a subroutine used by the `optimize'
     command.)  Thus, calling `collapse' may be useful after loading in
     a `save' file.  You can collapse several expressions together by
     using `collapse ([<expr_1>, ..., <expr_n>])'.  Similarly, you can
     collapse the elements of the array `A' by doing `collapse
     (listarray ('A))'.


 -- Function: concat (<arg_1>, <arg_2>, ...)
     Concatenates its arguments.  The arguments must evaluate to atoms.
     The return value is a symbol if the first argument is a symbol and
     a Maxima string otherwise.

     `concat' evaluates its arguments.  The single quote `'' prevents
     evaluation.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     A symbol constructed by `concat' may be assigned a value and
     appear in expressions.  The `::' (double colon) assignment
     operator evaluates its left-hand side.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Note that although `concat (1, 2)' looks like a number, it is a
     Maxima string.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Function: sconcat (<arg_1>, <arg_2>, ...)
     Concatenates its arguments into a string.  Unlike `concat', the
     arguments do not need to be atoms.

     The result is a Lisp string.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Function: disp (<expr_1>, <expr_2>, ...)
     is like `display' but only the value of the arguments are
     displayed rather than equations.  This is useful for complicated
     arguments which don't have names or where only the value of the
     argument is of interest and not the name.


 -- Function: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Function: dispcon (all)
     Displays the contraction properties of its arguments as were given
     to `defcon'.  `dispcon (all)' displays all the contraction
     properties which were defined.


 -- Function: display (<expr_1>, <expr_2>, ...)
     Displays equations whose left side is <expr_i> unevaluated, and
     whose right side is the value of the expression centered on the
     line.  This function is useful in blocks and `for' statements in
     order to have intermediate results displayed.  The arguments to
     `display' are usually atoms, subscripted variables, or function
     calls.  See also `disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done


 -- Option variable: display2d
     Default value: `true'

     When `display2d' is `false', the console display is a string
     (1-dimensional) form rather than a display (2-dimensional) form.


 -- Option variable: display_format_internal
     Default value: `false'

     When `display_format_internal' is `true', expressions are
     displayed without being transformed in ways that hide the internal
     mathematical representation.  The display then corresponds to what
     `inpart' returns rather than `part'.

     Examples:

          User     part       inpart
          a-b;      A - B     A + (- 1) B

                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   sqrt(X)    X

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Function: dispterms (<expr>)
     Displays <expr> in parts one below the other.  That is, first the
     operator of <expr> is displayed, then each term in a sum, or
     factor in a product, or part of a more general expression is
     displayed separately.  This is useful if <expr> is too large to be
     otherwise displayed.  For example if `P1', `P2', ...  are very
     large expressions then the display program may run out of storage
     space in trying to display `P1 + P2 + ...'  all at once.  However,
     `dispterms (P1 + P2 + ...)' displays `P1', then below it `P2',
     etc.  When not using `dispterms', if an exponential expression is
     too wide to be displayed as `A^B' it appears as `expt (A, B)' (or
     as `ncexpt (A, B)' in the case of `A^^B').


 -- Option variable: error_size
     Default value: 10

     `error_size' modifies error messages according to the size of
     expressions which appear in them.  If the size of an expression
     (as determined by the Lisp function `ERROR-SIZE') is greater than
     `error_size', the expression is replaced in the message by a
     symbol, and the symbol is assigned the expression.  The symbols
     are taken from the list `error_syms'.

     Otherwise, the expression is smaller than `error_size', and the
     expression is displayed in the message.

     See also `error' and `error_syms'.

     Example:

     The size of `U', as determined by `ERROR-SIZE', is 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Option variable: error_syms
     Default value: `[errexp1, errexp2, errexp3]'

     In error messages, expressions larger than `error_size' are
     replaced by symbols, and the symbols are set to the expressions.
     The symbols are taken from the list `error_syms'.  The first
     too-large expression is replaced by `error_syms[1]', the second by
     `error_syms[2]', and so on.

     If there are more too-large expressions than there are elements of
     `error_syms', symbols are constructed automatically, with the
     <n>-th symbol equivalent to `concat ('errexp, <n>)'.

     See also `error' and `error_size'.


 -- Function: expt (<a>, <b>)
     If an exponential expression is too wide to be displayed as
     `<a>^<b>' it appears as `expt (<a>, <b>)' (or as `ncexpt (<a>,
     <b>)' in the case of `<a>^^<b>').

     `expt' and `ncexpt' are not recognized in input.


 -- Option variable: exptdispflag
     Default value: `true'

     When `exptdispflag' is `true', Maxima displays expressions with
     negative exponents using quotients, e.g., `X^(-1)' as `1/X'.


 -- Function: filename_merge (<path>, <filename>)
     Constructs a modified path from <path> and <filename>.  If the
     final component of <path> is of the form `###.<something>', the
     component is replaced with `<filename>.<something>'.  Otherwise,
     the final component is simply replaced by <filename>.


 -- Function: file_search (<filename>)
 -- Function: file_search (<filename>, <pathlist>)
     `file_search' searches for the file <filename> and returns the
     path to the file (as a string) if it can be found; otherwise
     `file_search' returns `false'.  `file_search (<filename>)'
     searches in the default search directories, which are specified by
     the `file_search_maxima', `file_search_lisp', and
     `file_search_demo' variables.

     `file_search' first checks if the actual name passed exists,
     before attempting to match it to "wildcard" file search patterns.
     See `file_search_maxima' concerning file search patterns.

     The argument <filename> can be a path and file name, or just a
     file name, or, if a file search directory includes a file search
     pattern, just the base of the file name (without an extension).
     For example,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     all find the same file, assuming the file exists and
     `/home/wfs/special/###.mac' is in `file_search_maxima'.

     `file_search (<filename>, <pathlist>)' searches only in the
     directories specified by <pathlist>, which is a list of strings.
     The argument <pathlist> supersedes the default search directories,
     so if the path list is given, `file_search' searches only the ones
     specified, and not any of the default search directories.  Even if
     there is only one directory in <pathlist>, it must still be given
     as a one-element list.

     The user may modify the default search directories. See
     `file_search_maxima'.

     `file_search' is invoked by `load' with `file_search_maxima' and
     `file_search_lisp' as the search directories.


 -- Option variable: file_search_maxima
 -- Option variable: file_search_lisp
 -- Option variable: file_search_demo
     These variables specify lists of directories to be searched by
     `load', `demo', and some other Maxima functions.  The default
     values of these variables name various directories in the Maxima
     installation.

     The user can modify these variables, either to replace the default
     values or to append additional directories.  For example,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     replaces the default value of `file_search_maxima', while

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     appends two additional directories.  It may be convenient to put
     such an expression in the file `maxima-init.mac' so that the file
     search path is assigned automatically when Maxima starts.

     Multiple filename extensions and multiple paths can be specified by
     special "wildcard" constructions.  The string `###' expands into
     the sought-after name, while a comma-separated list enclosed in
     curly braces `{foo,bar,baz}' expands into multiple strings.  For
     example, supposing the sought-after name is `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     expands into `/home/wfs/neumann.lisp', `/home/gcj/neumann.lisp',
     `/home/wfs/neumann.mac', and `/home/gcj/neumann.mac'.


 -- Function: file_type (<filename>)
     Returns a guess about the content of <filename>, based on the
     filename extension.  <filename> need not refer to an actual file;
     no attempt is made to open the file and inspect the content.

     The return value is a symbol, either `object', `lisp', or `maxima'.
     If the extension starts with `m' or `d', `file_type' returns
     `maxima'.  If the extension starts with `l', `file_type' returns
     `lisp'.  If none of the above, `file_type' returns `object'.


 -- Function: grind (<expr>)
 -- Option variable: grind
     The function `grind' prints <expr> to the console in a form
     suitable for input to Maxima.  `grind' always returns `done'.

     See also `string', which returns a string instead of printing its
     output.  `grind' attempts to print the expression in a manner
     which makes it slightly easier to read than the output of `string'.

     When the variable `grind' is `true', the output of `string' and
     `stringout' has the same format as that of `grind'; otherwise no
     attempt is made to specially format the output of those functions.
     The default value of the variable `grind' is `false'.

     `grind' can also be specified as an argument of `playback'.  When
     `grind' is present, `playback' prints input expressions in the
     same format as the `grind' function.  Otherwise, no attempt is
     made to specially format input expressions.


 -- Option variable: ibase
     Default value: 10

     Integers entered into Maxima are interpreted with respect to the
     base `ibase'.

     `ibase' may be assigned any integer between 2 and 35 (decimal),
     inclusive.  When `ibase' is greater than 10, the numerals comprise
     the decimal numerals 0 through 9 plus capital letters of the
     alphabet A, B, C, ..., as needed.  The numerals for base 35, the
     largest acceptable base, comprise 0 through 9 and A through Y.

     See also `obase'.


 -- Option variable: inchar
     Default value: `%i'

     `inchar' is the prefix of the labels of expressions entered by the
     user.  Maxima automatically constructs a label for each input
     expression by concatenating `inchar' and `linenum'.  `inchar' may
     be assigned any string or symbol, not necessarily a single
     character.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     See also `labels'.


 -- Function: ldisp (<expr_1>, ..., <expr_n>)
     Displays expressions <expr_1>, ..., <expr_n> to the console as
     printed output.  `ldisp' assigns an intermediate expression label
     to each argument and returns the list of labels.

     See also `disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Function: ldisplay (<expr_1>, ..., <expr_n>)
     Displays expressions <expr_1>, ..., <expr_n> to the console as
     printed output.  Each expression is printed as an equation of the
     form `lhs = rhs' in which `lhs' is one of the arguments of
     `ldisplay' and `rhs' is its value.  Typically each argument is a
     variable.  `ldisp' assigns an intermediate expression label to
     each equation and returns the list of labels.

     See also `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Option variable: linechar
     Default value: `%t'

     `linechar' is the prefix of the labels of intermediate expressions
     generated by Maxima.  Maxima constructs a label for each
     intermediate expression (if displayed) by concatenating `linechar'
     and `linenum'.  `linechar' may be assigned any string or symbol,
     not necessarily a single character.

     Intermediate expressions might or might not be displayed.  See
     `programmode' and `labels'.


 -- Option variable: linel
     Default value: 79

     `linel' is the assumed width (in characters) of the console display
     for the purpose of displaying expressions.  `linel' may be
     assigned any value by the user, although very small or very large
     values may be impractical.  Text printed by built-in Maxima
     functions, such as error messages and the output of `describe', is
     not affected by `linel'.


 -- Option variable: lispdisp
     Default value: `false'

     When `lispdisp' is `true', Lisp symbols are displayed with a
     leading question mark `?'.  Otherwise, Lisp symbols are displayed
     with no leading mark.

     Examples:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Function: load (<filename>)
     Evaluates expressions in <filename>, thus bringing variables,
     functions, and other objects into Maxima.  The binding of any
     existing object is clobbered by the binding recovered from
     <filename>.  To find the file, `load' calls `file_search' with
     `file_search_maxima' and `file_search_lisp' as the search
     directories.  If `load' succeeds, it returns the name of the file.
     Otherwise `load' prints an error message.

     `load' works equally well for Lisp code and Maxima code.  Files
     created by `save', `translate_file', and `compile_file', which
     create Lisp code, and `stringout', which creates Maxima code, can
     all be processed by `load'.  `load' calls `loadfile' to load Lisp
     files and `batchload' to load Maxima files.

     See also `loadfile', `batch', `batchload', and `demo'.  `loadfile'
     processes Lisp files; `batch', `batchload', and `demo' process
     Maxima files.

     See `file_search' for more detail about the file search mechanism.

     `load' evaluates its argument.


 -- Function: loadfile (<filename>)
     Evaluates Lisp expressions in <filename>.  `loadfile' does not
     invoke `file_search', so `filename' must include the file
     extension and as much of the path as needed to find the file.

     `loadfile' can process files created by `save', `translate_file',
     and `compile_file'.  The user may find it more convenient to use
     `load' instead of `loadfile'.

     `loadfile' quotes its argument, so `filename' must be a literal
     string, not a string variable.  The double-single-quote operator
     defeats quotation.


 -- Option variable: loadprint
     Default value: `true'

     `loadprint' tells whether to print a message when a file is loaded.

        * When `loadprint' is `true', always print a message.

        * When `loadprint' is `'loadfile', print a message only if a
          file is loaded by the function `loadfile'.

        * When `loadprint' is `'autoload', print a message only if a
          file is automatically loaded.  See `setup_autoload'.

        * When `loadprint' is `false', never print a message.


 -- Option variable: obase
     Default value: 10

     `obase' is the base for integers displayed by Maxima.

     `obase' may be assigned any integer between 2 and 35 (decimal),
     inclusive.  When `obase' is greater than 10, the numerals comprise
     the decimal numerals 0 through 9 plus capital letters of the
     alphabet A, B, C, ..., as needed.  The numerals for base 35, the
     largest acceptable base, comprise 0 through 9, and A through Y.

     See also `ibase'.


 -- Option variable: outchar
     Default value: `%o'

     `outchar' is the prefix of the labels of expressions computed by
     Maxima.  Maxima automatically constructs a label for each computed
     expression by concatenating `outchar' and `linenum'.  `outchar'
     may be assigned any string or symbol, not necessarily a single
     character.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     See also `labels'.


 -- Option variable: packagefile
     Default value: `false'

     Package designers who use `save' or `translate' to create packages
     (files) for others to use may want to set `packagefile: true' to
     prevent information from being added to Maxima's information-lists
     (e.g. `values', `functions') except where necessary when the file
     is loaded in.  In this way, the contents of the package will not
     get in the user's way when he adds his own data.  Note that this
     will not solve the problem of possible name conflicts.  Also note
     that the flag simply affects what is output to the package file.
     Setting the flag to `true' is also useful for creating Maxima init
     files.


 -- Option variable: pfeformat
     Default value: `false'

     When `pfeformat' is `true', a ratio of integers is displayed with
     the solidus (forward slash) character, and an integer denominator
     `n' is displayed as a leading multiplicative term `1/n'.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Function: print (<expr_1>, ..., <expr_n>)
     Evaluates and displays <expr_1>, ..., <expr_n> one after another,
     from left to right, starting at the left edge of the console
     display.

     The value returned by `print' is the value of its last argument.
     `print' does not generate intermediate expression labels.

     See also `display', `disp', `ldisplay', and `ldisp'.  Those
     functions display one expression per line, while `print' attempts
     to display two or more expressions per line.

     To display the contents of a file, see `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Function: tcl_output (<list>, <i0>, <skip>)
 -- Function: tcl_output (<list>, <i0>)
 -- Function: tcl_output ([<list_1>, ..., <list_n>], <i>)
     Prints elements of a list enclosed by curly braces `{ }', suitable
     as part of a program in the Tcl/Tk language.

     `tcl_output (<list>, <i0>, <skip>)' prints <list>, beginning with
     element <i0> and printing elements `<i0> + <skip>', `<i0> + 2
     <skip>', etc.

     `tcl_output (<list>, <i0>)' is equivalent to `tcl_output (<list>,
     <i0>, 2)'.

     `tcl_output ([<list_1>, ..., <list_n>], <i>)' prints the <i>'th
     elements of <list_1>, ..., <list_n>.

     Examples:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }


 -- Function: read (<expr_1>, ..., <expr_n>)
     Prints <expr_1>, ..., <expr_n>, then reads one expression from the
     console and returns the evaluated expression.  The expression is
     terminated with a semicolon `;' or dollar sign `$'.

     See also `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Function: readonly (<expr_1>, ..., <expr_n>)
     Prints <expr_1>, ..., <expr_n>, then reads one expression from the
     console and returns the expression (without evaluation).  The
     expression is terminated with a `;' (semicolon) or `$' (dollar
     sign).

          (%i1) aa: 7$
          (%i2) foo: readonly ("Enter an expression:");
          Enter an expression:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Enter an expression:");
          Enter an expression:
          2^aa;
          (%o3)                            128

     See also `read'.


 -- Function: reveal (<expr>, <depth>)
     Replaces parts of <expr> at the specified integer <depth> with
     descriptive summaries.

        * Sums and differences are replaced by `sum(<n>)' where <n> is
          the number of operands of the sum.

        * Products are replaced by `product(<n>)' where <n> is the
          number of operands of the product.

        * Exponentials are replaced by `expt'.

        * Quotients are replaced by `quotient'.

        * Unary negation is replaced by `negterm'.

     When <depth> is greater than or equal to the maximum depth of
     <expr>, `reveal (<expr>, <depth>)' returns <expr> unmodified.

     `reveal' evaluates its arguments.  `reveal' returns the summarized
     expression.

     Example:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       quotient
          (%i3) reveal (e, 2);
                                       sum(3)
          (%o3)                        ------
                                       sum(3)
          (%i4) reveal (e, 3);
                               expt + negterm + expt
          (%o4)               ------------------------
                              product(2) + expt + expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - product(3) + a
          (%o5)         ------------------------------------
                                   product(2)     product(2)
                        2 expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Option variable: rmxchar
     Default value: `]'

     `rmxchar' is the character drawn on the right-hand side of a
     matrix.

     See also `lmxchar'.


 -- Function: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Function: save (<filename>, values, functions, labels, ...)
 -- Function: save (<filename>, [<m>, <n>])
 -- Function: save (<filename>, <name_1>=<expr_1>, ...)
 -- Function: save (<filename>, all)
     Stores the current values of <name_1>, <name_2>, <name_3>, ..., in
     <filename>.  The arguments are the names of variables, functions,
     or other objects.  If a name has no value or function associated
     with it, it is ignored.  `save' returns <filename>.

     `save' stores data in the form of Lisp expressions.  The data
     stored by `save' may be recovered by `load (<filename>)'.  The
     effect of executing `save' when <filename> already exists depends
     on the underlying Lisp implementation; the file may be clobbered,
     or `save' may complain with an error message.

     The special form `save (<filename>, values, functions, labels,
     ...)'  stores the items named by `values', `functions', `labels',
     etc.  The names may be any specified by the variable `infolists'.
     `values' comprises all user-defined variables.

     The special form `save (<filename>, [<m>, <n>])' stores the values
     of input and output labels <m> through <n>.  Note that <m> and <n>
     must be literal integers or double-quoted symbols.  Input and
     output labels may also be stored one by one, e.g., `save ("foo.1",
     %i42, %o42)'.  `save (<filename>, labels)' stores all input and
     output labels.  When the stored labels are recovered, they clobber
     existing labels.

     The special form `save (<filename>, <name_1>=<expr_1>,
     <name_2>=<expr_2>, ...)' stores the values of <expr_1>, <expr_2>,
     ..., with names <name_1>, <name_2>, ....  It is useful to apply
     this form to input and output labels, e.g., `save ("foo.1",
     aa=%o88)'.  The right-hand side of the equality in this form may
     be any expression, which is evaluated.  This form does not
     introduce the new names into the current Maxima environment, but
     only stores them in <filename>.

     These special forms and the general form of `save' may be mixed at
     will.  For example, `save (<filename>, aa, bb, cc=42, functions,
     [11, 17])'.

     The special form `save (<filename>, all)' stores the current state
     of Maxima.  This includes all user-defined variables, functions,
     arrays, etc., as well as some automatically defined items.  The
     saved items include system variables, such as `file_search_maxima'
     or `showtime', if they have been assigned new values by the user;
     see `myoptions'.

     `save' quotes its arguments.  <filename> must be a string, not a
     string variable.  The first and last labels to save, if specified,
     must be integers.  The double quote operator evaluates a string
     variable to its string value, e.g., `s: "foo.1"$ save (''s, all)$',
     and integer variables to their integer values, e.g., `m: 5$ n: 12$
     save ("foo.1", [''m, ''n])$'.


 -- Option variable: savedef
     Default value: `true'

     When `savedef' is `true', the Maxima version of a user function is
     preserved when the function is translated.  This permits the
     definition to be displayed by `dispfun' and allows the function to
     be edited.

     When `savedef' is `false', the names of translated functions are
     removed from the `functions' list.


 -- Function: show (<expr>)
     Displays `expr' with the indexed objects in it shown having
     covariant indices as subscripts, contravariant indices as
     superscripts.  The derivative indices are displayed as subscripts,
     separated from the covariant indices by a comma.


 -- Function: showratvars (<expr>)
     Returns a list of the canonical rational expression (CRE)
     variables in expression `expr'.

     See also `ratvars'.


 -- Option variable: stardisp
     Default value: `false'

     When `stardisp' is `true', multiplication is displayed with an
     asterisk `*' between operands.


 -- Function: string (<expr>)
     Converts `expr' to Maxima's linear notation just as if it had been
     typed in.

     The return value of `string' is a string, and thus it cannot be
     used in a computation.


 -- Lisp variable: stringdisp
     Default value: `false'

     When `?stringdisp' is `true', strings are displayed enclosed in
     double quote marks.  Otherwise, quote marks are not displayed.

     `?stringdisp' is always `true' when displaying a function
     definition.

     `?stringdisp' is a Lisp variable, so it must be written with a
     leading question mark `?'.

     Examples:

          (%i1) ?stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () := print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) ?stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


 -- Function: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Function: stringout (<filename>, [<m>, <n>])
 -- Function: stringout (<filename>, input)
 -- Function: stringout (<filename>, functions)
 -- Function: stringout (<filename>, values)
     `stringout' writes expressions to a file in the same form the
     expressions would be typed for input. The file can then be used as
     input for the `batch' or `demo' commands, and it may be edited for
     any purpose. `stringout' can be executed while `writefile' is in
     progress.

     The general form of `stringout' writes the values of one or more
     expressions to the output file. Note that if an expression is a
     variable, only the value of the variable is written and not the
     name of the variable. As a useful special case, the expressions
     may be input labels (`%i1', `%i2', `%i3', ...) or output labels
     (`%o1', `%o2', `%o3', ...).

     If `grind' is `true', `stringout' formats the output using the
     `grind' format. Otherwise the `string' format is used. See `grind'
     and `string'.

     The special form `stringout (<filename>, [<m>, <n>])' writes the
     values of input labels m through n, inclusive.

     The special form `stringout (<filename>, input)' writes all input
     labels to the file.

     The special form `stringout (<filename>, functions)' writes all
     user-defined functions (named by the global list `functions') to
     the file.

     The special form `stringout (<filename>, values)' writes all
     user-assigned variables (named by the global list `values') to the
     file. Each variable is printed as an assignment statement, with
     the name of the variable, a colon, and its value. Note that the
     general form of `stringout' does not print variables as assignment
     statements.


 -- Function: tex (<expr>)
 -- Function: tex (<expr>, <filename>)
 -- Function: tex (<label>, <filename>)
     In the case of a label, a left-equation-number is produced.  in
     case a file-name is supplied, the output is appended to the file.

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)


 -- Function: system (<command>)
     Executes <command> as a separate process.  The command is passed
     to the default shell for execution.  `system' is not supported by
     all operating systems, but generally exists in Unix and Unix-like
     environments.

     Supposing `_hist.out' is a list of frequencies which you wish to
     plot as a bar graph using `xgraph'.

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     In order to make the plot be done in the background (returning
     control to Maxima) and remove the temporary file after it is done
     do:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")


 -- Option variable: ttyoff
     Default value: `false'

     When `ttyoff' is `true', output expressions are not displayed.
     Output expressions are still computed and assigned labels. See
     `labels'.

     Text printed by built-in Maxima functions, such as error messages
     and the output of `describe', is not affected by `ttyoff'.


 -- Macro: with_stdout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
     Opens <filename> and then evaluates <expr_1>, <expr_2>, <expr_3>,
     ....  The values of the arguments are not stored in <filename>,
     but any printed output generated by evaluating the arguments (from
     `print', `display', `disp', or `grind', for example) goes to
     <filename> instead of the console.

     `with_stdout' returns the value of its final argument.

     See also `writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Function: writefile (<filename>)
     Begins writing a transcript of the Maxima session to <filename>.
     All interaction between the user and Maxima is then recorded in
     this file, just as it appears on the console.

     As the transcript is printed in the console output format, it
     cannot be reloaded into Maxima.  To make a file containing
     expressions which can be reloaded, see `save' and `stringout'.
     `save' stores expressions in Lisp form, while `stringout' stores
     expressions in Maxima form.

     The effect of executing `writefile' when <filename> already exists
     depends on the underlying Lisp implementation; the transcript file
     may be clobbered, or the file may be appended.  `appendfile'
     always appends to the transcript file.

     It may be convenient to execute `playback' after `writefile' to
     save the display of previous interactions.  As `playback' displays
     only the input and output variables (`%i1', `%o1', etc.), any
     output generated by a print statement in a function (as opposed to
     a return value) is not displayed by `playback'.

     `closefile' closes the transcript file opened by `writefile' or
     `appendfile'.



File: maxima.info,  Node: Floating Point,  Next: Contexts,  Prev: Input and Output,  Up: Top

10 Floating Point
*****************

* Menu:

* Definitions for Floating Point::


File: maxima.info,  Node: Definitions for Floating Point,  Prev: Floating Point,  Up: Floating Point

10.1 Definitions for Floating Point
===================================

 -- Function: bffac (<expr>, <n>)
     Bigfloat version of the factorial (shifted gamma) function.  The
     second argument is how many digits to retain and return, it's a
     good idea to request a couple of extra.

     `load ("bffac")' loads this function.


 -- Option variable: algepsilon
     Default value: 10^8

     `algepsilon' is used by `algsys'.


 -- Function: bfloat (<expr>)
     Converts all numbers and functions of numbers in <expr> to
     bigfloat numbers.  The number of significant digits in the
     resulting bigfloats is specified by the global variable `fpprec'.

     When `float2bf' is `false' a warning message is printed when a
     floating point number is converted into a bigfloat number (since
     this may lead to loss of precision).


 -- Function: bfloatp (<expr>)
     Returns `true' if <expr> is a bigfloat number, otherwise `false'.


 -- Function: bfpsi (<n>, <z>, <fpprec>)
 -- Function: bfpsi0 (<z>, <fpprec>)
     `bfpsi' is the polygamma function of real argument <z> and integer
     order <n>.  `bfpsi0' is the digamma function.  `bfpsi0 (<z>,
     <fpprec>)' is equivalent to `bfpsi (0, <z>, <fpprec>)'.

     These functions return bigfloat values.  <fpprec> is the bigfloat
     precision of the return value.

     `load ("bffac")' loads these functions.


 -- Option variable: bftorat
     Default value: `false'

     `bftorat' controls the conversion of bfloats to rational numbers.
     When `bftorat' is `false', `ratepsilon' will be used to control
     the conversion (this results in relatively small rational numbers).
     When `bftorat' is `true', the rational number generated will
     accurately represent the bfloat.


 -- Option variable: bftrunc
     Default value: `true'

     `bftrunc' causes trailing zeroes in non-zero bigfloat numbers not
     to be displayed.  Thus, if `bftrunc' is `false', `bfloat (1)'
     displays as `1.000000000000000B0'. Otherwise, this is displayed as
     `1.0B0'.


 -- Function: cbffac (<z>, <fpprec>)
     Complex bigfloat factorial.

     `load ("bffac")' loads this function.


 -- Function: float (<expr>)
     Converts integers, rational numbers and bigfloats in <expr> to
     floating point numbers.  It is also an `evflag', `float' causes
     non-integral rational numbers and bigfloat numbers to be converted
     to floating point.


 -- Option variable: float2bf
     Default value: `false'

     When `float2bf' is `false', a warning message is printed when a
     floating point number is converted into a bigfloat number (since
     this may lead to loss of precision).


 -- Function: floatnump (<expr>)
     Returns `true' if <expr> is a floating point number, otherwise
     `false'.


 -- Option variable: fpprec
     Default value: 16

     `fpprec' is the number of significant digits for arithmetic on
     bigfloat numbers.  `fpprec' does not affect computations on
     ordinary floating point numbers.

     See also `bfloat' and `fpprintprec'.


 -- Option variable: fpprintprec
     Default value: 0

     `fpprintprec' is the number of digits to print when printing a
     bigfloat number, making it possible to compute with a large number
     of digits of precision, but have the answer printed out with a
     smaller number of digits.

     When `fpprintprec' is 0, or greater than or equal to `fpprec',
     then the value of `fpprec' controls the number of digits used for
     printing.

     When `fpprintprec' has a value between 2 and `fpprec - 1', then it
     controls the number of digits used.  (The minimal number of digits
     used is 2, one to the left of the point and one to the right.

     The value 1 for `fpprintprec' is illegal.


 -- Lisp function: ?round (<x>)
 -- Lisp function: ?round (<x>, <divisor>)
     Round the floating point <x> to the nearest integer.   The argument
     must be an ordinary float, not a bigfloat.   The `?' beginning the
     name indicates this is a Lisp function.

          (%i1) ?round (-2.8);
          (%o1)                            - 3


 -- Lisp function: ?truncate (<x>)
 -- Lisp function: ?truncate (<x>, <divisor>)
     Truncate the floating point <x> towards 0, to become an integer.
     The argument must be an ordinary float, not a bigfloat.  The `?'
     beginning the name indicates this is a Lisp function.

          (%i1) ?truncate (-2.8);
          (%o1)                            - 2
          (%i2) ?truncate (2.4);
          (%o2)                             2
          (%i3) ?truncate (2.8);
          (%o3)                             2



File: maxima.info,  Node: Contexts,  Next: Polynomials,  Prev: Floating Point,  Up: Top

11 Contexts
***********

* Menu:

* Definitions for Contexts::


File: maxima.info,  Node: Definitions for Contexts,  Prev: Contexts,  Up: Contexts

11.1 Definitions for Contexts
=============================

 -- Function: activate (<context_1>, ..., <context_n>)
     Activates the contexts <context_1>, ..., <context_n>.  The facts
     in these contexts are then available to make deductions and
     retrieve information.  The facts in these contexts are not listed
     by `facts ()'.

     The variable `activecontexts' is the list of contexts which are
     active by way of the `activate' function.


 -- System variable: activecontexts
     Default value: `[]'

     `activecontexts' is a list of the contexts which are active by way
     of the `activate' function, as opposed to being active because
     they are subcontexts of the current context.


 -- Function: assume (<pred_1>, ..., <pred_n>)
     Adds predicates <pred_1>, ..., <pred_n> to the current database,
     after checking for redundancy and inconsistency.  If the
     predicates are consistent and non-redundant, they are added to the
     data base; if inconsistent or redundant, no action is taken.

     `assume' returns a list whose elements are the predicates added to
     the database and the atoms `redundant' or `inconsistent' where
     applicable.


 -- Option variable: assumescalar
     Default value: `true'

     `assumescalar' helps govern whether expressions `expr' for which
     `nonscalarp (expr)' is `false' are assumed to behave like scalars
     for certain transformations.

     Let `expr' represent any expression other than a list or a matrix,
     and let `[1, 2, 3]' represent any list or matrix.  Then `expr .
     [1, 2, 3]' yields `[expr, 2 expr, 3 expr]' if `assumescalar' is
     `true', or `scalarp (expr)' is `true', or `constantp (expr)' is
     `true'.

     If `assumescalar' is `true', such expressions will behave like
     scalars only for commutative operators, but not for noncommutative
     multiplication `.'.

     When `assumescalar' is `false', such expressions will behave like
     non-scalars.

     When `assumescalar' is `all', such expressions will behave like
     scalars for all the operators listed above.


 -- Option variable: assume_pos
     Default value: `false'

     When `assume_pos' is `true' and the sign of a parameter <x> cannot
     be determined from the `assume' database or other considerations,
     `sign' and `asksign (<x>)' return `true'.  This may forestall some
     automatically-generated `asksign' queries, such as may arise from
     `integrate' or other computations.

     By default, a parameter is <x> such that `symbolp (x)' or `subvarp
     (x)'.  The class of expressions considered parameters can be
     modified to some extent via the variable `assume_pos_pred'.

     `sign' and `asksign' attempt to deduce the sign of expressions
     from the sign of operands within the expression.  For example, if
     `a' and `b' are both positive, then `a + b' is also positive.

     However, there is no way to bypass all `asksign' queries.  In
     particular, when the `asksign' argument is a difference `<x> -
     <y>' or a logarithm `log(<x>)', `asksign' always requests an input
     from the user, even when `assume_pos' is `true' and
     `assume_pos_pred' is a function which returns `true' for all
     arguments.


 -- Option variable: assume_pos_pred
     Default value: `false'

     When `assume_pos_pred' is assigned the name of a function or a
     lambda expression of one argument <x>, that function is called to
     determine whether <x> is considered a parameter for the purpose of
     `assume_pos'.  `assume_pos_pred' is ignored when `assume_pos' is
     `false'.

     The `assume_pos_pred' function is called by `sign' and `asksign'
     with an argument <x> which is either an atom, a subscripted
     variable, or a function call expression.  If the `assume_pos_pred'
     function returns `true', <x> is considered a parameter for the
     purpose of `assume_pos'.

     By default, a parameter is <x> such that `symbolp (x)' or `subvarp
     (x)'.

     See also `assume' and `assume_pos'.

     Examples:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Option variable: context
     Default value: `initial'

     `context' names the collection of facts maintained by `assume' and
     `forget'.  `assume' adds facts to the collection named by
     `context', while `forget' removes facts.

     Binding `context' to a name <foo> changes the current context to
     <foo>.  If the specified context <foo> does not yet exist, it is
     created automatically by a call to `newcontext'.  The specified
     context is activated automatically.

     See `context' for a general description of the context mechanism.


 -- Option variable: contexts
     Default value: `[initial, global]'

     `contexts' is a list of the contexts which currently exist,
     including the currently active context.

     The context mechanism makes it possible for a user to bind together
     and name a selected portion of his database, called a context.
     Once this is done, the user can have Maxima assume or forget large
     numbers of facts merely by activating or deactivating their
     context.

     Any symbolic atom can be a context, and the facts contained in that
     context will be retained in storage until destroyed one by one by
     calling `forget' or destroyed as a whole by calling `kill' to
     destroy the context to which they belong.

     Contexts exist in a hierarchy, with the root always being the
     context `global', which contains information about Maxima that some
     functions need.  When in a given context, all the facts in that
     context are "active" (meaning that they are used in deductions and
     retrievals) as are all the facts in any context which is a
     subcontext of the active context.

     When a fresh Maxima is started up, the user is in a context called
     `initial', which has `global' as a subcontext.

     See also `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume', and `forget'.


 -- Function: deactivate (<context_1>, ..., <context_n>)
     Deactivates the specified contexts <context_1>, ..., <context_n>.


 -- Function: facts (<item>)
 -- Function: facts ()
     If <item> is the name of a context, `facts (<item>)' returns a list
     of the facts in the specified context.

     If <item> is not the name of a context, `facts (<item>)' returns a
     list of the facts known about <item> in the current context.
     Facts that are active, but in a different context, are not listed.

     `facts ()' (i.e., without an argument) lists the current context.


 -- Declaration: features
     Maxima recognizes certain mathematical properties of functions and
     variables.  These are called "features".

     `declare (<x>, <foo>)' gives the property <foo> to the function or
     variable `x'.

     `declare (<foo>, feature)' declares a new feature <foo>.  For
     example, `declare ([red, green, blue], feature)' declares three
     new features, `red', `green', and `blue'.

     The predicate `featurep (<x>, <foo>)' returns `true' if <x> has
     the <foo> property, and `false' otherwise.

     The infolist `features' is a list of known features.  These are
     `integer', `noninteger', `even', `odd', `rational', `irrational',
     `real', `imaginary', `complex', `analytic', `increasing',
     `decreasing', `oddfun', `evenfun', `posfun', `commutative',
     `lassociative', `rassociative', `symmetric', and `antisymmetric',
     plus any user-defined features.

     `features' is a list of mathematical features.  There is also a
     list of non-mathematical, system-dependent features. See `status'.


 -- Function: forget (<pred_1>, ..., <pred_n>)
 -- Function: forget (<L>)
     Removes predicates established by `assume'.  The predicates may be
     expressions equivalent to (but not necessarily identical to) those
     previously assumed.

     `forget (<L>)', where <L> is a list of predicates, forgets each
     item on the list.


 -- Function: killcontext (<context_1>, ..., <context_n>)
     Kills the contexts <context_1>, ..., <context_n>.

     If one of the contexts is the current context, the new current
     context will become the first available subcontext of the current
     context which has not been killed.  If the first available unkilled
     context is `global' then `initial' is used instead.  If the
     `initial' context is killed, a new, empty `initial' context is
     created.

     `killcontext' refuses to kill a context which is currently active,
     either because it is a subcontext of the current context, or by
     use of the function `activate'.

     `killcontext' evaluates its arguments.  `killcontext' returns
     `done'.


 -- Function: newcontext (<name>)
     Creates a new, empty context, called <name>, which has `global' as
     its only subcontext.  The newly-created context becomes the
     currently active context.

     `newcontext' evaluates its argument.  `newcontext' returns <name>.


 -- Function: supcontext (<name>, <context>)
 -- Function: supcontext (<name>)
     Creates a new context, called <name>, which has <context> as a
     subcontext.  <context> must exist.

     If <context> is not specified, the current context is assumed.



File: maxima.info,  Node: Polynomials,  Next: Constants,  Prev: Contexts,  Up: Top

12 Polynomials
**************

* Menu:

* Introduction to Polynomials::
* Definitions for Polynomials::


File: maxima.info,  Node: Introduction to Polynomials,  Next: Definitions for Polynomials,  Prev: Polynomials,  Up: Polynomials

12.1 Introduction to Polynomials
================================

Polynomials are stored in Maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

   Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC is set to `true').  In this CRE form an ordering
of variables (from most to least main) is assumed for each expression.
Polynomials are represented recursively by a list consisting of the
main variable followed by a series of pairs of expressions, one for
each term of the polynomial.  The first member of each pair is the
exponent of the main variable in that term and the second member is the
coefficient of that term which could be a number or a polynomial in
another variable again represented in this form.  Thus the principal
part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that of 2*X*Y+X-3
is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main variable, and is
(X 1 (Y 1 2 0 1) 0 -3) assuming X is the main variable. "Main"-ness is
usually determined by reverse alphabetical order.  The "variables" of a
CRE expression needn't be atomic.  In fact any subexpression whose main
operator is not + - * / or ^ with integer power will be considered a
"variable" of the expression (in CRE form) in which it occurs.  For
example the CRE variables of the expression X+SIN(X+1)+2*SQRT(X)+1 are
X, SQRT(X), and SIN(X+1).  If the user does not specify an ordering of
variables by using the RATVARS function Maxima will choose an
alphabetic one.  In general, CRE's represent rational expressions, that
is, ratios of polynomials, where the numerator and denominator have no
common factors, and the denominator is positive.  The internal form is
essentially a pair of polynomials (the numerator and denominator)
preceded by the variable ordering list.  If an expression to be
displayed is in CRE form or if it contains any subexpressions in CRE
form, the symbol /R/ will follow the line label.  See the RAT function
for converting an expression to CRE form.  An extended CRE form is used
for the representation of Taylor series.  The notion of a rational
expression is extended so that the exponents of the variables can be
positive or negative rational numbers rather than just positive
integers and the coefficients can themselves be rational expressions as
described above rather than just polynomials.  These are represented
internally by a recursive polynomial form which is similar to and is a
generalization of CRE form, but carries additional information such as
the degree of truncation.  As with CRE form, the symbol /T/ follows the
line label of such expressions.

