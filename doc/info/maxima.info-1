This is maxima.info, produced by makeinfo version 4.1 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introduction to MAXIMA,  Prev: (dir),  Up: (dir)



   MAXIMA is a fairly complete computer algebra system.

   This system MAXIMA is a COMMON LISP implementation due to William F.
Schelter, and is based on the original implementation of Macsyma at
MIT, as distributed by the Department of Energy.  I now have permission
from DOE to make derivative copies, and in particular to distribute it
under the GNU public license.  See the file COPYING included in the
distribution.   Thus these files may now be redistributed under the
terms of GNU public license.

* Menu:

MAXIMA infrastructure

* Introduction to MAXIMA::      Sample MAXIMA sessions.
* Help::                        Asking for help from within a MAXIMA session.
* Command Line::                MAXIMA command line syntax.
* Operators::                   Operators used in MAXIMA expressions.
* Expressions::                 Expressions in MAXIMA.
* Simplification::              Simplifying expressions.
* Plotting::                    2D and 3D graphical output.
* Input and Output::            File input and output.
* Floating Point::              Low level numerical routines.
* Contexts::                    Sets of assumed facts.

Support for specific areas of mathematics

* Polynomials::                 Standard forms for polynomials, and
                                functions operating on them.
* Constants::                   Numerical constants.
* Logarithms::                  Manipulation of expressions involving
                                logarithms.
* Trigonometric::               Manipulating expressions with trig and
                                inverse trig functions.
* Special Functions::           Special functions
* Orthogonal Polynomials::      Orthogonal Polynomials and Special functions
* Elliptic Functions::          Elliptic Functions and Integrals
* Limits::                      Limits of expressions.
* Differentiation::             Differential calculus.
* Integration::                 Integral calculus.
* Equations::                   Defining and solving equations.
* Differential Equations::      Defining and solving differential equations.
* Numerical::                   Numerical integration, Fourier
                                transforms, etc.
* Statistics::                  Statistical functions.
* Arrays and Tables::           Creating and working with arrays.
* Matrices and Linear Algebra:: Matrix operations.
* Affine::
* Tensor::                      Indicial Tensor Manipulation package.
* Ctensor::                     Component Tensor Manipulation.
* Series::                      Taylor and power series.
* Number Theory::               Number theory.
* Symmetries::
* Groups::                      Abstract algebra.

Advanced facilities and programming

* Runtime Environment::         Customization of the MAXIMA environment.
* Miscellaneous Options::       Options with a global effect on MAXIMA.
* Rules and Patterns::          User defined pattern matching and
                                simplification rules.
* Lists::                       Manipulation of Lisp lists.
* Function Definition::         Defining functions.
* Program Flow::                Defining MAXIMA programs.
* Debugging::                   Debugging MAXIMA programs.

Index

* Function and Variable Index:: Index.

 --- The Detailed Node Listing ---

Introduction

* Introduction to MAXIMA::

Help

* Introduction to Help::
* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::

Command Line

* Introduction to Command Line::
* Definitions for Command Line::

Operators

* NARY::
* NOFIX::
* OPERATOR::
* POSTFIX::
* PREFIX::
* Definitions for Operators::

Expressions

* Introduction to Expressions::
* ASSIGNMENT::
* COMPLEX::
* INEQUALITY::
* SYNTAX::
* Definitions for Expressions::

Simplification

* Definitions for Simplification::

Plotting

* Definitions for Plotting::

Input and Output

* Introduction to Input and Output::
* FILES::
* PLAYBACK::
* Definitions for Input and Output::

Floating Point

* Definitions for Floating Point::

Contexts

* Definitions for Contexts::

Polynomials

* Introduction to Polynomials::
* Definitions for Polynomials::

Constants

* Definitions for Constants::

Logarithms

* Definitions for Logarithms::

Trigonometric

* Introduction to Trigonometric::
* Definitions for Trigonometric::

Special Functions

* Introduction to Special Functions::
* GAMALG::
* SPECINT::
* Definitions for Special Functions::

Orthogonal Polynomials

* Introduction to Orthogonal Polynomials::
* Definitions for Orthogonal Polynomials::

Elliptic Functions

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::

Limits

* Definitions for Limits::

Differentiation

* Definitions for Differentiation::

Integration

* Introduction to Integration::
* Definitions for Integration::

Equations

* Definitions for Equations::

Differential Equations

* Definitions for Differential Equations::

Numerical

* Introduction to Numerical::
* DCADRE::
* ELLIPT::
* FOURIER::
* NDIFFQ::
* Definitions for Numerical::

Statistics

* Definitions for Statistics::

Arrays and Tables

* Definitions for Arrays and Tables::

Matrices and Linear Algebra

* Introduction to Matrices and Linear Algebra::
* DOT::
* VECTORS::
* Definitions for Matrices and Linear Algebra::

Affine

* Definitions for Affine::

Tensor

* Introduction to Tensor::
* Definitions for Tensor::

Ctensor

* Introduction to Ctensor::
* Definitions for Ctensor::

Series

* Introduction to Series::
* Definitions for Series::

Number Theory

* Definitions for Number Theory::

Symmetries

* Definitions for Symmetries::

Groups

* Definitions for Groups::

Runtime Environment

* Introduction for Runtime Environment::
* INTERRUPTS::
* Definitions for Runtime Environment::

Miscellaneous Options

* Introduction to Miscellaneous Options::
* SHARE::
* Definitions for Miscellaneous Options::

Rules and Patterns

* Introduction to Rules and Patterns::
* Definitions for Rules and Patterns::

Lists

* Introduction to Lists::
* Definitions for Lists::

Function Definition

* Introduction to Function Definition::
* FUNCTION::
* MACROS::
* OPTIMIZATION::
* Definitions for Function Definition::

Program Flow

* Introduction to Program Flow::
* Definitions for Program Flow::

Debugging

* Definitions for Debugging::


File: maxima.info,  Node: Introduction to MAXIMA,  Next: Help,  Prev: Top,  Up: Top

Introduction to MAXIMA
**********************

   Start MAXIMA with the command "maxima".  MAXIMA will display version
information and a prompt.  End each MAXIMA command with a semicolon.
End the session with the command "quit();".  Here's a sample session:

     sonia$ maxima
     GCL (GNU Common Lisp)  Version(2.3) Tue Mar 21 14:15:15 CST 2000
     Licensed under GNU Library General Public License
     Contains Enhancements by W. Schelter
     Maxima 5.4 Tue Mar 21 14:14:45 CST 2000 (enhancements by W. Schelter)
     Licensed under the GNU Public License (see file COPYING)
     (C1) factor(10!);
     
                                        8  4  2
     (D1)                              2  3  5  7
     (C2) expand((x+y)^6);
     
                6        5       2  4       3  3       4  2      5      6
     (D2)      y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (C3) factor(x^6-1);
     
                                          2            2
     (D3)               (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (C4) quit();
     
     sonia$

   MAXIMA can search the info pages.  Use the `describe' command to show
all the commands and variables containing a string, and optionally their
documentation:

     (C1) describe(factor);
     
     
      0: DONTFACTOR :(maxima.info)Definitions for Matrices and ..
      1: EXPANDWRT_FACTORED :Definitions for Simplification.
      2: FACTOR :Definitions for Polynomials.
      3: FACTORFLAG :Definitions for Polynomials.
      4: FACTORIAL :Definitions for Number Theory.
      5: FACTOROUT :Definitions for Polynomials.
      6: FACTORSUM :Definitions for Polynomials.
      7: GCFACTOR :Definitions for Polynomials.
      8: GFACTOR :Definitions for Polynomials.
      9: GFACTORSUM :Definitions for Polynomials.
      10: MINFACTORIAL :Definitions for Number Theory.
      11: NUMFACTOR :Definitions for Special Functions.
      12: SAVEFACTORS :Definitions for Polynomials.
      13: SCALEFACTORS :Definitions for Miscellaneous Options.
      14: SOLVEFACTORS :Definitions for Equations.
     Enter n, all, none, or multiple choices eg 1 3 : 2 8;
     
     Info from file /d/linux/local/lib/maxima-5.4/info/maxima.info:
      - Function: FACTOR (EXP)
          factors the expression exp, containing any number of variables or
          functions, into factors irreducible over the integers.
          FACTOR(exp, p) factors exp over the field of integers with an
          element adjoined whose minimum polynomial is p.  FACTORFLAG[FALSE]
          if FALSE suppresses the factoring of integer factors of rational
          expressions.  DONTFACTOR may be set to a list of variables with
          respect to which factoring is not to occur.  (It is initially
          empty).  Factoring also will not take place with respect to any
          variables which are less important (using the variable ordering
          assumed for CRE form) than those on the DONTFACTOR list.
          SAVEFACTORS[FALSE] if TRUE causes the factors of an expression
          which is a product of factors to be saved by certain functions in
          order to speed up later factorizations of expressions containing
          some of the same factors.  BERLEFACT[TRUE] if FALSE then the
          Kronecker factoring algorithm will be used otherwise the Berlekamp
          algorithm, which is the default, will be used.  INTFACLIM[1000] is
          the largest divisor which will be tried when factoring a bignum
          integer.  If set to FALSE (this is the case when the user calls
          FACTOR explicitly), or if the integer is a fixnum (i.e.  fits in
          one machine word), complete factorization of the integer will be
          attempted.  The user's setting of INTFACLIM is used for internal
          calls to FACTOR. Thus, INTFACLIM may be reset to prevent MACSYMA
          from taking an inordinately long time factoring large integers.
          NEWFAC[FALSE] may be set to true to use the new factoring routines.
          Do EXAMPLE(FACTOR); for examples.
     
     
      - Function: GFACTOR (EXP)
          factors the polynomial exp over the Gaussian integers (i.  e.
          with SQRT(-1) = %I adjoined).  This is like FACTOR(exp,A**2+1)
          where A is %I.
               (C1)  GFACTOR(X**4-1);
               (D1)        (X - 1) (X + 1) (X + %I) (X - %I)
     (D1) 				     FALSE

   To use a result in later calculations, you can assign it to a
variable or refer to it by its automatically supplied label.  In
addition, `%' refers to the most recent calculated result:

     (C2) u:expand((x+y)^6);
     
                6        5       2  4       3  3       4  2      5      6
     (D2)     y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (C3) diff(u,x);
     
                     5         4       2  3       3  2       4        5
     (D3)        6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (C4) factor(d3);
     
                                                5
     (D4)                             6 (y + x)

   MAXIMA knows about complex numbers and numerical constants:

     (C6) cos(%pi);
     
     (D6)                                  - 1
     
     (C7) %e^(%i*%pi);
     
     (D7)                                  - 1

   MAXIMA can do differential and integral calculus:

     (C8) u:expand((x+y)^6);
     
                6        5       2  4       3  3       4  2      5      6
     (D8)     y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (C9) diff(%,x);
     
                     5         4       2  3       3  2       4        5
     (D9)        6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (C10) integrate(1/(1+x^3),x);
     
                                              2 x - 1
                            2            ATAN(-------)
                       LOG(x  - x + 1)        SQRT(3)    LOG(x + 1)
     (D10)           - --------------- + ------------- + ----------
                              6             SQRT(3)          3

   MAXIMA can solve linear systems and cubic equations:

     (C11) linsolve( [ 3*x + 4*y = 7, 2*x + a*y = 13], [x,y]);
     
                                    7 a - 52        25
     (D11)                     [x = --------, y = -------]
                                    3 a - 8       3 a - 8
     (C12) solve( x^3 - 3*x^2 + 5*x = 15, x);
     
     (D12)              [x = - SQRT(5) %I, x = SQRT(5) %I, x = 3]

   MAXIMA can solve nonlinear sets of equations.  Note that if you don't
want a result printed, you can finish your command with `$' instead of
`;'.

     (C13) eq1: x^2 + 3*x*y + y^2 = 0$
     
     (C14) eq2: 3*x + y = 1$
     
     (C15) solve([eq1, eq2]);
     
                   3 SQRT(5) + 7      SQRT(5) + 3
     (D15) [[y = - -------------, x = -----------],
                         2                 2
     
                                         3 SQRT(5) - 7        SQRT(5) - 3
                                    [y = -------------, x = - -----------]]
                                               2                   2

   Under the X window system, MAXIMA can generate plots of one or more
functions:

     (C13) plot2d(sin(x)/x,[x,-20,20]);
     
     
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (D13)                                  0
     (C14) plot2d([atan(x), erf(x), tanh(x)], [x,-5,5]);
     
     
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (YMIN -3.0 YMAX 3.0 0.29999999999999999)
     (D14)                                  0
     (C15) plot3d(sin(sqrt(x^2+y^2))/sqrt(x^2+y^2),[x,-12,12],[y,-12,12]);
     
     (D15)                                  0

   Moving the cursor to the top left corner of the plot window will pop
up a menu that will, among other things, let you generate a PostScript
file of the plot.  (By default, the file is placed in your home
directory.)  You can rotate a 3D plot.


File: maxima.info,  Node: Help,  Next: Command Line,  Prev: Introduction to MAXIMA,  Up: Top

Help
****

* Menu:

* Introduction to Help::
* Lisp and Maxima::
* Garbage Collection::
* Documentation::
* Definitions for Help::


File: maxima.info,  Node: Introduction to Help,  Next: Lisp and Maxima,  Prev: Help,  Up: Help

Introduction to Help
====================

   The most useful online help command is DESCRIBE which obtains help
on all commands containing a particular string.  Here by command we
mean a built in operator such as INTEGRATE or FACTOR etc.   As a typing
short cut you may type `? fact' in lieu of `describe("fact")'
     (C3) ? inte;
     
     
      0: (maxima.info)Integration.
      1: Introduction to Integration.
      2: Definitions for Integration.
      3: INTERRUPTS.
      4: ASKINTEGER :Definitions for Simplification.
      5: DISPLAY_FORMAT_INTERNAL :Definitions for Input and Output.
      6: INTEGERP :Definitions for Miscellaneous Options.
      7: INTEGRATE :Definitions for Integration.
      8: INTEGRATION_CONSTANT_COUNTER :Definitions for Integration.
      9: INTERPOLATE :Definitions for Numerical.
     Enter n, all, none, or multiple choices eg 1 3 : 7 8;
     
     Info from file /d/linux2/local/share/info/maxima.info:
      - Function: INTEGRATE (EXP, VAR)
          integrates exp with respect to var or returns an integral
          expression (the noun form) if it cannot perform the integration
          (see note 1 below).  Roughly speaking three stages are used:
     ...
   In the above the user said he wanted items 7 and 8.  Note the `;'
following the two numbers.  He might have typed `all' to see help on
all the items.


File: maxima.info,  Node: Lisp and Maxima,  Next: Garbage Collection,  Prev: Introduction to Help,  Up: Help

Lisp and Maxima
===============

   All of Maxima is of course written in lisp.  There is a naming
convention for functions and variables:  All symbols which begin with a
"$" sign at lisp level, are read with the "$" sign stripped off at
Macsyma level.  For example, there are two lisp functions TRANSLATE and
$TRANSLATE.   If at macsyma level you enter TRANSLATE(FOO); the
function which is called is the $translate function.  To access the
other function you must prefix with a "?".   Note you may not put a
space after the `?' since that would indicate you were looking for help!

     (C1) ?TRANSLATE(FOO);

   Of course, this may well not do what you wanted it to do since it is
a completely different function.

   To enter a lisp command you may use
     (C1) :lisp (foo 1 2)
   or to get a lisp prompt use `to_lisp();', or alternately type
`Ctrl-c' to enter into a debug break.  This will cause a lisp break
loop to be entered.  You could now evaluate $d2 and view the value of
the line label D2, in its internal lisp format.   Typing `:q' will quit
to top level, if you are in a debug break.  If you had exited maxima
with `to_lisp();' then you should type
     MAXIMA>(run)
   at the lisp prompt, to restart the Maxima session.

   If you intend to write lisp functions to be called at macsyma level
you should name them by names beginning with a "$".   Note that all
symbols typed at lisp level are automatically read in upper case,
unless you do something like `|$odeSolve|' to force the case to be
respected.   Maxima interprets symbols as mixed case, if the symbol has
already been read before or at the time it was first read there was not
an already existing symbol with the same letters but upper case only.
Thus if you type
     (C1) Integrate;
     (D1) INTEGRATE
     (C2) Integ;
     (D2) Integ
   The symbol `Integrate' already existed in upper case since it is a
Maxima primitive, but INTEG, does not already exist, so the Integ is
permitted.   This may seem a little bizarre, but we wish to keep old
maxima code working, which assumes that Maxima primitives may be in
upper or lower case.   An advantage of this system is that if you type
in lower case, you will immediately see which are the maxima keywords
and functions.

   To enter Maxima forms at lisp level, you may use the `#$' macro.
                               (setq $foo #$[x,y]$)

   This will have the same effect as entering

     (C1)FOO:[X,Y];

except that foo will not appear in the VALUES list.  In order to view
foo in macsyma printed format you may type

     (displa $foo)

   In this documentation when we wish to refer to a macsyma symbol we
shall generally omit the $ just as you would when typing at macsyma
level.  This will cause confusion when we also wish to refer to a lisp
symbol.  In this case we shall usually try to use lower case for the
lisp symbol and upper case for the macsyma symbol.  For example LIST
for $list and list for the lisp symbol whose printname is "list".

   Since functions defined using the MAXIMA language are not ordinary
lisp functions, you must use mfuncall to call them.  For example:

     (D2)                        FOO(X, Y) := X + Y + 3

then at lisp level

     CL-MAXIMA>>(mfuncall '$foo 4 5)
     12

   A number of lisp functions are shadowed in the maxima package.  This
is because their use within maxima is not compatible with the
definition as a system function.  For example typep behaves differently
common lisp than it did in Maclisp.  If you want to refer to the zeta
lisp typep while in the maxima package you should use global:typep (or
cl:typep for common lisp).  Thus


       (macsyma:typep '(1 2)) ==> 'list
       (lisp:typep '(1 2))==> error (lisp:type-of '(1 2))==> 'cons

   To see which symbols are shadowed look in "src/maxima-package.lisp"
or do a describe of the package at lisp level.


File: maxima.info,  Node: Garbage Collection,  Next: Documentation,  Prev: Lisp and Maxima,  Up: Help

Garbage Collection
==================

   Symbolic computation tends to create a good deal of garbage, and
effective handling of this can be crucial to successful completion of
some programs.

   Under GCL, on UNIX systems where the mprotect system call is
available (including SUN OS 4.0 and some variants of BSD) a stratified
garbage collection is available.   This limits the collection to pages
which have been recently written to.    See the GCL documentation under
ALLOCATE and GBC.   At the lisp level doing (setq si::*notify-gbc* t)
will help you determine which areas might need more space.


File: maxima.info,  Node: Documentation,  Next: Definitions for Help,  Prev: Garbage Collection,  Up: Help

Documentation
=============

   The source for the documentation is in `.texi' texinfo format.  From
this format we can produce the info files used by the online commands
`? ' and `describe'.   Also `html' and `pdf' files can be produced.

   Additionally there are examples so that you may do
     example(integrate);
     (C4) example(integrate);
     (C5) test(f):=BLOCK([u],u:INTEGRATE(f,x),RATSIMP(f-DIFF(u,x)));
     (D5) test(f) := BLOCK([u], u :
              INTEGRATE(f, x), RATSIMP(f - DIFF(u, x)));
     (C6) test(SIN(x));
     (D6) 						       0
     (C7) test(1/(x+1));
     (D7) 						       0
     (C8) test(1/(x^2+1));
     (D8) 						       0
     (C9) INTEGRATE(SIN(X)^3,X);


File: maxima.info,  Node: Definitions for Help,  Prev: Documentation,  Up: Help

Definitions for Help
====================

 - Function: DEMO (file)
     this is the same as BATCH but pauses after each command line and
     continues when a space is typed (you may need to type `;' followed
     by a newline, if running under xmaxima).   The demo files have
     suffix `.dem'


 - Function: DESCRIBE (cmd)
     This command prints documentation on all commands which contain
     the substring "cmd".   Thus
          (C1) describe("integ");
           0: (maxima.info)Integration.
           1: Introduction to Integration.
           2: Definitions for Integration.
           3: ASKINTEGER :Definitions for Simplification.
          ..
          Enter n, all, none, or multiple choices eg 1 3 : 2 3;
          Info from file /d/linux2/local/share/info/maxima.info:
          Definitions for Integration
          ===========================
          
           - Function: CHANGEVAR (EXP,F(X,Y),Y,X)
          ...
     *note Introduction to Help::


 - Function: EXAMPLE (command)
     will start up a demonstration of how command works on some
     expressions.  After each command line it will pause and wait for a
     space to be typed, as in the DEMO command.

     The name of the file containing the examples is given by the
     variable manual_demo, which defaults to "maxima.demo".



File: maxima.info,  Node: Command Line,  Next: Operators,  Prev: Help,  Up: Top

Command Line
************

* Menu:

* Introduction to Command Line::
* Definitions for Command Line::


File: maxima.info,  Node: Introduction to Command Line,  Next: Definitions for Command Line,  Prev: Command Line,  Up: Command Line

Introduction to Command Line
============================

 - Function: %TH (i)
     is the ith previous computation.  That is, if the next expression
     to be computed is D(j) this is D(j-i).  This is useful in BATCH
     files or for referring to a group of D expressions.  For example,
     if SUM is initialized to 0 then FOR I:1 THRU 10 DO SUM:SUM+%TH(I)
     will set SUM to the sum of the last ten D expressions.


 - operator: "'"
     - (single quote) has the effect of preventing evaluation.  E.g.
     '(F(X)) means do not evaluate the expression F(X).  'F(X) means
     return the noun form of F applied to [X].


 - operator: """
     - (two single quotes) causes an extra evaluation to occur.  E.g.
     "c4; will re-execute line C4.  "(F(X)) means evaluate the
     expression F(X) an extra time.  "F(X) means return the verb form
     of F applied to [X].



File: maxima.info,  Node: Definitions for Command Line,  Prev: Introduction to Command Line,  Up: Command Line

Definitions for Command Line
============================

 - Function: ALIAS (newname1, oldname1, newname2, oldname2, ...)
     provides an alternate name for a (user or system) function,
     variable, array, etc.  Any even number of arguments may be used.


 - Function: DEBUG ()
     LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG(); make available to
     the user debugging features used by systems programmers.  These
     tools are powerful, and although some conventions are different
     from the usual macsyma level it is felt their use is very
     intuitive.  [Some printout may be verbose for slow terminals,
     there are switches for controlling this.]  These commands were
     designed for the user who must debug translated macsyma code, as
     such they are a boon.  See MACDOC;TRDEBG USAGE for more
     information.


 - Variable: DEBUGMODE
     default: [FALSE] - causes MACSYMA to enter a MACSYMA break loop
     whenever a MACSYMA error occurs if it is TRUE and to terminate
     that mode if it is FALSE.  If it is set to ALL then the user may
     examine BACKTRACE for the list of functions currently entered.


 - Function: DEBUGPRINTMODE ()
     LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG(); make available to
     the user debugging features used by systems programmers.  These
     tools are powerful, and although some conventions are different
     from the usual macsyma level it is felt their use is very
     intuitive.  [Some printout may be verbose for slow terminals,
     there are switches for controlling this.]  These commands were
     designed for the user who must debug translated macsyma code, as
     such they are a boon.  See MACDOC;TRDEBG USAGE for more
     information.


 - Function: EV (exp, arg1, ..., argn)
     is one of MACSYMA's most powerful and versatile commands. It
     evaluates the expression exp in the environment specified by the
     argi.  This is done in steps, as follows:
        *     (1) First the environment is set up by scanning the argi
          which may be as follows: SIMP causes exp to be simplified
          regardless of the setting of the switch SIMP which inhibits
          simplification if FALSE.  NOEVAL supresses the evaluation
          phase of EV (see step (4) below).  This is useful in
          conjunction with the other switches and in causing exp to be
          resimplified without being reevaluated.  EXPAND causes
          expansion.  EXPAND(m,n) causes expansion, setting the values
          of MAXPOSEX and MAXNEGEX to m and n respectively.  DETOUT
          causes any matrix inverses computed in exp to have their
          determinant kept outside of the inverse rather than dividing
          through each element.  DIFF causes all differentiations
          indicated in exp to be performed.  DERIVLIST(var1,...,vark)
          causes only differentiations with respect to the indicated
          variables.  FLOAT causes non-integral rational numbers to be
          converted to floating point.  NUMER causes some mathematical
          functions (including exponentiation) with numerical arguments
          to be evaluated in floating point.  It causes variables in
          exp which have been given numervals to be replaced by their
          values.  It also sets the FLOAT switch on.  PRED causes
          predicates (expressions which evaluate to TRUE or FALSE) to
          be evaluated.  EVAL causes an extra post-evaluation of exp to
          occur. (See step (5) below.)  E where E is an atom declared
          to be an EVFLAG causes E to be bound to TRUE during the
          evaluation of exp.  V:expression (or alternately
          V=expression) causes V to be bound to the value of expression
          during the evaluation of exp.  Note that if V is a MACSYMA
          option, then expression is used for its value during the
          evaluation of exp.  If more than one argument to EV is of
          this type then the binding is done in parallel.  If V is a
          non-atomic expression then a substitution rather than a
          binding is performed.  E where E, a function name, has been
          declared to be an EVFUN causes E to be applied to exp.  Any
          other function names (e.g.  SUM) cause evaluation of
          occurrences of those names in exp as though they were verbs.
          In addition a function occurring in exp (say F(args)) may be
          defined locally for the purpose of this evaluation of exp by
          giving F(args):=body as an argument to EV.  If an atom not
          mentioned above or a subscripted variable or subscripted
          expression was given as an argument, it is evaluated and if
          the result is an equation or assignment then the indicated
          binding or substitution is performed.  If the result is a
          list then the members of the list are treated as if they were
          additional arguments given to EV. This permits a list of
          equations to be given (e.g. [X=1, Y=A**2] ) or a list of
          names of equations (e.g.  [E1,E2] where E1 and E2 are
          equations) such as that returned by SOLVE.  The argi of EV
          may be given in any order with the exception of substitution
          equations which are handled in sequence, left to right, and
          EVFUNS which are composed, e.g. EV(exp,RATSIMP,REALPART) is
          handled as REALPART(RATSIMP(exp)).  The SIMP, NUMER, FLOAT,
          and PRED switches may also be set locally in a block, or
          globally at the "top level" in MACSYMA so that they will
          remain in effect until being reset.  If exp is in CRE form
          then EV will return a result in CRE form provided the NUMER
          and FLOAT switches are not both TRUE.

        *     (2) During step (1), a list is made of the non-subscripted
          variables appearing on the left side of equations in the argi
          or in the value of some argi if the value is an equation.
          The variables (both subscripted variables which do not have
          associated array functions, and non-subscripted variables) in
          the expression exp are replaced by their global values,
          except for those appearing in this list.  Usually, exp is
          just a label or % (as in (C2) below), so this step simply
          retrieves the expression named by the label, so that EV may
          work on it.

        *     (3) If any substitutions are indicated by the argi, they
          are carried out now.

        *     (4) The resulting expression is then re-evaluated (unless
          one of the argi was NOEVAL) and simplified according the the
          argi.  Note that any function calls in exp will be carried
          out after the variables in it are evaluated and that EV(F(X))
          thus may behave like F(EV(X)).

        *     (5) If one of the argi was EVAL, steps (3) and (4) are
          repeated.

                               Examples
          
          (C1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
                                  d                 2
          (D1)  COS(Y) + SIN(X) + -- SIN(W) + (W + 1)
                                  dW
          (C2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
                              2
          (D2)      COS(W) + W  + 2 W + COS(1) + 1.90929742

     An alternate top level syntax has been provided for EV, whereby one
     may just type in its arguments, without the EV().  That is, one may
     write simply
          exp, arg1, ...,argn.

     This is not permitted as part of another expression, i.e. in
     functions, blocks, etc.

          (C4) X+Y,X:A+Y,Y:2;
          (D4)                Y + A + 2
          (Notice the parallel binding process)
          (C5) 2*X-3*Y=3$
          (C6) -3*X+2*Y=-4$
          (C7) SOLVE([D5,D6]);
          SOLUTION
                                          1
          (E7)                     Y =  - -
                                          5
                                    6
          (E8)                  X = -
                                    5
          (D8)               [E7, E8]
          (C9) D6,D8;
          (D9)               - 4 =  - 4
          (C10) X+1/X > GAMMA(1/2);
                              1
          (D10)           X + - > SQRT(%PI)
                              X
          (C11) %,NUMER,X=1/2;
          (D11)            2.5 > 1.7724539
          (C12) %,PRED;
          (D12)                  TRUE


 - Variable: EVFLAG
     default: [] - the list of things known to the EV function.  An
     item will be bound to TRUE during the execution of EV if it is
     mentioned in the call to EV, e.g. EV(%,numer);.  Initial evflags
     are

          FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE,
          KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
          RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER,
          RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER,
          PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
          EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM,
          NUMER_PBRANCH, M1PBRANCH, DOTSCRULES, and LOGEXPAND.


 - Variable: EVFUN
     - the list of functions known to the EV function which will get
     applied if their name is mentioned.  Initial evfuns are FACTOR,
     TRIGEXPAND, TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, RADCAN,
     LOGCONTRACT, RECTFORM, and POLARFORM.


 - special symbol: INFEVAL
     leads to an "infinite evaluation" mode.  EV repeatedly evaluates
     an expression until it stops changing.  To prevent a variable, say
     X, from being evaluated away in this mode, simply include X='X as
     an argument to EV.  Of course expressions such as
     EV(X,X=X+1,INFEVAL); will generate an infinite loop.  CAVEAT
     EVALUATOR.


 - Function: KILL (arg1, arg2, ...)
     eliminates its arguments from the MACSYMA system.  If argi is a
     variable (including a single array element), function, or array,
     the designated item with all of its properties is removed from
     core.  If argi=LABELS then all input, intermediate, and output
     lines to date (but not other named items) are eliminated. If
     argi=CLABELS then only input lines will be eliminated; if
     argi=ELABELS then only intermediate E-lines will be eliminated; if
     argi=DLABELS only the output lines will be eliminated.  If argi is
     the name of any of the other information lists (the elements of
     the MACSYMA variable INFOLISTS), then every item in that class
     (and its properties) is KILLed and if argi=ALL then every item on
     every information list previously defined as well as LABELS is
     KILLed.  If argi=a number (say n), then the last n lines (i.e. the
     lines with the last n line numbers) are deleted.  If argi is of
     the form [m,n] then all lines with numbers between m and n
     inclusive are killed. Note that KILL(VALUES) or KILL(variable)
     will not free the storage occupied unless the labels which are
     pointing to the same expressions are also KILLed.  Thus if a large
     expression was assigned to X on line C7 one should do KILL(D7) as
     well as KILL(X) to release the storage occupied.
     KILL(ALLBUT(name1,...,namek) will do a KILL(ALL) except it will not
     KILL the names specified.  (Note: namei means a name such as U, V,
     F, G, not an infolist such as FUNCTIONS.)      KILL removes all
     properties from the given argument thus KILL(VALUES) will kill all
     properties associated with every item on the VALUES list whereas
     the REMOVE set of functions
     (REMVALUE,REMFUNCTION,REMARRAY,REMRULE) remove a specific property.
     Also the latter print out a list of names or FALSE if the specific
     argument doesn't exist whereas KILL always has value "DONE" even if
     the named item doesn't exist.      Note that killing expressions
     will not help the problem which occurs on MC indicated by "NO CORE
     - FASLOAD" which results when either too many FASL files have been
     loaded in or when allocation level has gotten too high.  In either
     of these cases, no amount of killing will cause the size of these
     spaces to decrease.  Killing expressions only causes some spaces
     to get emptied out but not made smaller.


 - Function: LABELS (char)
     takes a char C, D, or E as arg and generates a list of all
     C-labels, D-labels, or E- labels, respectively.  If you've
     generated many E- labels via SOLVE, then
          FIRST(REST(LABELS(C)))
     reminds you what the last C-label was.  LABELS will take as arg
     any symbolic name, so if you have reset INCHAR, OUTCHAR, or
     LINECHAR, it will return the list of labels whose first character
     matches the first character of the arg you give to LABELS.  The
     variable, LABELS, default: [], is a list of C, D, and E lines
     which are bound.


 - Variable: LASTTIME
     - the time to compute the last expression in milliseconds
     presented as a list of "time" and "gctime".


 - Variable: LINENUM
     - the line number of the last expression.


 - Variable: MYOPTIONS
     default: [] - all options ever reset by the user (whether or not
     they get reset to their default value).


 - Variable: NOLABELS
     default: [FALSE] - if TRUE then no labels will be bound except for
     E lines generated by the solve functions.  This is most useful in
     the "BATCH" mode where it eliminates the need to do KILL(LABELS)
     in order to free up storage.


 - Variable: OPTIONSET
     default: [FALSE] - if TRUE, MACSYMA will print out a message
     whenever a MACSYMA option is reset.  This is useful if the user is
     doubtful of the spelling of some option and wants to make sure
     that the variable he assigned a value to was truly an option
     variable.


 - Function: PLAYBACK (arg)
     "plays back" input and output lines.  If arg=n (a number) the last
     n expressions (Ci, Di, and Ei count as 1 each) are "played-back",
     while if arg is omitted, all lines are.  If arg=INPUT then only
     input lines are played back. If arg=[m,n] then all lines with
     numbers from m to n inclusive are played-back.  If m=n then [m] is
     sufficient for arg.  Arg=SLOW places PLAYBACK in a slow-mode
     similar to DEMO's (as opposed to the "fast" BATCH).  This is
     useful in conjunction with SAVE or STRINGOUT when creating a
     secondary-storage file in order to pick out useful expressions.
     If arg=TIME then the computation times are displayed as well as
     the expressions.  If arg=GCTIME or TOTALTIME, then a complete
     breakdown of computation times are displayed, as with
     SHOWTIME:ALL;.  Arg=STRING strings-out (see STRING function) all
     input lines when playing back rather than displaying them.  If
     ARG=GRIND "grind" mode can also be turned on (for processing input
     lines) (see GRIND).  One may include any number of options as in
     PLAYBACK([5,10],20,TIME,SLOW).


 - Function: PRINTPROPS (a, i)
     will display the property with the indicator i associated with the
     atom a. a may also be a list of atoms or the atom ALL in which
     case all of the atoms with the given property will be used.  For
     example, PRINTPROPS([F,G],ATVALUE).  PRINTPROPS is for properties
     that cannot otherwise be displayed, i.e. for ATVALUE, ATOMGRAD,
     GRADEF, and MATCHDECLARE.


 - Variable: PROMPT
     default: [_] is the prompt symbol of the DEMO function,
     PLAYBACK(SLOW) mode, and (MACSYMA-BREAK).


 - Function: QUIT ()
     kills the current MACSYMA but doesn't affect the user's other
     jobs;  equivalent to exiting to DCL and stopping the MACSYMA
     process.  One may "quit" to MACSYMA top-level by typing Control-C
     Control-G; Control-C gets NIL's interrupt prompt, at which one
     types either Control-G or just G.  Typing X at the Interrupt
     prompt will cause a quit in a computation started within a
     MACSYMA-BREAK without disrupting the suspended main computation.


 - Function: REMFUNCTION (f1, f2, ...)
     removes the user defined functions f1,f2,... from MACSYMA.  If
     there is only one argument of ALL then all functions are removed.


 - Function: RESET ()
     causes all MACSYMA options to be set to their default values.
     (Please note that this does not include features of terminals such
     as LINEL which can only be changed by assignment as they are not
     considered to be computational features of MACSYMA.)


 - Function: RESTORE (file-specification)
     reinitializes all quantities filed away by a use of the SAVE or
     STORE functions, in a prior MACSYMA session, from the file given
     by file-specification without bringing them into core.


 - Variable: SHOWTIME
     default: [FALSE] - if TRUE then the computation time will be
     printed automatically with each output expression.  By setting
     SHOWTIME:ALL, in addition to the cpu time MACSYMA now also prints
     out (when not zero) the amount of time spent in garbage collection
     (gc) in the course of a computation.  This time is of course
     included in the time printed out as "time=" .  (It should be noted
     that since the "time=" time only includes computation time and not
     any intermediate display time or time it takes to load in
     out-of-core files, and since it is difficult to ascribe
     "responsibility" for gc's, the gctime printed will include all
     gctime incurred in the course of the computation and hence may in
     rare cases even be larger than "time=").


 - Function: SSTATUS (feature,package)
     - meaning SET STATUS.  It can be used to SSTATUS( FEATURE,
     HACK_PACKAGE) so that STATUS( FEATURE, HACK_PACKAGE) will then
     return TRUE.  This can be useful for package writers, to keep
     track of what FEATURES they have loaded in.


 - Function: TOBREAK ()
     causes the MACSYMA break which was left by typing TOPLEVEL; to be
     re-entered.  If TOBREAK is given any argument whatsoever, then the
     break will be exited, which is equivalent to typing TOBREAK()
     immediately followed by EXIT;.


 - Function: TOPLEVEL ()
     During a break one may type TOPLEVEL;.  This will cause top-level
     MACSYMA to be entered recursively.  Labels will now be bound as
     usual.  Everything will be identical to the previous top-level
     state except that the computation which was interrupted is saved.
     The function TOBREAK() will cause the break which was left by
     typing TOPLEVEL; to be re-entered.  If TOBREAK is given any
     argument whatsoever, then the break will be exited, which is
     equivalent to typing TOBREAK() immediately followed by EXIT;.


 - Function: TO_LISP ()
     enters the LISP system under MACSYMA.  This is useful on those
     systems where control-uparrow is not available for this function.


 - Variable: TTYINTFUN
     default: [FALSE] - Governs the function which will be run whenever
     the User-interrupt-character is typed.  To use this feature, one
     sets TTYINTFUN (default FALSE meaning feature not in use) to a
     function of no arguments.  Then whenever (e.g.) ^U (control-U) is
     typed, this function is run.  E.g. suppose you have a FOR statement
     loop which increments I, and you want an easy way of checking on
     the value of I while the FOR statement is running.  You can do:
     TTYINTFUN:PRINTI$ PRINTI():=PRINT(I)$ , then whenever you type
     (e.g.)  ^U you get the check you want.


 - Variable: TTYINTNUM
     default: [21] (the ascii value of Control-U (^U), U being the 21st
     letter of the alphabet).  This controls what character becomes the
     User-interrupt-character.  ^U was chosen for it mnemonic value.
     Most users should not reset TTYINTNUM unless they are already
     using ^U for something else.


 - Variable: VALUES
     default:[] - all bound atoms, i.e. user variables, not MACSYMA
     Options or Switches, (set up by : , :: , or functional binding).



File: maxima.info,  Node: Operators,  Next: Expressions,  Prev: Command Line,  Up: Top

Operators
*********

* Menu:

* NARY::
* NOFIX::
* OPERATOR::
* POSTFIX::
* PREFIX::
* Definitions for Operators::


File: maxima.info,  Node: NARY,  Next: NOFIX,  Prev: Operators,  Up: Operators

NARY
====

   - An NARY operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the operator,
e.g. A+B or A+B+C.  The NARY("x") function is a syntax extension
function to declare x to be an NARY operator.  Do DESCRIBE(SYNTAX); for
more details.  Functions may be DECLAREd to be NARY.  If
DECLARE(J,NARY); is done, this tells the simplifier to simplify, e.g.
J(J(A,B),J(C,D)) to J(A, B, C, D).


File: maxima.info,  Node: NOFIX,  Next: OPERATOR,  Prev: NARY,  Up: Operators

NOFIX
=====

   - NOFIX operators are used to denote functions of no arguments.  The
mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a MACSYMA break, "exit" is behaving similar to a
NOFIX operator.  The function NOFIX("x") is a syntax extension function
which declares x to be a NOFIX operator.  Do DESCRIBE(SYNTAX); for more
details.


File: maxima.info,  Node: OPERATOR,  Next: POSTFIX,  Prev: NOFIX,  Up: Operators

OPERATOR
========

   - See OPERATORS


File: maxima.info,  Node: POSTFIX,  Next: PREFIX,  Prev: OPERATOR,  Up: Operators

POSTFIX
=======

   - POSTFIX operators like the PREFIX variety denote functions of a
single argument, but in this case the argument immediately precedes an
occurrence of the operator in the input string, e.g. 3! .  The
POSTFIX("x") function is a syntax extension function to declare x to be
a POSTFIX operator.  Do DESCRIBE(SYNTAX); for details.


File: maxima.info,  Node: PREFIX,  Next: Definitions for Operators,  Prev: POSTFIX,  Up: Operators

PREFIX
======

   - A PREFIX operator is one which signifies a function of one
argument, which argument immediately follows an occurrence of the
operator.  PREFIX("x") is a syntax extension function to declare x to
be a PREFIX operator.  Do DESCRIBE(SYNTAX); for more details.

