<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Orthogonal Polynomials</TITLE>
<link href="maxima_17.html" rel=Next>
<link href="maxima_15.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_15.html">previous</A>, <A HREF="maxima_17.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC53" HREF="maxima_toc.html#TOC53">Orthogonal Polynomials</A></H1>



<H2><A NAME="SEC54" HREF="maxima_toc.html#TOC54">Introduction to Orthogonal Polynomials</A></H2>

<P>
The specfun package, located in the share directory,  contains Maxima
code for the evaluation of all orthogonal polynomials listed in 
Chapter 22 of Abramowitz and Stegun. These include Chebyshev, 
Laguerre, Hermite, Jacobi, Legendre, and ultraspherical (Gegenbauer) 
polynomials.  Additionally, specfun contains code for 
spherical Bessel, spherical  Hankel, and spherical harmonic functions. 

</P>
<P>
The following table lists each  function in specfun,
its Maxima name, restrictions on its arguments 
( m  and  n  must be integers), and a 
reference to the algorithm specfun uses to evaluate it.
With few exceptions, specfun follows the conventions of  
Abramowitz and Stegun.  Before you use specfun, check
that specfun's conventions match your expectations.

</P>
<P>
A&#38;S refers to Abramowitz and Stegun, <EM>Handbook of 
Mathematical Functions</EM> (10th printing, December 1972), 
G&#38;R to Gradshteyn and Ryzhik, 
<EM>Table of Integrals, Series, and Products</EM>
(1980 corrected and enlarged edition), and Merzbacher 
to <EM>Quantum Mechanics</EM> (2ed, 1970).  

</P>
<TABLE>

<TR><EM>Function</EM> <TD>  <EM>Maxima Name</EM>  <TD> <EM>Restrictions</EM> <TD> <EM>Reference(s)</EM>
<BR>
<TR>&#160;Chebyshev T <TD> chebyshev_t(n, x) <TD> n &#62; -1 <TD> A&#38;S 22.5.31
<BR>
<TR>Chebyshev U <TD> chebyshev_u(n, x) <TD> n &#62; -1 <TD> A&#38;S 22.5.32
<BR>
<TR>generalized Laguerre <TD> gen_laguerre(n,a,x) <TD> n &#62; -1 <TD> A&#38;S page 789
<BR>
<TR>Laguerre <TD> laguerre(n,x) <TD> n &#62; -1 <TD> A&#38;S 22.5.67
<BR>
<TR>Hermite <TD> hermite(n,x) <TD>  n &#62; -1 <TD> A&#38;S 22.4.40, 22.5.41
<BR>
<TR>Jacobi <TD> jacobi_p(n,a,b,x) <TD>  n &#62; -1, a, b &#62; -1 <TD> A&#38;S page 789
<BR>
<TR>associated Legendre P <TD> assoc_legendre_p(n,m,x) <TD> n &#62; -1 <TD> A&#38;S 22.5.37, 8.6.6, 8.2.5
<BR>
<TR>associated Legendre Q <TD> assoc_legendre_q(n,m,x) <TD> n &#62; -1, m &#62; -1 <TD> G &#38; R 8.706
<BR>
<TR>Legendre P <TD> legendre_p(n,m,x) <TD> n &#62; -1 <TD> A&#38;S 22.5.35
<BR>
<TR>Legendre Q <TD> legendre_q(n,m,x) <TD> n &#62; -1 <TD> A&#38;S 8.6.19
<BR>
<TR>spherical Hankel 1st <TD> spherical_hankel1(n, x) <TD> n &#62; -1 <TD> A&#38;S 10.1.36
<BR>
<TR>spherical Hankel 2nd <TD> spherical_hankel2(n, x) <TD> n &#62; -1 <TD> A&#38;S 10.1.17
<BR>
<TR>spherical Bessel J <TD> spherical_bessel_j(n,x) <TD> n &#62; -1 <TD> A&#38;S 10.1.8, 10.1.15
<BR>
<TR>spherical Bessel Y <TD> spherical_bessel_y(n,x) <TD> n &#62; -1 <TD> A&#38;S 10.1.9, 10.1.15
<BR>
<TR>spherical harmonic <TD> spherical_harmonic(n,m,x,y) <TD> n &#62; -1, |m| &#60;= n <TD> Merzbacher 9.64
<BR>
<TR>ultraspherical (Gegenbauer) <TD> ultraspherical(n,a,x) <TD>  n &#62; -1 <TD> A&#38;S 22.5.27
</TABLE>

The specfun package is primarily intended for symbolic 
computation. It is hoped  that it gives accurate floating point 
results as well; however, no claims are made  that the algorithms 
are well suited for numerical evaluation.  Some effort, however,
has been made to provide good numerical performance.
When all arguments, except for the order, are floats (but not bfloats), 
many functions in specfun call a float modedeclared version of the
Jacobi function.  This  greatly speeds floating point evaluation
of the orthogonal polynomials.

specfun handles most domain errors  by returning an unevaluated
function.  No attempt has been made to define simplification
rules (based on recursion relations) for unevaluated functions.
Users should be aware that it is possible for an expression
involving sums of unevaluated special functions to vanish, yet 
Maxima is unable to reduce it to zero.  Be careful.

To access functions in specfun, you must first load specfun.o. 
Alternatively, you may append autoload statements to your 
init.lsp file (located in your working directory). To autoload  the 
hermite function, for example, append

<PRE>
   (defprop |$hermite| #"specfun.o" autoload) 
   (add2lnc '|$hermite| $props) 
</PRE>

to your init.lsp file.  An example use of specfun is

<PRE>
(c1) load("specfun.o")$
(c2) [hermite(0,x),hermite(1,x),hermite(2,x)];
(d2) [1,2*x,-2*(1-2*x^2)]
(c3) diff(hermite(n,x),x);
(d3) 2*n*hermite(n-1,x)
</PRE>

When using the compiled version of specfun, be especially
careful to  use the correct number of function arguments; calling
them with too few arguments may generate a fatal error messages.  
For example

<PRE>
(c1) load("specfun")$
/* chebyshev_t requires two arguments. */
(c2) chebyshev_t(8);
Error: Caught fatal error [memory may be damaged]
Fast links are on: do (si::use-fast-links nil) for debugging
Error signalled by MMAPCAR.
Broken at SIMPLIFY.  Type :H for Help.
</PRE>

Maxima code translated into Lisp handles such errors more gracefully. 
If specfun.LISP is installed on your machine, the same computation 
results in  a clear error message.  For example

<PRE>
(c1) load("specfun.LISP")$
(c2) chebyshev_t(8);
Error: Expected 2 args but received 1 args
Fast links are on: do (si::use-fast-links nil) for debugging
Error signalled by MACSYMA-TOP-LEVEL.
Broken at |$CHEBYSHEV_T|.  Type :H for Help.
</PRE>

Generally, compiled code runs faster than translated code; however, 
translated code may be better for program development.

For some functions, when the order is symbolic but has been 
declared to be an integer, specfun will return a series 
representation.  (The series representation is not
used by specfun for any computations.) You may use this feature to 
find symbolic values for special values orthogonal polynomials.  
An example:

<PRE>
(c1) load("specfun")$
(c2) legendre_p(n,1);
(d2)        legendre_p(n, 1)
/* Declare n to be an integer; now legendre_p(n,1) evaluates to 1. */
(c3) declare(n,integer)$
(c4) legendre_p(n,1);
(d4)        1
(c5) ultraspherical(n,3/2,1);
(d4)         (n+1)*gamma (n+3) / (2*gamma (n+2))
</PRE>

Although the preceding example doesn't show it, two terms
of the sum are added outside the summation.  Removing these
two terms avoids errors associated with  0^0 terms
in a sum that should evaluate to 1, but evaluate to 0 in a Maxima 
summation. Because the sum index runs from 1 to 
n - 1, the lower sum 
index will exceed the upper sum index when  n = 0; 
setting sumhack to true provides a fix. For example:


<PRE>
(c1) load("specfun.o")$
(c2) declare(n,integer)$
(c3) e : legendre_p(n,x)$
(c4) ev(e,sum,n=0);
Lower bound to SUM: 1
is greater than the upper bound: - 1
 -- an error.  Quitting.  To debug this try DEBUGMODE(TRUE);)
(c5) ev(e,sum,n=0),sumhack : true;
(d5)         1
</PRE>

Most  functions in specfun have a gradef property; 
derivatives with respect to the order or other function parameters 
aren't unevaluated. 

The specfun package and its documentation were written by
Barton Willis of the University of Nebraska at Kearney. It is 
released under the terms of the General Public License (GPL).
Send bug reports and comments on this package to 
willisb@unk.edu.  In your  report, please include 
Maxima and specfun version information.  The specfun
version may be found using get:

<PRE>
 (c2) get('specfun,'version);
 (d2)          110
 @end example



<H2><A NAME="SEC55" HREF="maxima_toc.html#TOC55">Definitions for Orthogonal Polynomials</A></H2>

<P>
<DL>
<DT><U>Function:</U> <B>ASSOC_LEGENDRE_P</B> <I>(n, m, x)</I>
<DD><A NAME="IDX464"></A>[specfun package] return the associated Legendre function
of the first kind for  integers  n &#62; -1  and 
 m &#62; -1.  When  | m | &#62; n  and  n &#62;= 0,
we have   assoc_legendre_p (n, m, x) = 0.
Reference: A&#38;S 22.5.37 page 779,  A&#38;S 8.6.6 (second 
equation) page 334, and A&#38;S 8.2.5 page 333.
To access this function, load("specfun").
See  <A HREF="maxima_16.html#ASSOC_LEGENDRE_Q">ASSOC_LEGENDRE_Q</A>,  <A HREF="maxima_16.html#LEGENDRE_P">LEGENDRE_P</A>, and  <A HREF="maxima_16.html#LEGENDRE_Q">LEGENDRE_Q</A>.
</DL>

</P>
<a name="ASSOC_LEGENDRE_Q"></a><P>
<DL>
<DT><U>Function:</U> <B>ASSOC_LEGENDRE_Q</B> <I>(n, m, x)</I>
<DD><A NAME="IDX465"></A>
</P>
<P>
[specfun package] return the associated Legendre function
of the second kind for  integers  n &#62; -1  and 
 m &#62; -1. 

</P>
<P>
Reference: Gradshteyn and Ryzhik  8.706 page 1000.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also ASSOC_LEGENDRE_P, LEGENDRE_P, and LEGENDRE_Q.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>CHEBYSHEV_T</B> <I>(n, x)</I>
<DD><A NAME="IDX466"></A>
</P>
<P>
[specfun package] return the Chebyshev function of the first kind
for  integers  n &#62; -1.

</P>
<P>
Reference: A&#38;S 22.5.31 page 778 and A&#38;S 6.1.22 page 256.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also CHEBYSHEV_U.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>CHEBYSHEV_U</B> <I>(n, x)</I>
<DD><A NAME="IDX467"></A>
</P>
<P>
[specfun package] return the Chebyshev function of the 
second kind for integers  n &#62; -1.

</P>
<P>
Reference: A&#38;S, 22.8.3 page 783  and A&#38;S 6.1.22 page 256. 

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also CHEBYSHEV_T.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>GEN_LAGUERRE</B> <I>(n, a, x)</I>
<DD><A NAME="IDX468"></A>
</P>
<P>
[specfun package] return the generalized Laguerre polynomial
for  integers  n &#62; -1.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
Reference: table on page 789 in A&#38;S.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> <B>HERMITE</B> <I>(n,x)</I>
<DD><A NAME="IDX469"></A>
</P>
<P>
[specfun package] return the Hermite polynomial for
integers  n &#62; -1.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
Reference:  A&#38;S 22.5.40 and 22.5.41, page 779.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>JACOBI_P</B> <I>(n, a, b, x)</I>
<DD><A NAME="IDX470"></A>
</P>
<P>
[specfun package] return the Jacobi polynomial for
integers  n &#62; -1  and  a  and  b 
symbolic or  a &#62; -1  and b &#62; -1.  
(The Jacobi polynomials are actually defined for all
 a  and  b ; however, the Jacobi polynomial
weight  (1-x)^a(1+x)^b isn't integrable for  a &#60;= -1 or  
 b &#60;= -1. ) 

</P>
<P>
When a, b, and  x  are floats (but not bfloats)  
specfun calls a special modedeclared version of jacobi_p.
For numerical values, the modedeclared version is much 
faster than the other version. Many  functions in specfun are 
computed as a special case of the  Jacobi polynomials; they also 
enjoy the  speed boost from the modedeclared version of 
 jacobi.

</P>
<P>
If  n  has been declared to be an integer, 
jacobi_p (n, a, b, x) returns a summation representation
for the Jacobi function. Because Maxima simplifies 
0^0  to  0  in a sum, two terms of the sum are
added outside the summation.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
Reference:  table on page 789 in A&#38;S.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>LAGUERRE</B> <I>(n, x)</I>
<DD><A NAME="IDX471"></A>
</P>
<P>
[specfun package] return the Laguerre polynomial for 
integers  n &#62; -1.  

</P>
<P>
Reference: A&#38;S 22.5.16, page 778 and A&#38;S page 789.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also GEN_LAGUERRE.

</P>
</DL>

<a name="LEGENDRE_P"></a><P>
<DL>
<DT><U>Function:</U> <B>LEGENDRE_P</B> <I>(n, x)</I>
<DD><A NAME="IDX472"></A>
</P>

<P>
[specfun package] return the Legendre polynomial of the 
first kind for  integers  n &#62; -1.  

</P>
<P>
Reference: A&#38;S 22.5.35 page 779.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See  <A HREF="maxima_16.html#LEGENDRE_Q">LEGENDRE_Q</A>.

</P>
</DL>

<a name="LEGENDRE_Q"></a><P>
<DL>
<DT><U>Function:</U> <B>LEGENDRE_Q</B> <I>(n, x)</I>
<DD><A NAME="IDX473"></A>
</P>
<P>
[specfun package] return the Legendre polynomial of the 
first kind for  integers  n &#62; -1.  

</P>
<P>
Reference: A&#38;S 8.6.19 page 334.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also LEGENDRE_P.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>SPHERICAL_BESSEL_J</B> <I>(n, x)</I>
<DD><A NAME="IDX474"></A>
</P>
<P>
[specfun package] return the spherical Bessel function of
the first kind for  integers  n &#62; -1.  

</P>
<P>
Reference: A&#38;S 10.1.8 page 437 and A&#38;S 10.1.15 page 439.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also SPHERICAL_HANKEL1, SPHERICAL_HANKEL2, 
and SPHERICAL_BESSEL_Y.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>SPHERICAL_BESSEL_Y</B> <I>(n, x)</I>
<DD><A NAME="IDX475"></A>
</P>
<P>
[specfun package] return the spherical Bessel function of
the second kind for  integers  n &#62; -1.  

</P>
<P>
Reference: A&#38;S 10.1.9 page 437 and 10.1.15 page 439.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also SPHERICAL_HANKEL1, SPHERICAL_HANKEL2, 
and SPHERICAL_BESSEL_Y.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>SPHERICAL_HANKEL1</B> <I>(n,x)</I>
<DD><A NAME="IDX476"></A>
</P>
<P>
[specfun package] return the spherical hankel function  of the
first kind for  integers  n &#62; -1.  

</P>
<P>
Reference: A&#38;S 10.1.36 page 439.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also SPHERICAL_HANKEL2, SPHERICAL_BESSEL_J, and
SPHERICAL_BESSEL_Y.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>SPHERICAL_HANKEL2</B> <I>(n,x)</I>
<DD><A NAME="IDX477"></A>
</P>
<P>
[specfun package] return the spherical hankel function  of the
second kind for  integers  n &#62; -1.  

</P>
<P>
Reference:  A&#38;S 10.1.17 page 439.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also SPHERICAL_HANKEL1, SPHERICAL_BESSEL_J, and
SPHERICAL_BESSEL_Y.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>SPHERICAL_HARMONIC</B> <I>(n, m, x, y)</I>
<DD><A NAME="IDX478"></A>
</P>
<P>
[specfun package] return the spherical harmonic function
for  integers  n &#62; -1 and  | m | &#60;= n .

</P>
<P>
Reference:  Merzbacher 9.64.

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also ASSOC_LEGENDRE_P

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>ULTRASPHERICAL</B> <I>(n,a,x)</I>
<DD><A NAME="IDX479"></A>
</P>
<P>
[specfun package] return the ultraspherical polynomials for  
integers  n &#62; -1.  The ultraspherical polynomials are
also known as Gegenbauer polynomials.

</P>
<P>
Reference: A&#38;S 22.5.27

</P>
<P>
To access this function, load("specfun").

</P>
<P>
See also JACOBI_P.

</P>
</DL>

<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_15.html">previous</A>, <A HREF="maxima_17.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
