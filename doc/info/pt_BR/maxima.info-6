This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para linearalgebra,  Prev: Introdução a linearalgebra,  Up: linearalgebra

57.2 Definições para linearalgebra
==================================

 -- Função: addmatrices (<f>, <M_1>, ..., <M_n>)
     Usando a função <f> como a função de adição, retorne a adição das
     matrizes <M_1>, ..., <M_n>. A função <f> deve aceitar qualquer
     número de argumentos (uma função enária do Maxima).

     Exemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])


 -- Função: blockmatrixp (<M>)
     Retorna `true' se e somente se <M> for uma matriz e toda entrada de
     <M> também for uma matriz.


 -- Função: columnop (<M>, <i>, <j>, <theta>)
     Se <M> for uma matriz, retorna a matriz que resulta de fazer a
     operação de coluna `C_i <- C_i - <theta> * C_j'. Se <M> não tiver
     uma linha <i> ou <j>, emite uma mensagem de erro.


 -- Função: columnswap (<M>, <i>, <j>)
     Se <M> for uma matriz, troca as colunas <i> e <j>.  Se <M> não
     tiver uma coluna <i> ou <j>, emite uma mensagem de erro.


 -- Função: columnspace (<M>)
     Se <M> for uma matriz, retorna `span (v_1, ..., v_n)', onde o
     conjunto `{v_1, ..., v_n}' é uma base para o espaço coluna de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é `{0}'. Dessa forma, quando o espaço coluna tiver somente
     um membro, retorna `span ()'.


 -- Função: copy (<e>)
     Retorna uma cópia da expressão <e> do Maxima. Embora <e> possa ser
     qualquer expressão do Maxima, Afunção `copy' é mais útil quando
     <e> for ou uma lista ou uma matriz; considere: load
     (linearalgebra); m : [1,[2,3]]$ mm : m$ mm[2][1] : x$ m; mm;
          (%i1) load("linearalgebra")$
          (%i2) m : [1,[2,3]]$
          (%i3) mm : m$
          (%i4) mm[2][1] : x$
          (%i5) m;
          (%o5) [1,[x,3]]
          (%i6) mm;
          (%o6) [1,[x,3]]
     Vamos tentar a mesma experiência, mas dessa vez tomemos <mm> como
     sendo uma cópia de <m> m : [1,[2,3]]$ mm : copy(m)$ mm[2][1] : x$
     m; mm;
          (%i7) m : [1,[2,3]]$
          (%i8) mm : copy(m)$
          (%i9) mm[2][1] : x$
          (%i10) m;
          (%o10) [1,[2,3]]
          (%i11) mm;
          (%o11) [1,[x,3]]
     Dessa vez, a atribuição a <mm> não muda o valor de <m>.


 -- Função: cholesky (<M>)
 -- Função: cholesky (<M>, <corpo>)
     Retorna fatorização de Cholesky da matriz hermitiana (or
     autoadjunta) <M>. O valor padrão para o segundo argumento é
     `generalring'. Para uma descrição dos possíveis valores para
     <corpo>, veja `lu_factor'.


 -- Função: ctranspose (<M>)
     Retorna a matriz transposta conjugada complexa da matriz <M>. A
     função `ctranspose' usa `matrix_element_transpose' para transpor
     cada elemento da matriz.


 -- Função: diag_matrix (<d_1>, <d_2>,...,<d_n>)
     Retorna uma matriz diagonal matriz com entradas de diagonal <d_1>,
     <d_2>,...,<d_n>.  Quando as entradas de diagonal forem matrizes,
     as entradas zero da matriz retornada serão todas matrizes de
     tamanho apropriado; por exemplo:
          (%i1) load(linearalgebra)$

          (%i2) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o2)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i3) diag_matrix(p,q);

                                             [ p  0 ]
          (%o3)                              [      ]
                                             [ 0  q ]

 -- Função: dotproduct (<u>, <v>)
     Retorna o produto do ponto (produto escalar) dos vetores <u> e
     <v>.  Isso é o mesmo que `conjugate (transpose (<u>)) . <v>'.  Os
     argumentos <u> e <v> devem ser vetores coluna.


 -- Função: eigens_by_jacobi (<A>)
 -- Função: eigens_by_jacobi (<A>, <tipo_corpo>)
     Calculam os autovalores e autovetores de <A> pelo método de
     rotações de Jacobi.  <A> deve ser uma matriz simétrica (mas essa
     matriz simétrica precisa não ser nem definida positiva e nem
     semidefinida positiva).  <tipo_corpo> indica o corpo
     computacional, pode ser ou `floatfield' ou `bigfloatfield'.  Se
     <tipo_corpo> não for especificado, o padrão é `floatfield'.

     Os elementos de <A> devem ser números ou expressões que avaliam
     para números via `float' ou `bfloat' (dependendo do valor de
     <tipo_corpo>).

     Exemplos:

          (%i1) load (linearalgebra);
          (%o1) /home/robert/tmp/maxima-head/maxima/share/linearalgebra/li\
          nearalgebra.mac
          (%i2) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o2)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i3) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o3)                 [                  ]
                                [    0     sqrt(5) ]
          (%i4) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o4)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i5) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) float ([[sqrt(3), sqrt(5)], S]);
          (%o6) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i7) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o7) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]


 -- Função: get_lu_factors (<x>)
     Quando `<x> = lu_factor (<A>)', então `get_lu_factors' retorna uma
     lista da forma `[P, L, U]', onde <P> é uma matriz de permutação,
     <L> é triangular baixa com a diagonal preenchida com a unidade, e
     <U> é triangular alta, e `<A> = <P> <L> <U>'.


 -- Função: hankel (<col>)
 -- Função: hankel (<col>, <lin>)
     Retorna uma matriz de Hankel <H>. A primeira coluna de <H> é <col>;
     exceto para a primeira entrada, a última linha de <H> é <lin>. O
     valor padrão para <lin> é o vetor nulo com o mesmo comprimento que
     <col>.


 -- Função: hessian (<f>,<vars>)
     Retorna a matriz hessiana de <f> com relação às variáveis na lista
     <vars>.  As entradas <i>,<j> da matriz hessiana são <diff(f
     vars[i],1,vars[j],1)>.


 -- Função: hilbert_matrix (<n>)
     Retorna the <n> by <n> matriz de Hilbert. Quando <n> não for um
     inteiro positivo, emite uma mensagem de erro.


 -- Função: identfor (<M>)
 -- Função: identfor (<M>, <corpo>)
     Retorna uma matriz identidade que tem o mesmo tamanho que a matriz
     <M>.  As entradas de diagonal da matriz identidade são a
     identidade multiplicativa do corpo <corpo>; o padrão para <corpo>
     é <generalring>.

     O primeiro argumento <M> pode ser uma  matriz quadrada ou um não
     matriz. Quando <M> for uma matriz, cada entrada de <M> pode ser uma
     matriz quadrada - dessa forma <M> pode ser uma matriz de bloco do
     Maxima. A matriz pode ser de bloco para qualquer (finita)
     quantidade de níveis.

     Veja também `zerofor'


 -- Função: invert_by_lu (<M>, <(rng generalring)>)
     Inverte a matriz <M> através de fatorização linear alta (LU).  A
     fatorização LU é concluída usando o anel <rng>.


 -- Função: kronecker_product (<A>, <B>)
     Retorna o produto de Kronecker das matrizes <A> e <B>.


 -- Função: listp (<e>, <p>)
 -- Função: listp (<e>)
     Recebendo um argumento opcional <p>, retorna `true' se <e> for uma
     lista do Maxima e <p> avalia para `true' para elemento da lista.
     Quando `listp' não recebe o argumento opcional, retorna `true' se
     <e> for uma lista do Maxima.  em todos os outros casos, retorna
     `false'.


 -- Função: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)
     O primeiro argumento deve ser uma matriz; os argumentos que vão de
     <r_1> até <c_2> determinam um sub-matriz de <M> que consiste de
     linhas que vão de <r_1> até <r_2> e colunas que vão de <c_1> até
     <c_2>.

     Encontra uma entrada na sub-matriz <M> que satisfaz alguma
     propriedade.  Existem três casos:

     (1) `<rel> = 'bool' e <f> um predicado:

     Examina a sub-matriz da esquerda para a direita e de cima para
     baixo, e retorna o índice da primeria entrada que satisfizer o
     predicado <f>. Se nenhuma entrada da matriz satisfizer o predicado
     <f>, retorna `false'.

     (2) `<rel> = 'max' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que maximize <f>.
     Retorna retorna o índice da entrada maximizada.

     (3) `<rel> = 'min' e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que minimize <f>.
     Retorna o índice de uma entrada minimizada.


 -- Função: lu_backsub (<M>, <b>)
     Quando `<M> = lu_factor (<A>, <corpo>)', então `lu_backsub (<M>,
     <b>)' resolve o sistema linear `<A> <x> = <b>'.


 -- Função: lu_factor (<M>, <corpo>)
     Retorna uma lista da forma `[<LU>, <perm>, <corpo>]', ou da forma
     `[<LU>, <perm>, <cmp>, <baixo-cnd> <alto-cnd>]', onde

     (1) A matriz <LU> contéa fatorização de <M> na forma enpacotada.
     Forma       empacotada significa três coisas: Primeiro, as linhas
     de <LU> são permutadas confirme a       lista <perm>.  Se, por
     exemplo, <perm> for a lista list `[3,2,1]', a primeira linha atual
          da fatorização <LU> será a terceira linha da matriz <LU>.
     Segundo,       o fator triangular baixo de m é a parte triangular
     baixa de <LU> com as       entradas de diagonal todas substituídas
     pela unidade. Terceiro, o fator triangular alto de       <M> é a
     parte triangular alta de <LU>.

     (2) Quando o corpo for ou `floatfield' ou `complexfield',       os
     números <baixo-cnd> e <alto-cnd> serão associados baixo e alto
     para o       número condicional de norma infinita de <M>.  Para
     todos os corpos (fields), o número condicional de norma infinita
        não pode ser estimado; para tais corpos, `lu_factor' retorna
     uma lista com dois itens.        Ambos o baixo e o alto associado
     podem diferir de seus verdadeiros valores de       fatores
     arbitráriamente grandes. (Veja também `mat_cond'.)

     O argumento <M> deve ser a matriz quadrada.

     O argumento opcional <cmp> deve ser um símbolo que determine um
     anel ou corpo. Os corpos e anéis   predefinidos são:

     (a) `generalring' - o anel de expressões do Maxima,     (b)
     `floatfield' -  o corpo dos números em ponto flutuante do tipo de
     precisão dupla,     (c) `complexfield' -  o corpo dos números
     complexos em ponto flutuante do         tipo de precisão dupla,
     (d) `crering'  - o anel das expressões racionais canônicas (CRE)
     do Maxima,     (e) `rationalfield' - o corpo dos números racionais,
        (f) `runningerror' - rastro de todos os erros de
     arredondamento de números em ponto flutuante,      (g)
     `noncommutingring' - o anel de expressões do Maxima onde
     multiplicação for o         operador ponto não comutativo.

     Quando o corpo for `floatfield', `complexfield', ou
     `runningerror', o algorítmo usa pivotagem parcial; para todos os
     outros corpos, linhas são comutadas somente quando necessário para
     evitar um pivô nulo.

     A adição aritmética em ponto flutuante não é associativa, então o
     significado de 'corpo' difere da definição matemática.

     Um membro do corpo `runningerror' é uma lista do Máxima de dois
     membros da forma `[x,n]',onde <x> é um número em onto flutuante e
     `n' é um inteiro. A diferença relativa entre o valor de
     'verdadeiro' de `x' e `x' é aproximadamente associado pelo épsilon
     da máquina vezes `n'. O erro de execução associado arrasta alguns
     termos da ordem do quadrado do épsilon da máquina.

     Não existe interface de usuário definida um novo anel. Um usuário
     que estiver familiazrizado com o Lisp Comum está apto para definir
     um novo corpo.  Para fazer isso, um usuário deve definir funções
     para as operações aritméticas e funções para conversão para a
     representação de corpo do Máxima e vice-versa. Adicionalmente,
     para corpos ordenados (onde a pivotagem parcial será usada), um
     uduário deve definir funções para módulo e para comparar membros
     do corpo.  Após isso tudo que resta é definir uma estrutura de
     Lisp Comum `mring'.  O arquivo `mring' tem muitos exemplos.

     Para calcular a fatorização, a primeira tarefa é converter cada
     entrada de matriz para um elemento do corpo indicado. Quando a
     cnversão não for possível, a fatorização encerra com uma mensagem
     de erro. Elementos do corpo não precisam ser expressões do Maxima.
     Elementos do `complexfield', por exemplo, são números complexos
     do Lisp Comum. Dessa forma após calcular a fatorização, como
     entradas da matriz devem ser convertidas para expressões do Maxima.

     Veja também  `get_lu_factors'.

     Exemplos:
          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) w[i,j] := random (1.0) + %i * random (1.0);
          (%o2)          w     := random(1.) + %i random(1.)
                          i, j
          (%i3) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i4) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i5) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i6) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i7) showtime : false$

          (%i8) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o8)                   [              ]
                                  [   3    8 - z ]
          (%i9) lu_factor (M, generalring);
                         [ 1 - z         3        ]
                         [                        ]
          (%o9)         [[   3            9       ], [1, 2]]
                         [ -----  - z - ----- + 8 ]
                         [ 1 - z        1 - z     ]
          (%i10) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o10) [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i11) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o11)                  [              ]
                                  [   3    8 - z ]


 -- Função: mat_cond (<M>, 1)
 -- Função: mat_cond (<M>, inf)
     Retorna o número condiciona da norma de ordem <p> da matriz <m>.
     Os valores permitidos para <p> são 1 e <inf>.  Essa função utiliza
     a fatorização linear alta para inverter a matriz <m>. Dessa forma
     o tempode execução para `mat_cond' é proporcional ao cubo do
     tamanho da matriz; `lu_factor' determina as associaçãoes baixa e
     alta para o número de condição de norma infinita em tempo
     proporcional ao quadrado do tamanho da matriz.


 -- Função: mat_norm (<M>, 1)
 -- Função: mat_norm (<M>, inf)
 -- Função: mat_norm (<M>, frobenius)
     Retorna a matriz de norma <p> da matriz <M>.  Os valores
     permitidos para <p> são 1, `inf', e `frobenius' (a norma da matriz
     de Frobenius). A matriz <M> pode ser uma matriz não de bloco.


 -- Função: matrixp (<e>, <p>)
 -- Função: matrixp (<e>)
     Fornecendo um argumento opcional <p>, `matrixp' retorna `true' se
     <e> for uma matriz e <p> avaliar para `true' para todo elemento da
     matriz.  Quando a `matrixp' não for fornecido umargumento
     opcional, retorna `true' se `e' for uma matriz.  em todos os
     outros casos, retorna `false'.

     Veja também `blockmatrixp'


 -- Função: matrix_size (<M>)
     Retorna uma lista com dois elementos que fornecem o número de
     linhas e colunas, respectivamente da matriz <M>.


 -- Função: mat_fullunblocker (<M>)
     Se <M> for uma matriz de bloco, expande todos os blocos da matriz
     em todos os níveis. Se <M> for uma matriz, retorna <M>; de outra
     forma, emite uma mensagem de erro.


 -- Função: mat_trace (<M>)
     Retorna o traço da matriz <M>. Se <M> não for uma matriz, retorna
     uma forma substantiva. Quando <M> for uma matriz de bloco,
     `mat_trace(M)' retorna o mesmo valor retornado por
     `mat_trace(mat_unblocker(m))'.


 -- Função: mat_unblocker (<M>)
     Se <M> for uma matriz de bloco, `mat_unbloker' desfaz o bloco de
     <M> um nível. Se <M> for uma matriz, `mat_unblocker (M)' retorna
     <M>; de outra forma, emite uma mensagem de erro.

     Dessa forma se cada entrada de <M> for matriz, `mat_unblocker (M)'
     retorna uma matriz "desblocada", mas se cada entrada de <M> for
     uma matriz de bloco, `mat_unblocker (M)' retorna uma matriz de
     bloco com um nível de bloco a menos.

     Se você usa matrizes de bloco, muito provavelmente você irá querer
     escolher `matrix_element_mult' para `"."' e
     `matrix_element_transpose' para `'transpose'. Veja também
     `mat_fullunblocker'.

     Exemplo:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o2)                       [      ]
                                      [ 3  4 ]
          (%i3) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o3)                       [       ]
                                      [ 9  10 ]
          (%i4) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o4)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i5) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o5)                    [             ]
                                   [ 3  4  9  10 ]


 -- Função: nonnegintegerp (<n>)
     Retorna `true' se e somente se `<n> >= 0' e <n> for um inteiro.


 -- Função: nullspace (<M>)
     Se <M> for uma matriz, retorna `span (v_1, ..., v_n)', onde o
     conjunto `{v_1, ..., v_n}' é uma base para o espaço nulo de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é  `{0}'.  Dessa forma, quando o espaço nulo tiver somente
     um membro, retorna `span ()'.


 -- Função: nullity (<M>)
     Se <M> for uma matriz, retorna a dimensão do espaço nulo de <M>.


 -- Função: orthogonal_complement (<v_1>, ..., <v_n>)
     Retorna `span (u_1, ..., u_m)', onde o conjunto `{u_1, ..., u_m}'
     é uma base para o complemento ortogonal do conjunto `(v_1, ...,
     v_n)'.

     Cada vetor no intervalo de <v_1> até <v_n> deve ser um vetor
     coluna.


 -- Função: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Função: polynomialp (<p>, <L>, <coeffp>)
 -- Função: polynomialp (<p>, <L>)
     Retorna `true' se <p> for um polinômio nas variáveis da lista <L>,
     O predicado <coeffp> deve avaliar para `true' para cada
     coeficiente, e o predicado <exponp> deve avaliar para `true' para
     todos os expoentes das variáveis na lista <L>. Se você quiser usar
     um valor personalizado para <exponp>, você deve fornecer <coeffp>
     com um valor mesmo se você quiser o valor padrão para <coeffp>.

     `polynomialp (<p>, <L>, <coeffp>)' é equivalente a `polynomialp
     (<p>, <L>, <coeffp>, 'nonnegintegerp)'.

     `polynomialp (<p>, <L>)' é equivalente a `polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     O polinômio não precisa ser expandido:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp ((x + 1)*(x + 2), [x]);
          (%o2)                         true
          (%i3) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o3)                         false

     Um exemplo usando um valor personalizado para `coeffp' e para
     `exponp':

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o2)                         true
          (%i3) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o3)                         true

     Polinômios com duas variáveis:

          (%i1) load (linearalgebra);
          Warning - you are redefining the Maxima function require_list
          Warning - you are redefining the Maxima function matrix_size
          Warning - you are redefining the Maxima function rank
          (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o2)                         false
          (%i3) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o3)                         true


 -- Função: polytocompanion (<p>, <x>)
     Se <p> for um polinômio em <x>, retorna a atriz companheira de
     <p>. Para um polinômio mônico <p> de grau <n>, temos `<p> =
     (-1)^<n> charpoly (polytocompanion (<p>, <x>))'.

     Quando <p> não for um polinômio em <x>, emite uma mensagem de erro.


 -- Função: ptriangularize (<M>, <v>)
     Se <M> for uma matriz onde cada entrada dessa matriz for um
     polinômio em <v>, retorna a matriz <M2> tal que

     (1) <M2> é triangular alta,

     (2) `<M2> = <E_n> ... <E_1> <M>', onde os elemetnos de <E_1> a
     <E_n> são matrizes elementares cujas entrada são polinômios em <v>,

     (3) `|det (<M>)| = |det (<M2>)|',

     Nota: Essa função não verifica se toda entrada é um polinômio em
     <v>.


 -- Função: rowop (<M>, <i>, <j>, <theta>)
     Se <M> for uma matriz, retorna a matriz que resulta de se fazer a
     operação de linha `R_i <- R_i - theta * R_j'. Se <M> não tiver uma
     linha <i> ou <j>, emite uma mensagem de erro.


 -- Função: rank (<M>)
     Retorna o ranque daquela matriz <M>. O rank é a dimensão do
     espaço coluna. Exemplo:
          (%i1) load (linearalgebra)$
          WARNING: DEFUN/DEFMACRO: redefining function $COPY in
                   /share/maxima/5.11.0/share/linearalgebra/linalg-utilities.lisp,
                   was defined in
                   /maxima-5.11.0/src/binary-clisp/comm2.fas
          (%i2) rank(matrix([1,2],[2,4]));
          (%o2)                                  1
          (%i3) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o3)                                  2


 -- Função: rowswap (<M>, <i>, <j>)
     Se <M> for uma matriz, permuta as linha <i> e <j>. Se <M> não
     tiver uma linha <i> ou <j>, emite uma mensagem de erro.


 -- Função: toeplitz (<col>)
 -- Função: toeplitz (<col>, <lin>)
     Retorna uma matriz de Toeplitz <T>. a primeira coluna de <T> é
     <col>; exceto para a primeira entrada, a primeira linha de <T> é
     <lin>. O padrão para <lin> é o conjugado complexo de <col>.
     Exemplo:
          (%i1) load(linearalgebra)$

          (%i2)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o2)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i3)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o3)                         [                ]
                                        [ %I + 1    1    ]


 -- Função: vandermonde_matrix ([<x_1>, ..., <x_n>])
     Retorna uma matriz <n> por <n> cuja <i>-ésima linha é `[1, <x_i>,
     <x_i>^2, ... <x_i>^(<n>-1)]'.


 -- Função: zerofor (<M>)
 -- Função: zerofor (<M>, <fld>)
     Retorna uma matriz zero que tem o mesmo tamanho da matriz <M>.
     Toda entrada da matriz zero é a identidade aditiva do anel <fld>;
     o valor padrão para <fld> é <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou uma não
     matriz. Quando <M> for uma matriz, cada entrada de <M> pode ser uma
     matriz quadrada - dessa forma <M> pode ser uma matriz de bloco do
     Maxima. A matriz pode ser de bloco para qualquer nível (finito).

     Veja também `identfor'


 -- Função: zeromatrixp (<M>)
     Se <M> não for uma matriz de bloco, retorna `true' se `is (equal
     (<e>, 0))' for verdadeiro para cada elemento <e> da matriz <M>.
     Se <M> for uma matriz de bloco, retorna `true' se `zeromatrixp'
     avaliar para `true' para cada elemento de <e>.



File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

58 lsquares
***********

/lsquares.texi/1.1/Mon Feb 27 22:09:17 2006//

* Menu:

* Definições para lsquares::


File: maxima.info,  Node: Definições para lsquares,  Prev: lsquares,  Up: lsquares

58.1 Definições para lsquares
=============================

 -- Variável global: DETCOEF
     Essa variável é usada pelas funções `lsquares' e `plsquares' para
     armazenar o Coeficiente de Determinação que mede o melhor do
     ajuste. Esse intervalo de 0 (nenhuma correlação) a 1
     (correlação exata).

     Quando `plsquares' for chamada com uma lista de variáveis
     independentes, <DETCOEF> é escolhida para uma lista de
     Coeficientes de Determinação. Veja `plsquares' para detalhes.

     Veja também `lsquares'.

 -- Função: lsquares (<Mat>,<VarList>,<equação>,<ParamList>)
 -- Função: lsquares
          (<Mat>,<VarList>,<equação>,<ParamList>,<EsperadosList>)
     Ajuste múltiplo de equações não lineares de uma tabela de dados
     pelo método dos "mínimos quadrados". <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um para
     cada coluna de <Mat>), <equação> é a equação a ser ajustada (essa
     equação deve estar na forma: `depvar=f(indepvari,...,
     paramj,...)', `g(depvar)=f(indepvari,..., paramj,...)' ou na forma
     `g(depvar, paramk,...)=f(indepvari,..., paramj,...)'), <ParamList>
     é a lista de parâmetros para obter, e <EsperadosList> é uma lista
     opcional de aproximações iniciais para os parâmetros; quando esse
     último argumento estiver presente, `mnewton' é usado em lugar de
     `solve' com o objetivo de pegar os parâmetros.

     A equação pode ser completamente não linear com relação às
     variáveis independentes e à variável dependente.  Com o objetivo
     de usar `solve()', as equações devem ser lineares ou polinomiais
     com relação aos parâmetros. Equações como `y=a*b^x+c' podem ser
     ajustadas para `[a,b,c]' com `solve' se os valores de `x' forem
     inteiros positivos pequenos e existam poucos dados (veja o exemplo
     em lsquares.dem).  `mnewton' permite ajustar uma equação não
     linear com relação aos parâmetros, mas um bom conjunto de
     aproximações iniciais deve ser fornecido.

     Se possível, a equação ajustada é retornada. Se existir mais de
     uma solução, uma lista de equações é retornada.  O Coeficiente de
     Determinação é mostrado para informar sobre o melhor do ajuste, de
     0 (nenhuma correlação) a 1 (correlação exata).  Esse valor é
     também armazenada na vriável global <DETCOEF>.

     Exemplos usando `solve':
          (%i1) load("lsquares")$

          (%i2) lsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                         [x,y,z], z=a*x*y+b*x+c*y+d, [a,b,c,d]);
                Determination Coefficient = 1.0
                              x y + 23 y - 29 x - 19
          (%o2)           z = ----------------------
                                        6
          (%i3) lsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                         [n,p], p=a4*n^4+a3*n^3+a2*n^2+a1*n+a0,
                   [a0,a1,a2,a3,a4]);
                Determination Coefficient = 1.0
                               4       3      2
                            3 n  - 10 n  + 9 n  - 2 n
          (%o3)         p = -------------------------
                                        6
          (%i4) lsquares(matrix([1,7],[2,13],[3,25]),
                         [x,y], (y+c)^2=a*x+b, [a,b,c]);
                Determination Coefficient = 1.0
          (%o4) [y = 28 - sqrt(657 - 216 x),
                                          y = sqrt(657 - 216 x) + 28]
          (%i5) lsquares(matrix([1,7],[2,13],[3,25],[4,49]),
                         [x,y], y=a*b^x+c, [a,b,c]);
                Determination Coefficient = 1.0
                                        x
          (%o5)                  y = 3 2  + 1

     Exemplos usando `mnewton':
          (%i6) load("lsquares")$

          (%i7) lsquares(matrix([1.1,7.1],[2.1,13.1],[3.1,25.1],[4.1,49.1]),
                         [x,y], y=a*b^x+c, [a,b,c], [5,5,5]);
                                                       x
          (%o7) y = 2.799098974610482 1.999999999999991
                                                  + 1.099999999999874
          (%i8) lsquares(matrix([1.1,4.1],[4.1,7.1],[9.1,10.1],[16.1,13.1]),
                         [x,y], y=a*x^b+c, [a,b,c], [4,1,2]);
                                       .4878659755898127
          (%o8) y = 3.177315891123101 x
                                                  + .7723843491402264
          (%i9) lsquares(matrix([0,2,4],[3,3,5],[8,6,6]),
                        [m,n,y], y=(A*m+B*n)^(1/3)+C, [A,B,C], [3,3,3]);
                                                               1/3
          (%o9) y = (3.999999999999862 n + 4.999999999999359 m)
                                                   + 2.00000000000012

     Para usar essa função escreva primeiro `load("lsquares")'. Veja
     também `DETCOEF' e `mnewton'.

 -- Função: plsquares (<Mat>,<VarList>,<depvars>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Ajuste de polinômios de várias variáveis de uma tabela de dados
     pelo método dos "mínimos quadrados". <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um nome
     para cada coluna de Mat, mas use "-" em lugar de nomes de
     variáveis para colunas de Mat), <depvars> é o nome de uma variável
     dependente ou uma lista com um ou mais nomes de variáveis
     dependentes (os quais nomes podem estar em <VarList>), <maxexpon>
     é o expoente máximo opcional para cada variável independente (1
     por padrão), e <maxdegree> é o argumento opcional grau máximo do
     polinômio (<maxexpon> por padrão); note que a soma dos expoentes
     de cada termo deve ser menor ou igual a <maxdegree>, e se
     `maxdgree = 0' então nenhum limite é aplicado.

     Se <depvars> é o nome de uma variável dependente (fora de uma
     lista), `plsquares' retorna o polinômio ajustado. Se <depvars> for
     uma lista de uma ou mais variáveis dependentes, `plsquares'
     retorna uma lista com o(s) polinômio(s) ajustado(s). Os
     Coeficientes de Determinação são mostrados com o objetivo de
     informar sobre o melhor do ajuste, cujo intervalo vai de 0
     (nenhuma correlação) a 1 (correlação exata). Esses valores são
     também são também armazenados na variável global <DETCOEF> (uma
     lista se <depvars> for também uma lista).

     Um simples exemplo de ajuste linear de várias variáveis:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     O mesmo exemplo sem restrições de gra:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Quantas diagonais possi um polígono de N lados tem? What
     polynomial degree should be used?
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonais],diagonais,5);
               Determination Coefficient for diagonais = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonais = --------
                                            2
          (%i5) ev(%, N=9);   /* Testando para um polígono de 9 lados - o eneágono */
          (%o5)                 diagonals = 27

     Quantos caminhos fazemos para colocar  duas raínhas sem que elas
     estejam ameaçadas em um tabuleiro de xadrez n x n ?
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,posicoes],[posicoes],4);
               Determination Coefficient for [posicoes] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [posicoes  = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Tesando para um tabuleiro de (8 x 8) */
          (%o7)                posicoes = 1288

     Em exemplo com seis variáveis dependentes:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Para usar essa função escreva primeiramente `load("lsquares")'.


File: maxima.info,  Node: makeOrders,  Next: mnewton,  Prev: lsquares,  Up: Top

59 makeOrders
*************

* Menu:

* Definições para makeOrders::


File: maxima.info,  Node: Definições para makeOrders,  Prev: makeOrders,  Up: makeOrders

59.1 Definições para makeOrders
===============================

 -- Função: makeOrders (<indvarlist>,<orderlist>)
     Retorna uma lista de todos os expoentes para um polinômio acima de
     e incluindo os argumentos.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     onde `[0, 1]' está associado ao termo b e `[2, 3]' está associado
     ao termo a^2 b^3.

     Para usar essa função escreva primeiro `load("makeOrders")'.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: makeOrders,  Up: Top

60 mnewton
**********

* Menu:

* Definições para mnewton::


File: maxima.info,  Node: Definições para mnewton,  Prev: mnewton,  Up: mnewton

60.1 Definições para mnewton
============================

 -- Variável de opção: newtonepsilon
     Valor padrão: `10.0^(-fpprec/2)'

     Precisão para determinar quando a função `mnewton' convergiu em
     direção à solução.

     Veja também `mnewton'.

 -- Variável de opção: newtonmaxiter
     Valor padrão: `50'

     Número máximo de iterações que para a função `mnewton' caso essa
     função não seja convergente ou se convergir muito lentamente.

     Veja também `mnewton'.

 -- Função: mnewton (<FuncList>,<VarList>,<GuessList>)
     Solução de multiplas funções não lineares usando o método de
     Newton.  <FuncList> é a lista de funções a serem resolvidas,
     <VarList> é a lista dos nomes de variáveis, e <GuessList> é a
     lista de aproximações iniciais.

     A solução é retornada no mesmo formato retornado pela função
     `solve()'.  Caso a solução não seja encontrada, `[]' é retornado.

     Essa função é controlada através das variáveis globais
     `newtonepsilon' e `newtonmaxiter'.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     Para usar essa função primeiro escreva `load("mnewton")'. Veja
     também `newtonepsilon' e `newtonmaxiter'.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

61 numericalio
**************

* Menu:

* Introdução a numericalio::
* Definições para numericalio::


File: maxima.info,  Node: Introdução a numericalio,  Next: Definições para numericalio,  Prev: numericalio,  Up: numericalio

61.1 Introdução a numericalio
=============================

`numericalio' é uma coleção de funções para ler e escrever arquivos de
dados.  O arquivo é lido completamente para construir um objeto;
leituras parciais não são suportadas.

   É assumido que cada item a ler ou escrever é atômico: um número
inteiro, número em ponto flutuante, grande número em ponto flutuante,
seqüência de caracteres, ou símbolo, e não um número racional ou um
número complexo ou qualquer outro tipo de expressão não atômica.  Essas
funções podem tentar fazer alguma coisa levemente parecida com
expressões não atômicas, mas os resultados não são especificados aqui e
são sujeitos a mudanças.

   Átomos em ambos os arquivos de entrada e saída possuem o mesmo
formato que em arquivos de lote do Maxima ou no console interativo.  Em
particular, seqüência de caracteres são contidas dentro de aspas duplas,
contrabarra `\' evita qualquer interpretação especial do caractere
seguinte, e o ponto de interrogação `?' é reconhecido no início de um
símbolo para significar um símbolo do Lisp (em oposição a um símbolo do
Maxima).  Nenhum caractere de continuação (para continuar linhas
quebradas) é reconhecido.

   <separator_flag> diz que caracteres separa elementos.
<separator_flag> é um argumento opcional para todas as funções de
leitura e escrita.

   Para entrada, os valores de <separator_flag> reconhecidos são:
`comma' para valores separados por vírgula, `pipe' para valores
separados pelo caractere barra vertical `|', `semicolon' para valores
separados por ponto e vírgula `;', e `space' para valores separados
pelos caracteres de espaço e de tabulação.  Se o nome do arquivo a ser
lido/escrito termina em `.csv' e <separator_flag> não for especificado,
`comma' é assumido.  Se o nome do arquivo termina em alguma outra coisa
que não `.csv' e `separator_flag' não for especificado, `space' é
assumido.

   Para saída, os mesmos quatro sinalizadores são reconhecidos como na
entrada, e também `tab', para valores separados pelo caractere de
tabulaçao.

   Em entrada, múltiplos espaços e multiplas tabulações sucessivas
contam como um separador simples.  Todavia, múltiplas vírgulas, barras
verticais, ou ponto-e-vírgulas são significativos.  Sucessivas
vírgulas, barras verticais, ou ponto-e-vírgulas (com ou sem
intercalação de espaços ou tabulações) são considerados como tendo
`false' entre os separadores.  Por exemplo, `1234,,Foo' é tratado da
mesma forma que `1234,false,Foo'.  Em saídas, os átomos `false' são
escritos como tais; uma lista `[1234, false, Foo]' é escrita
`1234,false,Foo', e não é tentado colapsar a saída para `1234,,Foo'.


File: maxima.info,  Node: Definições para numericalio,  Prev: Introdução a numericalio,  Up: numericalio

61.2 Definições para numericalio
================================

 -- Função: read_matrix (<nomearquivo>)
 -- Função: read_matrix (<nomearquivo>, <separator_flag>)
     Lê o arquivo <nomearquivo> e retorna seu conteúdo completo como
     uma matriz.  Se <separator_flag> não for especificado, o arquivo é
     assumido como delimitado por espaços em branco.

     `read_matrix' infere o tamanho da matriz dos dados de entrada.
     Cada linha do arquivo inicia uma linha da matriz.  Se algumas
     linhas possuirem diferentes comprimentos, `read_matrix' reclama.


 -- Função: read_lisp_array (<nomearquivo>, <A>)
 -- Função: read_lisp_array (<nomearquivo>, <A>, <separator_flag>)
     `read_lisp_array' exige que o array seja declarado através de
     `make_array' antes de chamar a função de leitura. (Isso obviamente
     é necessário para inferir a dimensão do array, que pode ser um
     problema para arrays com múltiplas dimensões.)

     `read_lisp_array' não verifica para ver se o arquivo de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando `fillarray'.


 -- Função: read_maxima_array (<nomearquivo>, <A>)
 -- Função: read_maxima_array (<nomearquivo>, <A>, <separator_flag>)
     `read_maxima_array' requer que o array seja declarado através de
     `array' antes de chamar a função de leitura. (Isso obviamente é
     necessário para inferir a dimensão do array, que pode ser uma
     hassle para arrays com múltiplas dimensões.)

     `read_maxima_array' não verifica para ver se o arquivo de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando `fillarray'.


 -- Função: read_hashed_array (<nomearquivo>, <A>)
 -- Função: read_hashed_array (<nomearquivo>, <A>, <separator_flag>)
     `read_hashed_array' trata o primeiro item sobre uma linha como uma
     chave hash, e associa o restante da linha (como uma lista) com a
     chava.  Por exemplo, a linha `567 12 17 32 55' é equivalente a
     `A[567]: [12, 17, 32, 55]$'.  Linhas não precisam ter o mesmo
     número de elementos.


 -- Função: read_nested_list (<nomearquivo>)
 -- Função: read_nested_list (<nomearquivo>, <separator_flag>)
     `read_nested_list' retorna uma lista que tem uma sublista para cada
     linha de entrada. Linhas não precisam ter o mesmo n´umero de
     elementos.  Linhas vazias não são ignoradas: uma linha vazia
     retorna uma sublista vazia.


 -- Função: read_list (<nomearquivo>)
 -- Função: read_list (<nomearquivo>, <separator_flag>)
     `read_list' lê todas as entradas em uma lista monótona.
     `read_list' ignora o caractere de fim de linha.


 -- Função: write_data (<X>, <nomearquivo>)
 -- Função: write_data (<object>, <nomearquivo>, <separator_flag>)
     `write_data' escreve o objeto <X> no arquivo <nomearquivo>.

     `write_data' escreve matrizes da forma usual, com uma linha por
     fileira.

     `write_data' escreve arrays declarados do Lisp e do Maxima da
     forma usual, com um caractere de nova linha no final de todo
     pedaço.  Pedaços dimensionais muito grandes são separados por meio
     de novas linhas adicionais.

     `write_data' escreve arrays desordenados com uma chave seguida por
     a lista associada sobre cada linha.

     `write_data' escreve a lista seguinte com cada sublista em uma
     linha.

     `write_data' escreve uma lista monótona toda em uma linha.

     Se `write_data' anexa ao final ou abandona os excessos em seus
     arquivos de saída é governado através da variável global
     `file_output_append'.



File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

62 opsubst
**********

* Menu:

* Definições para  opsubst::


File: maxima.info,  Node: Definições para opsubst,  Prev: opsubst,  Up: opsubst

62.1 Definições para  opsubst
=============================

 -- Função: opsubst (<f>,<g>,<e>)
 -- Função: opsubst (<g>=<f>,<e>)
 -- Função: opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     A função `opsubst'  similar à função `subst', exceto que `opsubst'
     somente faz substituições para as operações em uma expressões. Em
     geral, quando <f> for um operador em uma expressão <e>, substitui
     <g> por <f> na expressão <e>.

     Para determinar o operador, `opsubst' escolhe `inflag' para
     verdadeiro ( true ). Isso significa que `opsubst' substitui para a
     forma de operador interna, não para a mostrada, na expressão.

     Exemplos:
          (%i1) load (opsubst)$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internamente, Maxima não usa os operadores de negação unária,
     divisão, ou de subtração; dessa forma:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","//",a/b);
                                       a
          (%o10)                       -
                                       b

     A representação interna de -a*b é *(-1,a,b); dessa forma
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     Quando o operador não for um símbolo Maxima, geralmente alguma
     outra função sinalizará um erro:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     Todavia, operadores subscritos são permitidos:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     Para usar essa função escreva primeiramente `load("opsubst")'.


File: maxima.info,  Node: orthopoly,  Next: plotdf,  Prev: opsubst,  Up: Top

63 orthopoly
************

* Menu:

* Introdução a polinômios ortogonais::
* Definições para polinômios ortogonais::


File: maxima.info,  Node: Introdução a polinômios ortogonais,  Next: Definições para polinômios ortogonais,  Prev: orthopoly,  Up: orthopoly

63.1 Introdução a polinômios ortogonais
=======================================

`orthopoly' é um pacote para avaliação simbólica e numérica de muitos
tipos de polinômios ortogonais, incluindo polinômios de Chebyshev,
Laguerre, Hermite, Jacobi, Legendre, e ultraesférico (Gegenbauer).
Adicionalmentey, `orthopoly' inclui suporte funções esféricas segundo o
critério de Bessel, esféricas segundo o critério de Hankel, e funções
harmônica esféricas.

   Em sua maior parte, `orthopoly' segue as convenções de Abramowitz e
Stegun Handbook of Mathematical Functions, Chapter 22 (10th printing,
December 1972); adicionalmente, usamos Gradshteyn e Ryzhik, Table of
Integrals, Series, and Products (1980 corrected and enlarged edition),
e Eugen Merzbacher Quantum Mechanics (2nd edition, 1970).

   Barton Willis da University de Nebraska e Kearney (UNK) escreveu o
pacote `orthopoly' e sua documetação. O pacote é liberado segundo a
licença pública geral GNU (GPL).

63.1.1 Iniciando com orthopoly
------------------------------

`load (orthopoly)' torna o pacote `orthopoly' disponível para uso.

   Para encontrar o polinômio de Legendre de terceira ordem,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

   Para expressar esse polinômio como uma soma de potências de <x>,
aplique <ratsimp> ou <rat> para o resultado anterior.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

   Alternativamente, faça o segundo argumento  para `legendre_p' (sua
variável "principal") uma expressão racional canônica (CRE)  usando
`rat(x)' em lugar de somente `x'.

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

   Para avaliação em ponto flutuante, `orthopoly' usa uma análise de
erro durante a execução para estimar uma associação superior para o
erro. Por exemplo,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

   intervalos possuem a forma `interval (<c>, <r>)', onde <c> é o
centro e <r> é o raio do intervalo. Uma vez que Maxima não suporta
aritmética sobre intervalos, em algumas situações, tais como em
gráficos, você vai querer suprimir o erro e sair somente com o centro
do intervalo. Para fazer isso, escolha a variável de opção
`orthopoly_returns_intervals' para `false'.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

   Veja a seção *note Avaliação em Ponto Flutuante:: para maiores
informaçõesfor more information.

   Muitas funções em `orthopoly' possuem uma propriedade `gradef';
dessa forma

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

   A função de um único passo no segundo exemplo previne um erro que
poderia de outra forma surgir através da avaliação de <n> para 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

   A propriedade `gradef' somente aplica para a variável "principal";
dderivadas com relação a outros argumentos usualmente resultam em uma
mensagem de erro; por exemplo

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with respect the first argument
      -- an error.  Quitting.  To debug this try debugmode(true);

   Geralmente, funções em `orthopoly' mapeiam sobre listas e matrizes.
Para o mapeamento para avaliação total, as variáveis de opção
`doallmxops' e `listarith' devem ambas serem `true' (o valor padrão).
Para ilustrar o mapeamento sobre matrizes, considere

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

   No segundo exemplo, o elemento `i, j' do valor é `hermite (2,
m[i,j])'; isso não é o mesmo que calcular `-2 + 4 m . m', como visto no
próximo exemplo.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

   Se você avaliar uma função em um ponto fora do seu domínio,
geralmente `orthopoly' retorna uma função não avaliada. Por exemplo,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

   `orthopoly' suporta tradução em TeX; `orthopoly' também faz saídas
bidimensionais em um terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

63.1.2 Limitations
------------------

Quando uma expressão envolve muitos polinômios ortogonais com ordens
simbólicas, é possível que a expressão atualmente tenda para zero, e
ainda ocorre também que Maxima estar incapacitado de simplificar essa
expressão para zero. Se você faz uma divisão por tal quantidade que
tende a zero, você pode estar em apuros. Por exemplo, a seguinte
expressão tende para zero para inteiros <n> maiores que 1, e ainda
ocorre também que  Maxima está incapacitado de simplificar essa
expressão para zero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x) + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

   Para um <n> específico, podemos reduzir a expressão a zero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

   Geralmente, a forma polinomial de um polinômio ortogonal esteja
adequada de forma hostil para avaliaçao em ponto flutuante. Aqui está
um exemplo.

     (%i1) p : jacobi_p (100, 2, 3, x)$

     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

   O verdadeiro valor está em torno de 0.184; ess calculo suporta erro
de cancelamento por extremo subtrativo.Expandindo o polinômio e então
avaliando, fornecendo um melhor resultado.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

   Essa não é uma regra geral; expandindo o polinômio não resulta sempre
em expressões que são melhores adaptadas a avaliação numérica.  Com
grande folga, o melhor caminho para fazer avaliação numérica é fazer um
ou mais argumentos da função serem números em ponto flutuante. Em
função disso, algorítmos especializados em ponto flutuante são usados
para avaliação.

   A função `float' do Maxima é até certo ponto indiscriminada; se você
aplicar `float' a uma expressão envolvendo um polinômio ortogonal com um
grau simbólico ou um parâmetro de ordem, esses parâmetos (inteiros)
podem ser convertido em números em ponto flutuante; após o que, a
expressão não irá avaliar completamente. Considere

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

   A expressão em (%o3) não irá avaliar para um número em ponto
flutuante; `orthopoly' não reconhece valores em ponto flutuante em
lugares onde deve haver valores inteiros. Similarmente, avaliação
numérica da função `pochhammer' para ordens que excedam
`pochhammer_max_index' pode ser perturbador; considere

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

   Aplicando `float' não avalia <x> para um número em ponto flutuante

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

   Para avaliar <x> para um número em ponto flutuante, você irá
precisar associar `pochhammer_max_index' a 11 ou mais e aplicar `float'
a <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

   O valor padrão de `pochhammer_max_index' é 100; modifique esse valor
após chama `orthopoly'.

   Finalmente, tenha consciência que os livros citados nas referências
adotam diferentes definições de polinômios ortogonais; geralmente
adotamos as convenções citadas nas convenções de Abramowitz e Stegun.

   Antes de você suspeitar de um erro no pacote `orthopoly', verifique
alguns casos especiais para determinar se suas definições coincidem com
aquelas usadas por `orthopoly'.  Definitions muitas vezes diferem por
uma normalização; ocasionalmente, autores utilizam versões
"modificadas" das funções que fazem a família ortogonal sobre um
intervalo diferente do intervalo (-1, 1). Para definir, por exemplo, um
polinômio de Legendre que é ortogonal a (0, 1), defina

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

63.1.3 Avaliação em Ponto Flutuante
-----------------------------------

Muitas funções em `orthopoly' utilizam análise de erro durante a
execução para estimar o erro em avaliações em ponto flutuante; as
exceções são funções de Bessel esféricas e os polinômios associados de
Legendre do segundo tipo. Para avaliações numéricas, as funções de
Bessel esféricas chamam funções da coleção de programas `SLATEC'.
Nenhum método especializado é usado para avaliação numérica dos
polinômios associados  de Legendre do segundo tipo.

   A análise de erro durante a execução ignora erros que são de segunda
ordem ou maior na máquina (também conhecida como perda de algarismos).
A análise de erro durante a execução também ignora alguns poucos outros
tipos de erro. É possível (embora não provável) que o erro atual exceda
o estimado.

   Intervalos possuem a forma `interval (<c>, <r>)', onde <c> é o centro
do intervalo e <r> é seu raio. O centro de um intervalo pode sr um
número complexo, e o raio é sempre um número real positivo.

   Aqui está um exemplo.

     (%i1) fpprec : 50$

     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

   Vamos testar o quanto o erro atual é é menor que o erro estimado

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

   Realmente, por esse exemplo o erro estimado é um maior que o erro
verdadeiro.

   Maxima não suporta aritmética sobre intervalos.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

   Um usuário pode definir operadores aritméticos que fazem matemática
de intervalos. Para definir adição de intervalos, podemos definir

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1), part (x, 2) + part (y, 2))$

     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

   As rotinas eseciais em ponto flutuante são chamadas quando os
argumentos forem complexos.  Por exemplo,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

   Let's compare this to the true value.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

   Adicionalmente, quando os argumentos forem grandes números em ponto
flutuante, as rotinas especiais de ponto flutuante são chamadas;
todavia, tos grandes números em ponto flutuante são convertidos para
números em ponto flutuante de dupla precisão e o resultado final é
número em ponto flutuante de precisão dupla.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

63.1.4 Gráficos e `orthopoly'
-----------------------------

Para montar gráficos de expressões que envolvem polinômios ortogonais,
você deve azer duas coisas:
  1. Escolher a variável de opção `orthopoly_returns_intervals' para
     `false',

  2. Colocar apóstrofo em qualquer chamada a funções do pacote
     `orthopoly'.
        Se chamadas a funções não receberem apóstrofo, Maxima irá
avaliá-las para polinômios antes de montar o gráfico; conseqüêntemente,
as rotinas especializadas em ponto flutuante não serão chamadas.  Aqui
está um exemplo de como montar o gráfico de uma expressão que envolve
um polinômio de Legendre.

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]), orthopoly_returns_intervals : false;
     (%o1)

   A expressão completa `legendre_p (5, x)' recebe apóstrofo; isso é
diferente de apenas colocar apóstrofo no nome da função usando
`'legendre_p (5, <x>)'.

63.1.5 Funções Diversas
-----------------------

O pacote `orthopoly' define o síbolo de Pochhammer e uma função de
passo de unidade. `orthopoly' utiliza a função delta de Kronecker e a
função de passo de unidade em declarações `gradef'.

   Para converter os símbolos Pochhammer em quocientes da funções gama,
use `makegamma'.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

   Derivadas de símbolos de Pochhammer são fornecidas em termos de `psi'
function.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

   Vocêprecisa ser cuidadoso com expressões como (%o1); a diferença das
funções `psi' possuem polinômios quando `<x> = -1, -2, .., -<n>'. Esses
polinômios cacelam-se com fatores em `pochhammer (<x>, <n>)' fazendo da
derivada um polinômio de grau `<n> - 1' quando <n> for um inteiro
positivo.

   O símbolo de Pochhammer é definido de ordens negativas até sua
representação como um quociente de funções gama. Considere

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

   Alternativamente, podemos tomar ese resultado diretamente.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

   A função passo de unidade é contínua à esquerda; dessa forma

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

   Se você precisa de uma função de unidade de passo que é ou contínua
à esquerda ou contínua à direita em zero, defina sua própria função de
unidade de passo usando `signum'; por exemplo,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

   Não redefina a própria `unit_step'; alguns código em `orthopoly'
requerem que a função de passo de unidade seja contínua à esquerda.

63.1.6 Algorítmos
-----------------

Geralmente, `orthopoly' faz avaliações simbólicas pelo uso de uma
representação hipergeométrica de polinômios ortogonais. As funções
hipegeométricas são avaliadas usando as funções (não documetadas)
`hypergeo11' e `hypergeo21'. As excessões são as funções de Bessel
metade inteiras e a função de Legendre associada de segundo tipo. As
funções de Bessel metade inteiras são avaliadas usando uma
representação explícita, e a função de Legendre associada de segundo
tipo é avaliada usando recursividade.

   Para avaliação em ponto flutuante, nós novamente convertemos muitas
fuções em uma forma hipergeométrica; nós avaliamos as funções
hipergeométricas usando recursividade para frente. Novamente, as
excessões são as funções de Bessel metade inteiras e a função de
Legendre associada de segundo tipo. Numericamente, as funções de Bessel
meio inteiras são avaliadas usando o código SLATEC.


File: maxima.info,  Node: Definições para polinômios ortogonais,  Prev: Introdução a polinômios ortogonais,  Up: orthopoly

63.2 Definições para polinômios ortogonais
==========================================

 -- Função: assoc_legendre_p (<n>, <m>, <x>)
     As funções de Legendre associadas de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 22.5.37, página 779,
     8.6.6 (segunda equação), página 334, e 8.2.5, página 333.

 -- Função: assoc_legendre_q (<n>, <m>, <x>)
     A função de Legendre associada de segundo tipo.

     Referência: Abramowitz e Stegun, equação 8.5.3 e 8.1.8.

 -- Função: chebyshev_t (<n>, <x>)
     A função de Chebyshev de primeiro tipo.

     Referência: Abramowitz e Stegun, equação 22.5.47,página 779.

 -- Função: chebyshev_u (<n>, <x>)
     A função de Chebyshev do segundo tipo.

     Referência: Abramowitz e Stegun, equação 22.5.48,página 779.

 -- Função: gen_laguerre (<n>, <a>, <x>)
     O poliômio generalizado de Laguerre.

     Referência: Abramowitz e Stegun, equação 22.5.54,página 780.

 -- Função: hermite (<n>, <x>)
     O polinômio de Hermite.

     Referência: Abramowitz e Stegun, equação 22.5.55,página 780.

 -- Função: intervalp (<e>)
     Retorna `true' se a entrada for um intervalo e retorna `false' se
     não for.

 -- Função: jacobi_p (<n>, <a>, <b>, <x>)
     o polinômio de Jacobi.

     Os polinômios de Jacobi são atualmente definidos para todo <a> e
     <b>; todavia, o peso do polinômio de Jacobi `(1 - <x>)^<a> (1 +
     <x>)^<b>' não é integrável para `<a> <= -1' ou `<b> <= -1'.

     Referência: Abramowitz e Stegun, equação 22.5.42,página 779.

 -- Função: laguerre (<n>, <x>)
     O polinômio de Laguerre.

     Referência: Abramowitz e Stegun, equatções 22.5.16 e
     22.5.54,página 780.

 -- Função: legendre_p (<n>, <x>)
     O polinômio de Legendre de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 22.5.50 e 22.5.51,página
     779.

 -- Função: legendre_q (<n>, <x>)
     O polinômio de Legendre de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 8.5.3 e 8.1.8.

 -- Função: orthopoly_recur (<f>, <args>)
     Retorna uma relação recursiva para a família de funções ortogonais
     <f> com argumentos <args>. A recursividade é com relação ao grau
     do polinômio.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                          (2 n - 1) P     (x) x + (1 - n) P     (x)
                                     n - 1                 n - 2
          (%o1)   P (x) = -----------------------------------------
                   n                          n

     O segundo argumento a `orthopoly_recur' deve ser uma lista com o
     número correto de argumentos para a função <f>; se o número de
     argumetnos não for o correto, Maxima sinaliza com um erro.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Adicionalmente, quando <f> não for o nome de uma das famílias de
     polinômios ortogonais, um erro é sinalizado.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable: orthopoly_returns_intervals
     Valor padrão: `true'

     Quando `orthopoly_returns_intervals' for `true', resultados em
     ponto flutuante são retornados na forma `interval (<c>, <r>)',
     onde <c> é o centro de um intervalo e <r> é seu raio. O centro
     pode ser um número complexo; nesse caso, o intervalo é um disco no
     plano complexo.

 -- Função: orthopoly_weight (<f>, <args>)
     Retorna uma lista de três elementos; o primeiro elemento é a
     fórmula do peso para a família de polinômios ortogonais <f> com
     argumentos fornecidos pela lista <args>; os segundos e terceiros
     elementos fornecem os pontos finais inferior e superior do
     intervalo de ortogonalidade. Por exemplo,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate (w[1] * hermite (3, x) * hermite (2, x), x, w[2], w[3]);
          (%o2)                           0

     A variável principal de <f> deve ser um símbolo; Se não for, Maxima
     sinaliza com um erro.


 -- Função: pochhammer (<n>, <x>)
     O símbolo de Pochhammer. Para inteiros não negativos <n> com `<n>
     <= pochhammer_max_index', a expressão `pochhammer (<x>, <n>)'
     avalia para o produto `<x> (<x> + 1) (<x> + 2) ... (<x> + n - 1)'
     when `<n> > 0' e para 1 quando `<n> = 0'. Para valores negativos
     de <n>, `pochhammer (<x>, <n>)' é definido como `(-1)^<n> /
     pochhammer (1 - <x>, -<n>)'.  Dessa forma

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     Para converter um símbolo de Pochhammer em um quociente de
     funções gama, (veja Abramowitz e Stegun, equação 6.1.22) use
     `makegamma'; por exemplo

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     Quando <n> exceder `pochhammer_max_index' ou quando <n> for
     simbólico, `pochhammer' retorna uma forma substantiva.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variável: pochhammer_max_index
     Valor padrão: 100

     `pochhammer (<n>, <x>)' expande para um produto se e somente se
     `<n> <= pochhammer_max_index'.

     Exemplos:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Referência: Abramowitz e Stegun, equação 6.1.16,página 256.

 -- Função: spherical_bessel_j (<n>, <x>)
     A Função de Bessel esférica de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 10.1.8,página 437 e
     10.1.15,página 439.

 -- Função: spherical_bessel_y (<n>, <x>)
     A Função de Bessel esférica de segundo tipo.

     Referência: Abramowitz e Stegun, equações 10.1.9,página 437 e
     10.1.15,página 439.

 -- Função: spherical_hankel1 (<n>, <x>)
     A Função de Hankel esférica de primeiro tipo.

     Referência: Abramowitz e Stegun, equação 10.1.36,página 439.

 -- Função: spherical_hankel2 (<n>, <x>)
     A Função de Hankel esférica de segundo tipo.

     Referência: Abramowitz e Stegun, equação 10.1.17,página 439.

 -- Função: spherical_harmonic (<n>, <m>, <x>, <y>)
     A função armônica esférica.

     Referência: Merzbacher 9.64.

 -- Função: unit_step (<x>)
     A função de passo de unidade contínua à esquerda; dessa forma
     `unit_step (<x>)' tende para `<x> <= 0' e é igual a 1 para `<x> >
     0'.

     Se você quiser uma função de passo de unidade que tome o valor 1/2
     em zero, use `(1 + signum (<x>))/2'.

 -- Função: ultraspherical (<n>, <a>, <x>)
     A função polinômial ultraesférica (também conhecida como função
     polinomial de Gegenbauer).

     Referência: Abramowitz e Stegun, equação 22.5.46,página 779.


File: maxima.info,  Node: plotdf,  Next: romberg,  Prev: orthopoly,  Up: Top

64 plotdf
*********

* Menu:

* Introdução a plotdf::
* Definições para plotdf::


File: maxima.info,  Node: Introdução a plotdf,  Next: Definições para plotdf,  Prev: plotdf,  Up: plotdf

64.1 Introdução a plotdf
========================

A função `plotdf' cria um gráfico do campo de direção de uma Equação
Diferencial Ordinária (EDO) de primeira ordem ou um sistema de duas
EDO's de primeira ordem autônomas.

   Uma vez que esse é um pacote adicional, com o objetivo de usá-lo
você deve primeiramente chamá-lo com `load("plotdf")'. Plotdf precisa
do Openmath, que é fornecido pelo pacote Xmaxima (Xmaxima, para além de
servir como consola gráfica para o Maxima, é também o programa que
produz os gráficos no formato Openmath).

   Para montar um gráfico do campo de direção de uma EDO simples, a EDO
deve ser escrita na forma:
            dy
            -- = F(x,y)
            dx

   e a função <F> pode ser dada como um argumento para `plotdf'. Se as
variáveis independente e dependente não forem <x> e <y>, como na
equação acima, então os nomes dessas duas variáveis deverá indicar-se
numa lista que será o segundo argumento para o comando plotdf (ver os
exemplos).

   Para montar o gráfico do campo de direção de um conjunto de duas
EDO's autônomas, elas devem ser escritas na forma
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   e o argumento para `plotdf' pode ser uma lista com as duas funções
<F> e <G>, nessa ordem; nomeadamente, a primeira expressão definirá a
derivada no tempo da variável representada no eixo horizontal, e a
segunda expressão será a derivada no tempo da variável representada no
eixo vertical. Essas duas variáveis não têm que ser <x> e <y>, mas se
não forem, então o segundo argumento para o comando plotdf deverá ser
uma lista com os nomes dessas variáveis, primeiro a variável no eixo
horizontal, seguida da variável no eixo vertical.

   Se somente uma EDO for fornecida, `plotdf' irá admitir implicitamente
`x=t', e `G(x,y)=1', transformando a equação não autônoma em um sistema
de duas equações autônomas.


File: maxima.info,  Node: Definições para plotdf,  Prev: Introdução a plotdf,  Up: plotdf

64.2 Definições para plotdf
===========================

 -- Function: plotdf (<dydx>, ...opç ~oes...)
 -- Function: plotdf (<dvdu>, `['<u>,<v>`]', ...opç ~oes...)
 -- Function: plotdf (`['<dxdt>,<dydt>`]', ...opç ~oes...)
 -- Function: plotdf (`['<dudt>,<dvdt>`]', `['<u>,<v>`]',
          ...opç ~oes...)
     Mostra um campo de direção em duas dimensões <x> e <y>.

     <dydx>, <dxdt> e <dydt> são expressões que dependem de <x> e <y>.
     <dvdu>, <dudt> e <dvdt> são expressões que dependem de <u> e <v>.
     Adicionalmente para essas duas variáveis, as expressões podem
     também depender de um conjunto de parâmetros, com valores
     numéricos fornecidos com os `parâmetros' opção (a sintaxe de
     opção é fornecida abaixo), ou com um intervalo de valores
     permitidos especificados por meio de uma opção <sliders>.

     Muitas outras opções podem ser fornecidas dentro do comando, ou
     selecionadas no menu. Curvas integrais podem ser obtidas por meio
     de um clique no gráfico, ou com a opção `trajectory_at'. A
     direção da integração pode ser controlada com a opção `direction',
     que pode ter valores de _forward_ (adiante), _backward_(para trás)
     or _both_ (ambos). O número de passos de integração é fornecido
     por meio de `nsteps' e o intervalo de tempo entre eles é escolhido
     com a opção `tstep'. O método de Adams Moulton é usado para a
     integração; é também possível alternar para um método adaptativo
     de Runge-Kutta de quarta ordem.

     Menu da janela do gráfico:

     O menu na janela do gráfico tem as seguintes opções: _Zoom_, irá
     modificar o comportamento do mouse de forma que seja permitido a
     você aproximar uma região do gráfico por meio de um clique nessa
     região como o botão esquerdo. Cada clique próximo a um ponto do
     gráfico amplia esse gráfico, mantendo o contro no ponto onde você
     clicou. Mantendo a tecla <Shift> pressionada enquanto clica,
     afasta para a ampliação anterior. Para continuar calculando
     trajetórias quando você clica sobre um ponto, selecione
     _Integrate_ a partir do menu.

     A opção _Config_ no menu pode ser usada para mudar a(s) EDO(s) em
     uso e para várias outras escolhas. Após as mudanças de
     configuração serem feitas, a opção do menu _Replot_ estará
     selecionada, para ativar as novas escolhas.  Se um par de
     coordenadas for fornecido em um campo _Trajectory at_ na caixa de
     diálogo _Config_ do menu, e a tecla <enter> fo pressionada, uma
     nova curva integral será mostrada, adicionalmente com as outras já
     mostradas. Quando _Replot_ está selecionada, somente a última
     curva integral fornecida será mostrada.

     Mantendo o botão direito do mouse pressionado enquanto o cursor é
     movido, pode ser usado para arrastar as laterais do gráfico para
     cima ou para baixo. Parâmetros adicionais tais como o número de
     passos, o valor inicial de <t> e os centros de x e y e raios,
     podem ser escolhidos no menu Config.

     Uma cópia do gráfico pode ser gravada como um arquivo postscript,
     usando a opção _Save_ do menu.

     Opções de gráfico:

     O comando `plotdf' pode incluir muitos comandos, cada comando é
     uma lista de dois ou mais itens.  O primeiro item é o nome da
     opção, e o restante compreende o valor ou valores atribuídos à
     opção.

     As opçõesque são reconhecidas por `plotdf' são as seguintes:

        * "tstep" define o comprimento dos incrementos sobre a variável
          independente <t>, usado para calcular uma curva integral. Se
          somente uma expressão <dydx> for fornecida a `plotdf', a
          variável <x> será diretamente proporcional a <t>.  O valor
          padrão é 0.1.

        * "nsteps" define o número de passos de comprimento `tstep' que
          será usando para a variável independente, para calcular uma
          curva integral.  O valor padrão é 100.

        * "direction" define a direção da variável independente que
          será seguida para calcular uma curva integral. Possíveis
          valores são `forward', para fazer a variável independente
          aumentar `nsteps' vezes, com incrementos de `tstep',
          `backward', para fazer a variável independente diminuir, ou
          `both' que irá conduzir a uma curva integral que amplia
          `nsteps' adiante, e `nsteps' para trás. As palavras chave
          `right' e `left' podem ser usadas como sinonimos para
          `forward' e `backward'.  O valor padrão é `both'.

        * "tinitial" define o valor inicial da variável <t> usada para
          calcular curva integral. Uma vez que equações diferenciais
          forem autônomas, aquela escolha irá aparecer somente no
          gráfico das curvas como funções de <t>.  O valor padrão é 0.

        * "versus_t" é usado para criar uma segunda janela de gráfico,
          com um gráfico de uma curva integral, como duas funções <x>,
          <y>, da variável independente <t>. Se para `versus_t' for
          atribuído qualquer valor diferente de 0, a segunda janela de
          gráfico será mostrada. A segunda janela de gráfico inclui
          outro menu, semelhante ao menu da janela de gráfico principal.
          O valor padrão é 0.

        * "trajectory_at" define as coordenadas <xinitial> e <yinitial>
          para o ponto de partida de uma curva integral.  A opção está
          vazia por padrão.

        * "parameters" define uma lista de parâmetros, e seus valores
          numéricos, usados na definição das equações diferenciais. O
          nome e valores dos parâmetros devem ser fornecidos em uma
          seqüência de caracteres com uma seqüência de pares
          `nome=valor' separados por vírgula.

        * "sliders" define uma lista de parâmetros que será modificada
          interativamente usando botões de deslizamento, e o intervalo
          de variação desses parâmetros. Os nomes e intervalos dos
          parâmetros devem ser fornecidos in a seqüência de caracteres
          com uma seqüência de elementos  `name=min:max' separados por
          vírgula.

        * "xfun" define uma seqüência de caracteres com uma seqüência
          de funções separadas com ponto e vírgula <x> para serem
          mostradas, no topo do campo de direção.  Essas funções irão
          ser passadas pelo Tcl e não pelo Maxima.

        * "x" deverá estar seguida de dois números que definem os
          valores mínimo e máximo a serem apresentados no eixo
          horizontal.  Se a variável no eixo horizontal não for <x>,
          esta opção deverá ter o nome da variável no eixo horizontal.
          O intervalo padrão é de -10 a 10.

        * "y" deverá estar seguida de dois números que definem os
          valores mínimo e máximo a serem apresentados no eixo vertical.
          Se a variável no eixo vertical não for <y>, esta opção deverá
          ter o nome da variável no eixo vertical.  O intervalo padrão
          é de -10 a 10.


     Exemplos:

        * Para mostrar o campo de direção da equação diferencial y' =
          exp(-x) + y e a solução que vai em toda a extensão do
          intervalo (2, -0.1):
               (%i1) load("plotdf")$

               (%i2) plotdf(exp(-x)+y,[trajectory_at,2,-0.1])$

        * Para obter o campo de direção para a equação diff(y,x) = x -
          y^2 e a solução com condição inicial y(-1) = 3, podemos usar
          o comando:
               (%i3) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                         [trajectory_at,-1,3], [direction,forward],
                         [y,-5,5], [x,-4,16])$
          O gráfico também mostra a função y = sqrt(x).

        * O seguinte exemplo mostra o campo de direção de um oscilador
          harmônico, definido pelas duas equações dz/dt = v e dv/dt =
          -k*z/m, e a curva integral no ponto (z,v) = (6,0), com um
          botão de deslizamento que irá permitir a você mudar o valor
          de m interativamente (k está fixado em 2):
               (%i4) plotdf([v,-k*z/m], [z,v], [parameters,"m=2,k=2"],
                           [sliders,"m=1:5"], [trajectory_at,6,0])$

        * Para montar o gráfico do campo de direção da equação de
          Duffing, m*x"+c*x'+k*x+b*x^3 = 0, introduzimos a variável
          y=x' e usamos:
               (%i5) plotdf([y,-(k*x + c*y + b*x^3)/m],
                             [parameters,"k=-1,m=1.0,c=0,b=1"],
                             [sliders,"k=-2:2,m=-1:1"], [tstep,0.1])$

        * O campo de direção para um pêdulo amortecido, incluindo a
          solução para as condições iniciais fornecidas, com um botão
          de deslizamento que pode ser usado para mudar o valor da
          massa m, e com um gráfico das duas  variáveis de estado como
          uma função do tempo:

               (%i6) plotdf([w,-g*sin(a)/l - b*w/m/l], [a,w],
                        [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                        [trajectory_at,1.05,-9], [tstep,0.01],
                        [x,-10,2], [y,-14,14], [direction,forward],
                        [nsteps,300], [sliders,"m=0.1:1"], [versus_t,1])$




File: maxima.info,  Node: romberg,  Next: simplex,  Prev: plotdf,  Up: Top

65 romberg
**********

* Menu:

* Definições para romberg::


File: maxima.info,  Node: Definições para romberg,  Prev: Top,  Up: Top

65.1 Definições para romberg
============================

 -- Função: romberg (<expr>, <x>, <a>, <b>)
 -- Função: romberg (<F>, <a>, <b>)
     Calcula uma integração numérica pelo método de Romberg.

     `romberg(<expr>, <x>, <a>, <b>)' retorna uma estimativa da
     integral `integrate(<expr>, <x>, <a>, <b>)'.  <expr> deve ser uma
     expressão que avalie para um valor em ponto flutuante quando <x>
     estiver associado a um valor em ponto flutuante.

     `romberg(<F>, <a>, <b>)' retorna uma estimativa da integral
     `integrate(<F>(x), x, <a>, <b>)' onde `x' representa o não
     nomeado, isolado argumeno de <F>; o atual argumento não é chamado
     `x'.  <F> deve ser uma função do Maxima ou do Lisp que retorne um
     valor em ponto flutuante quando o argumento for um número em ponto
     flutuante.  <F> pode nomear uma função traduzida ou compilada do
     Maxima.

     A precisão de `romberg' é governada pelas variáveis globais
     `rombergabs' e `rombergtol'.  `romberg' termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que `rombergabs', ou a diferença relativa em aproximações
     sucessivas for menor que `rombergtol'.  Dessa forma quando
     `rombergabs' for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre `romberg'.

     `romberg' divide ao meio o tamanho do passo no máximo `rombergit'
     vezes antes de interromper; o número máximo de avaliações de
     função é portanto `2^rombergit'.  Se o critério de erro
     estabelecido por `rombergabs' e por `rombergtol' não for
     satisfeito, `romberg' mostra uma mensagem de erro.  `romberg'
     sempre faz ao menos `rombergmin' iterações; isso é uma intenção
     eurísstica de previnir encerramentos espúrios quando o integrando
     for oscilatório.

     `romberg' repetidamente avalia o integrando após associar a
     variável de integração a um valor específico (e não antes).  Essa
     política de avaliação torna possível aninhar chamadas a `romberg',
     para calcular integrais multidimensionais.  Todavia, os cálculos
     de erro não tomam os erros de integrações aninhadas em
     consideração, então erros podem ser subestimados.  Também, métodos
     imaginados especialmente para problemas multidimensionais podem
     retornar a mesma precisão com poucas avaliações de função.

     `load(romberg)' torna essa função disponível para uso.

     Veja também `QUADPACK', uma coleção de funções de integração
     numérica.

     Exemplos:

     Uma integração unidimensonal.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) f(x) := 1/((x - 1)^2 + 1/100) + 1/((x - 2)^2 + 1/1000) + 1/((x - 3)^2 + 1/200);
                              1                 1                1
          (%o2) f(x) := -------------- + --------------- + --------------
                               2    1           2    1            2    1
                        (x - 1)  + ---   (x - 2)  + ----   (x - 3)  + ---
                                   100              1000              200
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) rombergit : 15;
          (%o4)                          15
          (%i5) estimate : romberg (f(x), x, -5, 5);
          (%o5)                   173.6730736617464
          (%i6) exact : integrate (f(x), x, -5, 5);
          (%o6) 10 sqrt(10) atan(70 sqrt(10))
           + 10 sqrt(10) atan(30 sqrt(10)) + 10 sqrt(2) atan(80 sqrt(2))
           + 10 sqrt(2) atan(20 sqrt(2)) + 10 atan(60) + 10 atan(40)
          (%i7) abs (estimate - exact) / exact, numer;
          (%o7)                7.5527060865060088E-11

     Uma integração bidimensional, implementada com chamadas aninhadas
     a `romberg'.

          (%i1) load (romberg);
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) g(x, y) := x*y / (x + y);
                                              x y
          (%o2)                   g(x, y) := -----
                                             x + y
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) estimate : romberg (romberg (g(x, y), y, 0, x/2), x, 1, 3);
          (%o4)                   0.81930239628356
          (%i5) assume (x > 0);
          (%o5)                        [x > 0]
          (%i6) integrate (integrate (g(x, y), y, 0, x/2), x, 1, 3);
                                                    3
                                              2 log(-) - 1
                              9                     2        9
          (%o6)       - 9 log(-) + 9 log(3) + ------------ + -
                              2                    6         2
          (%i7) exact : radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o7)             - --------------------------
                                          3
          (%i8) abs (estimate - exact) / exact, numer;
          (%o8)                1.3711979871851024E-10


 -- Variável de opção: rombergabs
     Valor padrão: 0.0

     A precisão de `romberg' é governada pelas variávies globais
     `rombergabs' e `rombergtol'.  `romberg' termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que `rombergabs', ou a diferença relativa em aproximações
     sucessivas for menor que `rombergtol'.  Dessa forma quando
     `rombergabs' for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre `romberg'.

     Veja também `rombergit' e `rombergmin'.


 -- Variável de opção: rombergit
     Valor padrão: 11

     `romberg' divide ao meio o tamanho do passo no máximo `rombergit'
     vezes antes de interromper; o número máximo de avaliações de
     função é portanto `2^rombergit'.  Se o critério de erro
     estabelecido por `rombergabs' e por `rombergtol' não for
     satisfeito, `romberg' mostra uma mensagem de erro.  `romberg'
     sempre faz ao menos `rombergmin' iterações; isso é uma intenção
     eurísstica de previnir encerramentos espúrios quando o integrando
     for oscilatório.

     Veja também `rombergabs' e `rombergtol'.


 -- Variável de opção: rombergmin
     Valor padrão: 0

     `romberg' sempre faz ao menos `rombergmin' iterações; isso é uma
     intenção eurísstica para prevenir terminações espúrias quando o
     integrando for.

     Veja também `rombergit', `rombergabs', e `rombergtol'.


 -- Variável de opção: rombergtol
     Valor padrão: 1e-4

     A precisão de `romberg' é governada pelas variáveis globais
     `rombergabs' e `rombergtol'.  `romberg' termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que `rombergabs', ou a diferença relativa em aproximações
     sucessivas for menor que `rombergtol'.  Dessa forma quando
     `rombergabs' for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre `romberg'.

     Veja também `rombergit' e `rombergmin'.



File: maxima.info,  Node: simplex,  Next: simplification,  Prev: romberg,  Up: Top

66 simplex
**********

* Menu:

* Introdução a simplex::
* Definições para simplex::


File: maxima.info,  Node: Introdução a simplex,  Next: Definições para simplex,  Prev: simplex,  Up: simplex

66.1 Introdução a simplex
=========================

`simplex' é um pacote para otimização linear usando o algorítmo simplex.

   Exemplo:

     (%i1) load("simplex")$
     (%i2) minimize_sx(x+y, [3*x+2*y>2, x+4*y>3]);
                       9        7       1
     (%o2)            [--, [y = --, x = -]]
                       10       10      5


File: maxima.info,  Node: Definições para simplex,  Prev: Introdução a simplex,  Up: simplex

66.2 Definições para simplex
============================

 -- Variável de opção: epsilon_sx
     Valor padrão: `10^-8'

     Epsilon usando para cálculos numéricos em `linear_program'.

     Veja também: `linear_program'.


 -- Função: linear_program (<A>, <b>, <c>)
     `linear_program' é uma implementação do algorítmo simplex.
     `linear_program(A, b, c)' calcula um vetor <x> para o qual `c.x' é
     o mínimo possível entre vetores para os quais `A.x = b' e `x >=
     0'. O argumento <A> é uma matriz e os argumentos <b> e <c> são
     listas.

     `linear_program' retorna uma lista contendo o vetor minimizado <x>
     e o valor mínimo `c.x'. Se o problema for não associado, é
     retornado "Problem not bounded!" e se o problema for não viável, é
     retornado "Problem not feasible!".

     Para usar essa função primeiramente chame o pacote `simplex' com
     `load(simplex);'.

     Exemplo:

          (%i2) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i3) b: [1,1,6]$
          (%i4) c: [1,-2,0,0]$
          (%i5) linear_program(A, b, c);
                             13     19        3
          (%o5)            [[--, 4, --, 0], - -]
                             2      2         2

     Veja também: `minimize_sx', `scale_sx', e `epsilon_sx'.


 -- Função: maximize_sx (<obj>, <cond>, [<pos>])
     Maximiza a função linear objetiva <obj> submetida a alguma
     restrição linear <cond>. Veja `minimize_sx' para uma descrição
     detalhada de argumentos e valores de retorno.

     Veja também: `minimize_sx'.


 -- Função: minimize_sx (<obj>, <cond>, [<pos>])
     Minimiza uma função linear objetiva <obj> submetida a alguma
     restrição linear <cond>. <cond> é uma lista de equações lineares ou
     desigualdades. Em desigualdades estritas `>' é  substituido por
     `>=' e `<' por `<='. O argumento opcional <pos> é uma lista de
     variáveis de decisão que são assumidas como sendo positivas.

     Se o mínimo existir, `minimize_sx' retorna uma lista que contém o
     menor valor da função objetiva e uma lista de valores de variáveis
     de decisão para os quais o mínimo é alcançado. Se o problema for
     não associado, `minimize_sx' retorna "Problem not bounded!" e se o
     problema for não viável, é retornado "Ploblem not feasible!".

     As variáveis de decisão não são assumidas para serem não negativas
     por padrão. Se todas as variáveis de dicisão forem não negativas,
     escolha `nonegative_sx' para `true'.  Se somente algumas das
     variáveis de decisão forem positivas, coloque-as então no argumento
     opcional <pos> (note que isso é mais eficiente que adicionar
     restrições).

     `minimize_sx' utiliza o algorítmo simplex que é implementado na
     função `linear_program' do Maxima.

     Para usar essa função primeiramente chame o pacote `simplex' com
     `load(simplex);'.

     Exemplos:

          (%i1) minimize_sx(x+y, [3*x+y=0, x+2*y>2]);
                                4       6        2
          (%o1)                [-, [y = -, x = - -]]
                                5       5        5
          (%i2) minimize_sx(x+y, [3*x+y>0, x+2*y>2]), nonegative_sx=true;
          (%o2)                [1, [y = 1, x = 0]]
          (%i3) minimize_sx(x+y, [3*x+y=0, x+2*y>2]), nonegative_sx=true;
          (%o3)                Problem not feasible!
          (%i4) minimize_sx(x+y, [3*x+y>0]);
          (%o4)                Problem not bounded!

     Veja também: `maximize_sx', `nonegative_sx', `epsilon_sx'.


 -- Variável de opção: nonegative_sx
     Valor padrão: `false'

     Se `nonegative_sx' for verdadeiro (true) todas as variáveis de
     decisão para `minimize_sx' e `maximize_sx' são assumidas para
     serem positivas.

     Veja também: `minimize_sx'.



File: maxima.info,  Node: simplification,  Next: solve_rec,  Prev: simplex,  Up: Top

67 simplification
*****************

* Menu:

* Introdução a simplification::
* Definições para simplification::


File: maxima.info,  Node: Introdução a simplification,  Next: Definições para simplification,  Prev: simplification,  Up: simplification

67.1 Introdução a simplification
================================

O diretório `maxima/share/simplification' contém muitos scripts que
implementam regras de simplificação e funções, e também algumas
funções não relacionadas a simplificação.


File: maxima.info,  Node: Definições para simplification,  Prev: Introdução a simplification,  Up: simplification

67.2 Definições para simplification
===================================

67.2.1 Package absimp
---------------------

O pacote `absimp' contém regras de comparação de seqüências decaractere
que extendem as regras internas de simplificação para as funções `abs' e
`signum'.  `absimp' respeita as relações estabelecidas com a função
interna `assume' e por meio de declarações tais como `modedeclare (m,
even, n, odd)'  para inteiros paes ou ímpares.

   `absimp' define as funções `unitramp' e `unitstep' em termos de
`abs' e `signum'.

   `load (absimp)' torna esse pacote disponível para uso.  `demo
(absimp)' faz uma demonstração desse pacote.

   Exemplos:

     (%i1) load (absimp)$
     (%i2) (abs (x))^2;
                                            2
     (%o2)                                 x
     (%i3) diff (abs (x), x);
                                           x
     (%o3)                               ------
                                         abs(x)
     (%i4) cosh (abs (x));
     (%o4)                               cosh(x)

67.2.2 Package facexp
---------------------

O pacote `facexp' contém muitas funções relacionadas a simplificações
que fornecem ao usuário a habilidade de estruturar expressões por meio
de expansão controlada.   Essa capacidade é especialmente útil quando a
expressão contém variáveis que possuem significado físico, porque é
muitas vezes verdadeiro que a forma mais econômica de uma tal expressão
pode ser obtida por meio de uma expansão completa da expressão com
relação a essas variáveis, e então fatorar seus coeficientes.  Apesar
de ser verdadeiro que esse procedimento é fácil de realizar usando as
funções padrão do Maxima, ajustes adicionais podem se desejáveis, e
esses toques finais podem ser mais difíceis de aplicar.

   A função `facsum'  e suas formas relacionadas fornecem um meio
conveniente de controlar a estrutura de expressões por esse caminho.
Outra função, `collectterms', pode ser usada para adicionar duas ou
mais expressões que já tenham sido simplificadas para essa forma, sem
resimplificar a expressão completa novamente.  Essa função pode ser
útil quando expressões forem muito grandes.

   `load (facexp)' torna dispon;ivel para uso esse pacote.  `demo
(facexp)' faz uma demonstração desse pacote.

 -- Função: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Retorna uma forma de <expr>  que depende dos argumentos <arg_1>,
     ..., <arg_n>.  Os argumentos podem ser quaisquer formas adequadas
     para `ratvars', ou eles podem ser listas  de tais formas.  Se os
     argumentos não forem listas, então a forma retornada é
     completamente expandida com relação aos argumentos,  e os
     coeficientes dos argumentos foram fatorados.  Esses coeficientes
     são livres dos argumentos, exceto talvez no sentido não racional.

     Se quaisquer dos argumentos forem listas, então todas as tais
     listas são combinadas em uma lista simples,   e em lugar de chamar
     `factor'   sobre os coeficientes  dos  argumentos,  `facsum'
     chama a si mesma sobre esses coeficientes, usando  essa nova lista
     simples que foi construída como o novo argumento listo  para essa
     chamada recursiva.  Esse processo pode ser repetido para um
     quantidade arbitrária de repetições por através do aninhamento dos
     elementos desejados nas listas.

     É possível que alguém possa querer usar `facsum' com relação a
     subexpressões mais complicadas,  tal como  `log (x + y)'.  Tais
     argumentos são também permitidos.   Sem especificação de variável,
     por exemplo `facsum (<expr>)', o resultado retornado é o mesmo
     que o que é retornado por meio de `ratsimp (<expr>)'.

     Ocasionalmente o usuário pode querer obter quaisquer das formas
     abaixo para expressões que são especificadas somente por meio de
     seus operadores líderes.  Por exemplo, alguém pode querer usar
     `facsum' com relação a todos os `log''s.  Nessa situação, alguém
     pode incluir no meio dos argumentos ou o código dos `log''s
     eespecíficos que devem ser tratados po esse caminho ou
     alternativamente a expressão  `operator (log)' ou a expressão
     `'operator (log)'.   Se alguém quiser usar `facsum' na expressão
     <expr> com relação aos operadores <op_1>, ..., <op_n>, pode-se
     avaliar `facsum (<expr>, operator (<op_1>, ..., <op_n>))'.  A
     forma `operator' pode também aparecer dentro de uma lista de
     argumentos.

     Adicionalmente,  a escolha de comutadores `facsum_combine'  e
     `nextlayerfactor' pode afetar o ressultado de `facsum'.

 -- Variável global: nextlayerfactor
     Valor padrão: `false'

     Quando `nextlayerfactor' for `true', chamadas recursivas a `facsum'
     são aplicdas aos fatores da forma fatorada dos coeficientes dos
     argumentos.

     Quando `nextlayerfactor' for `false', `facsum' é aplicada a cada
     coeficiente como um todo mesmo se chamadas recursivas a `facsum'
     acontecerem.

     A inclusão do átomo `nextlayerfactor' na lista argumento de
     `facsum'  tem o efieto de `nextlayerfactor: true', mas para o
     próximo nível da expressão somente.  Uma vez que `nextlayerfactor'
     é sempre associado ou a `true' ou a  `false', `nextlayerfactor'
     deve ser apresentada com apóstrofo simples mesmo que
     `nextlayerfactor' apareça na lista de argumento de `facsum'.

 -- Variável global: facsum_combine
     Valor padrão: `true'

     `facsum_combine' controla a forma do resultado final retornada por
     meio de `facsum'  quando seu argumento é um quociente de
     polinômios.   Se `facsum_combine' for `false'  então a forma será
     retornada como um somatório completametne expandido como descrito
     acima,  mas se `true',  então a expressão retornada é uma razão de
     polinômios, com cada polinômio na forma descrita acima.

     A escolha de `true' desse comutador é útil quando se deseja para
     `facsum' ambos o dumerador e o denominador de uma expressão
     racional,  mas não se deseja que o denominador seja multiplicado
     de forma completa pelos termos do numerador.

 -- Função: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Retorna uma forma de <expr>  que é obtida por meio de chamada a
     `facsum' sobre os fatores de <expr> com <arg_1>, ... <arg_n> como
     argumentos.  Se qualqeur dos fatores de <expr> estiver elevado a
     um expoente, ambos o fator e o expoente irão ser processados por
     esse meio.

 -- Função: collectterms (<arg_1>, ..., <arg_n>)
     Se muitas expressões tiverem sido simplificadas com `facsum',
     `factorfacsum',  `factenexpand',  `facexpten' ou com
     `factorfacexpten',  e elas estão para serem adicionadas umas às
     outras, pode ser desejável combiná-las usando a função
     `collecterms'.  `collecterms' pode pegar como argumentos todos os
     argumentos que podem ser fornecidos para essas outras funções
     associadas com excessão de `nextlayerfactor', que não tem efeito
     sobre `collectterms'.  A vantagem de `collectterms'  está em que
     `collectterms' retorna uma forma similar a `facsum', mas uma vez
     que `collectterms' está adicionando forma que já tenham sido
     processadas por `facsum', `collectterms' não precisa repetir
     aquele esforço.   Essa capacidade é especialmente útil quando a
     expressão a ser somada for muito grande.

67.2.3 Pacote functs
--------------------

 -- Função: rempart (<expr>, <n>)
     Remove a parte <n> da expressão <expr>.

     Se <n> é uma lsita da forma `[<l>, <m>]' então as partes de <l>
     até <m> são removidas.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: wronskian ([<f_1>, ..., <f_n>], <x>)
     Retorna a matriz Wronskiana das funções <f_1>, ..., <f_n> na
     variável <x>.

     <f_1>, ..., <f_n> pode ser o nome de funções definidas pelo
     usuário, ou expressões na variável <x>.

     O determinante da matriz Wronskiana é o determinante Wronskiano do
     conjunto de funções.  As funções são linearmente independentes
     entre si se seu determinante for igual a zero.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: tracematrix (<M>)
     Retorna o traço (somatório dos elementos da diagonal principal) da
     matriz <M>.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: rational (`z')
     Multiplica o numerador e o denominador de <z> pelo complexo
     conjugado do denominador, racionando dessa forma o denominador
     complexo.  Retorna a forma de expressão racional canônica (CRE) se
     fornecida uma CRE, caso contrário retorna a forma geral.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: logand (`x',`y')
     Retorna o "e" lógico (bit-wise) dos argumento x e do argumento y.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: logor (`x',`y')
     Retorna o "ou" lógico (bit-wise) dos argumento x e do argumento y.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: logxor (`x',`y')
     Retorna "ou-exclusivo" lógico (bit-wise) dos argumento x e do
     argumento y.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: nonzeroandfreeof (<x>, <expr>)
     Retorna `true' se <expr> for diferente de zero e `freeof (<x>,
     <expr>)' retorna `true'.  Retorna `false' de outra forma.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: linear (<expr>, <x>)
     Quando <expr> for uma expressão linear na variável <x>, `linear'
     retorna `<a>*<x> + <b>' onde <a> é diferente de zero, e <a> e <b>
     são livres de <x>.  De outra forma, `linear' retorna <expr>.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: gcdivide (<p>, <q>)
     Quando `takegcd' for `true', `gcdivide' divide os polinômios <p> e
     <q> por seu maior divisor comum (MDC) e retorna a razão dos
     resultados.

     Quando `takegcd' for `false', `gcdivide' retorna a razão `<p>/<q>'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: arithmetic (<a>, <d>, <n>)
     Retorna o <n>-ésiomo termo da série aritmética `<a>, <a> + <d>,
     <a> + 2*<d>, ..., <a> + (<n> - 1)*<d>'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: geometric (<a>, <r>, <n>)
     Retorna o <n>-ésimo termo da série geométrica `<a>, <a>*<r>,
     <a>*<r>^2, ..., <a>*<r>^(<n> - 1)'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: harmonic (<a>, <b>, <c>, <n>)
     Retorna o <n>-ésimo termo da série harmônica `<a>/<b>, <a>/(<b> +
     <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> - 1)*<c>)'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: arithsum (<a>, <d>, <n>)
     Retorna a soma dos elementos da série aritmética de 1 a <n>.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: geosum (<a>, <r>, <n>)
     Retorna a soma dos elementos da série geométrica de 1 a <n>.  Se
     <n> for infinito (`inf') então a soma será finita se e somente se
     o valor absoluto de <r> for menor que 1.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: gaussprob (<x>)
     Retorna a função de probalilidade de Gauss `%e^(-<x>^2/2) /
     sqrt(2*%pi)'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: gd (<x>)
     Retorna a função de Gudermann `2 * atan(%e^<x> - %pi/2)'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: agd (<x>)
     Retorna o inverso da função de Gudermann `log (tan (%pi/4 +
     x/2)))'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: vers (<x>)
     Retorna o sinus versus `1 - cos (x)'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: covers (<x>)
     Retorna o sinus versus do complemento `1 - sin (<x>)'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: exsec (<x>)
     Retorna a parte externa da secante `sec (<x>) - 1'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: hav (<x>)
     Retorna o semi-sinus versus `(1 - cos(x))/2'.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: combination (<n>, <r>)
     Retorna o número de combinações de <n> objetos tomados em grupos
     de <r> elementos.

     Para usar essa função escreva primeiramente `load(functs)'.

 -- Função: permutation (<n>, <r>)
     Retorna o número de permutações de <r> objetos selecionados de um
     conjunto de <n> objetos.

     Para usar essa função escreva primeiramente `load(functs)'.

67.2.4 Package ineq
-------------------

O pacote `ineq' contém regras de simplificação para desigualdades.

   Sessão exemplo:

     (%i1) load(ineq)$
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     (%i2) a>=4;  /* uma desigualdade exemplo */
     (%o2)                               a >= 4
     (%i3) (b>c)+%; /* adiciona uma segunda e estrita desigualdade */
     (%o3)                            b + a > c + 4
     (%i4) 7*(x<y); /* multiplica por um número positivo */
     (%o4)                              7 x < 7 y
     (%i5) -2*(x>=3*z); /* multiplica por um número negativo */
     (%o5)                           - 2 x <= - 6 z
     (%i6) (1+a^2)*(1/(1+a^2)<=1); /* Maxima sabe que 1+a^2 > 0 */
                                             2
     (%o6)                             1 <= a  + 1
     (%i7) assume(x>0)$ x*(2<3); /* assumindo x>0 */
     (%o7)                              2 x < 3 x
     (%i8) a>=b; /* outa desigualdade */
     (%o8)                               a >= b
     (%i9) 3+%; /* adiciona alguma coisa à desigualdade imediatamente acima */
     (%o9)                           a + 3 >= b + 3
     (%i10) %-3; /* retirando essa alguma coisa */
     (%o10)                              a >= b
     (%i11) a>=c-b; /* ainda outra desigualdade */
     (%o11)                            a >= c - b
     (%i12) b+%; /* adiciona b a ambos os lados da desigualdade */
     (%o12)                            b + a >= c
     (%i13) %-c; /* subtrai c de ambos os lados */
     (%o13)                         - c + b + a >= 0
     (%i14) -%;  /* multiplica por -1 */
     (%o14)                          c - b - a <= 0
     (%i15) (z-1)^2>-2*z; /* determinando a verdade de uma assertiva */
                                           2
     (%o15)                         (z - 1)  > - 2 z
     (%i16) expand(%)+2*z; /* expandindo essa assertiva e adicionado 2*z a ambos os lados */
                                        2
     (%o16)                            z  + 1 > 0
     (%i17) %,pred;
     (%o17)                               true

   Seja cuidadoso com o uso dos parêntesis em torno de desigualdades:
quando o usuário digita `(A > B) + (C = 5)' o resltado é `A + C > B +
5', mas `A > B + C = 5' é um erro de sintaxe, e `(A > B + C) = 5' é
alguma coisa completametne diferente.

   Faça `disprule (all)' para ver uma lista completa das definições de
regras.

   O usuário será questionado se o Maxima for incapaz de decidir o
sinal de uma quantidade multiplicando uma desigualdade.

   O mais comum recurso estranho é ilustrado por:

     (%i1) eq: a > b;
     (%o1)                                a > b
     (%i2) 2*eq;
     (%o2)                              2 (a > b)
     (%i3) % - eq;
     (%o3)                                a > b

   Outro problema é 0 vezes uma desigualdade; o padrão para isso
acontecer é 0 ter sido colocado à esquerda sozinho. Todavia, se você
digitar `X*<some_inequality>' e Maxima perguntar sobre o sinal de `X' e
você responder `zero' (ou `z'), o programa retorna `X*<some_inequality>'
e não utiliza a informação que `X' é 0. Você pode fazer `ev (%, x: 0)'
em casos semelhantes a esse, como a base de dados irá somente ser usada
para propósitos de comparação em decisões, e não para o propósito de
avaliação de `X'.

   O usuário pode notar uma resposta lenta quando esse pacote é
disponibilizado para uso, como o simplificador é forçado a examinar
mais regras do precisaria sem esse pacote, então você pode desejar
remover essas regras após fazer uso delas. Faça `kill (rules)' para
eliminar todas as regras (incluindo qualquer regra que você possa ter
definido); ou você pode ser mais seletivo eliminando somente algumas
delas; ou use `remrule' sobre uma regra específica.

   Note que se você disponibiliza para uso esse pacote após definir
suas próprias regras você irá sobrscrever suas regras que possuirem
nomes identicos a nomes contidos em regras do pacote. As regras no
pacote são: `*rule1', ..., `*rule8', `+rule1', ..., `+rule18', e você
deve colocar o nome de regra entre aspas duplas ao referir-se a eles,
como em `remrule ("+", "+rule1")' para especificamente remover a
primeira regra sobre `"+"' ou `disprule ("*rule2")' para mostrar a
definição da segunda regra multiplicativa.

67.2.5 Package rducon
---------------------

 -- Função: reduce_consts (<expr>)
     Substitui subexpressões constantes de <expr> com construída com
     átomos constantes, gravando a definição de todas essas constantes
     construídas na lista de equações `const_eqns', e retornando a
     expressão modificada <expr>.  Essas partes de <expr> são
     constantes que retornam `true' quando operadas por meio da
     função `constantp'.  Conseqüêntemente, antes de usar
     `reduce_consts', se pode fazer

          declare ([<objeto que vai receber a propriedade constante>], constant)$

     para escolher a base de dados das quantidades constantes ocorrendo
     em suas expressões.

     Se você está planejando gerar saídas em Fortran após esses cálculos
     simbólicos, uma das primeiras seções de código pode ser o cálculo
     de todas as constantes.  Para gerar esse segmento de código,
     faça

          map ('fortran, const_eqns)$

     Variables como `const_eqns' que afetam `reduce_consts' são:

     `const_prefix' (valor padrão: `xx') é a seqüência de caracteres
     usada para prefixar todos os símbolos gerados por `reduce_consts'
     para representar subexpressões constantes.

     `const_counter' (valor padrão: 1) é o índice inteiro usado para
     gerar símbolos únicos para representar cada subexpressão constante
     emcontrada por `reduce_consts'.

     `load (rducon)' torna essa função disponível para uso.  `demo
     (rducon)' faz uma demonstração dessa função.

67.2.6 Pacote scifac
--------------------

 -- Função: gcfac (<expr>)
     `gcfac' função de fatoração que tenta aplicar a mesma heurística
     que cientístas aplicam em tentativas de fazer expressões
     extremamente simples.  `gcfac' está limitada a fatorações
     monomiais.  Para um somatório, `gcfac' faz o seguinte:

       1. Fatores sobre os inteiros.

       2. Coloca em evidência o maior expoente de termos ocorrendo como
          coeficientes, independentemente da complexidade dos termos.

       3. Usa (1) e (2) em fatorações de pares de termos adjascentes.

       4. Repetidamente e recursivamente aplica essas técnicas até que
          a expressão não mais mude.

     O item (3) não necessáriamente faz uma tarefa ótima fatoração par
     a par devido à dificuldade combinatória natural de encontrar qual
     de todas dos possíveis rearranjos de pares retorna o mais compacto
     resultado de fatoração de um par.

     `load (scifac)' torna essa função disponível para uso.  `demo
     (scifac)' faz uma demonstração dessa função.

67.2.7 Pacote sqdnst
--------------------

 -- Função: sqrtdenest (<expr>)
     Desaninha `sqrt' de simples, numérico, binômios de raízes
     irracionais de números racionais , onde for possível.  E.g.

          (%i1) load (sqdnst)$
          (%i2) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);
                                              sqrt(3)
                                         sqrt(------- + 1)
                                                 2
          (%o2)                        ---------------------
                                       sqrt(11 sqrt(2) - 12)
          (%i3) sqrtdenest(%);
                                            sqrt(3)   1
                                            ------- + -
                                               2      2
          (%o3)                            -------------
                                              1/4    3/4
                                           3 2    - 2

     Algumas vezes isso ajuda na hora de aplicar `sqrtdenest' mais que
     uma vez, sobre coisas como `(19601-13860 sqrt(2))^(7/4)'.

     `load (sqdnst)' Torna essa função disponível para uso.


File: maxima.info,  Node: solve_rec,  Next: stats,  Prev: simplification,  Up: Top

68 solve_rec
************

/solve_rec.texi/1.7/Tue Jan 16 15:15:10 2007//

* Menu:

* Introdução a solve_rec::
* Definições para solve_rec::


File: maxima.info,  Node: Introdução a solve_rec,  Next: Definições para solve_rec,  Prev: solve_rec,  Up: solve_rec

68.1 Introdução a solve_rec
===========================

`solve_rec' é um pacote para resolver recorrências lineares com
coeficientes polinomiais.

   Um arquivo de domostração está disponivel com `demo(solve_rec);'.

   Exemplo:

     (%i1) load("solve_rec")$
     (%i2) solve_rec((n+4)*s[n+2] + s[n+1] - (n+1)*s[n], s[n]);
                                         n
                      %k  (2 n + 3) (- 1)          %k
                        1                            2
     (%o2)       s  = -------------------- + ---------------
                  n     (n + 1) (n + 2)      (n + 1) (n + 2)


File: maxima.info,  Node: Definições para solve_rec,  Prev: Introdução a solve_rec,  Up: solve_rec

68.2 Definições para solve_rec
==============================

 -- Função: reduce_order (<rec>, <sol>, <var>)
     Reduz a ordem de recorrência linear <rec> quando uma solução
     particular <sol> for conhecida. A recorrência reduzida pode ser
     usada para pegar outras soluções.

     Exemplo:

          (%i3) rec: x[n+2] = x[n+1] + x[n]/n;
                                                x
                                                 n
          (%o3)               x      = x      + --
                               n + 2    n + 1   n
          (%i4) solve_rec(rec, x[n]);
          WARNING: found some hypergeometrical solutions!
          (%o4)                    x  = %k  n
                                    n     1
          (%i5) reduce_order(rec, n, x[n]);
          (%t5)                    x  = n %z
                                    n       n

                                     n - 1
                                     ====
                                     \
          (%t6)                %z  =  >     %u
                                 n   /        %j
                                     ====
                                     %j = 0

          (%o6)             (- n - 2) %u     - %u
                                        n + 1     n
          (%i6) solve_rec((n+2)*%u[n+1] + %u[n], %u[n]);
                                               n
                                      %k  (- 1)
                                        1
          (%o6)                 %u  = ----------
                                  n    (n + 1)!

          So the general solution is

                       n - 1
                       ====        n
                       \      (- 1)
                 %k  n  >    -------- + %k  n
                   2   /     (n + 1)!     1
                       ====
                       n = 0


 -- Variável de opção: simplify_products
     Valor padrão: `true'

     Se `simplify_products' for `true', `solve_rec' irá tentar
     simplificar produtos no resultado.

     Veja também: `solve_rec'.


 -- Função: simplify_sum (<expr>)
     Tenta simplificar todos os somatórios que aparecem na <expr> para
     uma forma a mais simplificada possível.

     `simplify_sum' usa os algorítmos de Gosper e de Zeilberger para
     simplificar somatórios.

     Para usar essa função primeiramente chame o pacote `simplify_sum'
     com `load(simplify_sum)'.

     Exemplo:

          (%i1) load("simplify_sum")$
          (%i2) sum(binom(n+k,k)/2^k, k, 0, n) + sum(binom(2*n, 2*k), k, 0, n);
                   n                            n
                  ====                         ====
                  \      binomial(n + k, k)    \
          (%o2)    >     ------------------ +   >    binomial(2 n, 2 k)
                  /               k            /
                  ====           2             ====
                  k = 0                        k = 0
          (%i3) simplify_sum(%);
                                         n
                                        4     n
          (%o3)                         -- + 2
                                        2


 -- Função: solve_rec (<eqn>, <var>, [<init>])
     Encontra soluções hipergeométricas para a recorrência linear <eqn>
     com coeficientes polinomiais na variável <var>. Argumentos
     opcionais <init> são as condições iniciais.

     `solve_rec' pode resolver recorrências lineares com coeficientes
     constantes, encontrando soluções hipergeométricas para
     recorrências lineares homogêneas com coeficientes polinomiais,
     soluções racionais para recorrências lineares com coeficientes
     polinomiais e pode resolver recorrências do tipo de Ricatti.

     Note que o tempo de execução do algorítmo usado para encontrar
     soluções hipergeométricas aumenta exponencialmente com o grau do
     coeficiente lider e guia.

     Para usar essa função primeiramente chame o pacote `solve_rec' com
     `load(solve_rec);'.

     Exemplo de recorrência linear com coeficientes constantes:

          (%i2) solve_rec(a[n]=a[n-1]+a[n-2]+n/2^n, a[n]);
                                  n          n
                     (sqrt(5) - 1)  %k  (- 1)
                                      1           n
          (%o2) a  = ------------------------- - ----
                 n               n                  n
                                2                5 2
                                                          n
                                             (sqrt(5) + 1)  %k
                                                              2    2
                                           + ------------------ - ----
                                                      n              n
                                                     2            5 2

     Exemplo de recorrência linear com coeficientes polinomiais:

          (%i7) 2*x*(x+1)*y[x] - (x^2+3*x-2)*y[x+1] + (x-1)*y[x+2];
                                   2
          (%o7) (x - 1) y      - (x  + 3 x - 2) y      + 2 x (x + 1) y
                         x + 2                   x + 1                x
          (%i8) solve_rec(%, y[x], y[1]=1, y[3]=3);
                                        x
                                     3 2    x!
          (%o9)                 y  = ---- - --
                                 x    4     2

     Exemplo de recorrência do tipo de Ricatti:

          (%i2) x*y[x+1]*y[x] - y[x+1]/(x+2) + y[x]/(x-1) = 0;
                                      y         y
                                       x + 1     x
          (%o2)         x y  y      - ------ + ----- = 0
                           x  x + 1   x + 2    x - 1
          (%i3) solve_rec(%, y[x], y[3]=5)$
          (%i4) ratsimp(minfactorial(factcomb(%)));
                                             3
                                         30 x  - 30 x
          (%o4) y  = - -------------------------------------------------
                 x        6      5       4       3       2
                       5 x  - 3 x  - 25 x  + 15 x  + 20 x  - 12 x - 1584

     Veja também: `solve_rec_rat', `simplify_products', e
     `product_use_gamma'.


 -- Função: solve_rec_rat (<eqn>, <var>, [<init>])
     Encontra soluções racionais para recorrências lineares. Veja
     solve_rec para uma descrição dos argumentos.

     Para usar essa função primeirametne chame o pacote `solve_rec' com
     `load(solve_rec);'.

     Exemplo:

          (%i1) (x+4)*a[x+3] + (x+3)*a[x+2] - x*a[x+1] + (x^2-1)*a[x];
          (%o1)  (x + 4) a      + (x + 3) a      - x a
                          x + 3            x + 2      x + 1
                                                             2
                                                         + (x  - 1) a
                                                                      x
          (%i2) solve_rec_rat(% = (x+2)/(x+1), a[x]);
                                 1
          (%o2)      a  = ---------------
                      x   (x - 1) (x + 1)

     Veja também: `solve_rec'.


 -- Variável de opção: product_use_gamma
     Valor padrão: `true'

     Quando simplificando produtos, `solve_rec' introduz a função gama
     dentro da expressão se `product_use_gamma' for `true'.

     Veja também: `simplify_products', `solve_rec'.


 -- Função: summand_to_rec (<summand>, <k>, <n>)
 -- Função: summand_to_rec (<summand>, [<k>, <lo>, <hi>], <n>)
     Retorna a recorrência satisfeita pelo somatório

               sup
              ====
              \
               >     x
              /
              ====
            k = inf

     onde x é hipergeométrico em <k> e <n>. SE <inf> e <sup> forem
     omitidos, são assumidos como sendo `inf = -inf' e `sup = inf'.

     Para usar essa função primeiro chame o pacote `simplify_sum' com
     `load(simplify_sum)'.

     Exemplo:

          (%i1) load("simplify_sum")$
          (%i2) summand: binom(n,k);
          (%o2)                           binomial(n, k)
          (%i3) summand_to_rec(summand,k,n);
          (%o3)                      2 sm  - sm      = 0
                                         n     n + 1
          (%i7) summand: binom(n, k)/(k+1);
                                          binomial(n, k)
          (%o7)                           --------------
                                              k + 1
          (%i8) summand_to_rec(summand, [k, 0, n], n);
          (%o8)               2 (n + 1) sm  - (n + 2) sm      = - 1
                                          n             n + 1



File: maxima.info,  Node: stats,  Next: stirling,  Prev: solve_rec,  Up: Top

69 stats
********

* Menu:

* Introdução a stats::
* Definições para inference_result::
* Definições para stats::
* Definições para distribuições especiais::


File: maxima.info,  Node: Introdução a stats,  Next: Definições para inference_result,  Prev: Top,  Up: Top

69.1 Introdução a stats
=======================

O pacote `stats' contém um conjunto de procedimentos de inferência
clássica estatística e procedimentos de teste.

   Todas essas funções retornam um objeto do Maxima chamado
`inference_result' que contém os resultados necessários para
inferências de manipulação e tomada de decisões.

   A variável global `stats_numer' controla se resultados são mostrados
em ponto flutuante ou simbólico e no formato racional; seu valor padrão
é `true' e os resultados são retornados no formato de ponto flutuante.

   O pacote `descriptive' contém alguns utilitários para manipular
estruturas de dados (listas e matrizes); por exemplo, para extrair
subamostras. O pacote `descriptive' também contém alguns exemplos sobre
como usar o pacote `numericalio' para ler dados a partir de arquivo no
formato texto plano. Veja `descriptive' e `numericalio' para maiores
detalhes.

   O pacote `stats' precisa dos pacotes `descriptive', `distrib' e
`inference_result'.

   Para comentários, erros ou sugestões, por favor contate o autor em

   <'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para inference_result,  Next: Definições para stats,  Prev: Introdução a stats,  Up: Top

69.2 Definições para inference_result
=====================================

 -- Função: inference_result (<título>, <valores>, <números>)
     Constrói um objeto `inference_result' do tipo retornado pelas
     funções stats. O argumento <título> é uma seqüência de caracteres
     do Maxima co o nome do procedimento; <valores> é uma lissta com
     elementos da forma `símbolo = valor' e <números> é uma lista com
     números inteiros positivos no intervalo de um para
     `length(<valores>)', indicando que valores serão mostrados por
     padrão.

     Exemplo:

     Este é um exemplo que mostras os resultados associados a um
     retángulo. O título deste bojeto é a seqüência de caraceteres
     `"Retângulo"', o qual armazena cinco resultados, a saber, `'base',
     `'altura', `'diagonal', `'área' y `'perímetro', porém só mostra o
     primeiro, segundo, quinto e quarto resultado. O resultado
     `'diagonal' também é armazenado neste objeto, no entanto não é
     mostrado por padrão; para se ter acesso a este valor, faz-se uso
     da função `take_inference'.

          (%i1) load(inference_result)$
          (%i2) b: 3$ h: 2$
          (%i3) inference_result("Retângulo",
                                  ['base=b,
                                   'altura=h,
                                   'diagonal=sqrt(b^2+h^2),
                                   'área=b*h,
                                   'perímetro=2*(b+h)],
                                  [1,2,5,4] );
                                  |   Retângulo
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   altura = 2
                                  |
                                  | perímetro = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('diagonal,%);
          (%o4)                        sqrt(13)

     Veja também `take_inference'.

 -- Função: inferencep (<obj>)
     Retorna `true' ou `false', dependendo se <obj> é um objeto
     `inference_result' ou não.


 -- Função: items_inference (<obj>)
     Retorna uma lista com os nomes dos itens em <obj>, que devem ser
     um objeto `inference_result'.

     Exemplo:

     O objeto `inference_result' armazena dois valores, a saber `'pi' e
     `'e', mas somente o segundo é mostrado. A função `items_inference'
     retorna os nomes de todos os itens, não importa se eles são ou não
     mostrados.

          (%i1) load(inference_result)$
          (%i2) inference_result("Hi", ['pi=%pi,'e=%e],[2]);
                                      |   Hi
          (%o2)                       |
                                      | e = %e
          (%i3) items_inference(%);
          (%o3)                        [pi, e]

 -- Função: take_inference (<n>, <obj>)
 -- Função: take_inference (<nome>, <obj>)
 -- Função: take_inference (<lista>, <obj>)
     Retorna o <n>-ésimo valor armazenado em <obj> se <n> for um
     inteiro positivo, ou o item chamado <nome> se esse for o nome de
     um item. Se o primeiro argumento for uma lista de números e/ou
     símbolos, a função `take_inference' retorna uma lista com os
     resultados correspondentes.

     Exemplo:

     Fornece um objeto `inference_result', a função `take_inference' é
     chamada com o objetivo de extrair alguma informação armazenada
     nesse objeto.

          (%i1) load(inference_result)$
          (%i2) b: 3$ h: 2$
          (%i3) sol: inference_result("Retângulo",
                                      ['base=b,
                                       'altura=h,
                                       'diagonal=sqrt(b^2+h^2),
                                       'area=b*h,
                                       'perímetro=2*(b+h)],
                                      [1,2,5,4] );
                                  |   Retângulo
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   altura = 2
                                  |
                                  | perímetro = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('base,sol);
          (%o4)                           3
          (%i5) take_inference(5,sol);
          (%o5)                          10
          (%i6) take_inference([1,'diagonal],sol);
          (%o6)                     [3, sqrt(13)]
          (%i7) take_inference(items_inference(sol),sol);
          (%o7)                [3, 2, sqrt(13), 6, 10]

     Veja também `inference_result' e `take_inference'.


File: maxima.info,  Node: Definições para stats,  Next: Definições para distribuições especiais,  Prev: Definições para inference_result,  Up: Top

69.3 Definições para stats
==========================

 -- Variável de opção: stats_numer
     Valor padrão: `true'

     Se `stats_numer' for `true', funções de inferência estatística
     retornam seus resultados em números com ponto flutuante. Se
     `stats_numer' for `false', resultados são fornecidos em formato
     simbólico e racional.


 -- Função: test_mean (<x>)
 -- Função: test_mean (<x>, <opção_1>, <opção_2>, ...)
     Esse é o teste-<t> de média. O argumento <x> é uma lista ou uma
     matriz coluna contendo uma amostra unidimensional. `test_mean'
     tamb;em executa um teste assintótico baseado no Teorema do Limite
     Central se a opção `'asymptotic' for `true'.

     Opções:

        * `'mean', o valor padrão é `0', é o valor da média a ser
          verificado.

        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.

        * `'dev', o valor padrão é `'unknown', corresponde ao valor do
          desvio padrão quando esse valor de desvio padrão for
          conhecido; valores válidos são: `'unknown' ou uma expressão
          positiva.

        * `'conflevel', o valor padrão é `95/100', nível de confidência
          para o intervalo de confidência; deve ser uma expressão que
          toma um valor em (0,1).

        * `'asymptotic', o valor padrão é `false', indica se
          `test_mean' exeecuta um teste-<t> exato ou um teste
          assintótico baseando-se no Teorema do Limite Central; valores
          válidos são `true' e `false'.


     A saída da função `test_mean' é um objeto `inference_result' do
     Maxima mostrando os seguintes resultados:

       1. `'mean_estimate': a média da amostra.

       2. `'conf_level': nível de confidência selecionado pelo usuário.

       3. `'conf_interval': intervalo de confidência para a média da
          população.

       4. `'method': procedimento de inferência.

       5. `'hypotheses': hipótese do nulo e hipótese alternativa a ser
          testada.

       6. `'statistic': valor da amostra estatística a ser usado para
          testar a hipótese do nulo.

       7. `'distribution': distribuição da amostra estatística,
          juntamente com seus parâmetro(s).

       8. `'p_value': valores de p do teste.


     Exemplos:

     Executa um teste-<t> exato com variância desconhecida. A hipótese
     do nulo é H_0: mean=50 contra a alternativa unilatera H_1: mean<50;
     conforme os resultados, o valor de p é muito grande, não existem
     evidências paa rejeitar H_0.

          (%i1) load("stats")$
          (%i2) data: [78,64,35,45,45,75,43,74,42,42]$
          (%i3) test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
                    |                 MEAN TEST
                    |
                    |            mean_estimate = 54.3
                    |
                    |              conf_level = 0.9
                    |
                    | conf_interval = [minf, 61.51314273502712]
                    |
          (%o3)     |  method = Exact t-test. Unknown variance.
                    |
                    | hypotheses = H0: mean = 50 , H1: mean < 50
                    |
                    |       statistic = .8244705235071678
                    |
                    |       distribution = [student_t, 9]
                    |
                    |        p_value = .7845100411786889

     Nesta ocasião Maxima executa um testte assintótico, baseado no
     Teorema do Limite Central.  A hipótese do nulo é H_0: equal(mean,
     50) contra a alternativa de duas vias H_1: not equal(mean, 50);
     conforme os resultados, o valor de p é muito pequeno, H_0 pode ser
     rejeitado em favor da alternativa H_1. Note que, como indicado
     pela componente `Method', esse procedimento pode ser aplicado a
     grandes amostras.

          (%i1) load("stats")$
          (%i2) test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
                        98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
                        45,51,123,54,151],
                        'asymptotic=true,'mean=50);
                    |                       MEAN TEST
                    |
                    |           mean_estimate = 74.88571428571429
                    |
                    |                   conf_level = 0.95
                    |
                    | conf_interval = [57.72848600856194, 92.04294256286663]
                    |
          (%o2)     |    method = Large sample z-test. Unknown variance.
                    |
                    |       hypotheses = H0: mean = 50 , H1: mean # 50
                    |
                    |             statistic = 2.842831192874313
                    |
                    |             distribution = [normal, 0, 1]
                    |
                    |             p_value = .004471474652002261


 -- Função: test_means_difference (<x1>, <x2>)
 -- Função: test_means_difference (<x1>, <x2>, <opção_1>, <opção_2>,
          ...)
     Esse é o teste-<t> de diferença de médias entre duas amostras.  Os
     argumentos <x1> e <x2> são listas ou matrizes colunas contendo
     duas amostras independentes. No caso de diferentes variâncias
     desconhecidas (veja opções `'dev1', `'dev2' e `'varequal' abaixo),
     os graus de liberdade são calculados por meio da aproximação de
     Welch.  `test_means_difference' também executa um teste assintótico
     baseado no Teorema do Limite Central se a opção `'asymptotic' for
     escolhida para `true'.

     Opções:

        *        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.

        * `'dev1', o valor padrão é `'unknown', é o valor do desvio
          padrão da amostra <x1> quando esse desvio for conhecido;
          valores válidos são: `'unknown' ou uma expressão positiva.

        * `'dev2', o valor padrão é `'unknown', é o valor do desvio
          padrão da amostra <x2> quando esse desvio for conhecido;
          valores válidos são: `'unknown' ou uma expressão positiva.

        * `'varequal', o valor padrão é `false', se variâncias podem
          serem consideradas como iguais ou não; essa opção tem efeito
          somente quando `'dev1' e/ou `'dev2' forem  `'unknown'.

        * `'conflevel', o valor padrão é `95/100', nível de confidência
          para o intervalo de confidência; deve ser uma expressão que
          toma valores em (0,1).

          Nota de Tradução: (0,1) representa intervalo aberto.

        * `'asymptotic', o valor padrão é `false', indica se
          `test_means_difference' executa um teste-<t> exato ou um
          teste assíntótico baseando-se no Teorema do Limite Central;
          valores válidos são `true' e `false'.


     A saída da função `test_means_difference' é um objeto
     `inference_result' do Maxima mostrando os seguintes resultados:

       1. `'diff_estimate': a diferença de médias estimadas.

       2. `'conf_level': nível de confidência selecionado pelo usuário.

       3. `'conf_interval': intervalo de confidência para a
          diferença de médias.

       4. `'method': procedimento de inferência.

       5. `'hypotheses': a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       6. `'statistic': valor da amostra estatística usado para testar
          a hipótese do nulo.

       7. `'distribution': distribuição da amostra estatística,
          juntamente com seu(s) parâmetro(s).

       8. `'p_value': valor de p do teste.


     Exemplos:

     A igualdade de médias é testada com duas pequenas amostras <x> e
     <y>, contra a alternativa H_1: m_1>m_2, sendo m_1 e m_2 as médias
     das populações; variâncias são desconhecidas e supostamente
     admitidas para serem diferentes.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_means_difference(x,y,'alternative='greater);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |    conf_interval = [- .04597417812882298, inf]
                      |
          (%o4)       |        method = Exact t-test. Welch approx.
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.838004300728477
                      |
                      |    distribution = [student_t, 8.62758740184604]
                      |
                      |            p_value = .05032746527991905

     O mesmo teste que antes, mas agora as variâncias são admitidas
     serem supostamente iguais.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: matrix([1.2],[6.9],[38.7],[20.4],[17.2])$
          (%i4) test_means_difference(x,y,'alternative='greater,'varequal=true);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |     conf_interval = [- .7722627696897568, inf]
                      |
          (%o4)       |   method = Exact t-test. Unknown equal variances
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.765996124515009
                      |
                      |           distribution = [student_t, 9]
                      |
                      |            p_value = .05560320992529344


 -- Função: test_variance (<x>)
 -- Função: test_variance (<x>, <opção_1>, <opção_2>, ...)
     Esse é o teste da variância <chi^2>. O argumento <x> é uma lista
     ou uma matriz coluna contendo uma amostra unidimensional tomada
     entre a população normal.

     Opções:

        * `'mean', o valor padrão é `'unknown', é a média da
          população, quando for conhecida.

        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.

        * `'variance', o valor padrão é `1', isso é o valor (positivo)
          da variância a ser testado.

        * `'conflevel', o valor padrão é `95/100', nível de confidência
          para o intervalo de confidência; deve ser uma expressão que
          toma valores em (0,1).


     A saída da função `test_variance' está no objeto
     `inference_result' do Maxima mostrando os seguintes resultados:

       1. `'var_estimate': a variância da amostra.

       2. `'conf_level': nível de confidência selecionado pelo usuário.

       3. `'conf_interval': intervalo de confidência para a variância
          da população.

       4. `'method': procedimento de inferência.

       5. `'hypotheses': a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       6. `'statistic': valor da amostra estatística usado para testar
          a hipótese do nulo.

       7. `'distribution': distribuição da amostra estatística,
          juntamente com seu parâmetro.

       8. `'p_value': o valor de p do teste.


     Exemplos:

     Isso é testado se a variância de uma população com média
     desconhhecida for igual ou maior que 200.

          (%i1) load("stats")$
          (%i2) x: [203,229,215,220,223,233,208,228,209]$
          (%i3) test_variance(x,'alternative='greater,'variance=200);
                       |                  VARIANCE TEST
                       |
                       |              var_estimate = 110.75
                       |
                       |                conf_level = 0.95
                       |
                       |     conf_interval = [57.13433376937479, inf]
                       |
          (%o3)        | method = Variance Chi-square test. Unknown mean.
                       |
                       |    hypotheses = H0: var = 200 , H1: var > 200
                       |
                       |                 statistic = 4.43
                       |
                       |             distribution = [chi2, 8]
                       |
                       |           p_value = .8163948512777689


 -- Função: test_variance_ratio (<x1>, <x2>)
 -- Função: test_variance_ratio (<x1>, <x2>, <opção_1>, <opção_2>, ...)
     Isso é o teste <F> da razão de variância para duas populações
     normais.  Os argumentos <x1> e <x2> são listas ou matrizes colunas
     contendo duas amostras independentes.

     Opções:

        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.

        * `'mean1', o valor padrão é `'unknown', quando for conhecida,
          isso é a média da população da qual <x1> foi tomada.

        * `'mean2', o valor padrão é `'unknown', quando for conhecida,
          isso é a média da população da qual <x2> foi tomada.

        * `'conflevel', o valor padrão é `95/100', nível de confidência
          para o intervalo de confidência da razão; deve ser uma
          expressão que tome valores em (0,1).


     A saída da função `test_variance_ratio' é um objeto
     `inference_result' do Maxima mostrando os seguintes resultados:

       1. `'ratio_estimate': a razão de variância da amostra.

       2. `'conf_level': nível de confidência selecionado pelo usuário.

       3. `'conf_interval': intervalo de confidência para a razão de
          variância.

       4. `'method': procedimento de inferência.

       5. `'hypotheses': a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       6. `'statistic': valor da amostra estatística usado para testar
          a hipótese do nulo.

       7. `'distribution': distribuição da amostra estatística,
          juntamente com seus parâmetros.

       8. `'p_value': o valor de p do teste.


     Exemplos:

     a igualdade das variâncias de duas populações normais é verificado
     contra a alternativa que a primeira é maior que a segunda.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_variance_ratio(x,y,'alternative='greater);
                        |              VARIANCE RATIO TEST
                        |
                        |       ratio_estimate = 2.316933391522034
                        |
                        |               conf_level = 0.95
                        |
                        |    conf_interval = [.3703504689507268, inf]
                        |
          (%o4)         | method = Variance ratio F-test. Unknown means.
                        |
                        | hypotheses = H0: var1 = var2 , H1: var1 > var2
                        |
                        |         statistic = 2.316933391522034
                        |
                        |            distribution = [f, 5, 4]
                        |
                        |          p_value = .2179269692254457


 -- Função: test_sign (<x>)
 -- Função: test_sign (<x>, <opção_1>, <opção_2>, ...)
     Esse é o teste de sinal não paramétrico para a mediana de uma
     população contínua.  O argumento <x> é uma lista ou uma matriz
     coluna contendo uma amostra unidimensional.

     Opções:

        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.

        * `'median', o valor padrão é `0', é o valor da mediana a ser
          verificado.


     A saída da função `test_sign' é um objeto `inference_result' do
     Maxima mostrando os seguintes resultados:

       1. `'med_estimate': a mediana da amostra.

       2. `'method': procedimento de inferência.

       3. `'hypotheses': a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       4. `'statistic': valor da amostra estatística usada para testar
          a hipótese do nulo.

       5. `'distribution': distribuição da amostra estatística,
          juntamente com seu(s) parâmetro(s).

       6. `'p_value': o valor de p do teste.


     Exemplos:

     Verifica se a população da qual a amostra foi tomada tem mediana 6,
     contra a alternativa H_1: median > 6.

          (%i1) load("stats")$
          (%i2) x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
          (%i3) test_sign(x,'median=6,'alternative='greater);
                         |                  SIGN TEST
                         |
                         |              med_estimate = 5.1
                         |
                         |      method = Non parametric sign test.
                         |
          (%o3)          | hypotheses = H0: median = 6 , H1: median > 6
                         |
                         |                statistic = 7
                         |
                         |      distribution = [binomial, 10, 0.5]
                         |
                         |         p_value = .05468749999999989


 -- Função: test_signed_rank (<x>)
 -- Função: test_signed_rank (<x>, <opção_1>, <opção_2>, ...)
     Esse é o teste de ranque sinalizado de Wilcoxon para fazer
     inferências sobre a mediana de uma população contínua. O argumento
     <x> é uma lista ou uma matriz coluna contendo uma amostra
     unidimensional. Executa uma aproximação normal se o tamanho da
     amostra for maior que 20, ou se existirem zeros ou houverem
     empates.

     Veja também `pdf_rank_test' e `cdf_rank_test'.

     Opções:

        * `'median', o valor padrão é `0', é o valor da mediana a ser
          verificado.

        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.


     A saída da função `test_signed_rank' é um objeto
     `inference_result' do Maxima com os seguintes resultados:

       1. `'med_estimate': a mediana da amostra.

       2. `'method': procedimento de inferência.

       3. `'hypotheses': a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       4. `'statistic': valor da amostra estatística usado para testar
          a hipótese do nulo.

       5. `'distribution': distribuição da amostra estatística,
          juntamente com seu(s) parâmetro(s).

       6. `'p_value': o valor de p do teste.


     Exemplos:

     Verifica a hipótese do nulo H_0: median = 15 contra a alternativa
     H_1: median > 15. Esse é um teste exato, ua vez que não exite
     empates.

          (%i1) load("stats")$
          (%i2) x: [17.1,15.9,13.7,13.4,15.5,17.6]$
          (%i3) test_signed_rank(x,median=15,alternative=greater);
                           |             SIGNED RANK TEST
                           |
                           |           med_estimate = 15.7
                           |
                           |           method = Exact test
                           |
          (%o3)            | hypotheses = H0: med = 15 , H1: med > 15
                           |
                           |              statistic = 14
                           |
                           |     distribution = [signed_rank, 6]
                           |
                           |            p_value = 0.28125

     Verifica a hipótese do nulo H_0: equal(median, 2.5) contra a
     alternativa H_1: not equal(median, 2.5). Esse é um teste
     aproximado, uma vez que ocorrem empates.

          (%i1) load("stats")$
          (%i2) y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
          (%i3) test_signed_rank(y,median=2.5);
                       |                 SIGNED RANK TEST
                       |
                       |                med_estimate = 2.9
                       |
                       |          method = Asymptotic test. Ties
                       |
          (%o3)        |    hypotheses = H0: med = 2.5 , H1: med # 2.5
                       |
                       |                 statistic = 76.5
                       |
                       | distribution = [normal, 60.5, 17.58195097251724]
                       |
                       |           p_value = .3628097734643669


 -- Função: test_rank_sum (<x1>, <x2>)
 -- Função: test_rank_sum (<x1>, <x2>, <opção_1>)
     Esse é o teste de Wilcoxon-Mann-Whitney para comparação das
     medianas de duas populações contínuas. Os primeiros dois
     argumentos <x1> e <x2> são listas ou matrizes colunas com os dados
     de duas amostras independentes. Executa aproximação normal se
     quaisquer dos tamanhos de amostra for maior que 10, ou se houverem
     empates.

     Opção:

        * `'alternative', o valor padrão é `'twosided', é a hipótese
          alternativa; valores válidos são: `'twosided', `'greater' e
          `'less'.


     A saída da função `test_rank_sum' é um objeto `inference_result'
     do Maxima com os seguintes resultados:

       1. `'method': procedimento de inferência.

       2. `'hypotheses': a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       3. `'statistic': valor da amostra estatística usada para testar
          a hipótese do nulo.

       4. `'distribution': distribuição da amostra estatística,
          juntamente com seus parâmetros.

       5. `'p_value': o valor de p do teste.


     Exemplos:

     Verifica se populações possuem medianas similares. Tamanhos de
     amotra são pequenos e é feito um teste exato.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) y:[21,18,25,14,52,65,40,43]$
          (%i4) test_rank_sum(x,y);
                        |                 RANK SUM TEST
                        |
                        |              method = Exact test
                        |
                        | hypotheses = H0: med1 = med2 , H1: med1 # med2
          (%o4)         |
                        |                 statistic = 22
                        |
                        |        distribution = [rank_sum, 9, 8]
                        |
                        |          p_value = .1995886466474702

     Agora, com grandes amostras e empates, o procedimento faz
     aproximação norma. A hipótese alternativa é H_1: median1 < median2.

          (%i1) load("stats")$
          (%i2) x: [39,42,35,13,10,23,15,20,17,27]$
          (%i3) y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
          (%i4) test_rank_sum(x,y,'alternative='less);
                       |                  RANK SUM TEST
                       |
                       |          method = Asymptotic test. Ties
                       |
                       |  hypotheses = H0: med1 = med2 , H1: med1 < med2
          (%o4)        |
                       |                 statistic = 48.5
                       |
                       | distribution = [normal, 79.5, 18.95419580097078]
                       |
                       |           p_value = .05096985666598441


 -- Função: test_normality (<x>)
     Teste de Shapiro-Wilk para normalidade. O argumento <x> é uma
     lista de números, e o tamanho da amostra deve ser maior que 2 e
     menor ou igua a 5000, de outra forma, a função `test_normality'
     sinaliza com um erro.

     Referência:

     [1] Algorithm AS R94, Applied Statistics (1995), vol.44, no.4,
     547-551

     A saída da função `test_normality' é um objeto `inference_result'
     do Maxima com os seguintes resultados:

       1. `'statistic': valor do <W> estatístico.

       2. `'p_value': valor de p sob a hipótese de normalidade.


     Exemplos:

     Verifica a normalidade de uma população, baseada em uma amostra de
     tamanho 9.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) test_normality(x);
                                 |      SHAPIRO - WILK TEST
                                 |
          (%o3)                  | statistic = .9251055695162436
                                 |
                                 |  p_value = .4361763918860381


 -- Função: simple_linear_regression (<x>)
 -- Função: simple_linear_regression (<x> <opção_1>)
     Regressão linear simples, y_i=a+b x_i+e_i, onde os e_i são
     N(0,sigma) variáveis aleatórias independentes. O argumento <x>
     deve ser uma matriz de duas colunas ou uma lista de pares.

     Opções:

        * `'conflevel', o valor padrão é `95/100', nível de confidência
          para o intervalo de confidência; isso deve ser uma expressão
          que tome valores em (0,1).

        * `'regressor', o valor padrão é `'x', nome da variável
          independente.


     A saída da função `simple_linear_regression' é um objeto
     `inference_result' do Maxima com os seguintes resultados:

       1. `'model': a equação ajustada. Útil para fazer novas
          previsões. Veja exemplos abaixo.

       2. `'means': média de duas variáveis pseudo-aleatórias.

       3. `'variances': variâncias de ambas as variáveis.

       4. `'correlation': coeficiente de correlação.

       5. `'adc': coeficiente de determinação ajustado.

       6. `'a_estimation': estimador do parâmetro <a>.

       7. `'a_conf_int': intervalo de confidência do parâmetro <a>.

       8. `'b_estimation': estimador do parâmetro <b>.

       9. `'b_conf_int': intervalo de confidência do parâmetro <b>.

      10. `'hypotheses': a hipótese do nulo e a hipótese alternativa
          sobre o parâmetro <b>.

      11. `'statistic': valor da amostra estatística usado para testar
          a hipótese do nulo.

      12. `'distribution': distribuição da amostra estatística,
          juntamente com seu parâmetro.

      13. `'p_value': o valor de p do teste sobre <b>.

      14. `'v_estimation': estimador de variância imparcial, ou
          variância residual.

      15. `'v_conf_int': intervalo de confidência da variância.

      16. `'cond_mean_conf_int': intervalo de confidência paa a média
          condicionada. Veja exemplos abaixo.

      17. `'new_pred_conf_int': intervalo de confidência para uma nova
          previsão. Veja exemplos abaixo.

      18. `'residuals': lista de pares (previsão, resíduo), ordenados
          em relação às previsões.  Útil para achar o melhor da análise
          de ajuste. Veja exemplos abaixo.


     Somente os itens 1, 4, 14, 9, 10, 11, 12, e 13 acima, nessa ordem,
     são mostrados por padrão. Os restantes escondem-se até que o
     usuário faça uso de funções `items_inference' e `take_inference'.

     Exemplo:

     Ajustando um modelo linear para uma amostras de duas variáveis. A
     entrada `%i4' monta p gráfico da amostra junto com a linha de
     regressão; a entrada `%i5' calcula `y' dado `x=113'; a média e o
     intervalo de confidência para uma nova previsão quando `x=113' são
     também calculados.

          (%i1) load("stats")$
          (%i2) s:[[125,140.7],[130,155.1],[135,160.3],[140,167.2],[145,169.8]]$
          (%i3) z:simple_linear_regression(s,conflevel=0.99);
                     |               SIMPLE LINEAR REGRESSION
                     |
                     |   model = 1.405999999999985 x - 31.18999999999804
                     |
                     |           correlation = .9611685255255155
                     |
                     |           v_estimation = 13.57966666666665
                     |
          (%o3)      | b_conf_int = [.04469633662525263, 2.767303663374718]
                     |
                     |          hypotheses = H0: b = 0 ,H1: b # 0
                     |
                     |            statistic = 6.032686683658114
                     |
                     |            distribution = [student_t, 3]
                     |
                     |             p_value = 0.0038059549413203
          (%i4) plot2d([[discrete, s], take_inference(model,z)],
                        [x,120,150],
                        [gnuplot_curve_styles, ["with points","with lines"]] )$
          (%i5) take_inference(model,z), x=133;
          (%o5)                         155.808
          (%i6) take_inference(means,z);
          (%o6)                     [135.0, 158.62]
          (%i7) take_inference(new_pred_conf_int,z), x=133;
          (%o7)              [132.0728595995113, 179.5431404004887]



File: maxima.info,  Node: Definições para distribuições especiais,  Prev: Definições para stats,  Up: Top

69.4 Definições para distribuições especiais
============================================

 -- Função: pdf_signed_rank (<x>, <n>)
     Função densidade de probabilidade da distribuição exata da
     estatística do rank sinalizado. O argumento <x> é um número real e
     <n> um inteiro positivo.

     Veja também `test_signed_rank'.

 -- Função: cdf_signed_rank (<x>, <n>)
     Função de densidade cumulativa da distribuição exata da
     estatística do rank sinalizado. O argumento <x> é um número real e
     <n> um inteiro positivo.

     Veja também `test_signed_rank'.

 -- Função: pdf_rank_sum (<x>, <n>, <m>)
     Função densidade de probabilidade da distribuição exata da
     estatística do somatório do rank. O argumento <x> é um número real
     e <n> e <m> são ambos inteiros positivos.

     Veja também `test_rank_sum'.

 -- Função: cdf_rank_sum (<x>, <n>, <m>)
     Função de densidade cumulativa da distribuição exata da
     estatística do somatório do rank. O argumento <x> é um número real
     e <n> e <m> são ambos inteiro positivos.

     Veja também `test_rank_sum'.


File: maxima.info,  Node: stirling,  Next: stringproc,  Prev: stats,  Up: Top

70 stirling
***********

* Menu:

* Definições para stirling::


File: maxima.info,  Node: Definições para stirling,  Prev: stirling,  Up: stirling

70.1 Definições para stirling
=============================

 -- Função: stirling (<z>,<n>)
     Substitui `gamma(x)' pela fórmula de Stirling O(1/x^(2n-1)).
     Quando <n> for um inteiro estritamente negativo, sinaliza um erro.

     Referência: Abramowitz & Stegun, " Handbook of mathematical
     functions", 6.1.40.

     Exemplos:
          (%i1) load (stirling)$

          (%i2) stirling(gamma(%alpha+x)/gamma(x),1);
                 1/2 - x             x + %alpha - 1/2
          (%o2) x        (x + %alpha)
                                             1           1
                                      --------------- - ---- - %alpha
                                      12 (x + %alpha)   12 x
                                    %e
          (%i3) taylor(%,x,inf,1);
                              %alpha       2    %alpha
                    %alpha   x       %alpha  - x       %alpha
          (%o3)/T/ x       + -------------------------------- + . . .
                                           2 x
          (%i4) map('factor,%);
                                                 %alpha - 1
                   %alpha   (%alpha - 1) %alpha x
          (%o4)   x       + -------------------------------
                                            2

     A função `stirling' conhece a diferença entre a variável <gamma> e
     a função `gamma':

          (%i5) stirling(gamma + gamma(x),0);
                                              x - 1/2   - x
          (%o5)    gamma + sqrt(2) sqrt(%pi) x        %e
          (%i6) stirling(gamma(y) + gamma(x),0);
                                   y - 1/2   - y
          (%o6) sqrt(2) sqrt(%pi) y        %e
                                                        x - 1/2   - x
                                   + sqrt(2) sqrt(%pi) x        %e

     Para usar essa função escreva primeiro `load("stirling")'.


File: maxima.info,  Node: stringproc,  Next: unit,  Prev: stirling,  Up: Top

71 stringproc
*************

* Menu:

* Introdução a manipulação de seqüências de caracteres::
* Definições para entrada e saída::
* Definições para caracteres::
* Definições para seqüências de caracteres::


File: maxima.info,  Node: Introdução a manipulação de seqüências de caracteres,  Next: Definições para entrada e saída,  Prev: stringproc,  Up: stringproc

71.1 Introdução a manipulação de seqüências de caracteres
=========================================================

O arquivo `stringproc.lisp' amplia a compatibilidade do Maxima de
trabalhar com seqüências de caracteres e adiciona algumas funções úteis
a entrada e saída de dados.

   Para esclarecimentos e erros por favor mande um e-mail para van.nek
at arcor.de .

   Para disponibilizar `stringproc.lisp' para uso digite
`load("stringproc");'.

   No Maxima uma seqüência de caracteres é facilmente contruída
digitando "texto" (qualquer texto desejado entre aspas duplas).  Note
que seqüências de caracteres do Maxima não são seqüências de caracteres
do Lisp e vice-versa.  Testes podem ser concluídos com `stringp' e
`lstringp'.  Se por alguma razão voce tiver um valor, que é uma
seqüência de caracteres do Lisp, talvez quando estiver usando a
função `sconcat' do Maxima, você pode converter via `sunlisp'.

     (%i1) load("stringproc")$
     (%i2) m: "text";
     (%o2)                         text
     (%i3) [stringp(m),lstringp(m)];
     (%o3)                     [true, false]
     (%i4) l: sconcat("text");
     (%o4)                         text
     (%i5) [stringp(l),lstringp(l)];
     (%o5)                     [false, true]
     (%i6) stringp( sunlisp(l) );
     (%o6)                         true

   Todas as funções em `stringproc.lisp', que retornarem seqüências de
caracteres, retornam seqüências de caracteres do Maxima.

   Caracteres são introduzidos como seqüências de caracteres do Maxima
de comprimento 1.  Com certeza, esses caracteres não são caracteres do
Lisp.  Testes podem ser realizados com `charp' ( `lcharp' e conversões
do Lisp para o Maxima com `cunlisp').

     (%i1) load("stringproc")$
     (%i2) c: "e";
     (%o2)                           e
     (%i3) [charp(c),lcharp(c)];
     (%o3)                     [true, false]
     (%i4) supcase(c);
     (%o4)                           E
     (%i5) charp(%);
     (%o5)                         true

   Novamente, todas as funções em `stringproc.lisp', que retornam
caracteres, retornam caracteres do Maxima.  devido a esse fato, que os
caracteres introduzidos são seqüências de caracteres comprimento 1,
você pode usar muitas das funções de seqüência de caracteres também
para caracteres.  Como visto, `supcase' é um exemplo.

   É importante saber, que o primeiro caractere em uma seqüência de
caracteres do Maxima éstá na posição 1.  Isso é designado devido ao
fato de o primeiro elemento em uma lista do Maxima está na posição 1
também.  Veja definições de `charat' e de `charlist' para obter
exemplos.

   Em aplicações fnções de seqüência de caractere são muitas vezes
usadas quando estamos trabalhando com arquivos.  Você encontrará
algumas úteis funções de fluxo e funções de impressões em
`stringproc.lisp'.  O seguinte exemplo mostra algumas das funções aqui
introduzidas no trabalho.

   Exemplo:

   `openw' retorna um fluxo de saída para um arquivo, `printf' então
permite escrita formatada para esse arquivo. Veja `printf' para
detalhes.

     (%i1) load("stringproc")$
     (%i2) s: openw("E:/file.txt");
     (%o2)                    #<output stream E:/file.txt>
     (%i3) for n:0 thru 10 do printf( s, "~d ", fib(n) );
     (%o3)                                done
     (%i4) printf( s, "~%~d ~f ~a ~a ~f ~e ~a~%",
                   42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
     (%o4)                                false
     (%i5) close(s);
     (%o5)                                true

   Após fechar o fluxo você pode abrí-lo novamente, dessa vez com
direção de entrada.  `readline' retorna a linha completa como uma
seqüência de caracteres. O pacote `stringproc' agora oferece muitas
funções para manipulação de seqüências de caracteres. A troca de
indicações/fichas pode ser realizada por `split' ou por `tokens'.

     (%i6) s: openr("E:/file.txt");
     (%o6)                     #<input stream E:/file.txt>
     (%i7) readline(s);
     (%o7)                     0 1 1 2 3 5 8 13 21 34 55
     (%i8) line: readline(s);
     (%o8)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
     (%i9) list: tokens(line);
     (%o9)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
     (%i10) map( parsetoken, list );
     (%o10)           [42, 1.234, false, false, 0.01, 0.01, false]

   `parsetoken' somente analiza números inteiros e em ponto flutuante.
A análise de símbolos ou grandes números em ponto flutuante precisa de
`parse_string', que pode ser disponibilizada para uso através de
`eval_string.lisp'.

     (%i11) load("eval_string")$
     (%i12) map( parse_string, list );
     (%o12)           [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
     (%i13) float(%);
     (%o13) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01, 0.01, 0.01]
     (%i14) readline(s);
     (%o14)                               false
     (%i15) close(s)$

   `readline' retorna `false' quado o fim de arquivo acontecer.


File: maxima.info,  Node: Definições para entrada e saída,  Next: Definições para caracteres,  Prev: Introdução a manipulação de seqüências de caracteres,  Up: stringproc

71.2 Definições para entrada e saída
====================================

Exemplo:

     (%i1) load("stringproc")$
     (%i2) s: openw("E:/file.txt");
     (%o2)                     #<output stream E:/file.txt>
     (%i3) control:
     "~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2tand an integer: ~20t~d~%"$
     (%i4) printf( s,control, 'true,[1,2,3],42 )$
     (%o4)                                false
     (%i5) close(s);
     (%o5)                                true
     (%i6) s: openr("E:/file.txt");
     (%o6)                     #<input stream E:/file.txt>
     (%i7) while stringp( tmp:readline(s) ) do print(tmp)$
       An atom:          true
       and a list:       one two three
       and an integer:   42
     (%i8) close(s)$

 -- Função: close (<fluxo>)
     Fecha  <fluxo> e retorna `true' se <fluxo> tiver sido aberto
     anteriormente.


 -- Função: flength (<fluxo>)
     Retorna o número de elementos em <fluxo>.


 -- Função: fposition (<fluxo>)
 -- Função: fposition (<fluxo>, <pos>)
     Retorna a posição corrente em <fluxo>, se <pos> não está sendo
     usada.  Se <pos> estiver sendo usada, `fposition' escolhe a
     posição em <fluxo>.  <pos> tem que ser um número positivo, o
     primeiro elemento em <fluxo> está na posição 1.


 -- Função: freshline ()
 -- Função: freshline (<fluxo>)
     escreve uma nova linha (em <fluxo>), se a posição atual não for um
     início de linha.  Veja também `newline'.

 -- Função: newline ()
 -- Função: newline (<fluxo>)
     Escreve uma nova linha (para <fluxo>).  Veja `sprint' para um
     exemplo de uso de `newline()'.  Note que existem alguns casos,
     onde `newline()'não trabalha como esperado.


 -- Função: opena (<arquivo>)
     Retorna um fluxo de saída para <arquivo>.  Se um arquivo já
     existente tiver sido aberto, `opena' anexa os elementos ao final
     do arquivo.


 -- Função: openr (<arquivo>)
     Retorna um fluxo para <arquivo>.  Se <arquivo> não existir, ele
     será criado.


 -- Função: openw (<arquivo>)
     Retorna um fluxo de saída para <arquivo>.  Se <arquivo> não
     existir, será criado.  Se um arquivo já existente for aberto,
     `openw' modifica destrutivametne o <arquivo>.


 -- Função: printf (<dest>, <seq_caracte>)
 -- Função: printf (<dest>, <seq_caracte>, <expr_1>, ..., <expr_n>)
     Torna a função FORMAT do Lisp Comum disponível no Maxima.
     (Retirado de gcl.info: "format produces formatted output by
     outputting the caracteres of control-string string and observing
     that a tilde introduces a directive.  The caractere after the
     tilde, possibly preceded by prefix parameters and modifiers,
     specifies what kind of formatting is desired.  Most directives use
     one or more elements of args to create their output.")

     A seguinte descrição e oa exemplos podem fornecer uma idéia de uso
     de `printf'.  Veja um referência de Lisp para maiores
     informações.

             ~%       nova linha
             ~&       novíssima line
             ~t       tabulação
             ~$       monetário
             ~d       inteiro decimal
             ~b       inteiro binário
             ~o       inteiro octal
             ~x       inteiro hexadecimal
             ~br      inteiro de base b
             ~r       soletra um inteiro
             ~p       plural
             ~f       ponto flutuante
             ~e       notação científica
             ~g       ~f ou ~e, dependendo  da magnitude
             ~a       como mostrado pela função print do Maxima
             ~s       seqüências de caracteres entre "aspas duplas"
             ~~       ~
             ~<       justificação de texto, ~> terminador de justificação de texto
             ~(       conversão de caixa alta/baixa, ~) terminador de conversão de caixa
             ~[       seleção, ~] terminador de seleção
             ~{       iteração, ~} terminador de iteração

     Por favor note que não existe especificador de formato para
     grandes números em ponto flutuante. Todavia grandes números em
     ponto flutuante podem simplesmente serem mostrados por meio da
     diretiva `~a'.  `~s' mostra a seqüências de caracteres entre
     "aspas duplas", você pode evitar isso usando `~a'.  Note que a
     diretiva de seleção `~[' é indexada em zero.  Também note que
     existem algumas diretivas, que não trabalham no Maxima.  Por
     exemplo, `~:[' falha.

          (%i1) load("stringproc")$
          (%i2) printf( false, "~a ~a ~4f ~a ~@r",
                        "String",sym,bound,sqrt(12),144), bound = 1.234;
          (%o2)                 String sym 1.23 2*sqrt(3) CXLIV
          (%i3) printf( false,"~{~a ~}",["one",2,"THREE"] );
          (%o3)                          one 2 THREE
          (%i4) printf( true,"~{~{~9,1f ~}~%~}",mat ),
                        mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
                1.1       2.0       3.3
                4.0       5.0       6.0
                7.0       8.9       9.0
          (%i5) control: "~:(~r~) bird~p ~[is~;are~] singing."$
          (%i6) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
          (%o6)                    Two birds are singing.

     Se <dest> for um fluxo ou `true', então `printf' retorna `false'.
     De outra forma, `printf' retorna uma seqüência de caracteres
     contendo a saída.


 -- Função: readline (<fluxo>)
     Retorna uma seqüência de caracteres contendo os caracteres a
     partir da posição corrente em <fluxo> até o fim de linha ou
     <false> se o fim de linha do arquivo for encontrado.


 -- Função: sprint (<expr_1>, ..., <expr_n>)
     Avalia e mostra seus argumentos um após o outro `sobre uma linha'
     iniciando na posição mais à esquerda.  Os números são mostrados
     com o '-' à direita do número, e isso desconsidera o comprimento
     da linha. `newline()', que pode ser chamada a partir de
     `stringproc.lisp' pode ser útil, se você desejar colocar uma
     parada de linha intermediária.

          (%i1) for n:0 thru 22 do sprint( fib(n) )$
          0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711
          (%i2) load("stringproc")$
          (%i3) for n:0 thru 22 do (
                   sprint(fib(n)), if mod(n,10)=9 then newline() )$
          0 1 1 2 3 5 8 13 21 34
          55 89 144 233 377 610 987 1597 2584 4181
          6765 10946 17711



File: maxima.info,  Node: Definições para caracteres,  Next: Definições para seqüências de caracteres,  Prev: Definições para entrada e saída,  Up: stringproc

71.3 Definições para caracteres
===============================

 -- Função: alphacharp (<caractere>)
     Retorna `true' se <caractere> for um caractere alfabético.


 -- Função: alphanumericp (<caractere>)
     Retorna `true' se <caractere> for um caractere alfabético ou um
     dígito.


 -- Função: ascii (<int>)
     Retorna o caractere correspondente ao código numérico ASCII <int>.
     ( -1 < int < 256 )

          (%i1) load("stringproc")$
          (%i2) for n from 0 thru 255 do (
          tmp: ascii(n), if alphacharp(tmp) then sprint(tmp), if n=96 then newline() )$
          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
          a b c d e f g h i j k l m n o p q r s t u v w x y z


 -- Função: cequal (<caractere_1>, <caractere_2>)
     Retorna `true' se <caractere_1> e <caractere_2> forem os mesmos.


 -- Função: cequalignore (<caractere_1>, <caractere_2>)
     como `cequal' mas ignora a caixa alta/baixa.


 -- Função: cgreaterp (<caractere_1>, <caractere_2>)
     Retorna `true' se o código numérico ASCII do <caractere_1> for
     maior que o código numérico ASCII do <caractere_2>.


 -- Função: cgreaterpignore (<caractere_1>, <caractere_2>)
     Como `cgreaterp' mas ignora a caixa alta/baixa.


 -- Função: charp (<obj>)
     Retorna `true' se <obj> for um caractere do Maxima.  Veja na
     seção "Introdução a manipulação de seqüências de caracteres" para
     ter um exemplo.


 -- Função: cint (<caractere>)
     Retorna o código numéico ASCII de <caractere>.


 -- Função: clessp (<caractere_1>, <caractere_2>)
     Retorna `true' se o código numérico ASCII de <caractere_1> for
     menor que o código numérico ASCII de <caractere_2>.


 -- Função: clesspignore (<caractere_1>, <caractere_2>)
     Como em `clessp' ignora a caixa alta/baixa.


 -- Função: constituent (<caractere>)
     Retorna `true' se <caractere> for caractere  gráfico e não o
     caractere de espaço em branco.  Um caractere gráfico é um
     caractere que se pode ver, adicionado o caractere de espaço em
     branco.  (`constituent' foi definida por Paul Graham, em ANSI
     Common Lisp, 1996, página 67.)

          (%i1) load("stringproc")$
          (%i2) for n from 0 thru 255 do (
          tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
          ! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B
          C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
          d e f g h i j k l m n o p q r s t u v w x y z { | } ~


 -- Função: cunlisp (<lisp_char>)
     Converte um caractere do Lisp em um caractere do Maxima.  (Você
     pode não precisar dessa função.)


 -- Função: digitcharp (<caractere>)
     Retorna `true' se <caractere> for um dígito (algarismo de 0 a 9).


 -- Função: lcharp (<obj>)
     Retorna `true' se <obj> for um caractere do Lisp.  (Você pode não
     precisar dessa função.)


 -- Função: lowercasep (<caractere>)
     Retorna `true' se <caractere> for um caractere em caixa baixa.


 -- Variable: newline
     O caractere de nova linha.


 -- Variável: space
     O caractere de espaço em branco.


 -- Variável: tab
     O caractere de tabulação.


 -- Função: uppercasep (<caractere>)
     Retorna `true' se <caractere> for um caractere em caixa alta.



File: maxima.info,  Node: Definições para seqüências de caracteres,  Prev: Definições para caracteres,  Up: stringproc

71.4 Definições para seqüências de caracteres
=============================================

 -- Função: sunlisp (<lisp_string>)
     Converte uma seqüência de caracteres do Lisp em uma seqüência de
     caracteres do Maxima.  (Em geral você pode não precisar dessa
     função.)


 -- Função: lstringp (<obj>)
     Retorna `true' se <obj> is uma seqüência de caracteres do Lisp.
     (Em geral você pode não precisar dessa função.)


 -- Função: stringp (<obj>)
     Retorna `true' se <obj> for uma seqüência de caracteres do Maxima.
     Veja a introdução para obter exemplos.


 -- Função: charat (<seq_caracte>, <n>)
     Retorna o <n>-ésimo caractere de <seq_caracte>.  O primeiro
     caractere em <seq_caracte> é retornado com <n> = 1.

          (%i1) load("stringproc")$
          (%i2) charat("Lisp",1);
          (%o2)                           L


 -- Função: charlist (<seq_caracte>)
     Retorna a lsita de todos os caracteres em <seq_caracte>.

          (%i1) load("stringproc")$
          (%i2) charlist("Lisp");
          (%o2)                     [L, i, s, p]
          (%i3) %[1];
          (%o3)                           L


 -- Função: parsetoken (<seq_caracte>)
     `parsetoken' converte a primeira ficha em <seq_caracte> para o
     correspondente número ou retorna `false' se o número não puder ser
     determinado.  O conjunto de delimitadores para a troca de fichas é
     `{space, comma, semicolon, tab, newline}'

     Nota de tradução: espaço, vírgula, ponto e vírgula, tabulação e
     nova linha.

          (%i1) load("stringproc")$
          (%i2) 2*parsetoken("1.234 5.678");
          (%o2)                         2.468

     Para analizar você pode também usar  a função `parse_string'.
     Veja a descrição no arquivo 'share\contrib\eval_string.lisp'.


 -- Função: sconc (<expr_1>, ..., <expr_n>)
     Avalia seus argumentos e concatena-os em uma seqüência de
     caracteres.  `sconc' é como `sconcat' mas retorna uma seqüência de
     caracteres do Maxima.

          (%i1) load("stringproc")$
          (%i2) sconc("xx[",3,"]:",expand((x+y)^3));
          (%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i3) stringp(%);
          (%o3)                         true


 -- Função: scopy (<seq_caracte>)
     Retorna uma cópia de <seq_caracte> como uma nova seqüência de
     caracteres.


 -- Função: sdowncase (<seq_caracte>)
 -- Função: sdowncase (<seq_caracte>, <início>)
 -- Função: sdowncase (<seq_caracte>, <início>, <fim>)
     Como em `supcase', mas caracteres em caixa alta são convertidos
     para caracteres em caixa baixa.


 -- Função: sequal (<seq_caracte__1>, <seq_caracte__2>)
     Retorna `true' se <seq_caracte__1> e <seq_caracte__2> tiverem o
     mesmo comprimento e contiverem os mesmos caracteres.


 -- Função: sequalignore (<seq_caracte__1>, <seq_caracte__2>)
     Como em `sequal' mas igonara a caixa alta/baixa.


 -- Função: sexplode (<seq_caracte>)
     `sexplode' é um apelido para a função `charlist'.


 -- Função: simplode (<lista>)
 -- Função: simplode (<lista>, <delim>)
     `simplode' takes uma `lista' ou expressões  e concatena-as em uma
     seqüência de caracteres.  Se nenhum delimitador <delim> for usado,
     `simplode' funciona como `sconc' e não utiliza delimitador.
     <delim> pode ser qualquer seqüência de caracteres.

          (%i1) load("stringproc")$
          (%i2) simplode(["xx[",3,"]:",expand((x+y)^3)]);
          (%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i3) simplode( sexplode("stars")," * " );
          (%o3)                   s * t * a * r * s
          (%i4) simplode( ["One","more","coffee."]," " );
          (%o4)                   One more coffee.


 -- Função: sinsert (<seq>, <seq_caracte>, <pos>)
     Retorna uma seqüência de caracteres que é uma concatenação de
     `substring (<seq_caracte>, 1, <pos> - 1)', a seqüência de
     caracteres <seq> e `substring (<seq_caracte>, <pos>)'.  Note que o
     primeiro caractere está em <seq_caracte> e está na posição 1.

          (%i1) load("stringproc")$
          (%i2) s: "A submarine."$
          (%i3) sconc( substring(s,1,3),"yellow ",substring(s,3) );
          (%o3)                  A yellow submarine.
          (%i4) sinsert("hollow ",s,3);
          (%o4)                  A hollow submarine.


 -- Função: sinvertcase (<seq_caracte>)
 -- Função: sinvertcase (<seq_caracte>, <início>)
 -- Função: sinvertcase (<seq_caracte>, <início>, <fim>)
     Retorna <seq_caracte> exceto que cada caractere da posição
     <início> até a posição <fim> está invertido.  Se a posição <fim>
     não for fornecida, todos os caracteres do início ao <fim> de
     <seq_caracte> são substituídos.

          (%i1) load("stringproc")$
          (%i2) sinvertcase("sInvertCase");
          (%o2)                      SiNVERTcASE


 -- Função: slength (<seq_caracte>)
     Retorna número de caracteres em <seq_caracte>.


 -- Função: smake (<num>, <caractere>)
     Retorna uma nova seqüência de caracteres repetindo <num> vezes
     <caractere>.

          (%i1) load("stringproc")$
          (%i2) smake(3,"w");
          (%o2)                          www


 -- Função: smismatch (<seq_caracte__1>, <seq_caracte__2>)
 -- Função: smismatch (<seq_caracte__1>, <seq_caracte__2>, <test>)
     Retorna a posição do primeiro caractere de <seq_caracte__1> no
     qual <seq_caracte__1> e <seq_caracte__2> diferem ou `false' em
     caso contrário.  A função padrao de teste para coincidência é
     `sequal'.  Se `smismatch' pode ignorar a caixa alta/baixa, use
     `sequalignore' como função de teste.

          (%i1) load("stringproc")$
          (%i2) smismatch("seven","seventh");
          (%o2)                           6


 -- Função: split (<seq_caracte>)
 -- Função: split (<seq_caracte>, <delim>)
 -- Função: split (<seq_caracte>, <delim>, <multiple>)
     Retorna a lista de todas as fichas em <seq_caracte>.  Cada ficha é
     uma seqüência de caracteres não analisada.  `split' usa <delim>
     como delimitador.  Se <delim> não for fornecido, o caractere de
     espaço é o delimitador padrão.  <multiple> é uma variável booleana
     com `true' como valor padrão.  Multiplos delimitadores são lidos
     como um.  Essa função é útil se tabulações são gravadas com
     caracteres de espaço multiplos.  Se <multiple> for escolhido para
     `false', cada delimitador é considerado.

          (%i1) load("stringproc")$
          (%i2) split("1.2   2.3   3.4   4.5");
          (%o2)                 [1.2, 2.3, 3.4, 4.5]
          (%i3) split("first;;third;fourth",";",false);
          (%o3)               [first, , third, fourth]


 -- Função: sposition (<caractere>, <seq_caracte>)
     Retorna a posição do primeiro caractere em <seq_caracte> que
     coincide com <caractere>.  O primeiro caractere em <seq_caracte>
     está na posição 1.  Para que os caracteres que coincidirem
     desconsiderem a caixa alta/baixa veja `ssearch'.


 -- Função: sremove (<seq>, <seq_caracte>)
 -- Função: sremove (<seq>, <seq_caracte>, <test>)
 -- Função: sremove (<seq>, <seq_caracte>, <test>, <início>)
 -- Função: sremove (<seq>, <seq_caracte>, <test>, <início>, <fim>)
     Retorna uma seqüência de caracteres como <seq_caracte> mas com
     todas as subseqüências de caracteres que coincidirem com <seq>.  A
     função padrão de teste de coincidência é `sequal'.  Se `sremove'
     puder ignorar a caixa alta/baixa enquanto busca por <seq>, use
     `sequalignore' como teste.  Use <início> e <fim> para limitar a
     busca.  Note que o primeiro caractere em <seq_caracte> está na
     posição 1.

          (%i1) load("stringproc")$
          (%i2) sremove("n't","I don't like coffee.");
          (%o2)                   I do like coffee.
          (%i3) sremove ("DO ",%,'sequalignore);
          (%o3)                    I like coffee.


 -- Função: sremovefirst (<seq>, <seq_caracte>)
 -- Função: sremovefirst (<seq>, <seq_caracte>, <test>)
 -- Função: sremovefirst (<seq>, <seq_caracte>, <test>, <início>)
 -- Função: sremovefirst (<seq>, <seq_caracte>, <test>, <início>, <fim>)
     Como em `sremove' exceto qie a primeira subseqüência de caracteres
     que coincide com `seq' é removida.


 -- Função: sreverse (<seq_caracte>)
     Retorna uma seqüência de caracteres com todos os caracteres de
     <seq_caracte> em ordem reversa.


 -- Função: ssearch (<seq>, <seq_caracte>)
 -- Função: ssearch (<seq>, <seq_caracte>, <test>)
 -- Função: ssearch (<seq>, <seq_caracte>, <test>, <início>)
 -- Função: ssearch (<seq>, <seq_caracte>, <test>, <início>, <fim>)
     Retorna a posição da primeira subseqüência de caracteres de
     <seq_caracte> que coincide com a seqüência de caracteres <seq>.  A
     função padrão de teste de coincidência é `sequal'.  Se `ssearch'
     puder igonorar a caixa alta/baixa, use `sequalignore' como
     função de teste.  Use <início> e <fim> para limitar a busca.  Note
     que o primeiro caractere em <seq_caracte> está na posição 1.

          (%i1) ssearch("~s","~{~S ~}~%",'sequalignore);
          (%o1)                                  4


 -- Função: ssort (<seq_caracte>)
 -- Função: ssort (<seq_caracte>, <test>)
     Retorna uma seqüência de caracteres que contém todos os caracteres
     de <seq_caracte> em uma ordem tal que não existam dois caracteres
     <c> sucessivos e <d> seja tal que `test (<c>, <d>)' seja `false' e
     `test (<d>, <c>)' seja `true'.  A função padrão de teste para
     ordenaçào é <clessp>.  O conjunto de funções de teste é `{clessp,
     clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore}'.

          (%i1) load("stringproc")$
          (%i2) ssort("I don't like Mondays.");
          (%o2)                    '.IMaddeiklnnoosty
          (%i3) ssort("I don't like Mondays.",'cgreaterpignore);
          (%o3)                 ytsoonnMlkIiedda.'


 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>)
 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>, <test>)
 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>, <test>, <início>)
 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>, <test>, <início>,
          <fim>)
     Retorna uma seqüência de caracteres como <seq_caracte> exceto que
     todas as subseqüências de caracteres que coincidirem com <antiga>
     são substituídas por <nova>.  <antiga> e <nova> não precisam ser
     de mesmo comprimento.  A função padrão de teste para coincidência
     é para coincidências é `sequal'.  Se `ssubst' puder ignorar a cixa
     alta/baixa enquanto procurando por <antiga>, use `sequalignore'
     como função de teste.  Use <início> e <fim> para limitar a busca.
     Note que o primeiro caractere em <seq_caracte> está na posição 1.

          (%i1) load("stringproc")$
          (%i2) ssubst("like","hate","I hate Thai food. I hate green tea.");
          (%o2)          I like Thai food. I like green tea.
          (%i3) ssubst("Indian","thai",%,'sequalignore,8,12);
          (%o3)         I like Indian food. I like green tea.


 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>)
 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>, <test>)
 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>, <test>,
          <início>)
 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>, <test>,
          <início>, <fim>)
     Como em `subst' exceto que somente a primeira subseqüência de
     caracteres que coincidir com <antiga> é substituída.


 -- Função: strim (<seq>,<seq_caracte>)
     Retorna uma seqüência de caracteres como <seq_caracte>, mas com
     todos os caracteres que aparecerem em <seq> removidos de ambas as
     extremidades.

          (%i1) load("stringproc")$
          (%i2) "/* comment */"$
          (%i3) strim(" /*",%);
          (%o3)                        comment
          (%i4) slength(%);
          (%o4)                           7


 -- Função: striml (<seq>, <seq_caracte>)
     Como em `strim' exceto que somente a extremidade esquerda de
     <seq_caracte> é recordada.


 -- Função: strimr (<seq>, <seq_caracte>)
     Como em `strim' exceto que somente a extremidade direita de
     seqüência de caracteres é recortada.


 -- Função: substring (<seq_caracte>, <início>)
 -- Função: substring (<seq_caracte>, <início>, <fim>)
     Retorna a subseqüência de caracteres de <seq_caracte> começando na
     posição <início> e terminando na posição <fim>.  O caractere na
     posição <fim> não é incluído.  Se <fim> não for fornecido, a
     subseqüência de caracteres contém o restante da seqüência de
     caracteres.  Note que o primeiro caractere em <seq_caracte> está
     na posição 1.

          (%i1) load("stringproc")$
          (%i2) substring("substring",4);
          (%o2)                        string
          (%i3) substring(%,4,6);
          (%o3)                          in


 -- Função: supcase (<seq_caracte>)
 -- Função: supcase (<seq_caracte>, <início>)
 -- Função: supcase (<seq_caracte>, <início>, <fim>)
     Retorna <seq_caracte> exceto que caracteres em caixa baixa a
     partir da posição <início> até a posição <fim> são substituídos
     pelo correspondente caracteres em cixa alta.  Se <fim> não for
     fornecido, todos os caracteres em caixa baixa de <início> até o
     fim de <seq_caracte> são substituídos.

          (%i1) load("stringproc")$
          (%i2) supcase("english",1,2);
          (%o2)                        English


 -- Função: tokens (<seq_caracte>)
 -- Função: tokens (<seq_caracte>, <test>)
     Retorna uma lista de fichas, que tiverem sido extrídos de
     <seq_caracte>.  As fichas são subseqüências de caracteres cujos
     caracteres satisfazem a uma determinada função de teste.  Se o
     teste não for fornecido, <constituent> é usada como teste padrão.
     `{constituent, alphacharp, digitcharp, lowercasep, uppercasep,
     charp, characterp, alphanumericp}' é o conjunto de fnções de teste.
     (A verão Lisp de `tokens' é escrita por Paul Graham. ANSI Common
     Lisp, 1996, page 67.)

          (%i1) load("stringproc")$
          (%i2) tokens("24 October 2005");
          (%o2)                  [24, October, 2005]
          (%i3) tokens("05-10-24",'digitcharp);
          (%o3)                     [05, 10, 24]
          (%i4) map(parsetoken,%);
          (%o4)                      [5, 10, 24]



File: maxima.info,  Node: unit,  Next: zeilberger,  Prev: stringproc,  Up: Top

72 unit
*******

* Menu:

* Introdução a Units::
* Definições para Units::


File: maxima.info,  Node: Introdução a Units,  Next: Definições para Units,  Prev: unit,  Up: unit

72.1 Introdução a Units
=======================

O pacote _unit_ torna o usuário apto a converter entre unidades
arbitrárias e trabalhar com dimensões em equações. O funcionamento
desse pacote é radicalmente diferente do pacote original units do
Maxima - apesar de o original conter uma lista básica de definições, o
pacote atual usa um conjunto de regras para permitir ao usuário
escolher, sobre uma base dimensional, qual a resposta fianl de unidade
pode ser convertida.  Isso irá separar unidades em lugar de misturá-las
na tela, permitindo ao usuário durante a leitura identificar as
unidades associadas com uma resposta em particular.  Isso permitirá ao
usuário simplificar uma expressão em sua Base fundamental de Unidades,
bem como fornecer ajuste fino sobre a simplificação de unidades
derivadas.  Análise dimensional é possível, e uma variedade de
ferramentas está disponível para gerenciar a conversão e também uma
variedade de opções de simplificação. Adicionalmente para personalizar
conversão automática, _units_ também fornede um manual tradicional de
opções de conversão.

   Nota -quando conversões de unidade forem não exatas Maxima irá fazer
aproximações resultando em frações. Esso é uma conceqüência das
técnicas usadas para simplificar unidades.  A mensagem de alerta desse
tipo de substituição está desabilitada por padrão no caso de inidades
(normalmente essas mensagens estão habilitadas) uma vez que essa
situação de iemissão de mensagens de alerta ocorre freqüêntemente e os
alertas confundem a saída.  (O estado atual de `ratprint' é
restabelecido após uma conversão de unidades, de forma que
modificações de usuário para aquela configuração irão ser preservadas
de outra forma.)  Se o usuário precisar dessa informação para `units',
ele pode escolher _unitverbose:on_ para reativar a impressão de
mensagens de alerta do processo de conversão.

   _unit_ está inclído no Maxima no diretório share/contrib/unit
directory. Isso segue aos pacotes normais do Maxima conforme
convenções:

     (%i1) load("unit")$
     *******************************************************************
     *                       Units version 0.50                        *
     *          Definitions based on the NIST Reference on             *
     *              Constants, Units, and Uncertainty                  *
     *       Conversion factors from various sources including         *
     *                   NIST and the GNU units package                *
     *******************************************************************

     Redefining necessary functions...
     WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
     WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
     WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
     WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
     Initializing unit arrays...
     Done.

   As mensagens WARNING (DE ALERTA) são esperadas n ão uma causa de
preocupação - elas indicam que o pacote _unit_ está redefinindo
funções anteriormente definidas no local adequado do Maxima.  Essa
redefinição é necessária com o bojetivo de manusear adequadamente as
unidades.  O usuário pode estar consciente que se outras modificações
tiverem sido feitas para essas funções por outros pacotes essas novas
mudanças irão ser sobrescritas por meio desse processo de
disponibilização do pacote `unit'.

   O arquivo _unit.mac_ também chama um arquivo lisp, a saber
_unit-functions.lisp_, que contém as funçãoes lisp necessárias ao
pacote.

   Clifford Yapp é o autor primário.  Ele recebeu grande
contribuição de Barton Willis da University of Nebraska at Kearney
(UNK), Robert Dodier, e da intrépida tribo da lista de mensagens do
Maxima.

   Existem provavelmente muitos erros.  Diga-me quais.  `float' e
`numer' não fazem o que é esperado.

   PORFAZER : funcionalidade de dimensão, manuseio de temperatura, a
função `showabbr' e Cia. Ltda.  Mostrar exemplos com adição de
quantidades contendo unidades.


File: maxima.info,  Node: Definições para Units,  Prev: Introdução a Units,  Up: unit

72.2 Definições para Units
==========================

 -- Função: setunits (<list>)
     Por padrão, o pacote _unit_ não usa qualquer dimensões derivadas,
     mas irá converter todas as unidades nas sete fundamentais do
     sistema MKS.
          (%i2) N;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) dyn;
                                             1      kg m
          (%o3)                           (------) (----)
                                           100000     2
                                                     s
          (%i4) g;
                                              1
          (%o4)                             (----) (kg)
                                             1000
          (%i5) centigram*inch/minutes^2;
                                            127        kg m
          (%o5)                       (-------------) (----)
                                       1800000000000     2
                                                        s

     Em alguns casos esse é o comportamento desejado.  Se o usuário
     desejar usar outras unidades, isso é conseguido com o comando
     `setunits':
          (%i6) setunits([centigram,inch,minute]);
          (%o6)                                done
          (%i7) N;
                                      1800000000000   %in cg
          (%o7)                      (-------------) (------)
                                           127            2
                                                      %min
          (%i8) dyn;
                                         18000000   %in cg
          (%o8)                         (--------) (------)
                                           127          2
                                                    %min
          (%i9) g;
          (%o9)                             (100) (cg)
          (%i10) centigram*inch/minutes^2;
                                              %in cg
          (%o10)                              ------
                                                  2
                                              %min

     A escolha de unidades é completamente flexível.  Por exemplo, se
     quisermos voltar para quiilogramas, metros, e segundos como padrão
     para essas dimensão nós podemos fazer:
          (%i11) setunits([kg,m,s]);
          (%o11)                               done
          (%i12) centigram*inch/minutes^2;
                                            127        kg m
          (%o12)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     Unidade derivadas são também manuseáveis por meio desse comando:
          (%i17) setunits(N);
          (%o17)                               done
          (%i18) N;
          (%o18)                                 N
          (%i19) dyn;
                                              1
          (%o19)                           (------) (N)
                                            100000
          (%i20) kg*m/s^2;
          (%o20)                                 N
          (%i21) centigram*inch/minutes^2;
                                              127
          (%o21)                        (-------------) (N)
                                         1800000000000

     Note que o pacote _unit_ reconhece a combinação não MKS de massa,
     comprimento, e tempo inverso elevado ao quadrado como uma
     força, e converte isso para Newtons.  É dessa forma que Maxima
     trabalha geralmente.  Se, por exemplo, nós preferirmos dinas em
     lugar de Newtons, simplesmente fazemos o seguinte:
          (%i22) setunits(dyn);
          (%o22)                               done
          (%i23) kg*m/s^2;
          (%o23)                          (100000) (dyn)
          (%i24) centigram*inch/minutes^2;
                                            127
          (%o24)                         (--------) (dyn)
                                          18000000

     Para descontinuar simplificando para qualquer unidade de força,
     usamos o comando `uforget':
          (%i26) uforget(dyn);
          (%o26)                               false
          (%i27) kg*m/s^2;
                                               kg m
          (%o27)                               ----
                                                 2
                                                s
          (%i28) centigram*inch/minutes^2;
                                            127        kg m
          (%o28)                      (-------------) (----)
                                       1800000000000     2
                                                        s
     Isso pode trabalhar igualmente bem com `uforget(N)' ou
     `uforget(%force)'.

     Veja também `uforget'. Para usar essa função escreva primeiro
     `load("unit")'.

 -- Função: uforget (<list>)
     Por padrão, o pacote _unit_ converte todas as unidades para as
     sete unidaes fundamentais do sitema MKS de unidades. Ess
     comportamento pode ser mudado com o comando `setunits'. Após o
     qual, o usuário pode restabelecer o comportamento padrão para uma
     dimensão em particular mediante o comando `uforget':
          (%i13) setunits([centigram,inch,minute]);
          (%o13)                               done
          (%i14) centigram*inch/minutes^2;
                                              %in cg
          (%o14)                              ------
                                                  2
                                              %min
          (%i15) uforget([cg,%in,%min]);
          (%o15)                      [false, false, false]
          (%i16) centigram*inch/minutes^2;
                                            127        kg m
          (%o16)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     `uforget' opera sobre dimensões, não sobre unidades, de forma que
     qualquer unidade de uma dimensão em particular irá trabalhar.  A
     própia dimensão é também um argumento legal.

     Veja também `setunits'. To use this function write first
     `load("unit")'.

 -- Função: convert (<expr>, <list>)
     Quando do restabelecimento dos valores padrão o ambiente global é
     destruído, existe o comando `convert', que permite conversões
     imediatas.  `convert' pode aceitar  um argumetno simples ou uma
     lista de unidades a serem usadas na conversão.  Quando uma
     operação de conversão for concluída, o sistema normal de
     avaliação global é contornado, com o objetivo de evitar que o
     resultado desejado seja convertido novamente.  Como conseqüência,
     em cálculos aproximados alertas de "rat" irão ser visíveis se o
     ambiente global que controla esse comportamento (`ratprint') for
     `true'.  `convert' também é útil para uma verificação pontual e
     imediata da precisão de uma conversão global.  Outro recurso é que
     `convert' irá permitir a um usuário fazer um Base de Conversões
     Dimensionais mesmo se o ambiente global for escolhido para
     simplificar par uma Dimensão Derivada.

          (%i2) kg*m/s^2;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) convert(kg*m/s^2,[g,km,s]);
                                               g km
          (%o3)                                ----
                                                 2
                                                s
          (%i4) convert(kg*m/s^2,[g,inch,minute]);

          `rat' replaced 39.37007874015748 by 5000//127 = 39.37007874015748
                                        18000000000   %in g
          (%o4)                        (-----------) (-----)
                                            127           2
                                                      %min
          (%i5) convert(kg*m/s^2,[N]);
          (%o5)                                  N
          (%i6) convert(kg*m^2/s^2,[N]);
          (%o6)                                 m N
          (%i7) setunits([N,J]);
          (%o7)                                done
          (%i8) convert(kg*m^2/s^2,[N]);
          (%o8)                                 m N
          (%i9) convert(kg*m^2/s^2,[N,inch]);

          `rat' replaced 39.37007874015748 by 5000//127 = 39.37007874015748
                                           5000
          (%o9)                           (----) (%in N)
                                           127
          (%i10) convert(kg*m^2/s^2,[J]);
          (%o10)                                 J
          (%i11) kg*m^2/s^2;
          (%o11)                                 J
          (%i12) setunits([g,inch,s]);
          (%o12)                               done
          (%i13) kg*m/s^2;
          (%o13)                                 N
          (%i14) uforget(N);
          (%o14)                               false
          (%i15) kg*m/s^2;
                                          5000000   %in g
          (%o15)                         (-------) (-----)
                                            127       2
                                                     s
          (%i16) convert(kg*m/s^2,[g,inch,s]);

          `rat' replaced 39.37007874015748 by 5000//127 = 39.37007874015748
                                          5000000   %in g
          (%o16)                         (-------) (-----)
                                            127       2
                                                     s

     Veja também `setunits' e `uforget'. Para usar essa função
     primeiramente escreva `load("unit")'.

 -- Variável de opção: usersetunits
     Valor padrão: none

     Se um usuário desejar ter um comportamento padrão de unidade
     diferente daquele descrito, ele pode fazer uso de
     _maxima-init.mac_ e da variável _usersetunits_.  O pacote _unit_
     irá verificar o arquivo _maxima-init.mac_ na inicialização para
     ver se a essa variável foi atribuído uma lista.  Se isso
     aconteceu, o pacote _unit_ irá usar `setunits' sobre aquela lista
     e pegar as unidades lá colocadas para serem as padrões.  `uforget'
     irá reverter para o comportamento definido por `usersetunits'
     sobrescrevendo seus próprios padrões.  Por exemplo, Se tivermos um
     arquivo _maxima-init.mac_ contendo:
          usersetunits : [N,J];
     nós poderemos ver o seguinte comportamento:
          (%i1) load("unit")$
          *******************************************************************
          *                       Units version 0.50                        *
          *          Definitions based on the NIST Reference on             *
          *              Constants, Units, and Uncertainty                  *
          *       Conversion factors from various sources including         *
          *                   NIST and the GNU units package                *
          *******************************************************************

          Redefining necessary functions...
          WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
          WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
          WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
          WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
          Initializing unit arrays...
          Done.
          User defaults found...
          User defaults initialized.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) kg*m^3/s^2;
          (%o4)                                 J m
          (%i5) kg*m*km/s^2;
          (%o5)                             (1000) (J)
          (%i6) setunits([dyn,eV]);
          (%o6)                                done
          (%i7) kg*m/s^2;
          (%o7)                           (100000) (dyn)
          (%i8) kg*m^2/s^2;
          (%o8)                     (6241509596477042688) (eV)
          (%i9) kg*m^3/s^2;
          (%o9)                    (6241509596477042688) (eV m)
          (%i10) kg*m*km/s^2;
          (%o10)                   (6241509596477042688000) (eV)
          (%i11) uforget([dyn,eV]);
          (%o11)                           [false, false]
          (%i12) kg*m/s^2;
          (%o12)                                 N
          (%i13) kg*m^2/s^2;
          (%o13)                                 J
          (%i14) kg*m^3/s^2;
          (%o14)                                J m
          (%i15) kg*m*km/s^2;
          (%o15)                            (1000) (J)
     Sem `usersetunits', as entradas iniciais poderiam ter sido
     convertidas para o sistema de unidades MKS, e `uforget' poderia
     ter resultado em um retorno para as regras do MKS.  Em vez disso,
     as preferências do usuário foram respeitadas em ambos os casos.
     Note que esse podem ainda serem sobrescritos se for desejado.
     Para eliminar completamente essa simplificação - i.e.  ter as
     preferências de usuário escolhidas para os padrões de unidade do
     Maxima - o comando `dontusedimension' pode ser usado.  `uforget'
     pode restabelecer as preferências de usuário novamente, mas
     somente se `usedimension' liberar isso para uso.  Alternativamente,
     `kill(usersetunits)' irá remover completametne todo o conhecimento
     dessas escolhas de usuário da sessão atual.  Aqui está alguns
     exemplos de como esssas várias opções trabalham.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) setunits([dyn,eV]);
          (%o4)                                done
          (%i5) kg*m/s^2;
          (%o5)                           (100000) (dyn)
          (%i6) kg*m^2/s^2;
          (%o6)                     (6241509596477042688) (eV)
          (%i7) uforget([dyn,eV]);
          (%o7)                          [false, false]
          (%i8) kg*m/s^2;
          (%o8)                                  N
          (%i9) kg*m^2/s^2;
          (%o9)                                  J
          (%i10) dontusedimension(N);
          (%o10)                             [%force]
          (%i11) dontusedimension(J);
          (%o11)                         [%energy, %force]
          (%i12) kg*m/s^2;
                                               kg m
          (%o12)                               ----
                                                 2
                                                s
          (%i13) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o13)                               -----
                                                 2
                                                s
          (%i14) setunits([dyn,eV]);
          (%o14)                               done
          (%i15) kg*m/s^2;
                                               kg m
          (%o15)                               ----
                                                 2
                                                s
          (%i16) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o16)                               -----
                                                 2
                                                s
          (%i17) uforget([dyn,eV]);
          (%o17)                         [false, false]
          (%i18) kg*m/s^2;
                                               kg m
          (%o18)                               ----
                                                 2
                                                s
          (%i19) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o19)                               -----
                                                 2
                                                s
          (%i20) usedimension(N);
          Done.  To have Maxima simplify to this dimension, use setunits([unit])
          to select a unit.
          (%o20)                               true
          (%i21) usedimension(J);
          Done.  To have Maxima simplify to this dimension, use setunits([unit])
          to select a unit.
          (%o21)                               true
          (%i22) kg*m/s^2;
                                               kg m
          (%o22)                               ----
                                                 2
                                                s
          (%i23) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o23)                               -----
                                                 2
                                                s
          (%i24) setunits([dyn,eV]);
          (%o24)                               done
          (%i25) kg*m/s^2;
          (%o25)                          (100000) (dyn)
          (%i26) kg*m^2/s^2;
          (%o26)                    (6241509596477042688) (eV)
          (%i27) uforget([dyn,eV]);
          (%o27)                           [false, false]
          (%i28) kg*m/s^2;
          (%o28)                                 N
          (%i29) kg*m^2/s^2;
          (%o29)                                 J
          (%i30) kill(usersetunits);
          (%o30)                               done
          (%i31) uforget([dyn,eV]);
          (%o31)                          [false, false]
          (%i32) kg*m/s^2;
                                               kg m
          (%o32)                               ----
                                                 2
                                                s
          (%i33) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o33)                               -----
                                                 2
                                                s
     Desafortunadamente essa ampla variedade de opções é um pouco
     confus no início, mas uma vez que o usuário cultiva o uso delas o
     usuário perceberá que elas permitem completo controle sobre seu
     ambiente de trabalho.


 -- Função: metricexpandall (<x>)
     Reconstrói listas de unidades globais automaticamente criando
     todas as unidades métricas desejadas.  <x> é um argumento numérico
     que é usado para especificar quantos prefixos métricos o usuário
     deseja que seja definido.  Os argumentos são os seguintes, com cada
     maior número definindo todos os menores números de unidade:
                     0 - none. Only base units
                     1 - kilo, centi, milli
          (default)  2 - giga, mega, kilo, hecto, deka, deci, centi, milli,
                         micro, nano
                     3 - peta, tera, giga, mega, kilo, hecto, deka, deci,
                         centi, milli, micro, nano, pico, femto
                     4 - all
     Normalmente, Maxima não irá definir a expansão completa desses
     resultados em uma grande número de unidades, mas `metricexpandall'
     pode ser usada para reconstruir a lista em um estilo mais ou menos
     completo. A variável relevante no arquivo _unit.mac_ é
     <%unitexpand>.

 -- Variável: %unitexpand
     Valor padrão: `2'

     Ess é o valor fornecido a `metricexpandall' durante a
     inicialização de _unit_.



File: maxima.info,  Node: zeilberger,  Next: Índice de Funções e Variáveis,  Prev: unit,  Up: Top

73 zeilberger
*************

* Menu:

* Introdução a zeilberger::
* Definições para zeilberger::


File: maxima.info,  Node: Introdução a zeilberger,  Next: Definições para zeilberger,  Prev: zeilberger,  Up: zeilberger

73.1 Introdução a zeilberger
============================

`zeilberger' é uma implementação do algorítmo de Zeilberger para
somatório hipergeométricos definidos, e também para o algorítmo de
Gosper para somatórios hipergeométricos indefinidos.

   `zeilberger' faz uso do método de otimização "filtering"
desenvolvido por Axel Riese.

   `zeilberger' foi desenvolvido por Fabrizio Caruso.

   `load (zeilberger)' torna esse pacote disponível para uso.

73.1.0.1 O problema dos somatórios hipergeométricos indefinidos
...............................................................

`zeilberger' implementa o algorítmo de Gosper para somatório
hipergeométrico indefinido.  Dado um termo hipergeométrico F_k em k
queremos encontrar sua anti-diferença hipergeométrica, isto é, um termo
hipergeométrico f_k tal que F_k = f_(k+1) - f_k.

73.1.0.2 O problema dos somatórios hipergeométricos definidos
.............................................................

`zeilberger' implementa o algorítmo de Zeilberger para somatório
hipergeométrico definido.  Dado um termo hipergeométrico apropriado (em
n e k) F_(n,k) e um inteiro positivo d queremos encontrar um d-ésima
ordem de recorrência linear com coeficientes polinomiais (em n) para
F_(n,k) e uma função racional R em n e k tal que

   a_0 F_(n,k) + ... + a_d F_(n+d),k = Delta_K(R(n,k) F_(n,k))

   onde Delta_k é o k-seguinte operador de diferença, i.e.,
Delta_k(t_k) := t_(k+1) - t_k.

73.1.1 Níveis de detalhe nas informações
----------------------------------------

Existe também versões de níveis de detalhe fornecidos pelos comandos
que são chamados (os níveis) através da adição de um dos seguintes
prefixos:

`Summary'
     Apenas um sumário é mostrado no final

`Verbose'
     Algumas informações nos passos intermediários

`VeryVerbose'
     Muita informação

`Extra'
     Muito mais informação incluindo informação sobre o sistema linear
     no algorítmo de Zeilberger

   Por exemplo: `GosperVerbose', `parGosperVeryVerbose',
`ZeilbergerExtra', `AntiDifferenceSummary'.


File: maxima.info,  Node: Definições para zeilberger,  Prev: Introdução a zeilberger,  Up: zeilberger

73.2 Definições para zeilberger
===============================

 -- Função: AntiDifference (<F_k>, <k>)
     Retorna a anti-diferença hipergeométrica de <F_k>, se essa
     anti-diferença.  De outra forma `AntiDifference' retorna
     `no_hyp_antidifference'.

 -- Função: Gosper (<F_k>, <k>)
     Retorna o certificado racional <R(k)> para <F_k>, isto é, uma
     função racional tal que

     F_k = R(k+1) F_(k+1) - R(k) F_k

     se essa função racional exitir.  De outra forma, `Gosper' retorna
     `no_hyp_sol'.

 -- Função: GosperSum (<F_k>, <k>, <a>, <b>)
     Retorna o somatório de <F_k> de <k> = <a> a <k> = <b> se <F_k>
     tiver ma diferença hipergeométrica.  De outra forma, `GosperSum'
     retorna `nongosper_summable'.

     Exemplos:

          (%i1) load (zeilberger);
          (%o1)  /usr/share/maxima/share/contrib/Zeilberger/zeilberger.mac
          (%i2) GosperSum ((-1)^k*k / (4*k^2 - 1), k, 1, n);

          Dependent equations eliminated:  (1)
                                     3       n + 1
                                (n + -) (- 1)
                                     2               1
          (%o2)               - ------------------ - -
                                            2        4
                                2 (4 (n + 1)  - 1)
          (%i3) GosperSum (1 / (4*k^2 - 1), k, 1, n);
                                          3
                                    - n - -
                                          2       1
          (%o3)                  -------------- + -
                                          2       2
                                 4 (n + 1)  - 1
          (%i4) GosperSum (x^k, k, 1, n);
                                    n + 1
                                   x          x
          (%o4)                    ------ - -----
                                   x - 1    x - 1
          (%i5) GosperSum ((-1)^k*a! / (k!*(a - k)!), k, 1, n);
                                          n + 1
                          a! (n + 1) (- 1)              a!
          (%o5)       - ------------------------- - ----------
                        a (- n + a - 1)! (n + 1)!   a (a - 1)!
          (%i6) GosperSum (k*k!, k, 1, n);

          Dependent equations eliminated:  (1)
          (%o6)                     (n + 1)! - 1
          (%i7) GosperSum ((k + 1)*k! / (k + 1)!, k, 1, n);
                            (n + 1) (n + 2) (n + 1)!
          (%o7)             ------------------------ - 1
                                    (n + 2)!
          (%i8) GosperSum (1 / ((a - k)!*k!), k, 1, n);
          (%o8)                  nonGosper_summable

 -- Função: parGosper (<F_{n,k}>, <k>, <n>, <d>)
     Tenta encontrar uma recorrência de <d>-ésima ordem para <F_{n,k}>.

     O algorítmo retorna uma seqüência [s_1, s_2, ..., s_m] de
     soluções.  Cada solução tem a forma

     [R(n, k), [a_0, a_1, ..., a_d]]

     `parGosper' retorna `[]' caso não consiga encontrar uma
     recorrência.

 -- Função: Zeilberger (<F_{n,k}>, <k>, <n>)
     Tenta calcular o somatório hipergeométrico indefinido de <F_{n,k}>.

     `Zeilberger' primeiro invoca `Gosper', e se `Gosper' não conseguir
     encontrar uma solução, então `Zeilberger' invoca `parGosper'com
     ordem 1, 2, 3, ..., acima de `MAX_ORD'.  Se Zeilberger encontrar
     uma solução antes de esticar `MAX_ORD', Zeilberger para e retorna
     a solução.

     O algorítmo retorna uma seqüência [s_1, s_2, ..., s_m] de
     soluções.  Cada solução tem a forma

     [R(n,k), [a_0, a_1, ..., a_d]]

     `Zeilberger' retorna `[]' se não conseguir encontrar uma
     solução.

     `Zeilberger' invoca `Gosper' somente se `gosper_in_zeilberger' for
     `true'.

73.3 Variáveis globais gerais
=============================

 -- Variável global: MAX_ORD
     Valor padrão: 5

     `MAX_ORD' é a ordem máxima de recorrência tentada por `Zeilberger'.

 -- Variável global: simplified_output
     Valor padrão: `false'

     Quando `simplified_output' for `true', funções no pacote
     `zeilberger' tentam simplificação adicional da solução.

 -- Variável global: linear_solver
     Valor padrão: `linsolve'

     `linear_solver' nomeia o resolvedor que é usado para resolver o
     sistema de equações no algorítmo de Zeilberger.

 -- Variável global: warnings
     Valor padrão: `true'

     Quando `warnings' for `true', funções no pacote `zeilberger'
     imprimem mensagens de alerta durante a execução.

 -- Variável global: gosper_in_zeilberger
     Valor padrão: `true'

     Quando `gosper_in_zeilberger' for `true', a função `Zeilberger'
     chama `Gosper' antes de chamar `parGosper'.  De outra forma,
     `Zeilberger' vai imediatamente para `parGosper'.

 -- Variável global: trivial_solutions
     Valor padrão: `true'

     Quando `trivial_solutions' for `true', `Zeilberger' retorna
     soluções que possuem certificado igual a zero, ou todos os
     coeficientes iguais a zero.

73.4 Variáveis relacionadas ao teste modular
============================================

 -- Variável global: mod_test
     Valor padrão: `false'

     Quando `mod_test' for `true', `parGosper' executa um teste modular
     discartando sistemas sem solução.

 -- Variável global: modular_linear_solver
     Valor padrão: `linsolve'

     `modular_linear_solver' nomeia o resolvedor linear usado pelo
     teste modular em `parGosper'.

 -- Variável global: ev_point
     Valor padrão: `big_primes[10]'

     `ev_point' é o valor no qual a variável <n> é avaliada no momento
     da execução do teste modular em `parGosper'.

 -- Variável global: mod_big_prime
     Valor padrão: `big_primes[1]'

     `mod_big_prime' é o módulo usado pelo teste modular em `parGosper'.

 -- Variável global: mod_threshold
     Valor padrão: 4

     `mod_threshold' is the maior ordem para a qual o teste modular em
     `parGosper' é tentado.



Local Variables:
coding: iso-8859-1
End:
