This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: draw,  Up: Top

49 dynamics
***********

* Menu:

* Introdução a dynamics::
* Funções e Variáveis Definidas para dynamics::


File: maxima.info,  Node: Introdução a dynamics,  Next: Funções e Variáveis Definidas para dynamics,  Prev: dynamics,  Up: dynamics

49.1 Introdução a dynamics
==========================

O pacote adicional ‘dynamics’ inclui muitas funções para criar várias
representações gráficas de sistemas dinâmicos discretos e fractais, e
uma implementação deo método numérico de Runge-Kutta de quarta ordem
para a resolução de sistemas de equações diferenciais.

   Para usar as funções nesse pacote você deve primeiramente torná-lo
disponível para uso com ‘load("dynamics")’.

   Modificações introduzidas no Maxima 5.12

   Iniciando no Maxima 5.12, o pacote dynamics agora utiliza a função
‘plot2d’ para monar os gráficos.  Os comandos que produzem gráficos (com
exceção de ‘julia’ e de ‘mandelbrot’) agora aceitam qualquer opção de
‘plot2d’, incluindo a opção que modificam o montante das várias
interfaces gráficas, usando diferentes estilos de montagem de gráfico e
cores, e representando um ou ambos os eixos em uma escala logarítmica.
As antigas opções <domain>, <pointsize>, <xcenter>, <xradius>,
<ycenter>, <yradius>, <xaxislabel> e <yaxislabel> não são aceitas nessa
nova versão.

   Todos os programas irão agora aceitar quaisquer nomes de variáveis, e
não apenas <x> e <y> como nas antigas versões.  Dois parâmetros
requeridos tiveram modificações em dois desses programas: ‘evolution2d’
agora requer uma lista nomeando explicitamente as duas variáveis
independentes, e o intervalo horizontal para ‘orbits’ não mais requer um
tamanho de passo; o intervalo pode somente espcificar o nome da
variável, e o menor e o maior valores; o número de passos pode agora ser
modificado com a opção <nticks>.


File: maxima.info,  Node: Funções e Variáveis Definidas para dynamics,  Prev: Introdução a dynamics,  Up: dynamics

49.2 Funções e Variáveis Definidas para dynamics
================================================

 -- Função: chaosgame (‘[[’<x1>, <y1>‘]’...‘[’<xm>, <ym>‘]]’, ‘[’<x0>,
          <y0>‘]’, <b>, <n>, ...opções...);

     Implementa o então chamado jogo do caos: o ponto inicial (<x0>,
     <y0>) é colocado no gráfico e então um dos <m> pontos ‘[’<x1>,
     <y1>‘]’...‘[’<xm>, <ym>‘]’ será selecionado de forma aleatória.  O
     próximo ponto colocado no gráfico será sobre o segmento que vai do
     ponto anteriormente colocado no gráfico ao ponto escolhido
     aleatóriamente, à distância do ponto aleatório que será <b> vezes o
     comprimento daquele segmento.  o procedimento é repetido <n> vezes.

 -- Função: evolution (<F>, <y0>, <n>, ..., opções, ...);

     Desenha <n+1> pontos em gráfico bidimensional, onde as coordenadas
     horizontais dos pontos são os inteiros 0, 1, 2, ..., <n>, e as
     coordenadas verticais são os valores correspondentes <y(n)> da
     seqüência definida pela relação de recorrência
                  y(n+1) = F(y(n))

     com valor inicial <y(0)> igual a <y0>.  <F> deve ser uma expressão
     que depende somente de uma variável (no exemplo, essa variável
     dependente de <y>, mas qualquer outra variável pode ser usada em
     lugar de <y>), <y0> deve ser um número real e <n> deve ser um
     inteiro positivo.

 -- Função: evolution2d (‘[’<F>, <G>‘]’, ‘[’<u>, <v>‘]’, ‘[’<u0>,
          <y0>‘]’, <n>, ..., opções, ...);

     Mostra, em um gráfico bidimensional, os primeiros <n+1> pontos na
     seqüência de pontos definida por meio do sistema dinâmico discreto
     bidimensional com relações de recorrência
                  u(n+1) = F(u(n), v(n))    v(n+1) = G(u(n), v(n))

     Com valores iniciais <u0> e <v0>.  <F> e <G> devem ser duas
     expressões que dependem somente de duas variáveis <u> e <v>, que
     devem ser nomeadas explicitamente em uma lista.

 -- Função: ifs (‘[’<r1>, ..., <rm>‘]’, ‘[’<A1>, ..., <Am>‘]’, ‘[[’<x1>,
          <y1>‘]’, ..., ‘[’<xm>, <ym>‘]]’, ‘[’<x0>, <y0>‘]’, <n>, ...,
          opções, ...);

     Implemanta o método de Sistemas de Funções iteradas.  Esse método é
     similar ao método descrito na função ‘chaosgame’, mas em lugar de
     encolher o segmento do ponto corrente ao ponto escolhido
     aleatóriamente, as duas componentes daquele segmento irão ser
     multiplicadas pela matrix 2 por 2 <Ai> que corresponde ao ponto
     escolhido aleatóriamente.

     A escolha aleatória de um dos <m> pontos de atração pode ser feita
     com uma distribuição de probabilidade não uniforme definida por
     meio dos pesos <r1>,...,<rm>.  Esses pesos são fornecidos de forma
     cumulativa; por exemplo se existem 3 pontos com probabilidades 0.2,
     0.5 e 0.3, os pesos <r1>, <r2> e <r3> podem ser 2, 7 e 10.

 -- Função: rk (EDO, var, inicio, domain)
 -- Função: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm], domain)

     A primeira forma resolve numericamente uma equação diferencial de
     primeira ordem, e a segunda formaresolve um sistema de m dessas
     equações, usando o método de Runge-Kutta de quarta ordem.  ‘var’
     representa a variável dependente.  EDO deve ser uma expressão que
     dependa somente da variável independente e da variável dependente e
     defina a derivada da variável dependente com relação à variável
     independente.

     A variável independente é especificada com ‘domain’, que deve ser
     uma lista dde quatro elementos como, por exemplo:
          [t, 0, 10, 0.1]
     O primeiro elemento da lista identifica a variável independente, o
     segundo e o terceiro elementos são os valores inicial e final para
     para aquela variável, e o último elemento escolhe o incremento que
     pode ser usado dentro daquele intervalo.

     Se <m> equações estão sendo resolvidas, podem existir <m> variáveis
     dependentes <v1>, <v2>, ..., <vm>.  Os valores iniciais para
     aquelas variáveis serão <inic1>, <inic2>, ..., <inicm>.  Ainda pode
     ser apenas uma variável independente definida por ‘domain’, como no
     caso anterior.  <EDO1>, ..., <EDOm> são as expressões que definem
     as derivadas de cada variável dependente em termos da variável
     independente.  As variáveis que podem aparecer naquelas expressões
     são a variável independente e quaisquer outras variáveis
     dependentes.  É importante fornecer as derivadas <EDO1>, ...,
     <EDOm> na lista exatamente na mesma ordem usada para variáveis
     dependentes; por exemplo, o terceiro elemento na lista irá ser
     interpretado com a derivada da terceira variável dependente.

     O programa tentará integrar as equações a partir do valor inicial
     da variável independente até seu último valor, usando incrementos
     constantes.  Se em algum passo uma das variáveis dependentes recebe
     um valor absoluto muito grande, a integração será interrompida
     naquele ponto.  O resultado será uma lista com tamtos elementos
     quantos forem o número de iterações feitas.  Cada elemento na lista
     de resultado é em si mesmo outra lista comh <m>+1 elementos: o
     valor da variável independente, seguido pelos valores das variáveis
     dependentes correspondentes àquele ponto.

 -- Função: staircase (<F>, <y0>, <n>, ...opções...);

     Desenha um diagrama em escada para a seqüência definida pela
     relação de recorrência
                  y(n+1) = F(y(n))

     A interpretação e os valores permitidos dos parâmetros de entrada
     são os mesmos que para a função ‘evolution’.  Um diagrama em escada
     consiste de um gráfico da função <F(y)>, juntamente com a linha
     <G(y)> ‘=’ <y>.  Um segmento vertical é desenhado a partir das
     point (<y0>, <y0>) on that line until the point where it
     intersecções com a função <F>.  A partir daquele ponto um segmento
     horizontal é desenhado até encontrar o ponto (<y1>, <y1>) sobre a
     linha, e o procedimento é repetido <n> vezes até que o ponto (<yn>,
     <yn>) é encontrado.

   opções

   Cada opção é uma lista de dois ou mais itens.  O primeiro item é o
nome da opção, e os restantes compreendem os argumentos para a opção.

   As opções aceitas pelas funções ‘evolution’, ‘evolution2d’,
‘staircase’, ‘orbits’, ‘ifs’ e ‘chaosgame’ são as mesmas opções para
‘plot2d’.  Adicionalmente para aquelas opções, ‘orbits’ aceita a opção
extra <pixels> que escolhe o número máximo de pontos diferentes que irão
ser representados na direção vertical.

   Exemplos

   Representação gráfica e diagrama em escada para a seqüência: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$

     (%i2) evolution(cos(y), 2, 11);

     (%i3) staircase(cos(y), 1, 11, [y, 0, 1.2]);

   Se seu sistema for lento, você deverá reduzir o número de iterações
nos seguintes exemplos.  E se os pontos parecerem muito pequenos no seu
monitor, você pode querer tentar um estilo diferente, tal como
‘[’<style>,‘[’<points>,0.8‘]]’.

   Diagrama de órbitas para o mapa quadrático, com um parâmetro <a>.
             x(n+1) = a + x(n)^2

     (%i4) orbits(x^2+a, 0, 50, 200, [a, -2, 0.25], [style, dots]);

   Para ampliar a região em torno da bifurcação menor perto de x ‘=’
-1.25 use:
     (%i5) orbits(x+y^2, 0, 100, 400, [a,-1,-1.53], [x,-1.6,-0.8],
                  [nticks, 400], [style,dots]);

   Evolução de um sistemma bidimensional que leva a um fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$

     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$

     (%i8) evolution2d([f,g], [x,y], [-0.5,0], 50000, [style,dots]);

   E uma ampliação de uma pequena regial naquele fractal:

     (%i9) evolution2d([f,g], [x,y], [-0.5,0], 300000, [x,-0.8,-0.6],
                       [y,-0.4,-0.2], [style, dots]);

   Um gráfico do triângulo de Sierpinsky, obtido com o jogo do caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [style, dots]);

   A samambaia de Barnsley, obtida com um Sistema de Funções Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$

     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$

     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$

     (%i13) a4: matrix([0,0],[0,0.16])$

     (%i14) p1: [0,1.6]$

     (%i15) p2: [0,1.6]$

     (%i16) p3: [0,0.44]$

     (%i17) p4: [0,0]$

     (%i18) w: [85,92,99,100]$

     (%i19) ifs(w, [a1,a2,a3,a4], [p1,p2,p3,p4], [5,0], 50000, [style,dots]);

   Para resolver numericamente a equação diferencial

               dx/dt = t - x^2

   Com valor inicial x(t=0) = 1, no intervalo de ‘t’ de 0 a 8 e com
incrementos de 0.1 para ‘t’, use:

     (%i20) results: rk(t-x^2,x,1,[t,0,8,0.1])$

   os resultados serão salvos na lista de resultados.

   Para resolver numericamente o sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para ‘t’ entre 0 e 4, e com valores de -1.25 e 0.75 para x e y em
t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

50 eval_string
**************

* Menu:

* Funções e Variáveis Definidas para eval_string::


File: maxima.info,  Node: Funções e Variáveis Definidas para eval_string,  Prev: eval_string,  Up: eval_string

50.1 Funções e Variáveis Definidas para eval_string
===================================================

 -- Função: eval_string (<str>)
     Entrega a seqüência de caracteres do Maxima <str> como uma
     expressão do Maxima e a avalia.  <str> é uma seqüência de
     caracteres do Maxima.  Essa seqüência pode ou não ter um marcador
     de final (sinal de dólar ‘$’ ou ponto e vírgula ‘;’).  Somente a
     primeira expressão é entregue e avaliada, se ouver mais de uma.

     Reclama se <str> não for uma seqüência de caracteres do Maxima.

     Exemplos:
          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

     Veja também ‘parse_string’.

 -- Função: parse_string (<str>)
     Entrega a seqüência de caracteres do Maxima <str> como uma
     expressão do Maxima (sem fazer nenhuma avaliação dessa expressão).
     <str> é uma seqüência de caracteres do Maxima.  Essa seqüência pode
     ou não ter um marcador de final (sinal de dólar ‘$’ ou ponto e
     vírgula ‘;’).  Somente a primeira expressão é entregue e avaliada,
     se ouver mais de uma.

     Reclama se <str> não for uma seqüência de caracteres do Maxima.

     Exemplos:
          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                              2
          (%o2)          (foo : 42, bar : foo  + baz)

     Veja também a função ‘eval_string’.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

51 f90
******

* Menu:

* Funções e Variáveis Definidas para f90::


File: maxima.info,  Node: Funções e Variáveis Definidas para f90,  Prev: f90,  Up: f90

51.1 Funções e Variáveis Definidas para f90
===========================================

 -- Função: f90 (<expr>)
     O comando f90 é uma atualização para o comando ‘fortran’ original
     do maxima.  A diferença primária é o caminho através do qual linhas
     longas são quebradas.

     No exemplo seguinte, observe como o comando ‘fortran’ para linhas
     dentro de símbolos.  O comando ‘f90’ jamais para linha dentro de um
     símbolo.

          (%i1) load("f90")$

          (%i2) expr:expand((xxx+yyy+7)^4);
                   4            3         3        2    2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                       2          2        3             2
           + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                         4         3          2
           + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
           + 1372 xxx + 2401
          (%i3) fortran(expr);
                yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
               1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
               2   xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                       done
          (%i4) f90(expr);
          yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
               yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
               4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                       done

     A implementação ‘f90’ termina como um rápido reparo em ‘fortran’.
     Não é necessáriamente um bom exemplo sobre o qual se deva basear
     outros tradutores do Maxima para outras linguagens de programação.

     Para usar essa função escreva primeiro ‘load("f90")’.


File: maxima.info,  Node: ggf,  Next: grobner,  Prev: f90,  Up: Top

52 ggf
******

* Menu:

* Funções e Variáveis Definidas para ggf::


File: maxima.info,  Node: Funções e Variáveis Definidas para ggf,  Prev: ggf,  Up: ggf

52.1 Funções e Variáveis Definidas para ggf
===========================================

 -- Variável de Opção: GGFINFINITY
     Valor padrão: 3

     Essa é uma variável de opção para a função ‘ggf’.

     Quando calculando a fração contínua da função geradora, um
     quociente parcial tendo um grau (estritamente) maior que
     <GGFINFINITY> será descartado e o convergente atual será
     considerado como o valor exato da função geradora; na grande mioria
     dos casos o grau de todos os quocientes parciais será ou 0 ou 1; se
     você usar um valor muito grande, então você poderá fornecer termos
     suficientes com o objetivo de fazer o cálculo preciso o bastante.

     Veja também ‘ggf’.

 -- Variável de opção: GGFCFMAX
     Valor padrão: 3

     Essa é uma variável de opção para a função ‘ggf’.

     Quando calculando a fração contínua da função geradora, se nenhum
     bom resultado for encontrado (veja o sinalizador <GGFINFINITY>)
     após se ter calculado uma quantidade de <GGFCFMAX> quocientes
     parciais, a função geradora será considerada como não sendo uma
     fração de dois polinômios e a função irá terminar.  Coloque
     livemente um valor muito grande para funções geradoras mais
     complicadas.

     Veja também ‘ggf’.

 -- Função: ggf (<l>)
     Calcula a função geradora (se for uma fração de dois polinômios) de
     uma seqüência, sendo dados seus primeiros termos.  <l> é uma lista
     de números.

     A solução é retornada como uma fração de dois polinômios.  Se
     nenhuma solução tiver sido encontrada, é retornado ‘done’.

     Essa função é controlada attravés das variáveis globais
     <GGFINFINITY> e <GGFCFMAX>.  Veja também <GGFINFINITY> e
     <GGFCFMAX>.

     Para usar essa função primeiro escreva ‘load("ggf")’.


File: maxima.info,  Node: grobner,  Next: impdiff,  Prev: ggf,  Up: Top

53 grobner
**********

/grobner.texi/1.3/Sat Jun 2 00:13:21 2007//
* Menu:

* Introdução a grobner::
* Funções e Variáveis Definidas para grobner::


File: maxima.info,  Node: Introdução a grobner,  Next: Funções e Variáveis Definidas para grobner,  Prev: Top,  Up: Top

53.1 Introdução a grobner
=========================

‘grobner’ é um pacote para trabalhos com bases de Groebner no Maxima.

Um tutorial sobre _Bases de Groebner_ pode ser encontrado em

<http://www.geocities.com/CapeCanaveral/Hall/3131/>

Para usar as seguintes funções você deve primeiramente tornar o pacote
‘grobner.lisp’ disponível para uso:

     load("grobner");

Uma demonstração de uso pode ser iniciada com
     demo("grobner.demo");

ou com
     batch("grobner.demo")

Alguns dos cálculos no arquivo de demonstração irão tomar um pouco de
tempo portanto a saída ‘grobner-demo.output’ do arquivo de demonstração
pode ser encontrada no mesmo diretório que o arquivo de demonstração.

53.1.1 Notas sobre o pacote grobner
-----------------------------------

O pacote foi escrito por

Marek Rychlik

<http://alamos.math.arizona.edu>

e foi liberado em 24/05/2002 nos termos da Licença Pública Geral
(GPL/GNU/FSF) (veja o arquivo ‘grobner.lisp’.  Essa documentação foi
extraída dos arquivos
‘README’, ‘grobner.lisp’, ‘grobner.demo’, ‘grobner-demo.output’

por Günter Nowak.  Sugestões de melhorias da documentação podem ser
discutidas em _maxima_-mailing-list <maxima@math.utexas.edu>.  O código
está um pouco desatualizado atualmente.  Implementações modernas
utilizam o algorítmo rápido _F4_ descrito em
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

53.1.2 Implementações de ordem monomial admissível em grobner
-------------------------------------------------------------

   • ‘lex’

     puramente lexicográfica, ordenação padrão para comparações
     monomiais
   • ‘grlex’

     ordenação total de grau, quando houver empate é quebrada pela ordem
     lexicográfica

   • ‘grevlex’

     grau total, quando houver empate é quebrada pela ordem
     lexicográfica reversa

   • ‘invlex’

     ordenação lexicográfica reversa


File: maxima.info,  Node: Funções e Variáveis Definidas para grobner,  Prev: Introdução a grobner,  Up: Top

53.2 Funções e Variáveis Definidas para grobner
===============================================

53.2.1 Comutadores globais para grobner
---------------------------------------

 -- Variável de opção: poly_monomial_order
     Valor padrão: ‘lex’

     Esse comutador globalcontrola qual a ordenação monomial é usada em
     polinomio e em cálculos com Bases de Groebner.  Se não for
     escolhidat, ‘lex’ será usada.

 -- Variável de opção: poly_coefficient_ring
     Valor padrão: ‘expression_ring’

     Esse comutador indica o anel de coeficiente dos polinômios que irá
     ser usado em cálculos de grobner.  Se não for escolhido, o anel de
     expressão geral do _maxima’s_ irá ser usado.  Essa variável pode
     ser escolhida para ‘ring_of_integers’ se for desejado.

 -- Variável de opção: poly_primary_elimination_order
     Valor padrão: ‘false’

     Nome da ordem padrão de eliminação de variáveis em funções de
     eliminação.  Se não for escolhida, ‘lex’ irá ser usada.

 -- Variável de opção: poly_secondary_elimination_order
     Valor padrão: ‘false’

     Nome da ordem padrão para manter variáveis em funções de
     eliminação.  Se não for escolhida, ‘lex’ irá ser usada.

 -- Variável de opção: poly_elimination_order
     Valor padrão: ‘false’

     Nome da ordem padrão de funções de eliminação.  Se escolhida, irá
     sobrescrever as escolhas nas variáveis
     ‘poly_primary_elimination_order’ e
     ‘poly_secondary_elimination_order’.  O usuário deve garantir que
     essa é uma ordem de eliminação verdadeira válida para o número de
     variáveis eliminadas.

 -- Variável de opção: poly_return_term_list
     Valor padrão: ‘false’

     Se escolhida para ‘true’, todas as funções no pacote ‘grobner’ irão
     retornar cada polinômio como uma lista de termos na ordem monomial
     corrente em lugar de retornar uma expressão geral do _maxima_.

 -- Variável de opção: poly_grobner_debug
     Valor padrão: ‘false’

     Se escolhida para ‘true’, produz saída de depuração e rastros.

 -- Variável de opção: poly_grobner_algorithm
     Valor padrão: ‘buchberger’

     Valores possíveis:
        • ‘buchberger’
        • ‘parallel_buchberger’
        • ‘gebauer_moeller’

     O nome do algorítmo usado para encontrar as bases de Groebner.

 -- Variável de opção: poly_top_reduction_only
     Valor padrão: ‘false’

     Se não for ‘false’, usa redução de topo somente se for possível.
     Redução de topo significa que o algorítmo de divisão para após a
     primeira redução.

53.2.2 Operadores simples em grobner
------------------------------------

‘poly_add’, ‘poly_subtract’, ‘poly_multiply’ e ‘poly_expt’ são as
operações aritméticas sobre polinômios.  Elas são executadas usando
representação interna, mas os resultados são convertidos de volta à
forma geral do _maxima_.

 -- Função: poly_add (<poli1>, <poli2>, <varlist>)
     Adiciona dois polinômios <poli1> e <poli2>.

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x

 -- Função: poly_subtract (<poli1>, <poli2>, <varlist>)
     Subtrai o polinômio <poli2> do polinômio <poli1>.

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- Função: poly_multiply (<poli1>, <poli2>, <varlist>)
     Retorna o produto dos polinômios <poli1> e <poli2>.

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- Função: poly_s_polynomial (<poli1>, <poli2>, <varlist>)
     Retorna o _polinômio syzygy_ (_S-polinomial_) de dois polinômios
     <poli1> e <poli2>.

 -- Função: poly_primitive_part (<poli1>, <varlist>)
     Retorna o polinômio <poli> dividido pelo MDC entre seus
     coeficientes.

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- Função: poly_normalize (<poli>, <varlist>)
     Retorna o polinômio <poli> dividido pelo coeficiente lider.
     ‘poly_normalize’ assume que a divisão é possível, o que nem sempre
     ocorre em anéis que não são corpos (fields).

53.2.3 Outras funções em grobner
--------------------------------

 -- Função: poly_expand (<poli>, <varlist>)
     Essa função transforma polinômios para a forma interna e da forma
     interna para a forma geral.  ‘poly_expand’ é equivalente a
     ‘expand(poly)’ se <poli> passa corretamente para um polinômio.  Se
     a representação não for compatível com um polinômio nas variáveis
     <varlist>, o resultado é um erro.  Esse resultado em erro pode ser
     usado para testar se uma expressão transforma-se corretamente para
     a representação interna.  Os seguintes exemplos ilustra que
     variáveis de funções indexadas e transcendentes são permitidas.

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1

 -- Função: poly_expt (<poli>, <número>, <varlist>)
     eleva <poli> a um inteiro positivo <número>.  If <número> não for
     um inteiro positivo um erro irá ser mostrado.

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- Função: poly_content (<poli>. <varlist>)
     ‘poly_content’ extrai o MDC entre seus coeficientes

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- Função: poly_pseudo_divide (<poli>, <polilist>, <varlist>)
     Realiza a divisão falsa do polinômio <poli> pela lista de n
     polinômios <polilist>.  Retorna multiplos valores.  O primeiro
     valor é uma lista de quocientes a.  O segundo valor é o resto r.  O
     terceiro argumento é um coeficiente escalar c, tal que c*poli pode
     ser dividido por<polilist> dentro do anel dos coeficientes, que não
     é necessáriamente corpo.  Finalmente, o quarto valor é um contador
     inteiro do número de reduções realizadas.  O objetos resultantes
     satisfazem à equação:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- Função: poly_exact_divide (<poli1>, <poli2>, <varlist>)
     Divide um polinômio <poli1> por outro polinômio <poli2>.  Assume
     que a divisão exata (sem resto) é possível.  Retorna o quociente.

 -- Função: poly_normal_form (<poli>, <polilist>, <varlist>)
     ‘poly_normal_form’ encontra a forma normal de um polinômio <poli>
     com relação a um conjunto de polinômios <polilist>.

 -- Função: poly_buchberger_criterion (<polilist>, <varlist>)
     Returns ‘true’ if <polilist> is a Groebner basis with respect to
     the current term order, by using the Buchberger criterion: for
     every two polynomials h1 and h2 in <polilist> the S-polynomial
     S(h1,h2) reduces to 0 modulo <polilist>.

 -- Função: poly_buchberger (<polilist_fl> <varlist>)
     ‘poly_buchberger’ realiza o algorítmo de Buchberger sobre uma lista
     de polinômios e retorna a base de Grobner resultante.

53.2.4 Pósprocessamento padão de bases de Groebner
--------------------------------------------------

O _k-ésimo ideal de eliminação_ I_k de uma Ideal I sobre K[
x[1],...,x[n] ] é o ideal intersecção(I, K[ x[k+1],...,x[n] ]).
O _ideal quociente_ I:J é o ideal {h|for all w em J: w*h em I}.
O ideal I:p^inf é o ideal {h| existe um n em N: p^n*h em I}.
O ideal I:J^inf é o ideal {h| existe um n em N \and a p em J: p^n*h em
I}.
O _ideal radical_ sqrt(I) é o ideal {h| existe um n em N : h^n em I }.

 -- Função: poly_reduction (<polilist>, <varlist>)
     ‘poly_reduction’ reduz uma lista de polinômios <polilist>, de forma
     que cada poinômio é completametne reduzido com relação a outros
     polinômios.

 -- Função: poly_minimization (<polilist>, <varlist>)
     Retorna uma sublista da lista de polinômios <polilist> gerando o
     mesmo ideal de monômio que <polilist> mas minimo, i.e.  nenhum
     monômio líder de um polinômio na sublista divide o monômio líder de
     outro polinômio.

 -- Função: poly_normalize_list (<polilist>, <varlist>)
     ‘poly_normalize_list’ aplica ‘poly_normalize’ a cada polinômio na
     lista.  Que significa que ‘poly_normalize_list’ divide todo
     polinômio em uma lista <polilist> por seu coeficiente líder.

 -- Função: poly_grobner (<polilist>, <varlist>)
     Retorna uma base de Groebner do ideal gerado pelos polinômios
     <polilist>.  Afetado pelos sinalizadores globais.

 -- Função: poly_reduced_grobner (<polilist>, <varlist>)
     Retorna uma base de Groebner reduzida do ideal gerado pelos
     polinômios <polilist>.  Afetado pelos sinalizadores globais.

 -- Função: poly_depends_p (<poli>, <var>, <varlist>)
     ‘poly_depends’ testa se um polinômio depende da variável <var>.

 -- Função: poly_elimination_ideal (<polilist>, <num>, <varlist>)

     ‘poly_elimination_ideal’ retorna a base de grobner do num-ésimo
     ideal de eliminação de um ideal especificado como uma lista de
     polinômios geradores (não necessáriamente base de Groebner)

 -- Função: poly_colon_ideal (<polilist1>, <polilist2>, <varlist>)

     Retorna a base reduzida de Groebner do ideal quociente

     I(polilist1):I(polilist2)

     onde polilist1 e polilist2 são duas listas de polinômios.

 -- Função: poly_ideal_intersection (<polilist1>, <polilist2>,
          <varlist>)

     ‘poly_ideal_intersection’ retorna a intersecção entre dois ideais.

 -- Função: poly_lcm (<poli1>, <poli2>, <varlist>)
     Retorna o mínimo múltiplo comum entre <poli1> e <poli2>.

 -- Função: poly_gcd (<poli1>, <poli2>, <varlist>)
     Retorna máximo divisor comum de <poli1> e <poli2>.

 -- Função: poly_grobner_equal (<polilist1>, <polilist2>, <varlist>)
     ‘poly_grobner_equal’ testa se duas bases de Groebner geram o mesmo
     ideal.  Retorna ‘true’ se as duas listas de polinômios <polilist1>
     e <polilist2>, assumidas serem bases de Groebner, geram o mesmo
     ideal, e ‘false’ de outra forma.  Isso é equivalente a verificar
     que todo polinômio da primeira base é reduzido a 0 módulo a segunda
     base e vice-versa.  Note que no exemplo abaixo a primeira lista não
     é uma base de Groebner, e dessa forma o resultado é ‘false’.

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false

 -- Função: poly_grobner_subsetp (<polilist1>, <polilist2>, <varlist>)

     ‘poly_grobner_subsetp’ testa se um ideal gerado pela <polilist1>
     está contido em um ideal gerado pela <polilist2>.  Para esse teste
     sempre tenha sucesso, <polilist2> deve ser uma base de Groebner.

 -- Função: poly_grobner_member (<poli>, <polilist>, <varlist>)

     Retorna ‘true’ se um polinômio <poli> pertence ao ideal gerado pela
     lista polinomial <polilist>, que é assumida como sendouma base de
     Groebner.  Retorna ‘false’ de outra forma.

     ‘poly_grobner_member’ testa se um polinômio pertence a um ideal
     gerado por uma lista de polinômios, que é assumida ser uma base de
     Groebner.  Equivale a ‘normal_form’ sendo 0.

 -- Função: poly_ideal_saturation1 (<polilist>, <poli>, <varlist>)
     Retorna abase de Groebner reduzida da saturação do ideal

     I(polylist):poly^inf

     Geometricamente, sobre um corpo algebricamente fechado, esse é um
     conjunto de polinmios no ideal gerado por <polilist> que não tende
     identicamente a zero sobre a variação de <poli>.

 -- Função: poly_ideal_saturation (<polilist1>, <polilist2>, <varlist>)
     Retorna a base de Groebner reduzida da saturação do ideal

     I(polylist1):I(polylist2)^inf

     Geometricamente, sobre um corpo algebricamente fechado, esse é um
     conjunto de polinmios no ideal gerado por <polilist1> que não tende
     identicamente a zero sobre a variação de <polilist2>.

 -- Função: poly_ideal_polysaturation1 (<polilist1>, <polilist2>,
          <varlist>)
     <polilist2> ist a list of n polynomials ‘[poly1,...,polyn]’.
     Retorna a base de Groebner reduzida do ideal

     I(polylist):poly1^inf:...:polyn^inf

     obtido por uma seqüência de sucessivas saturações nos polinômios da
     lista polinômial <polilist2> do ideal gerado pela lista polinomial
     <polilist1>.

 -- Função: poly_ideal_polysaturation (<polilist>, <polilistlist>,
          <varlist>)
     <polilistlist> is a list of n list of polynomials
     ‘[polylist1,...,polylistn]’.  Retorna a base reduzida de Groebner
     da saturação do ideal

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf

 -- Função: poly_saturation_extension (<poli>, <polilist>, <varlist1>,
          <varlist2>)

     ‘poly_saturation_extension’ implementa o famoso artifício de
     Rabinowitz.


File: maxima.info,  Node: impdiff,  Next: implicit_plot,  Prev: grobner,  Up: Top

54 impdiff
**********

* Menu:

* Funções e Variáveis Definidas para impdiff::


File: maxima.info,  Node: Funções e Variáveis Definidas para impdiff,  Prev: impdiff,  Up: impdiff

54.1 Funções e Variáveis Definidas para impdiff
===============================================

 -- Função: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Essa subrotina calcula derivadas implícitas de funções de várias
     variáveis.  <f> é uma função do tipo array, os índices são o grau
     da derivada na ordem <indvarlist>; <indvarlist> é a lista de
     variáveis independentes; <orderlist> é a ordem desejada; e <depvar>
     é a variável dependente.

     Para usar essa função escreva primeiro ‘load("impdiff")’.


File: maxima.info,  Node: implicit_plot,  Next: interpol,  Prev: impdiff,  Up: Top

55 implicit_plot
****************

* Menu:

* Funções e Variáveis Definidas para implicit_plot::


File: maxima.info,  Node: Funções e Variáveis Definidas para implicit_plot,  Prev: implicit_plot,  Up: implicit_plot

55.1 Funções e Variáveis Definidas para implicit_plot
=====================================================

 -- Função: implicit_plot (<expr>, <x_range>, <y_range>)
 -- Função: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)

     Mostra na tela um gráfico de uma ou mais expressões na forma
     implícita.  <expr> é a expressão a ser montado o gráfico, <x_range>
     o intervalo do eixo do eixo horizontal e <y_range> o intervalo do
     eixo vertical.  ‘implicit_plot’ somente trabalha com o driver do
     gnuplot.  ‘implicit_plot’ respeita as escolhas globais para o
     driver do gnuplot escolhidas por meio da função <set_plot_option>.
     Opções podem tamb;em serem passadas para a função ‘implicit_plot’
     como argumentos opcionais.

     ‘implicit_plot’ trabalha por meio de mudanças de sinal de trilha
     sobre a área fornecida através de <x_range> e <y_range> e pode
     falhar em expressões complicadas.

     ‘load("implicit_plot")’ torna essa função disponível para uso.

     Exemplo:
          (%i1) load("implicit_plot")$
          (%i2) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4])$


File: maxima.info,  Node: interpol,  Next: lbfgs,  Prev: implicit_plot,  Up: Top

56 interpol
***********

* Menu:

* Introdução a interpol::
* Funções e Variáveis Definidas para interpol::


File: maxima.info,  Node: Introdução a interpol,  Next: Funções e Variáveis Definidas para interpol,  Prev: interpol,  Up: interpol

56.1 Introdução a interpol
==========================

Pacote ‘interpol’ define os métodos Lagrangiano, linear e o de splines
cúbicos para interpolação polinomial.

   Comentários, correções e sugestões, por favor contacte-me em <’mario
AT edu DOT xunta DOT es’>.


File: maxima.info,  Node: Funções e Variáveis Definidas para interpol,  Prev: Introdução a interpol,  Up: interpol

56.2 Funções e Variáveis Definidas para interpol
================================================

 -- Função: lagrange (<pontos>)
 -- Função: lagrange (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método Lagrangiano.  O
     argumento <pontos> deve ser um dos seguintes:

        • uma matriz de duas colunas, ‘p:matrix([2,4],[5,6],[9,3])’,
        • uma lista de pares, ‘p: [[2,4],[5,6],[9,3]]’,
        • uma lista de números, ‘p: [4,6,3]’, e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é ‘'x’ por padrão; para definir qualquer
     outra, z por exemplo, escreva ‘varname='z’.

     Exemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) /* Plot the polynomial together with points */
                plot2d([f(x),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o8)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5

 -- Função: charfun2 (<x>, <a>, <b>)
     Retorna ‘true’, i.  e., verdadeiro se o número <x> pertence ao
     intervalo [a, b), e ‘false’, i.  e., falsono caso contrário.

 -- Função: linearinterpol (<pontos>)
 -- Função: linearinterpol (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método linear.  O
     argumento <pontos> deve ser um dos seguintes:

        • uma matriz de duas colunas, ‘p:matrix([2,4],[5,6],[9,3])’,
        • uma lista de pares, ‘p: [[2,4],[5,6],[9,3]]’,
        • uma lista de números, ‘p: [4,6,3]’, e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é ‘'x’ por padrão; para definir qualquer
     outra, z por exemplo, escreva ‘varname='z’.

     Examples:
          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7)  /* Plot the polynomial together with points */
                 plot2d(['(f(x)),[discrete,args(p)]],[x,-5,20],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o8) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3

 -- Função: cspline (<pontos>)
 -- Função: cspline (<pontos>, <opção1>, <opção2>, ...)
     Calcula a interpolação polnomial pelo método de splines (
     polinômios de ordem k que interpolam os dados e têm k-1 derivadas
     contínuas em todo o intervalo ) cúbicos.  O argumento <pontos> deve
     ser um dos seguintes:

        • uma matriz de duas colunas, ‘p:matrix([2,4],[5,6],[9,3])’,
        • uma lista de pares, ‘p: [[2,4],[5,6],[9,3]]’,
        • uma lista de números, ‘p: [4,6,3]’, e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Existem três opções para ajustar necessidades específicas:
        • ‘'d1’, o padrão é ‘'unknown’, é a primeira derivada em x_1; se
          essa primeira derivada for desconhecida, ‘'unknown’, a segunda
          derivada em x_1 é igualada a 0 (o spline cúbico natural); se
          essa primeira derivada for igual a um número, a segunda
          derivada é calculada baseando-se nesse número.

        • ‘'dn’, o padrão é ‘'unknown’, é a primeira derivada em x_n; se
          essa primeira derivada for desconhecida, ‘'unknown’, a segunda
          derivada em x_n é igualada a 0 (o spline cúbico natural); se
          essa primeira derivada for igual a um número, a segunda
          derivada é calculada baseando-se nesse número.

        • ‘'nome_var’, o padrão é ‘'x’, é o nome da variável
          independente.

     Exemplos:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) /* Plotting interpolating function */
                plot2d(['(f(x)),[discrete,p]],[x,0,10],
                    [gnuplot_curve_styles,
                         ["with lines","with points pointsize 3"]])$
          (%i7) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o7)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                        ["with lines","with lines","with points pointsize 3"]])$


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: interpol,  Up: Top

57 lbfgs
********

* Menu:

* Introdução a lbfgs::
* Funções e Variáveis Definidas para lbfgs::


File: maxima.info,  Node: Introdução a lbfgs,  Next: Funções e Variáveis Definidas para lbfgs,  Prev: Top,  Up: Top

57.1 Introdução a lbfgs
=======================

‘lbfgs’ é uma implementação do algorítmo[1] L-BFGS
(Broyden-Fletcher-Goldfarb-Shanno) para resolver problemas de
minimização não limitada através de um algorítmo de memória limitada
quasi-Newton (BFGS). Esse algorítmo é chamado de método de memória
limitada porque uma aproximação de baixo ranque da inverso da matriz
Hessiana é armazenado em lugar da inversa da matriz Hessiana completa.
O programa foi escrito origináriamente em Fortran [2] por Jorge Nocedal,
incorporando algumas funções originalmente escritas por Jorge J. Moré e
David J. Thuente, e traduzidas para Lisp automaticamente através do
programa ‘f2cl’.  O pacote do Maxima ‘lbfgs’ compreende o código
traduzido e adicionalmente uma interface de função que gerencia alguns
detallhes.

   Referências:

   [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
large scale optimization".  Mathematical Programming B 45:503–528 (1989)

   [2] http://netlib.org/opt/lbfgs_um.shar


File: maxima.info,  Node: Funções e Variáveis Definidas para lbfgs,  Prev: Introdução a lbfgs,  Up: Top

57.2 Funções e Variáveis Definidas para lbfgs
=============================================

 -- Função: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)

     Encontra uma solução aproximada da minimização não limitada de
     número de mérito <FOM> sobre a lista de variáveis <X>, começando a
     partir da estimativa inicial <X0>, tal que norm grad FOM < epsilon
     max(1, norm X).

     O algorítmo aplicado é um algorítmo de memória limitada[1]
     quasi-Newton (BFGS). Esse algorítmo é chamado de método de memória
     limitada porque uma aproximação de baixo ranque da inverso da
     matriz Hessiana é armazenado em lugar da inversa da matriz Hessiana
     completa.  Cada iteração do algorítmo é uma busca de linha, isto é,
     uma busca ao longo de um raio em torno da variáveis <X>, com a
     direção de busca calculada a partir da Hessian inversa aproximada.
     O FOM é sempre decrementado por meio de uma busca de linha
     realizada com sucesso.  Usualmente (mas não sempre) a norma do
     gradiente de FOM também é decrementada.

     <iprint> controla as messaens de progresso mostradas através de
     ‘lbfgs’.

     ‘iprint[1]’
          ‘<iprint>[1]’ controla a freqüência das mensagens de
          progresso.
          ‘iprint[1] < 0’
               Nenhuma mensagem de progresso.
          ‘iprint[1] = 0’
               Messagens na primeira iteração e na última iteração.
          ‘iprint[1] > 0’
               Mostra uma mensagem a cada ‘<iprint>[1]’ iterações.
     ‘iprint[2]’
          ‘<iprint>[2]’ controla a quantidade de informações fornecidas
          pelas mensagens de progresso (verbosidade).
          ‘iprint[2] = 0’
               Mostra na tela o contador de iterações, o número de
               avaliações de <FOM>, o valor de <FOM>, a norma do
               gradiente de <FOM>, e o comprimento do salto.
          ‘iprint[2] = 1’
               O mesmo que ‘<iprint>[2] = 0’, adicionando <X0> e o
               gradiente de <FOM> avaliado em <X0>.
          ‘iprint[2] = 2’
               O mesmo que ‘<iprint>[2] = 1’, adicionando valores de <X>
               a cada iteração.
          ‘iprint[2] = 3’
               O mesmo que ‘<iprint>[2] = 2’, adicionando o gradiente de
               <FOM> a cada iteração.

     As colunas mostradas por ‘lbfgs’ são as seguintes.

     ‘I’
          número de iterações.  Esse número é incrementado a cada busca
          de linha.
     ‘NFN’
          Número de avaliações do número de mérito.
     ‘FUNC’
          Valor do nero de mérito ao final da busca de linha mais
          recente.
     ‘GNORM’
          Norma do gradiente do número de mérito ao final da mais
          recente busca de linha.
     ‘STEPLENGTH’
          Um parâmetro interno do algorítmo de busca.

     Informação adicional com relação a detalhes do algorítmo podem ser
     encontradas nos comentários do código Fortran original em [2].

     Veja também ‘lbfgs_nfeval_max’ e ‘lbfgs_ncorrections’.

     Referências:

     [1] D. Liu e J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503–528
     (1989)

     [2] http://netlib.org/opt/lbfgs_um.shar

     Exemplo:

     O mesmo FOM como calculada por FGCOMPUTE no programa sdrive.f no
     pacote LBFGS de Netlib.  Note que as variáveis em questão são
     variáveis com subscritos.  O FOM tem um mínimo exato igual a zero
     em u[k] = 1 for k = 1, ..., 8.

          (%i1) load ("lbfgs");
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
             2    4     1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
             3    5     1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
             4    6     1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
             5    7     1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
             6    8     1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
             7    9     1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
             8   10     1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
             9   11     1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
            10   12     9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
            11   13     7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
            12   15     7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
            13   16     6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
            14   17     5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
            15   18     3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
            16   20     3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
            17   22     2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
            18   23     2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
            19   24     2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
            20   25     1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
            21   27     1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
            22   28     9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
            23   29     5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
            24   31     3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
            25   32     3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
            26   33     1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
            27   34     9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
            28   35     4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
            29   36     1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
            30   37     6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
            31   38     1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
            32   39     1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
            33   40     1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
            34   41     1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
            35   42     1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
            36   43     3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

 -- Variãvel: lbfgs_nfeval_max
     Valor padrão: 100

     ‘lbfgs_nfeval_max’ é o número máximo de avaliações do número de
     mérito (FOM - "figure of merit" em inglês) em ‘lbfgs’.  Quando
     ‘lbfgs_nfeval_max’ for encontrada, ‘lbfgs’ retorna o resultado da
     última busca de linha realizada co sucesso.

 -- Variãvel: lbfgs_ncorrections
     Valor padrão: 25

     ‘lbfgs_ncorrections’ é o número de correções aplicadas à matriz
     Hessiana inversa aproximada que é mantida por ‘lbfgs’.


File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

58 lindstedt
************

* Menu:

* Funções e Variáveis Definidas para lindstedt::


File: maxima.info,  Node: Funções e Variáveis Definidas para lindstedt,  Prev: lindstedt,  Up: lindstedt

58.1 Funções e Variáveis Definidas para lindstedt
=================================================

 -- Função: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Esse é um primeiro passo para um código de Lindstedt.  Esse código
     pode resolver problemas com condições iniciais fornecidas, às quais
     podem ser constantes arbitrárias, (não apenas <%k1> e <%k2>) onde
     as condições iniciais sobre as equações de perturbação são z[i]=0,
     z'[i]=0 para i>0.  <ic> é a lista de condições iniciais.

     Problemas ocorrem quando condições iniciais não forem dadas, como
     as constantes nas equações de perturbação são as mesmas que a
     solução da equação de ordem zero.  Também, problemas ocorrem quando
     as condições iniciais para as equações de perturbação não são
     z[i]=0, z'[i]=0 para i>0, tais como a equação de Van der Pol.

     Exemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Para usar essa função escreva primeiro ‘load("makeOrders")’ e
     ‘load("lindstedt")’.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

59 linearalgebra
****************

* Menu:

* Introdução a linearalgebra::
* Funções e Variáveis Definidas para linearalgebra::


File: maxima.info,  Node: Introdução a linearalgebra,  Next: Funções e Variáveis Definidas para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

59.1 Introdução a linearalgebra
===============================

‘linearalgebra’ é uma coleção de funções para álgebra linear.

   Exemplo:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)         [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Funções e Variáveis Definidas para linearalgebra,  Prev: Introdução a linearalgebra,  Up: linearalgebra

59.2 Funções e Variáveis Definidas para linearalgebra
=====================================================

 -- Função: addmatrices (<f>, <M_1>, ..., <M_n>)

     Usando a função <f> como a função de adição, retorne a adição das
     matrizes <M_1>, ..., <M_n>.  A função <f> deve aceitar qualquer
     número de argumentos (uma função enária do Maxima).

     Exemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- Função: blockmatrixp (<M>)

     Retorna ‘true’ se e somente se <M> for uma matriz e toda entrada de
     <M> também for uma matriz.

 -- Função: columnop (<M>, <i>, <j>, <theta>)

     Se <M> for uma matriz, retorna a matriz que resulta de fazer a
     operação de coluna ‘C_i <- C_i - <theta> * C_j’.  Se <M> não tiver
     uma linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: columnswap (<M>, <i>, <j>)

     Se <M> for uma matriz, troca as colunas <i> e <j>.  Se <M> não
     tiver uma coluna <i> ou <j>, emite uma mensagem de erro.

 -- Função: columnspace (<M>)

     Se <M> for uma matriz, retorna ‘span (v_1, ..., v_n)’, onde o
     conjunto ‘{v_1, ..., v_n}’ é uma base para o espaço coluna de <M>.
     A diferença entre o maior elemento e o menor elemento do conjunto
     vazio é ‘{0}’.  Dessa forma, quando o espaço coluna tiver somente
     um membro, retorna ‘span ()’.

 -- Função: copy (<e>)

     Retorna uma cópia da expressão <e> do Maxima.  Embora <e> possa ser
     qualquer expressão do Maxima, A função ‘copy’ é mais útil quando
     <e> for ou uma lista ou uma matriz; considere:
          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]
     Vamos tentar a mesma experiência, mas dessa vez tomemos <mm> como
     sendo uma cópia de <m>
          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]
     Dessa vez, a atribuição a <mm> não muda o valor de <m>.

 -- Função: cholesky (<M>)
 -- Função: cholesky (<M>, <campo>)

     Retorna fatorização de Cholesky da matriz hermitiana (or
     autoadjunta) <M>.  O valor padrão para o segundo argumento é
     ‘generalring’.  Para uma descrição dos possíveis valores para
     <campo>, veja ‘lu_factor’.

 -- Função: ctranspose (<M>)

     Retorna a matriz transposta conjugada complexa da matriz <M>.  A
     função ‘ctranspose’ usa ‘matrix_element_transpose’ para transpor
     cada elemento da matriz.

 -- Função: diag_matrix (<d_1>, <d_2>,...,<d_n>)

     Retorna uma matriz diagonal matriz com entradas de diagonal <d_1>,
     <d_2>,...,<d_n>.  Quando as entradas de diagonal forem matrizes, as
     entradas zero da matriz retornada serão todas matrizes de tamanho
     apropriado; por exemplo:
          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Função: dotproduct (<u>, <v>)

     Retorna o produto do ponto (produto escalar) dos vetores <u> e <v>.
     Isso é o mesmo que ‘conjugate (transpose (<u>)) . <v>’.  Os
     argumentos <u> e <v> devem ser vetores coluna.

 -- Função: eigens_by_jacobi (<A>)
 -- Função: eigens_by_jacobi (<A>, <tipo_corpo>)

     Calculam os autovalores e autovetores de <A> pelo método de
     rotações de Jacobi.  <A> deve ser uma matriz simétrica (mas essa
     matriz simétrica precisa não ser nem definida positiva e nem
     semidefinida positiva).  <tipo_corpo> indica o corpo computacional,
     pode ser ou ‘floatfield’ ou ‘bigfloatfield’.  Se <tipo_corpo> não
     for especificado, o padrão é ‘floatfield’.

     Os elementos de <A> devem ser números ou expressões que avaliam
     para números via ‘float’ ou ‘bfloat’ (dependendo do valor de
     <tipo_corpo>).

     Exemplos:

          (%i1) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);                     [     1         1    ]
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- Função: get_lu_factors (<x>)

     Quando ‘<x> = lu_factor (<A>)’, então ‘get_lu_factors’ retorna uma
     lista da forma ‘[P, L, U]’, onde <P> é uma matriz de permutação,
     <L> é triangular baixa com a diagonal preenchida com a unidade, e
     <U> é triangular alta, e ‘<A> = <P> <L> <U>’.

 -- Função: hankel (<col>)
 -- Função: hankel (<col>, <lin>)

     Retorna uma matriz de Hankel <H>.  A primeira coluna de <H> é
     <col>; exceto para a primeira entrada, a última linha de <H> é
     <lin>.  O valor padrão para <lin> é o vetor nulo com o mesmo
     comprimento que <col>.

 -- Função: hessian (<f>,<vars>)

     Retorna a matriz hessiana de <f> com relação às variáveis na lista
     <vars>.  As entradas <i>,<j> da matriz hessiana são <diff(f
     vars[i],1,vars[j],1)>.

 -- Função: hilbert_matrix (<n>)

     Retorna the <n> by <n> matriz de Hilbert.  Quando <n> não for um
     inteiro positivo, emite uma mensagem de erro.

 -- Função: identfor (<M>)
 -- Função: identfor (<M>, <corpo>)

     Retorna uma matriz identidade que tem o mesmo tamanho que a matriz
     <M>.  As entradas de diagonal da matriz identidade são a identidade
     multiplicativa do corpo <corpo>; o padrão para <corpo> é
     <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou um não
     matriz.  Quando <M> for uma matriz, cada entrada de <M> pode ser
     uma matriz quadrada – dessa forma <M> pode ser uma matriz de bloco
     do Maxima.  A matriz pode ser de bloco para qualquer (finita)
     quantidade de níveis.

     Veja também ‘zerofor’

 -- Função: invert_by_lu (<M>, <(rng generalring)>)

     Inverte a matriz <M> através de fatorização linear alta (LU). A
     fatorização LU é concluída usando o anel <rng>.

 -- Função: kronecker_product (<A>, <B>)

     Retorna o produto de Kronecker das matrizes <A> e <B>.

 -- Função: listp (<e>, <p>)
 -- Função: listp (<e>)

     Recebendo um argumento opcional <p>, retorna ‘true’ se <e> for uma
     lista do Maxima e <p> avalia para ‘true’ para elemento da lista.
     Quando ‘listp’ não recebe o argumento opcional, retorna ‘true’ se
     <e> for uma lista do Maxima.  em todos os outros casos, retorna
     ‘false’.

 -- Função: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     O primeiro argumento deve ser uma matriz; os argumentos que vão de
     <r_1> até <c_2> determinam um sub-matriz de <M> que consiste de
     linhas que vão de <r_1> até <r_2> e colunas que vão de <c_1> até
     <c_2>.

     Encontra uma entrada na sub-matriz <M> que satisfaz alguma
     propriedade.  Existem três casos:

     (1) ‘<rel> = 'bool’ e <f> um predicado:

     Examina a sub-matriz da esquerda para a direita e de cima para
     baixo, e retorna o índice da primeria entrada que satisfizer o
     predicado <f>.  Se nenhuma entrada da matriz satisfizer o predicado
     <f>, retorna ‘false’.

     (2) ‘<rel> = 'max’ e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que maximize <f>.
     Retorna retorna o índice da entrada maximizada.

     (3) ‘<rel> = 'min’ e <f> avaliar para um número real:

     Examina a sub-matriz procurando por uma entrada que minimize <f>.
     Retorna o índice de uma entrada minimizada.

 -- Função: lu_backsub (<M>, <b>)

     Quando ‘<M> = lu_factor (<A>, <corpo>)’, então ‘lu_backsub (<M>,
     <b>)’ resolve o sistema linear ‘<A> <x> = <b>’.

 -- Função: lu_factor (<M>, <corpo>)

     Retorna uma lista da forma ‘[<LU>, <perm>, <corpo>]’, ou da forma
     ‘[<LU>, <perm>, <cmp>, <baixo-cnd> <alto-cnd>]’, onde

     (1) A matriz <LU> contéa fatorização de <M> na forma enpacotada.
     Forma empacotada significa três coisas: Primeiro, as linhas de <LU>
     são permutadas confirme a lista <perm>.  Se, por exemplo, <perm>
     for a lista list ‘[3,2,1]’, a primeira linha atual da fatorização
     <LU> será a terceira linha da matriz <LU>.  Segundo, o fator
     triangular baixo de m é a parte triangular baixa de <LU> com as
     entradas de diagonal todas substituídas pela unidade.  Terceiro, o
     fator triangular alto de <M> é a parte triangular alta de <LU>.

     (2) Quando o corpo for ou ‘floatfield’ ou ‘complexfield’, os
     números <baixo-cnd> e <alto-cnd> serão associados baixo e alto para
     o número condicional de norma infinita de <M>.  Para todos os
     corpos (fields), o número condicional de norma infinita não pode
     ser estimado; para tais corpos, ‘lu_factor’ retorna uma lista com
     dois itens.  Ambos o baixo e o alto associado podem diferir de seus
     verdadeiros valores de fatores arbitráriamente grandes.  (Veja
     também ‘mat_cond’.)

     O argumento <M> deve ser a matriz quadrada.

     O argumento opcional <cmp> deve ser um símbolo que determine um
     anel ou corpo.  Os corpos e anéis predefinidos são:

     (a) ‘generalring’ – o anel de expressões do Maxima, (b)
     ‘floatfield’ – o corpo dos números em ponto flutuante do tipo de
     precisão dupla, (c) ‘complexfield’ – o corpo dos números complexos
     em ponto flutuante do tipo de precisão dupla, (d) ‘crering’ – o
     anel das expressões racionais canônicas (CRE) do Maxima, (e)
     ‘rationalfield’ – o corpo dos números racionais, (f) ‘runningerror’
     – rastro de todos os erros de arredondamento de números em ponto
     flutuante, (g) ‘noncommutingring’ – o anel de expressões do Maxima
     onde multiplicação for o operador ponto não comutativo.

     Quando o corpo for ‘floatfield’, ‘complexfield’, ou ‘runningerror’,
     o algorítmo usa pivotagem parcial; para todos os outros corpos,
     linhas são comutadas somente quando necessário para evitar um pivô
     nulo.

     A adição aritmética em ponto flutuante não é associativa, então o
     significado de ’corpo’ difere da definição matemática.

     Um membro do corpo ‘runningerror’ é uma lista do Máxima de dois
     membros da forma ‘[x,n]’,onde <x> é um número em onto flutuante e
     ‘n’ é um inteiro.  A diferença relativa entre o valor de
     ’verdadeiro’ de ‘x’ e ‘x’ é aproximadamente associado pelo épsilon
     da máquina vezes ‘n’.  O erro de execução associado arrasta alguns
     termos da ordem do quadrado do épsilon da máquina.

     Não existe interface de usuário definida um novo anel.  Um usuário
     que estiver familiazrizado com o Lisp Comum está apto para definir
     um novo corpo.  Para fazer isso, um usuário deve definir funções
     para as operações aritméticas e funções para conversão para a
     representação de corpo do Máxima e vice-versa.  Adicionalmente,
     para corpos ordenados (onde a pivotagem parcial será usada), um
     uduário deve definir funções para módulo e para comparar membros do
     corpo.  Após isso tudo que resta é definir uma estrutura de Lisp
     Comum ‘mring’.  O arquivo ‘mring’ tem muitos exemplos.

     Para calcular a fatorização, a primeira tarefa é converter cada
     entrada de matriz para um elemento do corpo indicado.  Quando a
     cnversão não for possível, a fatorização encerra com uma mensagem
     de erro.  Elementos do corpo não precisam ser expressões do Maxima.
     Elementos do ‘complexfield’, por exemplo, são números complexos do
     Lisp Comum.  Dessa forma após calcular a fatorização, como entradas
     da matriz devem ser convertidas para expressões do Maxima.

     Veja também ‘get_lu_factors’.

     Exemplos:
          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9) [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]

 -- Função: mat_cond (<M>, 1)
 -- Função: mat_cond (<M>, inf)

     Retorna o número condiciona da norma de ordem <p> da matriz <m>.
     Os valores permitidos para <p> são 1 e <inf>.  Essa função utiliza
     a fatorização linear alta para inverter a matriz <m>.  Dessa forma
     o tempode execução para ‘mat_cond’ é proporcional ao cubo do
     tamanho da matriz; ‘lu_factor’ determina as associaçãoes baixa e
     alta para o número de condição de norma infinita em tempo
     proporcional ao quadrado do tamanho da matriz.

 -- Função: mat_norm (<M>, 1)
 -- Função: mat_norm (<M>, inf)
 -- Função: mat_norm (<M>, frobenius)

     Retorna a matriz de norma <p> da matriz <M>.  Os valores permitidos
     para <p> são 1, ‘inf’, e ‘frobenius’ (a norma da matriz de
     Frobenius).  A matriz <M> pode ser uma matriz não de bloco.

 -- Função: matrixp (<e>, <p>)
 -- Função: matrixp (<e>)

     Fornecendo um argumento opcional <p>, ‘matrixp’ retorna ‘true’ se
     <e> for uma matriz e <p> avaliar para ‘true’ para todo elemento da
     matriz.  Quando a ‘matrixp’ não for fornecido umargumento opcional,
     retorna ‘true’ se ‘e’ for uma matriz.  em todos os outros casos,
     retorna ‘false’.

     Veja também ‘blockmatrixp’

 -- Função: matrix_size (<M>)

     Retorna uma lista com dois elementos que fornecem o número de
     linhas e colunas, respectivamente da matriz <M>.

 -- Função: mat_fullunblocker (<M>)

     Se <M> for uma matriz de bloco, expande todos os blocos da matriz
     em todos os níveis.  Se <M> for uma matriz, retorna <M>; de outra
     forma, emite uma mensagem de erro.

 -- Função: mat_trace (<M>)

     Retorna o traço da matriz <M>.  Se <M> não for uma matriz, retorna
     uma forma substantiva.  Quando <M> for uma matriz de bloco,
     ‘mat_trace(M)’ retorna o mesmo valor retornado por
     ‘mat_trace(mat_unblocker(m))’.

 -- Função: mat_unblocker (<M>)

     Se <M> for uma matriz de bloco, ‘mat_unbloker’ desfaz o bloco de
     <M> um nível.  Se <M> for uma matriz, ‘mat_unblocker (M)’ retorna
     <M>; de outra forma, emite uma mensagem de erro.

     Dessa forma se cada entrada de <M> for matriz, ‘mat_unblocker (M)’
     retorna uma matriz "desblocada", mas se cada entrada de <M> for uma
     matriz de bloco, ‘mat_unblocker (M)’ retorna uma matriz de bloco
     com um nível de bloco a menos.

     Se você usa matrizes de bloco, muito provavelmente você irá querer
     escolher ‘matrix_element_mult’ para ‘"."’ e
     ‘matrix_element_transpose’ para ‘'transpose’.  Veja também
     ‘mat_fullunblocker’.

     Exemplo:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]

 -- Função: nonnegintegerp (<n>)

     Retorna ‘true’ se e somente se ‘<n> >= 0’ e <n> for um inteiro.

 -- Função: nullspace (<M>)

     Se <M> for uma matriz, retorna ‘span (v_1, ..., v_n)’, onde o
     conjunto ‘{v_1, ..., v_n}’ é uma base para o espaço nulo de <M>.  A
     diferença entre o maior elemento e o menor elemento do conjunto
     vazio é ‘{0}’.  Dessa forma, quando o espaço nulo tiver somente um
     membro, retorna ‘span ()’.

 -- Função: nullity (<M>)

     Se <M> for uma matriz, retorna a dimensão do espaço nulo de <M>.

 -- Função: orthogonal_complement (<v_1>, ..., <v_n>)

     Retorna ‘span (u_1, ..., u_m)’, onde o conjunto ‘{u_1, ..., u_m}’ é
     uma base para o complemento ortogonal do conjunto ‘(v_1, ...,
     v_n)’.

     Cada vetor no intervalo de <v_1> até <v_n> deve ser um vetor
     coluna.

 -- Função: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Função: polynomialp (<p>, <L>, <coeffp>)
 -- Função: polynomialp (<p>, <L>)

     Retorna ‘true’ se <p> for um polinômio nas variáveis da lista <L>,
     O predicado <coeffp> deve avaliar para ‘true’ para cada
     coeficiente, e o predicado <exponp> deve avaliar para ‘true’ para
     todos os expoentes das variáveis na lista <L>.  Se você quiser usar
     um valor personalizado para <exponp>, você deve fornecer <coeffp>
     com um valor mesmo se você quiser o valor padrão para <coeffp>.

     ‘polynomialp (<p>, <L>, <coeffp>)’ é equivalente a ‘polynomialp
     (<p>, <L>, <coeffp>, 'nonnegintegerp)’.

     ‘polynomialp (<p>, <L>)’ é equivalente a ‘polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)’.

     O polinômio não precisa ser expandido:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     Um exemplo usando um valor personalizado para ‘coeffp’ e para
     ‘exponp’:

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o2)                         true

     Polinômios com duas variáveis:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true

 -- Função: polytocompanion (<p>, <x>)

     Se <p> for um polinômio em <x>, retorna a atriz companheira de <p>.
     Para um polinômio mônico <p> de grau <n>, temos ‘<p> = (-1)^<n>
     charpoly (polytocompanion (<p>, <x>))’.

     Quando <p> não for um polinômio em <x>, emite uma mensagem de erro.

 -- Função: ptriangularize (<M>, <v>)

     Se <M> for uma matriz onde cada entrada dessa matriz for um
     polinômio em <v>, retorna a matriz <M2> tal que

     (1) <M2> é triangular alta,

     (2) ‘<M2> = <E_n> ... <E_1> <M>’, onde os elemetnos de <E_1> a
     <E_n> são matrizes elementares cujas entrada são polinômios em <v>,

     (3) ‘|det (<M>)| = |det (<M2>)|’,

     Nota: Essa função não verifica se toda entrada é um polinômio em
     <v>.

 -- Função: rowop (<M>, <i>, <j>, <theta>)

     Se <M> for uma matriz, retorna a matriz que resulta de se fazer a
     operação de linha ‘R_i <- R_i - theta * R_j’.  Se <M> não tiver uma
     linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: rank (<M>)

     Retorna o ranque daquela matriz <M>.  O rank é a dimensão do espaço
     coluna.  Exemplo:
          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
           Proviso:  {d - b c # 0}
          (%o2)                                  2

 -- Função: rowswap (<M>, <i>, <j>)

     Se <M> for uma matriz, permuta as linha <i> e <j>.  Se <M> não
     tiver uma linha <i> ou <j>, emite uma mensagem de erro.

 -- Função: toeplitz (<col>)
 -- Função: toeplitz (<col>, <lin>)

     Retorna uma matriz de Toeplitz <T>.  a primeira coluna de <T> é
     <col>; exceto para a primeira entrada, a primeira linha de <T> é
     <lin>.  O padrão para <lin> é o conjugado complexo de <col>.
     Exemplo:
          (%i1)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]

 -- Função: vandermonde_matrix ([<x_1>, ..., <x_n>])

     Retorna uma matriz <n> por <n> cuja <i>-ésima linha é ‘[1, <x_i>,
     <x_i>^2, ... <x_i>^(<n>-1)]’.

 -- Função: zerofor (<M>)
 -- Função: zerofor (<M>, <fld>)

     Retorna uma matriz zero que tem o mesmo tamanho da matriz <M>.
     Toda entrada da matriz zero é a identidade aditiva do anel <fld>; o
     valor padrão para <fld> é <generalring>.

     O primeiro argumento <M> pode ser uma matriz quadrada ou uma não
     matriz.  Quando <M> for uma matriz, cada entrada de <M> pode ser
     uma matriz quadrada – dessa forma <M> pode ser uma matriz de bloco
     do Maxima.  A matriz pode ser de bloco para qualquer nível
     (finito).

     Veja também ‘identfor’

 -- Função: zeromatrixp (<M>)

     Se <M> não for uma matriz de bloco, retorna ‘true’ se ‘is (equal
     (<e>, 0))’ for verdadeiro para cada elemento <e> da matriz <M>.  Se
     <M> for uma matriz de bloco, retorna ‘true’ se ‘zeromatrixp’
     avaliar para ‘true’ para cada elemento de <e>.


File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

60 lsquares
***********

* Menu:

* Funções e Variáveis Definidas para lsquares::


File: maxima.info,  Node: Funções e Variáveis Definidas para lsquares,  Prev: lsquares,  Up: lsquares

60.1 Funções e Variáveis Definidas para lsquares
================================================

 -- Variável global: DETCOEF

     Essa variável é usada pelas funções ‘lsquares’ e ‘plsquares’ para
     armazenar o Coeficiente de Determinação que mede o melhor do
     ajuste.  Esse intervalo de 0 (nenhuma correlação) a 1 (correlação
     exata).

     Quando ‘plsquares’ for chamada com uma lista de variáveis
     independentes, <DETCOEF> é escolhida para uma lista de Coeficientes
     de Determinação.  Veja ‘plsquares’ para detalhes.

     Veja também ‘lsquares’.

 -- Função: lsquares (<Mat>,<VarList>,<equação>,<ParamList>)
 -- Função: lsquares
          (<Mat>,<VarList>,<equação>,<ParamList>,<EsperadosList>)
     Ajuste múltiplo de equações não lineares de uma tabela de dados
     pelo método dos "mínimos quadrados".  <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um para cada
     coluna de <Mat>), <equação> é a equação a ser ajustada (essa
     equação deve estar na forma: ‘depvar=f(indepvari,..., paramj,...)’,
     ‘g(depvar)=f(indepvari,..., paramj,...)’ ou na forma ‘g(depvar,
     paramk,...)=f(indepvari,..., paramj,...)’), <ParamList> é a lista
     de parâmetros para obter, e <EsperadosList> é uma lista opcional de
     aproximações iniciais para os parâmetros; quando esse último
     argumento estiver presente, ‘mnewton’ é usado em lugar de ‘solve’
     com o objetivo de pegar os parâmetros.

     A equação pode ser completamente não linear com relação às
     variáveis independentes e à variável dependente.  Com o objetivo de
     usar ‘solve()’, as equações devem ser lineares ou polinomiais com
     relação aos parâmetros.  Equações como ‘y=a*b^x+c’ podem ser
     ajustadas para ‘[a,b,c]’ com ‘solve’ se os valores de ‘x’ forem
     inteiros positivos pequenos e existam poucos dados (veja o exemplo
     em lsquares.dem).  ‘mnewton’ permite ajustar uma equação não linear
     com relação aos parâmetros, mas um bom conjunto de aproximações
     iniciais deve ser fornecido.

     Se possível, a equação ajustada é retornada.  Se existir mais de
     uma solução, uma lista de equações é retornada.  O Coeficiente de
     Determinação é mostrado para informar sobre o melhor do ajuste, de
     0 (nenhuma correlação) a 1 (correlação exata).  Esse valor é também
     armazenada na vriável global <DETCOEF>.

     Exemplos usando ‘solve’:
          (%i1) load("lsquares")$

          (%i2) lsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                         [x,y,z], z=a*x*y+b*x+c*y+d, [a,b,c,d]);
                Determination Coefficient = 1.0
                              x y + 23 y - 29 x - 19
          (%o2)           z = ----------------------
                                        6
          (%i3) lsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                         [n,p], p=a4*n^4+a3*n^3+a2*n^2+a1*n+a0,
                   [a0,a1,a2,a3,a4]);
                Determination Coefficient = 1.0
                               4       3      2
                            3 n  - 10 n  + 9 n  - 2 n
          (%o3)         p = -------------------------
                                        6
          (%i4) lsquares(matrix([1,7],[2,13],[3,25]),
                         [x,y], (y+c)^2=a*x+b, [a,b,c]);
                Determination Coefficient = 1.0
          (%o4) [y = 28 - sqrt(657 - 216 x),
                                          y = sqrt(657 - 216 x) + 28]
          (%i5) lsquares(matrix([1,7],[2,13],[3,25],[4,49]),
                         [x,y], y=a*b^x+c, [a,b,c]);
                Determination Coefficient = 1.0
                                        x
          (%o5)                  y = 3 2  + 1

     Exemplos usando ‘mnewton’:
          (%i6) load("lsquares")$

          (%i7) lsquares(matrix([1.1,7.1],[2.1,13.1],[3.1,25.1],[4.1,49.1]),
                         [x,y], y=a*b^x+c, [a,b,c], [5,5,5]);
                                                       x
          (%o7) y = 2.799098974610482 1.999999999999991
                                                  + 1.099999999999874
          (%i8) lsquares(matrix([1.1,4.1],[4.1,7.1],[9.1,10.1],[16.1,13.1]),
                         [x,y], y=a*x^b+c, [a,b,c], [4,1,2]);
                                       .4878659755898127
          (%o8) y = 3.177315891123101 x
                                                  + .7723843491402264
          (%i9) lsquares(matrix([0,2,4],[3,3,5],[8,6,6]),
                        [m,n,y], y=(A*m+B*n)^(1/3)+C, [A,B,C], [3,3,3]);
                                                               1/3
          (%o9) y = (3.999999999999862 n + 4.999999999999359 m)
                                                   + 2.00000000000012

     Para usar essa função escreva primeiro ‘load("lsquares")’.  Veja
     também ‘DETCOEF’ e ‘mnewton’.

 -- Função: plsquares (<Mat>,<VarList>,<depvars>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Função: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Ajuste de polinômios de várias variáveis de uma tabela de dados
     pelo método dos "mínimos quadrados".  <Mat> é uma matriz contendo
     os dados, <VarList> é uma lista de nomes de variáveis (um nome para
     cada coluna de Mat, mas use "-" em lugar de nomes de variáveis para
     colunas de Mat), <depvars> é o nome de uma variável dependente ou
     uma lista com um ou mais nomes de variáveis dependentes (os quais
     nomes podem estar em <VarList>), <maxexpon> é o expoente máximo
     opcional para cada variável independente (1 por padrão), e
     <maxdegree> é o argumento opcional grau máximo do polinômio
     (<maxexpon> por padrão); note que a soma dos expoentes de cada
     termo deve ser menor ou igual a <maxdegree>, e se ‘maxdgree = 0’
     então nenhum limite é aplicado.

     Se <depvars> é o nome de uma variável dependente (fora de uma
     lista), ‘plsquares’ retorna o polinômio ajustado.  Se <depvars> for
     uma lista de uma ou mais variáveis dependentes, ‘plsquares’ retorna
     uma lista com o(s) polinômio(s) ajustado(s).  Os Coeficientes de
     Determinação são mostrados com o objetivo de informar sobre o
     melhor do ajuste, cujo intervalo vai de 0 (nenhuma correlação) a 1
     (correlação exata).  Esses valores são também são também
     armazenados na variável global <DETCOEF> (uma lista se <depvars>
     for também uma lista).

     Um simples exemplo de ajuste linear de várias variáveis:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     O mesmo exemplo sem restrições de gra:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Quantas diagonais possi um polígono de N lados tem?  What
     polynomial degree should be used?
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonais],diagonais,5);
               Determination Coefficient for diagonais = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonais = --------
                                            2
          (%i5) ev(%, N=9);   /* Testando para um polígono de 9 lados - o eneágono */
          (%o5)                 diagonals = 27

     Quantos caminhos fazemos para colocar duas raínhas sem que elas
     estejam ameaçadas em um tabuleiro de xadrez n x n ?
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,posicoes],[posicoes],4);
               Determination Coefficient for [posicoes] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [posicoes  = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Tesando para um tabuleiro de (8 x 8) */
          (%o7)                posicoes = 1288

     Em exemplo com seis variáveis dependentes:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Para usar essa função escreva primeiramente ‘load("lsquares")’.


File: maxima.info,  Node: makeOrders,  Next: mnewton,  Prev: lsquares,  Up: Top

61 makeOrders
*************

* Menu:

* Funções e Variáveis Definidas para makeOrders::


File: maxima.info,  Node: Funções e Variáveis Definidas para makeOrders,  Prev: makeOrders,  Up: makeOrders

61.1 Funções e Variáveis Definidas para makeOrders
==================================================

 -- Função: makeOrders (<indvarlist>,<orderlist>)
     Retorna uma lista de todos os expoentes para um polinômio acima de
     e incluindo os argumentos.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     onde ‘[0, 1]’ está associado ao termo b e ‘[2, 3]’ está associado
     ao termo a^2 b^3.

     Para usar essa função escreva primeiro ‘load("makeOrders")’.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: makeOrders,  Up: Top

62 mnewton
**********

* Menu:

* Funções e Variáveis Definidas para mnewton::


File: maxima.info,  Node: Funções e Variáveis Definidas para mnewton,  Prev: mnewton,  Up: mnewton

62.1 Funções e Variáveis Definidas para mnewton
===============================================

 -- Variável de opção: newtonepsilon
     Valor padrão: ‘10.0^(-fpprec/2)’

     Precisão para determinar quando a função ‘mnewton’ convergiu em
     direção à solução.

     Veja também ‘mnewton’.

 -- Variável de opção: newtonmaxiter
     Valor padrão: ‘50’

     Número máximo de iterações que para a função ‘mnewton’ caso essa
     função não seja convergente ou se convergir muito lentamente.

     Veja também ‘mnewton’.

 -- Função: mnewton (<FuncList>,<VarList>,<GuessList>)
     Solução de multiplas funções não lineares usando o método de
     Newton.  <FuncList> é a lista de funções a serem resolvidas,
     <VarList> é a lista dos nomes de variáveis, e <GuessList> é a lista
     de aproximações iniciais.

     A solução é retornada no mesmo formato retornado pela função
     ‘solve()’.  Caso a solução não seja encontrada, ‘[]’ é retornado.

     Essa função é controlada através das variáveis globais
     ‘newtonepsilon’ e ‘newtonmaxiter’.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     Para usar essa função primeiro escreva ‘load("mnewton")’.  Veja
     também ‘newtonepsilon’ e ‘newtonmaxiter’.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

63 numericalio
**************

* Menu:

* Introdução a numericalio::
* Funções e Variáveis Definidas para numericalio::


File: maxima.info,  Node: Introdução a numericalio,  Next: Funções e Variáveis Definidas para numericalio,  Prev: numericalio,  Up: numericalio

63.1 Introdução a numericalio
=============================

‘numericalio’ é uma coleção de funções para ler e escrever arquivos de
dados.  O arquivo é lido completamente para construir um objeto;
leituras parciais não são suportadas.

   É assumido que cada item a ler ou escrever é atômico: um número
inteiro, número em ponto flutuante, grande número em ponto flutuante,
seqüência de caracteres, ou símbolo, e não um número racional ou um
número complexo ou qualquer outro tipo de expressão não atômica.  Essas
funções podem tentar fazer alguma coisa levemente parecida com
expressões não atômicas, mas os resultados não são especificados aqui e
são sujeitos a mudanças.

   Átomos em ambos os arquivos de entrada e saída possuem o mesmo
formato que em arquivos de lote do Maxima ou no console interativo.  Em
particular, seqüência de caracteres são contidas dentro de aspas duplas,
contrabarra ‘\’ evita qualquer interpretação especial do caractere
seguinte, e o ponto de interrogação ‘?’ é reconhecido no início de um
símbolo para significar um símbolo do Lisp (em oposição a um símbolo do
Maxima).  Nenhum caractere de continuação (para continuar linhas
quebradas) é reconhecido.

   <separator_flag> diz que caracteres separa elementos.
<separator_flag> é um argumento opcional para todas as funções de
leitura e escrita.

   Para entrada, os valores de <separator_flag> reconhecidos são:
‘comma’ para valores separados por vírgula, ‘pipe’ para valores
separados pelo caractere barra vertical ‘|’, ‘semicolon’ para valores
separados por ponto e vírgula ‘;’, e ‘space’ para valores separados
pelos caracteres de espaço e de tabulação.  Se o nome do arquivo a ser
lido/escrito termina em ‘.csv’ e <separator_flag> não for especificado,
‘comma’ é assumido.  Se o nome do arquivo termina em alguma outra coisa
que não ‘.csv’ e ‘separator_flag’ não for especificado, ‘space’ é
assumido.

   Para saída, os mesmos quatro sinalizadores são reconhecidos como na
entrada, e também ‘tab’, para valores separados pelo caractere de
tabulaçao.

   Em entrada, múltiplos espaços e multiplas tabulações sucessivas
contam como um separador simples.  Todavia, múltiplas vírgulas, barras
verticais, ou ponto-e-vírgulas são significativos.  Sucessivas vírgulas,
barras verticais, ou ponto-e-vírgulas (com ou sem intercalação de
espaços ou tabulações) são considerados como tendo ‘false’ entre os
separadores.  Por exemplo, ‘1234,,Foo’ é tratado da mesma forma que
‘1234,false,Foo’.  Em saídas, os átomos ‘false’ são escritos como tais;
uma lista ‘[1234, false, Foo]’ é escrita ‘1234,false,Foo’, e não é
tentado colapsar a saída para ‘1234,,Foo’.


File: maxima.info,  Node: Funções e Variáveis Definidas para numericalio,  Prev: Introdução a numericalio,  Up: numericalio

63.2 Funções e Variáveis Definidas para numericalio
===================================================

 -- Função: read_matrix (<nomearquivo>)
 -- Função: read_matrix (<nomearquivo>, <separator_flag>)
     Lê o arquivo <nomearquivo> e retorna seu conteúdo completo como uma
     matriz.  Se <separator_flag> não for especificado, o arquivo é
     assumido como delimitado por espaços em branco.

     ‘read_matrix’ infere o tamanho da matriz dos dados de entrada.
     Cada linha do arquivo inicia uma linha da matriz.  Se algumas
     linhas possuirem diferentes comprimentos, ‘read_matrix’ reclama.

 -- Função: read_lisp_array (<nomearquivo>, <A>)
 -- Função: read_lisp_array (<nomearquivo>, <A>, <separator_flag>)

     ‘read_lisp_array’ exige que o array seja declarado através de
     ‘make_array’ antes de chamar a função de leitura.  (Isso obviamente
     é necessário para inferir a dimensão do array, que pode ser um
     problema para arrays com múltiplas dimensões.)

     ‘read_lisp_array’ não verifica para ver se o arquivo de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando ‘fillarray’.

 -- Função: read_maxima_array (<nomearquivo>, <A>)
 -- Função: read_maxima_array (<nomearquivo>, <A>, <separator_flag>)

     ‘read_maxima_array’ requer que o array seja declarado através de
     ‘array’ antes de chamar a função de leitura.  (Isso obviamente é
     necessário para inferir a dimensão do array, que pode ser uma
     hassle para arrays com múltiplas dimensões.)

     ‘read_maxima_array’ não verifica para ver se o arquivo de entrada
     está de acordo com as dimensãoes do array; a entrada é lida como
     uma lista monótona, então o array é preenchido usando ‘fillarray’.

 -- Função: read_hashed_array (<nomearquivo>, <A>)
 -- Função: read_hashed_array (<nomearquivo>, <A>, <separator_flag>)

     ‘read_hashed_array’ trata o primeiro item sobre uma linha como uma
     chave hash, e associa o restante da linha (como uma lista) com a
     chava.  Por exemplo, a linha ‘567 12 17 32 55’ é equivalente a
     ‘A[567]: [12, 17, 32, 55]$’.  Linhas não precisam ter o mesmo
     número de elementos.

 -- Função: read_nested_list (<nomearquivo>)
 -- Função: read_nested_list (<nomearquivo>, <separator_flag>)

     ‘read_nested_list’ retorna uma lista que tem uma sublista para cada
     linha de entrada.  Linhas não precisam ter o mesmo número de
     elementos.  Linhas vazias não são ignoradas: uma linha vazia
     retorna uma sublista vazia.

 -- Função: read_list (<nomearquivo>)
 -- Função: read_list (<nomearquivo>, <separator_flag>)

     ‘read_list’ lê todas as entradas em uma lista monótona.
     ‘read_list’ ignora o caractere de fim de linha.

 -- Função: write_data (<X>, <nomearquivo>)
 -- Função: write_data (<object>, <nomearquivo>, <separator_flag>)

     ‘write_data’ escreve o objeto <X> no arquivo <nomearquivo>.

     ‘write_data’ escreve matrizes da forma usual, com uma linha por
     fileira.

     ‘write_data’ escreve arrays declarados do Lisp e do Maxima da forma
     usual, com um caractere de nova linha no final de todo pedaço.
     Pedaços dimensionais muito grandes são separados por meio de novas
     linhas adicionais.

     ‘write_data’ escreve arrays desordenados com uma chave seguida por
     a lista associada sobre cada linha.

     ‘write_data’ escreve a lista seguinte com cada sublista em uma
     linha.

     ‘write_data’ escreve uma lista monótona toda em uma linha.

     Se ‘write_data’ anexa ao final ou abandona os excessos em seus
     arquivos de saída é governado através da variável global
     ‘file_output_append’.


File: maxima.info,  Node: opsubst,  Next: orthopoly,  Prev: numericalio,  Up: Top

64 opsubst
**********

* Menu:

* Funções e Variáveis Definidas para  opsubst::


File: maxima.info,  Node: Funções e Variáveis Definidas para opsubst,  Prev: opsubst,  Up: opsubst

64.1 Funções e Variáveis Definidas para opsubst
===============================================

 -- Função: opsubst (<f>,<g>,<e>)
 -- Função: opsubst (<g>=<f>,<e>)
 -- Função: opsubst ([<g1>=<f1>,<g2>=<f2>,..., <gn>=<fn>],<e>)
     A função ‘opsubst’ similar à função ‘subst’, exceto que ‘opsubst’
     somente faz substituições para as operações em uma expressões.  Em
     geral, quando <f> for um operador em uma expressão <e>, substitui
     <g> por <f> na expressão <e>.

     Para determinar o operador, ‘opsubst’ escolhe ‘inflag’ para
     verdadeiro ( true ).  Isso significa que ‘opsubst’ substitui para a
     forma de operador interna, não para a mostrada, na expressão.

     Exemplos:
          (%i1) load ("opsubst")$

          (%i2) opsubst(f,g,g(g(x)));
          (%o2)                     f(f(x))
          (%i3) opsubst(f,g,g(g));
          (%o3)                       f(g)
          (%i4) opsubst(f,g[x],g[x](z));
          (%o4)                       f(z)
          (%i5) opsubst(g[x],f, f(z));
          (%o5)                      g (z)
                                      x
          (%i6) opsubst(tan, sin, sin(sin));
          (%o6)                     tan(sin)
          (%i7) opsubst([f=g,g=h],f(x));
          (%o7)                       h(x)

     Internamente, Maxima não usa os operadores de negação unária,
     divisão, ou de subtração; dessa forma:
          (%i8) opsubst("+","-",a-b);
          (%o8)                     a - b
          (%i9) opsubst("f","-",-a);
          (%o9)                      - a
          (%i10) opsubst("^^","/",a/b);
                                       a
          (%o10)                       -
                                       b

     A representação interna de -a*b é *(-1,a,b); dessa forma
          (%i11) opsubst("[","*", -a*b);
          (%o11)                  [- 1, a, b]

     Quando o operador não for um símbolo Maxima, geralmente alguma
     outra função sinalizará um erro:
          (%i12) opsubst(a+b,f, f(x));

          Improper name or value in functional position:
          b + a
           -- an error.  Quitting.  To debug this try debugmode(true);

     Todavia, operadores subscritos são permitidos:
          (%i13) opsubst(g[5],f, f(x));
          (%o13)                     g (x)
                                      5

     Para usar essa função escreva primeiramente ‘load("opsubst")’.


File: maxima.info,  Node: orthopoly,  Next: plotdf,  Prev: opsubst,  Up: Top

65 orthopoly
************

* Menu:

* Introdução a polinômios ortogonais::
* Funções e Variáveis Definidas para polinômios ortogonais::


File: maxima.info,  Node: Introdução a polinômios ortogonais,  Next: Funções e Variáveis Definidas para polinômios ortogonais,  Prev: orthopoly,  Up: orthopoly

65.1 Introdução a polinômios ortogonais
=======================================

‘orthopoly’ é um pacote para avaliação simbólica e numérica de muitos
tipos de polinômios ortogonais, incluindo polinômios de Chebyshev,
Laguerre, Hermite, Jacobi, Legendre, e ultraesférico (Gegenbauer).
Adicionalmentey, ‘orthopoly’ inclui suporte funções esféricas segundo o
critério de Bessel, esféricas segundo o critério de Hankel, e funções
harmônica esféricas.

   Em sua maior parte, ‘orthopoly’ segue as convenções de Abramowitz e
Stegun Handbook of Mathematical Functions, Chapter 22 (10th printing,
December 1972); adicionalmente, usamos Gradshteyn e Ryzhik, Table of
Integrals, Series, and Products (1980 corrected and enlarged edition), e
Eugen Merzbacher Quantum Mechanics (2nd edition, 1970).

   Barton Willis da University de Nebraska e Kearney (UNK) escreveu o
pacote ‘orthopoly’ e sua documetação.  O pacote é liberado segundo a
licença pública geral GNU (GPL).

65.1.1 Iniciando com orthopoly
------------------------------

‘load ("orthopoly")’ torna o pacote ‘orthopoly’ disponível para uso.

   Para encontrar o polinômio de Legendre de terceira ordem,

     (%i1) legendre_p (3, x);
                           3             2
                  5 (1 - x)    15 (1 - x)
     (%o1)      - ---------- + ----------- - 6 (1 - x) + 1
                      2             2

   Para expressar esse polinômio como uma soma de potências de <x>,
aplique <ratsimp> ou <rat> para o resultado anterior.

     (%i2) [ratsimp (%), rat (%)];
                             3           3
                          5 x  - 3 x  5 x  - 3 x
     (%o2)/R/            [----------, ----------]
                              2           2

   Alternativamente, faça o segundo argumento para ‘legendre_p’ (sua
variável “principal”) uma expressão racional canônica (CRE) usando
‘rat(x)’ em lugar de somente ‘x’.

     (%i1) legendre_p (3, rat (x));
                                   3
                                5 x  - 3 x
     (%o1)/R/                   ----------
                                    2

   Para avaliação em ponto flutuante, ‘orthopoly’ usa uma análise de
erro durante a execução para estimar uma associação superior para o
erro.  Por exemplo,

     (%i1) jacobi_p (150, 2, 3, 0.2);
     (%o1) interval(- 0.062017037936715, 1.533267919277521E-11)

   intervalos possuem a forma ‘interval (<c>, <r>)’, onde <c> é o centro
e <r> é o raio do intervalo.  Uma vez que Maxima não suporta aritmética
sobre intervalos, em algumas situações, tais como em gráficos, você vai
querer suprimir o erro e sair somente com o centro do intervalo.  Para
fazer isso, escolha a variável de opção ‘orthopoly_returns_intervals’
para ‘false’.

     (%i1) orthopoly_returns_intervals : false;
     (%o1)                         false
     (%i2) jacobi_p (150, 2, 3, 0.2);
     (%o2)                  - 0.062017037936715

   Veja a seção *note Avaliação em Ponto Flutuante:: para maiores
informaçõesfor more information.

   Muitas funções em ‘orthopoly’ possuem uma propriedade ‘gradef’; dessa
forma

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (gen_laguerre (n, a, x), x);
                   (a)               (a)
                n L   (x) - (n + a) L     (x) unit_step(n)
                   n                 n - 1
     (%o2)      ------------------------------------------
                                    x

   A função de um único passo no segundo exemplo previne um erro que
poderia de outra forma surgir através da avaliação de <n> para 0.

     (%i3) ev (%, n = 0);
     (%o3)                           0

   A propriedade ‘gradef’ somente aplica para a variável “principal”;
dderivadas com relação a outros argumentos usualmente resultam em uma
mensagem de erro; por exemplo

     (%i1) diff (hermite (n, x), x);
     (%o1)                     2 n H     (x)
                                    n - 1
     (%i2) diff (hermite (n, x), n);

     Maxima doesn't know the derivative of hermite with respect the first argument
      -- an error.  Quitting.  To debug this try debugmode(true);

   Geralmente, funções em ‘orthopoly’ mapeiam sobre listas e matrizes.
Para o mapeamento para avaliação total, as variáveis de opção
‘doallmxops’ e ‘listarith’ devem ambas serem ‘true’ (o valor padrão).
Para ilustrar o mapeamento sobre matrizes, considere

     (%i1) hermite (2, x);
                                          2
     (%o1)                    - 2 (1 - 2 x )
     (%i2) m : matrix ([0, x], [y, 0]);
                                 [ 0  x ]
     (%o2)                       [      ]
                                 [ y  0 ]
     (%i3) hermite (2, m);
                    [                             2  ]
                    [      - 2        - 2 (1 - 2 x ) ]
     (%o3)          [                                ]
                    [             2                  ]
                    [ - 2 (1 - 2 y )       - 2       ]

   No segundo exemplo, o elemento ‘i, j’ do valor é ‘hermite (2,
m[i,j])’; isso não é o mesmo que calcular ‘-2 + 4 m . m’, como visto no
próximo exemplo.

     (%i4) -2 * matrix ([1, 0], [0, 1]) + 4 * m . m;
                         [ 4 x y - 2      0     ]
     (%o4)               [                      ]
                         [     0      4 x y - 2 ]

   Se você avaliar uma função em um ponto fora do seu domínio,
geralmente ‘orthopoly’ retorna uma função não avaliada.  Por exemplo,

     (%i1) legendre_p (2/3, x);
     (%o1)                        P   (x)
                                   2/3

   ‘orthopoly’ suporta tradução em TeX; ‘orthopoly’ também faz saídas
bidimensionais em um terminal.

     (%i1) spherical_harmonic (l, m, theta, phi);
                               m
     (%o1)                    Y (theta, phi)
                               l
     (%i2) tex (%);
     $$Y_{l}^{m}\left(\vartheta,\varphi\right)$$
     (%o2)                         false
     (%i3) jacobi_p (n, a, a - b, x/2);
                               (a, a - b) x
     (%o3)                    P          (-)
                               n          2
     (%i4) tex (%);
     $$P_{n}^{\left(a,a-b\right)}\left({{x}\over{2}}\right)$$
     (%o4)                         false

65.1.2 Limitations
------------------

Quando uma expressão envolve muitos polinômios ortogonais com ordens
simbólicas, é possível que a expressão atualmente tenda para zero, e
ainda ocorre também que Maxima estar incapacitado de simplificar essa
expressão para zero.  Se você faz uma divisão por tal quantidade que
tende a zero, você pode estar em apuros.  Por exemplo, a seguinte
expressão tende para zero para inteiros <n> maiores que 1, e ainda
ocorre também que Maxima está incapacitado de simplificar essa expressão
para zero.

     (%i1) (2*n - 1) * legendre_p (n - 1, x) * x - n * legendre_p (n, x) + (1 - n) * legendre_p (n - 2, x);
     (%o1)  (2 n - 1) P     (x) x - n P (x) + (1 - n) P     (x)
                       n - 1           n               n - 2

   Para um <n> específico, podemos reduzir a expressão a zero.

     (%i2) ev (% ,n = 10, ratsimp);
     (%o2)                           0

   Geralmente, a forma polinomial de um polinômio ortogonal esteja
adequada de forma hostil para avaliaçao em ponto flutuante.  Aqui está
um exemplo.

     (%i1) p : jacobi_p (100, 2, 3, x)$

     (%i2) subst (0.2, x, p);
     (%o2)                3.4442767023833592E+35
     (%i3) jacobi_p (100, 2, 3, 0.2);
     (%o3)  interval(0.18413609135169, 6.8990300925815987E-12)
     (%i4) float(jacobi_p (100, 2, 3, 2/10));
     (%o4)                   0.18413609135169

   O verdadeiro valor está em torno de 0.184; ess calculo suporta erro
de cancelamento por extremo subtrativo.Expandindo o polinômio e então
avaliando, fornecendo um melhor resultado.
     (%i5) p : expand(p)$
     (%i6) subst (0.2, x, p);
     (%o6) 0.18413609766122982

   Essa não é uma regra geral; expandindo o polinômio não resulta sempre
em expressões que são melhores adaptadas a avaliação numérica.  Com
grande folga, o melhor caminho para fazer avaliação numérica é fazer um
ou mais argumentos da função serem números em ponto flutuante.  Em
função disso, algorítmos especializados em ponto flutuante são usados
para avaliação.

   A função ‘float’ do Maxima é até certo ponto indiscriminada; se você
aplicar ‘float’ a uma expressão envolvendo um polinômio ortogonal com um
grau simbólico ou um parâmetro de ordem, esses parâmetos (inteiros)
podem ser convertido em números em ponto flutuante; após o que, a
expressão não irá avaliar completamente.  Considere

     (%i1) assoc_legendre_p (n, 1, x);
                                    1
     (%o1)                         P (x)
                                    n
     (%i2) float (%);
                                   1.0
     (%o2)                        P   (x)
                                   n
     (%i3) ev (%, n=2, x=0.9);
                                  1.0
     (%o3)                       P   (0.9)
                                  2

   A expressão em (%o3) não irá avaliar para um número em ponto
flutuante; ‘orthopoly’ não reconhece valores em ponto flutuante em
lugares onde deve haver valores inteiros.  Similarmente, avaliação
numérica da função ‘pochhammer’ para ordens que excedam
‘pochhammer_max_index’ pode ser perturbador; considere

     (%i1) x :  pochhammer (1, 10), pochhammer_max_index : 5;
     (%o1)                         (1)
                                      10

   Aplicando ‘float’ não avalia <x> para um número em ponto flutuante

     (%i2) float (x);
     (%o2)                       (1.0)
                                      10.0

   Para avaliar <x> para um número em ponto flutuante, você irá precisar
associar ‘pochhammer_max_index’ a 11 ou mais e aplicar ‘float’ a <x>.

     (%i3) float (x), pochhammer_max_index : 11;
     (%o3)                       3628800.0

   O valor padrão de ‘pochhammer_max_index’ é 100; modifique esse valor
após chama ‘orthopoly’.

   Finalmente, tenha consciência que os livros citados nas referências
adotam diferentes definições de polinômios ortogonais; geralmente
adotamos as convenções citadas nas convenções de Abramowitz e Stegun.

   Antes de você suspeitar de um erro no pacote ‘orthopoly’, verifique
alguns casos especiais para determinar se suas definições coincidem com
aquelas usadas por ‘orthopoly’.  Definitions muitas vezes diferem por
uma normalização; ocasionalmente, autores utilizam versões “modificadas”
das funções que fazem a família ortogonal sobre um intervalo diferente
do intervalo (-1, 1).  Para definir, por exemplo, um polinômio de
Legendre que é ortogonal a (0, 1), defina

     (%i1) shifted_legendre_p (n, x) := legendre_p (n, 2*x - 1)$

     (%i2) shifted_legendre_p (2, rat (x));
                                 2
     (%o2)/R/                 6 x  - 6 x + 1
     (%i3) legendre_p (2, rat (x));
                                    2
                                 3 x  - 1
     (%o3)/R/                    --------
                                    2

65.1.3 Avaliação em Ponto Flutuante
-----------------------------------

Muitas funções em ‘orthopoly’ utilizam análise de erro durante a
execução para estimar o erro em avaliações em ponto flutuante; as
exceções são funções de Bessel esféricas e os polinômios associados de
Legendre do segundo tipo.  Para avaliações numéricas, as funções de
Bessel esféricas chamam funções da coleção de programas ‘SLATEC’.
Nenhum método especializado é usado para avaliação numérica dos
polinômios associados de Legendre do segundo tipo.

   A análise de erro durante a execução ignora erros que são de segunda
ordem ou maior na máquina (também conhecida como perda de algarismos).
A análise de erro durante a execução também ignora alguns poucos outros
tipos de erro.  É possível (embora não provável) que o erro atual exceda
o estimado.

   Intervalos possuem a forma ‘interval (<c>, <r>)’, onde <c> é o centro
do intervalo e <r> é seu raio.  O centro de um intervalo pode sr um
número complexo, e o raio é sempre um número real positivo.

   Aqui está um exemplo.

     (%i1) fpprec : 50$

     (%i2) y0 : jacobi_p (100, 2, 3, 0.2);
     (%o2) interval(0.1841360913516871, 6.8990300925815987E-12)
     (%i3) y1 : bfloat (jacobi_p (100, 2, 3, 1/5));
     (%o3) 1.8413609135168563091370224958913493690868904463668b-1

   Vamos testar o quanto o erro atual é é menor que o erro estimado

     (%i4) is (abs (part (y0, 1) - y1) < part (y0, 2));
     (%o4)                         true

   Realmente, por esse exemplo o erro estimado é um maior que o erro
verdadeiro.

   Maxima não suporta aritmética sobre intervalos.

     (%i1) legendre_p (7, 0.1) + legendre_p (8, 0.1);
     (%o1) interval(0.18032072148437508, 3.1477135311021797E-15)
             + interval(- 0.19949294375000004, 3.3769353084291579E-15)

   Um usuário pode definir operadores aritméticos que fazem matemática
de intervalos.  Para definir adição de intervalos, podemos definir

     (%i1) infix ("@+")$

     (%i2) "@+"(x,y) := interval (part (x, 1) + part (y, 1), part (x, 2) + part (y, 2))$

     (%i3) legendre_p (7, 0.1) @+ legendre_p (8, 0.1);
     (%o3) interval(- 0.019172222265624955, 6.5246488395313372E-15)

   As rotinas eseciais em ponto flutuante são chamadas quando os
argumentos forem complexos.  Por exemplo,

     (%i1) legendre_p (10, 2 + 3.0*%i);
     (%o1) interval(- 3.876378825E+7 %i - 6.0787748E+7,
                                                1.2089173052721777E-6)

   Let’s compare this to the true value.

     (%i1) float (expand (legendre_p (10, 2 + 3*%i)));
     (%o1)          - 3.876378825E+7 %i - 6.0787748E+7

   Adicionalmente, quando os argumentos forem grandes números em ponto
flutuante, as rotinas especiais de ponto flutuante são chamadas;
todavia, tos grandes números em ponto flutuante são convertidos para
números em ponto flutuante de dupla precisão e o resultado final é
número em ponto flutuante de precisão dupla.

     (%i1) ultraspherical (150, 0.5b0, 0.9b0);
     (%o1) interval(- 0.043009481257265, 3.3750051301228864E-14)

65.1.4 Gráficos e ‘orthopoly’
-----------------------------

Para montar gráficos de expressões que envolvem polinômios ortogonais,
você deve azer duas coisas:
  1. Escolher a variável de opção ‘orthopoly_returns_intervals’ para
     ‘false’,
  2. Colocar apóstrofo em qualquer chamada a funções do pacote
     ‘orthopoly’.
   Se chamadas a funções não receberem apóstrofo, Maxima irá avaliá-las
para polinômios antes de montar o gráfico; conseqüêntemente, as rotinas
especializadas em ponto flutuante não serão chamadas.  Aqui está um
exemplo de como montar o gráfico de uma expressão que envolve um
polinômio de Legendre.

     (%i1) plot2d ('(legendre_p (5, x)), [x, 0, 1]), orthopoly_returns_intervals : false;
     (%o1)

   A expressão completa ‘legendre_p (5, x)’ recebe apóstrofo; isso é
diferente de apenas colocar apóstrofo no nome da função usando
‘'legendre_p (5, <x>)’.

65.1.5 Funções Diversas
-----------------------

O pacote ‘orthopoly’ define o síbolo de Pochhammer e uma função de passo
de unidade.  ‘orthopoly’ utiliza a função delta de Kronecker e a função
de passo de unidade em declarações ‘gradef’.

   Para converter os símbolos Pochhammer em quocientes da funções gama,
use ‘makegamma’.

     (%i1) makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) makegamma (pochhammer (1/2, 1/2));
                                     1
     (%o2)                       ---------
                                 sqrt(%pi)

   Derivadas de símbolos de Pochhammer são fornecidas em termos de ‘psi’
function.

     (%i1) diff (pochhammer (x, n), x);
     (%o1)             (x)  (psi (x + n) - psi (x))
                          n     0             0
     (%i2) diff (pochhammer (x, n), n);
     (%o2)                   (x)  psi (x + n)
                                n    0

   Vocêprecisa ser cuidadoso com expressões como (%o1); a diferença das
funções ‘psi’ possuem polinômios quando ‘<x> = -1, -2, .., -<n>’.  Esses
polinômios cacelam-se com fatores em ‘pochhammer (<x>, <n>)’ fazendo da
derivada um polinômio de grau ‘<n> - 1’ quando <n> for um inteiro
positivo.

   O símbolo de Pochhammer é definido de ordens negativas até sua
representação como um quociente de funções gama.  Considere

     (%i1) q : makegamma (pochhammer (x, n));
                               gamma(x + n)
     (%o1)                     ------------
                                 gamma(x)
     (%i2) sublis ([x=11/3, n= -6], q);
                                    729
     (%o2)                        - ----
                                    2240

   Alternativamente, podemos tomar ese resultado diretamente.

     (%i1) pochhammer (11/3, -6);
                                    729
     (%o1)                        - ----
                                    2240

   A função passo de unidade é contínua à esquerda; dessa forma

     (%i1) [unit_step (-1/10), unit_step (0), unit_step (1/10)];
     (%o1)                       [0, 0, 1]

   Se você precisa de uma função de unidade de passo que é ou contínua à
esquerda ou contínua à direita em zero, defina sua própria função de
unidade de passo usando ‘signum’; por exemplo,

     (%i1) xunit_step (x) := (1 + signum (x))/2$

     (%i2) [xunit_step (-1/10), xunit_step (0), xunit_step (1/10)];
                                     1
     (%o2)                       [0, -, 1]
                                     2

   Não redefina a própria ‘unit_step’; alguns código em ‘orthopoly’
requerem que a função de passo de unidade seja contínua à esquerda.

65.1.6 Algorítmos
-----------------

Geralmente, ‘orthopoly’ faz avaliações simbólicas pelo uso de uma
representação hipergeométrica de polinômios ortogonais.  As funções
hipegeométricas são avaliadas usando as funções (não documetadas)
‘hypergeo11’ e ‘hypergeo21’.  As excessões são as funções de Bessel
metade inteiras e a função de Legendre associada de segundo tipo.  As
funções de Bessel metade inteiras são avaliadas usando uma representação
explícita, e a função de Legendre associada de segundo tipo é avaliada
usando recursividade.

   Para avaliação em ponto flutuante, nós novamente convertemos muitas
fuções em uma forma hipergeométrica; nós avaliamos as funções
hipergeométricas usando recursividade para frente.  Novamente, as
excessões são as funções de Bessel metade inteiras e a função de
Legendre associada de segundo tipo.  Numericamente, as funções de Bessel
meio inteiras são avaliadas usando o código SLATEC.


File: maxima.info,  Node: Funções e Variáveis Definidas para polinômios ortogonais,  Prev: Introdução a polinômios ortogonais,  Up: orthopoly

65.2 Funções e Variáveis Definidas para polinômios ortogonais
=============================================================

 -- Função: assoc_legendre_p (<n>, <m>, <x>)
     As funções de Legendre associadas de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 22.5.37, página 779,
     8.6.6 (segunda equação), página 334, e 8.2.5, página 333.

 -- Função: assoc_legendre_q (<n>, <m>, <x>)
     A função de Legendre associada de segundo tipo.

     Referência: Abramowitz e Stegun, equação 8.5.3 e 8.1.8.

 -- Função: chebyshev_t (<n>, <x>)
     A função de Chebyshev de primeiro tipo.

     Referência: Abramowitz e Stegun, equação 22.5.47,página 779.

 -- Função: chebyshev_u (<n>, <x>)
     A função de Chebyshev do segundo tipo.

     Referência: Abramowitz e Stegun, equação 22.5.48,página 779.

 -- Função: gen_laguerre (<n>, <a>, <x>)
     O poliômio generalizado de Laguerre.

     Referência: Abramowitz e Stegun, equação 22.5.54,página 780.

 -- Função: hermite (<n>, <x>)
     O polinômio de Hermite.

     Referência: Abramowitz e Stegun, equação 22.5.55,página 780.

 -- Função: intervalp (<e>)
     Retorna ‘true’ se a entrada for um intervalo e retorna ‘false’ se
     não for.

 -- Função: jacobi_p (<n>, <a>, <b>, <x>)
     o polinômio de Jacobi.

     Os polinômios de Jacobi são atualmente definidos para todo <a> e
     <b>; todavia, o peso do polinômio de Jacobi ‘(1 - <x>)^<a> (1 +
     <x>)^<b>’ não é integrável para ‘<a> <= -1’ ou ‘<b> <= -1’.

     Referência: Abramowitz e Stegun, equação 22.5.42,página 779.

 -- Função: laguerre (<n>, <x>)
     O polinômio de Laguerre.

     Referência: Abramowitz e Stegun, equatções 22.5.16 e 22.5.54,página
     780.

 -- Função: legendre_p (<n>, <x>)
     O polinômio de Legendre de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 22.5.50 e 22.5.51,página
     779.

 -- Função: legendre_q (<n>, <x>)
     O polinômio de Legendre de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 8.5.3 e 8.1.8.

 -- Função: orthopoly_recur (<f>, <args>)
     Retorna uma relação recursiva para a família de funções ortogonais
     <f> com argumentos <args>.  A recursividade é com relação ao grau
     do polinômio.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                          (2 n - 1) P     (x) x + (1 - n) P     (x)
                                     n - 1                 n - 2
          (%o1)   P (x) = -----------------------------------------
                   n                          n

     O segundo argumento a ‘orthopoly_recur’ deve ser uma lista com o
     número correto de argumentos para a função <f>; se o número de
     argumetnos não for o correto, Maxima sinaliza com um erro.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Adicionalmente, quando <f> não for o nome de uma das famílias de
     polinômios ortogonais, um erro é sinalizado.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable: orthopoly_returns_intervals
     Valor padrão: ‘true’

     Quando ‘orthopoly_returns_intervals’ for ‘true’, resultados em
     ponto flutuante são retornados na forma ‘interval (<c>, <r>)’, onde
     <c> é o centro de um intervalo e <r> é seu raio.  O centro pode ser
     um número complexo; nesse caso, o intervalo é um disco no plano
     complexo.

 -- Função: orthopoly_weight (<f>, <args>)

     Retorna uma lista de três elementos; o primeiro elemento é a
     fórmula do peso para a família de polinômios ortogonais <f> com
     argumentos fornecidos pela lista <args>; os segundos e terceiros
     elementos fornecem os pontos finais inferior e superior do
     intervalo de ortogonalidade.  Por exemplo,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate (w[1] * hermite (3, x) * hermite (2, x), x, w[2], w[3]);
          (%o2)                           0

     A variável principal de <f> deve ser um símbolo; Se não for, Maxima
     sinaliza com um erro.

 -- Função: pochhammer (<n>, <x>)
     O símbolo de Pochhammer.  Para inteiros não negativos <n> com ‘<n>
     <= pochhammer_max_index’, a expressão ‘pochhammer (<x>, <n>)’
     avalia para o produto ‘<x> (<x> + 1) (<x> + 2) ... (<x> + n - 1)’
     when ‘<n> > 0’ e para 1 quando ‘<n> = 0’.  Para valores negativos
     de <n>, ‘pochhammer (<x>, <n>)’ é definido como ‘(-1)^<n> /
     pochhammer (1 - <x>, -<n>)’.  Dessa forma

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     Para converter um símbolo de Pochhammer em um quociente de funções
     gama, (veja Abramowitz e Stegun, equação 6.1.22) use ‘makegamma’;
     por exemplo

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     Quando <n> exceder ‘pochhammer_max_index’ ou quando <n> for
     simbólico, ‘pochhammer’ retorna uma forma substantiva.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variável: pochhammer_max_index
     Valor padrão: 100

     ‘pochhammer (<n>, <x>)’ expande para um produto se e somente se
     ‘<n> <= pochhammer_max_index’.

     Exemplos:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Referência: Abramowitz e Stegun, equação 6.1.16,página 256.

 -- Função: spherical_bessel_j (<n>, <x>)
     A Função de Bessel esférica de primeiro tipo.

     Referência: Abramowitz e Stegun, equações 10.1.8,página 437 e
     10.1.15,página 439.

 -- Função: spherical_bessel_y (<n>, <x>)
     A Função de Bessel esférica de segundo tipo.

     Referência: Abramowitz e Stegun, equações 10.1.9,página 437 e
     10.1.15,página 439.

 -- Função: spherical_hankel1 (<n>, <x>)
     A Função de Hankel esférica de primeiro tipo.

     Referência: Abramowitz e Stegun, equação 10.1.36,página 439.

 -- Função: spherical_hankel2 (<n>, <x>)
     A Função de Hankel esférica de segundo tipo.

     Referência: Abramowitz e Stegun, equação 10.1.17,página 439.

 -- Função: spherical_harmonic (<n>, <m>, <x>, <y>)
     A função armônica esférica.

     Referência: Merzbacher 9.64.

 -- Função: unit_step (<x>)
     A função de passo de unidade contínua à esquerda; dessa forma
     ‘unit_step (<x>)’ tende para ‘<x> <= 0’ e é igual a 1 para ‘<x> >
     0’.

     Se você quiser uma função de passo de unidade que tome o valor 1/2
     em zero, use ‘(1 + signum (<x>))/2’.

 -- Função: ultraspherical (<n>, <a>, <x>)
     A função polinômial ultraesférica (também conhecida como função
     polinomial de Gegenbauer).

     Referência: Abramowitz e Stegun, equação 22.5.46,página 779.


File: maxima.info,  Node: plotdf,  Next: romberg,  Prev: orthopoly,  Up: Top

66 plotdf
*********

* Menu:

* Introdução a plotdf::
* Funções e Variáveis Definidas para plotdf::


File: maxima.info,  Node: Introdução a plotdf,  Next: Funções e Variáveis Definidas para plotdf,  Prev: plotdf,  Up: plotdf

66.1 Introdução a plotdf
========================

A função ‘plotdf’ cria um gráfico do campo de direção de uma Equação
Diferencial Ordinária (EDO) de primeira ordem ou um sistema de duas
EDO’s de primeira ordem autônomas.

   Uma vez que esse é um apcote adicional, com o objetivo de usá-lo você
deve primeiramente chamá-lo com ‘load("plotdf")’.  Você também precisa
do Xmaxima instalado, mesmo que você execute o Maxima usando uma
interface diferente.

   Para montar um gráfico do campo de direção de uma EDO simples, a EDO
deve ser escrita na forma:
            dy
            -- = F(x,y)
            dx

   e a função <F> pode ser dada como um argumento para ‘plotdf’.  A
variável independente está sempre identificada como <x>, e a variável
dependente como <y>.  Essas duas variáveis podem não ter quaisquer
valores atribuídos a elas.

   Para montar o gráfico do campo de direção de um conjunto de duas
EDO’s autônomas, elas devem ser escritas na forma
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   e o argumento para ‘plotdf’ pode ser uma lista com as duas funções
<F> e <G>, em qualquer ordem.

   Se somente uma EDO for fornecida, ‘plotdf’ irá admitir implicitamente
‘x=t’, e ‘G(x,y)=1’, transformando a equação não autônoma em um sistema
de duas equações autônomas.


File: maxima.info,  Node: Funções e Variáveis Definidas para plotdf,  Prev: Introdução a plotdf,  Up: plotdf

66.2 Funções e Variáveis Definidas para plotdf
==============================================

 -- Função: plotdf (<dydx>,...opções...)
 -- Função: plotdf (‘[’<dxdt>,<dydt>‘]’,...opções...)

     Mostra um campo de direção em duas dimensões <x> e <y>.

     <dydx>, <dxdt> e <dydt> são expressões que dependem de <x> e <y>.
     Adicionalmente para essas duas variáveis, as expressões podem
     também depender de um conjunto de parâmetros, com valores numéricos
     fornecidos com os ‘parâmetros’ opção (a sintaxe de opção é
     fornecida abaixo), ou com um intervalo de valores permitidos
     especificados por meio de uma opção <sliders>.

     Muitas outras opções podem ser fornecidas dentro do comando, ou
     selecionadas no menu.  Curvas integrais podem ser obtidas por meio
     de um clique no gráfico, ou com a opção ‘trajectory_at’.  A direção
     da integração pode ser controlada com a opção ‘direction’, que pode
     ter valores de _forward_ (adiante), _backward_(para trás) or _both_
     (ambos).  O número de passos de integração é fornecido por meio de
     ‘nsteps’ e o intervalo de tempo entre eles é escolhido com a opção
     ‘tstep’.  O método de Adams Moulton é usado para a integração; é
     também possível alternar para um método adaptativo de Runge-Kutta
     de quarta ordem.

     Menu da janela do gráfico:

     O menu na janela do gráfico tem as seguintes opções: _Zoom_, irá
     modificar o comportamento do mouse de forma que seja permitido a
     você aproximar uma região do gráfico por meio de um clique nessa
     região como o botão esquerdo.  Cada clique próximo a um ponto do
     gráfico amplia esse gráfico, mantendo o contro no ponto onde você
     clicou.  Mantendo a tecla <Shift> pressioada enquanto clica, afasta
     para a ampliação anterior.  Para continuar calculando trajetórias
     quando você clica sobre um ponto, selecione _Integrate_ a partir do
     menu.

     A opção _Config_ no menu pode ser usada para mudar a(s) EDO(s) em
     uso e para várias outras escolhas.  Após as mudanças de
     configuração serem feitas, a opção do menu _Replot_ estará
     selecionada, para ativar as novas escolhas.  Se um par de
     coordenadas for fornecido em um campo _Trajectory at_ na caixa de
     diálogo _Config_ do menu, e a tecla <enter> fo pressionada, uma
     nova curva integral será mostrada, adicionalmente com as outras já
     mostradas.  Quando _Replot_ está selecionada, somente a última
     curva integral fornecida será mostrada.

     Mantendo o botão direito do mouse pressionado enquanto o cursor é
     movido, pode ser usado para arrastar as laterais do gráfico para
     cima ou para baixo.  Parâmetros adicionais tais como o número de
     passos, o valor inicial de <t> e os centros de x e y e raios, podem
     ser escolhidos no menu Config.

     Uma cópia do gráfico pode ser impressa para uma impressora
     Postscript, ou gravada como um arquivo postscript, usando a opção
     _Save_ do menu.  Para alternar entre imprimir e gravar para um
     arquivo Postscript, _Print Options_ pode ser selecionada na janela
     de diálogo de _Config_.  Após as escolhas na janela de diálogo
     _Save_ serem fornecidas, "Save” deve ser selecionada no primeiro
     menu, para cirar o arquivo ou imprimir o gráfico.

     Opções de gráfico:

     O comando ‘plotdf’ pode incluir muitos comandos, cada comando é uma
     lista de dois ou mais itens.  O primeiro item é o nome da opção, e
     o restante compreende o valor ou valores atribuídos à opção.

     As opçõesque são reconhecidas por ‘plotdf’ são as seguintes:

        • "tstep" define o comprimento dos incrementos sobre a variável
          independente <t>, usado para calcular uma curva integral.  Se
          somente uma expressão <dydx> for fornecida a ‘plotdf’, a
          variável <x> será diretamente proporcional a <t>.  O valor
          padrão é 0.1.

        • "nsteps" define o número de passos de comprimento ‘tstep’ que
          será usando para a variável independente, para calcular uma
          curva integral.  O valor padrão é 100.

        • "direction" define a direção da variável independente que será
          seguida para calcular uma curva integral.  Possíveis valores
          são ‘forward’, para fazer a variável independente aumentar
          ‘nsteps’ vezes, com incrementos de ‘tstep’, ‘backward’, para
          fazer a variável independente diminuir, ou ‘both’ que irá
          conduzir a um curva integral que amplia ‘nsteps’ adiante, e
          ‘nsteps’ para trás.  As palavras chave ‘right’ e ‘left’ podem
          ser usadas como sinonimos para ‘forward’ e ‘backward’.  O
          valor padrão é ‘both’.

        • "tinitial" define o valor inicial da variável <t> usada para
          calcular curva integral.  Uma vez que equações diferenciais
          forem autônomas, aquela esxolha irá aparecer somente no
          gráfico das curvas como funções de <t>.  O valor padrão é 0.

        • "versus_t" é usado para criar uma segunda janela de gráfico,
          com um gráfico de uma curva integral, como duas funções <x>,
          <y>, da variável independente <t>.  Se para ‘versus_t’ for
          atribuído qualquer valor diferente de 0, a segunda janela de
          gráfico será mostrada.  A segunda janela de gráfico inclui
          outro menu, semelhante ao menu da janela de gráfico principal.
          O valor padrão é 0.

        • "trajectory_at" define as coordenadas <xinitial> e <yinitial>
          para o ponto de partida de uma curva integral.  A opção está
          vazia por padrão.

        • "parameters" define uma lista de parâmetros, e seus valores
          numéricos, usados na definição das equações diferenciais.  O
          nome e valores dos parâmetros devem ser fornecidos em uma
          seqüência de caracteres com uma seqüência de pares
          ‘nome=valor’ separados por vírgula.

        • "sliders" define uma lista de parâmetros que será modificada
          interativamente usando botões de deslizamento, e o intervalo
          de variação desses parâmetros.  Os nomes e intervalos dos
          parâmetros devem ser fornecidos in a seqüência de caracteres
          com uma seqüência de elementos ‘name=min:max’ separados por
          vírgula.

        • "xfun" define uma seqüência de caracteres com uma seqüência de
          funções separadas com ponto e vírgula <x> para serem
          mostradas, no topo do campo de direção.  Essas funções irão
          ser passadas pelo Tcl e não pelo Maxima.

        • "xradius" é metade do comprimento do intervalo dos valores que
          irão ser mostrados na direção x.  O valor padrão é 10.

        • "yradius" é metade do comprimento do intervalo dos valores que
          irão ser mostrados na direção y.  O valor padrão é 10.

        • "xcenter" é a coordenada x do ponto no centro do gráfico.  O
          valor padrão é 0.

        • "ycenter" é a coordenada y do ponto no centro do gráfico.  O
          valor padrão é 0.

        • "width" define a largura da janela do gráfico, em pixels.  O
          valor padrão é 500.

        • "height" define a altura da janela do gráfico, em pixels.  O
          valor padrão é 500.

     Exemplos:

     NOTA: Dependendo da interface usada para executar o Maxima, as
     funções que usam ‘openmath’, em particular ‘plotdf’, podem
     possivelmente disparar um erro se erminarem com ponto e vírgula e
     não com um sinal de dólar.  Para evitar problemas, usamos um sinal
     de dólar em todos os exemplos abaixo.

        • Para mostrar o campo de direção da equação diferencial y' =
          exp(-x) + y e a solução que vai em toda a extensão do
          intervalo (2, -0.1):
               (%i1) load("plotdf")$

               (%i2) plotdf(exp(-x)+y,[trajectory_at,2,-0.1]);

        • Para obter o campo de direção para a equação diff(y,x) = x -
          y^2 e a solução com condição inicial y(-1) = 3, podemos usar o
          comando:
               (%i3) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                         [trajectory_at,-1,3], [direction,forward],
                         [yradius,5],[xcenter,6]);
          O gráfico também mostra a função y = sqrt(x).

        • O seguinte exemplo mostra o campo de direção de um oscilador
          harmônico, definido pelas duas equações dx/dt = y e dy/dt =
          -k*x/m, e a curva integral em todo o intervalo (x,y) = (6,0),
          com um botão de deslizamento que irá permitir a você mudar o
          valor de m interativamente (k está fixado em 2):
               (%i4) plotdf([y,-k*x/m],[parameters,"m=2,k=2"],
                           [sliders,"m=1:5"], [trajectory_at,6,0]);

        • Para montar o gráfico do campo de direção da equação de
          Duffing, m*x''+c*x'+k*x+b*x^3 = 0, introduzimos a variável
          y=x' e usamos:
               (%i5) plotdf([y,-(k*x + c*y + b*x^3)/m],
                             [parameters,"k=-1,m=1.0,c=0,b=1"],
                             [sliders,"k=-2:2,m=-1:1"],[tstep,0.1]);

        • O campo de direção para um pêdulo amortecido, incluindo a
          solução para as condições iniciais fornecidas, com um botão de
          deslizamento que pode ser usado para mudar o valor da massa m,
          e com um gráfico das duas variáveis de estado como uma função
          do tempo:

               (%i6) plotdf([y,-g*sin(x)/l - b*y/m/l],
                        [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                        [trajectory_at,1.05,-9],[tstep,0.01],
                        [xradius,6],[yradius,14],
                        [xcenter,-4],[direction,forward],[nsteps,300],
                        [sliders,"m=0.1:1"], [versus_t,1]);


File: maxima.info,  Node: romberg,  Next: simplex,  Prev: plotdf,  Up: Top

67 romberg
**********

* Menu:

* Funções e Variáveis Definidas para romberg::


File: maxima.info,  Node: Funções e Variáveis Definidas para romberg,  Prev: Top,  Up: Top

67.1 Funções e Variáveis Definidas para romberg
===============================================

 -- Função: romberg (<expr>, <x>, <a>, <b>)
 -- Função: romberg (<F>, <a>, <b>)

     Calcula uma integração numérica pelo método de Romberg.

     ‘romberg(<expr>, <x>, <a>, <b>)’ retorna uma estimativa da integral
     ‘integrate(<expr>, <x>, <a>, <b>)’.  <expr> deve ser uma expressão
     que avalie para um valor em ponto flutuante quando <x> estiver
     associado a um valor em ponto flutuante.

     ‘romberg(<F>, <a>, <b>)’ retorna uma estimativa da integral
     ‘integrate(<F>(x), x, <a>, <b>)’ onde ‘x’ representa o não nomeado,
     isolado argumeno de <F>; o atual argumento não é chamado ‘x’.  <F>
     deve ser uma função do Maxima ou do Lisp que retorne um valor em
     ponto flutuante quando o argumento for um número em ponto
     flutuante.  <F> pode nomear uma função traduzida ou compilada do
     Maxima.

     A precisão de ‘romberg’ é governada pelas variáveis globais
     ‘rombergabs’ e ‘rombergtol’.  ‘romberg’ termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que ‘rombergabs’, ou a diferença relativa em aproximações
     sucessivas for menor que ‘rombergtol’.  Dessa forma quando
     ‘rombergabs’ for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre ‘romberg’.

     ‘romberg’ divide ao meio o tamanho do passo no máximo ‘rombergit’
     vezes antes de interromper; o número máximo de avaliações de função
     é portanto ‘2^rombergit’.  Se o critério de erro estabelecido por
     ‘rombergabs’ e por ‘rombergtol’ não for satisfeito, ‘romberg’
     mostra uma mensagem de erro.  ‘romberg’ sempre faz ao menos
     ‘rombergmin’ iterações; isso é uma intenção eurísstica de previnir
     encerramentos espúrios quando o integrando for oscilatório.

     ‘romberg’ repetidamente avalia o integrando após associar a
     variável de integração a um valor específico (e não antes).  Essa
     política de avaliação torna possível aninhar chamadas a ‘romberg’,
     para calcular integrais multidimensionais.  Todavia, os cálculos de
     erro não tomam os erros de integrações aninhadas em consideração,
     então erros podem ser subestimados.  Também, métodos imaginados
     especialmente para problemas multidimensionais podem retornar a
     mesma precisão com poucas avaliações de função.

     ‘load("romberg")’ torna essa função disponível para uso.

     Veja também ‘QUADPACK’, uma coleção de funções de integração
     numérica.

     Exemplos:

     Uma integração unidimensonal.

          (%i1) load ("romberg");
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) f(x) := 1/((x - 1)^2 + 1/100) + 1/((x - 2)^2 + 1/1000) + 1/((x - 3)^2 + 1/200);
                              1                 1                1
          (%o2) f(x) := -------------- + --------------- + --------------
                               2    1           2    1            2    1
                        (x - 1)  + ---   (x - 2)  + ----   (x - 3)  + ---
                                   100              1000              200
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) rombergit : 15;
          (%o4)                          15
          (%i5) estimate : romberg (f(x), x, -5, 5);
          (%o5)                   173.6730736617464
          (%i6) exact : integrate (f(x), x, -5, 5);
          (%o6) 10 sqrt(10) atan(70 sqrt(10))
           + 10 sqrt(10) atan(30 sqrt(10)) + 10 sqrt(2) atan(80 sqrt(2))
           + 10 sqrt(2) atan(20 sqrt(2)) + 10 atan(60) + 10 atan(40)
          (%i7) abs (estimate - exact) / exact, numer;
          (%o7)                7.5527060865060088E-11

     Uma integração bidimensional, implementada com chamadas aninhadas a
     ‘romberg’.

          (%i1) load ("romberg");
          (%o1)    /usr/share/maxima/5.11.0/share/numeric/romberg.lisp
          (%i2) g(x, y) := x*y / (x + y);
                                              x y
          (%o2)                   g(x, y) := -----
                                             x + y
          (%i3) rombergtol : 1e-6;
          (%o3)                 9.9999999999999995E-7
          (%i4) estimate : romberg (romberg (g(x, y), y, 0, x/2), x, 1, 3);
          (%o4)                   0.81930239628356
          (%i5) assume (x > 0);
          (%o5)                        [x > 0]
          (%i6) integrate (integrate (g(x, y), y, 0, x/2), x, 1, 3);
                                                    3
                                              2 log(-) - 1
                              9                     2        9
          (%o6)       - 9 log(-) + 9 log(3) + ------------ + -
                              2                    6         2
          (%i7) exact : radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o7)             - --------------------------
                                          3
          (%i8) abs (estimate - exact) / exact, numer;
          (%o8)                1.3711979871851024E-10

 -- Variável de opção: rombergabs
     Valor padrão: 0.0

     A precisão de ‘romberg’ é governada pelas variávies globais
     ‘rombergabs’ e ‘rombergtol’.  ‘romberg’ termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que ‘rombergabs’, ou a diferença relativa em aproximações
     sucessivas for menor que ‘rombergtol’.  Dessa forma quando
     ‘rombergabs’ for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre ‘romberg’.

     Veja também ‘rombergit’ e ‘rombergmin’.

 -- Variável de opção: rombergit
     Valor padrão: 11

     ‘romberg’ divide ao meio o tamanho do passo no máximo ‘rombergit’
     vezes antes de interromper; o número máximo de avaliações de função
     é portanto ‘2^rombergit’.  ‘romberg’ sempre faz ao menos
     ‘rombergmin’ iterações; isso é uma intenção eurísstica de previnir
     encerramentos espúrios quando o integrando for oscilatório.

     Veja também ‘rombergabs’ e ‘rombergtol’.

 -- Variável de opção: rombergmin
     Valor padrão: 0

     ‘romberg’ sempre faz ao menos ‘rombergmin’ iterações; isso é uma
     intenção eurísstica para prevenir terminações espúrias quando o
     integrando for.

     Veja também ‘rombergit’, ‘rombergabs’, e ‘rombergtol’.

 -- Variável de opção: rombergtol
     Valor padrão: 1e-4

     A precisão de ‘romberg’ é governada pelas variáveis globais
     ‘rombergabs’ e ‘rombergtol’.  ‘romberg’ termina com sucesso quando
     a diferença absoluta entre duas aproximações sucessivas for menor
     que ‘rombergabs’, ou a diferença relativa em aproximações
     sucessivas for menor que ‘rombergtol’.  Dessa forma quando
     ‘rombergabs’ for 0.0 (o padrão) somente o erro relativo tem algum
     efeito sobre ‘romberg’.

     Veja também ‘rombergit’ e ‘rombergmin’.


File: maxima.info,  Node: simplex,  Next: simplification,  Prev: romberg,  Up: Top

68 simplex
**********

* Menu:

* Introdução a simplex::
* Funções e Variáveis Definidas para simplex::


File: maxima.info,  Node: Introdução a simplex,  Next: Funções e Variáveis Definidas para simplex,  Prev: simplex,  Up: simplex

68.1 Introdução a simplex
=========================

‘simplex’ é um pacote para otimização linear usando o algorítmo simplex.

   Exemplo:

     (%i1) load("simplex")$
     (%i2) minimize_sx(x+y, [3*x+2*y>2, x+4*y>3]);
                       9        7       1
     (%o2)            [--, [y = --, x = -]]
                       10       10      5


File: maxima.info,  Node: Funções e Variáveis Definidas para simplex,  Prev: Introdução a simplex,  Up: simplex

68.2 Funções e Variáveis Definidas para simplex
===============================================

 -- Variável de opção: epsilon_sx
     Valor padrão: ‘10^-8’

     Epsilon usando para cálculos numéricos em ‘linear_program’.

     Veja também: ‘linear_program’.

 -- Função: linear_program (<A>, <b>, <c>)

     ‘linear_program’ é uma implementação do algorítmo simplex.
     ‘linear_program(A, b, c)’ calcula um vetor <x> para o qual ‘c.x’ é
     o mínimo possível entre vetores para os quais ‘A.x = b’ e ‘x >= 0’.
     O argumento <A> é uma matriz e os argumentos <b> e <c> são listas.

     ‘linear_program’ retorna uma lista contendo o vetor minimizado <x>
     e o valor mínimo ‘c.x’.  Se o problema for não associado, é
     retornado "Problem not bounded!"  e se o problema for não viável, é
     retornado "Problem not feasible!".

     Para usar essa função primeiramente chame o pacote ‘simplex’ com
     ‘load("simplex");’.

     Exemplo:

          (%i2) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i3) b: [1,1,6]$
          (%i4) c: [1,-2,0,0]$
          (%i5) linear_program(A, b, c);
                             13     19        3
          (%o5)            [[--, 4, --, 0], - -]
                             2      2         2

     Veja também: ‘minimize_sx’, ‘scale_sx’, e ‘epsilon_sx’.

 -- Função: maximize_sx (<obj>, <cond>, [<pos>])

     Maximiza a função linear objetiva <obj> submetida a alguma
     restrição linear <cond>.  Veja ‘minimize_sx’ para uma descrição
     detalhada de argumentos e valores de retorno.

     Veja também: ‘minimize_sx’.

 -- Função: minimize_sx (<obj>, <cond>, [<pos>])

     Minimiza uma função linear objetiva <obj> submetida a alguma
     restrição linear <cond>.  <cond> é uma lista de equações lineares
     ou desigualdades.  Em desigualdades estritas ‘>’ é substituido por
     ‘>=’ e ‘<’ por ‘<=’.  O argumento opcional <pos> é uma lista de
     variáveis de decisão que são assumidas como sendo positivas.

     Se o mínimo existir, ‘minimize_sx’ retorna uma lista que contém o
     menor valor da função objetiva e uma lista de valores de variáveis
     de decisão para os quais o mínimo é alcançado.  Se o problema for
     não associado, ‘minimize_sx’ retorna "Problem not bounded!"  e se o
     problema for não viável, é retornado "Ploblem not feasible!".

     As variáveis de decisão não são assumidas para serem não negativas
     por padrão.  Se todas as variáveis de dicisão forem não negativas,
     escolha ‘nonegative_sx’ para ‘true’.  Se somente algumas das
     variáveis de decisão forem positivas, coloque-as então no argumento
     opcional <pos> (note que isso é mais eficiente que adicionar
     restrições).

     ‘minimize_sx’ utiliza o algorítmo simplex que é implementado na
     função ‘linear_program’ do Maxima.

     Para usar essa função primeiramente chame o pacote ‘simplex’ com
     ‘load("simplex");’.

     Exemplos:

          (%i1) minimize_sx(x+y, [3*x+y=0, x+2*y>2]);
                                4       6        2
          (%o1)                [-, [y = -, x = - -]]
                                5       5        5
          (%i2) minimize_sx(x+y, [3*x+y>0, x+2*y>2]), nonegative_sx=true;
          (%o2)                [1, [y = 1, x = 0]]
          (%i3) minimize_sx(x+y, [3*x+y=0, x+2*y>2]), nonegative_sx=true;
          (%o3)                Problem not feasible!
          (%i4) minimize_sx(x+y, [3*x+y>0]);
          (%o4)                Problem not bounded!

     Veja também: ‘maximize_sx’, ‘nonegative_sx’, ‘epsilon_sx’.

 -- Variável de opção: nonegative_sx
     Valor padrão: ‘false’

     Se ‘nonegative_sx’ for verdadeiro (true) todas as variáveis de
     decisão para ‘minimize_sx’ e ‘maximize_sx’ são assumidas para serem
     positivas.

     Veja também: ‘minimize_sx’.


File: maxima.info,  Node: simplification,  Next: solve_rec,  Prev: simplex,  Up: Top

69 simplification
*****************

* Menu:

* Introdução a simplification::
* Funções e Variáveis Definidas para simplification::


File: maxima.info,  Node: Introdução a simplification,  Next: Funções e Variáveis Definidas para simplification,  Prev: simplification,  Up: simplification

69.1 Introdução a simplification
================================

O diretório ‘maxima/share/simplification’ contém muitos scripts que
implementam regras de simplificação e funções, e também algumas funções
não relacionadas a simplificação.


File: maxima.info,  Node: Funções e Variáveis Definidas para simplification,  Prev: Introdução a simplification,  Up: simplification

69.2 Funções e Variáveis Definidas para simplification
======================================================

69.2.1 Package absimp
---------------------

O pacote ‘absimp’ contém regras de comparação de seqüências decaractere
que extendem as regras internas de simplificação para as funções ‘abs’ e
‘signum’.  ‘absimp’ respeita as relações estabelecidas com a função
interna ‘assume’ e por meio de declarações tais como ‘modedeclare (m,
even, n, odd)’ para inteiros paes ou ímpares.

   ‘absimp’ define as funções ‘unitramp’ e ‘unitstep’ em termos de ‘abs’
e ‘signum’.

   ‘load ("absimp")’ torna esse pacote disponível para uso.  ‘demo
(absimp)’ faz uma demonstração desse pacote.

   Exemplos:

     (%i1) load ("absimp")$
     (%i2) (abs (x))^2;
                                            2
     (%o2)                                 x
     (%i3) diff (abs (x), x);
                                           x
     (%o3)                               ------
                                         abs(x)
     (%i4) cosh (abs (x));
     (%o4)                               cosh(x)

69.2.2 Package facexp
---------------------

O pacote ‘facexp’ contém muitas funções relacionadas a simplificações
que fornecem ao usuário a habilidade de estruturar expressões por meio
de expansão controlada.  Essa capacidade é especialmente útil quando a
expressão contém variáveis que possuem significado físico, porque é
muitas vezes verdadeiro que a forma mais econômica de uma tal expressão
pode ser obtida por meio de uma expansão completa da expressão com
relação a essas variáveis, e então fatorar seus coeficientes.  Apesar de
ser verdadeiro que esse procedimento é fácil de realizar usando as
funções padrão do Maxima, ajustes adicionais podem se desejáveis, e
esses toques finais podem ser mais difíceis de aplicar.

   A função ‘facsum’ e suas formas relacionadas fornecem um meio
conveniente de controlar a estrutura de expressões por esse caminho.
Outra função, ‘collectterms’, pode ser usada para adicionar duas ou mais
expressões que já tenham sido simplificadas para essa forma, sem
resimplificar a expressão completa novamente.  Essa função pode ser útil
quando expressões forem muito grandes.

   ‘load ("facexp")’ torna dispon;ivel para uso esse pacote.  ‘demo
(facexp)’ faz uma demonstração desse pacote.

 -- Função: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Retorna uma forma de <expr> que depende dos argumentos <arg_1>,
     ..., <arg_n>.  Os argumentos podem ser quaisquer formas adequadas
     para ‘ratvars’, ou eles podem ser listas de tais formas.  Se os
     argumentos não forem listas, então a forma retornada é
     completamente expandida com relação aos argumentos, e os
     coeficientes dos argumentos foram fatorados.  Esses coeficientes
     são livres dos argumentos, exceto talvez no sentido não racional.

     Se quaisquer dos argumentos forem listas, então todas as tais
     listas são combinadas em uma lista simples, e em lugar de chamar
     ‘factor’ sobre os coeficientes dos argumentos, ‘facsum’ chama a si
     mesma sobre esses coeficientes, usando essa nova lista simples que
     foi construída como o novo argumento listo para essa chamada
     recursiva.  Esse processo pode ser repetido para um quantidade
     arbitrária de repetições por através do aninhamento dos elementos
     desejados nas listas.

     É possível que alguém possa querer usar ‘facsum’ com relação a
     subexpressões mais complicadas, tal como ‘log (x + y)’.  Tais
     argumentos são também permitidos.  Sem especificação de variável,
     por exemplo ‘facsum (<expr>)’, o resultado retornado é o mesmo que
     o que é retornado por meio de ‘ratsimp (<expr>)’.

     Ocasionalmente o usuário pode querer obter quaisquer das formas
     abaixo para expressões que são especificadas somente por meio de
     seus operadores líderes.  Por exemplo, alguém pode querer usar
     ‘facsum’ com relação a todos os ‘log’’s.  Nessa situação, alguém
     pode incluir no meio dos argumentos ou o código dos ‘log’’s
     específicos que devem ser tratados po esse caminho ou
     alternativamente a expressão ‘operator (log)’ ou a expressão
     ‘'operator (log)’.  Se alguém quiser usar ‘facsum’ na expressão
     <expr> com relação aos operadores <op_1>, ..., <op_n>, pode-se
     avaliar ‘facsum (<expr>, operator (<op_1>, ..., <op_n>))’.  A forma
     ‘operator’ pode também aparecer dentro de uma lista de argumentos.

     Adicionalmente, a escolha de comutadores ‘facsum_combine’ e
     ‘nextlayerfactor’ pode afetar o resultado de ‘facsum’.

 -- Variável global: nextlayerfactor
     Valor padrão: ‘false’

     Quando ‘nextlayerfactor’ for ‘true’, chamadas recursivas a ‘facsum’
     são aplicadas aos fatores da forma fatorada dos coeficientes dos
     argumentos.

     Quando ‘nextlayerfactor’ for ‘false’, ‘facsum’ é aplicada a cada
     coeficiente como um todo mesmo se chamadas recursivas a ‘facsum’
     acontecerem.

     A inclusão do átomo ‘nextlayerfactor’ na lista argumento de
     ‘facsum’ tem o efeito de ‘nextlayerfactor: true’, mas para o
     próximo nível da expressão somente.  Uma vez que ‘nextlayerfactor’
     é sempre associado ou a ‘true’ ou a ‘false’, ‘nextlayerfactor’ deve
     ser apresentada com apóstrofo simples mesmo que ‘nextlayerfactor’
     apareça na lista de argumento de ‘facsum’.

 -- Variável global: facsum_combine
     Valor padrão: ‘true’

     ‘facsum_combine’ controla a forma do resultado final retornada por
     meio de ‘facsum’ quando seu argumento é um quociente de polinômios.
     Se ‘facsum_combine’ for ‘false’ então a forma será retornada como
     um somatório completamente expandido como descrito acima, mas se
     ‘true’, então a expressão retornada é uma razão de polinômios, com
     cada polinômio na forma descrita acima.

     A escolha de ‘true’ desse comutador é útil quando se deseja para
     ‘facsum’ ambos o numerador e o denominador de uma expressão
     racional, mas não se deseja que o denominador seja multiplicado de
     forma completa pelos termos do numerador.

 -- Função: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Retorna uma forma de <expr> que é obtida por meio de chamada a
     ‘facsum’ sobre os fatores de <expr> com <arg_1>, ...  <arg_n> como
     argumentos.  Se qualqeur dos fatores de <expr> estiver elevado a um
     expoente, ambos o fator e o expoente irão ser processados por esse
     meio.

 -- Função: collectterms (<expr>, <arg_1>, ..., <arg_n>)
     Se muitas expressões tiverem sido simplificadas com ‘facsum’,
     ‘factorfacsum’, ‘factenexpand’, ‘facexpten’ ou com
     ‘factorfacexpten’, e elas estão para serem adicionadas umas às
     outras, pode ser desejável combiná-las usando a função
     ‘collecterms’.  ‘collecterms’ pode pegar como argumentos todos os
     argumentos que podem ser fornecidos para essas outras funções
     associadas com excessão de ‘nextlayerfactor’, que não tem efeito
     sobre ‘collectterms’.  A vantagem de ‘collectterms’ está em que
     ‘collectterms’ retorna uma forma similar a ‘facsum’, mas uma vez
     que ‘collectterms’ está adicionando forma que já tenham sido
     processadas por ‘facsum’, ‘collectterms’ não precisa repetir aquele
     esforço.  Essa capacidade é especialmente útil quando a expressão a
     ser somada for muito grande.

69.2.3 Pacote functs
--------------------

 -- Função: rempart (<expr>, <n>)
     Remove a parte <n> da expressão <expr>.

     Se <n> é uma lsita da forma ‘[<l>, <m>]’ então as partes de <l> até
     <m> são removidas.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: wronskian ([<f_1>, ..., <f_n>], <x>)
     Retorna a matriz Wronskiana das funções <f_1>, ..., <f_n> na
     variável <x>.

     <f_1>, ..., <f_n> pode ser o nome de funções definidas pelo
     usuário, ou expressões na variável <x>.

     O determinante da matriz Wronskiana é o determinante Wronskiano do
     conjunto de funções.  As funções são linearmente independentes
     entre si se seu determinante for igual a zero.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: tracematrix (<M>)
     Retorna o traço (somatório dos elementos da diagonal principal) da
     matriz <M>.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: rational (‘z’)
     Multiplica o numerador e o denominador de <z> pelo complexo
     conjugado do denominador, racionalizando dessa forma o denominador
     complexo.  Retorna a forma de expressão racional canônica (CRE) se
     fornecida uma CRE, caso contrário retorna a forma geral.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: nonzeroandfreeof (<x>, <expr>)
     Retorna ‘true’ se <expr> for diferente de zero e ‘freeof (<x>,
     <expr>)’ retorna ‘true’.  Retorna ‘false’ de outra forma.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: linear (<expr>, <x>)
     Quando <expr> for uma expressão linear na variável <x>, ‘linear’
     retorna ‘<a>*<x> + <b>’ onde <a> é diferente de zero, e <a> e <b>
     são livres de <x>.  De outra forma, ‘linear’ retorna <expr>.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: gcdivide (<p>, <q>)
     Quando ‘takegcd’ for ‘true’, ‘gcdivide’ divide os polinômios <p> e
     <q> por seu maior divisor comum (MDC) e retorna a razão dos
     resultados.

     Quando ‘takegcd’ for ‘false’, ‘gcdivide’ retorna a razão ‘<p>/<q>’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: arithmetic (<a>, <d>, <n>)
     Retorna o <n>-ésiomo termo da série aritmética ‘<a>, <a> + <d>, <a>
     + 2*<d>, ..., <a> + (<n> - 1)*<d>’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: geometric (<a>, <r>, <n>)
     Retorna o <n>-ésimo termo da série geométrica ‘<a>, <a>*<r>,
     <a>*<r>^2, ..., <a>*<r>^(<n> - 1)’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: harmonic (<a>, <b>, <c>, <n>)
     Retorna o <n>-ésimo termo da série harmônica ‘<a>/<b>, <a>/(<b> +
     <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> - 1)*<c>)’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: arithsum (<a>, <d>, <n>)
     Retorna a soma dos elementos da série aritmética de 1 a <n>.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: geosum (<a>, <r>, <n>)
     Retorna a soma dos elementos da série geométrica de 1 a <n>.  Se
     <n> for infinito (‘inf’) então a soma será finita se e somente se o
     valor absoluto de <r> for menor que 1.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: gaussprob (<x>)
     Retorna a função de probalilidade de Gauss ‘%e^(-<x>^2/2) /
     sqrt(2*%pi)’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: gd (<x>)
     Retorna a função de Gudermann ‘2 * atan(%e^<x> - %pi/2)’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: agd (<x>)
     Retorna o inverso da função de Gudermann ‘log (tan (%pi/4 +
     x/2)))’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: vers (<x>)
     Retorna o sinus versus ‘1 - cos (x)’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: covers (<x>)
     Retorna o sinus versus do complemento ‘1 - sin (<x>)’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: exsec (<x>)
     Retorna a parte externa da secante ‘sec (<x>) - 1’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: hav (<x>)
     Retorna o semi-sinus versus ‘(1 - cos(x))/2’.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: combination (<n>, <r>)
     Retorna o número de combinações de <n> objetos tomados em grupos de
     <r> elementos.

     Para usar essa função escreva primeiramente ‘load("functs")’.

 -- Função: permutation (<n>, <r>)
     Retorna o número de permutações de <r> objetos selecionados de um
     conjunto de <n> objetos.

     Para usar essa função escreva primeiramente ‘load("functs")’.

69.2.4 Package ineq
-------------------

O pacote ‘ineq’ contém regras de simplificação para desigualdades.

   Sessão exemplo:

     (%i1) load("ineq")$
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     (%i2) a>=4;  /* uma desigualdade exemplo */
     (%o2)                               a >= 4
     (%i3) (b>c)+%; /* adiciona uma segunda e estrita desigualdade */
     (%o3)                            b + a > c + 4
     (%i4) 7*(x<y); /* multiplica por um número positivo */
     (%o4)                              7 x < 7 y
     (%i5) -2*(x>=3*z); /* multiplica por um número negativo */
     (%o5)                           - 2 x <= - 6 z
     (%i6) (1+a^2)*(1/(1+a^2)<=1); /* Maxima sabe que 1+a^2 > 0 */
                                             2
     (%o6)                             1 <= a  + 1
     (%i7) assume(x>0)$ x*(2<3); /* assumindo x>0 */
     (%o7)                              2 x < 3 x
     (%i8) a>=b; /* outa desigualdade */
     (%o8)                               a >= b
     (%i9) 3+%; /* adiciona alguma coisa à desigualdade imediatamente acima */
     (%o9)                           a + 3 >= b + 3
     (%i10) %-3; /* retirando essa alguma coisa */
     (%o10)                              a >= b
     (%i11) a>=c-b; /* ainda outra desigualdade */
     (%o11)                            a >= c - b
     (%i12) b+%; /* adiciona b a ambos os lados da desigualdade */
     (%o12)                            b + a >= c
     (%i13) %-c; /* subtrai c de ambos os lados */
     (%o13)                         - c + b + a >= 0
     (%i14) -%;  /* multiplica por -1 */
     (%o14)                          c - b - a <= 0
     (%i15) (z-1)^2>-2*z; /* determinando a verdade de uma assertiva */
                                           2
     (%o15)                         (z - 1)  > - 2 z
     (%i16) expand(%)+2*z; /* expandindo essa assertiva e adicionado 2*z a ambos os lados */
                                        2
     (%o16)                            z  + 1 > 0
     (%i17) %,pred;
     (%o17)                               true

   Seja cuidadoso com o uso dos parêntesis em torno de desigualdades:
quando o usuário digita ‘(A > B) + (C = 5)’ o resultado é ‘A + C > B +
5’, mas ‘A > B + C = 5’ é um erro de sintaxe, e ‘(A > B + C) = 5’ é
alguma coisa completametne diferente.

   Faça ‘disprule (all)’ para ver uma lista completa das definições de
regras.

   O usuário será questionado se o Maxima for incapaz de decidir o sinal
de uma quantidade multiplicando uma desigualdade.

   O mais comum recurso estranho é ilustrado por:

     (%i1) eq: a > b;
     (%o1)                                a > b
     (%i2) 2*eq;
     (%o2)                              2 (a > b)
     (%i3) % - eq;
     (%o3)                                a > b

   Outro problema é 0 vezes uma desigualdade; o padrão para isso
acontecer é 0 ter sido colocado à esquerda sozinho.  Todavia, se você
digitar ‘X*<some_inequality>’ e Maxima perguntar sobre o sinal de ‘X’ e
você responder ‘zero’ (ou ‘z’), o programa retorna ‘X*<some_inequality>’
e não utiliza a informação que ‘X’ é 0.  Você pode fazer ‘ev (%, x: 0)’
em casos semelhantes a esse, como a base de dados irá somente ser usada
para propósitos de comparação em decisões, e não para o propósito de
avaliação de ‘X’.

   O usuário pode notar uma resposta lenta quando esse pacote é
disponibilizado para uso, como o simplificador é forçado a examinar mais
regras do precisaria sem esse pacote, então você pode desejar remover
essas regras após fazer uso delas.  Faça ‘kill (rules)’ para eliminar
todas as regras (incluindo qualquer regra que você possa ter definido);
ou você pode ser mais seletivo eliminando somente algumas delas; ou use
‘remrule’ sobre uma regra específica.

   Note que se você disponibiliza para uso esse pacote após definir suas
próprias regras você irá sobrscrever suas regras que possuirem nomes
identicos a nomes contidos em regras do pacote.  As regras no pacote
são: ‘*rule1’, ..., ‘*rule8’, ‘+rule1’, ..., ‘+rule18’, e você deve
colocar o nome de regra entre aspas duplas ao referir-se a eles, como em
‘remrule ("+", "+rule1")’ para especificamente remover a primeira regra
sobre ‘"+"’ ou ‘disprule ("*rule2")’ para mostrar a definição da segunda
regra multiplicativa.

69.2.5 Package rducon
---------------------

 -- Função: reduce_consts (<expr>)
     Substitui subexpressões constantes de <expr> com construída com
     átomos constantes, gravando a definição de todas essas constantes
     construídas na lista de equações ‘const_eqns’, e retornando a
     expressão modificada <expr>.  Essas partes de <expr> são constantes
     que retornam ‘true’ quando operadas por meio da função ‘constantp’.
     Conseqüêntemente, antes de usar ‘reduce_consts’, se pode fazer

          declare ([<objeto que vai receber a propriedade constante>], constant)$

     para escolher a base de dados das quantidades constantes ocorrendo
     em suas expressões.

     Se você está planejando gerar saídas em Fortran após esses cálculos
     simbólicos, uma das primeiras seções de código pode ser o cálculo
     de todas as constantes.  Para gerar esse segmento de código, faça

          map ('fortran, const_eqns)$

     Variables como ‘const_eqns’ que afetam ‘reduce_consts’ são:

     ‘const_prefix’ (valor padrão: ‘xx’) é a seqüência de caracteres
     usada para prefixar todos os símbolos gerados por ‘reduce_consts’
     para representar subexpressões constantes.

     ‘const_counter’ (valor padrão: 1) é o índice inteiro usado para
     gerar símbolos únicos para representar cada subexpressão constante
     emcontrada por ‘reduce_consts’.

     ‘load ("rducon")’ torna essa função disponível para uso.  ‘demo
     (rducon)’ faz uma demonstração dessa função.

69.2.6 Pacote scifac
--------------------

 -- Função: gcfac (<expr>)
     ‘gcfac’ função de fatoração que tenta aplicar a mesma heurística
     que cientístas aplicam em tentativas de fazer expressões
     extremamente simples.  ‘gcfac’ está limitada a fatorações
     monomiais.  Para um somatório, ‘gcfac’ faz o seguinte:

       1. Fatores sobre os inteiros.
       2. Coloca em evidência o maior expoente de termos ocorrendo como
          coeficientes, independentemente da complexidade dos termos.
       3. Usa (1) e (2) em fatorações de pares de termos adjascentes.
       4. Repetidamente e recursivamente aplica essas técnicas até que a
          expressão não mais mude.

     O item (3) não necessáriamente faz uma tarefa ótima fatoração par a
     par devido à dificuldade combinatória natural de encontrar qual de
     todas dos possíveis rearranjos de pares retorna o mais compacto
     resultado de fatoração de um par.

     ‘load ("scifac")’ torna essa função disponível para uso.  ‘demo
     (scifac)’ faz uma demonstração dessa função.

69.2.7 Pacote sqdnst
--------------------

 -- Função: sqrtdenest (<expr>)
     Desaninha ‘sqrt’ de simples, numérico, binômios de raízes
     irracionais de números racionais , onde for possível.  E.g.

          (%i1) load ("sqdnst")$
          (%i2) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);
                                              sqrt(3)
                                         sqrt(------- + 1)
                                                 2
          (%o2)                        ---------------------
                                       sqrt(11 sqrt(2) - 12)
          (%i3) sqrtdenest(%);
                                            sqrt(3)   1
                                            ------- + -
                                               2      2
          (%o3)                            -------------
                                              1/4    3/4
                                           3 2    - 2

     Algumas vezes isso ajuda na hora de aplicar ‘sqrtdenest’ mais que
     uma vez, sobre coisas como ‘(19601-13860 sqrt(2))^(7/4)’.

     ‘load ("sqdnst")’ Torna essa função disponível para uso.


File: maxima.info,  Node: solve_rec,  Next: stats,  Prev: simplification,  Up: Top

70 solve_rec
************

* Menu:

* Introdução a solve_rec::
* Funções e Variáveis Definidas para solve_rec::


File: maxima.info,  Node: Introdução a solve_rec,  Next: Funções e Variáveis Definidas para solve_rec,  Prev: solve_rec,  Up: solve_rec

70.1 Introdução a solve_rec
===========================

‘solve_rec’ é um pacote para resolver recorrências lineares com
coeficientes polinomiais.

   Um arquivo de domostração está disponivel com ‘demo(solve_rec);’.

   Exemplo:

     (%i1) load("solve_rec")$
     (%i2) solve_rec((n+4)*s[n+2] + s[n+1] - (n+1)*s[n], s[n]);
                                         n
                      %k  (2 n + 3) (- 1)          %k
                        1                            2
     (%o2)       s  = -------------------- + ---------------
                  n     (n + 1) (n + 2)      (n + 1) (n + 2)


File: maxima.info,  Node: Funções e Variáveis Definidas para solve_rec,  Prev: Introdução a solve_rec,  Up: solve_rec

70.2 Funções e Variáveis Definidas para solve_rec
=================================================

 -- Função: reduce_order (<rec>, <sol>, <var>)

     Reduz a ordem de recorrência linear <rec> quando uma solução
     particular <sol> for conhecida.  A recorrência reduzida pode ser
     usada para pegar outras soluções.

     Exemplo:

          (%i3) rec: x[n+2] = x[n+1] + x[n]/n;
                                                x
                                                 n
          (%o3)               x      = x      + --
                               n + 2    n + 1   n
          (%i4) solve_rec(rec, x[n]);
          WARNING: found some hypergeometrical solutions!
          (%o4)                    x  = %k  n
                                    n     1
          (%i5) reduce_order(rec, n, x[n]);
          (%t5)                    x  = n %z
                                    n       n

                                     n - 1
                                     ====
                                     \
          (%t6)                %z  =  >     %u
                                 n   /        %j
                                     ====
                                     %j = 0

          (%o6)             (- n - 2) %u     - %u
                                        n + 1     n
          (%i6) solve_rec((n+2)*%u[n+1] + %u[n], %u[n]);
                                               n
                                      %k  (- 1)
                                        1
          (%o6)                 %u  = ----------
                                  n    (n + 1)!

          So the general solution is

                       n - 1
                       ====        n
                       \      (- 1)
                 %k  n  >    -------- + %k  n
                   2   /     (n + 1)!     1
                       ====
                       n = 0

 -- Variável de opção: simplify_products
     Valor padrão: ‘true’

     Se ‘simplify_products’ for ‘true’, ‘solve_rec’ irá tentar
     simplificar produtos no resultado.

     Veja também: ‘solve_rec’.

 -- Função: simplify_sum (<expr>)

     Tenta simplificar todos os somatórios que aparecem na <expr> para
     uma forma a mais simplificada possível.

     ‘simplify_sum’ usa os algorítmos de Gosper e de Zeilberger para
     simplificar somatórios.

     Para usar essa função primeiramente chame o pacote ‘simplify_sum’
     com ‘load("simplify_sum")’.

     Exemplo:

          (%i1) load("simplify_sum")$
          (%i2) sum(binom(n+k,k)/2^k, k, 0, n) + sum(binom(2*n, 2*k), k, 0, n);
                   n                            n
                  ====                         ====
                  \      binomial(n + k, k)    \
          (%o2)    >     ------------------ +   >    binomial(2 n, 2 k)
                  /               k            /
                  ====           2             ====
                  k = 0                        k = 0
          (%i3) simplify_sum(%);
                                         n
                                        4     n
          (%o3)                         -- + 2
                                        2

 -- Função: solve_rec (<eqn>, <var>, [<init>])
     Encontra soluções hipergeométricas para a recorrência linear <eqn>
     com coeficientes polinomiais na variável <var>.  Argumentos
     opcionais <init> são as condições iniciais.

     ‘solve_rec’ pode resolver recorrências lineares com coeficientes
     constantes, encontrando soluções hipergeométricas para recorrências
     lineares homogêneas com coeficientes polinomiais, soluções
     racionais para recorrências lineares com coeficientes polinomiais e
     pode resolver recorrências do tipo de Ricatti.

     Note que o tempo de execução do algorítmo usado para encontrar
     soluções hipergeométricas aumenta exponencialmente com o grau do
     coeficiente lider e guia.

     Para usar essa função primeiramente chame o pacote ‘solve_rec’ com
     ‘load("solve_rec");’.

     Exemplo de recorrência linear com coeficientes constantes:

          (%i2) solve_rec(a[n]=a[n-1]+a[n-2]+n/2^n, a[n]);
                                  n          n
                     (sqrt(5) - 1)  %k  (- 1)
                                      1           n
          (%o2) a  = ------------------------- - ----
                 n               n                  n
                                2                5 2
                                                          n
                                             (sqrt(5) + 1)  %k
                                                              2    2
                                           + ------------------ - ----
                                                      n              n
                                                     2            5 2

     Exemplo de recorrência linear com coeficientes polinomiais:

          (%i7) 2*x*(x+1)*y[x] - (x^2+3*x-2)*y[x+1] + (x-1)*y[x+2];
                                   2
          (%o7) (x - 1) y      - (x  + 3 x - 2) y      + 2 x (x + 1) y
                         x + 2                   x + 1                x
          (%i8) solve_rec(%, y[x], y[1]=1, y[3]=3);
                                        x
                                     3 2    x!
          (%o9)                 y  = ---- - --
                                 x    4     2

     Exemplo de recorrência do tipo de Ricatti:

          (%i2) x*y[x+1]*y[x] - y[x+1]/(x+2) + y[x]/(x-1) = 0;
                                      y         y
                                       x + 1     x
          (%o2)         x y  y      - ------ + ----- = 0
                           x  x + 1   x + 2    x - 1
          (%i3) solve_rec(%, y[x], y[3]=5)$
          (%i4) ratsimp(minfactorial(factcomb(%)));
                                             3
                                         30 x  - 30 x
          (%o4) y  = - -------------------------------------------------
                 x        6      5       4       3       2
                       5 x  - 3 x  - 25 x  + 15 x  + 20 x  - 12 x - 1584

     Veja também: ‘solve_rec_rat’, ‘simplify_products’, e
     ‘product_use_gamma’.

 -- Função: solve_rec_rat (<eqn>, <var>, [<init>])

     Encontra soluções racionais para recorrências lineares.  Veja
     solve_rec para uma descrição dos argumentos.

     Para usar essa função primeirametne chame o pacote ‘solve_rec’ com
     ‘load("solve_rec");’.

     Exemplo:

          (%i1) (x+4)*a[x+3] + (x+3)*a[x+2] - x*a[x+1] + (x^2-1)*a[x];
          (%o1)  (x + 4) a      + (x + 3) a      - x a
                          x + 3            x + 2      x + 1
                                                             2
                                                         + (x  - 1) a
                                                                      x
          (%i2) solve_rec_rat(% = (x+2)/(x+1), a[x]);
                                 1
          (%o2)      a  = ---------------
                      x   (x - 1) (x + 1)

     Veja também: ‘solve_rec’.

 -- Variável de opção: product_use_gamma
     Valor padrão: ‘true’

     Quando simplificando produtos, ‘solve_rec’ introduz a função gama
     dentro da expressão se ‘product_use_gamma’ for ‘true’.

     Veja também: ‘simplify_products’, ‘solve_rec’.

 -- Função: summand_to_rec (<summand>, <k>, <n>)
 -- Função: summand_to_rec (<summand>, [<k>, <lo>, <hi>], <n>)

     Retorna a recorrência satisfeita pelo somatório

               sup
              ====
              \
               >     x
              /
              ====
            k = inf

     onde x é hipergeométrico em <k> e <n>.  SE <inf> e <sup> forem
     omitidos, são assumidos como sendo ‘inf = -inf’ e ‘sup = inf’.

     Para usar essa função primeiro chame o pacote ‘simplify_sum’ com
     ‘load("simplify_sum")’.

     Exemplo:

          (%i1) load("simplify_sum")$
          (%i2) summand: binom(n,k);
          (%o2)                           binomial(n, k)
          (%i3) summand_to_rec(summand,k,n);
          (%o3)                      2 sm  - sm      = 0
                                         n     n + 1
          (%i7) summand: binom(n, k)/(k+1);
                                          binomial(n, k)
          (%o7)                           --------------
                                              k + 1
          (%i8) summand_to_rec(summand, [k, 0, n], n);
          (%o8)               2 (n + 1) sm  - (n + 2) sm      = - 1
                                          n             n + 1


File: maxima.info,  Node: stats,  Next: stirling,  Prev: solve_rec,  Up: Top

71 stats
********

* Menu:

* Introdução a stats::
* Funções e Variáveis Definidas para inference_result::
* Funções e Variáveis Definidas para stats::
* Funções e Variáveis Definidas para distribuições especiais::


File: maxima.info,  Node: Introdução a stats,  Next: Funções e Variáveis Definidas para inference_result,  Prev: Top,  Up: Top

71.1 Introdução a stats
=======================

O pacote ‘stats’ contém um conjunto de procedimentos de inferência
clássica estatística e procedimentos de teste.

   Todas essas funções retornam um objeto do Maxima chamado
‘inference_result’ que contém os resultados necessários para inferências
de manipulação e tomada de decisões.

   A variável global ‘stats_numer’ controla se resultados são mostrados
em ponto flutuante ou simbólico e no formato racional; seu valor padrão
é ‘true’ e os resultados são retornados no formato de ponto flutuante.

   O pacote ‘descriptive’ contém alguns utilitários para manipular
estruturas de dados (listas e matrizes); por exemplo, para extrair
subamostras.  O pacote ‘descriptive’ também contém alguns exemplos sobre
como usar o pacote ‘numericalio’ para ler dados a partir de arquivo no
formato texto plano.  Veja ‘descriptive’ e ‘numericalio’ para maiores
detalhes.

   O pacote ‘stats’ precisa dos pacotes ‘descriptive’, ‘distrib’ e
‘inference_result’.

   Para comentários, erros ou sugestões, por favor contate o autor em

   <’mario AT edu DOT xunta DOT es’>.


File: maxima.info,  Node: Funções e Variáveis Definidas para inference_result,  Next: Funções e Variáveis Definidas para stats,  Prev: Introdução a stats,  Up: Top

71.2 Funções e Variáveis Definidas para inference_result
========================================================

 -- Função: inference_result (<título>, <valores>, <números>)

     Constrói um objeto ‘inference_result’ do tipo retornado pelas
     funções stats.  O argumento <título> é uma seqüência de caracteres
     do Maxima co o nome do procedimento; <valores> é uma lissta com
     elementos da forma ‘símbolo = valor’ e <números> é uma lista com
     números inteiros positivos no intervalo de um para
     ‘length(<valores>)’, indicando que valores serão mostrados por
     padrão.

     Exemplo:

     Este é um exemplo que mostras os resultados associados a um
     retángulo.  O título deste objeto é a seqüência de caraceteres
     ‘"Retângulo"’, o qual armazena cinco resultados, a saber ‘'base’,
     ‘'altura’, ‘'diagonal’, ‘'área’, e ‘'perímetro’, porém só mostra o
     primeiro, segundo, quinto e quarto resultado.  O resultado
     ‘'diagonal’ também é armazenado neste objeto, no entanto não é
     mostrado por padrão; para se ter acesso a este valor, faz-se uso da
     função ‘take_inference’.

          (%i1) load("inference_result")$
          (%i2) b: 3$ h: 2$
          (%i3) inference_result("Retângulo",
                                  ['base=b,
                                   'altura=h,
                                   'diagonal=sqrt(b^2+h^2),
                                   'área=b*h,
                                   'perímetro=2*(b+h)],
                                  [1,2,5,4] );
                                  |   Retângulo
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   altura = 2
                                  |
                                  | perímetro = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('diagonal,%);
          (%o4)                        sqrt(13)

     Veja também ‘take_inference’.

 -- Função: inferencep (<obj>)

     Retorna ‘true’ ou ‘false’, dependendo se <obj> é um objeto
     ‘inference_result’ ou não.

 -- Função: items_inference (<obj>)

     Retorna uma lista com os nomes dos itens em <obj>, que devem ser um
     objeto ‘inference_result’.

     Exemplo:

     O objeto ‘inference_result’ armazena dois valores, a saber ‘'pi’ e
     ‘'e’, mas somente o segundo é mostrado.  A função ‘items_inference’
     retorna os nomes de todos os itens, não importa se eles são ou não
     mostrados.

          (%i1) load("inference_result")$
          (%i2) inference_result("Hi", ['pi=%pi,'e=%e],[2]);
                                      |   Hi
          (%o2)                       |
                                      | e = %e
          (%i3) items_inference(%);
          (%o3)                        [pi, e]

 -- Função: take_inference (<n>, <obj>)
 -- Função: take_inference (<nome>, <obj>)
 -- Função: take_inference (<lista>, <obj>)

     Retorna o <n>-ésimo valor armazenado em <obj> se <n> for um inteiro
     positivo, ou o item chamado <nome> se esse for o nome de um item.
     Se o primeiro argumento for uma lista de números e/ou símbolos, a
     função ‘take_inference’ retorna uma lista com os resultados
     correspondentes.

     Exemplo:

     Fornece um objeto ‘inference_result’, a função ‘take_inference’ é
     chamada com o objetivo de extrair alguma informação armazenada
     nesse objeto.

          (%i1) load("inference_result")$
          (%i2) b: 3$ h: 2$
          (%i3) sol: inference_result("Retângulo",
                                      ['base=b,
                                       'altura=h,
                                       'diagonal=sqrt(b^2+h^2),
                                       'area=b*h,
                                       'perímetro=2*(b+h)],
                                      [1,2,5,4] );
                                  |   Retângulo
                                  |
                                  |    base = 3
                                  |
          (%o3)                   |   altura = 2
                                  |
                                  | perímetro = 10
                                  |
                                  |    area = 6
          (%i4) take_inference('base,sol);
          (%o4)                           3
          (%i5) take_inference(5,sol);
          (%o5)                          10
          (%i6) take_inference([1,'diagonal],sol);
          (%o6)                     [3, sqrt(13)]
          (%i7) take_inference(items_inference(sol),sol);
          (%o7)                [3, 2, sqrt(13), 6, 10]

     Veja também ‘inference_result’ e ‘take_inference’.


File: maxima.info,  Node: Funções e Variáveis Definidas para stats,  Next: Funções e Variáveis Definidas para distribuições especiais,  Prev: Funções e Variáveis Definidas para inference_result,  Up: Top

71.3 Funções e Variáveis Definidas para stats
=============================================

 -- Variável de opção: stats_numer
     Valor padrão: ‘true’

     Se ‘stats_numer’ for ‘true’, funções de inferência estatística
     retornam seus resultados em números com ponto flutuante.  Se
     ‘stats_numer’ for ‘false’, resultados são fornecidos em formato
     simbólico e racional.

 -- Função: test_mean (<x>)
 -- Função: test_mean (<x>, <opção_1>, <opção_2>, ...)

     Esse é o teste-<t> de média.  O argumento <x> é uma lista ou uma
     matriz coluna contendo uma amostra unidimensional.  ‘test_mean’
     tamb;em executa um teste assintótico baseado no Teorema do Limite
     Central se a opção ‘'asymptotic’ for ‘true’.

     Opções:

        • ‘'mean’, o valor padrão é ‘0’, é o valor da média a ser
          verificado.

        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

        • ‘'dev’, o valor padrão é ‘'unknown’, corresponde ao valor do
          desvio padrão quando esse valor de desvio padrão for
          conhecido; valores válidos são: ‘'unknown’ ou uma expressão
          positiva.

        • ‘'conflevel’, o valor padrão é ‘95/100’, nível de confidência
          para o intervalo de confidência; deve ser uma expressão que
          toma um valor em (0,1).

        • ‘'asymptotic’, o valor padrão é ‘false’, indica se ‘test_mean’
          exeecuta um teste-<t> exato ou um teste assintótico
          baseando-se no Teorema do Limite Central; valores válidos são
          ‘true’ e ‘false’.

     A saída da função ‘test_mean’ é um objeto ‘inference_result’ do
     Maxima mostrando os seguintes resultados:

       1. ‘'mean_estimate’: a média da amostra.

       2. ‘'conf_level’: nível de confidência selecionado pelo usuário.

       3. ‘'conf_interval’: intervalo de confidência para a média da
          população.

       4. ‘'method’: procedimento de inferência.

       5. ‘'hypotheses’: hipótese do nulo e hipótese alternativa a ser
          testada.

       6. ‘'statistic’: valor da amostra estatística a ser usado para
          testar a hipótese do nulo.

       7. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seus parâmetro(s).

       8. ‘'p_value’: valores de p do teste.

     Exemplos:

     Executa um teste-<t> exato com variância desconhecida.  A hipótese
     do nulo é H_0: mean=50 contra a alternativa unilatera H_1: mean<50;
     conforme os resultados, o valor de p é muito grande, não existem
     evidências paa rejeitar H_0.

          (%i1) load("stats")$
          (%i2) data: [78,64,35,45,45,75,43,74,42,42]$
          (%i3) test_mean(data,'conflevel=0.9,'alternative='less,'mean=50);
                    |                 MEAN TEST
                    |
                    |            mean_estimate = 54.3
                    |
                    |              conf_level = 0.9
                    |
                    | conf_interval = [minf, 61.51314273502712]
                    |
          (%o3)     |  method = Exact t-test. Unknown variance.
                    |
                    | hypotheses = H0: mean = 50 , H1: mean < 50
                    |
                    |       statistic = .8244705235071678
                    |
                    |       distribution = [student_t, 9]
                    |
                    |        p_value = .7845100411786889

     Nesta ocasião Maxima executa um testte assintótico, baseado no
     Teorema do Limite Central.  A hipótese do nulo é H_0: equal(mean,
     50) contra a alternativa de duas vias H_1: not equal(mean, 50);
     conforme os resultados, o valor de p é muito pequeno, H_0 pode ser
     rejeitado em favor da alternativa H_1.  Note que, como indicado
     pela componente ‘Method’, esse procedimento pode ser aplicado a
     grandes amostras.

          (%i1) load("stats")$
          (%i2) test_mean([36,118,52,87,35,256,56,178,57,57,89,34,25,98,35,
                        98,41,45,198,54,79,63,35,45,44,75,42,75,45,45,
                        45,51,123,54,151],
                        'asymptotic=true,'mean=50);
                    |                       MEAN TEST
                    |
                    |           mean_estimate = 74.88571428571429
                    |
                    |                   conf_level = 0.95
                    |
                    | conf_interval = [57.72848600856194, 92.04294256286663]
                    |
          (%o2)     |    method = Large sample z-test. Unknown variance.
                    |
                    |       hypotheses = H0: mean = 50 , H1: mean # 50
                    |
                    |             statistic = 2.842831192874313
                    |
                    |             distribution = [normal, 0, 1]
                    |
                    |             p_value = .004471474652002261

 -- Função: test_means_difference (<x1>, <x2>)
 -- Função: test_means_difference (<x1>, <x2>, <opção_1>, <opção_2>,
          ...)

     Esse é o teste-<t> de diferença de médias entre duas amostras.  Os
     argumentos <x1> e <x2> são listas ou matrizes colunas contendo duas
     amostras independentes.  No caso de diferentes variâncias
     desconhecidas (veja opções ‘'dev1’, ‘'dev2’ e ‘'varequal’ abaixo),
     os graus de liberdade são calculados por meio da aproximação de
     Welch.  ‘test_means_difference’ também executa um teste assintótico
     baseado no Teorema do Limite Central se a opção ‘'asymptotic’ for
     escolhida para ‘true’.

     Opções:

        • 
        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

        • ‘'dev1’, o valor padrão é ‘'unknown’, é o valor do desvio
          padrão da amostra <x1> quando esse desvio for conhecido;
          valores válidos são: ‘'unknown’ ou uma expressão positiva.

        • ‘'dev2’, o valor padrão é ‘'unknown’, é o valor do desvio
          padrão da amostra <x2> quando esse desvio for conhecido;
          valores válidos são: ‘'unknown’ ou uma expressão positiva.

        • ‘'varequal’, o valor padrão é ‘false’, se variâncias podem
          serem consideradas como iguais ou não; essa opção tem efeito
          somente quando ‘'dev1’ e/ou ‘'dev2’ forem ‘'unknown’.

        • ‘'conflevel’, o valor padrão é ‘95/100’, nível de confidência
          para o intervalo de confidência; deve ser uma expressão que
          toma valores em (0,1).

          Nota de Tradução: (0,1) representa intervalo aberto.

        • ‘'asymptotic’, o valor padrão é ‘false’, indica se
          ‘test_means_difference’ executa um teste-<t> exato ou um teste
          assíntótico baseando-se no Teorema do Limite Central; valores
          válidos são ‘true’ e ‘false’.

     A saída da função ‘test_means_difference’ é um objeto
     ‘inference_result’ do Maxima mostrando os seguintes resultados:

       1. ‘'diff_estimate’: a diferença de médias estimadas.

       2. ‘'conf_level’: nível de confidência selecionado pelo usuário.

       3. ‘'conf_interval’: intervalo de confidência para a diferença de
          médias.

       4. ‘'method’: procedimento de inferência.

       5. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       6. ‘'statistic’: valor da amostra estatística usado para testar a
          hipótese do nulo.

       7. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seu(s) parâmetro(s).

       8. ‘'p_value’: valor de p do teste.

     Exemplos:

     A igualdade de médias é testada com duas pequenas amostras <x> e
     <y>, contra a alternativa H_1: m_1>m_2, sendo m_1 e m_2 as médias
     das populações; variâncias são desconhecidas e supostamente
     admitidas para serem diferentes.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_means_difference(x,y,'alternative='greater);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |    conf_interval = [- .04597417812882298, inf]
                      |
          (%o4)       |        method = Exact t-test. Welch approx.
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.838004300728477
                      |
                      |    distribution = [student_t, 8.62758740184604]
                      |
                      |            p_value = .05032746527991905

     O mesmo teste que antes, mas agora as variâncias são admitidas
     serem supostamente iguais.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: matrix([1.2],[6.9],[38.7],[20.4],[17.2])$
          (%i4) test_means_difference(x,y,'alternative='greater,'varequal=true);
                      |              DIFFERENCE OF MEANS TEST
                      |
                      |         diff_estimate = 20.31999999999999
                      |
                      |                 conf_level = 0.95
                      |
                      |     conf_interval = [- .7722627696897568, inf]
                      |
          (%o4)       |   method = Exact t-test. Unknown equal variances
                      |
                      | hypotheses = H0: mean1 = mean2 , H1: mean1 > mean2
                      |
                      |           statistic = 1.765996124515009
                      |
                      |           distribution = [student_t, 9]
                      |
                      |            p_value = .05560320992529344

 -- Função: test_variance (<x>)
 -- Função: test_variance (<x>, <opção_1>, <opção_2>, ...)

     Esse é o teste da variância <chi^2>.  O argumento <x> é uma lista
     ou uma matriz coluna contendo uma amostra unidimensional tomada
     entre a população normal.

     Opções:

        • ‘'mean’, o valor padrão é ‘'unknown’, é a média da população,
          quando for conhecida.

        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

        • ‘'variance’, o valor padrão é ‘1’, isso é o valor (positivo)
          da variância a ser testado.

        • ‘'conflevel’, o valor padrão é ‘95/100’, nível de confidência
          para o intervalo de confidência; deve ser uma expressão que
          toma valores em (0,1).

     A saída da função ‘test_variance’ está no objeto ‘inference_result’
     do Maxima mostrando os seguintes resultados:

       1. ‘'var_estimate’: a variância da amostra.

       2. ‘'conf_level’: nível de confidência selecionado pelo usuário.

       3. ‘'conf_interval’: intervalo de confidência para a variância da
          população.

       4. ‘'method’: procedimento de inferência.

       5. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       6. ‘'statistic’: valor da amostra estatística usado para testar a
          hipótese do nulo.

       7. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seu parâmetro.

       8. ‘'p_value’: o valor de p do teste.

     Exemplos:

     Isso é testado se a variância de uma população com média
     desconhhecida for igual ou maior que 200.

          (%i1) load("stats")$
          (%i2) x: [203,229,215,220,223,233,208,228,209]$
          (%i3) test_variance(x,'alternative='greater,'variance=200);
                       |                  VARIANCE TEST
                       |
                       |              var_estimate = 110.75
                       |
                       |                conf_level = 0.95
                       |
                       |     conf_interval = [57.13433376937479, inf]
                       |
          (%o3)        | method = Variance Chi-square test. Unknown mean.
                       |
                       |    hypotheses = H0: var = 200 , H1: var > 200
                       |
                       |                 statistic = 4.43
                       |
                       |             distribution = [chi2, 8]
                       |
                       |           p_value = .8163948512777689

 -- Função: test_variance_ratio (<x1>, <x2>)
 -- Função: test_variance_ratio (<x1>, <x2>, <opção_1>, <opção_2>, ...)

     Isso é o teste <F> da razão de variância para duas populações
     normais.  Os argumentos <x1> e <x2> são listas ou matrizes colunas
     contendo duas amostras independentes.

     Opções:

        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

        • ‘'mean1’, o valor padrão é ‘'unknown’, quando for conhecida,
          isso é a média da população da qual <x1> foi tomada.

        • ‘'mean2’, o valor padrão é ‘'unknown’, quando for conhecida,
          isso é a média da população da qual <x2> foi tomada.

        • ‘'conflevel’, o valor padrão é ‘95/100’, nível de confidência
          para o intervalo de confidência da razão; deve ser uma
          expressão que tome valores em (0,1).

     A saída da função ‘test_variance_ratio’ é um objeto
     ‘inference_result’ do Maxima mostrando os seguintes resultados:

       1. ‘'ratio_estimate’: a razão de variância da amostra.

       2. ‘'conf_level’: nível de confidência selecionado pelo usuário.

       3. ‘'conf_interval’: intervalo de confidência para a razão de
          variância.

       4. ‘'method’: procedimento de inferência.

       5. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       6. ‘'statistic’: valor da amostra estatística usado para testar a
          hipótese do nulo.

       7. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seus parâmetros.

       8. ‘'p_value’: o valor de p do teste.

     Exemplos:

     a igualdade das variâncias de duas populações normais é verificado
     contra a alternativa que a primeira é maior que a segunda.

          (%i1) load("stats")$
          (%i2) x: [20.4,62.5,61.3,44.2,11.1,23.7]$
          (%i3) y: [1.2,6.9,38.7,20.4,17.2]$
          (%i4) test_variance_ratio(x,y,'alternative='greater);
                        |              VARIANCE RATIO TEST
                        |
                        |       ratio_estimate = 2.316933391522034
                        |
                        |               conf_level = 0.95
                        |
                        |    conf_interval = [.3703504689507268, inf]
                        |
          (%o4)         | method = Variance ratio F-test. Unknown means.
                        |
                        | hypotheses = H0: var1 = var2 , H1: var1 > var2
                        |
                        |         statistic = 2.316933391522034
                        |
                        |            distribution = [f, 5, 4]
                        |
                        |          p_value = .2179269692254457

 -- Função: test_sign (<x>)
 -- Função: test_sign (<x>, <opção_1>, <opção_2>, ...)

     Esse é o teste de sinal não paramétrico para a mediana de uma
     população contínua.  O argumento <x> é uma lista ou uma matriz
     coluna contendo uma amostra unidimensional.

     Opções:

        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

        • ‘'median’, o valor padrão é ‘0’, é o valor da mediana a ser
          verificado.

     A saída da função ‘test_sign’ é um objeto ‘inference_result’ do
     Maxima mostrando os seguintes resultados:

       1. ‘'med_estimate’: a mediana da amostra.

       2. ‘'method’: procedimento de inferência.

       3. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       4. ‘'statistic’: valor da amostra estatística usada para testar a
          hipótese do nulo.

       5. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seu(s) parâmetro(s).

       6. ‘'p_value’: o valor de p do teste.

     Exemplos:

     Verifica se a população da qual a amostra foi tomada tem mediana 6,
     contra a alternativa H_1: median > 6.

          (%i1) load("stats")$
          (%i2) x: [2,0.1,7,1.8,4,2.3,5.6,7.4,5.1,6.1,6]$
          (%i3) test_sign(x,'median=6,'alternative='greater);
                         |                  SIGN TEST
                         |
                         |              med_estimate = 5.1
                         |
                         |      method = Non parametric sign test.
                         |
          (%o3)          | hypotheses = H0: median = 6 , H1: median > 6
                         |
                         |                statistic = 7
                         |
                         |      distribution = [binomial, 10, 0.5]
                         |
                         |         p_value = .05468749999999989

 -- Função: test_signed_rank (<x>)
 -- Função: test_signed_rank (<x>, <opção_1>, <opção_2>, ...)

     Esse é o teste de ranque sinalizado de Wilcoxon para fazer
     inferências sobre a mediana de uma população contínua.  O argumento
     <x> é uma lista ou uma matriz coluna contendo uma amostra
     unidimensional.  Executa uma aproximação normal se o tamanho da
     amostra for maior que 20, ou se existirem zeros ou houverem
     empates.

     Veja também ‘pdf_rank_test’ e ‘cdf_rank_test’.

     Opções:

        • ‘'median’, o valor padrão é ‘0’, é o valor da mediana a ser
          verificado.

        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

     A saída da função ‘test_signed_rank’ é um objeto ‘inference_result’
     do Maxima com os seguintes resultados:

       1. ‘'med_estimate’: a mediana da amostra.

       2. ‘'method’: procedimento de inferência.

       3. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       4. ‘'statistic’: valor da amostra estatística usado para testar a
          hipótese do nulo.

       5. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seu(s) parâmetro(s).

       6. ‘'p_value’: o valor de p do teste.

     Exemplos:

     Verifica a hipótese do nulo H_0: median = 15 contra a alternativa
     H_1: median > 15.  Esse é um teste exato, ua vez que não exite
     empates.

          (%i1) load("stats")$
          (%i2) x: [17.1,15.9,13.7,13.4,15.5,17.6]$
          (%i3) test_signed_rank(x,median=15,alternative=greater);
                           |             SIGNED RANK TEST
                           |
                           |           med_estimate = 15.7
                           |
                           |           method = Exact test
                           |
          (%o3)            | hypotheses = H0: med = 15 , H1: med > 15
                           |
                           |              statistic = 14
                           |
                           |     distribution = [signed_rank, 6]
                           |
                           |            p_value = 0.28125

     Verifica a hipótese do nulo H_0: equal(median, 2.5) contra a
     alternativa H_1: not equal(median, 2.5).  Esse é um teste
     aproximado, uma vez que ocorrem empates.

          (%i1) load("stats")$
          (%i2) y:[1.9,2.3,2.6,1.9,1.6,3.3,4.2,4,2.4,2.9,1.5,3,2.9,4.2,3.1]$
          (%i3) test_signed_rank(y,median=2.5);
                       |                 SIGNED RANK TEST
                       |
                       |                med_estimate = 2.9
                       |
                       |          method = Asymptotic test. Ties
                       |
          (%o3)        |    hypotheses = H0: med = 2.5 , H1: med # 2.5
                       |
                       |                 statistic = 76.5
                       |
                       | distribution = [normal, 60.5, 17.58195097251724]
                       |
                       |           p_value = .3628097734643669

 -- Função: test_rank_sum (<x1>, <x2>)
 -- Função: test_rank_sum (<x1>, <x2>, <opção_1>)

     Esse é o teste de Wilcoxon-Mann-Whitney para comparação das
     medianas de duas populações contínuas.  Os primeiros dois
     argumentos <x1> e <x2> são listas ou matrizes colunas com os dados
     de duas amostras independentes.  Executa aproximação normal se
     quaisquer dos tamanhos de amostra for maior que 10, ou se houverem
     empates.

     Opção:

        • ‘'alternative’, o valor padrão é ‘'twosided’, é a hipótese
          alternativa; valores válidos são: ‘'twosided’, ‘'greater’ e
          ‘'less’.

     A saída da função ‘test_rank_sum’ é um objeto ‘inference_result’ do
     Maxima com os seguintes resultados:

       1. ‘'method’: procedimento de inferência.

       2. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa a
          serem testadas.

       3. ‘'statistic’: valor da amostra estatística usada para testar a
          hipótese do nulo.

       4. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seus parâmetros.

       5. ‘'p_value’: o valor de p do teste.

     Exemplos:

     Verifica se populações possuem medianas similares.  Tamanhos de
     amotra são pequenos e é feito um teste exato.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) y:[21,18,25,14,52,65,40,43]$
          (%i4) test_rank_sum(x,y);
                        |                 RANK SUM TEST
                        |
                        |              method = Exact test
                        |
                        | hypotheses = H0: med1 = med2 , H1: med1 # med2
          (%o4)         |
                        |                 statistic = 22
                        |
                        |        distribution = [rank_sum, 9, 8]
                        |
                        |          p_value = .1995886466474702

     Agora, com grandes amostras e empates, o procedimento faz
     aproximação norma.  A hipótese alternativa é H_1: median1 <
     median2.

          (%i1) load("stats")$
          (%i2) x: [39,42,35,13,10,23,15,20,17,27]$
          (%i3) y: [20,52,66,19,41,32,44,25,14,39,43,35,19,56,27,15]$
          (%i4) test_rank_sum(x,y,'alternative='less);
                       |                  RANK SUM TEST
                       |
                       |          method = Asymptotic test. Ties
                       |
                       |  hypotheses = H0: med1 = med2 , H1: med1 < med2
          (%o4)        |
                       |                 statistic = 48.5
                       |
                       | distribution = [normal, 79.5, 18.95419580097078]
                       |
                       |           p_value = .05096985666598441

 -- Função: test_normality (<x>)

     Teste de Shapiro-Wilk para normalidade.  O argumento <x> é uma
     lista de números, e o tamanho da amostra deve ser maior que 2 e
     menor ou igua a 5000, de outra forma, a função ‘test_normality’
     sinaliza com um erro.

     Referência:

     [1] Algorithm AS R94, Applied Statistics (1995), vol.44, no.4,
     547-551

     A saída da função ‘test_normality’ é um objeto ‘inference_result’
     do Maxima com os seguintes resultados:

       1. ‘'statistic’: valor do <W> estatístico.

       2. ‘'p_value’: valor de p sob a hipótese de normalidade.

     Exemplos:

     Verifica a normalidade de uma população, baseada em uma amostra de
     tamanho 9.

          (%i1) load("stats")$
          (%i2) x:[12,15,17,38,42,10,23,35,28]$
          (%i3) test_normality(x);
                                 |      SHAPIRO - WILK TEST
                                 |
          (%o3)                  | statistic = .9251055695162436
                                 |
                                 |  p_value = .4361763918860381

 -- Função: simple_linear_regression (<x>)
 -- Função: simple_linear_regression (<x> <opção_1>)

     Regressão linear simples, y_i=a+b x_i+e_i, onde os e_i são
     N(0,sigma) variáveis aleatórias independentes.  O argumento <x>
     deve ser uma matriz de duas colunas ou uma lista de pares.

     Opções:

        • ‘'conflevel’, o valor padrão é ‘95/100’, nível de confidência
          para o intervalo de confidência; isso deve ser uma expressão
          que tome valores em (0,1).

        • ‘'regressor’, o valor padrão é ‘'x’, nome da variável
          independente.

     A saída da função ‘simple_linear_regression’ é um objeto
     ‘inference_result’ do Maxima com os seguintes resultados:

       1. ‘'model’: a equação ajustada.  Útil para fazer novas
          previsões.  Veja exemplos abaixo.

       2. ‘'means’: média de duas variáveis pseudo-aleatórias.

       3. ‘'variances’: variâncias de ambas as variáveis.

       4. ‘'correlation’: coeficiente de correlação.

       5. ‘'adc’: coeficiente de determinação ajustado.

       6. ‘'a_estimation’: estimador do parâmetro <a>.

       7. ‘'a_conf_int’: intervalo de confidência do parâmetro <a>.

       8. ‘'b_estimation’: estimador do parâmetro <b>.

       9. ‘'b_conf_int’: intervalo de confidência do parâmetro <b>.

       10. ‘'hypotheses’: a hipótese do nulo e a hipótese alternativa
          sobre o parâmetro <b>.

       11. ‘'statistic’: valor da amostra estatística usado para testar
          a hipótese do nulo.

       12. ‘'distribution’: distribuição da amostra estatística,
          juntamente com seu parâmetro.

       13. ‘'p_value’: o valor de p do teste sobre <b>.

       14. ‘'v_estimation’: estimador de variância imparcial, ou
          variância residual.

       15. ‘'v_conf_int’: intervalo de confidência da variância.

       16. ‘'cond_mean_conf_int’: intervalo de confidência paa a média
          condicionada.  Veja exemplos abaixo.

       17. ‘'new_pred_conf_int’: intervalo de confidência para uma nova
          previsão.  Veja exemplos abaixo.

       18. ‘'residuals’: lista de pares (previsão, resíduo), ordenados
          em relação às previsões.  Útil para achar o melhor da análise
          de ajuste.  Veja exemplos abaixo.

     Somente os itens 1, 4, 14, 9, 10, 11, 12, e 13 acima, nessa ordem,
     são mostrados por padrão.  Os restantes escondem-se até que o
     usuário faça uso de funções ‘items_inference’ e ‘take_inference’.

     Exemplo:

     Ajustando um modelo linear para uma amostras de duas variáveis.  A
     entrada ‘%i4’ monta p gráfico da amostra junto com a linha de
     regressão; a entrada ‘%i5’ calcula ‘y’ dado ‘x=113’; a média e o
     intervalo de confidência para uma nova previsão quando ‘x=113’ são
     também calculados.

          (%i1) load("stats")$
          (%i2) s:[[125,140.7],[130,155.1],[135,160.3],[140,167.2],[145,169.8]]$
          (%i3) z:simple_linear_regression(s,conflevel=0.99);
                     |               SIMPLE LINEAR REGRESSION
                     |
                     |   model = 1.405999999999985 x - 31.18999999999804
                     |
                     |           correlation = .9611685255255155
                     |
                     |           v_estimation = 13.57966666666665
                     |
          (%o3)      | b_conf_int = [.04469633662525263, 2.767303663374718]
                     |
                     |          hypotheses = H0: b = 0 ,H1: b # 0
                     |
                     |            statistic = 6.032686683658114
                     |
                     |            distribution = [student_t, 3]
                     |
                     |             p_value = 0.0038059549413203
          (%i4) plot2d([[discrete, s], take_inference(model,z)],
                        [x,120,150],
                        [gnuplot_curve_styles, ["with points","with lines"]] )$
          (%i5) take_inference(model,z), x=133;
          (%o5)                         155.808
          (%i6) take_inference(means,z);
          (%o6)                     [135.0, 158.62]
          (%i7) take_inference(new_pred_conf_int,z), x=133;
          (%o7)              [132.0728595995113, 179.5431404004887]


File: maxima.info,  Node: Funções e Variáveis Definidas para distribuições especiais,  Prev: Funções e Variáveis Definidas para stats,  Up: Top

71.4 Funções e Variáveis Definidas para distribuições especiais
===============================================================

 -- Função: pdf_signed_rank (<x>, <n>)
     Função densidade de probabilidade da distribuição exata da
     estatística do rank sinalizado.  O argumento <x> é um número real e
     <n> um inteiro positivo.

     Veja também ‘test_signed_rank’.

 -- Função: cdf_signed_rank (<x>, <n>)
     Função de densidade cumulativa da distribuição exata da estatística
     do rank sinalizado.  O argumento <x> é um número real e <n> um
     inteiro positivo.

     Veja também ‘test_signed_rank’.

 -- Função: pdf_rank_sum (<x>, <n>, <m>)
     Função densidade de probabilidade da distribuição exata da
     estatística do somatório do rank.  O argumento <x> é um número real
     e <n> e <m> são ambos inteiros positivos.

     Veja também ‘test_rank_sum’.

 -- Função: cdf_rank_sum (<x>, <n>, <m>)
     Função de densidade cumulativa da distribuição exata da estatística
     do somatório do rank.  O argumento <x> é um número real e <n> e <m>
     são ambos inteiro positivos.

     Veja também ‘test_rank_sum’.


File: maxima.info,  Node: stirling,  Next: stringproc,  Prev: stats,  Up: Top

72 stirling
***********

* Menu:

* Funções e Variáveis Definidas para stirling::


File: maxima.info,  Node: Funções e Variáveis Definidas para stirling,  Prev: stirling,  Up: stirling

72.1 Funções e Variáveis Definidas para stirling
================================================

 -- Função: stirling (<z>,<n>)
     Substitui ‘gamma(x)’ pela fórmula de Stirling O(1/x^(2n-1)).
     Quando <n> for um inteiro estritamente negativo, sinaliza um erro.

     Referência: Abramowitz & Stegun, " Handbook of mathematical
     functions", 6.1.40.

     Exemplos:
          (%i1) load ("stirling")$

          (%i2) stirling(gamma(%alpha+x)/gamma(x),1);
                 1/2 - x             x + %alpha - 1/2
          (%o2) x        (x + %alpha)
                                             1           1
                                      --------------- - ---- - %alpha
                                      12 (x + %alpha)   12 x
                                    %e
          (%i3) taylor(%,x,inf,1);
                              %alpha       2    %alpha
                    %alpha   x       %alpha  - x       %alpha
          (%o3)/T/ x       + -------------------------------- + . . .
                                           2 x
          (%i4) map('factor,%);
                                                 %alpha - 1
                   %alpha   (%alpha - 1) %alpha x
          (%o4)   x       + -------------------------------
                                            2

     A função ‘stirling’ conhece a diferença entre a variável <gamma> e
     a função ‘gamma’:

          (%i5) stirling(gamma + gamma(x),0);
                                              x - 1/2   - x
          (%o5)    gamma + sqrt(2) sqrt(%pi) x        %e
          (%i6) stirling(gamma(y) + gamma(x),0);
                                   y - 1/2   - y
          (%o6) sqrt(2) sqrt(%pi) y        %e
                                                        x - 1/2   - x
                                   + sqrt(2) sqrt(%pi) x        %e

     Para usar essa função escreva primeiro ‘load("stirling")’.


File: maxima.info,  Node: stringproc,  Next: unit,  Prev: stirling,  Up: Top

73 stringproc
*************

* Menu:

* Introdução a manipulação de seqüências de caracteres::
* Funções e Variáveis para entrada e saída::
* Funções e Variáveis para caracteres::
* Funções e Variáveis para seqüências de caracteres::


File: maxima.info,  Node: Introdução a manipulação de seqüências de caracteres,  Next: Funções e Variáveis para entrada e saída,  Prev: stringproc,  Up: stringproc

73.1 Introdução a manipulação de seqüências de caracteres
=========================================================

O arquivo ‘stringproc.lisp’ amplia a compatibilidade do Maxima de
trabalhar com seqüências de caracteres e adiciona algumas funções úteis
a entrada e saída de dados.

   Para esclarecimentos e correções por favor mande um e-mail para
van.nek at arcor.de .

   No Maxima uma seqüência de caracteres é facilmente contruída
digitando "texto" (qualquer texto desejado entre aspas duplas).  Note
que seqüências de caracteres do Maxima não são seqüências de caracteres
do Lisp e vice-versa.  ‘stringp’ realiza testes para seqüências de
caracteres do Maxima, e ‘lstringp’ realiza testes para seqüências de
caracteres do Lisp.  Se por alguma razão voce tiver um valor, que é uma
seqüência de caracteres do Lisp, talvez quando estiver usando a função
‘sconcat’ do Maxima, você pode converter via ‘sunlisp’.

     (%i1) m: "text";
     (%o1)                         text
     (%i2) [stringp(m),lstringp(m)];
     (%o2)                     [true, false]
     (%i3) l: sconcat("text");
     (%o3)                         text
     (%i4) [stringp(l),lstringp(l)];
     (%o4)                     [false, true]
     (%i5) stringp( sunlisp(l) );
     (%o5)                         true

   Todas as funções em ‘stringproc.lisp’, que retornarem seqüências de
caracteres, retornam seqüências de caracteres do Maxima.

   Caracteres são introduzidos como seqüências de caracteres do Maxima
de comprimento 1.  Com certeza, esses caracteres não são caracteres do
Lisp.  Testes podem ser realizados com ‘charp’ ( ‘lcharp’ e conversões
do Lisp para o Maxima com ‘cunlisp’).

     (%i1) c: "e";
     (%o1)                           e
     (%i2) [charp(c),lcharp(c)];
     (%o2)                     [true, false]
     (%i3) supcase(c);
     (%o3)                           E
     (%i4) charp(%);
     (%o4)                         true

   Novamente, todas as funções em ‘stringproc.lisp’, que retornam
caracteres, retornam caracteres do Maxima.  devido a esse fato, que os
caracteres introduzidos são seqüências de caracteres comprimento 1, você
pode usar muitas das funções de seqüência de caracteres também para
caracteres.  Como visto, ‘supcase’ é um exemplo.

   É importante saber, que o primeiro caractere em uma seqüência de
caracteres do Maxima éstá na posição 1.  Isso é designado devido ao fato
de o primeiro elemento em uma lista do Maxima está na posição 1 também.
Veja definições de ‘charat’ e de ‘charlist’ para obter exemplos.

   Em aplicações fnções de seqüência de caractere são muitas vezes
usadas quando estamos trabalhando com arquivos.  Você encontrará algumas
úteis funções de fluxo e funções de impressões em ‘stringproc.lisp’.  O
seguinte exemplo mostra algumas das funções aqui introduzidas no
trabalho.

   Exemplo:

   ‘openw’ retorna um fluxo de saída para um arquivo, ‘printf’ então
permite escrita formatada para esse arquivo.  Veja ‘printf’ para
detalhes.

     +(%i1) s: openw("E:/file.txt");
     +(%o1)                    #<output stream E:/file.txt>
     +(%i2) for n:0 thru 10 do printf( s, "~d ", fib(n) );
     +(%o2)                                done
     +(%i3) printf( s, "~%~d ~f ~a ~a ~f ~e ~a~%",
                    42,1.234,sqrt(2),%pi,1.0e-2,1.0e-2,1.0b-2 );
     +(%o3)                                false
     +(%i4) close(s);
     +(%o4)                                true

   Após fechar o fluxo você pode abrí-lo novamente, dessa vez com
direção de entrada.  ‘readline’ retorna a linha completa como uma
seqüência de caracteres.  O pacote ‘stringproc’ agora oferece muitas
funções para manipulação de seqüências de caracteres.  A troca de
indicações/fichas pode ser realizada por ‘split’ ou por ‘tokens’.

     (%i5) s: openr("E:/file.txt");
     (%o5)                     #<input stream E:/file.txt>
     (%i6) readline(s);
     (%o6)                     0 1 1 2 3 5 8 13 21 34 55
     (%i7) line: readline(s);
     (%o7)               42 1.234 sqrt(2) %pi 0.01 1.0E-2 1.0b-2
     (%i8) list: tokens(line);
     (%o8)           [42, 1.234, sqrt(2), %pi, 0.01, 1.0E-2, 1.0b-2]
     (%i9) map( parsetoken, list );
     (%o9)           [42, 1.234, false, false, 0.01, 0.01, false]

   ‘parsetoken’ somente analiza números inteiros e em ponto flutuante.
A análise de símbolos ou grandes números em ponto flutuante precisa de
‘parse_string’, que irá ser disponibilizada para uso automaticamente
através de ‘eval_string.lisp’.

     (%i10) map( parse_string, list );
     (%o10)           [42, 1.234, sqrt(2), %pi, 0.01, 0.01, 1.0b-2]
     (%i11) float(%);
     (%o11) [42.0, 1.234, 1.414213562373095, 3.141592653589793, 0.01, 0.01, 0.01]
     (%i12) readline(s);
     (%o12)                               false
     (%i13) close(s)$

   ‘readline’ retorna ‘false’ quado o fim de arquivo acontecer.


File: maxima.info,  Node: Funções e Variáveis para entrada e saída,  Next: Funções e Variáveis para caracteres,  Prev: Introdução a manipulação de seqüências de caracteres,  Up: stringproc

73.2 Funções e Variáveis para entrada e saída
=============================================

Exemplo:

     (%i1) s: openw("E:/file.txt");
     (%o1)                     #<output stream E:/file.txt>
     (%i2) control:
      "~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2tand an integer: ~20t~d~%"$
     (%i3) printf( s,control, 'true,[1,2,3],42 )$
     (%o3)                                false
     (%i4) close(s);
     (%o4)                                true
     (%i5) s: openr("E:/file.txt");
     (%o5)                     #<input stream E:/file.txt>
     (%i6) while stringp( tmp:readline(s) ) do print(tmp)$
       An atom:          true
       and a list:       one two three
       and an integer:   42
     (%i7) close(s)$

 -- Função: close (<fluxo>)
     Fecha <fluxo> e retorna ‘true’ se <fluxo> tiver sido aberto
     anteriormente.

 -- Função: flength (<fluxo>)
     Retorna o número de elementos em <fluxo>.

 -- Função: fposition (<fluxo>)
 -- Função: fposition (<fluxo>, <pos>)
     Retorna a posição corrente em <fluxo>, se <pos> não está sendo
     usada.  Se <pos> estiver sendo usada, ‘fposition’ escolhe a posição
     em <fluxo>.  <pos> tem que ser um número positivo, o primeiro
     elemento em <fluxo> está na posição 1.

 -- Função: freshline ()
 -- Função: freshline (<fluxo>)
     escreve uma nova linha (em <fluxo>), se a posição atual não for um
     início de linha.  Veja também ‘newline’.

 -- Função: newline ()
 -- Função: newline (<fluxo>)
     Escreve uma nova linha (para <fluxo>).  Veja ‘sprint’ para um
     exemplo de uso de ‘newline()’.  Note que existem alguns casos, onde
     ‘newline()’não trabalha como esperado.

 -- Função: opena (<arquivo>)
     Retorna um fluxo de saída para <arquivo>.  Se um arquivo já
     existente tiver sido aberto, ‘opena’ anexa os elementos ao final do
     arquivo.

 -- Função: openr (<arquivo>)
     Retorna um fluxo para <arquivo>.  Se <arquivo> não existir, ele
     será criado.

 -- Função: openw (<arquivo>)
     Retorna um fluxo de saída para <arquivo>.  Se <arquivo> não
     existir, será criado.  Se um arquivo já existente for aberto,
     ‘openw’ modifica destrutivametne o <arquivo>.

 -- Função: printf (<dest>, <seq_caracte>)
 -- Função: printf (<dest>, <seq_caracte>, <expr_1>, ..., <expr_n>)
     Torna a função FORMAT do Lisp Comum disponível no Maxima.
     (Retirado de gcl.info: "format produces formatted output by
     outputting the caracteres of control-string string and observing
     that a tilde introduces a directive.  The caractere after the
     tilde, possibly preceded by prefix parameters and modifiers,
     specifies what kind of formatting is desired.  Most directives use
     one or more elements of args to create their output.")

     A seguinte descrição e oa exemplos podem fornecer uma idéia de uso
     de ‘printf’.  Veja um referência de Lisp para maiores informações.

             ~%       nova linha
             ~&       novíssima line
             ~t       tabulação
             ~$       monetário
             ~d       inteiro decimal
             ~b       inteiro binário
             ~o       inteiro octal
             ~x       inteiro hexadecimal
             ~br      inteiro de base b
             ~r       soletra um inteiro
             ~p       plural
             ~f       ponto flutuante
             ~e       notação científica
             ~g       ~f ou ~e, dependendo  da magnitude
             ~a       como mostrado pela função print do Maxima
             ~s       seqüências de caracteres entre "aspas duplas"
             ~~       ~
             ~<       justificação de texto, ~> terminador de justificação de texto
             ~(       conversão de caixa alta/baixa, ~) terminador de conversão de caixa
             ~[       seleção, ~] terminador de seleção
             ~{       iteração, ~} terminador de iteração

     Por favor note que não existe especificador de formato para grandes
     números em ponto flutuante.  Todavia grandes números em ponto
     flutuante podem simplesmente serem mostrados por meio da diretiva
     ‘~a’.  ‘~s’ mostra a seqüências de caracteres entre "aspas duplas",
     você pode evitar isso usando ‘~a’.  Note que a diretiva de seleção
     ‘~[’ é indexada em zero.  Também note que existem algumas
     diretivas, que não trabalham no Maxima.  Por exemplo, ‘~:[’ falha.

          (%i1) printf( false, "~a ~a ~4f ~a ~@r",
                        "String",sym,bound,sqrt(12),144), bound = 1.234;
          (%o1)                 String sym 1.23 2*sqrt(3) CXLIV
          (%i2) printf( false,"~{~a ~}",["one",2,"THREE"] );
          (%o2)                          one 2 THREE
          (%i3) printf( true,"~{~{~9,1f ~}~%~}",mat ),
                        mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
                1.1       2.0       3.3
                4.0       5.0       6.0
                7.0       8.9       9.0
          (%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
          (%i5) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
          (%o5)                    Two birds are singing.

     Se <dest> for um fluxo ou ‘true’, então ‘printf’ retorna ‘false’.
     De outra forma, ‘printf’ retorna uma seqüência de caracteres
     contendo a saída.

 -- Função: readline (<fluxo>)
     Retorna uma seqüência de caracteres contendo os caracteres a partir
     da posição corrente em <fluxo> até o fim de linha ou <false> se o
     fim de linha do arquivo for encontrado.

 -- Função: sprint (<expr_1>, ..., <expr_n>)
     Avalia e mostra seus argumentos um após o outro ‘sobre uma linha’
     iniciando na posição mais à esquerda.  Os números são mostrados com
     o ’-’ à direita do número, e isso desconsidera o comprimento da
     linha.  ‘newline()’, que irá ser chamada automaticamente a partir
     de ‘stringproc.lisp’ pode ser útil, se você desejar colocar uma
     parada de linha intermediária.

          (%i1) for n:0 thru 22 do sprint( fib(n) )$
          0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711
          (%i2) for n:0 thru 22 do (
                   sprint(fib(n)), if mod(n,10)=9 then newline() )$
          0 1 1 2 3 5 8 13 21 34
          55 89 144 233 377 610 987 1597 2584 4181
          6765 10946 17711


File: maxima.info,  Node: Funções e Variáveis para caracteres,  Next: Funções e Variáveis para seqüências de caracteres,  Prev: Funções e Variáveis para entrada e saída,  Up: stringproc

73.3 Funções e Variáveis para caracteres
========================================

 -- Função: alphacharp (<caractere>)
     Retorna ‘true’ se <caractere> for um caractere alfabético.

 -- Função: alphanumericp (<caractere>)
     Retorna ‘true’ se <caractere> for um caractere alfabético ou um
     dígito.

 -- Função: ascii (<int>)
     Retorna o caractere correspondente ao código numérico ASCII <int>.
     ( -1 < int < 256 )

          (%i1) for n from 0 thru 255 do (
          tmp: ascii(n), if alphacharp(tmp) then sprint(tmp), if n=96 then newline() )$
          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
          a b c d e f g h i j k l m n o p q r s t u v w x y z

 -- Função: cequal (<caractere_1>, <caractere_2>)
     Retorna ‘true’ se <caractere_1> e <caractere_2> forem os mesmos.

 -- Função: cequalignore (<caractere_1>, <caractere_2>)
     como ‘cequal’ mas ignora a caixa alta/baixa.

 -- Função: cgreaterp (<caractere_1>, <caractere_2>)
     Retorna ‘true’ se o código numérico ASCII do <caractere_1> for
     maior que o código numérico ASCII do <caractere_2>.

 -- Função: cgreaterpignore (<caractere_1>, <caractere_2>)
     Como ‘cgreaterp’ mas ignora a caixa alta/baixa.

 -- Função: charp (<obj>)
     Retorna ‘true’ se <obj> for um caractere do Maxima.  Veja na seção
     "Introdução a manipulação de seqüências de caracteres" para ter um
     exemplo.

 -- Função: cint (<caractere>)
     Retorna o código numéico ASCII de <caractere>.

 -- Função: clessp (<caractere_1>, <caractere_2>)
     Retorna ‘true’ se o código numérico ASCII de <caractere_1> for
     menor que o código numérico ASCII de <caractere_2>.

 -- Função: clesspignore (<caractere_1>, <caractere_2>)
     Como em ‘clessp’ ignora a caixa alta/baixa.

 -- Função: constituent (<caractere>)
     Retorna ‘true’ se <caractere> for caractere gráfico e não o
     caractere de espaço em branco.  Um caractere gráfico é um caractere
     que se pode ver, adicionado o caractere de espaço em branco.
     (‘constituent’ foi definida por Paul Graham, em ANSI Common Lisp,
     1996, página 67.)

          (%i1) for n from 0 thru 255 do (
          tmp: ascii(n), if constituent(tmp) then sprint(tmp) )$
          ! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B
          C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
          d e f g h i j k l m n o p q r s t u v w x y z { | } ~

 -- Função: cunlisp (<lisp_char>)
     Converte um caractere do Lisp em um caractere do Maxima.  (Você
     pode não precisar dessa função.)

 -- Função: digitcharp (<caractere>)
     Retorna ‘true’ se <caractere> for um dígito (algarismo de 0 a 9).

 -- Função: lcharp (<obj>)
     Retorna ‘true’ se <obj> for um caractere do Lisp.  (Você pode não
     precisar dessa função.)

 -- Função: lowercasep (<caractere>)
     Retorna ‘true’ se <caractere> for um caractere em caixa baixa.

 -- Variable: newline
     O caractere de nova linha.

 -- Variável: space
     O caractere de espaço em branco.

 -- Variável: tab
     O caractere de tabulação.

 -- Função: uppercasep (<caractere>)
     Retorna ‘true’ se <caractere> for um caractere em caixa alta.


File: maxima.info,  Node: Funções e Variáveis para seqüências de caracteres,  Prev: Funções e Variáveis para caracteres,  Up: stringproc

73.4 Funções e Variáveis para seqüências de caracteres
======================================================

 -- Função: sunlisp (<lisp_string>)
     Converte uma seqüência de caracteres do Lisp em uma seqüência de
     caracteres do Maxima.  (Em geral você pode não precisar dessa
     função.)

 -- Função: lstringp (<obj>)
     Retorna ‘true’ se <obj> is uma seqüência de caracteres do Lisp.
     (Em geral você pode não precisar dessa função.)

 -- Função: stringp (<obj>)
     Retorna ‘true’ se <obj> for uma seqüência de caracteres do Maxima.
     Veja a introdução para obter exemplos.

 -- Função: charat (<seq_caracte>, <n>)
     Retorna o <n>-ésimo caractere de <seq_caracte>.  O primeiro
     caractere em <seq_caracte> é retornado com <n> = 1.

          (%i1) charat("Lisp",1);
          (%o1)                           L

 -- Função: charlist (<seq_caracte>)
     Retorna a lsita de todos os caracteres em <seq_caracte>.

          (%i1) charlist("Lisp");
          (%o1)                     [L, i, s, p]
          (%i2) %[1];
          (%o2)                           L

 -- Função: parsetoken (<seq_caracte>)
     ‘parsetoken’ converte a primeira ficha em <seq_caracte> para o
     correspondente número ou retorna ‘false’ se o número não puder ser
     determinado.  O conjunto de delimitadores para a troca de fichas é
     ‘{space, comma, semicolon, tab, newline}’

     Nota de tradução: espaço, vírgula, ponto e vírgula, tabulação e
     nova linha.

          (%i1) 2*parsetoken("1.234 5.678");
          (%o1)                         2.468

     Para analizar você pode também usar a função ‘parse_string’.  Veja
     a descrição no arquivo ’share\contrib\eval_string.lisp’.

 -- Função: sconc (<expr_1>, ..., <expr_n>)
     Avalia seus argumentos e concatena-os em uma seqüência de
     caracteres.  ‘sconc’ é como ‘sconcat’ mas retorna uma seqüência de
     caracteres do Maxima.

          (%i1) sconc("xx[",3,"]:",expand((x+y)^3));
          (%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i2) stringp(%);
          (%o2)                         true

 -- Função: scopy (<seq_caracte>)
     Retorna uma cópia de <seq_caracte> como uma nova seqüência de
     caracteres.

 -- Função: sdowncase (<seq_caracte>)
 -- Função: sdowncase (<seq_caracte>, <início>)
 -- Função: sdowncase (<seq_caracte>, <início>, <fim>)
     Como em ‘supcase’, mas caracteres em caixa alta são convertidos
     para caracteres em caixa baixa.

 -- Função: sequal (<seq_caracte__1>, <seq_caracte__2>)
     Retorna ‘true’ se <seq_caracte__1> e <seq_caracte__2> tiverem o
     mesmo comprimento e contiverem os mesmos caracteres.

 -- Função: sequalignore (<seq_caracte__1>, <seq_caracte__2>)
     Como em ‘sequal’ mas igonara a caixa alta/baixa.

 -- Função: sexplode (<seq_caracte>)
     ‘sexplode’ é um apelido para a função ‘charlist’.

 -- Função: simplode (<lista>)
 -- Função: simplode (<lista>, <delim>)
     ‘simplode’ takes uma ‘lista’ ou expressões e concatena-as em uma
     seqüência de caracteres.  Se nenhum delimitador <delim> for usado,
     ‘simplode’ funciona como ‘sconc’ e não utiliza delimitador.
     <delim> pode ser qualquer seqüência de caracteres.

          (%i1) simplode(["xx[",3,"]:",expand((x+y)^3)]);
          (%o1)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i2) simplode( sexplode("stars")," * " );
          (%o2)                   s * t * a * r * s
          (%i3) simplode( ["One","more","coffee."]," " );
          (%o3)                   One more coffee.

 -- Função: sinsert (<seq>, <seq_caracte>, <pos>)
     Retorna uma seqüência de caracteres que é uma concatenação de
     ‘substring (<seq_caracte>, 1, <pos> - 1)’, a seqüência de
     caracteres <seq> e ‘substring (<seq_caracte>, <pos>)’.  Note que o
     primeiro caractere está em <seq_caracte> e está na posição 1.

          (%i1) s: "A submarine."$
          (%i2) sconc( substring(s,1,3),"yellow ",substring(s,3) );
          (%o2)                  A yellow submarine.
          (%i3) sinsert("hollow ",s,3);
          (%o3)                  A hollow submarine.

 -- Função: sinvertcase (<seq_caracte>)
 -- Função: sinvertcase (<seq_caracte>, <início>)
 -- Função: sinvertcase (<seq_caracte>, <início>, <fim>)
     Retorna <seq_caracte> exceto que cada caractere da posição <início>
     até a posição <fim> está invertido.  Se a posição <fim> não for
     fornecida, todos os caracteres do início ao <fim> de <seq_caracte>
     são substituídos.

          (%i1) sinvertcase("sInvertCase");
          (%o1)                      SiNVERTcASE

 -- Função: slength (<seq_caracte>)
     Retorna número de caracteres em <seq_caracte>.

 -- Função: smake (<num>, <caractere>)
     Retorna uma nova seqüência de caracteres repetindo <num> vezes
     <caractere>.

          (%i1) smake(3,"w");
          (%o1)                          www

 -- Função: smismatch (<seq_caracte__1>, <seq_caracte__2>)
 -- Função: smismatch (<seq_caracte__1>, <seq_caracte__2>, <test>)
     Retorna a posição do primeiro caractere de <seq_caracte__1> no qual
     <seq_caracte__1> e <seq_caracte__2> diferem ou ‘false’ em caso
     contrário.  A função padrao de teste para coincidência é ‘sequal’.
     Se ‘smismatch’ pode ignorar a caixa alta/baixa, use ‘sequalignore’
     como função de teste.

          (%i1) smismatch("seven","seventh");
          (%o1)                           6

 -- Função: split (<seq_caracte>)
 -- Função: split (<seq_caracte>, <delim>)
 -- Função: split (<seq_caracte>, <delim>, <multiple>)
     Retorna a lista de todas as fichas em <seq_caracte>.  Cada ficha é
     uma seqüência de caracteres não analisada.  ‘split’ usa <delim>
     como delimitador.  Se <delim> não for fornecido, o caractere de
     espaço é o delimitador padrão.  <multiple> é uma variável booleana
     com ‘true’ como valor padrão.  Multiplos delimitadores são lidos
     como um.  Essa função é útil se tabulações são gravadas com
     caracteres de espaço multiplos.  Se <multiple> for escolhido para
     ‘false’, cada delimitador é considerado.

          (%i1) split("1.2   2.3   3.4   4.5");
          (%o1)                 [1.2, 2.3, 3.4, 4.5]
          (%i2) split("first;;third;fourth",";",false);
          (%o2)               [first, , third, fourth]

 -- Função: sposition (<caractere>, <seq_caracte>)
     Retorna a posição do primeiro caractere em <seq_caracte> que
     coincide com <caractere>.  O primeiro caractere em <seq_caracte>
     está na posição 1.  Para que os caracteres que coincidirem
     desconsiderem a caixa alta/baixa veja ‘ssearch’.

 -- Função: sremove (<seq>, <seq_caracte>)
 -- Função: sremove (<seq>, <seq_caracte>, <test>)
 -- Função: sremove (<seq>, <seq_caracte>, <test>, <início>)
 -- Função: sremove (<seq>, <seq_caracte>, <test>, <início>, <fim>)
     Retorna uma seqüência de caracteres como <seq_caracte> mas com
     todas as subseqüências de caracteres que coincidirem com <seq>.  A
     função padrão de teste de coincidência é ‘sequal’.  Se ‘sremove’
     puder ignorar a caixa alta/baixa enquanto busca por <seq>, use
     ‘sequalignore’ como teste.  Use <início> e <fim> para limitar a
     busca.  Note que o primeiro caractere em <seq_caracte> está na
     posição 1.

          (%i1) sremove("n't","I don't like coffee.");
          (%o1)                   I do like coffee.
          (%i2) sremove ("DO ",%,'sequalignore);
          (%o2)                    I like coffee.

 -- Função: sremovefirst (<seq>, <seq_caracte>)
 -- Função: sremovefirst (<seq>, <seq_caracte>, <test>)
 -- Função: sremovefirst (<seq>, <seq_caracte>, <test>, <início>)
 -- Função: sremovefirst (<seq>, <seq_caracte>, <test>, <início>, <fim>)
     Como em ‘sremove’ exceto qie a primeira subseqüência de caracteres
     que coincide com ‘seq’ é removida.

 -- Função: sreverse (<seq_caracte>)
     Retorna uma seqüência de caracteres com todos os caracteres de
     <seq_caracte> em ordem reversa.

 -- Função: ssearch (<seq>, <seq_caracte>)
 -- Função: ssearch (<seq>, <seq_caracte>, <test>)
 -- Função: ssearch (<seq>, <seq_caracte>, <test>, <início>)
 -- Função: ssearch (<seq>, <seq_caracte>, <test>, <início>, <fim>)
     Retorna a posição da primeira subseqüência de caracteres de
     <seq_caracte> que coincide com a seqüência de caracteres <seq>.  A
     função padrão de teste de coincidência é ‘sequal’.  Se ‘ssearch’
     puder igonorar a caixa alta/baixa, use ‘sequalignore’ como função
     de teste.  Use <início> e <fim> para limitar a busca.  Note que o
     primeiro caractere em <seq_caracte> está na posição 1.

          (%i1) ssearch("~s","~{~S ~}~%",'sequalignore);
          (%o1)                                  4

 -- Função: ssort (<seq_caracte>)
 -- Função: ssort (<seq_caracte>, <test>)
     Retorna uma seqüência de caracteres que contém todos os caracteres
     de <seq_caracte> em uma ordem tal que não existam dois caracteres
     <c> sucessivos e <d> seja tal que ‘test (<c>, <d>)’ seja ‘false’ e
     ‘test (<d>, <c>)’ seja ‘true’.  A função padrão de teste para
     ordenaçào é <clessp>.  O conjunto de funções de teste é ‘{clessp,
     clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore}’.

          (%i1) ssort("I don't like Mondays.");
          (%o1)                    '.IMaddeiklnnoosty
          (%i2) ssort("I don't like Mondays.",'cgreaterpignore);
          (%o2)                 ytsoonnMlkIiedda.'

 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>)
 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>, <test>)
 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>, <test>, <início>)
 -- Função: ssubst (<nova>, <antiga>, <seq_caracte>, <test>, <início>,
          <fim>)
     Retorna uma seqüência de caracteres como <seq_caracte> exceto que
     todas as subseqüências de caracteres que coincidirem com <antiga>
     são substituídas por <nova>.  <antiga> e <nova> não precisam ser de
     mesmo comprimento.  A função padrão de teste para coincidência é
     para coincidências é ‘sequal’.  Se ‘ssubst’ puder ignorar a cixa
     alta/baixa enquanto procurando por <antiga>, use ‘sequalignore’
     como função de teste.  Use <início> e <fim> para limitar a busca.
     Note que o primeiro caractere em <seq_caracte> está na posição 1.

          (%i1) ssubst("like","hate","I hate Thai food. I hate green tea.");
          (%o1)          I like Thai food. I like green tea.
          (%i2) ssubst("Indian","thai",%,'sequalignore,8,12);
          (%o2)         I like Indian food. I like green tea.

 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>)
 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>, <test>)
 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>, <test>,
          <início>)
 -- Função: ssubstfirst (<nova>, <antiga>, <seq_caracte>, <test>,
          <início>, <fim>)
     Como em ‘subst’ exceto que somente a primeira subseqüência de
     caracteres que coincidir com <antiga> é substituída.

 -- Função: strim (<seq>,<seq_caracte>)
     Retorna uma seqüência de caracteres como <seq_caracte>, mas com
     todos os caracteres que aparecerem em <seq> removidos de ambas as
     extremidades.

          (%i1) "/* comment */"$
          (%i2) strim(" /*",%);
          (%o2)                        comment
          (%i3) slength(%);
          (%o3)                           7

 -- Função: striml (<seq>, <seq_caracte>)
     Como em ‘strim’ exceto que somente a extremidade esquerda de
     <seq_caracte> é recordada.

 -- Função: strimr (<seq>, <seq_caracte>)
     Como em ‘strim’ exceto que somente a extremidade direita de
     seqüência de caracteres é recortada.

 -- Função: substring (<seq_caracte>, <início>)
 -- Função: substring (<seq_caracte>, <início>, <fim>)
     Retorna a subseqüência de caracteres de <seq_caracte> começando na
     posição <início> e terminando na posição <fim>.  O caractere na
     posição <fim> não é incluído.  Se <fim> não for fornecido, a
     subseqüência de caracteres contém o restante da seqüência de
     caracteres.  Note que o primeiro caractere em <seq_caracte> está na
     posição 1.

          (%i1) substring("substring",4);
          (%o1)                        string
          (%i2) substring(%,4,6);
          (%o2)                          in

 -- Função: supcase (<seq_caracte>)
 -- Função: supcase (<seq_caracte>, <início>)
 -- Função: supcase (<seq_caracte>, <início>, <fim>)
     Retorna <seq_caracte> exceto que caracteres em caixa baixa a partir
     da posição <início> até a posição <fim> são substituídos pelo
     correspondente caracteres em caixa alta.  Se <fim> não for
     fornecido, todos os caracteres em caixa baixa de <início> até o fim
     de <seq_caracte> são substituídos.

          (%i1) load("stringproc")$
          (%i1) supcase("english",1,2);
          (%o1)                        English

 -- Função: tokens (<seq_caracte>)
 -- Função: tokens (<seq_caracte>, <test>)
     Retorna uma lista de fichas, que tiverem sido extrídos de
     <seq_caracte>.  As fichas são subseqüências de caracteres cujos
     caracteres satisfazem a uma determinada função de teste.  Se o
     teste não for fornecido, <constituent> é usada como teste padrão.
     ‘{constituent, alphacharp, digitcharp, lowercasep, uppercasep,
     charp, characterp, alphanumericp}’ é o conjunto de fnções de teste.
     (A verão Lisp de ‘tokens’ é escrita por Paul Graham.  ANSI Common
     Lisp, 1996, page 67.)

          (%i1) tokens("24 October 2005");
          (%o1)                  [24, October, 2005]
          (%i2) tokens("05-10-24",'digitcharp);
          (%o2)                     [05, 10, 24]
          (%i3) map(parsetoken,%);
          (%o3)                      [5, 10, 24]


File: maxima.info,  Node: unit,  Next: zeilberger,  Prev: stringproc,  Up: Top

74 unit
*******

* Menu:

* Introdução a Units::       
* Funções e Variáveis Definidas para Units::       


File: maxima.info,  Node: Introdução a Units,  Next: Funções e Variáveis Definidas para Units,  Prev: unit,  Up: unit

74.1 Introdução a Units
=======================

O pacote _unit_ torna o usuário apto a converter entre unidades
arbitrárias e trabalhar com dimensões em equações.  O funcionamento
desse pacote é radicalmente diferente do pacote original units do Maxima
- apesar de o original conter uma lista básica de definições, o pacote
atual usa um conjunto de regras para permitir ao usuário escolher, sobre
uma base dimensional, qual a resposta fianl de unidade pode ser
convertida.  Isso irá separar unidades em lugar de misturá-las na tela,
permitindo ao usuário durante a leitura identificar as unidades
associadas com uma resposta em particular.  Isso permitirá ao usuário
simplificar uma expressão em sua Base fundamental de Unidades, bem como
fornecer ajuste fino sobre a simplificação de unidades derivadas.
Análise dimensional é possível, e uma variedade de ferramentas está
disponível para gerenciar a conversão e também uma variedade de opções
de simplificação.  Adicionalmente para personalizar conversão
automática, _units_ também fornede um manual tradicional de opções de
conversão.

   Nota -quando conversões de unidade forem não exatas Maxima irá fazer
aproximações resultando em frações.  Esso é uma conceqüência das
técnicas usadas para simplificar unidades.  A mensagem de alerta desse
tipo de substituição está desabilitada por padrão no caso de inidades
(normalmente essas mensagens estão habilitadas) uma vez que essa
situação de iemissão de mensagens de alerta ocorre freqüêntemente e os
alertas confundem a saída.  (O estado atual de ‘ratprint’ é
restabelecido após uma conversão de unidades, de forma que modificações
de usuário para aquela configuração irão ser preservadas de outra
forma.)  Se o usuário precisar dessa informação para ‘units’, ele pode
escolher _unitverbose:on_ para reativar a impressão de mensagens de
alerta do processo de conversão.

   _unit_ está inclído no Maxima no diretório share/contrib/unit
directory.  Isso segue aos pacotes normais do Maxima conforme
convenções:

     (%i1) load("unit")$
     *******************************************************************
     *                       Units version 0.50                        *
     *          Definitions based on the NIST Reference on             *
     *              Constants, Units, and Uncertainty                  *
     *       Conversion factors from various sources including         *
     *                   NIST and the GNU units package                *
     *******************************************************************

     Redefining necessary functions...
     WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
     WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
     WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
     WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
     Initializing unit arrays...
     Done.

   As mensagens WARNING (DE ALERTA) são esperadas n ão uma causa de
preocupação - elas indicam que o pacote _unit_ está redefinindo funções
anteriormente definidas no local adequado do Maxima.  Essa redefinição é
necessária com o bojetivo de manusear adequadamente as unidades.  O
usuário pode estar consciente que se outras modificações tiverem sido
feitas para essas funções por outros pacotes essas novas mudanças irão
ser sobrescritas por meio desse processo de disponibilização do pacote
‘unit’.

   O arquivo _unit.mac_ também chama um arquivo lisp, a saber
_unit-functions.lisp_, que contém as funçãoes lisp necessárias ao
pacote.

   Clifford Yapp é o autor primário.  Ele recebeu grande contribuição de
Barton Willis da University of Nebraska at Kearney (UNK), Robert Dodier,
e da intrépida tribo da lista de mensagens do Maxima.

   Existem provavelmente muitos erros.  Diga-me quais.  ‘float’ e
‘numer’ não fazem o que é esperado.

   PORFAZER : funcionalidade de dimensão, manuseio de temperatura, a
função ‘showabbr’ e Cia.  Ltda.  Mostrar exemplos com adição de
quantidades contendo unidades.


File: maxima.info,  Node: Funções e Variáveis Definidas para Units,  Prev: Introdução a Units,  Up: unit

74.2 Funções e Variáveis Definidas para Units
=============================================

 -- Função: setunits (<list>)
     Por padrão, o pacote _unit_ não usa qualquer dimensões derivadas,
     mas irá converter todas as unidades nas sete fundamentais do
     sistema MKS.
          (%i2) N;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) dyn;
                                             1      kg m
          (%o3)                           (------) (----)
                                           100000     2
                                                     s
          (%i4) g;
                                              1
          (%o4)                             (----) (kg)
                                             1000
          (%i5) centigram*inch/minutes^2;
                                            127        kg m
          (%o5)                       (-------------) (----)
                                       1800000000000     2
                                                        s

     Em alguns casos esse é o comportamento desejado.  Se o usuário
     desejar usar outras unidades, isso é conseguido com o comando
     ‘setunits’:
          (%i6) setunits([centigram,inch,minute]);
          (%o6)                                done
          (%i7) N;
                                      1800000000000   %in cg
          (%o7)                      (-------------) (------)
                                           127            2
                                                      %min
          (%i8) dyn;
                                         18000000   %in cg
          (%o8)                         (--------) (------)
                                           127          2
                                                    %min
          (%i9) g;
          (%o9)                             (100) (cg)
          (%i10) centigram*inch/minutes^2;
                                              %in cg
          (%o10)                              ------
                                                  2
                                              %min

     A escolha de unidades é completamente flexível.  Por exemplo, se
     quisermos voltar para quiilogramas, metros, e segundos como padrão
     para essas dimensão nós podemos fazer:
          (%i11) setunits([kg,m,s]);
          (%o11)                               done
          (%i12) centigram*inch/minutes^2;
                                            127        kg m
          (%o12)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     Unidade derivadas são também manuseáveis por meio desse comando:
          (%i17) setunits(N);
          (%o17)                               done
          (%i18) N;
          (%o18)                                 N
          (%i19) dyn;
                                              1
          (%o19)                           (------) (N)
                                            100000
          (%i20) kg*m/s^2;
          (%o20)                                 N
          (%i21) centigram*inch/minutes^2;
                                              127
          (%o21)                        (-------------) (N)
                                         1800000000000

     Note que o pacote _unit_ reconhece a combinação não MKS de massa,
     comprimento, e tempo inverso elevado ao quadrado como uma força, e
     converte isso para Newtons.  É dessa forma que Maxima trabalha
     geralmente.  Se, por exemplo, nós preferirmos dinas em lugar de
     Newtons, simplesmente fazemos o seguinte:
          (%i22) setunits(dyn);
          (%o22)                               done
          (%i23) kg*m/s^2;
          (%o23)                          (100000) (dyn)
          (%i24) centigram*inch/minutes^2;
                                            127
          (%o24)                         (--------) (dyn)
                                          18000000

     Para descontinuar simplificando para qualquer unidade de força,
     usamos o comando ‘uforget’:
          (%i26) uforget(dyn);
          (%o26)                               false
          (%i27) kg*m/s^2;
                                               kg m
          (%o27)                               ----
                                                 2
                                                s
          (%i28) centigram*inch/minutes^2;
                                            127        kg m
          (%o28)                      (-------------) (----)
                                       1800000000000     2
                                                        s
     Isso pode trabalhar igualmente bem com ‘uforget(N)’ ou
     ‘uforget(%force)’.

     Veja também ‘uforget’.  Para usar essa função escreva primeiro
     ‘load("unit")’.

 -- Função: uforget (<list>)
     Por padrão, o pacote _unit_ converte todas as unidades para as sete
     unidaes fundamentais do sitema MKS de unidades.  Ess comportamento
     pode ser mudado com o comando ‘setunits’.  Após o qual, o usuário
     pode restabelecer o comportamento padrão para uma dimensão em
     particular mediante o comando ‘uforget’:
          (%i13) setunits([centigram,inch,minute]);
          (%o13)                               done
          (%i14) centigram*inch/minutes^2;
                                              %in cg
          (%o14)                              ------
                                                  2
                                              %min
          (%i15) uforget([cg,%in,%min]);
          (%o15)                      [false, false, false]
          (%i16) centigram*inch/minutes^2;
                                            127        kg m
          (%o16)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     ‘uforget’ opera sobre dimensões, não sobre unidades, de forma que
     qualquer unidade de uma dimensão em particular irá trabalhar.  A
     própia dimensão é também um argumento legal.

     Veja também ‘setunits’.  To use this function write first
     ‘load("unit")’.

 -- Função: convert (<expr>, <list>)
     Quando do restabelecimento dos valores padrão o ambiente global é
     destruído, existe o comando ‘convert’, que permite conversões
     imediatas.  ‘convert’ pode aceitar um argumetno simples ou uma
     lista de unidades a serem usadas na conversão.  Quando uma operação
     de conversão for concluída, o sistema normal de avaliação global é
     contornado, com o objetivo de evitar que o resultado desejado seja
     convertido novamente.  Como conseqüência, em cálculos aproximados
     alertas de "rat" irão ser visíveis se o ambiente global que
     controla esse comportamento (‘ratprint’) for ‘true’.  ‘convert’
     também é útil para uma verificação pontual e imediata da precisão
     de uma conversão global.  Outro recurso é que ‘convert’ irá
     permitir a um usuário fazer um Base de Conversões Dimensionais
     mesmo se o ambiente global for escolhido para simplificar par uma
     Dimensão Derivada.

          (%i2) kg*m/s^2;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) convert(kg*m/s^2,[g,km,s]);
                                               g km
          (%o3)                                ----
                                                 2
                                                s
          (%i4) convert(kg*m/s^2,[g,inch,minute]);

          `rat' replaced 39.37007874015748 by 5000/127 = 39.37007874015748
                                        18000000000   %in g
          (%o4)                        (-----------) (-----)
                                            127           2
                                                      %min
          (%i5) convert(kg*m/s^2,[N]);
          (%o5)                                  N
          (%i6) convert(kg*m^2/s^2,[N]);
          (%o6)                                 m N
          (%i7) setunits([N,J]);
          (%o7)                                done
          (%i8) convert(kg*m^2/s^2,[N]);
          (%o8)                                 m N
          (%i9) convert(kg*m^2/s^2,[N,inch]);

          `rat' replaced 39.37007874015748 by 5000/127 = 39.37007874015748
                                           5000
          (%o9)                           (----) (%in N)
                                           127
          (%i10) convert(kg*m^2/s^2,[J]);
          (%o10)                                 J
          (%i11) kg*m^2/s^2;
          (%o11)                                 J
          (%i12) setunits([g,inch,s]);
          (%o12)                               done
          (%i13) kg*m/s^2;
          (%o13)                                 N
          (%i14) uforget(N);
          (%o14)                               false
          (%i15) kg*m/s^2;
                                          5000000   %in g
          (%o15)                         (-------) (-----)
                                            127       2
                                                     s
          (%i16) convert(kg*m/s^2,[g,inch,s]);

          `rat' replaced 39.37007874015748 by 5000/127 = 39.37007874015748
                                          5000000   %in g
          (%o16)                         (-------) (-----)
                                            127       2
                                                     s

     Veja também ‘setunits’ e ‘uforget’.  Para usar essa função
     primeiramente escreva ‘load("unit")’.

 -- Variável de opção: usersetunits
     Valor padrão: none

     Se um usuário desejar ter um comportamento padrão de unidade
     diferente daquele descrito, ele pode fazer uso de _maxima-init.mac_
     e da variável _usersetunits_.  O pacote _unit_ irá verificar o
     arquivo _maxima-init.mac_ na inicialização para ver se a essa
     variável foi atribuído uma lista.  Se isso aconteceu, o pacote
     _unit_ irá usar ‘setunits’ sobre aquela lista e pegar as unidades
     lá colocadas para serem as padrões.  ‘uforget’ irá reverter para o
     comportamento definido por ‘usersetunits’ sobrescrevendo seus
     próprios padrões.  Por exemplo, Se tivermos um arquivo
     _maxima-init.mac_ contendo:
          usersetunits : [N,J];
     nós poderemos ver o seguinte comportamento:
          (%i1) load("unit")$
          *******************************************************************
          *                       Units version 0.50                        *
          *          Definitions based on the NIST Reference on             *
          *              Constants, Units, and Uncertainty                  *
          *       Conversion factors from various sources including         *
          *                   NIST and the GNU units package                *
          *******************************************************************

          Redefining necessary functions...
          WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
          WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
          WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
          WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
          Initializing unit arrays...
          Done.
          User defaults found...
          User defaults initialized.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) kg*m^3/s^2;
          (%o4)                                 J m
          (%i5) kg*m*km/s^2;
          (%o5)                             (1000) (J)
          (%i6) setunits([dyn,eV]);
          (%o6)                                done
          (%i7) kg*m/s^2;
          (%o7)                           (100000) (dyn)
          (%i8) kg*m^2/s^2;
          (%o8)                     (6241509596477042688) (eV)
          (%i9) kg*m^3/s^2;
          (%o9)                    (6241509596477042688) (eV m)
          (%i10) kg*m*km/s^2;
          (%o10)                   (6241509596477042688000) (eV)
          (%i11) uforget([dyn,eV]);
          (%o11)                           [false, false]
          (%i12) kg*m/s^2;
          (%o12)                                 N
          (%i13) kg*m^2/s^2;
          (%o13)                                 J
          (%i14) kg*m^3/s^2;
          (%o14)                                J m
          (%i15) kg*m*km/s^2;
          (%o15)                            (1000) (J)
     Sem ‘usersetunits’, as entradas iniciais poderiam ter sido
     convertidas para o sistema de unidades MKS, e ‘uforget’ poderia ter
     resultado em um retorno para as regras do MKS. Em vez disso, as
     preferências do usuário foram respeitadas em ambos os casos.  Note
     que esse podem ainda serem sobrescritos se for desejado.  Para
     eliminar completamente essa simplificação - i.e.  ter as
     preferências de usuário escolhidas para os padrões de unidade do
     Maxima - o comando ‘dontusedimension’ pode ser usado.  ‘uforget’
     pode restabelecer as preferências de usuário novamente, mas somente
     se ‘usedimension’ liberar isso para uso.  Alternativamente,
     ‘kill(usersetunits)’ irá remover completametne todo o conhecimento
     dessas escolhas de usuário da sessão atual.  Aqui está alguns
     exemplos de como esssas várias opções trabalham.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) setunits([dyn,eV]);
          (%o4)                                done
          (%i5) kg*m/s^2;
          (%o5)                           (100000) (dyn)
          (%i6) kg*m^2/s^2;
          (%o6)                     (6241509596477042688) (eV)
          (%i7) uforget([dyn,eV]);
          (%o7)                          [false, false]
          (%i8) kg*m/s^2;
          (%o8)                                  N
          (%i9) kg*m^2/s^2;
          (%o9)                                  J
          (%i10) dontusedimension(N);
          (%o10)                             [%force]
          (%i11) dontusedimension(J);
          (%o11)                         [%energy, %force]
          (%i12) kg*m/s^2;
                                               kg m
          (%o12)                               ----
                                                 2
                                                s
          (%i13) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o13)                               -----
                                                 2
                                                s
          (%i14) setunits([dyn,eV]);
          (%o14)                               done
          (%i15) kg*m/s^2;
                                               kg m
          (%o15)                               ----
                                                 2
                                                s
          (%i16) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o16)                               -----
                                                 2
                                                s
          (%i17) uforget([dyn,eV]);
          (%o17)                         [false, false]
          (%i18) kg*m/s^2;
                                               kg m
          (%o18)                               ----
                                                 2
                                                s
          (%i19) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o19)                               -----
                                                 2
                                                s
          (%i20) usedimension(N);
          Done.  To have Maxima simplify to this dimension, use setunits([unit])
          to select a unit.
          (%o20)                               true
          (%i21) usedimension(J);
          Done.  To have Maxima simplify to this dimension, use setunits([unit])
          to select a unit.
          (%o21)                               true
          (%i22) kg*m/s^2;
                                               kg m
          (%o22)                               ----
                                                 2
                                                s
          (%i23) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o23)                               -----
                                                 2
                                                s
          (%i24) setunits([dyn,eV]);
          (%o24)                               done
          (%i25) kg*m/s^2;
          (%o25)                          (100000) (dyn)
          (%i26) kg*m^2/s^2;
          (%o26)                    (6241509596477042688) (eV)
          (%i27) uforget([dyn,eV]);
          (%o27)                           [false, false]
          (%i28) kg*m/s^2;
          (%o28)                                 N
          (%i29) kg*m^2/s^2;
          (%o29)                                 J
          (%i30) kill(usersetunits);
          (%o30)                               done
          (%i31) uforget([dyn,eV]);
          (%o31)                          [false, false]
          (%i32) kg*m/s^2;
                                               kg m
          (%o32)                               ----
                                                 2
                                                s
          (%i33) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o33)                               -----
                                                 2
                                                s
     Desafortunadamente essa ampla variedade de opções é um pouco confus
     no início, mas uma vez que o usuário cultiva o uso delas o usuário
     perceberá que elas permitem completo controle sobre seu ambiente de
     trabalho.

 -- Função: metricexpandall (<x>)
     Reconstrói listas de unidades globais automaticamente criando todas
     as unidades métricas desejadas.  <x> é um argumento numérico que é
     usado para especificar quantos prefixos métricos o usuário deseja
     que seja definido.  Os argumentos são os seguintes, com cada maior
     número definindo todos os menores números de unidade:
                     0 - none. Only base units
                     1 - kilo, centi, milli
          (default)  2 - giga, mega, kilo, hecto, deka, deci, centi, milli,
                         micro, nano
                     3 - peta, tera, giga, mega, kilo, hecto, deka, deci,
                         centi, milli, micro, nano, pico, femto
                     4 - all
     Normalmente, Maxima não irá definir a expansão completa desses
     resultados em uma grande número de unidades, mas ‘metricexpandall’
     pode ser usada para reconstruir a lista em um estilo mais ou menos
     completo.  A variável relevante no arquivo _unit.mac_ é
     <%unitexpand>.

 -- Variável: %unitexpand
     Valor padrão: ‘2’

     Ess é o valor fornecido a ‘metricexpandall’ durante a inicialização
     de _unit_.


File: maxima.info,  Node: zeilberger,  Next: Índice de Funções e Variáveis,  Prev: unit,  Up: Top

75 zeilberger
*************

* Menu:

* Introdução a zeilberger::
* Funções e Variáveis Definidas para zeilberger::


File: maxima.info,  Node: Introdução a zeilberger,  Next: Funções e Variáveis Definidas para zeilberger,  Prev: zeilberger,  Up: zeilberger

75.1 Introdução a zeilberger
============================

‘zeilberger’ é uma implementação do algorítmo de Zeilberger para
somatório hipergeométricos definidos, e também para o algorítmo de
Gosper para somatórios hipergeométricos indefinidos.

   ‘zeilberger’ faz uso do método de otimização "filtering" desenvolvido
por Axel Riese.

   ‘zeilberger’ foi desenvolvido por Fabrizio Caruso.

   ‘load ("zeilberger")’ torna esse pacote disponível para uso.

75.1.1 O problema dos somatórios hipergeométricos indefinidos
-------------------------------------------------------------

‘zeilberger’ implementa o algorítmo de Gosper para somatório
hipergeométrico indefinido.  Dado um termo hipergeométrico F_k em k
queremos encontrar sua anti-diferença hipergeométrica, isto é, um termo
hipergeométrico f_k tal que F_k = f_(k+1) - f_k.

75.1.2 O problema dos somatórios hipergeométricos definidos
-----------------------------------------------------------

‘zeilberger’ implementa o algorítmo de Zeilberger para somatório
hipergeométrico definido.  Dado um termo hipergeométrico apropriado (em
n e k) F_(n,k) e um inteiro positivo d queremos encontrar um d-ésima
ordem de recorrência linear com coeficientes polinomiais (em n) para
F_(n,k) e uma função racional R em n e k tal que

   a_0 F_(n,k) + ... + a_d F_(n+d),k = Delta_K(R(n,k) F_(n,k))

   onde Delta_k é o k-seguinte operador de diferença, i.e., Delta_k(t_k)
:= t_(k+1) - t_k.

75.1.3 Níveis de detalhe nas informações
----------------------------------------

Existe também versões de níveis de detalhe fornecidos pelos comandos que
são chamados (os níveis) através da adição de um dos seguintes prefixos:

‘Summary’
     Apenas um sumário é mostrado no final
‘Verbose’
     Algumas informações nos passos intermediários
‘VeryVerbose’
     Muita informação
‘Extra’
     Muito mais informação incluindo informação sobre o sistema linear
     no algorítmo de Zeilberger

   Por exemplo: ‘GosperVerbose’, ‘parGosperVeryVerbose’,
‘ZeilbergerExtra’, ‘AntiDifferenceSummary’.

