This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Depurando o Código Fonte,  Next: Comandos Palavra Chave,  Up: Depurando

41.1 Depurando o Código Fonte
=============================

Maxima tem um depurador interno de código fonte.  O usuário pode
escolher um ponto de parada em uma função, e então caminhar linha por
linha a partir daí.  A pilha de chamadas po ser examinada, juntamente
com as variáveis associadas àquele nível.

   O comando `:help' ou `:h' mostra a lista de comando de depuração.
(Em geral, comandos podem ser abreviados se a abreviação for única.  Se
não for única, as alternativas podem ser listadas.)  Dentro do
depurador, o usuário pode também usar qualquer funções comuns do Maxima
para examinar, definir, e manipular variáveis e expressões.

   Um ponto de parada é escolhido através do comando `:br' na linha de
comando do Maxima.  Dentro do depurador, o usuário pode avançar uma
linha de cada vez usando o comando `:n' ("next").  o comando `:bt'
("backtrace") mostra uma lista da pilha de frames.  O comando `:r'
("resume") sai do depurador e continua com a execução.  Esses comandos
são demostrados no exemplo abaixo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt digitado aqui lista os frames
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investiga o valor de u
     28

     (dbm:1) u: 33;                     <-- Altera u para ser 33
     33

     (dbm:1) :r                         <-- Digite :r para retomar a computação

     (%o2)                                1094

   O arquivo `/tmp/foobar.mac' é o seguinte:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USO DO DEPURADOR ATRAVÉS DO EMACS

   Se o usuário estiver rodando o código sob o GNU emacs em uma janela
shell (shel dbl), ou está rodando a versão de interface gráfica,
`xmaxima', então se ele para em um ponto de parada, ele verá sua
posição corrente no arquivo fonte a qua será mostrada na outra metade
da janela, ou em vermelho brilhante, ou com um pequeno seta apontando
na direita da linha.  Ele pode avançar uma linha por vez digitando M-n
(Alt-n).

   Sob Emacs você pode executar em um shell `dbl', o qual requer o
arquivo `dbl.el' no diretório elisp.  Tenha certeza que instalou os
arquivos elisp ou adicionou o diretório elisp do Macima ao seu caminho:
e.g., adicione o seguinte ao seu arquivo `.emacs' ou ao seu arquivo
`site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   então no emacs

     M-x dbl

   pode iniciar uma janela shell na qual você pode executar programas,
por exemplo Maxima, gcl, gdb etc.   Essa janela de shell também
reconhece informações sobre depuração de código fonte, e mostra o
código fonte em outra janela.

   O usuário pode escolher um ponto de parada em certa linha do arquivo
digitando `C-x space'.  Isso encontra qual a função que o cursor está
posicionado, e então mostra qual a linha daquela função que o cursor
está habilitado.   Se o cursor estiver habilitado, digamos, na linha 2
de `foo', então isso irá inserir na outra janela o comando, "`:br foo
2'", para parar `foo' nessa segunda linha.   Para ter isso habilitado,
o usuário deve ter maxima-mode.el habilitado na janela na qual o
arquivo `foobar.mac' estiver interagindo.  Existe comandos adicional
disponíveis naquela janela de arquivo, tais como avaliando a função
dentro do Maxima, através da digitação de `Alt-Control-x'.


File: maxima.info,  Node: Comandos Palavra Chave,  Next: Definições para Depuração,  Prev: Depurando o Código Fonte,  Up: Depurando

41.2 Comandos Palavra Chave
===========================

Comandos palavra chave são palavras chaves especiais que não são
interpretadas como expressões do Maxima.  Um comando palavra chave pode
ser inserido na linha de comando do Maxima ou na linha de comando do
depurador, embora não possa ser inserido na linha de comando de parada.
Comandos palavra chave iniciam com um dois pontos Keyword commands
start with a colon, ':'.  Por exemplo, para avaliar uma forma Lisp você
pode digitar `:lisp' seguido pela forma a ser avaliada.

     (%i1) :lisp (+ 2 3)
     5

   O número de argumentos tomados depende do comando em particular.
Também, você não precisa digitar o comando completo, apenas o
suficiente para ser único no meio das palavras chave de parada.   Dessa
forma `:br' será suficiente para `:break'.

   Os comandos de palavra chave são listados abaixo.

`:break F n'
     Escolhe um ponto de parada em uma função `F' na linha `n' a partir
     do início da função.  Se `F' for dado como uma seqüência de
     caracteres, então essa seqüência de caracteres é assumida
     referir-se a um arquivo, e `n' é o deslocamente a partir do início
     do arquivo.  O deslocamento é opcional. Se for omitido, é assumido
     ser zero (primeira linha da função ou do arquivo).

`:bt'
     Imprime na tela uma lista da pilha de frames

`:continue'
     Continua a computação

`:delete'
     Remove o ponto de parada selecionado, ou todos se nenum for
     especificado

`:disable'
     Desabilita os pontos de parada selecionados, ou todos se nenhum
     for especificado

`:enable'
     Habilita os pontos de de parada especificados, ou todos se nenhum
     for especificado

`:frame n'
     Imprime na tela a pilha de frame `n', ou o corrente frame se
     nenhum for especificado

`:help'
     Imprime na tela a ajuda sobre um comando do depurador, ou todos os
     comandos se nenhum for especificado

`:info'
     Imprime na tela informações sobre um item

`:lisp alguma-forma'
     Avalia `alguma-forma' como uma forma Lisp

`:lisp-quiet alguma-forma'
     Avalia a forma Lisp `alguma-forma' sem qualquer saída

`:next'
     Como `:step', exceto `:next' passos sobre chamadas de fução

`:quit'
     Sai do nível corrente do depurador sem concluir a computação

`:resume'
     Continua a computação

`:step'
     Continua a computação até encontraruma nova linha de códico

`:top'
     Retorne para a linha de comando do Maxima (saindo de qualquer
     nível do depurador) sem completar a computação


File: maxima.info,  Node: Definições para Depuração,  Prev: Comandos Palavra Chave,  Up: Depurando

41.3 Definições para Depuração
==============================

 -- Variável de opção: refcheck
     Valor padrão: `false'

     Quando `refcheck' for `true', Maxima imprime uma mensagem cada vez
     que uma variável associada for usada pela primeira vez em uma
     computação.


 -- Variável de opção: setcheck
     Valor padrão: `false'

     Se `setcheck' for escolhido para uma lista de variáveis (as quais
     podem ser subscritas), Maxima mostra uma mensagem quando as
     variáveis, ou ocorrências subscritas delas, forem associadas com o
     operador comum de atribuição `:', o operador `::' de atribuição,
     ou associando argumentos de função, mas não com o operador de
     atribuição de função `:=' nem o operador de atribuição `::=' de
     macro.  A mensagem compreende o nome das variáveis e o valor
     associado a ela.

     `setcheck' pode ser escolhida para `all' ou `true' incluindo desse
     modo todas as variáveis.

     Cada nova atribuição de `setcheck' estabelece uma nova lista de
     variáveis para verificar, e quaisquer variáveis previamente
     atribuídas a `setcheck' são esquecidas.

     Os nomes atribuídos a `setcheck' devem ter um apóstrofo no início
     se eles forem de outra forma avaliam para alguma outra coisa que
     não eles mesmo.  Por exemplo, se `x', `y', e `z' estiverem
     atualmente associados, então digite

          setcheck: ['x, 'y, 'z]$

     para colocá-los na lista de variáveis monitoradas.

     Nenhuma saída é gerada quando uma variável na lista `setcheck' for
     atribuída a sí mesma, e.g., `X: 'X'.


 -- Variável de opção: setcheckbreak
     Valor padrão: `false'

     Quando `setcheckbreak' for `true', Maxima mostrará um ponto de
     parada quando uma variável sob a lista `setcheck' for atribuída a
     um novo valor.  A parada ocorre antes que a atribuíção seja
     concluída.  Nesse ponto, `setval' retém o valor para o qual a
     variável está para ser atribuída.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setval'.


 -- Variável de sistema: setval
     Mantém o valor para o qual a variável está para ser escolhida
     quando um `setcheckbreak' ocorrer.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setcheckbreak'.


 -- Função: timer (<f_1>, ..., <f_n>)
 -- Função: timer (all)
 -- Função: timer ()
     Dadas as funções <f_1>, ..., <f_n>, `timer' coloca cada uma na
     lista de funções para as quais cronometragens estatísticas são
     coletadas.  `timer(f)$ timer(g)$' coloca `f' e então `g' sobre a
     lista; a lista acumula de uma chamada para a chamada seguinte.

     `timer(all)' coloca todas as funções definidas pelo usuário (a
     saber pela variável global `functions') na lista de funções
     monitoradas pela função `time'.

     Sem argumentos, `timer' retorna a lista das funções tempo
     estatisticamente monitoradas.

     Maxima armazena quanto tempo é empregado executando cada função na
     lista de funções tempo estatisticamente monitoradas.  `timer_info'
     retorna a coronometragem estatística, incluindo o tempo médio
     decorrido por chamada de função, o número de chamadas, e o tempo
     total decorrido.  `untimer' remove funções da lista de funções
     tempo estatisticamente monitoradas.

     `timer' não avalia seus argumentos.  `f(x) := x^2$ g:f$ timer(g)$'
     não coloca `f' na lista de funções estatisticamente monitoradas.

     Se `trace(f)' está vigorando, então `timer(f)' não tem efeito;
     `trace' e `timer' não podem ambas atuarem ao mesmo tempo.

     Veja também `timer_devalue'.


 -- Função: untimer (<f_1>, ..., <f_n>)
 -- Função: untimer ()
     Dadas as funções <f_1>, ..., <f_n>, `untimer' remove cada uma das
     funções listadas da lista de funções estatisticamente monitoradas.

     Sem argumentos, `untimer' remove todas as funções atualmente na
     lista de funções estatisticamente monitoradas.

     Após `untimer (f)' ser executada, `timer_info (f)' ainda retorna
     estatisticas de tempo previamente coletadas, embora `timer_info()'
     (sem argumentos) não retorna informações sobre qualquer função que
     não estiver atualmente na lista de funções tempo estatisticamente
     monitoradas.  `timer (f)' reposiciona todas as estatisticas de
     tempo para zero e coloca `f' na lista de funções estatisticamente
     monitoradas novamente.


 -- Variável de opção: timer_devalue
     Valor Padrão: `false'

     Quando `timer_devalue' for `true', Maxima subtrai de cada
     função estatisticamente monitorada o tempo empregado em ou
     funções estatisticamente monitoradas. De outra forma, o tempo
     reportado para cada função inclui o tempo empregado em outras
     funções.  Note que tempo empregado em funções não estatisticamente
     monitoradas não é subtraído do tempo total.

     Veja também `timer' e `timer_info'.


 -- Função: timer_info (<f_1>, ..., <f_n>)
 -- Função: timer_info ()
     Dadas as funções <f_1>, ..., <f_n>, `timer_info' retorna uma
     matriz contendo informações de cronometragem para cada função.
     Sem argumentos, `timer_info' retorna informações de cronometragem
     para todas as funções atualmente na lista de funções
     estatisticamente monitoradas.

     A matriz retornada através de `timer_info' contém o nome da
     função, tempo por chamda de função, número de chamadas a
     funções,tempo total, e `gctime', cujja forma "tempo de descarte"
     no Macsyma original mas agora é sempre zero.

     Os dados sobre os quais `timer_info' constrói seu valor de retorno
     podem também serem obtidos através da função `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Veja também `timer'.


 -- Função: trace (<f_1>, ..., <f_n>)
 -- Função: trace (all)
 -- Função: trace ()
     Dadas as funções <f_1>, ..., <f_n>, `trace' instrui Maxima para
     mostrar informações de depuração quando essas funções forem
     chamadas.  `trace(f)$ trace(g)$' coloca `f' e então `g' na lista
     de funções para serem colocadas sob a ação de `trace'; a lista
     acumula de uma chamada para a seguinte.

     `trace(all)' coloca todas as funções definidas pelo usuário (a
     saber pela variável global `functions') na lista de funções a
     serem monitoradas pela função `trace'.

     Sem argumentos, `trace' retorna uma lista de todas as funções
     atualmente sob a ação de `trace'.

     A função `untrace' desabilita a ação de `trace'.  Veja também
     `trace_options'.

     `trace' não avalia seus argumentos. Dessa forma, `f(x) := x^2$
     g:f$ trace(g)$' não coloca `f' sobre a lista de funções
     monitoradas pela função `trace'.

     Quando uma função for redefinida, ela é removida da lista de
     `timer'.  Dessa forma após `timer(f)$ f(x) := x^2$', a função `f'
     não mais está na lista de `timer'.

     Se `timer (f)' estiver em efeito, então `trace (f)' não está
     agindo; `trace' e `timer' não podem ambas estar agindo para a
     mesma função.


 -- Função: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Função: trace_options (<f>)
     Escolhe as opções de `trace' para a função <f>.  Quaisquer
     opções anteriores são substituídas.  `trace_options (<f>, ...)'
     não tem efeito a menos que `trace (<f>)' tenha sido também chamada
     (ou antes ou após `trace_options').

     `trace_options (<f>)' reposiciona todas as opções para seus
     valores padrão.

     As opções de palavra chave são:

        * `noprint' Não mostre uma mensagem na entrada da função e saia.

        * `break' Coloque um ponto de parada antes da função ser
          inserida, e após a funçãos er retirada. Veja `break'.

        * `lisp_print' Mostre argumentos e valores de retorno com
          objetos Lisp.

        * `info' Mostre `-> true' na entrada da funçào e saia.

        * `errorcatch' Capture os erros, fornecendo a opção para
          sinalizar um erro, tentar novamente a chamada de função, ou
          especificar um valor de retorno.

     Opções para `trace' são especificadas em duas formas. A
     presença da palavra chave de opção sozinha coloca a opção para ter
     efeito incondicionalmente.  (Note que opção <foo> não coloca para
     ter efeito especificando `<foo>: true' ou uma forma similar; note
     também que palavras chave não precisam estar com apóstrofo.)
     Especificando a opção palavra chave com uma função predicado torna
     a opção condicional sobre o predicado.

     A lista de argumentos para a função predicado é sempre `[level,
     direction, function, item]' onde `level' é o nível rerecursão para
     a função,  `direction' é ou `enter' ou `exit', `function' é o nome
     da função, e `item' é a lista de argumentos (sobre entrada) ou o
     valor de retorno (sobre a saída).

     Aqui está um exemplo de opções incondicionais de `trace':

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Aqui está a mesma função, com a opção `break' condicional sobre um
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Função: untrace (<f_1>, ..., <f_n>)
 -- Função: untrace ()
     Dadas as funções <f_1>, ..., <f_n>, `untrace' desabilita a a
     monitoração habilitada pela função `trace'.  Sem argumentos,
     `untrace' desabilita a atuação da função `trade' para todas as
     funções.

     `untrace' retorne uma lista das funções para as quais `untrace'
     desabilita a atuação de `trace'.



File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: Depurando,  Up: Top

42 augmented_lagrangian
***********************

* Menu:

* Definições para augmented_lagrangian::


File: maxima.info,  Node: Definições para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

42.1 Definições para augmented_lagrangian
=========================================

 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Função: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          args_opcionais)
     Retorna um mínimo aproximado da expressão <FOM> com relação às
     variáveis <xx>, mantendo restrito o valor de <C> a zero.  <yy> é
     uma lista de suposições iniciais para <xx>.  O método utilizado é
     o método do Lagrangiano aumentado (veja referências [1] e [2]).

     `args_opcionais' representam argumentos adicionais, especificados
     como `<símbolo> = <valor>'.  Os argumentos opcionais que podem ser
     colocados no lugar de <símbolo>:

    `niter'
          Número de iterações do algorítmo do Langrangiano aumentado

    `lbfgs_tolerance'
          Tolerância forneceida a LBFGS (Limited-memory, Broyden,
          Fletcher, Goldfarb, Shanno)

    `iprint'
          parâmetro IPRINT (uma lista de dois inteiros que controlam o
          nível de informação) fornecido a LBFGS

    `%lambda'
          valor inicial de `%lambda' a ser usado durante o cálculo do
          Lagrangiano aumentado

     Essa implementação minimiza o Lagrangiano aumentado pela pela
     aplicação do algorítmo de memória limitada BFGS (LBFGS), que é um
     algorítmo quasi-Newton.

     `load(augmented_lagrangian)' chama essa função.

     Veja também `lbfgs'.

     References:

     [1]
     http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html

     [2] http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf

     Exemplo:

          (%i1) load (lbfgs);
          (%o1) /home/robert/tmp/maxima-release-branch/maxima/share/lbfgs/\
          lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2) /home/robert/tmp/maxima-release-branch/maxima/share/contri\
          b/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method (FOM, xx, C, yy, iprint = [-1, 0]);
          (%o7) [[x = 0.6478349888525, y = 0.32391749442625],
                                           %lambda = [- 1.267422460983745]]



File: maxima.info,  Node: bode,  Next: descriptive,  Prev: augmented_lagrangian,  Up: Top

43 bode
*******

* Menu:

* Definições para bode::


File: maxima.info,  Node: Definições para bode,  Prev: bode,  Up: bode

43.1 Definições para bode
=========================

 -- Função: bode_gain (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de ganho para Bode.

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Para usar essa função escreva primeiramente `load("bode")'. Veja
     também `bode_phase'

 -- Função: bode_phase (<H>, <range>, ...<plot_opts>...)
     Função para desenhar gráficos de fase para Bode

     Exemplos (1 a 7 provenientes de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 proveniente de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Para usar essa função escreva primeiramente `load("bode")'. Veja
     também `bode_gain'


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: bode,  Up: Top

44 descriptive
**************

* Menu:

* Introdução ao pacote descriptive::
* Definições para manipulação da dados::
* Definições para estatística descritiva::
* Definições específicas para estatística descritiva de várias variáveis::
* Definições para gráficos estatísticos::


File: maxima.info,  Node: Introdução ao pacote descriptive,  Next: Definições para manipulação da dados,  Prev: descriptive,  Up: descriptive

44.1 Introdução ao pacote descriptive
=====================================

O pacote `descriptive' contém um conjunto de funções para fazer
cálculos de estatística descritiva e desenhar gráficos. Juntamente com
o código fonte três conjuntos de dados em suar árvore do Maxima:
`pidigits.data', `wind.data' e `biomed.data'. Eles também podem ser
baixados a partir de `www.biomates.net'.

   Qualque manual de estatística pode ser usado como referência para as
funções no pacote `descriptive'.

   Para comentários, erros ou sugestões, por favor entre em contato
comigo em <'mario AT edu DOT xunta DOT es'>.

   Aqui está um exemplo sobre como as funções de estatística descritiva
no pacote `descriptive' fazem esse trabalho, dependendo da natureza de
seus argumentos, listas e matrizes,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* amostra de várias variáveis */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

   Note que em amostras de várias variáveis a média é calculada em cada
coluna.

   No caso de muitas amostras amostras com possíveis tamanhos
diferentes, A função do Maxima `map' pode ser usada para pegar os
resultados desejados de cada amostra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

   Nesse caso, duas amostras de tamanhos 3 e 2 foram armazenadas em uma
lista.

   Amostras de uma única variável devem ser armazenadas em listas como

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

   e amostras de várias variáveis em matrizes como em

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

   Nesse caso, o número de colunas é igual à dimensão (ao número) de
variáveis e o n;umero de linhas é o tamano da amostra.

   Dados podem ser introduzidos manualmente, mas grandes amostras são
usualmente armazenadas em arquivos no formato texto plano. Por exemplo,
o arquivo `pidigits.data' contém os primeiros 100 dígitos do número
`%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

   Com o objetivo de chamar esses dígitos no Maxima,

     (%i1) load (numericalio)$
     (%i2) s1 : read_list (file_search ("pidigits.data"))$
     (%i3) length (s1);
     (%o3)                          100

   Por outro lado, o arquivo `wind.data' contém a média diária de
velocidades do ventoem 5 estações meteorológicas na República da
Irlanda (Esses dados são parte de um conjunto de dados tomados em 12
estações meteorológicas. O arquivo original está disponivel livremente
para download no Repositório de Dados StatLib e sua análise é discutida
em Haslett, J., Raftery, A. E. (1989) <Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource, with
Discussion>. Applied Statistics 38, 1-50). As linhas seguintes mostram
como tornar os dados disponíveis para o Maxima:

     (%i1) load (numericalio)$
     (%i2) s2 : read_matrix (file_search ("wind.data"))$
     (%i3) length (s2);
     (%o3)                          100
     (%i4) s2 [%]; /* last record */
     (%o4)            [3.58, 6.0, 4.58, 7.62, 11.25]

   Algumas amostras possuem dados não numéricos. Como um exemplo, o
arquivo `biomed.data' (que é parte de outro grande arquivo tomado do
Repósitório de Dados StatLib) contém quatro medidas sangüíneas tomadas
de dois grupos de pacientes, `A' e `B', de diferentes idades,

     (%i1) load (numericalio)$
     (%i2) s3 : read_matrix (file_search ("biomed.data"))$
     (%i3) length (s3);
     (%o3)                          100
     (%i4) s3 [1]; /* first record */
     (%o4)            [A, 30, 167.0, 89.0, 25.6, 364]

   O primeiro indivíduo pertence ao grupo `A', com 30 anos de idade e
suas medidas sangüíneas foram 167.0, 89.0, 25.6 e 364.

   Se deve tomar cuidado quando se trabalha com dados divididos por
categorias. no exemplo seguinte, ao símbolo `a' é atribuído um valor em
algum momento anterior e então a amostra com valores divididos por
categoria `a' é interpretada como,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Definições para manipulação da dados,  Next: Definições para estatística descritiva,  Prev: Introdução ao pacote descriptive,  Up: descriptive

44.2 Definições para manipulação da dados
=========================================

 -- Função: continuous_freq (<list>)
 -- Função: continuous_freq (<list>, <m>)
     O argumetno de `continuous_freq' deve ser uma lista de números,
     que serão então agrupadas em intervalos e contado quantos desses
     dados pertencem a cada grupo. Opcionalmente, a função
     `continuous_freq' admite um segundo argumento indicando o número
     de classes, 10 é o valor padrão,

          (%i1) load (numericalio)$
          (%i2) load (descriptive)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) continuous_freq (s1, 5);
          (%o4) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     A primeira lista contém os limites de intervalos e o segundo a
     correspondente contagem: existem 16 algarismos da parte decimal de
     `%pi' dentro do intervalo `[0, 1.8]', isto é 0's e 1's, 24
     algarismos em `(1.8, 3.6]', isto é 2's e 3's, e assim por diante.

 -- Função: discrete_freq (<list>)
     Conta as freqüências absolutas em amostras discretas, em amostras
     numéricas e em amostras divididas em categorias. Seu único
     argumento é uma lista,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"));
          (%o3) [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8,
          4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7,
          1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4,
          5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8,
          6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7]
          (%i4) discrete_freq (s1);
          (%o4) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     A primeira lista fornece os valores da amostra e a segunda seuas
     freqüências absolutas. Os comandos `? col' e `? transpose' podem
     ajudar a você a entender a última entrada.

 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>)
 -- Função: subsample (<matriz_de_dados>, <expressão_lógica>,
          <col_num>, <col_num>, ...)
     Essas funções são um tipo de variação da função `submatrix' do
     Maxima. O primeiro argumento é o nome da matriz de dados, o
     segundo argumento é uma expressão lógica que recebeu apóstrofo e
     os argumentos opcionais adicionais são o número de colunas a serem
     tomadas. Esse comportamento é melhor entendido com exemplos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o4)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     Existem registros de várias variáveis nos quais a velocidade do
     vento na primeira estação meteorológica foram maiores que 18. Veja
     que na expressão lógica que recebeu apóstrofo o <i>-ésimo
     componente é referenciado como `%c[i]'. O símbolo `%c[i]' é usado
     dentro da função `subsample', portanto quando usado como uma
     variável de uma categoria, Maxima fica confuso. No seguinte
     exemplo, requisitamos somente o primeiro, o segundo e o quinto
     componentes desses registro com velocidades de vento maiores que
     ou igual a 16 nós na estação meteorológica número 1 e menor que 25
     nós na estação meteorológica número 4,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] >= 16 and %c[4] < 25), 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Aqui está um exemplo com as variáveis divididas em categorias do
     arquivo `biomed.data'. Queremos os registros correspondentes a
     aqueles pacientes no grupo `B' que possuem idade maior que 38 anos,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38));
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probavelmente, a análise estatística irá envolver somente as
     medidas sangüíneas,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38), 3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o4)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Essa é a média de várias variáveis de `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o4) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100
     Aqui, a primeira componente é sem sentido, uma vez que `A' e `B'
     são categorias, o segundo componente é a idade média dos
     indivíduos na forma racional, e o quarto eo último valores exibem
     um comportamento estranho. Isso ocorre porque o símbolo `NA' é
     usado aqui para indicar dado não disponível (<non available> em
     inglês), e as duas médias são certamente sem sentido. Uma
     solução possível pode ser jogar fora a matriz cujas linhas possuam
     símbolos `NA', embora isso cause alguma perda de informação,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (subsample (s3, '(%c[4] # NA and %c[6] # NA), 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Definições para estatística descritiva,  Next: Definições específicas para estatística descritiva de várias variáveis,  Prev: Definições para manipulação da dados,  Up: descriptive

44.3 Definições para estatística descritiva
===========================================

 -- Função: mean (<lista>)
 -- Função: mean (<matriz>)
     Essa função calcula a média de uma amostra, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean (s1);
                                         471
          (%o4)                          ---
                                         100
          (%i5) %, numer;
          (%o5)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) mean (s2);
          (%o7)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Função: var (<list>)
 -- Função: var (<matrix>)
     This is the sample variance, defined as
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var (s1), numer;
          (%o4)                   8.425899999999999

     See also function `var1'.

 -- Função: var1 (<lista>)
 -- Função: var1 (<matriz>)
     Essa função calcula a variância da amostra, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var1 (s1), numer;
          (%o4)                    8.5110101010101
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) var1 (s2);
          (%o6) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     See also function `var'.

 -- Função: std (<lista>)
 -- Função: std (<matriz>)
     A raíz quadrada da função `var', a variância com denominador n.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std (s1), numer;
          (%o4)                   2.902740084816414
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std (s2);
          (%o6) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Veja também as funções `var' e `std1'.

 -- Função: std1 (<lista>)
 -- Função: std1 (<matriz>)
     É a raíz quadrada da função `var1', a variância com denominador
     n-1.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std1 (s1), numer;
          (%o4)                   2.917363553109228
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std1 (s2);
          (%o6) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Veja também as funções `var1' e `std'.

 -- Função: noncentral_moment (<lista>, <k>)
 -- Função: noncentral_moment (<matriz>, <k>)
     O momento não central de ordem k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) noncentral_moment (s1, 1), numer; /* the mean */
          (%o4)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) noncentral_moment (s2, 5);
          (%o7) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]

     Veja também a função `central_moment'.

 -- Função: central_moment (<lista>, <k>)
 -- Função: central_moment (<matriz>, <k>)
     O momento central de ordem k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) central_moment (s1, 2), numer; /* a variância */
          (%o4)                   8.425899999999999
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) central_moment (s2, 3);
          (%o7) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     Veja também as funções `central_moment' e `mean'.

 -- Função: cv (<lista>)
 -- Função: cv (<matriz>)
     O coeficiente de variação é o quociente entre o desvio padrão da
     amostra (`std') e a média `mean',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) cv (s1), numer;
          (%o4)                   .6193977819764815
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) cv (s2);
          (%o6) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Veja também as funções `std' e `mean'.

 -- Função: mini (<lista>)
 -- Função: mini (<matriz>)
     Ë o vaor mínimo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mini (s1);
          (%o4)                           0
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mini (s2);
          (%o6)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Veja também função `maxi'.

 -- Função: maxi (<lista>)
 -- Função: maxi (<matriz>)
     É o valor máximo da amostra <lista>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) maxi (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) maxi (s2);
          (%o6)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Veja também a função `mini'.

 -- Função: range (<lista>)
 -- Função: range (<matriz>)
     A amplitude é a diferença entre os valores de maximo e de mínimo.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) range (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) range (s2);
          (%o6)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Função: quantile (<lista>, <p>)
 -- Função: quantile (<matriz>, <p>)
     É o <p>-`quantile' (quantil de ordem <p>), com <p> sendo um número
     em [0, 1] (intervalo fechado), da amostra <lista>.  Embora exista
     muitas Definições para quantil de uma amostra (Hyndman, R. J.,
     Fan, Y. (1996) <Sample quantiles in statistical packages>.
     American Statistician, 50, 361-365), aquela que se baseia em
     interpolação linear é a que foi implementada no pacote
     `descriptive'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) /* 1st and 3rd quartiles */ [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o4)                      [2.0, 7.25]
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quantile (s2, 1/4);
          (%o6)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Função: median (<lista>)
 -- Função: median (<matriz>)
     Uma vez que a amostra está ordenada, se o tamanho da amostra for
     ímpar a mediana é o valor central, de outra forma a mediana será a
     média dos dois valores centrais.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median (s1);
                                          9
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median (s2);
          (%o6)         [10.06, 9.855, 10.73, 15.48, 14.105]

     A mediana é o 1/2-`quantil'.

     Veja também function `quantile'.

 -- Função: qrange (<lista>)
 -- Função: qrange (<matriz>)
     A amplitude do interquartil é a diferença entre o terceiro e o
     primeiro quartil, `quantile(<lista>,3/4) - quantile(<lista>,1/4)',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) qrange (s1);
                                         21
          (%o4)                          --
                                         4
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) qrange (s2);
          (%o6) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Veja também a função `quantile'.

 -- Função: mean_deviation (<lista>)
 -- Função: mean_deviation (<matriz>)
     O desvio médio, definido como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean_deviation (s1);
                                         51
          (%o4)                          --
                                         20
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean_deviation (s2);
          (%o6) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Veja também a função `mean'.

 -- Função: median_deviation (<lista>)
 -- Função: median_deviation (<matriz>)
     O desvio da mediana, definido como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     onde `med' é a mediana da <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median_deviation (s1);
                                          5
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median_deviation (s2);
          (%o6)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Veja também a função `mean'.

 -- Função: harmonic_mean (<lista>)
 -- Função: harmonic_mean (<matriz>)
     A média harmônica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) harmonic_mean (y), numer;
          (%o4)                   3.901858027632205
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) harmonic_mean (s2);
          (%o6) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Veja também as funções `mean' e `geometric_mean'.

 -- Função: geometric_mean (<lista>)
 -- Função: geometric_mean (<matriz>)
     A média geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) geometric_mean (y), numer;
          (%o4)                   4.454845412337012
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) geometric_mean (s2);
          (%o6) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Veja também as funções `mean' e `harmonic_mean'.

 -- Função: kurtosis (<lista>)
 -- Função: kurtosis (<matriz>)
     O coeficiente de curtose, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) kurtosis (s1), numer;
          (%o4)                  - 1.273247946514421
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) kurtosis (s2);
          (%o6) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Veja também as funções `mean', `var' e `skewness'.

 -- Função: skewness (<lista>)
 -- Função: skewness (<matriz>)
     O coeficiente de assimetria, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) skewness (s1), numer;
          (%o4)                  .009196180476450306
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) skewness (s2);
          (%o6) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Veja também as funções `mean', `var' e `kurtosis'.

 -- Função: pearson_skewness (<lista>)
 -- Função: pearson_skewness (<matriz>)
     O coeficiente de assimetria de pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s
     onde <med> é a mediana de <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) pearson_skewness (s1), numer;
          (%o4)                   .2159484029093895
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) pearson_skewness (s2);
          (%o6) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Veja também as funções `mean', `var' e `median'.

 -- Função: quartile_skewness (<lista>)
 -- Função: quartile_skewness (<matriz>)
     O coeficiented de assimetria do quartil, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     onde c_p é o quartil de ordem <p> da amostra <lista>.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) quartile_skewness (s1), numer;
          (%o4)                  .04761904761904762
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quartile_skewness (s2);
          (%o6) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Veja também a função `quantile'.


File: maxima.info,  Node: Definições específicas para estatística descritiva de várias variáveis,  Next: Definições para gráficos estatísticos,  Prev: Definições para estatística descritiva,  Up: descriptive

44.4 Definições específicas para estatística descritiva de várias variáveis
===========================================================================

 -- Função: cov (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     onde X_j é a j-ésima linha da matriz de amostra.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$  /* modifique a precisão para obter uma saída melhor */
          (%i5) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o5) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     Veja também a função `cov1'.

 -- Função: cov1 (<matriz>)
     A matriz de covariância da amostra de várias variáveis, definida
     como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     where X_j is the j-th row of the sample matrix.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$ /* modifique a precisão para obter uma saída melhor */
          (%i5) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o5) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     Veja também a função `cov'.

 -- Função: global_variances (<matriz>)
 -- Função: global_variances (<matriz>, <valor_lógico>)
     A função `global_variances' retorna uma lista de medidas de
     variância global:

        * <variância total>: `trace(S_1)',

        * <variância média>: `trace(S_1)/p',

        * <variância generalizada>: `determinant(S_1)',

        * <desvio padrão generalizado>: `sqrt(determinant(S_1))',

        * <variância efetiva> `determinant(S_1)^(1/p)', (defined in:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desvio padrão efetivo>: `determinant(S_1)^(1/(2*p))'.
     onde <p> é a dimensão das várias variáveis aleatórias e S_1 a
     matriz de covariância retornada por `cov1'.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) global_variances (s2);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     A função `global_variances' tem um argumento lógico opcional:
     `global_variances(x,true)' diz ao Maxima que `x' é a matriz de
     dados, fazendo o mesmo que `global_variances(x)'. Por outro lado,
     `global_variances(x,false)' significa que `x' não é a matriz de
     dados, mas a matriz de covariância, evitando a repetição seu
     cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) global_variances (s, false);
          (%o5) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Veja também `cov' e `cov1'.

 -- Função: cor (<matriz>)
 -- Função: cor (<matriz>, <valor_lógico>)
     A matriz de correlação da maostra de várias variáveis.

     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     A função `cor' tem um argumento lógico opcional: `cor(x,true)' diz
     ao Maxima que `x' é a matriz de dados, fazendo o mesmo que
     `cor(x)'. Por outro lado, `cor(x,false)' significa que `x' não é a
     matriz de dados, mas a matriz de covariância, evitando a
     repetição de seu cálculo,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec:7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) s : cov1 (s2)$
          (%i6) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o6) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Veja também `cov' e `cov1'.

 -- Função: list_correlations (<matriz>)
 -- Função: list_correlations (<matriz>, <valor_lógico>)
     A função `list_correlations' retorna uma lista de medidas de
     correlação:

        * <matriz de precisão>: o inverso da matriz de covariância S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <vetor de correlação multipla>:  (R_1^2, R_2^2, ..., R_p^2),
          com
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          sendo um indicador do melhor do ajuste do modelo de regressão
          linear de várias variáveis dobre X_i quando o resto das
          variáveis são usados como regressores.

        * <matriz de correlação parcial>: como elemento (i, j) sendo
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Exemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) z : list_correlations (s2)$
          (%i5) fpprintprec : 5$ /* for pretty output */
          (%i6) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o6) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i7) z[2];  /* multiple correlation vector */
          (%o7)       [.85063, .80634, .86474, .71867, .72675]
          (%i8) z[3];  /* partial correlation matrix */
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o8)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     A função `list_correlations' também tem um argumento lógico
     opcional: `list_correlations(x,true)' diz ao Maxima que `x' é a
     matriz de dados, fazendo o mesmo que `list_correlations(x)'. Por
     outro lado, `list_correlations(x,false)' significa que `x' não é a
     matriz de correlação, mas a matriz de covariancia, evitando a
     repetição de seu cálculo.

     Veja também `cov' e `cov1'.


File: maxima.info,  Node: Definições para gráficos estatísticos,  Prev: Definições específicas para estatística descritiva de várias variáveis,  Up: descriptive

44.5 Definições para gráficos estatísticos
==========================================

 -- Função: dataplot (<lista>)
 -- Função: dataplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: dataplot (<matriz>)
 -- Função: dataplot (<matriz>, <opção_1>, <opção_2>, ...)
     A função `dataplot' permite visualização direta de dados de
     amostra, ambas d uma única variável (<lista>) e de várias
     variáveis (<matriz>). Fornecendo valores para as seguintes
     <opções> que são alguns aspéctos de impressão que podem ser
     controlados:

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          dispositivo/arquivo da figura de saída; valores corretos são
          `"x"', `"eps"' e `"png"', para a tela, formato de arquivo
          postscript e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x","y","z"]', é uma lista
          de nomes dos eixos `x', `y' e `z'.

        * `'joined', o valor padrão é `false', um valor lógico para
          selecionar pontos em 2D para serem unidos ou isolados.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * `'threedim', o valor padrão é `true', diz ao Maxima se ou
          monta-se o gráfico de uma matriz de três colunas como um
          diagrama 3D ou se monta-se o gráfico como um diagrama de
          dispersão de várias variáveis. Veja exemplos abaixo.

        * `'axisrot', o valor padrão é `[60, 30]', modifica o ponto de
          visualização quando `'threedim' for escolhido para `true'
          dados forem armazenados em uma matriz de três colunas. O
          primeiro número é o ângulo de rotação do eixo <x>, e o
          segundo número é o angulo de rotação do eixo <z>-axis, ambas
          as medidas em graus.

        * `'nclasses', o valor padrão é `10', é o número de classes
          para histogramas na diagonal de gráficos de dispersão de
          várias variáveis.

        * `'pointstyle', o valor padrão é `1', é um inteiro que indica
          como mostrar pontos de amostra.


     Por exemplo, com a seguite entrada um gráfico simples dos
     primeiros vinte dígitos de `%pi' é requisitado e a saída é
     armazenada em um arquivo no formato eps.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 20), 'pointstyle = 3)$

     Note que dados unidimensionais são colocados no gráfico como uma
     série de tempo. No caso seguinte, ocorre a mesma coisa só que com
     mais dados e com mais configurações,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 50), 'maintitle = "Primeiros dígitos de pi",
           'axisnames = ["ordem do dígito", "valor do dígito"], 'pointstyle = 2,
           'joined = true)$

     A função `dataplot' pode ser usada para montar gráficos de pontos
     no plano. O exemplo seguinte é gráfico de dispersão de pares de
     pontos de velocidades de vento para o primeira e para o quinta
     estação meteorológica,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (submatrix (s2, 2, 3, 4), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidade do vento em nós",
           'axisnames = ["Velocidade do vento em A", "Velocidade do vento em E"])$

     Se pontos forem armazenados em uma matriz de duas colunas,
     `dataplot' pode montar o gráfico desses pontos diretamente, mas se
     eles forem formatados em uma lista de pares, essa lista deve ser
     transformada em uma matriz como no seguinte exemplo.

          (%i1) load (descriptive)$
          (%i2) x : [[-1, 2], [5, 7], [5, -3], [-6, -9], [-4, 6]]$
          (%i3) dataplot (apply ('matrix, x), 'maintitle = "Pontos",
           'joined = true, 'axisnames = ["", ""], 'picturescales = [0.5, 1.0])$

     Pontos no espaço tridimensional podem ser vistos como uma
     projeção no plano. Nesse exemplo, o gráfico de velocidades do
     vento correspondendo a três estações meteorológicas são
     requisitados, primeiramente em um gráfico em 3D e a seguir em um
     gráfico de dispers@~ao de várias variáveis.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) /* 3D plot */ dataplot (submatrix (s2, 4, 5), 'pointstyle = 2,
           'maintitle = "Pares de medidas de velocidades do vento em nós",
           'axisnames = ["Estação A", "Estação B", "Estação C"])$
          (%i5) /* Gráfico de dispersão de várias variáveis */ dataplot (submatrix (s2, 4, 5),
           'nclasses = 6, 'threedim = false)$
     Note que no último exemplo, o número de classes no histogramas da
     diagonal é escolhido para 6, e aquela opção `'threedim' for
     escolhida para `false'.

     Para mais que três dimensões somente gráficos de dispersão de
     várias variáveis são possível, como em

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (s2)$

 -- Função: histogram (<lista>)
 -- Função: histogram (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: histogram (<one_column_matrix>)
 -- Função: histogram (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Essa função monta um gráfico de um histograma. Dados de amostras
     devem ser armazenados em uma lista de números ou em uma matriz de
     uma coluna. Fornecendo valores para as seguintes <opções> alguns
     aspéctos do gráfico podem ser controlados:

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          arquivo da figura de saída; valores corretos são `"x"',
          `"eps"' e `"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x", "Fr."]', é uma lista de
          nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * `'nclasses', o valor padrão é `10', é o número de classes ou
          o número de barras.

        * `'relbarwidth', o valor padrão é `0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * `'barcolor', o valor padrão é `1', um inteiro para indicar a
          cor das barras.

        * `'colorintensity', o valor padrão é `1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.


     Nos próximos dois exemplos, histogramas são requisitados para os
     primeiros 100 dígitos do número `%pi' e para velocidades do vento
     na terceira estação meteorológica.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) histogram (s1, 'maintitle = "dígitos de pi", 'axisnames = ["", "Freqüência absoluta"],
           'relbarwidth = 0.2, 'barcolor = 3, 'colorintensity = 0.6)$
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) histogram (col (s2, 3), 'colorintensity = 0.3)$
     Note tque no primeiro caso, `s1' é uma lista  e o segundo exemplo,
     `col(s2,3)' é uma matriz.

     Veja também a função `barsplot'.

 -- Função: barsplot (<lista>)
 -- Função: barsplot (<lista>, <opção_1>, <opção_2>, ...)
 -- Função: barsplot (<one_column_matrix>)
 -- Função: barsplot (<one_column_matrix>, <opção_1>, <opção_2>, ...)
     Similar a `histogram' mas para variáveis estatísticas, numéricas
     ou divididas em categorias. As opções estão abaixo,

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          arquivo da figura de saída; valores corretos são `"x"',
          `"eps"' e `"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["x", "Fr."]', é uma lista de
          nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.

        * `'relbarwidth', o valor padrão é `0.9', um número decimao
          entre 0 e 1 para controlar a largura das barras.

        * `'barcolor', o valor padrão é `1', um inteiro para indicar a
          cor das barras.

        * `'colorintensity', o valor padrão é `1', um número decimal
          entre 0 e 1 para estabelecer a intensidade da cor.


     Esse exemplo monta um gráfico de barras para os grupos `A' e `B'
     de pacientes na amostra `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 1), 'maintitle = "Grupos de pacientes",
           'axisnames = ["Grupo", "# de indivíduos"], 'colorintensity = 0.2)$
     A primeira coluna na amostra `s3' armazena os valores das
     categorias `A' e `B', também conhecidos algumas vezes como
     fatores. Por outro lado, os números inteiros positivos na segunda
     coluna sào idades, em anos, que se comportam como variável
     discreta, então podemos montar um gráfico as freqüências absolutas
     para esses valores,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 2), 'maintitle = "Idades",
           'axisnames = ["Anos", "# dos indivíduos"], 'colorintensity = 0.2,
           'relbarwidth = 0.6)$

     Veja também a função `histogram'.

 -- Função: boxplot (<data>)
 -- Função: boxplot (<data>, <opção_1>, <opção_2>, ...)
     Essa função monta diagramas em caixas. O argumento <data> pode ser
     uma lista, que não é de grande interesse, uma vez que esses
     diagramas são principalmente usados para comparação entre
     diferentes amostras, ou uma matriz, eentão é possível comparar
     dois ou mais componentes de uma variável estatística de várias
     variáveis. Mas é também permitido <data> se uma lista de amostras
     com tamanhos diferentes de amostra, de fato essa é aa única
     função no pacote `descriptive' que admite esse tipo de estrutura
     de dados. Veja o exemplo abaixo.  Abaixo etão as opções,

        * `'outputdev', o valor padrão é `"x"', indica o formato de
          arquivo da figura de saída; valores corretos são `"x"',
          `"eps"' e `"png"', para a tela, formato de arquivo postscript
          e formato de arquivo png, respectivamente.

        * `'maintitle', o valor padrão é `""', é o título principal
          entre aspas duplas.

        * `'axisnames', o valor padrão é `["sample", "y"]', é uma lista
          de nomes dos eixos `x' e `y'.

        * `'picturescales', o valor padrão é `[1.0, 1.0]', fator de
          proporcionalidade para o tamanho do gráfico.


     Examples:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) boxplot (s2, 'maintitle = "Velocidade do vento em nós",
           'axisnames = ["Estação do ano", ""])$
          (%i5) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i6) boxplot (A)$


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Definições para diag::


File: maxima.info,  Node: Definições para diag,  Prev: diag,  Up: diag

45.1 Definições para diag
=========================

 -- Função: diag (<lm>)
     Constrói a matriz quadrada com as matrizes de <lm> na diagonal.
     <lm> é uma lista de matrizes ou escalares.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Para usar essa função escreva primeiramente `load("diag")'.

 -- Função: JF (<lambda>,<n>)
     Retorna a célula de Jordan de ordem <n> com autovalor <lambda>.

     Exemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Para usar essa função escreva primeiramente `load("diag")'.

 -- Função: jordan (<mat>)
     Retorna a forma de Jordan da matriz <mat>, mas codificada em uma
     lista do Maxima.  Para pegar a matriz correspondente à
     codificação, chame a função `dispJordan' sando como argumento a
     saída de `JF'.

     Exemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `dispJordan' e `minimalPoly'.

 -- Função: dispJordan (<l>)
     Retorna a matriz de Jordan associada à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Para usar essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `minimalPoly'.

 -- Função: minimalPoly (<l>)
     Retorna o menor polinômio associado à codificação fornecida pela
     lista do Maxima <l>, que é a saída fornecida pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Para usar essa função escreva prmeiramente `load("diag")'. Veja
     também `jordan' e `dispJordan'.

 -- Função: ModeMatrix (<A>,<l>)
     Retorna a matriz <M> tal que (M^^-1).A.M=J, onde <J> é a forma de
     Jordan de <A>. A lista do Maxima <l> é a codificação da forma de
     Jordan como retornado pela função `jordan'.

     Exemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Note que `dispJordan(%o3)' é a forma de Jordan da matriz `a'.

     Para usa essa função escreva primeiramente `load("diag")'. Veja
     também `jordan' e `dispJordan'.

 -- Função: mat_function (<f>,<mat>)
     Retorna f(mat), onde <f> é uma função analítica e <mat> uma
     matriz. Essa computação é baseada na fórmula da integral de
     Cauchy, que estabelece que se `f(x)' for analítica e

          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     então

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])*ModeMatrix^^(-1)

     Note que existem entre 6 ou 8 outros métodos para esse cálculo.

     Segue-se alguns exemplos.

     Exemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Exemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Exemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Para usar essa função escreva primeiramente `load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introdução a distrib::
* Definições para distribuições contínuas::
* Definições para distribuições discretas::


File: maxima.info,  Node: Introdução a distrib,  Next: Definições para distribuições contínuas,  Prev: distrib,  Up: distrib

46.1 Introdução a distrib
=========================

Pacote `distrib' contém um conjunto de funções para fazer cálculos
envolvendo probabilidades de modelos de uma única variável estatística
e de ambos os tipos discreta e contínua.

   O que segue é um curto resumo de definiçoes básicas relacionadas à
teoria das probabilidades.

   Seja f(x) a <função densidade de probabilidade> absoluta de uma
variável aleatória contínua X. A <função distribuição de probabilidade>
é definida como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   que é igual à probabilidade <Pr(X <= x)>.

   O valor <médio> é um parâmetro de localização e está definido como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   A <variância> é uma medida de variação,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   que é um número real positivo. A raíz quadrada da variância é o
<desvio padrão>, D[X]=sqrt(V[X]), e esse <desvio padrão> é outra medida
de variação.

   O <coeficiente de assimetria> é uma medida de não simetria,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   E o <coeficiente de curtose> mede o grau de achatamento de uma
distribuição,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   Se X for gaussiana, KU[X]=0. De fato, ambos assimetria e curtose são
parâmetros de ajuste usados para medir a não gaussianidade de uma
distribuição.

   Se a variável aleatória X for discreta, a função densidade de
probabilidade, ou simplesmente <probabilidade>, f(x) toma valores
positivos dentro de certos conjuntos contáveis de números x_i, e zero
em caso contrário. Nesse caso, a função distribuição de probabilidade é
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   A média, variância, desvio padrão, coeficiente de assimetria e
coeficiente de curtose tomam a forma
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   and
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectively.

   O Pacote `distrib' inclui funções para simulação de variáveis
estatísticas pseudo-aleatórias. Algumas dessas funções fazem uso de
variáveis opcionais que indicam o algorítmo a ser usado.  O método
inverso genérico (baseado no fato que se <u> for um número aleatório
uniforme no intervalo (0,1), então <F^(-1)(u)> é uma variável
estatística pseudo-aleatória com distribuição F) está implementada para
a maioria dos casos; isso é um método subótimo em termos de
cronometragem, mas útil para fazer comparações com outros algorítmos.
Nesse exemplo, a `perandom_formance' dos algorítmos `ahrens_cheng' e
`inverse' em simular  variáveis chi-quadradas (letra grega "chi") são
comparadas por meio de seus histogramas:

     (%i1) load(distrib)$
     (%i2) load(descriptive)$
     (%i3) showtime: true$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     (%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
     Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
     (%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.

   Com o objetivo de fazer comparações visuais entre algorítmos para uma
variável estatística discreta, a função `barsplot' do pacote
`descriptive' pode ser usada.

   Note que algum trabalho resta para ser realizado, uma vez que essas
funções de simulação não foram ainda verificadas pelos mais
rigorosamente melhores dos testes de ajuste.

   Por favor, consulte um manual introdutório sobre probabilidade e
estatística para maiores informações sobre todo esse material
matemático.

   Existe uma convenção de nome no pacote `distrib'. Todo nome de
função tem duas partes, a primeira faz referência à função ou ao
parâmetro que queremos calcular,
     Funções:
        função densidade de probabilidade            (pdf_*)
        função distribuição de probabilidade       (cdf_*)
        Quartil                    (quantile_*)
        Média                        (mean_*)
        Variância                    (var_*)
        Desvio padrão          (std_*)
        Coeficiente de assimetria        (skewness_*)
        Coeficiente de curtose        (kurtosis_*)
        Variável estatística pseudo-aleatória              (random_*)

   A segunda parte é uma referência explícita ao modelo probabilístico,
     Distribuíções contínuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gama               (*gamma)
        Beta                (*beta)
        contínua uniforme  (*continuous_uniform)
        Logística            (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuições discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica            (*geometric)
        discreta uniforme     (*discrete_uniform)
        hipergeométrica       (*hypergeometric)
        Binomial Negativa    (*negative_binomial)

   Por exemplo, `pdf_student_t(x,n)' é a função densidade de
probabilidade da distribuição de Student com <n> graus de liberdade,
`std_pareto(a,b)' é o desvio padrão da distribuição de Pareto com
parâmetros <a> e <b> e `kurtosis_poisson(m)' é o coeficiente de curtose
da distribuição de Poisson com média <m>.

   Com o objetivo de fazer uso do pacote `distrib' você precisa primeiro
tornar esse pacote disponível para uso escrevendo
     (%i1) load(distrib)$

   Para comentários, melhorias ou sugestões, por favor contacte o autor
em <'mario AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para distribuições contínuas,  Next: Definições para distribuições discretas,  Prev: Introdução a distrib,  Up: distrib

46.2 Definições para distribuições contínuas
============================================

 -- Função: pdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Normal(m,s), com s>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_normal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma  variável aleatória Normal(m,s), com s>0. Essa função é
     definida em termos de funções de erro internas do Maxima, `erf'.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Veja também `erf'.

 -- Função: quantile_normal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Normal(m,s), com
     s>0; em outras palavras, isso é o inverso de `cdf_normal'. O
     argumento <q> deve ser um elemento de [0,1]. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: mean_normal (<m>,<s>)
     Retorna a média de uma  variável aleatória Normal(m,s), com s>0, a
     saber <m>. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_normal (<m>,<s>)
     Retorna a variância de uma  variável aleatória Normal(m,s), com
     s>0, a saber <s^2>. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: std_normal (<m>,<s>)
     Retorna o desvio padrão de uma  variável aleatória Normal(m,s),
     com s>0, a saber <s>. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_normal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma  variável aleatória
     Normal(m,s), com s>0, que é sempre igual  a 0. Para fazer uso
     dessa função,escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_normal (<m>,<s>)
     Retorna o coeficiente de curtose de uma  variável aleatória
     Normal(m,s), com s>0, que é sempre igual  a 0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_normal_algorithm
     Valor padrão: `box_mueller'

     Esse é o algorítmo selecionado para simular variáveis aleatórias
     normais.  O algorítmos implementados são `box_mueller' e `inverse':
        * `box_mueller', Baseado no algorítmo descrito em Knuth, D.E.
          (1981) <Seminumerical Algorithms. The Art of Computer
          Programming.> Addison-Wesley.

        * `inverse', baseado no método inverso genérico.

     Veja também `random_normal'.

 -- Função: random_normal (<m>,<s>)
 -- Função: random_normal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Normal(m,s), com
     s>0. Chamando `random_normal' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementados para essa função, e o
     algorítmo a ser usado pode ser selecionado fornecendo um certo
     valor para a variável global `random_normal_algorithm', cujo valor
     padrão é `box_mueller'.

     Veja também `random_normal_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória de Student t(n), com n>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_student_t (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória de Student t(n), com n>0. Essa função não
     tem uma forma definitiva e é calculada numericamente se a variável
     global `numer' for igual a `true',  de outra froma `cdf_student_t'
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                               1  7
          (%o2)                  cdf_student_t(-, -)
                                               2  3
          (%i3) %,numer;
          (%o3)                   .6698450596140417

 -- Função: quantile_student_t (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória de Student t(n),
     com n>0; em outras palavras, `quantile_student_t' é o inverso de
     `cdf_student_t'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_student_t (<n>)
     Retorna a média de uma variável aleatória de Student t(n), com
     n>0, que é sempre igual a 0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: var_student_t (<n>)
     Retorna a variância de uma variável aleatória de Student t(n), com
     n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Função: std_student_t (<n>)
     Retorna o desvio padrão de uma variável aleatória de Student t(n),
     com n>2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_student_t (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória de
     Student t(n), com n>3, que é sempre igual a 0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_student_t (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória de
     Student t(n), com n>4. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_student_t_algorithm
     Valor padrão: `ratio'

     Esse é o  algorítmo selecionado para simular variáveis
     estatísticas pseudo-aleatórias de Student. Algorítmos
     implementados são `inverse' e `ratio':
        * `inverse', baseado no método inverso genérico.

        * `ratio', baseado no fato que se <Z> for uma variável
          aleatória normal N(0,1) e S^2 for uma variável aleatória chi
          quadrada com <n> graus de liberdade, Chi^2(n), então
                                          Z
                                X = -------------
                                    /   2  \ 1/2
                                    |  S   |
                                    | ---  |
                                    \  n   /
          é uma variável aleatória de Student com <n> graus de
          liberdade, t(n).

     Veja também `random_student_t'.

 -- Função: random_student_t (<n>)
 -- Função: random_student_t (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória de Student t(n),
     com n>0. Chamando `random_student_t' com um segundo argumento <m>,
     uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_student_t_algorithm', cujo valor padrão é
     `ratio'.

     Veja também `random_student_t_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Chi-quadrada Chi^2(n), com n>0.

     A  variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2),
     portanto quando Maxima não tiver informação para pegar o
     resultado, uma forma nomial baseada na função de densidade
     densidade de probabilidade da função  gama é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Função: cdf_chi2 (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Chi-quadrada Chi^2(n), com n>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal baseada na
     distribuição gama, uma vez que a variável aleatória Chi^2(n) é
     equivalente a    é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
          (%o2)                  cdf_gamma(3, 2, 2)
          (%i3) cdf_chi2(3,4),numer;
          (%o3)                   .4421745996289249

 -- Função: quantile_chi2 (<q>,<n>)
     Retorna o <q>-quantilede uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0; em outras palavras, essa função é a inversa da
     função `cdf_chi2'. O argumento <q> deve ser um elemento de [0,1].

     This função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal baseada no
     quantil da função gama, uma vez que a variável aleatória Chi^2(n)
     é equivalente a Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Função: mean_chi2 (<n>)
     Retorna a média de uma variável aleatória Chi-quadrada Chi^2(n),
     com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Função: var_chi2 (<n>)
     Retorna a variância de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância da função gama é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Função: std_chi2 (<n>)
     Retorna o desvio padrão de uma variável aleatória Chi-quadrada
     Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão da função
     gama é retornada.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Função: skewness_chi2 (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     da função gama é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Função: kurtosis_chi2 (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Chi-quadrada Chi^2(n), com n>0.

     A variável aleatória Chi^2(n) é equivalente a Gamma(n/2,2), embora
     quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose da
     função gama é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Variável de opção: random_chi2_algorithm
     Valor padrão: `ahrens_cheng'

     Esse é o algorítmo selecionado para simular variáveis estatística
     pseudo-aleatórias Chi-quadradas. Os algorítmos implementados são
     `ahrens_cheng' e `inverse':
        * `ahrens_cheng', baseado na simulação aleatória de variáveis
          gama.  Veja `random_gamma_algorithm' para mais detalhes.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_chi2'.

 -- Função: random_chi2 (<n>)
 -- Função: random_chi2 (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Chi-square
     Chi^2(n), com n>0. Chamando `random_chi2' com um segundo argumento
     <m>, uma amostra aleatória de tamanho <m> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_chi2_algorithm', cujo valor padrão é
     `ahrens_cheng'.

     Veja também `random_chi2_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória F, F(m,n), com m,n>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_f (<x>,<m>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória F, F(m,n), com m,n>0. Essa função não
     possui uma forma definitiva e é calculada numericamente se a
     variável global `numer' for igual a `true',  de outra forma
     retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                               9
          (%o2)                    cdf_f(2, 3, -)
                                               4
          (%i3) %,numer;
          (%o3)                   0.66756728179008

 -- Função: quantile_f (<q>,<m>,<n>)
     Retorna o <q>-quantil de uma variável aleatória F, F(m,n), com
     m,n>0; em outras palavras, essa função é o inverso de `cdf_f'. O
     argumento <q> deve ser um elemento de [0,1].

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Função: mean_f (<m>,<n>)
     Retorna a média de uma variável aleatória F, F(m,n), com m>0, n>2.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_f (<m>,<n>)
     Retorna a variância de uma variável aleatória F, F(m,n), com m>0,
     n>4.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_f (<m>,<n>)
     Retorna o desvio padrão de uma variável aleatória F, F(m,n), com
     m>0, n>4.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_f (<m>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória F,
     F(m,n), com m>0, n>6. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_f (<m>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória F,
     F(m,n), com m>0, n>8. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_f_algorithm
     Valor padrão: `inverse'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias F. Os algorítmos implementados são `ratio' e
     `inverse':
        * `ratio', baseado no fato de que se <X> for uma variável
          aleatória Chi^2(m) e Y for uma variável aleatória Chi^2(n),
          então
                                       n X
                                   F = ---
                                       m Y
          é uma variável aleatória F com <m> e <n> graus de liberdade,
          F(m,n).

        * `inverse', baseado no método inverso genérico.


     Veja também `random_f'.

 -- Função: random_f (<m>,<n>)
 -- Função: random_f (<m>,<n>,<k>)
     Retorna uma variável estatística pseudo-aleatória F, F(m,n), com
     m,n>0. Chamando `random_f' com um terceiro argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_f_algorithm', cujo valor padrão é
     `inverse'.

     Veja também `random_f_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_exp (<x>,<m>)
     Retorna o valor em <x> da função densidade de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a
     Weibull(1,1/m), embora quando Maxima não tiver informação
     disponível para pegar o resultado, uma forma nominal baseada na
     função de densidade de probabilidade de Weibull éretornada.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Função: cdf_exp (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade
     variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Função: quantile_exp (<q>,<m>)
     Retorna o <q>-quantil variável aleatória Exponential(m), com m>0;
     em outras palavras, essa função é inversa da função `cdf_exp'.  O
     argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no qualtil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Função: mean_exp (<m>)
     Retorna a média de uma variável aleatória Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média de Weibull é
     reornada.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: var_exp (<m>)
     Retorna a variância de uma variável aleatória Exponential(m), com
     m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Função: std_exp (<m>)
     Retorna o desvio padrão de uma variável aleatória Exponential(m),
     com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Função: skewness_exp (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a Weibull(1,1/m),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Função: kurtosis_exp (<m>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Exponential(m), com m>0.

     A variável aleatória Exponential(m) é equivalente a
     Weibull(1,1/m), embora quando Maxima não tiver informação
     disponível para pegar o resultado, uma forma nominal baseada no
     coeficiente de curtose de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Variável de opção: random_exp_algorithm
     Valor padrão: `inverse'

     Esse é o algorítmo selecionado para simular variáveis exponenciais
     estatística pseudo-aleatórias. Os algorítmos implementados são
     `inverse', `ahrens_cheng' e `ahrens_dieter'
        * `inverse', baseado no método inverso genérico.

        * `ahrens_cheng', baseado no fato de que a variável aleatória
          Exp(m) é equivalente a Gamma(1,1/m). Veja
          `random_gamma_algorithm' para maiores detalhes.

        * `ahrens_dieter', baseado no algorítmo descrito em Ahrens,
          J.H. e Dieter, U. (1972) <Computer methods for sampling from
          the exponential and normal distributions.> Comm, ACM, 15,
          Oct.,  873-882.


     Veja também `random_exp'.

 -- Função: random_exp (<m>)
 -- Função: random_exp (<m>,<k>)
     Retorna uma variável estatística pseudo-aleatória Exponential(m),
     com m>0. Chamando `random_exp' com um segundo argumento <k>, uma
     amostra aleatória de tamanho <k> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_exp_algorithm', cujo valor padrão é
     `inverse'.

     Veja também `random_exp_algorithm'. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: pdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Lognormal(m,s), com s>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_lognormal (<x>,<m>,<s>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Lognormal(m,s), com s>0. Essa função é
     definida em termos de funções `erf'de erro internas do Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Veja também `erf'.

 -- Função: quantile_lognormal (<q>,<m>,<s>)
     Retorna o <q>-quantil de uma variável aleatória Lognormal(m,s),
     com s>0; em outras palavras, essa função é a inversa da função
     `cdf_lognormal'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_lognormal (<m>,<s>)
     Retorna a média de uma variável aleatória Lognormal(m,s), com s>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_lognormal (<m>,<s>)
     Retorna a variância de uma variável aleatória Lognormal(m,s), com
     s>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_lognormal (<m>,<s>)
     Retorna o desvio padrão de uma variável aleatória Lognormal(m,s),
     com s>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_lognormal (<m>,<s>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Lognormal(m,s), com s>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_lognormal (<m>,<s>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Lognormal(m,s), com s>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_lognormal (<m>,<s>)
 -- Função: random_lognormal (<m>,<s>,<n>)
     Retorna uma variável estatística pseudo-aleatória Lognormal(m,s),
     com s>0. Chamando `random_lognormal' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Variáveis Log-normal são simuladas por meio de variáveis
     estatísticas normais pseudo-aleatórias. Existem dois algorítmos
     implementados para essa função, se pode selecionar o algorítmo a
     ser usado fornecendo um certo valor à variável global
     `random_normal_algorithm', cujo valor padrão é `box_mueller'.

     Veja também `random_normal_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gamma(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_gamma (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gamma(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
          (%o2)                  cdf_gamma(3, 5, 21)
          (%i3) %,numer;
          (%o3)                 4.402663157135039E-7

 -- Função: quantile_gamma (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gamma(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_gamma'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_gamma (<a>,<b>)
     Retorna a média de uma variável aleatória Gamma(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_gamma (<a>,<b>)
     Retorna a variância de uma variável aleatória Gamma(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_gamma (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gamma(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_gamma (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gamma(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_gamma (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gamma(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_gamma_algorithm
     Valor padrão: `ahrens_cheng'

     Esse é o algorítmo selecionado para simular variáveis estatística
     gama pseudo-aleatórias. Os algorítmos implementados são
     `ahrens_cheng' e `inverse'
        * `ahrens_cheng', essa é uma combinação de dois processos,
          dependendo do valor do parâmetro <a>:

          For a>=1, Cheng, R.C.H. e Feast, G.M. (1979). <Some simple
          gamma variate generators>. Appl. Stat., 28, 3, 290-295.

          For 0<a<1, Ahrens, J.H. e Dieter, U. (1974). <Computer
          methods for sampling from gamma, beta, poisson and binomial
          cdf_tributions>. Computing, 12, 223-246.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_gamma'.

 -- Função: random_gamma (<a>,<b>)
 -- Função: random_gamma (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gamma(a,b), com
     a,b>0. Chamando `random_gamma' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_gamma_algorithm', cujo valor padrão é
     `ahrens_cheng'.

     Veja também `random_gamma_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Beta(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_beta (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Beta(a,b), com a,b>0.

     Essa função não possui uma forma fechada e é calculada
     numericamante se a variável global `numer' for igual a `true',  de
     outra forma essa função retorna uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                           1
          (%o2)                   cdf_beta(-, 15, 2)
                                           3
          (%i3) %,numer;
          (%o3)                 7.666089131388224E-7

 -- Função: quantile_beta (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Beta(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_beta'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_beta (<a>,<b>)
     Retorna a média de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_beta (<a>,<b>)
     Retorna a variância de uma variável aleatória Beta(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: std_beta (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Beta(a,b), com
     a,b>0.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_beta (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Beta(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_beta (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Beta(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_beta_algorithm
     Valor padrão: `cheng'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     beta pseudo-aleatórias. Os algorítmos implementados são `cheng',
     `inverse' e `ratio'
        * `cheng', esse é o algorítmo definido em Cheng, R.C.H.  (1978).
          <Generating Beta Variates with Nonintegral Shape Parameters>.
          Communications of the ACM, 21:317-322

        * `inverse', baseado no método inverso genérico.

        * `ratio', baseado no fato de que se <X> for uma variável
          aleatória Gamma(a,1) e <Y> for Gamma(b,1), então a razão
          X/(X+Y) está distribuída como Beta(a,b).


     Veja também `random_beta'.

 -- Função: random_beta (<a>,<b>)
 -- Função: random_beta (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Beta(a,b), com
     a,b>0. Chamando `random_beta' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_beta_algorithm', cujo valor padrão é
     `cheng'.

     Veja também `random_beta_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Continuous Uniform(a,b), com a<b.  Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_continuous_uniform (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Continuous Uniform(a,b), com a<b.  Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_continuous_uniform (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Continuous
     Uniform(a,b), com a<b; em outras palavras, essa função é a inversa
     da função `cdf_continuous_uniform'. O argumento <q> deve ser um
     elemento de [0,1].  Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_continuous_uniform (<a>,<b>)
     Retorna a média de uma variável aleatória Continuous Uniform(a,b),
     com a<b. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_continuous_uniform (<a>,<b>)
     Retorna a variância de uma variável aleatória Continuous
     Uniform(a,b), com a<b. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: std_continuous_uniform (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Continuous
     Uniform(a,b), com a<b. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Continuous Uniform(a,b), com a<b. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_continuous_uniform (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Continuous Uniform(a,b), com a<b. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: random_continuous_uniform (<a>,<b>)
 -- Função: random_continuous_uniform (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Continuous
     Uniform(a,b), com a<b. Chamando `random_continuous_uniform' com um
     terceiro argumento <n>, uma amostra aleatória de tamanho <n> será
     simulada.

     Essa é uma aplicação direta da função `random' interna do Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Logistic(a,b) , com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_logistic (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Logistic(a,b), com b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_logistic (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Logistic(a,b) , com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_logistic'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: meanlog (<a>,<b>)
     Retorna a média de uma Logistic(a,b) variável aleatória , com b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_logistic (<a>,<b>)
     Retorna a variância de uma variável aleatória Logistic(a,b) , com
     b>0.  Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_logistic (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Logistic(a,b) ,
     com b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_logistic (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Logistic(a,b) , com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_logistic (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Logistic(a,b) , com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_logistic (<a>,<b>)
 -- Função: random_logistic (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Logistic(a,b),
     com b>0.  Chamando `random_logistic' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Pareto(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_pareto (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Pareto(a,b), com a,b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_pareto (<q>,<a>,<b>)
     Retorna o <q>-quantile de uma variável aleatória Pareto(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_pareto'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_pareto (<a>,<b>)
     Retorna a média de uma variável aleatória Pareto(a,b), com
     a>1,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_pareto (<a>,<b>)
     Retorna a variância de uma variável aleatória Pareto(a,b), com
     a>2,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_pareto (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Pareto(a,b), com
     a>2,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_pareto (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Pareto(a,b), com a>3,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_pareto (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Pareto(a,b), com a>4,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_pareto (<a>,<b>)
 -- Função: random_pareto (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Pareto(a,b), com
     a>0,b>0. Chamando `random_pareto' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Weibull(a,b), com a,b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_weibull (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Weibull(a,b), com a,b>0. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_weibull (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Weibull(a,b), com
     a,b>0; em outras palavras, essa função é a inversa da função
     `cdf_weibull'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_weibull (<a>,<b>)
     Retorna a média de uma variável aleatória Weibull(a,b), com a,b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_weibull (<a>,<b>)
     Retorna a variância de uma variável aleatória Weibull(a,b), com
     a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_weibull (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Weibull(a,b),
     com a,b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_weibull (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Weibull(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_weibull (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Weibull(a,b), com a,b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_weibull (<a>,<b>)
 -- Função: random_weibull (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Weibull(a,b),
     com a,b>0. Chamando `random_weibull' com um terceiro argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função densidade de
     probabilidade de Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Função: cdf_rayleigh (<x>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na distribuição de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Função: quantile_rayleigh (<q>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Rayleigh(b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_rayleigh'. O argumento <q> deve ser um elemento de [0,1].

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no quantil de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Função: mean_rayleigh (<b>)
     Retorna a média de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na meia de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Função: var_rayleigh (<b>)
     Retorna a variância de uma variável aleatória Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância de Weibull é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Função: std_rayleigh (<b>)
     Retorna o desvio padrão de uma variável aleatória Rayleigh(b), com
     b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na Weibull desvio padrão é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Função: skewness_rayleigh (<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     de Weibull  é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Função: kurtosis_rayleigh (<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Rayleigh(b), com b>0.

     A variável aleatória Rayleigh(b) é equivalente a Weibull(2,1/b),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose de
     Weibull é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Função: random_rayleigh (<b>)
 -- Função: random_rayleigh (<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Rayleigh(b), com
     b>0.  Chamando `random_rayleigh' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Laplace(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_laplace (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Laplace(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_laplace (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Laplace(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_laplace'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_laplace (<a>,<b>)
     Retorna a média de uma variável aleatória Laplace(a,b), com b>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_laplace (<a>,<b>)
     Retorna a variância de uma variável aleatória Laplace(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_laplace (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Laplace(a,b),
     com b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_laplace (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Laplace(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_laplace (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Laplace(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_laplace (<a>,<b>)
 -- Função: random_laplace (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Laplace(a,b),
     com b>0.  Chamando `random_laplace' com um terceiro argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Cauchy(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_cauchy (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Cauchy(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_cauchy (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Cauchy(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_cauchy'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: random_cauchy (<a>,<b>)
 -- Função: random_cauchy (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo aleatória Cauchy(a,b), com
     b>0.  Chamando `random_cauchy' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função densidade de probabilidade de uma
     variável aleatória Gumbel(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_gumbel (<x>,<a>,<b>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Gumbel(a,b), com b>0. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_gumbel (<q>,<a>,<b>)
     Retorna o <q>-quantil de uma variável aleatória Gumbel(a,b), com
     b>0; em outras palavras, essa função é a inversa da função
     `cdf_gumbel'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_gumbel (<a>,<b>)
     Retorna a média de uma variável aleatória Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     onde o símbolol `%gamma' representa a constante de
     Euler-Mascheroni.  Veja também `%gamma'.

 -- Função: var_gumbel (<a>,<b>)
     Retorna a variância de uma variável aleatória Gumbel(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_gumbel (<a>,<b>)
     Retorna o desvio padrão de uma variável aleatória Gumbel(a,b), com
     b>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_gumbel (<a>,<b>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Gumbel(a,b), com b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     onde `zeta' representa a função zeta de Riemann.

 -- Função: kurtosis_gumbel (<a>,<b>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Gumbel(a,b), com b>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: random_gumbel (<a>,<b>)
 -- Função: random_gumbel (<a>,<b>,<n>)
     Retorna uma variável estatística pseudo-aleatória Gumbel(a,b), com
     b>0. Chamando `random_gumbel' com um terceiro argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Somente o método inverso genérico está implementado. Para fazer
     uso dessa função, escreva primeiramente `load(distrib)'.


File: maxima.info,  Node: Definições para distribuições discretas,  Prev: Definições para distribuições contínuas,  Up: distrib

46.3 Definições para distribuições discretas
============================================

 -- Função: pdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma
     Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: cdf_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Binomial(n,p) variável aleatória, com 0<p<1 e n um inteiro
     positivo.

     `cdf_binomial' é calculada numéricamente se a variável global
     `numer' for igual a `true',  de outra forma `cdf_binomial' retorna
     uma expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                                   1
          (%o2)                 cdf_binomial(5, 7, -)
                                                   6
          (%i3) cdf_binomial(5,7,1/6), numer;
          (%o3)                   .9998713991769548

 -- Função: quantile_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo; em outras palavras, essa função é a
     inversa da função `cdf_binomial'. O argumento <q> deve ser um
     elemento de [0,1]. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Binomial(n,p), com 0<p<1
     e n um inteiro positivo. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: var_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Binomial(n,p), com
     0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: std_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: skewness_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_binomial_algorithm
     Valor padrão: `kachit'

     Esse é o algorítmo selecionado para simular rvariáveis
     estatísticas pseudo-aleatórias binomiais. Os algorítmos
     implementados são `kachit', `bernoulli' e `inverse':
        * `kachit', baseado no algorítmo descrito em Kachitvichyanukul,
          V. and Schmeiser, B.W. (1988) <Binomial Random Variate
          Generation>. Communications of the ACM, 31, Feb., 216.

        * `bernoulli', baseado na simulação testes de Bernoulli.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_binomial'.

 -- Função: random_binomial (<n>,<p>)
 -- Função: random_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Chamando `random_binomial' com
     um terceiro argumento <m>, uma amostra aleatória de tamanho <m>
     será simulada.

     Existem três algorítmos implementado para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_binomial_algorithm', cujo valor padrão é
     `kachit'.

     Veja também `random_binomial_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Poisson(m), com m>0. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: cdf_poisson (<x>,<m>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Poisson(m), com m>0.

     Essa função é calculada numéricamente se a variável global `numer'
     for igual a `true',  de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)                   cdf_poisson(3, 5)
          (%i3) cdf_poisson(3,5), numer;
          (%o3)                   .2650259152973617

 -- Função: quantile_poisson (<q>,<m>)
     Retorna o <q>-quantil de uma variável aleatória Poisson(m), com
     m>0; em outras palavras, essa função é a inversa da função
     `cdf_poisson'. O argumento <q> deve ser um elemento de [0,1]. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_poisson (<m>)
     Retorna a média de uma variável aleatória Poisson(m), com m>0.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_poisson (<m>)
     Retorna a variância de uma variável aleatória Poisson(m), com
     m>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_poisson (<m>)
     Retorna o desvio padrão de uma variável aleatória Poisson(m), com
     m>0. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_poisson (<m>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Poisson(m), com m>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_poisson (<m>)
     Retorna o coeficiente de curtose de uma Poisson variável aleatória
     Poi(m), com m>0. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_poisson_algorithm
     Valor padrão: `ahrens_dieter'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias de Poisson.Os algorítmos implementados são
     `ahrens_dieter' e `inverse':
        * `ahrens_dieter', baseado no algorítmo descrito em Ahrens,
          J.H. and Dieter, U. (1982) <Computer Generation of Poisson
          Deviates From Modified Normal Distributions>.  ACM Trans.
          Math. Software, 8, 2, June,163-179.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_poisson'.

 -- Função: random_poisson (<m>)
 -- Função: random_poisson (<m>,<n>)
     Retorna uma variável estatística pseudo-aleatória Poisson(m), com
     m>0.  Chamando `random_poisson' com um segundo argumento <n>, uma
     amostra aleatória de tamanho <n> será simulada.

     Existem dois algorítmos implementado para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_poisson_algorithm', cujo valor padrão é
     `ahrens_dieter'.

     Veja também `random_poisson_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na função binomial de
     probabilidade é retornada.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Função: cdf_bernoulli (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Bernoulli(p), com 0<p<1.  Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_bernoulli (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Bernoulli(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     `cdf_bernoulli'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_bernoulli (<p>)
     Retorna a média de uma variável aleatória Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na média binomial é retornada.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Função: var_bernoulli (<p>)
     Retorna a variância de uma variável aleatória Bernoulli(p), com
     0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada na variância binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Função: std_bernoulli (<p>)
     Retorna o desvio padrão de uma variável aleatória Bernoulli(p),
     com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no desvio padrão binomial é
     retornada.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Função: skewness_bernoulli (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de assimetria
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Função: kurtosis_bernoulli (<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Bernoulli(p), com 0<p<1.

     A variável aleatória Bernoulli(p) é equivalente a Binomial(1,p),
     embora quando Maxima não tiver informação disponível para pegar o
     resultado, uma forma nominal baseada no coeficiente de curtose
     binomial é retornada.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Função: random_bernoulli (<p>)
 -- Função: random_bernoulli (<p>,<n>)
     Retorna uma variável estatística pseudo-aleatória Bernoulli(p),
     com 0<p<1. Chamando `random_bernoulli' com um segundo argumento
     <n>, uma amostra aleatória de tamanho <n> será simulada.

     Essa é uma aplicação direta da função `random' built-in função do
     Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Geometric(p), com 0<p<1. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: cdf_geometric (<x>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Geometric(p), com 0<p<1. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_geometric (<q>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Geometric(p), com
     0<p<1; em outras palavras, essa função é a inversa da função
     `cdf_geometric'. O argumento <q> deve ser um elemento de [0,1].
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: mean_geometric (<p>)
     Retorna a média de uma variável aleatória Geometric(p), com 0<p<1.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: var_geometric (<p>)
     Retorna a variância de uma variável aleatória Geometric(p), com
     0<p<1. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_geometric (<p>)
     Retorna o desvio padrão de uma variável aleatória Geometric(p),
     com 0<p<1. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: skewness_geometric (<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Geometric(p), com 0<p<1. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_geometric (<p>)
     Retorna o coeficiente de curtose de uma geometric variável
     aleatória  Geo(p), com 0<p<1. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_geometric_algorithm
     Valor padrão: `bernoulli'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo-aleatórias geométricas. Algorítmos implementados são
     `bernoulli', `devroye' e `inverse':
        * `bernoulli', baseado na simulação de testes de Bernoulli.

        * `devroye', baseado no algorítmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation.> Springer Verlag, p.
          480.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_geometric'.

 -- Função: random_geometric (<p>)
 -- Função: random_geometric (<p>,<n>)
     Retorna um Geometric(p) variável estatística pseudo-aleatória, com
     0<p<1.  Chamando `random_geometric' com um segundo argumento <n>,
     uma amostra aleatória de tamanho <n> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_geometric_algorithm', cujo valor padrão é
     `bernoulli'.

     Veja também `random_geometric_algorithm'. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Discrete Uniform(n), com n a strictly positive integer.
     Para fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: cdf_discrete_uniform (<x>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Discrete Uniform(n), com n inteiro
     estritamente positivo. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: quantile_discrete_uniform (<q>,<n>)
     Retorna o <q>-quantil de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo; em outras
     palavras, essa função é a inversa da função
     `cdf_discrete_uniform'. O argumento <q> deve ser um elemento de
     [0,1]. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: mean_discrete_uniform (<n>)
     Retorna a média de uma variável aleatória Discrete Uniform(n), com
     n um inteiro estritamente positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: var_discrete_uniform (<n>)
     Retorna a variância de uma variável aleatória Discrete Uniform(n),
     com n um inteiro estritamente positivo. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: std_discrete_uniform (<n>)
     Retorna o desvio padrão de uma variável aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: skewness_discrete_uniform (<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_discrete_uniform (<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Discrete Uniform(n), com n um inteiro estritamente positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: random_discrete_uniform (<n>)
 -- Função: random_discrete_uniform (<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória Discrete
     Uniform(n), com n um inteiro estritamente positivo. Chamando
     `random_discrete_uniform' com um segundo argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Isso é uma aplicação direta da função `random' built-in função do
     Maxima.

     Veja também `random'. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros
     não negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma variável aleatória Hypergeometric(n1,n2,n), com <n1>, <n2> e
     <n> inteiros não negativos e n<=n1+n2. Para fazer uso dessa
     função, escreva primeiramente `load(distrib)'.

 -- Função: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Retorna o <q>-quantil de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2; em outras palavras, essa função é a inversa
     da função `cdf_hypergeometric'.  O argumento <q> deve ser um
     elemento de [0,1]. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: mean_hypergeometric (<n1>,<n2>,<n>)
     Retorna a média de uma variável aleatória discreta univorme
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: var_hypergeometric (<n1>,<n2>,<n>)
     Retorna a variância de uma variável aleatória hipergeométrica
     Hyp(n1,n2,n), com <n1>, <n2> e <n> inteiros não negativos e
     n<=n1+n2. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: std_hypergeometric (<n1>,<n2>,<n>)
     Retorna o desvio padrão de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: skewness_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Função: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Para fazer uso dessa função, escreva
     primeiramente `load(distrib)'.

 -- Variável de opção: random_hypergeometric_algorithm
     Valor padrão: `kachit'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseudo aleatórias hipergeométricas.Os algorítmos implementados são
     `kachit' e `inverse':
        * `kachit', baseado no algorítmo descrito em Kachitvichyanukul,
          V., Schmeiser, B.W. (1985) <Computer generation of
          hypergeometric variáveis estatística pseudo-aleatórias.>
          Journal of Statistical Computation and Simulation 22, 127-145.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_hypergeometric'.

 -- Função: random_hypergeometric (<n1>,<n2>,<n>)
 -- Função: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Retorna uma variável estatística pseudo-aleatória
     Hypergeometric(n1,n2,n), com <n1>, <n2> e <n> inteiros não
     negativos e n<=n1+n2. Chamando `random_hypergeometric' com um
     quarto argumento <m>, uma amostra aleatória de tamanho <m> será
     simulada.

     Existem dois algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_hypergeometric_algorithm', cujo valor
     padrão é `kachit'.

     Veja também `random_hypergeometric_algorithm'. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: pdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função de probabilidade de uma variável
     aleatória Negative Binomial(n,p), com 0<p<1 e n um inteiro
     positivo. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: cdf_negative_binomial (<x>,<n>,<p>)
     Retorna o valor em <x> da função distribuição de probabilidade de
     uma Negative Binomial(n,p) variável aleatória, com 0<p<1 e n um
     inteiro positivo.

     Essa função é calculada numéricamente se a variável global `numer'
     for igual a `true',  de outra forma essa função retorna uma
     expressão nominal.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                                       1
          (%o2)            cdf_negative_binomial(3, 4, -)
                                                       8
          (%i3) cdf_negative_binomial(3,4,1/8), numer;
          (%o3)                  .006238937377929698

 -- Função: quantile_negative_binomial (<q>,<n>,<p>)
     Retorna o <q>-quantil de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo; em outras
     palavras, essa função é a inversa da função
     `cdf_negative_binomial'. O argumento <q> deve ser um elemento de
     [0,1]. Para fazer uso dessa função, escreva primeiramente
     `load(distrib)'.

 -- Função: mean_negative_binomial (<n>,<p>)
     Retorna a média de uma variável aleatória Negative Binomial(n,p),
     com 0<p<1 e n um inteiro positivo. Para fazer uso dessa função,
     escreva primeiramente `load(distrib)'.

 -- Função: var_negative_binomial (<n>,<p>)
     Retorna a variância de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: std_negative_binomial (<n>,<p>)
     Retorna o desvio padrão de uma variável aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.

 -- Função: skewness_negative_binomial (<n>,<p>)
     Retorna o coeficiente de assimetria de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Função: kurtosis_negative_binomial (<n>,<p>)
     Retorna o coeficiente de curtose de uma variável aleatória
     Negative Binomial(n,p), com 0<p<1 e n um inteiro positivo. Para
     fazer uso dessa função, escreva primeiramente `load(distrib)'.

 -- Variável de opção: random_negative_binomial_algorithm
     Valor padrão: `bernoulli'

     Esse é o algorítmo selecionado para simular variáveis estatísticas
     pseuso-aleatórias binomiais negativas. Os algorítmos implementados
     são `devroye', `bernoulli' e `inverse':
        * `devroye', baseado no algorítmo descrito em Devroye, L. (1986)
          <Non-Uniform Random Variate Generation>. Springer Verlag, p.
          480.

        * `bernoulli', baseado na simulação de testes de Bernoulli.

        * `inverse', baseado no método inverso genérico.


     Veja também `random_negative_binomial'.

 -- Função: random_negative_binomial (<n>,<p>)
 -- Função: random_negative_binomial (<n>,<p>,<m>)
     Retorna uma variável estatística pseudo-aleatória Negative
     Binomial(n,p), com 0<p<1 e n um inteiro positivo. Chamando
     `random_negative_binomial' com um terceiro argumento <m>, uma
     amostra aleatória de tamanho <m> será simulada.

     Existem três algorítmos implementados para essa função, se pode
     selecionar o algorítmo a ser usado fornecendo um certo valor à
     variável global `random_negative_binomial_algorithm', cujo valor
     padrão é `bernoulli'.

     Veja também `random_negative_binomial_algorithm'. Para fazer uso
     dessa função, escreva primeiramente `load(distrib)'.


File: maxima.info,  Node: draw,  Next: dynamics,  Prev: distrib,  Up: Top

47 draw
*******

* Menu:

* Introdução a draw::
* Definições para draw::


File: maxima.info,  Node: Introdução a draw,  Next: Definições para draw,  Prev: draw,  Up: draw

47.1 Introdução a draw
======================

`draw' é uma uma nova interface entre o Maxima e o Gnuplot.

   Existem três funções a serem usadas n nível do Maxima: `draw2d',
`draw3d' e `draw'.


File: maxima.info,  Node: Definições para draw,  Prev: Introdução a draw,  Up: draw

47.2 Definições para draw
=========================

 -- Opção gráfica: xrange
     Valor padrão: `false'

     Se `xrange' for `false', o intevalo para a coordenada <x> é
     calculado automaticamente.

     Caso o usuário deseje um intervalo específico para <x>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em `xrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Veja também `yrange' e `zrange'.

 -- Opção gráfica: yrange
     Valor padrão: `false'

     Se `yrange' for `false', the range for the <y> coordinate is
     computed automatically.

     Se o usuário sesejar um intervalo específico para <y>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em `yrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Veja também `xrange' e `zrange'.

 -- Opção gráfica: zrange
     Valor padrão: `false'

     Se `zrange' for `false', o intervalo para a coordenada <z> é
     calculado automaticamente.

     Se o usuário sesejar um intervalo específico para <z>, esse
     intervalo deve ser fornecido como uma lista da forma definida pelo
     Maxima, como em `zrange=[-2, 3]'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Veja também `yrange' e `zrange'.

 -- Opção gráfica: logx
     Valor padrão: `false'

     Se `logx' for `true', o eixo <x>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Veja também `logy' e `logz'.

 -- Opção gráfica: logy
     Valor padrão: `false'

     Se `logy' for `true', o eixo <y>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Veja também `logx' e `logz'.

 -- Opção gráfica: logz
     Valor padrão: `false'

     Se `logz' for `true', o eixo <z>será desenhado em escala
     logarítmica.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Veja também `logx' e `logy'.

 -- Opção gráfica: terminal
     Valor padrão: `screen'

     Seleciona o terminal a ser usado pelo Gnuplot; os valores
     possíveis são: `screen' (o valor padrão), `png', `jpg', `eps', e
     `eps_color'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       pic_width = 300,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$

     Veja também `file_name', `pic_width', e `pic_height'.

 -- Opção gráfica: grid
     Valor padrão: `false'

     Se `grid' for `true', uma malha será desenhada sobre o plano <xy>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opção gráfica: title
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `title' armazena uma seqüência de caracteres do Maxima com
     o título principal de um fundo gráfico.  Por padrão, nenhum título
     é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opção gráfica: xlabel
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `xlabel' armazena uma seqüência de caracteres do Maxima
     com o rótulo para o eixo <x>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Veja também `ylabel', e `zlabel'.

 -- Opção gráfica: ylabel
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `ylabel' armazena uma seqüência de caracteres do Maxima
     com o rótulo para o eixo <y>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Veja também `xlabel', e `zlabel'.

 -- Opção gráfica: zlabel
     Valor padrão: `""' (a seqüência de caracteres vazia)

     A opção `zlabel' armazena uma seqüência de caracteres do Maxima
     com o rótulo para o eixo <z>.  Por padrão, nenhum rótulo é escrito.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Veja também `xlabel', e `ylabel'.

 -- Opção gráfica: xtics
     Valor padrão: `true'

     Se `xtics' for `true', a marcação numérica será feitas sobre o
     eixo <x>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the x-axis */
                draw2d(xtics = false,
                       explicit(exp(u),u,-2,2))$

     Veja também `ytics', e `ztics'.

 -- Opção gráfica: ytics
     Valor padrão: `true'

     Se `ytics' for `true', a marcação numérica será feitas sobre o
     eixo <y>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(ytics = false,
                       explicit(exp(u),u,-2,2),
                       xtics = false)$

     Veja também `xtics', e `ztics'.

 -- Opção gráfica: ztics
     Valor padrão: `true'

     Se `ztics' for `true', a marcação numérica será feitas sobre o
     eixo <z>.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the z-axis */
                draw3d(ztics = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `xtics', e `ytics'.

 -- Opção gráfica: rot_vertical
     Valor padrão: 60

     `rot_vertical' é o ângulo (em graus) da rotação vertical (em torno
     do eixo <x>) para escolher o ponto de visualização em fundos
     gráficos tridimensionais.

     O ângulo é associado ao intervalo [0, 180].

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `rot_horizontal'.

 -- Opção gráfica: rot_horizontal
     Valor padrão: 30

     `rot_horizontal' é o ângulo (em graus) da rotação horizontal (em
     torno do eixo <z>)  para escolher o ponto de visualização em
     fundos gráficos tridimensionais.

     O ângulo é associado ao intervalo [0, 180].

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       rot_horizontal = 360,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `rot_vertical'.

 -- Opção gráfica: xy_file
     Valor padrão: `""' (a seqüência de caracteres vazia)

     `xy_file' é o nome do arquivo onde as coordenada serão armazenadas
     após um clique com o botão do mouse e pressionar a tecla 'x'. Por
     padrão, nenhuma coordenada é armazenada.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

 -- Opção gráfica: user_preamble
     Valor padrão: `""' (a seqüência de caracteres vazia)

     Usuários experientes de Gnuplot podem fazer uso dessa opção para
     ajuste fino do comportamento do Gnuplot escolhendo opções para
     serem enviadas antes do comando `plot' ou do comando `splot'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

     O terminal dumb não é suportado pelo pacote `draw', mas é possível
     escolher o terminal dumb fazendo uso da opção `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opção gráfica: file_name
     Valor padrão: `"maxima_out"'

     Esse é o nome do arquivo onde os terminais `png', `jpg', `eps' e
     `eps_color' guardarão o gráfico.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Veja também `terminal', `pic_width', e `pic_height'.

 -- Opção gráfica: pic_width
     Valor padrão: 640

     Essa é a largura do arquivo de bitmap gerado pelos terminais `png'
     e `jpg'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Veja também `terminal', `file_name', e `pic_height'.

 -- Opção gráfica: pic_height
     Valor padrão: 640

     Essa é a altura do arquivo de bitmap gerado pelos terminais `png'
     e `jpg'.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Veja também `terminal', `file_name', e `pic_width'.

 -- Opção gráfica: axis_bottom
     Valor padrão: `true'

     Se `axis_bottom' for `true', o eixo inferior é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_left',  `axis_top', `axis_right', e `axis_3d'.

 -- Opção gráfica: axis_left
     Valor padrão: `true'

     Se `axis_left' for `true', o eixo da esquerda é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_bottom',  `axis_top', `axis_right', e `axis_3d'.

 -- Opção gráfica: axis_top
     Valor padrão: `true'

     Se `axis_top' for `true', o eixo superior é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_bottom',  `axis_left', `axis_right', e `axis_3d'.

 -- Opção gráfica: axis_right
     Valor padrão: `true'

     Se `axis_right' for `true', o eixo da direita é mostrado em fundos
     gráficos bidimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Veja também `axis_bottom',  `axis_left', `axis_top', e `axis_3d'.

 -- Opção gráfica: axis_3d
     Valor padrão: `true'

     Se `axis_3d' for `true', os eixos <x>, <y> e <z> são mostrados em
     fundos gráficos tridimensionais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Veja também `axis_bottom',  `axis_left', `axis_top', e
     `axis_right' para eixos em duas dimensões.

 -- Opção gráfica: point_size
     Valor padrão: 1

     `point_size' escolhe o tamanho para os pontos do gr´afico. Esse
     valor deve ser um número não negativo.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(points(makelist([random(20),random(50)],k,1,10)),
                       point_size = 5,
                       points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opção gráfica: point_type
     Valor padrão: 1

     `point_type' é um índice (maior ou igual a -1) para especificar
     como os pontos são mostrados.  As cores dos pontos são controladas
     com essa opção.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `explicit', `implicit', `parametric', e
          `polar'.

        * `gr3d': `points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = 1,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = 2,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = 3,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = 4,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = 7,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = 9,
                       points([[1,9],[5,9],[9,9]]) )$
          (%i3) draw2d(function_style = 'dots,
                       point_type = -1,
                       explicit(x^2,x,-1,1),
                       point_type = 7,
                       explicit(x^4,x,-1,1))$

 -- Opção gráfica: points_joined
     Valor padrão: `false'

     Se `points_joined' for `true', pontos são unidos por linhas retas.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = 1,
                       line_type     = 3,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = 3,
                       line_type     = 5,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = 5,
                       line_type     = 8,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opção gráfica: fill_type
     Valor padrão: 1

     `fill_type' é um índice (maior ou igual a -1) para especificar a
     cor para regiões a serem preenchidas.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `polygon', `rectangle', `ellipse', `explicit', e
          `implicit'.


     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_type      = 6,
                       polygon([[3,2],[7,2],[5,5]]),
                       fill_type      = 2,
                       function_style = filled,
                       explicit(sin(x),x,0,10) )$

 -- Opção gráfica: transparent
     Valor padrão: `false'

     Se `transparent' for `true', regiões internas de poligonos são
     preenchidas de acordo com `fill_type'.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `polygon', `rectangle', e `ellipse'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       line_type   = 3,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opção gráfica: border
     Valor padrão: `true'

     Se `border' for `true', bordas de polígonos são colorizadas de
     acordo com `line_type' e `line_width'.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `polygon', `rectangle', e `ellipse'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type   = 3,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_type   = 6,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opção gráfica: head_both
     Valor padrão: `false'

     Se `head_both' for `true', vetores são mostrados com seta dupla na
     ponta.  Se `false', somente uma seta é mostrada.

     Essa opção somente é relevante para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Veja também `head_length', `head_angle', e `head_type'.

 -- Opção gráfica: head_length
     Valor padrão: 2

     `head_length' indica, em unidades do eixo <x>, o comprimento da
     ponta da seta do vetor.

     Essa opção é relevante somente para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Veja também `head_both', `head_angle', e `head_type'.

 -- Opção gráfica: head_angle
     Valor padrão: 45

     `head_angle' indica o ângulo, em graus, entre a ponta da seta do
     vetor e o segmento que forma o corpo do vetor.

     Essa opção é relevante somente para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Veja também `head_both', `head_length', e `head_type'.

 -- Opção gráfica: head_type
     Valor padrão: `filled'

     `head_type' é usada para especificar como a ponta é mostrada.
     Valores possíveis são: `filled' (ponta fechada e preenchida),
     `empty' (ponta fechada mas não preenchida), e `nofilled' (ponta
     aberta).

     Essa opção é relevante somente para objetos do tipo `vector'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Veja também `head_both', `head_angle', e `head_length'.

 -- Opção gráfica: label_alignment
     Valor padrão: `center'

     `label_alignment' é usado para especificar onde escrever rótulos
     com relação às coordenadas fornecidas. Valores possíveis são:
     `center', `left', e `right'.

     Essa opção é relevante somente para objetos do tipo `label'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       label_color     = 3,
                       label("Centered alignment (default)",5,2),
                       label_alignment = 'left,
                       label("Left alignment",5,5),
                       label_alignment = 'right,
                       label("Right alignment",5,8))$

     Veja também `label_orientation', e `label_color'.

 -- Opção gráfica: label_orientation
     Valor padrão: `horizontal'

     `label_orientation' é usada para especificar a orientação dos
     rótulos.  Valores possíveis são: `horizontal', e `vertical'.

     Essa opção é relevante somente para objetos do tipo `label'.

     Exemplo:

     Nesse exemplo, um ponto fictício é adicionado para firmar uma
     imagem.  o pacote `draw' precisa sempre de dados para montar um
     fundo.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       label("Horizontal orientation (default)",5,2),
                       label_orientation = 'vertical,
                       label("Vertical orientation",1,5))$

     Veja também `label_alignment', e `label_color'.

 -- Opção gráfica: label_color
     Valor padrão: 1

     `label_color' é um índice (maior ou igual a -1) para especificar a
     cor da fonte usada no rótulo.

     Essa opção é relevante somente para objetos do tipo `label'.

     Exemplo:

     Nesse exemplo, um ponto imaginário é adicionado para firmar uma
     imagem.  O pacote `draw' precisa sempre de dados para desenharum
     fundo.  Essas cores podem mudar em diferentes terminais.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[0,0]]),
                       label_color = -1,
                       label("Cor de rótulo -1",5,1),
                       label_color = 1,
                       label("Cor de rótulo 1 (default)",5,2),
                       label_color = 2,
                       label("Cor de rótulo 2",5,3),
                       label_color = 3,
                       label("Cor de rótulo 3",5,4),
                       label_color = 4,
                       label("Cor de rótulo 4",5,5),
                       label_color = 5,
                       label("Cor de rótulo 5",5,6),
                       label_color = 6,
                       label("Cor de rótulo 6",5,7),
                       label_color = 7,
                       label("Cor de rótulo 7",5,8),
                       label_color = 8,
                       label("Cor de rótulo 8",5,9) )$

     Veja também `label_alignment', e `label_orientation'.

 -- Opção gráfica: line_width
     Valor padrão: 1

     `line_width' é a lagura para linhas do gráfico.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' e `polar'.

        * `gr3d': `points' e `parametric'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Veja também `line_type'.

 -- Opção gráfica: line_type
     Valor padrão: 1

     `line_type' é um índice (maior ou igual a -1) para especificar
     como linhas são mostradas.  A cor das linhas é controlada com essa
     opção.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' e `polar'.

        * `gr3d': `points', `explicit', `parametric' e
          `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default type */
                       line_type = 5,
                       explicit(1 + x^2,x,-1,1),
                       line_type = 10,
                       explicit(2 + x^2,x,-1,1))$

     Veja também `line_width'.

 -- Opção gráfica: nticks
     Valor padrão: 30

     `nticks' é o número de amostra de pontos usado pelas rotinas de
     montagem de gráfico.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' e `polar'.

        * `gr3d': `parametric'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opção gráfica: adapt_depth
     Valor padrão: 10

     `adapt_depth' é o número máximo de quebras usado pelas rotinas
     adaptativos de impressão.

     Essa opção é relevante somente para funções 2d `explicitas'.

 -- Opção gráfica: key
     Valor padrão: `""' (a seqüência de caracteres vazia)

     `key' é o nome de uma função na legenda. Se `key' é uma seqüência
     de caracteres vazia, nenhuma chave é atribuída à função.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric', e `polar'.

        * `gr3d': `points', `explicit', `parametric', e
          `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key = "Seno",
                       explicit(sin(x),x,0,10),
                       key = "Cosseno",
                       line_type = 3,
                       explicit(cos(x),x,0,10) )$

 -- Opção gráfica: function_style
     Valor padrão: `lines'

     `function_style' indica como funções são mostradas: com linhas
     (`lines') ou com pontos (`dots').

     Essa opção afeta os seguintes objetos gráficos:
        * `gr2d': `explicit', `implicit', `parametric', e `polar'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key = "Seno",
                       explicit(sin(x),x,0,10),
                       key = "Cosseno",
                       function_style = 'dots,
                       explicit(cos(x),x,0,10) )$

 -- Opção gráfica: xu_grid
     Valor padrão: 30

     `xu_grid' é o número de coordenadas da primeira variável (`x' na
     forma explícita e o número de coordenadas de `u' em superfícies
     tridimensionais na forma paramétrica) para contruir a grade dos
     pontos de amostra.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr3d': `explicit' e `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Veja também `yv_grid'.

 -- Opção gráfica: yv_grid
     Valor padrão: 30

     `yv_grid' é o número de coordenadas da segunda variável (`y' na
     forma explícita e o número de coordenadas de `v' em superfícies
     tridimensionais na forma paramétrica) para construir a grade dos
     pontos de amostra.

     Essa opção afeta os seguintes objetos gráficos:
        * `gr3d': `explicit' e `parametric_surface'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Veja também `xu_grid'.

 -- Opção gráfica: surface_hide
     Valor padrão: `false'

     Se `surface_hide' for `true', partes escondidas não são mostradas
     no gráfico em superfícies tridimensioais.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opção gráfica: contour
     Valor padrão: `none'

     Option `contour' torna o usuário capaz de selecionar onde imprimir
     linhas de contorno.  Valores possíveis são:

        * `none': nenhuma linha de contorno é mostrada.

        * `base': linhas de contorno são projetadas no plano xy.

        * `surface': linhas de contorno são mostradas sobre a
          superfície.

        * `both': duas linhas de contorno são mostradas: no plano xy e
          sobre a superfície.

        * `map': linhas de contorno são projetadas sobre o plano xy, e
          o ponto de boservação é escolhido na vertical.


     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Opção gráfica: contour_levels
     Valor padrão: 5

     `contour_levels' é o número de níveis em gráficos de contorno.

     Uma vez que essa é uma opção gráfica global, sua posição na
     descrição do fundo não é importante.

     Exemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

 -- Opção gráfica: columns
     Valor padrão: 1

     `columns' é o número de colunas em gráficos multiplos.

     Note que essa opção deve ser escrita fora de objetos `gr2d' e de
     objetos `gr3d'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Elipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triângulo",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opção gráfica: ip_grid
     Valor padrão: `[50, 50]'

     `ip_grid' escolhe a grade para a primeira amostragem em gráficos
     implícitos.

     Essa opção é relevante somente para `implicit' objects.

 -- Opção gráfica: ip_grid_in
     Valor padrão: `[5, 5]'

     `ip_grid_in' escolhe a grade para a segunda amostragem em gráficos
     implícitos.

     Essa opção é relevante somente para `implicit' objects.

 -- Construtor de fundo gráfico: gr2d (<opção gráfica>, ..., <objeto
          gráfico>, ...)
     A função `gr2d' constrói um objeto descrevendo um fundo gráfico em
     duas dimensões. Arguments are opções gráficas e objetos gráficos.
     Esse fundo gráfico é interpretado seqüêncialmente: opções gráficas
     afetam aqueles objetos gráficos colocados imediatamente à sua
     direita.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.

     Adiante encontra-se uma lista de objetos gráficos disponívies para
     fundos gráficos em duas dimensões:

        * `points([[x1,y1], [x2,y2], [x3,y3],...])' ou
          `points([x1,x2,x3,...], [y1,y2,y3,...])': posiciona os pontos
          `[x1,y1]', `[x2,y2]', `[x2,y2]', ... no gráfico.

          Esse objeto é efetado pelas seguintes opções gráficas:
          `point_size', `point_type', `points_joined', `line_width',
          `key' e `line_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(key           = "Small points",
                            points(makelist([random(20),random(50)],k,1,10)),
                            point_type    = 6,
                            point_size    = 3,
                            points_joined = true,
                            key           = "Great points",
                            points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

        * `polygon([[x1,y1], [x2,y2], [x3,y3],...])' ou
          `polygon([x1,x2,x3,...], [y1,y2,y3,...])': desenha um
          polígono com vértices `[x1,y1]', `[x2,y2]', `[x2,y2]', ... no
          plano.

          Esse objeto é afetado pelas seguintes opçs gráficas:
          `transparent', `fill_type', `border', `line_width', `key' e
          `line_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(line_type   = 3,
                            line_width  = 8,
                            polygon([[3,2],[7,2],[5,5]]),
                            border      = false,
                            fill_type   = 6,
                            polygon([[5,2],[9,2],[7,5]]) )$

        * `rectangle([x1,y1], [x2,y2])': desenha um retângulo partindo
          do vértice `[x1,y1]' e terminando no vértice `[x2,y2]' oposto
          ao primeiro.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `transparent', `fill_type', `border', `line_width', `key' e
          `line_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(fill_type   = 6,
                            line_width  = 6,
                            line_type   = 2,
                            transparent = false,
                            fill_type   = 8,
                            rectangle([-2,-2],[8,-1]),   /* opposite vertices */
                            transparent = true,
                            line_type   = 5,
                            line_width  = 1,
                            rectangle([9,4],[2,-1.5]),
                            xrange      = [-3,10],
                            yrange      = [-3,4.5] )$

        * `ellipse(xc, yc, a, b, ang1, ang2)': desenha uma elipse com
          centro em `[xc, yc]' com semi-eixo maior `a' e semi-eixo
          menor `b' traçando um arco de elipse que se inicia no ângulo
          `ang1' e que vai até o ângulo `ang2'.  semi axis `a' e `b',
          respectively, from angle `ang1' to angle `ang2'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `transparent', `fill_type', `border', `line_width',
          `line_type' e `key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(transparent = false,
                            fill_type   = 8,
                            line_type   = 5,
                            transparent = false,
                            line_width  = 5,
                            ellipse(0,6,3,2,270,-270),  /* center (x,y), a, b, start & end in degrees */
                            transparent = true,
                            line_type   = 7,
                            line_width  = 3,
                            ellipse(2.5,6,2,3,30,-90),
                            xrange      = [-3,6],
                            yrange      = [2,9] )$

        * `label(rótulo,x,y)': escreve o `rótulo' no ponto `[x,y]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `label_alignment', `label_orientation' e `label_color'.

          Exemplo:

          Nesse exemplo, um ponto imaginário é adicionado para firmar a
          imagem.  O pacote `draw' precisa sempre da dados para
          desenhar um fundo.  Essas cores podem mudar em diferentes
          terminais.
               (%i1) load(draw)$
               (%i2) draw2d(xrange     = [0,10],
                            yrange     = [0,10],
                            point_size = 0,
                            points([[0,0]]),
                            label_color = -1,
                            label("Cor de rótulo -1",5,1),
                            label_color = 1,
                            label("Cor de rótulo 1 (default)",5,2),
                            label_color = 2,
                            label("Cor de rótulo 2",5,3),
                            label_color = 3,
                            label("Cor de rótulo 3",5,4),
                            label_color = 4,
                            label("Cor de rótulo 4",5,5),
                            label_color = 5,
                            label("Cor de rótulo 5",5,6),
                            label_color = 6,
                            label("Cor de rótulo 6",5,7),
                            label_color = 7,
                            label("Cor de rótulo 7",5,8),
                            label_color = 8,
                            label("Cor de rótulo 8",5,9) )$

        * `vector([x,y], [dx,dy])': desenha um vetor de componentes
          ortogonais `[dx,dy]' com orígem eno ponto `[x,y]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `head_both', `head_length', `head_angle', `head_type',
          `line_width', `line_type' e `key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(xrange      = [0,12],
                            yrange      = [0,10],
                            head_length = 1,
                            vector([0,1],[5,5]), /* default type */
                            head_type = 'empty,
                            vector([3,1],[5,5]),
                            head_both = true,
                            head_type = 'nofilled,
                            vector([6,1],[5,5]))$

        * `explicit(fcn,var,minval,maxval)': monta o gráfico da
          função explícita `fcn', com variável `var' assumindo valores
          de `minval' a `maxval'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `adapt_depth', `line_width', `line_type', `key',
          `point_type', `function_style' e `fill_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(xu_grid = 10,
                            yv_grid = 50,
                            explicit(x^2+y^2,x,-3,3,y,-3,3) )$

        *
          `implicit(fcn,x-var,x-minval,x-maxval,y-var,y-minval,y-maxval)':
          monta o gráfico da função implícita definida por `fcn', com
          variável `x-var' assumindo de `x-minval' a `x-maxval', e
          variável `y-var' assumindo valores de `y-minval' a `y-maxval'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `ip_grid', `ip_grid_in', `line_width', `line_type', `key',
          `filled_function' e `fill_type', e `fill_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(grid      = true,
                            line_type = -1,
                            key       = "y^2=x^3-2*x+1",
                            implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                            line_type = 0,
                            key       = "x^3+y^3 = 3*x*y^2-x-1",
                            implicit(x^3+y^3 = 3*x*y^2-x-1, x, -4,4, y, -4,4),
                            title     = "Two implicit functions" )$

        * `polar(radius,ang,minang,maxang)': plots function
          `radius(ang)' defined in polar coordinates, com a variável
          `ang' assumindo valores de `minang' a `maxang'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type', `key', `function_style'
          e `point_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(user_preamble = "set grid polar",
                            nticks        = 200,
                            xrange        = [-5,5],
                            yrange        = [-5,5],
                            line_type     = 6,
                            line_width    = 3,
                            title         = "Hyperbolic Spiral",
                            polar(10/theta,theta,1,10*%pi) )$

        * `parametric(xfun,yfun,par,parmin,parmax)': monta o gráfico da
          função paramétrica `[xfun,yfun]', com parâmetro `par'
          assumindo valores de `parmin' a `parmax'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type', `key', `point_type',
          `function_style' e `point_type'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw2d(explicit(exp(x),x,-1,3),
                            line_type = 3,
                            key       = "This is the parametric one!!",
                            parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$


     Veja também as seguintes opções gráficas: `xrange', `yrange',
     `logx', `logy', `terminal', `grid', `title', `xlabel', `ylabel',
     `xtics', `ytics', `xy_file', `file_name', `pic_width',
     `pic_height', `user_preamble', `axis_bottom', `axis_left',
     `axis_top', e `axis_right'.


 -- Scene constructor: gr3d (<opção gráfica>, ..., <objeto gráfico>,
          ...)
     A função `gr3d' constrói um objeto descrevendo um fundo gráfico
     tridimensional. Argumentos são opções gráficas e objetos gráficos.
     Esse fundo gráfico é interpretado seqüêncialmente: opções gráficas
     afetam aqueles objetos gráficos colocados imediatamente à sua
     direita.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.

     Essa é a lista dos objetos gráficos disponíveis para fundos
     gráficos tridimensionais:

        * `points([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3],...])' ou
          `points([x1,x2,x3,...], [y1,y2,y3,...], [z1,z2,z3,...])':
          posiciona os pontos `[x1,y1,z1]', `[x2,y2,z2]', `[x2,y2,z3]',
          ... no gráfico.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `point_size', `point_type', `points_joined', `line_width',
          `key' e `line_type'.

          Exemplos:

          Uma amostra tridimensional,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Velocidades diárias de ventos disponíveis",
                            point_size = 2,
                            points(args(submatrix (s2, 4, 5))) )$

          Duas amostras tridimensionais,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Velocidades diárias de ventos disponíveis. Dois conjuntos de dados",
                            point_size = 2,
                            key        = "Amostras das estações 1, 2 e 3",
                            points(args(submatrix (s2, 4, 5))),
                            point_type = 4,
                            key        = "Amostras das estações 1, 4 e 5",
                            points(args(submatrix (s2, 2, 3))) )$

        * `label(rótulo,x,y,z)': escreve `rótulo' no ponto `[x,y,z]'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `label_alignment', `label_orientation' e `label_color'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            label_color = 6,
                            label("UP",-2,0,3),
                            label_color = 3,
                            label("DOWN",2,0,-3) )$

        * `explicit(fcn,var1,minval1,maxval1,var2,minval2,maxval2)':
          monta o gráfico da função explícita `fcn', com a variável
          `var1' assumindo valores de `minval1' a `maxval1' e variável
          `var2' assumindo valores de `minval2' a `maxval2'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `xu_grid', `yv_grid', `line_type' e `key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(key       = "Gauss",
                            line_type = 2,
                            explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                            yv_grid     = 10,
                            line_type = 5,
                            key="Plane",
                            explicit(x+y,x,-5,5,y,-5,5),
                            surface_hide = true)$

        * `parametric(xfun,yfun,zfun,par,parmin,parmax)': monta o
          gráfico da curva paramétrica `[xfun,yfun,zfun]', com
          parâmetro `par' assumindo valores de `parmin' a `parmax'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type' e `key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            line_type  = 3,
                            parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                            line_type  = 6,
                            line_width = 2,
                            parametric(t^2,sin(t),2+t,t,0,2),
                            surface_hide = true,
                            title = "Surface & curves" )$

        *
          `parametric_surface(xfun,yfun,zfun,par1,par1min,par1max,par2,par2min,par2max)':
          monta o gráfico da superfície paramétrica `[xfun,yfun,zfun]',
          com parâmetro `par1' assumindo valores de `par1min' a
          `par1max' e o parâmetro `par2' assumindo valores de `par2min'
          a `par2max'.

          Esse objeto é afetado pelas seguintes opções gráficas:
          `nticks', `line_width', `line_type', e `key'.

          Exemplo:

               (%i1) load(draw)$
               (%i2) draw3d(title          = "Concha do mar",
                            xu_grid        = 100,
                            yv_grid        = 25,
                            rot_vertical   = 100,
                            rot_horizontal = 20,
                            surface_hide   = true,
                            parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                               0.5*u*sin(u)*(cos(v)+1),
                                               u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                               u, 0, 13*%pi, v, -%pi, %pi) )$


     Veja também as seguintes opções gráficas: `xrange', `yrange',
     `zrange', `logx', `logy', `logz', `terminal', `grid', `title',
     `xlabel', `ylabel', `zlabel', `xtics', `ytics', `ztics', `xy_file',
     `user_preamble', `axis_bottom', `axis_left', `axis_top',
     `file_name', `pic_width', `pic_height', `axis_right',
     `rot_vertical', `rot_horizontal', `axis_3d', `xu_grid', `yv_grid',
     `surface_hide', `contour', e `contour_levels'.


 -- Function: draw (<gr2d>, ..., <gr3d>, ..., <opções>, ...)
     Monta o fundo de uma série de gráficos; seus argumentos são
     objetos `gr2d' e `gr3d', juntamente com algumas opções. Por
     padrão, o fundos gráficos são colocados juntos em uma coluna.

     A função `draw' aceita duas opções possíveis: `terminal' e
     `columns'.

     As funções `draw2d' e `draw3d' são atalhos para serem usados
     quando somente um fundo gráfico é requerido, em duas ou três
     dimensões, respectivamente.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.

     Exemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Função: draw2d (<opção>, <objeto gráfico>, ...)
     Essa função é um atalho para `draw2d(gr2d(<opções>, ..., <objeto
     gráfico>, ...))'.

     Pode ser usada para montar gráfico de um único fundo bidimensional.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.


 -- Função: draw3d (<opção>, <graphic object>, ...)
     Essa função é um atalho para `draw3d(gr3d(<opções>, ..., <objeto
     gráfico>, ...))'.

     Pode ser usada para montar o fundo gráfico único tridmensional.

     Para fazer uso dessa função escreva primeiramente `load(draw)'.


 -- Variável: draw_pipes
     Valor padrão: `true'

     Quando `draw_pipes' for `true', Maxima comunica-se com Gnuplot
     diretamente (via pipes). Se `draw_pipes' for `false', Maxima
     comunica-se com Gnuplot via arquivos. Essa opção não está
     disponível para usuários windows.



File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: draw,  Up: Top

48 dynamics
***********

* Menu:

* Introdução a dynamics::
* Definições para dynamics::


File: maxima.info,  Node: Introdução a dynamics,  Next: Definições para dynamics,  Prev: dynamics,  Up: dynamics

48.1 Introdução a dynamics
==========================

O pacote adicional `dynamics' inclui muitas funções para criar várias
representações gráficas de sistemas dinâmicos discretos e fractais, e
uma implementação deo método numérico de Runge-Kutta de quarta ordem
para a resolução de sistemas de equações diferenciais.

   Para usar as funções nesse pacote você deve primeiramente torná-lo
disponível para uso com `load("dynamics")', e as funções que irão criar
gráficos requerem que o Xmaxima esteja instalado.


File: maxima.info,  Node: Definições para dynamics,  Prev: Introdução a dynamics,  Up: dynamics

48.2 Definições para dynamics
=============================

 -- Função: chaosgame (`[['<x1>, <y1>`]'...`['<xm>, <ym>`]]', `['<x0>,
          <y0>`]', <b>, <n>, ...opç ~oes...);
     Implementa o então chamado jogo do caos: o ponto inicial (<x0>,
     <y0>) é colocado no gráfico e então um dos <m> pontos `['<x1>,
     <y1>`]'...`['<xm>, <ym>`]' será selecionado de forma aleatória. O
     próximo ponto colocado no gráfico será sobre o segmento que vai do
     ponto anteriormente colocado no gráfico ao ponto escolhido
     aleatóriamente, à distância do ponto aleatório que será <b> vezes
     o comprimento daquele segmento. o procedimento é repetido <n>
     vezes.


 -- Função: evolution (<F>, <y0>, <n>,...opç ~oes...);
     Desenha <n+1> pontos em gráfico bidimensional, onde as coordenadas
     horizontais dos pontos são os inteiros 0, 1, 2, ..., <n>, e as
     coordenadas verticais são os valores correspondentes <y(n)> da
     seqüência definida pela relação de recorrência
                  y(n+1) = F(y(n))

     com valor inicial <y(0)> igual a <y0>. <F> deve ser uma expressão
     que depende somente da variável <y> (e não da variável <n>), <y0>
     deve ser um número real e <n> deve ser um inteiro positivo.


 -- Função: evolution2d (`['<F>, <G>`]', `['<x0>, <y0>`]', <n>,
          ...opç ~oes...);
     Mostra, em um gráfico bidimensional, os primeiros <n+1> pontos na
     seqüência de pontos definida por meio do sistema dinâmico discreto
     bidimensional com relações de recorrência
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Com valores iniciais <x0> e <y0>. <F> e <G> devem ser duas
     expressões que dependem apenas de <x> e <y>.


 -- Função: ifs (`['<r1>,...,<rm>`]',`['<A1>,...,<Am>`]',
          `[['<x1>,<y1>`]'...`['<xm>, <ym>`]]', `['<x0>,<y0>`]', <n>,
          ...opç ~oes...);
     Implemanta o método de Sistemas de Funções iteradas. Esse método é
     similar ao método descrito na função `chaosgame', mas em lugar de
     encolher o segmento do ponto corrente ao ponto escolhido
     aleatóriamente, as duas componentes daquele segmento irão ser
     multiplicadas pela matrix 2 por 2 <Ai> que corresponde ao ponto
     escolhido aleatóriamente.

     A escolha aleatória de um dos <m> pontos de atração pode ser feita
     com uma distribuição de probabilidade não uniforme definida por
     meio dos pesos <r1>,...,<rm>. Esses pesos são fornecidos de forma
     cumulativa; por exemplo se existem 3 pontos com probabilidades
     0.2, 0.5 e 0.3, os pesos <r1>, <r2> e <r3> podem ser 2, 7 e 10.


 -- Função: julia (<x>, <y>, ...<opções>...)
     Cria um arquívo gráfico com a representação do conjunto de Julia
     para o número complexo (<x> + i <y>). Os parâmetros <x> e <y>
     devem ser reais. o arquivo é criado no diretório corrente ou no
     diretório do do usuário, usando o formato gráfico XPM. O programa
     pode demorar muitos segundos para executar e concluir após isso,
     uma mensagem será mostrada com o nome do arquivo criado.

     Os pontos que não pertencem ao conjunto de Julia recebem diferentes
     cores, conforme o número de iterações a função `julia' toma a
     seqüência iniciando naquele ponto para fora do círculo de
     convergência de raio 2. O número mácimo de iterações é escolhido
     com a opção <levels>; após aquele número de iterações, se a
     seqüência estiver ainda dentro do círculo de convergência, o ponto
     será desenhado com a cor definica pela opção <color>.

     Todas as cores usadas para os pontos que não pertencem ao conjunto
     de Julia irão ter a mesma <saturação> e o mesmo <value>, mas com
     diferentes ângulos de matizes distribuídos uniformemente entre
     <hue> e (<hue> + <huerange>)(1).

     <opções> é uma seqüência facultativa de opções. A lista de
     opções aceitas é fornecida em uma seção adiante.


 -- Função: mandelbrot (<opções>)
     Cria um arquivo gráfico com a representação do conjunto de
     Mandelbrot. O arquivo é criado no diretório atual ou no diretório
     do usuário, usando o formato gráfico XPM. O programa pode demorar
     muitos segundos para executar e concluir após isso, uma mensagem
     será mostrada com o nome do arquivo criado.

     Os pontos que não pertencem ao conjunto de Mandelbrot recebem
     diferentes cores, conforme o número de iterações a função
     `mandelbrot' toma a seqüência iniciando naquele ponto para fora do
     círculo de convergência de raio 2. O número máximo de iterações é
     escolhido com a opção <levels>; após aquele número de iterações,
     se a seqüência estiver ainda dentro do círculo de convergência, o
     ponto será desenhado com a cor definida pela opção <color>.

     Todas as cores usadas para os pontos que não pertencem ao conjunto
     de Julia irão ter a mesma <saturation> e o mesmo <value>, mas com
     diferentes ângulos de matizes distribuídos uniformemente entre
     <hue> e (<hue> + <huerange>).

     <opções> é uma seqüência facultativa de opções. A lista de
     opções aceitas é fornecida em uma seção adiante.


 -- Função: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opç ~oes...);
     Desenha o diagrama de órbitas para uma família de sistemas
     dinâmicos discretos unidimensionais, com um parâmetro <x>; esse
     tipo de diagrama é usado para estudar as bifurcações de um sistema
     discreto unidimensional.

     A função <F(y)> define uma seqüência com um valor inicial de <y0>,
     como no caso da função `evolution', mas nesse caso a função <F(y)>
     irá também depender de um parâmetro <x> que receberá valores no
     intervalo de <x0> a <xf> com incrementos de <xstep>. Cada valor
     usado para o parâmetro <x> é mostrado sobre o eixo horizontal. O
     eixo vertical irá mostrar os valores  de <n2> da seqüência
     <y(n1+1)>,..., <y(n1+n2+1)> obtida após permitir que a seqüência
     produza <n1> iteracões.


 -- Função: rk (EDO, var, inicio, domain)
 -- Função: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm], domain)
     A primeira forma resolve numericamente uma equação diferencial  de
     primeira ordem, e a segunda formaresolve um sistema de m dessas
     equações, usando o método de Runge-Kutta de quarta ordem. `var'
     representa a variável dependente. EDO deve ser uma expressão que
     dependa somente da variável  independente e da variável dependente
     e defina a derivada da variável dependente com relação à variável
     independente.

     A variável independente é especificada com `domain', que deve ser
     uma lista dde quatro elementos como, por exemplo:
          [t, 0, 10, 0.1]
     O primeiro elemento da lista identifica a variável independente, o
     segundo e o terceiro elementos são os valores inicial e final para
     para aquela variável, e o último elemento escolhe o incremento que
     pode ser usado dentro daquele intervalo.

     Se <m> equações estão sendo resolvidas, podem existir <m>
     variáveis dependentes <v1>, <v2>, ..., <vm>. Os valores iniciais
     para aquelas variáveis serão <inic1>, <inic2>, ..., <inicm>.
     Ainda pode ser apenas uma variável independente definida por
     `domain', como no caso anterior. <EDO1>, ..., <EDOm> são as
     expressões que definem as derivadas de cada variável dependente em
     termos da variável independente. As variáveis que podem aparecer
     naquelas expressões são a variável independente e quaisquer outras
     variáveis dependentes. É importante fornecer as derivadas <EDO1>,
     ..., <EDOm> na lista exatamente na mesma ordem usada para variáveis
     dependentes; por exemplo, o terceiro elemento na lista irá ser
     interpretado com a derivada da terceira variável dependente.

     O programa tentará integrar as equações a partir do valor inicial
     da variável independente até seu último valor, usando incrementos
     constantes. Se em algum passo uma das variáveis dependentes recebe
     um valor absoluto muito grande, a integração será interrompida
     naquele ponto. O resultado será uma lista com tamtos elementos
     quantos forem o número de iterações feitas. Cada elemento na lista
     de resultado é em si mesmo outra lista comh <m>+1 elementos: o
     valor da variável independente, seguido pelos valores das
     variáveis dependentes correspondentes àquele ponto.


 -- Função: staircase (<F>, <y0>, <n>, ...opç ~oes...);
     Desenha um diagrama em escada para a seqüência definida pela
     relação de recorrência
                  y(n+1) = F(y(n))

     A interpretação e os valores permitidos dos parâmetros de entrada
     são os mesmos que para a função `evolution'. Um diagrama em escada
     consiste de um gráfico da função <F(y)>, juntamente com a linha
     <G(y)> `=' <y>. Um segmento vertical é desenhado a partir das
     point (<y0>, <y0>) on that line until the point where it
     intersecções com a função <F>. A partir daquele ponto um segmento
     horizontal é desenhado até encontrar o ponto (<y1>, <y1>) sobre a
     linha, e o procedimento é repetido <n> vezes até que o ponto
     (<yn>, <yn>) é encontrado.


   opções

   Cada opção é uma lista de dois ou mais itens. O primeiro item é o
nome da opção, e os restantes compreendem os argumentos para a opção.

   As opções aceitas pela função `evolution', `evolution2d',
`staircase', `orbits', `ifs' e `chaosgame' são:

   * "domain" escolhe os valores de mínimo e de maximo paraa a variável
     independente na coonstrução do gráfico da função <F> mostrada por
     `staircase'.

   * "pointsize" define o raio de cada ponto mostrado, em unidades de
     pontos. O valor padrão é 1.

   * "xaxislabel" é o rótulo a ser colocado no eixo horizontal do
     gráfico.

   * "xcenter" é a coordenada x do ponto que pode aparecer no centro do
     gráfico. Essa opção não é utilizada na função `orbits'.

   * "xradius" é metade do comprimento do intervalo de valores que serão
     mostrados na direção x. Essa opção não é usada pela função
     `orbits'.

   * "yaxislabel" é o rótulo a ser colocado sobre o eixo vertical.

   * "ycenter" é a coordenada  y do ponto que irá aparecer no centro do
     gráfico.

   * "yradius" é a metade do comprimento do intervalo de valores que
     serão mostrados na direção y.


   As seguintes opções são aceitas pelas fuções `julia' e `mandelbrot':

   * "size" recebe um ou dois argumentos. Se somente um argumento é
     fornecido, a largura e a altura do arquivo gráfico criado serão
     iguais a esse valor, em pixels. Se dois argumentos forem
     fornecidos, eles irão definir a largura e a altura. O valor padrão
     é 400 pixels para ambos a largura e altura. Se os dois valores não
     forem iguais, o conjunto aparecerá distorcido.

   * "levels" define o número máximo de iterações, que também igual ao
     número de cores usados para pontos que não pertencem ao conjunto.
     O valor padrão é 12; grandes valoes significam maior quantidade de
     vezes de processamento.

   * "huerange" define o intervalo de ângulos de matiz usados para a
     matiz dos pontos não pertencentes ao conjunto. O valor padrão é
     360, que significa que as cores expandir-se-ão em todo o intervalo
     de matizes. Valores maiores que 360, significarão intervalos
     repetidos de matizes, e valores negativos podem ser usados para
     fazer o ângulo de matiz decrescer como o número de iterações
     também decresce.

   * "hue" conjuntos de matizes, em graus, da primeira cor usada para o
     ponto que não pertence ao conjunto. Seu valor padrão é 300 graus,
     que corresponde ao magenta; os valores para outras cores padrão
     são 0 para vermelho, 45 para laranja, 60 para amarelo, 120 para
     verde, 180 para ciano e 240 para o azul. Veja também a opção
     <huerange>.

   * "saturation" escolhe o valor da saturação usada para pontos não
     pertencentes ao conjunto. A `saturation' deve estar entre 0 e 1. o
     valor padrão é 0.46.

   * "value" escolhe o valor das cores usadas para pontos não
     pertencentes ao conjunto. <value> deve estar entre 0 e 1; Valores
     maiores, acarretam que as cores sejam mais brilhantes. O valor
     padrão é 0.96

   * "color" deve ser seguido por três parâmetros que definem o matiz,
     a saturação e o valor, para a cor usada para representar os pontos
     do conjunto. O valor padrão é 0 para três parâmetos, que
     correspondem ao preto. Para uma explanação do intervalo de valores
     permitidos, veja opções <hue>, <saturation> e <value>.

   * "center" deve ser seguida por dois parâmetros reais, que fornecem
     as coordenadas, sobre o plano complexo, do ponto no centro da
     região mostrada. O valor padrão é 0 para ambas as coordenadas (a
     orígem).

   * "radius" escolhe o raio do maior círculo dentro da região quadrado
     que será mostrado. O valor padrão é 2.

   * "filename" fornece o nome do arquivo onde o gráfico resultante será
     gravado. A extensão .xpm será adicionada à aquele nome. Se o
     arquivo já existir, ele será substituído pelo arquivo gerado pela
     função. Os valores padrão são `julia' para o conjunto de Julia, e
     `mandelbrot' para o conjunto de Mandelbrot.


   Exemplos

   Representação gráfica e diagrama em escada para a seqüência: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

   Se seu sistema for lento, você deverá reduzir o número de
iterações nos seguites exemplos. E o tamanho do ponto, <pointsize>,
que fornece melhores resultados depende do monitor e da resolução que
está sendo usada.Você pode experimentar usando diferentes valores.

   Diagrama de órbitas para o mapa quadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

   Para ampliar a região em torno da bifurcação menor perto de x `='
-1.25 use:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

   Evolução de um sistemma bidimensional que leva a um fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

   E uma ampliação de uma pequena regial naquele fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

   Um gráfico do triângulo de Sierpinsky, obtido com o jogo do caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

   A samambaia de Barnsley, obtida com um Sistema de Funções Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

   Para criar um arquivo chamado _dynamics9.xpm_ com uma
representação gráfica do conjunto de Mandelbrot, com 12 cores, use:

     mandelbrot([filename,"dynamics9"])$

   e o conjunto de Julia para o número (-0.55 + i 0.6) pode ser obtida
com:
     julia(-0.55, 0.6, [levels, 36], [center, 0, 0.6], [radius, 0.3],
           [hue, 240], [huerange, -180], [filename, "dynamics10"])$

   o gráfico será gravado no arquivo _dynamics10.xpm_ e irá mostrar a
região de -0.3 a 0.3 na direção x, e de 0.3 a 0.9 na direção y. 36
cores srão usadas, iniciando com azul e terminando com amarelo.

   Para resolver numericamente a equação diferencial

               dx/dt = t - x^2

   Com valor inicial x(t=0) = 1, no intervalo de `t' de 0 a 8 e com
incrementos de 0.1 para `t', use:

     (%i20) results: rk(t-x^2,x,1,[t,0,8,0.1])$

   os resultados serão salvos na lista de resultados.

   Para resolver numericamente o sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para `t' entre 0 e 4, e com valores de -1.25 e 0.75 para x e y em
t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$

   ---------- Footnotes ----------

   (1) hue - valor de matiz, huerange - valor do intervalo de matiz


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

49 eval_string
**************

* Menu:

* Definições para eval_string::


File: maxima.info,  Node: Definições para eval_string,  Prev: eval_string,  Up: eval_string

49.1 Definições para eval_string
================================

 -- Função: eval_string (<str>)
     Entrega a seqüência de caracteres do Maxima <str> como uma
     expressão do Maxima e a avalia.  <str> é uma seqüência de
     caracteres do Maxima. Essa seqüência pode ou não ter um marcador
     de final (sinal de dólar `$' ou ponto e vírgula `;').  Somente a
     primeira expressão é entregue e avaliada, se ouver mais de uma.

     Reclama se <str> não for uma seqüência de caracteres do Maxima.

     Exemplos:
          (%i1) load("eval_string")$

          (%i2) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o2)                       42
          (%i3) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o3)                   baz + 1764

     Para usar essa função escreva primeiro `load("eval_string")'. Veja
     também `parse_string'.

 -- Função: parse_string (<str>)
     Entrega a seqüência de caracteres do Maxima <str> como uma
     expressão do Maxima (sem fazer nenhuma avaliação dessa expressão).
     <str> é uma seqüência de caracteres do Maxima. Essa seqüência pode
     ou não ter um marcador de final (sinal de dólar `$' ou ponto e
     vírgula `;').  Somente a primeira expressão é entregue e avaliada,
     se ouver mais de uma.

     Reclama se <str> não for uma seqüência de caracteres do Maxima.

     Exemplos:
          (%i1) load("eval_string")$

          (%i2) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o2)                    foo : 42
          (%i3) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o3)          (foo : 42, bar : foo  + baz)

     Para usar essa função escreva primeiro `load("eval_string")'. Veja
     também a função `eval_string'.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

50 f90
******

* Menu:

* Definições para f90::


File: maxima.info,  Node: Definições para f90,  Prev: f90,  Up: f90

50.1 Definições para f90
========================

 -- Função: f90 (<expr>)
     O comando f90 é uma atualização para o comando `fortran' original
     do maxima. A diferença primária é o caminho através do qual linhas
     longas são quebradas.

     No exemplo seguinte, observe como o comando `fortran' para linhas
     dentro de símbolos. O comando `f90' jamais para linha dentro de um
     símbolo.

          (%i1) load("f90")$

          (%i2) expr:expand((xxx+yyy+7)^4);
                   4            3         3        2    2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                       2          2        3             2
           + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                         4         3          2
           + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
           + 1372 xxx + 2401
          (%i3) fortran(expr);
                yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
               1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
               2   xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                       done
          (%i4) f90(expr);
          yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
               yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
               4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                       done

     A implementação `f90' termina como um rápido reparo em `fortran'.
     Não é necessáriamente um bom exemplo sobre o qual se deva basear
     outros tradutores do Maxima para outras linguagens de
     programação.

     Para usar essa função escreva primeiro `load("f90")'.


File: maxima.info,  Node: ggf,  Next: impdiff,  Prev: f90,  Up: Top

51 ggf
******

* Menu:

* Definições para ggf::


File: maxima.info,  Node: Definições para ggf,  Prev: ggf,  Up: ggf

51.1 Definições para ggf
========================

 -- Variável de Opção: GGFINFINITY
     Valor padrão: 3

     Essa é uma variável de opção para a função `ggf'.

     Quando calculando a fração contínua da função geradora, um
     quociente parcial tendo um grau (estritamente) maior que
     <GGFINFINITY> será descartado e o convergente atual será
     considerado como o valor exato da função geradora; na grande
     mioria dos casos o grau de todos os quocientes parciais será ou 0
     ou 1; se você usar um valor muito grande, então você poderá
     fornecer termos suficientes com o objetivo de fazer o cálculo
     preciso o bastante.

     Veja também `ggf'.

 -- Variável de opção: GGFCFMAX
     Valor padrão: 3

     Essa é uma variável de opção para a função `ggf'.

     Quando calculando a fração contínua da função geradora, se nenhum
     bom resultado for encontrado (veja o sinalizador <GGFINFINITY>)
     após se ter calculado uma quantidade de <GGFCFMAX> quocientes
     parciais, a função geradora será considerada como não sendo uma
     fração de dois polinômios e a função irá terminar. Coloque
     livemente um valor muito grande para funções geradoras mais
     complicadas.

     Veja também `ggf'.

 -- Função: ggf (<l>)
     Calcula a função geradora (se for uma fração de dois polinômios)
     de uma seqüência, sendo dados seus primeiros termos. <l> é uma
     lista de números.

     A solução é retornada como uma fração de dois polinômios.  Se
     nenhuma solução tiver sido encontrada, é retornado `done'.

     Essa função é controlada attravés das variáveis globais
     <GGFINFINITY> e <GGFCFMAX>. Veja também <GGFINFINITY> e <GGFCFMAX>.

     Para usar essa função primeiro escreva `load("ggf")'.


File: maxima.info,  Node: impdiff,  Next: implicit_plot,  Prev: ggf,  Up: Top

52 impdiff
**********

* Menu:

* Definições para impdiff::


File: maxima.info,  Node: Definições para impdiff,  Prev: impdiff,  Up: impdiff

52.1 Definições para impdiff
============================

 -- Função: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Essa subrotina calcula derivadas implícitas de funções de várias
     variáveis.  <f> é uma função do tipo array, os índices são o grau
     da derivada na ordem <indvarlist>; <indvarlist> é a lista de
     variáveis independentes; <orderlist> é a ordem desejada; e
     <depvar> é a variável dependente.

     Para usar essa função escreva primeiro `load("impdiff")'.


File: maxima.info,  Node: implicit_plot,  Next: interpol,  Prev: impdiff,  Up: Top

53 implicit_plot
****************

* Menu:

* Definições para implicit_plot::


File: maxima.info,  Node: Definições para implicit_plot,  Prev: implicit_plot,  Up: implicit_plot

53.1 Definições para implicit_plot
==================================

 -- Função: implicit_plot (<expr>, <x_range>, <y_range>)
 -- Função: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)
     Mostra na tela um gráfico de uma ou mais expressões na forma
     implícita. <expr> é a expressão a ser montado o gráfico, <x_range>
     o intervalo do eixo do eixo horizontal e <y_range> o intervalo do
     eixo vertical. <implicit_plot> somente trabalha com o driver do
     gnuplot. <implicit_plot> respeita as escolhas globais para o
     driver do gnuplot escolhidas por meio da função <set_plot_option>.
     Opções podem tamb;em serem passadas para a função <implicit_plot>
     como argumentos opcionais.

     <implicit_plot> trabalha por meio de mudanças de sinal de trilha
     sobre a área fornecida através de <x_range> e <y_range> e pode
     falhar em expressões complicadas.

     Exemplo:
          (%i1) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4],
           [gnuplot_preamble, "set zeroaxis"]);



File: maxima.info,  Node: interpol,  Next: lbfgs,  Prev: implicit_plot,  Up: Top

54 interpol
***********

* Menu:

* Introdução a interpol::
* Definições para interpol::


File: maxima.info,  Node: Introdução a interpol,  Next: Definições para interpol,  Prev: interpol,  Up: interpol

54.1 Introdução a interpol
==========================

Pacote `interpol' define os métodos Lagrangiano, linear e o de splines
cúbicos para interpolação polinomial.

   Comentários, correções e sugestões, por favor contacte-me em <'mario
AT edu DOT xunta DOT es'>.


File: maxima.info,  Node: Definições para interpol,  Prev: Introdução a interpol,  Up: interpol

54.2 Definições para interpol
=============================

 -- Função: lagrange (<pontos>)
 -- Função: lagrange (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método Lagrangiano. O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, `p:matrix([2,4],[5,6],[9,3])',

        * uma lista de pares, `p: [[2,4],[5,6],[9,3]]',

        * uma lista de números, `p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é `'x' por padrão; para definir qualquer
     outra, z por exemplo, escreva `varname='z'.

     Exemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) /* Plot the polynomial together with points */
                plot2d([f(x),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o8)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5


 -- Função: charfun2 (<x>, <a>, <b>)
     Retorna `true', i. e., verdadeiro se o número <x> pertence ao
     intervalo [a, b), e `false', i. e., falsono caso contrário.

 -- Função: linearinterpol (<pontos>)
 -- Função: linearinterpol (<pontos>, <opção>)
     Calcula a interpolação polinomial através do método linear. O
     argumento <pontos> deve ser um dos seguintes:

        * uma matriz de duas colunas, `p:matrix([2,4],[5,6],[9,3])',

        * uma lista de pares, `p: [[2,4],[5,6],[9,3]]',

        * uma lista de números, `p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Com o argumento <opção> é possível escolher o nome da variável
     independente, o qual é `'x' por padrão; para definir qualquer
     outra, z por exemplo, escreva `varname='z'.

     Examples:
          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7)  /* Plot the polynomial together with points */
                 plot2d(['(f(x)),[discrete,args(p)]],[x,-5,20],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o8) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3


 -- Função: cspline (<pontos>)
 -- Função: cspline (<pontos>, <opção1>, <opção2>, ...)
     Calcula a interpolação polnomial pelo método de splines (
     polinômios de ordem k que interpolam os dados e têm k-1 derivadas
     contínuas em todo o intervalo ) cúbicos. O argumento <pontos> deve
     ser um dos seguintes:

        * uma matriz de duas colunas, `p:matrix([2,4],[5,6],[9,3])',

        * uma lista de pares, `p: [[2,4],[5,6],[9,3]]',

        * uma lista de números, `p: [4,6,3]', e nesse caso as abcissas
          irão ser atribuídas automaticamente aos valores 1, 2, 3, etc.

     Nos dois primeiros casos os pares são ordenados em relação à
     primeira coordenada antes de fazer os cálculos.

     Existem três opções para ajustar necessidades específicas:
        * `'d1', o padrão é `'unknown', é a primeira derivada em x_1;
          se essa primeira derivada for desconhecida, `'unknown', a
          segunda derivada em x_1 é igualada a 0 (o spline cúbico
          natural); se essa primeira derivada for igual a um número, a
          segunda derivada é calculada baseando-se nesse número.

        * `'dn', o padrão é `'unknown', é a primeira derivada em x_n;
          se essa primeira derivada for desconhecida, `'unknown', a
          segunda derivada em x_n é igualada a 0 (o spline cúbico
          natural); se essa primeira derivada for igual a um número, a
          segunda derivada é calculada baseando-se nesse número.

        * `'nome_var', o padrão é `'x', é o nome da variável
          independente.

     Exemplos:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) /* Plotting interpolating function */
                plot2d(['(f(x)),[discrete,p]],[x,0,10],
                    [gnuplot_curve_styles,
                         ["with lines","with points pointsize 3"]])$
          (%i7) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o7)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                        ["with lines","with lines","with points pointsize 3"]])$



File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: interpol,  Up: Top

55 lbfgs
********

* Menu:

* Introdução a lbfgs::
* Definições para lbfgs::


File: maxima.info,  Node: Introdução a lbfgs,  Next: Definições para lbfgs,  Prev: Top,  Up: Top

55.1 Introdução a lbfgs
=======================

`lbfgs' é uma implementação do algorítmo[1] L-BFGS
(Broyden-Fletcher-Goldfarb-Shanno) para resolver problemas de
minimização não limitada através de um algorítmo de memória limitada
quasi-Newton (BFGS).  Esse algorítmo é chamado de método de memória
limitada porque uma aproximação de baixo ranque da inverso da matriz
Hessiana é armazenado em lugar da inversa da matriz Hessiana completa.
O programa foi escrito origináriamente em Fortran [2] por Jorge Nocedal,
incorporando algumas funções originalmente escritas por Jorge J. Moré e
David J. Thuente, e traduzidas para Lisp automaticamente através do
programa `f2cl'.  O pacote do Maxima `lbfgs' compreende o código
traduzido e adicionalmente uma interface de função que gerencia alguns
detallhes.

   Referências:

   [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
large scale optimization". Mathematical Programming B 45:503-528 (1989)

   [2] http://netlib.org/opt/lbfgs_um.shar


File: maxima.info,  Node: Definições para lbfgs,  Prev: Introdução a lbfgs,  Up: Top

55.2 Definições para lbfgs
==========================

 -- Função: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
     Encontra uma solução aproximada da minimização não limitada de
     número de mérito <FOM> sobre a lista de variáveis <X>, começando a
     partir da estimativa inicial <X0>, tal que norm grad FOM < epsilon
     max(1, norm X).

     O algorítmo aplicado é um algorítmo de memória limitada[1]
     quasi-Newton (BFGS).  Esse algorítmo é chamado de método de
     memória limitada porque uma aproximação de baixo ranque da inverso
     da matriz Hessiana é armazenado em lugar da inversa da matriz
     Hessiana completa.

     <iprint> controla as messaens de progresso mostradas através de
     `lbfgs'.

    `iprint[1]'
          `<iprint>[1]' controla a freqüência das mensagens de
          progresso.
         `iprint[1] < 0'
               Nenhuma mensagem de progresso.

         `iprint[1] = 0'
               Messagens na primeira iteração e na última iteração.

         `iprint[1] > 0'
               Mostra uma mensagem a cada `<iprint>[1]' iterações.

    `iprint[2]'
          `<iprint>[2]' controla a quantidade de informações fornecidas
          pelas mensagens de progresso (verbosidade).
         `iprint[2] = 0'
               Mostra na tela o contador de iterações, o número de
               avaliações de <FOM>, o valor de <FOM>, a norma do
               gradiente de <FOM>, e o comprimento do salto.

         `iprint[2] = 1'
               O mesmo que `<iprint>[2] = 0', adicionando <X0> e o
               gradiente de <FOM> avaliado em <X0>.

         `iprint[2] = 2'
               O mesmo que `<iprint>[2] = 1', adicionando valores de
               <X> a cada iteração.

         `iprint[2] = 3'
               O mesmo que `<iprint>[2] = 2', adicionando o gradiente
               de <FOM> a cada iteração.

     Veja também `lbfgs_nfeval_max' e `lbfgs_ncorrections'.

     Referências:

     [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
     large scale optimization". Mathematical Programming B 45:503-528
     (1989)

     Exemplo:

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1, length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
             2    6     2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
             3    8     1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
             4    9     7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
             5   10     7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
             6   11     6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
             7   12     5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
             8   13     5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
             9   14     5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)


 -- Variãvel: lbfgs_nfeval_max
     Valor padrão: 100


 -- Variãvel: lbfgs_ncorrections
     Valor padrão: 25



File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

56 lindstedt
************

* Menu:

* Definições para lindstedt::


File: maxima.info,  Node: Definições para lindstedt,  Prev: lindstedt,  Up: lindstedt

56.1 Definições para lindstedt
==============================

 -- Função: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Esse é um primeiro passo para um código de Lindstedt.  Esse código
     pode resolver problemas com condições iniciais fornecidas, às
     quais podem ser constantes arbitrárias, (não apenas <%k1> e <%k2>)
     onde as condições iniciais sobre as equações de perturbação são
     z[i]=0, z'[i]=0 para i>0. <ic> é a lista de condições iniciais.

     Problemas ocorrem quando condições iniciais não forem dadas, como
     as constantes nas equações de perturbação são as mesmas que a
     solução da equação de ordem zero.  Também, problemas ocorrem
     quando as condições iniciais para as equações de perturbação não
     são z[i]=0, z'[i]=0 para i>0, tais como a equação de Van der Pol.

     Exemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Para usar essa função escreva primeiro `load("makeOrders")' e
     `load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

57 linearalgebra
****************

* Menu:

* Introdução a linearalgebra::
* Definições para linearalgebra::


File: maxima.info,  Node: Introdução a linearalgebra,  Next: Definições para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

57.1 Introdução a linearalgebra
===============================

`linearalgebra' é uma coleção de funções para álgebra linear.

   Exemplo:

     (%i1) load (linearalgebra);
     Warning - you are redefining the Maxima function require_list
     Warning - you are redefining the Maxima function matrix_size
     Warning - you are redefining the Maxima function rank
     (%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
     (%i2) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o2)                       [      ]
                                 [ 1  2 ]
     (%i3) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o3)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i4) columnspace (M);
                                     [ 1 ]
     (%o4)                      span([   ])
                                     [ 1 ]
     (%i5) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o5)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i6) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o6)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i7) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o7)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i8) algebraic : true;
     (%o8)                         true
     (%i9) tellrat (MM [3, 3]);
                              3       2
     (%o9)                  [z  - 15 z  - 18 z]
     (%i10) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o10)         [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i11) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o11)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i12) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o12)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i13) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o13)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i14) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o14)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]



Local Variables:
coding: iso-8859-1
End:
