<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Maxima Manual: Функции и переменные для правил преобразования и шаблонов</title>

<meta name="description" content="Maxima Manual: Функции и переменные для правил преобразования и шаблонов">
<meta name="keywords" content="Maxima Manual: Функции и переменные для правил преобразования и шаблонов">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" rel="index" title="Указатель функций и переменных">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_131.html#g_t_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b" rel="up" title="Правила преобразования и шаблоны">
<link href="maxima_134.html#g_t_0421_043f_0438_0441_043a_0438" rel="next" title="Списки">
<link href="maxima_132.html#g_t_0412_0432_0435_0434_0435_043d_0438_0435-_0432-_043f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_0439-_0438-_0448_0430_0431_043b_043e_043d_044b" rel="previous" title="Введение в правила преобразований и шаблоны">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="ru" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="g_t_0424_0443_043d_043a_0446_0438_0438-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0434_043b_044f-_043f_0440_0430_0432_0438_043b-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_043e_0432"></a>
<div class="header">
<p>
Previous: <a href="maxima_132.html#g_t_0412_0432_0435_0434_0435_043d_0438_0435-_0432-_043f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_0439-_0438-_0448_0430_0431_043b_043e_043d_044b" accesskey="p" rel="previous">Введение в правила преобразований и шаблоны</a>, Up: <a href="maxima_131.html#g_t_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b" accesskey="u" rel="up">Правила преобразования и шаблоны</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Funkcii-i-peremennye-dlya-pravil-preobrazovaniya-i-shablonov"></a>
<h3 class="section">34.2 Функции и переменные для правил преобразования и шаблонов</h3>

<a name="Item_003a-Rules_002fdeffn_002fapply1"></a><dl>
<dt><a name="index-apply1"></a>Функция: <strong>apply1</strong> <em>(<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</em></dt>
<dd><p>Осуществляет повторное применение правила преобразования <var>rule_1</var> к
<var>expr</var> до тех пор пока выражение отвечает шаблону преобразования,
затем, таким же образом осуществляется повторное применение этого правила ко всем
подвыражениям <var>expr</var>, слева направо. 
Далее, к полученному
результату тем же способом применяется правило <var>rule_2</var> и так далее 
все последующие правила вплоть до <var>rule_n</var>. Конечный результат возвращается.
</p>
<p>Переменная <code>maxapplydepth</code> контролирует нижнюю глубину уровня подвыражения до
которого применяются правила преобразований в функциях <code>apply1</code> и <code>apply2</code>.
</p>
<p>См. также <var>applyb1</var>, <code>apply2</code> и <code>let</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fapply2"></a><dl>
<dt><a name="index-apply2"></a>Функция: <strong>apply2</strong> <em>(<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</em></dt>
<dd><p>Если правило <var>rule_1</var> неприменимо на подвыражении  <var>expr</var>,
тогда применяется правило <var>rule_2</var> и далее по той же схеме остальные
правила. Только если каждое из правил является неприменимым на данном подвыражении <var>expr</var>, 
программа переходит на следующий уровень подвыражнния <var>expr</var>, 
и по той же схеме последовательно применяет весь набор правил, 
начиная с первого. Если применение одного из правил оказывается
успешным, тогда весь набор правил заново применяется к
этому подвыражению.
</p>
<p>Переменная <code>maxapplydepth</code> контролирует нижнюю глубину уровня подвыражения до
которого применяются правила преобразований в функциях <code>apply1</code> и <code>apply2</code>.
</p>
<p>См. также <code>apply1</code> и <code>let</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fapplyb1"></a><dl>
<dt><a name="index-applyb1"></a>Функция: <strong>applyb1</strong> <em>(<var>expr</var>, <var>rule_1</var>, ..., <var>rule_n</var>)</em></dt>
<dd><p>В отличие от <code>apply1</code> применяется по восходящей, т.е., сначала на
самом глубоком уровне <var>expr</var> повторяется применение правила
<var>rule_1</var>. Затем программа переходит на более высокие уровни
<var>expr</var> и применяет данное правило по той же схеме.  После того как
применение правила <var>rule_1</var> терпит неудачу на самом вернем уровне
<var>expr</var> программа переходит к применению правила  <var>rule_2</var> по
той же схеме (по восходящей) и так далее, заканчивая применением
правила  <var>rule_n</var>. После этого возвращается результат.
</p>
<p>Функция <code>applyb1</code> аналогична <code>apply1</code>, но работает по восходящей.
</p>
<p>Переменная <code>maxapplyheight</code> контролирует высоту уровня подвыражения до
которого применяются правила преобразований в функции <code>applyb1</code>.
</p>
<p>См. также <code>apply1</code>, <code>apply2</code> и <code>let</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdefvr_002fcurrent_005flet_005frule_005fpackage"></a><dl>
<dt><a name="index-current_005flet_005frule_005fpackage"></a>Управляющая переменная: <strong>current_let_rule_package</strong></dt>
<dd><p>Значение по умолчанию: <code>default_let_rule_package</code>
</p>
<p><code>current_let_rule_package</code> - имя пакета правил, которые, если не
определен другой пакет правил, используются функциями из программы  <code>let</code> (такими как,
<code>letsimp</code>, и т.д.) Эта переменной может быть присвоено имя любого пакета правил 
преобразований, определенного при помощи функции <code>let</code>.
</p>
<p>При вызове <code>letsimp (expr, rule_pkg_name)</code>,
пакет правил <code>rule_pkg_name</code> используется только во время данного
действия, при этом  значение переменной <code>current_let_rule_package</code>
остается неизменным.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdefvr_002fdefault_005flet_005frule_005fpackage"></a><dl>
<dt><a name="index-default_005flet_005frule_005fpackage"></a>Управляющая переменная: <strong>default_let_rule_package</strong></dt>
<dd><p>Значение по умолчанию: <code>default_let_rule_package</code>
</p>
<p><code>default_let_rule_package</code> - имя пакета правил, используемого по умолчанию, если
пакет правил не был задан в явном виде при вызове <code>let</code> или через
изменение значения переменной <code>current_let_rule_package</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fdefmatch"></a><dl>
<dt><a name="index-defmatch"></a>Функция: <strong>defmatch</strong> <em>(<var>progname</var>, <var>pattern</var>, <var>x_1</var>, ..., <var>x_n</var>)</em></dt>
<dt><a name="index-defmatch-1"></a>Функция: <strong>defmatch</strong> <em>(<var>progname</var>, <var>pattern</var>)</em></dt>
<dd><p>Определяет функцию <code><var>progname</var> (<var>expr</var>, <var>x_1</var>, ..., <var>x_n</var>)</code>, 
которая проверяет выражение <var>expr</var> на соответствие шаблону <var>pattern</var>.
</p>
<p>Шаблон <var>pattern</var> - выражение, содержащее аргументы шаблона <var>x_1</var>, ..., <var>x_n</var> (если есть)
и переменные шаблона (если есть).
Аргументы шаблона задаются в явном виде, как аргументы функции
<code>defmatch</code>, а переменные шаблона декларируются функцией <code>matchdeclare</code>.
Всякая переменная, не декларированная как переменная шаблона при помощи <code>mathdeclare</code>
или как аргумент шаблона при помощи <code>defmatch</code> соответствует только сама себе.
</p>
<p>Первым аргументом создаваемой функции <var>progname</var> является выражение,
проверяемое на соответствие шаблону, а другие аргументы это
актуальные параметры, соответствующие аргументам шаблона  <var>x_1</var>, ..., <var>x_n</var>.
</p>
<p>Если проверка на соответствие шаблону оказывается успешной, то
<var>progname</var> возвращает список уравнений, в которых левые части
являются аргументами и переменными шаблона, а правые части - подвыражения <var>expr</var>,
сопоставленные данным аргументам и переменным. 
Переменным шаблона, но не аргументам шаблона, присваиваются соответствующие значения.
В случае неудачи сопоставления <var>progname</var> возвращает <code>false</code>.  
</p>
<p>Любая переменная, не объявленная в параметрах шаблона в
<code>matchdeclare</code> или в переменных шаблона в <code>defmatch</code>,
сопоставляется только самой себе.
</p>
<p>Программа для буквального шаблона, т.е. шаблона не содержащего ни аргументов ни переменных, 
в случае удачи сопоставления возвращает <code>true</code>.
</p>
<p>См. также <code>matchdeclare</code>, <code>defrule</code>, <code>tellsimp</code> и <code>tellsimpafter</code>.
</p>
<p>Примеры:
</p>
<p>Определим функцию <code>linearp (expr, x)</code>, которая проверяет может ли <code>expr</code>  быть представлено
ввиде <code>a*x + b</code>, где <code>a</code> и <code>b</code> не содержат <code>x</code> и <code>a</code> отлично от нуля.
Эта функция сопоставима с выражениями линейными по любой переменной,
поскольку аргумент шаблона <code>x</code> определен в <code>defmatch</code>.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b, x);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2, z);
                         2
(%o3)              [b = y , a = y + 4, x = z]
(%i4) a;
(%o4)                         y + 4
(%i5) b;
                                2
(%o5)                          y
(%i6) x;
(%o6)                           x
</pre></div>

<p>Определим функцию <code>linearp(expr)</code>, которая проверяет может ли <code>expr</code> быть представлено
ввиде <code>a*x + b</code>, где <code>a</code> и <code>b</code> не содержат <code>x</code> и <code>a</code> отлично от нуля.
Эта функция сопоставима с выражениями линейными только по <code>x</code>,
поскольку в <code>defmatch</code> не заданы никакие аргументы шаблона.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                    freeof(x));
(%o1)                         done
(%i2) defmatch (linearp, a*x + b);
(%o2)                        linearp
(%i3) linearp (3*z + (y + 1)*z + y^2);
(%o3)                         false
(%i4) linearp (3*x + (y + 1)*x + y^2);
                             2
(%o4)                  [b = y , a = y + 4]
</pre></div>

<p>Определим функцию <code>checklimits(expr)</code>, которая проверяет,
определяет ли <code>expr</code> интеграл.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare ([a, f], true);
(%o1)                         done
(%i2) constinterval (l, h) := constantp (h - l);
(%o2)        constinterval(l, h) := constantp(h - l)
(%i3) matchdeclare (b, constinterval (a));
(%o3)                         done
(%i4) matchdeclare (x, atom);
(%o4)                         done
(%i5) simp : false;
(%o5)                         false
(%i6) defmatch (checklimits, 'integrate (f, x, a, b));
(%o6)                      checklimits
(%i7) simp : true;
(%o7)                         true
(%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                       x + 2 %pi
                      /
                      [
(%o8)                 I          sin(t) dt
                      ]
                      /
                       x + %pi
(%i9) checklimits (%);
(%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fdefrule"></a><dl>
<dt><a name="index-defrule"></a>Функция: <strong>defrule</strong> <em>(<var>rulename</var>, <var>pattern</var>, <var>replacement</var>)</em></dt>
<dd><p>Определяет и именует правило преобразования для данного шаблона.
Если правило c именем <var>rulename</var> применяется к выражению
(путем <code>apply1</code>, <code>applyb1</code> или <code>apply2</code>), то каждое
подвыражение, удовлетворяющее шаблону, заменяется соответствующей подстановкой. 
После этого выражение упрощается.
</p>
<p>Правила могут рассматриваться как функции, преобразующие выражение путем
одной операции сопоставления с шаблоном и подстановки. 
При неудаче сопоставления, функция правила преобразования возвращает <code>false</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fdisprule"></a><dl>
<dt><a name="index-disprule"></a>Функция: <strong>disprule</strong> <em>(<var>rulename_1</var>, ..., <var>rulename_2</var>)</em></dt>
<dt><a name="index-disprule-1"></a>Функция: <strong>disprule</strong> <em>(all)</em></dt>
<dd><p>Выводит правила преобразований и их имена <var>rulename_1</var>, ..., <var>rulename_n</var>,
определенные в  <code>defrule</code>, <code>tellsimp</code> или <code>tellsimpafter</code>, или
шаблоны, определенные <code>defmatch</code>.
Каждое правило выводится в форме промежуточного выражения, маркированного символом (<code>%t</code>).
</p>
<p>Вызов <code>disprule (all)</code> выводит все определенные правила.
</p>
<p>Функция <code>disprule</code> не вычисляет свои аргументы.
Функция <code>disprule</code> возвращает список меток промежуточных выражений, соответствующих выведенным правилам.
</p>
<p>См. также функцию <code>letrules</code>, которая выводит правила определенные <code>let</code>.
</p>
<p>Примеры:
</p>
<div class="example">
<pre class="example">(%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (x + y, special_add (x, y));
(%o2)                   [+rule1, simplus]
(%i3) defmatch (quux, mumble (x));
(%o3)                         quux
(%i4) disprule (foorule1, &quot;+rule1&quot;, quux);
(%t4)        foorule1 : foo(x, y) -&gt; baz(y) + bar(x)

(%t5)          +rule1 : y + x -&gt; special_add(x, y)

(%t6)                quux : mumble(x) -&gt; []

(%o6)                    [%t4, %t5, %t6]
(%i6) ''%;
(%o6) [foorule1 : foo(x, y) -&gt; baz(y) + bar(x), 
     +rule1 : y + x -&gt; special_add(x, y), quux : mumble(x) -&gt; []]
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;<a href="maxima_263.html#Category_003a-_0424_0443_043d_043a_0446_0438_0438-_0432_044b_0432_043e_0434_0430">Функции вывода</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002flet"></a><dl>
<dt><a name="index-let"></a>Функция: <strong>let</strong> <em>(<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, ..., <var>arg_n</var>)</em></dt>
<dt><a name="index-let-1"></a>Функция: <strong>let</strong> <em>([<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, ..., <var>arg_n</var>],  <var>package_name</var>)</em></dt>
<dd><p>Определяет правила подстановки для функции <code>letsimp</code> такие, что <var>prod</var> заменяется на <var>repl</var>.
<var>prod</var> является произведением подвыражений положительной или  отрицательной степени. 
Подвыражения могут быть следующего типа:
</p>
<ul>
<li> Атомы, поиск которых <code>letsimp</code> ведет только по имени, если перед
вызовом  <code>letsimp</code> в функции <code>matchdeclare</code> не был определен
предикат, связанный с этим атомом.  В последнем случае <code>letsimp</code>
будет сопоставлять атом с любым членом произведения удовлетворяющим предикату.
</li><li> Ядра типа <code>sin(x)</code>, <code>n!</code>, <code>f(x,y)</code> и т.п.  Как и в
предыдущем случае <code>letsimp</code> ищет буквальное соответствие, если
в <code>matchdeclare</code> не был определен предикат.
</li></ul>

<p>Члены положительной степени будут сопоставляться только членам, имеющим положительную
степень. Члены отрицательной степени будут сопоставляться только членам, имеющим отрицательную
степень. 
Для  того чтобы <code>letsimp</code> работал с отрицательными степенями в <var>prod</var> 
переменная  <code>letrat</code> должна быть установлена равной <code>true</code>.
См. также <code>letrat</code>.
</p>
<p>Если в функцию <code>let</code> включен предикат, с последующим списком аргументов,
то подстановки осуществляются только если  <code>predname (arg_1', ...,
arg_n')</code> дает <code>true</code>, где <var>arg_i&rsquo;</var> есть значение, сопоставленное  <var>arg_i</var>. 
Переменная <var>arg_i</var> может быть именем атома или аргументом любого ядра, присутствующего в <var>prod</var>.
<var>repl</var> может быть любым  рациональным выражением. Если любой атом или аргумент из <var>prod</var> присутствует в
<var>repl</var>, то выполняются соответствующие подстановки. </p>
<p>Глобальная переменная <code>letrat</code> управляет упрощением дробных
выражений в <code>letsimp</code>.
Если <code>letrat</code> равена <code>false</code>, то
<code>letsimp</code> упрощает отдельно числитель и знаменатель выражения
<var>expr</var>, но не упрощает их частное.
В этом случае подстановки типа <code>n!/n</code> на <code>(n-1)!</code> не будут работать.
Если <code>letrat</code> равена <code>true</code>, тогда числитель, знаменатель и
их частное упрощаются в данном порядке.
</p>
<p>Данные функции подстановок позволяют работать с несколькими пакетами
правил одновременно. Каждый пакет правил может содержать любое
количество правил преобразований <code>let</code> и обозначается некоторым
заданным пользователем именем.
Вызов <code>let ([<var>prod</var>, <var>repl</var>, <var>predname</var>, <var>arg_1</var>, ..., <var>arg_n</var>], <var>package_name</var>)</code>
добавляет правило <var>predname</var> к пакету правил <var>package_name</var>.
Вызов <code>letsimp (<var>expr</var>, <var>package_name</var>)</code>
применяет правила преобразований из пакета <var>package_name</var>.
Процедура <code>letsimp (<var>expr</var>, <var>package_name1</var>, <var>package_name2</var>, ...)</code>
эквивалентна применению функций <code>letsimp (<var>expr</var>, <var>package_name1</var>)</code>
и затем функции <code>letsimp (%, <var>package_name2</var>)</code>, ....
</p>
<p>Переменная <code>current_let_rule_package</code> содержит имя текущего пакета правил.
Данной переменной может быть присвоено имя любого пакета правил,
определенного при помощи <code>let</code>.
Вызов команды <code>let</code> без упоминания имени пакета приводит к
применению пакета, определенного <code>current_let_rule_package</code>.
При вызове типа <code>letsimp (<var>expr</var>, <var>rule_pkg_name</var>)</code>,
используются правила пакета <var>rule_pkg_name</var>, только для данного вызова <code>lrtsimp</code> а 
значение переменной  <code>current_let_rule_package</code>
не меняется. По умолчанию <code>current_let_rule_package</code> равно <code>default_let_rule_package</code>.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare ([a, a1, a2], true)$
(%i2) oneless (x, y) := is (x = y-1)$
(%i3) let (a1*a2!, a1!, oneless, a2, a1);
(%o3)         a1 a2! --&gt; a1! where oneless(a2, a1)
(%i4) letrat: true$
(%i5) let (a1!/a1, (a1-1)!);
                        a1!
(%o5)                   --- --&gt; (a1 - 1)!
                        a1
(%i6) letsimp (n*m!*(n-1)!/m);
(%o6)                      (m - 1)! n!
(%i7) let (sin(a)^2, 1 - cos(a)^2);
                        2               2
(%o7)                sin (a) --&gt; 1 - cos (a)
(%i8) letsimp (sin(x)^4);
                        4           2
(%o8)                cos (x) - 2 cos (x) + 1
</pre></div>


<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdefvr_002fletrat"></a><dl>
<dt><a name="index-letrat"></a>Управляющая переменная: <strong>letrat</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если <code>letrat</code> равна <code>false</code>, то <code>letsimp</code> упрощает отдельно числитель и знаменатель выражения
<var>expr</var>, и не упрощает их частное.
</p>
<p>Если <code>letrat</code> равна <code>true</code>, то числитель, знаменатель и их частное упрощаются в данном порядке.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (n, true)$
(%i2) let (n!/n, (n-1)!);
                         n!
(%o2)                    -- --&gt; (n - 1)!
                         n
(%i3) letrat: false$
(%i4) letsimp (a!/a);
                               a!
(%o4)                          --
                               a
(%i5) letrat: true$
(%i6) letsimp (a!/a);
(%o6)                       (a - 1)!
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fletrules"></a><dl>
<dt><a name="index-letrules"></a>Функция: <strong>letrules</strong> <em>()</em></dt>
<dt><a name="index-letrules-1"></a>Функция: <strong>letrules</strong> <em>(<var>package_name</var>)</em></dt>
<dd><p>Выводит правила, содержащиеся в пакете правил преобразований.
<code>letrules ()</code> выводит правила текущего пакета правил
преобразований.
<code>letrules (<var>package_name</var>)</code> выводит правила преобразований в
пакете <var>package_name</var>.
</p>
<p>Текущий пакет правил определяется значением <code>current_let_rule_package</code>.
Если не определено иначе, то <code>current_let_rule_package</code>
по умолчанию равен <code>default_let_rule_package</code>.
</p>
<p>См. также функцию <code>disprule</code>, отображающую правила, определенные
путем <code>tellsimp</code> и <code>tellsimpafter</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fletsimp"></a><dl>
<dt><a name="index-letsimp"></a>Функция: <strong>letsimp</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-letsimp-1"></a>Функция: <strong>letsimp</strong> <em>(<var>expr</var>, <var>package_name</var>)</em></dt>
<dt><a name="index-letsimp-2"></a>Функция: <strong>letsimp</strong> <em>(<var>expr</var>, <var>package_name_1</var>, ..., <var>package_name_n</var>)</em></dt>
<dd><p>Данная функция осуществляет повторное применение правил подстановки,
определенных в <code>let</code>, до тех пор пока выражение <var>expr</var> не
перестанет изменяться.
</p>
<p><code>letsimp (<var>expr</var>)</code> использует правила из пакета <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>package_name</var>)</code> использует правила из пакета <var>package_name</var>
без изменения значения переменной <code>current_let_rule_package</code>.
</p>
<p><code>letsimp (<var>expr</var>, <var>package_name_1</var>, ..., <var>package_name_n</var>)</code>
эквивалентно применению  <code>letsimp (<var>expr</var>, <var>package_name_1</var></code>,
затем <code>letsimp (%, <var>package_name_2</var>)</code> и так далее.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdefvr_002flet_005frule_005fpackages"></a><dl>
<dt><a name="index-let_005frule_005fpackages"></a>Управляющая переменная: <strong>let_rule_packages</strong></dt>
<dd><p>Значение по умолчанию: <code>[default_let_rule_package]</code>
</p>
<p><code>let_rule_packages</code> - список определенных пользователем пакетов
правил вместе с пакетом <code>default_let_rule_package</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fmatchdeclare"></a><dl>
<dt><a name="index-matchdeclare"></a>Функция: <strong>matchdeclare</strong> <em>(<var>a_1</var>, <var>pred_1</var>, ..., <var>a_n</var>, <var>pred_n</var>)</em></dt>
<dd><p>Связывает предикат <var>pred_k</var> с переменной или списком переменных
<var>a_k</var>, так что  <var>a_k</var> сопоставляется с выражениями,
для которых предикат возвращает значение отличное от <code>false</code>.
</p>
<p>Предикат это есть имя функции, или лямбда-выражение, или вызов функции 
или лямбда-выражения без последнего аргумента, или <code>true</code>, или <code>all</code>.
Если предикат определен при помощи вызова функции или лямбда-выражения, то 
тестируемое выражение добавляется к списку аргументов; аргументы вычисляются 
во время вызова процедуры проверки на соответствие. 
Если предикат определен в виде имени функции или лямбда-выражения, 
то единственным аргументом является тестируемое выражение.
Предикат не обязан быть определенным в момент вызова
<code>matchdeclare</code>, поскольку он не вычисляется до тех пор пока 
не вызывается проверка на соответствие.
</p>
<p>Предикат может возвращать логическое выражение а также <code>true</code> или <code>false</code>.
Логическое выражение вычисляется при помощи <code>is</code> внутри построенной функции правила,
так что нет необходимости вызывать <code>is</code> в предикате.
</p>
<p>Если выражение удовлетворяет предикату, то переменной шаблона
присваивается выражение за исключением переменных шаблона которые
являются операндами сложения  <code>+</code> или умножения <code>*</code>. 
Только сложение и умножение управляется специальным образом. Другие n-арные операторы,
(как пользовательские, так и встроенные) рассматриваются как обычные функции.
</p>
<p>В случае операторов сложения и умножения, переменной шаблона может быть
присвоено простое выражение, которое соответствует предикату, а также сумма
или произведение таких выражений. 
Такое сложное сопоставление является ресурсоемким: предикаты 
вычисляются в порядке в котором, ассоциированные с ними переменные,
встречаются в тестируемом выражении, и член, удовлетворяющий более чем одному предикату,
сопоставляется первому соответствующему предикату.
Каждый предикат проверяется для всех операндов суммы или произведения и только после этого проверяется
следующий предикат.  Кроме того, если 0 или 1 удовлетворяют предикату, а все остальные слагаемые выражения нет, 
тогда 0 или 1 присваиваются переменным шаблона ассоциированным с
предикатом.
</p>
<p>Алгоритм проверки шаблонов, содержащий суммы и произведения, 
может давать разные результаты (например,  шаблон, содержащий переменную соответствующую
&quot;всему, что угодно&quot;) в зависимости от порядка 
членов заданного шаблона и порядка членов тестируемого выражения. 
Если все операторы предикаты взаимно исключают друг друга, то результат не зависит от порядка, 
поскольку члены, соответствующие одному предикату, не могут соответствовать другому.
</p>
<p>Вызов  <code>matchdeclare</code> с переменной  <var>a</var> в качестве аргумента
изменяет ранее объявленные свойства  <code>matchdeclare</code> для <var>a</var> -
при определении правил преобразования, учитываются только самый последний 
вызов <code>matchdeclare</code>. 
Все последующие изменения свойства <code>matchdeclare</code> 
(посредством <code>matchdeclare</code> или <code>remove</code>) 
не меняют существующих правил преобразований.
</p>
<p><code>propvars (matchdeclare)</code> возвращает список всех переменных,
имеющих свойство <code>matchdeclare</code>.
<code>printprops (<var>a</var>, matchdeclare)</code> возвращает предикат
для переменной <code>a</code>.
<code>printprops (all, matchdeclare)</code> возвращает список всех предикатов
для всех переменных <code>matchdeclare</code>.
<code>remove (<var>a</var>, matchdeclare)</code> удаляет свойства
<code>matchdeclare</code> для переменной <var>a</var>.
</p>
<p>Функции
<code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>, <code>tellsimpafter</code> и <code>let</code>
строят правила, которые сопоставляют выражения с шаблонами.
</p>
<p>Функция <code>matchdeclare</code> не вычисляет свои аргументы.
Функция <code>matchdeclare</code> всегда возвращает <code>done</code>.
</p>
<p>Примеры:
</p>
<p>Предикат есть имя функции, или лямбда-выражение, или вызов функции или 
лямбда-вызов без последнего аргумента,
или <code>true</code>, или <code>all</code>.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) matchdeclare (bb, lambda ([x], x &gt; 0));
(%o2)                         done
(%i3) matchdeclare (cc, freeof (%e, %pi, %i));
(%o3)                         done
(%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
(%o4)                         done
(%i5) matchdeclare (ee, true);
(%o5)                         done
(%i6) matchdeclare (ff, all);
(%o6)                         done
</pre></div>

<p>Если выражение удовлетворяет предикату, то переменной 
шаблона присваивается выражение.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) defrule (r1, bb^aa, [&quot;integer&quot; = aa, &quot;atom&quot; = bb]);
                    aa
(%o2)        r1 : bb   -&gt; [integer = aa, atom = bb]
(%i3) r1 (%pi^8);
(%o3)               [integer = 8, atom = %pi]
</pre></div>

<p>В случае суммы и произведения,
переменной шаблона может быть присвоено простое выражение, которое
удовлетворяет предикату, или также сумма или произведение 
таких выражений.
</p><div class="example">
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + sin(x));
(%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * sin(x));
(%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]
</pre></div>

<p>При сопоставлении аргументов <code>+</code> и <code>*</code>,
если все предикаты условия являются взаимоисключающими, то результат
проверки не зависит порядка, так как один предикат не соответствует
членам, соответствующим другому предикату.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
(%o1)                         done
(%i2) defrule (r1, aa + bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb + aa partitions `sum'
(%o2)  r1 : bb + aa -&gt; [all atoms = aa, all nonatoms = bb]
(%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                     n
(%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
(%i4) defrule (r2, aa * bb, [&quot;all atoms&quot; = aa, &quot;all nonatoms&quot; =
               bb]);
bb aa partitions `product'
(%o4)   r2 : aa bb -&gt; [all atoms = aa, all nonatoms = bb]
(%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                  n
                                         (b + a) 2  sin(x)
(%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                 c
</pre></div>

<p>Функции <code>propvars</code> и <code>printprops</code> возвращают информацию о
переменных шаблона.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
(%o1)                         done
(%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x &gt; 100));
(%o2)                         done
(%i3) propvars (matchdeclare);
(%o3)             [aa, bb, cc, dd, ee, ff, gg]
(%i4) printprops (ee, matchdeclare);
(%o4)                    [integerp(ee)]
(%i5) printprops (gg, matchdeclare);
(%o5)              [lambda([x], x &gt; 100, gg)]
(%i6) printprops (all, matchdeclare);
(%o6) [lambda([x], x &gt; 100, gg), floatnump(ff), integerp(ee), 
                      integerp(dd), atom(cc), atom(bb), atom(aa)]
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;<a href="maxima_263.html#Category_003a-_0424_0430_043a_0442_044b-_0438-_0432_044b_0432_043e_0434_044b">Факты и выводы</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fmatchfix"></a><dl>
<dt><a name="index-matchfix"></a>Функция: <strong>matchfix</strong> <em>(<var>ldelimiter</var>, <var>rdelimiter</var>)</em></dt>
<dt><a name="index-matchfix-1"></a>Функция: <strong>matchfix</strong> <em>(<var>ldelimiter</var>, <var>rdelimiter</var>, <var>arg_pos</var>, <var>pos</var>)</em></dt>
<dd><p>Объявляет матчфиксный (matchfix) оператор с левым и правым ограничителями 
<var>ldelimiter</var> и <var>rdelimiter</var> соответственно. Ограничители являются строками.
</p>
<p>Матчфиксный оператор является функцией любого количества аргументов
заключенных между ограничителями <var>ldelimiter</var> и <var>rdelimiter</var>. 
Ограничителем может являться любая строка, если синтаксический анализатор 
может различить ограничители от других выражений и операторов.
На практике, это исключает такие ограничители, как
<code>%</code>, <code>,</code>, <code>$</code> и <code>;</code>, и может потребовать при вводе
изолировать ограничители пробелами. Правый ограничитель может
совпадать с левым или отличаться от него. 
</p>
<p>Левый ограничитель может быть ассоциирован только с одним правым; 
два различных матчфиксных оператора не могут иметь
одинаковых левых ограничителя. 
</p>
<p>Существующий оператор может быть переобъявлен, как матчфиксный оператор   
без изменения других его свойств. Например, встроенные
операторы сложения <code>+</code> могут быть объявлены матчфиксными, однако
операторные функции для встроенных операторов определены быть не могут.
</p>
<p>Вызов <code>matchfix (<var>ldelimiter</var>, <var>rdelimiter</var>, <var>arg_pos</var>, <var>pos</var>)</code> 
объявляет аргумент &quot;часть речи&quot; <var>arg_pos</var> и результат &quot;часть речи&quot; <var>pos</var> 
вместе с ограничителями <var>ldelimiter</var> и <var>rdelimiter</var>.
</p>
<p>Термин &quot;чать речи&quot; по отношению к декларации операторов означает тип выражения.
Различаются три типа выражений: <code>expr</code>, <code>clause</code> и <code>any</code>,
что обозначает алгебраическое выражение, логическое выражение и выражение
произвольного типа соответственно.  Maxima может обнаруживать некоторые
синтаксические ошибки сравнивая объявленную часть речи с реальным
выражением.
</p>

<p>Функция для выполнения матчфиксной операции является обычной пользовательской
функцией.  Операторная функция определяется стандартным образом 
при помощи операторов <code>:=</code> или <code>define</code>.
Аргументы могут быть записаны между ограничителями или при
помощи левого ограничителя в форме строки и последующих аргументов
в скобках.
<code>dispfun (<var>ldelimiter</var>)</code> выводит определение
функции. 
</p>
<p>Единственный встроенный матчфиксный оператор это конструктор
списка <code>[ ]</code>. Скобки <code>( )</code> и двойные кавычки <code>&quot; &quot;</code> 
работают как матчфиксные операторы, однако не обрабатываются
синтаксическим анализатором Maxima как таковые.
</p>
<p>Функция <code>matchfix</code> вычисляет свои аргументы.
Функция <code>matchfix</code> возвращает свой первый аргумент <var>ldelimiter</var>.
</p>
<p>Примеры:
</p>
<ul>
<li> В качестве ограничителей можно задавать практически любые строки.
</li></ul>
<div class="example">
<pre class="example">(%i1) matchfix (&quot;@@&quot;, &quot;~&quot;);
(%o1)                          @@
(%i2) @@ a, b, c ~;
(%o2)                      @@a, b, c~
(%i3) matchfix (&quot;&gt;&gt;&quot;, &quot;&lt;&lt;&quot;);
(%o3)                          &gt;&gt;
(%i4) &gt;&gt; a, b, c &lt;&lt;;
(%o4)                      &gt;&gt;a, b, c&lt;&lt;
(%i5) matchfix (&quot;foo&quot;, &quot;oof&quot;);
(%o5)                          foo
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) &gt;&gt; w + foo x, y oof + z &lt;&lt; / @@ p, q ~;
                     &gt;&gt;z + foox, yoof + w&lt;&lt;
(%o7)                ----------------------
                            @@p, q~
</pre></div>

<ul>
<li> Матчфиксные операторы &ndash; это обычные пользовательские функции.
</li></ul>
<div class="example">
<pre class="example">(%i1) matchfix (&quot;!-&quot;, &quot;-!&quot;);
(%o1)                         &quot;!-&quot;
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define (&quot;!-&quot; (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun (&quot;!-&quot;);
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) &quot;!-&quot; (3, 5);
                                16
(%o7)                         - --
                                15
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0421_0438_043d_0442_0430_043a_0441_0438_0441">Синтаксис</a>
&middot;<a href="maxima_263.html#Category_003a-_041e_043f_0435_0440_0430_0442_043e_0440_044b">Операторы</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fremlet"></a><dl>
<dt><a name="index-remlet"></a>Функция: <strong>remlet</strong> <em>(<var>prod</var>, <var>name</var>)</em></dt>
<dt><a name="index-remlet-1"></a>Функция: <strong>remlet</strong> <em>()</em></dt>
<dt><a name="index-remlet-2"></a>Функция: <strong>remlet</strong> <em>(all)</em></dt>
<dt><a name="index-remlet-3"></a>Функция: <strong>remlet</strong> <em>(all, <var>name</var>)</em></dt>
<dd><p>Удаляет правило подстановки <var>prod</var> -&gt; замена, 
определенное при самом последнем вызове функции <code>let</code>.  
При вызове с именем правила в качестве аргумента 
удаление производится из соответствующего пакета правил.
</p>
<p>Вызовы <code>remlet()</code> и <code>remlet(all)</code> удаляют все правила
подстановки из текущего пакета правил. При указании имени, например,
<code>remlet (all, <var>name</var>)</code>, пакет правил <var>name</var> также удаляется.
</p>
<p>Если необходимо изменить правило подстановки одного 
произведения, нет необходимости вызывать <code>remlet</code>, можно просто
переопределить подстановку данного произведения при помощи функции
<code>let</code>, с новой заменой и/или предикатом.
После этого вызов <code>remlet (<var>prod</var>)</code> восстанавливает исходное
правило подстановки.
</p>
<p>См. также функцию <code>remrule</code>, которая удаляет правила
определенные функцией  <code>tellsimp</code> или <code>tellsimpafter</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fremrule"></a><dl>
<dt><a name="index-remrule"></a>Функция: <strong>remrule</strong> <em>(<var>op</var>, <var>rulename</var>)</em></dt>
<dt><a name="index-remrule-1"></a>Функция: <strong>remrule</strong> <em>(<var>op</var>, all)</em></dt>
<dd><p>Удаляет правила, определенные функциями <code>tellsimp</code> или <code>tellsimpafter</code>.
</p>
<p><code>remrule (<var>op</var>, <var>rulename</var>)</code>
удаляет правило с именем <var>rulename</var> для оператора <var>op</var>.
Если оператор <var>op</var> является встроенным оператором или определен
пользователем (например, при помощи функций <code>infix</code>, <code>prefix</code>,
и т.п.), тогда <var>op</var> и <var>rulename</var> необходимо заключить в двойные кавычки.
</p>
<p><code>remrule (<var>op</var>, all)</code> удаляет все правила для оператора <var>op</var>.
</p>
<p>См. также функцию <code>remlet</code>, удаляющую правила, определенные при помощи <code>let</code>.
</p>
<p>Примеры:
</p>
<div class="example">
<pre class="example">(%i1) tellsimp (foo (aa, bb), bb - aa);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (aa + bb, special_add (aa, bb));
(%o2)                   [+rule1, simplus]
(%i3) infix (&quot;@@&quot;);
(%o3)                          @@
(%i4) tellsimp (aa @@ bb, bb/aa);
(%o4)                   [@@rule1, false]
(%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
(%o5)                  [quuxrule1, false]
(%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
(%o6)             [quuxrule2, quuxrule1, false]
(%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
       quux (%e, %pi)];
                                     bb
(%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                     aa
(%i8) remrule (foo, foorule1);
(%o8)                          foo
(%i9) remrule (&quot;+&quot;, &quot;+rule1&quot;);
(%o9)                           +
(%i10) remrule (&quot;@@&quot;, &quot;@@rule1&quot;);
(%o10)                         @@
(%i11) remrule (quux, all);
(%o11)                        quux
(%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
        quux (%e, %pi)];
(%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e), 
                                         quux(%e, %pi)]
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002ftellsimp"></a><dl>
<dt><a name="index-tellsimp"></a>Функция: <strong>tellsimp</strong> <em>(<var>pattern</var>, <var>replacement</var>)</em></dt>
<dd><p>аналогична <code>tellsimpafter</code>, но добавляет
новую информацию о правилах до уже существующей. Таким образом, сначала
применяются пользовательские правила упрощения, а потом правила,
встроенные в систему.
</p>
<p>Функция <code>tellsimp</code> используется, когда важно модифицировать выражение
до того, как оно обработано упрощателем, например, встроенный механизм
упрощения &quot;знает&quot; что-либо о структуре выражения, но возвращает результат,
который вас не устраивает. Если встроенный механизм
упрощения &quot;знает&quot; что-либо о главном операторе выражения, но работает не
достаточно эффективно - можно попробовать использовать <code>tellsimpafter</code>.
</p>
<p>Шаблон не может быть суммой, произведением, одиночной переменной или числом.
</p>
<p><code>rules</code> - список правил определенный функциями
<code>defrule</code>, <code>defmatch</code>, <code>tellsimp</code> и <code>tellsimpafter</code>.
</p>
<p>Примеры:
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (x, freeof (%i));
(%o1)                         done
(%i2) %iargs: false$
(%i3) tellsimp (sin(%i*x), %i*sinh(x));
(%o3)                 [sinrule1, simp-%sin]
(%i4) trigexpand (sin (%i*y + x));
(%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
(%i5) %iargs:true$
(%i6) errcatch(0^0);
 0
0  has been generated
(%o6)                          []
(%i7) ev (tellsimp (0^0, 1), simp: false);
(%o7)                  [^rule1, simpexpt]
(%i8) 0^0;
(%o8)                           1
(%i9) remrule (&quot;^&quot;, %th(2)[1]);
(%o9)                           ^
(%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
(%o10)                 [^rule2, simpexpt]
(%i11) (1 + sin(x))^2;
                                      2
(%o11)                    (sin(x) + 1)
(%i12) expand (%);
                                   2
(%o12)               2 sin(x) - cos (x) + 2
(%i13) sin(x)^2;
                                  2
(%o13)                     1 - cos (x)
(%i14) kill (rules);
(%o14)                        done
(%i15) matchdeclare (a, true);
(%o15)                        done
(%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
(%o16)                 [^rule3, simpexpt]
(%i17) sin(y)^2;
                                  2
(%o17)                     1 - cos (y)
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002ftellsimpafter"></a><dl>
<dt><a name="index-tellsimpafter"></a>Функция: <strong>tellsimpafter</strong> <em>(<var>pattern</var>, <var>replacement</var>)</em></dt>
<dd><p>Определяет правило упрощения, которое встроенный в Maxima механизм
упрощения применяет после встроенных правил упрощения.
<var>pattern</var> - выражение, включающее переменные шаблона (объявленные в <code>matchdeclare</code>)
и другие атомы и операторы, которые рассматриваются как константы с точки зрения сопоставления с шаблоном.
<var>replacement</var> подставляется вместо первоначального выражения, удовлетворяющего шаблону <var>pattern</var>;
переменным шаблона из в <var>replacement</var> присваиваются соответствующие подвыражения из
реального выражения.
</p>
<p><var>pattern</var> может быть любым составным выражением в котором имя главного
оператор не входит в число переменных шаблона;
правило упрощения связывается с именем главного оператора.
Имена функций (за исключением приведенных ниже), списки и массивы могут присутствовать
в шаблоне  <var>pattern</var> в качестве основного оператора только, как
литералы (не переменные шаблона);
это исключает шаблоны вида <code>aa(x)</code> и <code>bb[y]</code>,
если <code>aa</code> и <code>bb</code> являются переменными шаблона.
Имена функций, списки и массивы, которые являются переменными шаблона
могут входить в качестве не основных операторов в описание шаблона <var>pattern</var>.
</p>
<p>Есть одно исключение к указанному правилу, касающееся имен функций.
Имена функций с индексом в выражениях типа <code>aa[x](y)</code>
могут быть переменными шаблона, поскольку в этом случае главный оператор 
не  <code>aa</code>, а Lisp-атом <code>mqapply</code>.
Это является следствием представления выражений, включающих
функции с индексом.
</p>

<p>Правила упрощения применяются после вычисления (если вычисления не
запрещены либо экранированием выражения, либо ключом <code>noeval</code>).
Правила введенные <code>tellsimpafter</code> применяются в том порядке в
котором они были определены после всех встроенных правил.
Преобразования применяются &quot;снизу-вверх&quot;, т.е.,
сначала к подвыражению, перед обработкой выражения в  целом.
Иногда для того, чтобы обеспечить, что применены все правила, необходимо повторное упрощение результата 
(например, при применении оператора кавычка-кавычка <code>'<!-- /@w -->'</code> или ключа <code>infeval</code>).
</p>
<p>Переменные шаблона рассматриваются как локальные переменные в правилах
упрощения. Как только правило определено, значение переменной шаблона
не  влияет на правило, и наоборот, правило не влияет на значение переменной.
Присваивание значений переменным шаблона, происходящее в результате успешного
сопоставления шаблона, не влияет на текущие значения (или их отсутствие)
переменных шаблона. Однако, как и у всех атомов в Maxima,
свойства переменных шаблона (объявленные оператором  <code>put</code>
и подобными функциями) являются глобальными.
</p>
<p>Правило, построенное с помощью <code>tellsimpafter</code>,
обозначаеся именем главного оператора <var>pattern</var>.
Правила для встроенных операторов и пользовательских функций,
определенных  при помощи <code>infix</code>, <code>prefix</code>, 
<code>postfix</code>, <code>matchfix</code> и <code>nofix</code>,
имеют имена, являющиеся Lisp-идентификаторами.
Правила для других функций имеют имена, являющиеся идентификаторами Maxima.
</p>
<p>Обработка вычисляемых и не вычисляемых форм немного неоднозначна. Если правило определено для невычисляемой (или вычисляемой) формы
выражения, а правило для соответствующей вычисляемой (или невычисляемой) 
уже существует, то новое правило применяется к обеим формам
выражения (вычисляемой и невычисляемой).
Если правило для соответствующей вычисляемой (или невычисляемой) 
не существует, то новое правило применяется к невычисляемой 
(или вычисляемой) форме выражения.
</p>
<p>Правило, построенное с помощью <code>tellsimpafter</code>, является обычной
Lisp- функцией. Если имя правила - <code>$foorule1</code>, то
конструкция <code>:lisp (trace $foorule1)</code> дает трассировку ее вызовов, 
а <code>:lisp (symbol-function '$foorule1</code> выводит ее определение.
</p>
<p>Функция <code>tellsimpafter</code> не вычисляет свои аргументы.
Функция <code>tellsimpafter</code> возвращает список правил для основного оператора
шаблона <var>pattern</var>, включая вновь объявленные правила.
</p>
<p>См. также <code>matchdeclare</code>, <code>defmatch</code>, <code>defrule</code>, <code>tellsimp</code>, <code>let</code>,
<code>kill</code>, <code>remrule</code> и <code>clear_rules</code>.
</p>
<p>Примеры:
</p>
<p><var>pattern</var> может быть любым неатомарным выражением в котором главный
оператор не является переменной шаблона.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
(%i2) tellsimpafter (sin (ll), map (sin, ll));
(%o2)                 [sinrule1, simp-%sin]
(%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                    1  sqrt(2)  sqrt(3)
(%o3)              [-, -------, -------, 1, 0]
                    2     2        2
(%i4) tellsimpafter (ll^mm, map (&quot;^&quot;, ll, mm));
(%o4)                  [^rule1, simpexpt]
(%i5) [a, b, c]^[1, 2, 3];
                                2   3
(%o5)                      [a, b , c ]
(%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
(%o6)                   [foorule1, false]
(%i7) foo (bar (u - v));
(%o7)                    bar(foo(u - v))
</pre></div>

<p>Правила применяются в том порядке в котором они были определены.
Если два правила соответствуют выражению, то первым
применяется то, которое было определено раньше.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, integerp);
(%o1)                         done
(%i2) tellsimpafter (foo (aa), bar_1 (aa));
(%o2)                   [foorule1, false]
(%i3) tellsimpafter (foo (aa), bar_2 (aa));
(%o3)              [foorule2, foorule1, false]
(%i4) foo (42);
(%o4)                       bar_1(42)
</pre></div>

<p>Переменные шаблона являются локальными переменные правил упрощения.
(Сравни с  функцией <code>defmatch</code>, которая рассматривает переменные
шаблона, как глобальные).
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) bb: 12345;
(%o3)                         12345
(%i4) foo (42, %e);
(%o4)                 bar(aa = 42, bb = %e)
(%i5) bb;
(%o5)                         12345
</pre></div>

<p>Как и у всех атомов, свойства переменных шаблона
являются глобальными даже если их значение локально.
В данном примере свойство объявляется при помощи <code>define_variable</code>.
Это свойство атома <code>bb</code> является глобальным.
</p>
<div class="example">
<pre class="example">(%i1) matchdeclare (aa, integerp, bb, atom);
(%o1)                         done
(%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
(%o2)                   [foorule1, false]
(%i3) foo (42, %e);
(%o3)                 bar(aa = 42, bb = %e)
(%i4) define_variable (bb, true, boolean);
(%o4)                         true
(%i5) foo (42, %e);
Error: bb was declared mode boolean, has value: %e
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></div>

<p>Правила именуются по имени основного оператора.
Имена правил для встроенных и пользовательских операторов
являются Lisp-идентификаторами, тогда как имена других функций 
являются идентификаторами Maxima.
</p>
<div class="example">
<pre class="example">(%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
(%o1)                   [foorule1, false]
(%i2) tellsimpafter (foo (%pi * %e), 17*%e);
(%o2)              [foorule2, foorule1, false]
(%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
(%o3)         [foorule3, foorule2, foorule1, false]
(%i4) tellsimpafter (foo (9) + foo (13), quux (22));
(%o4)                   [+rule1, simplus]
(%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
(%o5)                  [*rule1, simptimes]
(%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
(%o6)                  [^rule1, simpexpt]
(%i7) rules;
(%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
(%i8) foorule_name: first (%o1);
(%o8)                       foorule1
(%i9) plusrule_name: first (%o4);
(%o9)                        +rule1
(%i10) remrule (foo, foorule1);
(%o10)                         foo
(%i11) remrule (&quot;^&quot;, ?\^rule1);
(%o11)                          ^
(%i12) rules;
(%o12)        [foorule2, foorule3, +rule1, *rule1]
</pre></div>

<p>Рабочий пример: антикоммутативное умножение.
</p>
<div class="example">
<pre class="example">(%i1) gt (i, j) := integerp(j) and i &lt; j;
(%o1)           gt(i, j) := integerp(j) and i &lt; j
(%i2) matchdeclare (i, integerp, j, gt(i));
(%o2)                         done
(%i3) tellsimpafter (s[i]^^2, 1);
(%o3)                 [^^rule1, simpncexpt]
(%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
(%o4)                   [.rule1, simpnct]
(%i5) s[1] . (s[1] + s[2]);
(%o5)                    s  . (s  + s )
                          1     2    1
(%i6) expand (%);
(%o6)                      1 - s  . s
                                2    1
(%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
(%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
            9    8    7    6    5    4    3    2    1    0
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<a name="Item_003a-Rules_002fdeffn_002fclear_005frules"></a><dl>
<dt><a name="index-clear_005frules"></a>Функция: <strong>clear_rules</strong> <em>()</em></dt>
<dd><p>Исполняет <code>kill (rules)</code> и обнуляет счетчик, т.е. новое правило
будет иметь номер <code>1</code> вслед за встроенными правилами для операторов суммы
<code>+</code>, умножения  <code>*</code> и степени <code>^</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b">Правила преобразования и шаблоны</a>
&middot;</div></dd></dl>

<hr>
<div class="header">
<p>
Previous: <a href="maxima_132.html#g_t_0412_0432_0435_0434_0435_043d_0438_0435-_0432-_043f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_0439-_0438-_0448_0430_0431_043b_043e_043d_044b" accesskey="p" rel="previous">Введение в правила преобразований и шаблоны</a>, Up: <a href="maxima_131.html#g_t_041f_0440_0430_0432_0438_043b_0430-_043f_0440_0435_043e_0431_0440_0430_0437_043e_0432_0430_043d_0438_044f-_0438-_0448_0430_0431_043b_043e_043d_044b" accesskey="u" rel="up">Правила преобразования и шаблоны</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
