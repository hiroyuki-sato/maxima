This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Sums Products and Series,  Next: Теория чисел,  Prev: Пакет atensor,  Up: Top

28 Sums, Products, and Series
*****************************

* Menu:

* Functions and Variables for Sums and Products::
* Introduction to Series::
* Functions and Variables for Series::
* Introduction to Fourier series::
* Functions and Variables for Fourier series::
* Functions and Variables for Poisson series::


File: maxima.info,  Node: Functions and Variables for Sums and Products,  Next: Introduction to Series,  Prev: Sums Products and Series,  Up: Sums Products and Series

28.1 Functions and Variables for Sums and Products
==================================================

 -- Function: bashindices (<expr>)

     Transforms the expression <expr> by giving each summation and
     product a unique index.  This gives ‘changevar’ greater precision
     when it is working with summations or products.  The form of the
     unique index is ‘j<number>’.  The quantity <number> is determined
     by referring to ‘gensumnum’, which can be changed by the user.  For
     example, ‘gensumnum:0$’ resets it.

 -- Function: lsum (<expr>, <x>, <L>)

     Represents the sum of <expr> for each element <x> in <L>.  A noun
     form ‘'lsum’ is returned if the argument <L> does not evaluate to a
     list.

     Examples:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1, x)

 -- Function: intosum (<expr>)

     Moves multiplicative factors outside a summation to inside.  If the
     index is used in the outside expression, then the function tries to
     find a reasonable index, the same as it does for ‘sumcontract’.
     This is essentially the reverse idea of the ‘outative’ property of
     summations, but note that it does not remove this property, it only
     bypasses it.

     In some cases, a ‘scanmap (multthru, <expr>)’ may be necessary
     before the ‘intosum’.

 -- Option variable: simpproduct
     Default value: ‘false’

     When ‘simpproduct’ is ‘true’, the result of a ‘product’ is
     simplified.  This simplification may sometimes be able to produce a
     closed form.  If ‘simpproduct’ is ‘false’ or if the quoted form
     ‘'product’ is used, the value is a product noun form which is a
     representation of the pi notation used in mathematics.

 -- Function: product (<expr>, <i>, <i_0>, <i_1>)

     Represents a product of the values of <expr> as the index <i>
     varies from <i_0> to <i_1>.  The noun form ‘'product’ is displayed
     as an uppercase letter pi.

     ‘product’ evaluates <expr> and lower and upper limits <i_0> and
     <i_1>, ‘product’ quotes (does not evaluate) the index <i>.

     If the upper and lower limits differ by an integer, <expr> is
     evaluated for each value of the index <i>, and the result is an
     explicit product.

     Otherwise, the range of the index is indefinite.  Some rules are
     applied to simplify the product.  When the global variable
     ‘simpproduct’ is ‘true’, additional rules are applied.  In some
     cases, simplification yields a result which is not a product;
     otherwise, the result is a noun form ‘'product’.

     See also ‘nouns’ and ‘evflag’.

     Examples:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- Option variable: simpsum
     Default value: ‘false’

     When ‘simpsum’ is ‘true’, the result of a ‘sum’ is simplified.
     This simplification may sometimes be able to produce a closed form.
     If ‘simpsum’ is ‘false’ or if the quoted form ‘'sum’ is used, the
     value is a sum noun form which is a representation of the sigma
     notation used in mathematics.

 -- Function: sum (<expr>, <i>, <i_0>, <i_1>)

     Represents a summation of the values of <expr> as the index <i>
     varies from <i_0> to <i_1>.  The noun form ‘'sum’ is displayed as
     an uppercase letter sigma.

     ‘sum’ evaluates its summand <expr> and lower and upper limits <i_0>
     and <i_1>, ‘sum’ quotes (does not evaluate) the index <i>.

     If the upper and lower limits differ by an integer, the summand
     <expr> is evaluated for each value of the summation index <i>, and
     the result is an explicit sum.

     Otherwise, the range of the index is indefinite.  Some rules are
     applied to simplify the summation.  When the global variable
     ‘simpsum’ is ‘true’, additional rules are applied.  In some cases,
     simplification yields a result which is not a summation; otherwise,
     the result is a noun form ‘'sum’.

     When the ‘evflag’ (evaluation flag) ‘cauchysum’ is ‘true’, a
     product of summations is expressed as a Cauchy product, in which
     the index of the inner summation is a function of the index of the
     outer one, rather than varying independently.

     The global variable ‘genindex’ is the alphabetic prefix used to
     generate the next index of summation, when an automatically
     generated index is needed.

     ‘gensumnum’ is the numeric suffix used to generate the next index
     of summation, when an automatically generated index is needed.
     When ‘gensumnum’ is ‘false’, an automatically-generated index is
     only ‘genindex’ with no numeric suffix.

     See also ‘lsum’, ‘sumcontract’, ‘intosum’, ‘bashindices’,
     ‘niceindices’, ‘nouns’, ‘evflag’, and *note zeilberger-pkg::

     Examples:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- Function: sumcontract (<expr>)

     Combines all sums of an addition that have upper and lower bounds
     that differ by constants.  The result is an expression containing
     one summation for each set of such summations added to all
     appropriate extra terms that had to be extracted to form this sum.
     ‘sumcontract’ combines all compatible sums and uses one of the
     indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.

     It may be necessary to do an ‘intosum (<expr>)’ before the
     ‘sumcontract’.

 -- Option variable: sumexpand
     Default value: ‘false’

     When ‘sumexpand’ is ‘true’, products of sums and exponentiated sums
     simplify to nested sums.

     See also ‘cauchysum’.

     Examples:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


File: maxima.info,  Node: Introduction to Series,  Next: Functions and Variables for Series,  Prev: Functions and Variables for Sums and Products,  Up: Sums Products and Series

28.2 Introduction to Series
===========================

Maxima contains functions ‘taylor’ and ‘powerseries’ for finding the
series of differentiable functions.  It also has tools such as ‘nusum’
capable of finding the closed form of some series.  Operations such as
addition and multiplication work as usual on series.  This section
presents the global variables which control the expansion.


File: maxima.info,  Node: Functions and Variables for Series,  Next: Introduction to Fourier series,  Prev: Introduction to Series,  Up: Sums Products and Series

28.3 Functions and Variables for Series
=======================================

 -- Option variable: cauchysum
     Default value: ‘false’

     When multiplying together sums with ‘inf’ as their upper limit, if
     ‘sumexpand’ is ‘true’ and ‘cauchysum’ is ‘true’ then the Cauchy
     product will be used rather than the usual product.  In the Cauchy
     product the index of the inner summation is a function of the index
     of the outer one rather than varying independently.

     Example:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) expand(s,0,0);
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0

 -- Function: deftaylor (<f_1>(<x_1>), <expr_1>, …, <f_n>(<x_n>),
          <expr_n>)

     For each function <f_i> of one variable <x_i>, ‘deftaylor’ defines
     <expr_i> as the Taylor series about zero.  <expr_i> is typically a
     polynomial in <x_i> or a summation; more general expressions are
     accepted by ‘deftaylor’ without complaint.

     ‘powerseries (<f_i>(<x_i>), <x_i>, 0)’ returns the series defined
     by ‘deftaylor’.

     ‘deftaylor’ returns a list of the functions <f_1>, …, <f_n>.
     ‘deftaylor’ evaluates its arguments.

     Example:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200

 -- Option variable: maxtayorder
     Default value: ‘true’

     When ‘maxtayorder’ is ‘true’, then during algebraic manipulation of
     (truncated) Taylor series, ‘taylor’ tries to retain as many terms
     as are known to be correct.

 -- Function: niceindices (<expr>)

     Renames the indices of sums and products in <expr>.  ‘niceindices’
     attempts to rename each index to the value of ‘niceindicespref[1]’,
     unless that name appears in the summand or multiplicand, in which
     case ‘niceindices’ tries the succeeding elements of
     ‘niceindicespref’ in turn, until an unused variable is found.  If
     the entire list is exhausted, additional indices are constructed by
     appending integers to the value of ‘niceindicespref[1]’, e.g.,
     ‘i0’, ‘i1’, ‘i2’, …

     ‘niceindices’ returns an expression.  ‘niceindices’ evaluates its
     argument.

     Example:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1

 -- Option variable: niceindicespref
     Default value: ‘[i, j, k, l, m, n]’

     ‘niceindicespref’ is the list from which ‘niceindices’ takes the
     names of indices for sums and products.

     The elements of ‘niceindicespref’ are typically names of variables,
     although that is not enforced by ‘niceindices’.

     Example:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1

 -- Function: nusum (<expr>, <x>, <i_0>, <i_1>)

     Carries out indefinite hypergeometric summation of <expr> with
     respect to <x> using a decision procedure due to R.W. Gosper.
     <expr> and the result must be expressible as products of integer
     powers, factorials, binomials, and rational functions.

     The terms "definite" and "indefinite summation" are used
     analogously to "definite" and "indefinite integration".  To sum
     indefinitely means to give a symbolic result for the sum over
     intervals of variable length, not just e.g.  0 to inf.  Thus, since
     there is no formula for the general partial sum of the binomial
     series, ‘nusum’ can’t do it.

     ‘nusum’ and ‘unsum’ know a little about sums and differences of
     finite products.  See also ‘unsum’.

     Examples:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1

 -- Function: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)

     Returns a list of all rational functions which have the given
     Taylor series expansion where the sum of the degrees of the
     numerator and the denominator is less than or equal to the
     truncation level of the power series, i.e.  are "best"
     approximants, and which additionally satisfy the specified degree
     bounds.

     <taylor_series> is an univariate Taylor series.  <numer_deg_bound>
     and <denom_deg_bound> are positive integers specifying degree
     bounds on the numerator and denominator.

     <taylor_series> can also be a Laurent series, and the degree bounds
     can be ‘inf’ which causes all rational functions whose total degree
     is less than or equal to the length of the power series to be
     returned.  Total degree is defined as ‘<numer_deg_bound> +
     <denom_deg_bound>’.  Length of a power series is defined as
     ‘"truncation level" + 1 - min(0, "order of series")’.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     There is no rational function of degree 4 numerator/denominator,
     with this power series expansion.  You must in general have degree
     of the numerator and degree of the denominator adding up to at
     least the degree of the power series, in order to have enough
     unknown coefficients to solve.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]

 -- Function: powerseries (<expr>, <x>, <a>)

     Returns the general form of the power series expansion for <expr>
     in the variable <x> about the point <a> (which may be ‘inf’ for
     infinity):
                     inf
                     ====
                     \               n
                      >    b  (x - a)
                     /      n
                     ====
                     n = 0

     If ‘powerseries’ is unable to expand <expr>, ‘taylor’ may give the
     first several terms of the series.

     When ‘verbose’ is ‘true’, ‘powerseries’ prints progress messages.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2

 -- Option variable: psexpand
     Default value: ‘false’

     When ‘psexpand’ is ‘true’, an extended rational function expression
     is displayed fully expanded.  The switch ‘ratexpand’ has the same
     effect.

     When ‘psexpand’ is ‘false’, a multivariate expression is displayed
     just as in the rational function package.

     When ‘psexpand’ is ‘multi’, then terms with the same total degree
     in the variables are grouped together.

 -- Function: revert (<expr>, <x>)
 -- Function: revert2 (<expr>, <x>, <n>)

     These functions return the reversion of <expr>, a Taylor series
     about zero in the variable <x>.  ‘revert’ returns a polynomial of
     degree equal to the highest power in <expr>.  ‘revert2’ returns a
     polynomial of degree <n>, which may be greater than, equal to, or
     less than the degree of <expr>.

     ‘load ("revert")’ loads these functions.

     Examples:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2

 -- Function: taylor
          taylor (<expr>, <x>, <a>, <n>)
          taylor (<expr>, [<x_1>, <x_2>, …], <a>, <n>)
          taylor (<expr>, [<x>, <a>, <n>, 'asymp])
          taylor (<expr>, [<x_1>, <x_2>, …], [<a_1>, <a_2>, …], [<n_1>,
          <n_2>, …])
          taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
          …)

     ‘taylor (<expr>, <x>, <a>, <n>)’ expands the expression <expr> in a
     truncated Taylor or Laurent series in the variable <x> around the
     point <a>, containing terms through ‘(<x> - <a>)^<n>’.

     If <expr> is of the form ‘<f>(<x>)/<g>(<x>)’ and ‘<g>(<x>)’ has no
     terms up to degree <n> then ‘taylor’ attempts to expand ‘<g>(<x>)’
     up to degree ‘2 <n>’.  If there are still no nonzero terms,
     ‘taylor’ doubles the degree of the expansion of ‘<g>(<x>)’ so long
     as the degree of the expansion is less than or equal to ‘<n>
     2^taylordepth’.

     ‘taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)’ returns a
     truncated power series of degree <n> in all variables <x_1>, <x_2>,
     … about the point ‘(<a>, <a>, ...)’.

     ‘taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)’ returns a truncated power series in the variables <x_1>,
     <x_2>, … about the point ‘(<a_1>, <a_2>, ...)’, truncated at <n_1>,
     <n_2>, …

     ‘taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])’ returns a truncated power series in the variables
     <x_1>, <x_2>, … about the point ‘(<a_1>, <a_2>, ...)’, truncated at
     <n_1>, <n_2>, …

     ‘taylor (<expr>, [<x>, <a>, <n>, 'asymp])’ returns an expansion of
     <expr> in negative powers of ‘<x> - <a>’.  The highest order term
     is ‘(<x> - <a>)^<-n>’.

     When ‘maxtayorder’ is ‘true’, then during algebraic manipulation of
     (truncated) Taylor series, ‘taylor’ tries to retain as many terms
     as are known to be correct.

     When ‘psexpand’ is ‘true’, an extended rational function expression
     is displayed fully expanded.  The switch ‘ratexpand’ has the same
     effect.  When ‘psexpand’ is ‘false’, a multivariate expression is
     displayed just as in the rational function package.  When
     ‘psexpand’ is ‘multi’, then terms with the same total degree in the
     variables are grouped together.

     See also the ‘taylor_logexpand’ switch for controlling expansion.

     Examples:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360

 -- Option variable: taylordepth
     Default value: 3

     If there are still no nonzero terms, ‘taylor’ doubles the degree of
     the expansion of ‘<g>(<x>)’ so long as the degree of the expansion
     is less than or equal to ‘<n> 2^taylordepth’.

 -- Function: taylorinfo (<expr>)

     Returns information about the Taylor series <expr>.  The return
     value is a list of lists.  Each list comprises the name of a
     variable, the point of expansion, and the degree of the expansion.

     ‘taylorinfo’ returns ‘false’ if <expr> is not a Taylor series.

     Example:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]

 -- Function: taylorp (<expr>)

     Returns ‘true’ if <expr> is a Taylor series, and ‘false’ otherwise.

 -- Option variable: taylor_logexpand
     Default value: ‘true’

     ‘taylor_logexpand’ controls expansions of logarithms in ‘taylor’
     series.

     When ‘taylor_logexpand’ is ‘true’, all logarithms are expanded
     fully so that zero-recognition problems involving logarithmic
     identities do not disturb the expansion process.  However, this
     scheme is not always mathematically correct since it ignores branch
     information.

     When ‘taylor_logexpand’ is set to ‘false’, then the only expansion
     of logarithms that occur is that necessary to obtain a formal power
     series.

 -- Option variable: taylor_order_coefficients
     Default value: ‘true’

     ‘taylor_order_coefficients’ controls the ordering of coefficients
     in a Taylor series.

     When ‘taylor_order_coefficients’ is ‘true’, coefficients of taylor
     series are ordered canonically.

 -- Function: taylor_simplifier (<expr>)

     Simplifies coefficients of the power series <expr>.  ‘taylor’ calls
     this function.

 -- Option variable: taylor_truncate_polynomials
     Default value: ‘true’

     When ‘taylor_truncate_polynomials’ is ‘true’, polynomials are
     truncated based upon the input truncation levels.

     Otherwise, polynomials input to ‘taylor’ are considered to have
     infinite precision.

 -- Function: taytorat (<expr>)

     Converts <expr> from ‘taylor’ form to canonical rational expression
     (CRE) form.  The effect is the same as ‘rat (ratdisrep (<expr>))’,
     but faster.

 -- Function: trunc (<expr>)

     Annotates the internal representation of the general expression
     <expr> so that it is displayed as if its sums were truncated Taylor
     series.  <expr> is not otherwise modified.

     Example:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true

 -- Function: unsum (<f>, <n>)

     Returns the first backward difference ‘<f>(<n>) - <f>(<n> - 1)’.
     Thus ‘unsum’ in a sense is the inverse of ‘sum’.

     See also ‘nusum’.

     Examples:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)

 -- Option variable: verbose
     Default value: ‘false’

     When ‘verbose’ is ‘true’, ‘powerseries’ prints progress messages.


File: maxima.info,  Node: Introduction to Fourier series,  Next: Functions and Variables for Fourier series,  Prev: Functions and Variables for Series,  Up: Sums Products and Series

28.4 Introduction to Fourier series
===================================

The ‘fourie’ package comprises functions for the symbolic computation of
Fourier series.  There are functions in the ‘fourie’ package to
calculate Fourier integral coefficients and some functions for
manipulation of expressions.


File: maxima.info,  Node: Functions and Variables for Fourier series,  Next: Functions and Variables for Poisson series,  Prev: Introduction to Fourier series,  Up: Sums Products and Series

28.5 Functions and Variables for Fourier series
===============================================

 -- Function: equalp (<x>, <y>)

     Returns ‘true’ if ‘equal (<x>, <y>)’ otherwise ‘false’ (doesn’t
     give an error message like ‘equal (x, y)’ would do in this case).

 -- Function: remfun
          remfun (<f>, <expr>)
          remfun (<f>, <expr>, <x>)

     ‘remfun (<f>, <expr>)’ replaces all occurrences of ‘<f> (<arg>)’ by
     <arg> in <expr>.

     ‘remfun (<f>, <expr>, <x>)’ replaces all occurrences of ‘<f>
     (<arg>)’ by <arg> in <expr> only if <arg> contains the variable
     <x>.

 -- Function: funp
          funp (<f>, <expr>)
          funp (<f>, <expr>, <x>)

     ‘funp (<f>, <expr>)’ returns ‘true’ if <expr> contains the function
     <f>.

     ‘funp (<f>, <expr>, <x>)’ returns ‘true’ if <expr> contains the
     function <f> and the variable <x> is somewhere in the argument of
     one of the instances of <f>.

 -- Function: absint
          absint (<f>, <x>, <halfplane>)
          absint (<f>, <x>)
          absint (<f>, <x>, <a>, <b>)

     ‘absint (<f>, <x>, <halfplane>)’ returns the indefinite integral of
     <f> with respect to <x> in the given halfplane (‘pos’, ‘neg’, or
     ‘both’).  <f> may contain expressions of the form ‘abs (x)’, ‘abs
     (sin (x))’, ‘abs (a) * exp (-abs (b) * abs (x))’.

     ‘absint (<f>, <x>)’ is equivalent to ‘absint (<f>, <x>, pos)’.

     ‘absint (<f>, <x>, <a>, <b>)’ returns the definite integral of <f>
     with respect to <x> from <a> to <b>.  <f> may include absolute
     values.

 -- Function: fourier (<f>, <x>, <p>)

     Returns a list of the Fourier coefficients of ‘<f>(<x>)’ defined on
     the interval ‘[-p, p]’.

 -- Function: foursimp (<l>)

     Simplifies ‘sin (n %pi)’ to 0 if ‘sinnpiflag’ is ‘true’ and ‘cos (n
     %pi)’ to ‘(-1)^n’ if ‘cosnpiflag’ is ‘true’.

 -- Option variable: sinnpiflag
     Default value: ‘true’

     See ‘foursimp’.

 -- Option variable: cosnpiflag
     Default value: ‘true’

     See ‘foursimp’.

 -- Function: fourexpand (<l>, <x>, <p>, <limit>)

     Constructs and returns the Fourier series from the list of Fourier
     coefficients <l> up through <limit> terms (<limit> may be ‘inf’).
     <x> and <p> have same meaning as in ‘fourier’.

 -- Function: fourcos (<f>, <x>, <p>)

     Returns the Fourier cosine coefficients for ‘<f>(<x>)’ defined on
     ‘[0, <p>]’.

 -- Function: foursin (<f>, <x>, <p>)

     Returns the Fourier sine coefficients for ‘<f>(<x>)’ defined on
     ‘[0, <p>]’.

 -- Function: totalfourier (<f>, <x>, <p>)

     Returns ‘fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)’.

 -- Function: fourint (<f>, <x>)

     Constructs and returns a list of the Fourier integral coefficients
     of ‘<f>(<x>)’ defined on ‘[minf, inf]’.

 -- Function: fourintcos (<f>, <x>)

     Returns the Fourier cosine integral coefficients for ‘<f>(<x>)’ on
     ‘[0, inf]’.

 -- Function: fourintsin (<f>, <x>)

     Returns the Fourier sine integral coefficients for ‘<f>(<x>)’ on
     ‘[0, inf]’.


File: maxima.info,  Node: Functions and Variables for Poisson series,  Prev: Functions and Variables for Fourier series,  Up: Sums Products and Series

28.6 Functions and Variables for Poisson series
===============================================

 -- Function: intopois (<a>)
     Converts <a> into a Poisson encoding.

 -- Function: outofpois (<a>)

     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, ‘outofpois’ carries out the conversion,
     i.e., the return value is ‘outofpois (intopois (<a>))’.  This
     function is thus a canonical simplifier for sums of powers of sine
     and cosine terms of a particular type.

 -- Function: poisdiff (<a>, <b>)

     Differentiates <a> with respect to <b>.  <b> must occur only in the
     trig arguments or only in the coefficients.

 -- Function: poisexpt (<a>, <b>)

     Functionally identical to ‘intopois (<a>^<b>)’.  <b> must be a
     positive integer.

 -- Function: poisint (<a>, <b>)

     Integrates in a similarly restricted sense (to ‘poisdiff’).
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.

 -- Option variable: poislim
     Default value: 5

     ‘poislim’ determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].

 -- Function: poismap (<series>, <sinfn>, <cosfn>)

     will map the functions <sinfn> on the sine terms and <cosfn> on the
     cosine terms of the Poisson series given.  <sinfn> and <cosfn> are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.

 -- Function: poisplus (<a>, <b>)

     Is functionally identical to ‘intopois (a + b)’.

 -- Function: poissimp (<a>)

     Converts <a> into a Poisson series for <a> in general
     representation.

 -- Special symbol: poisson

     The symbol ‘/P/’ follows the line label of Poisson series
     expressions.

 -- Function: poissubst (<a>, <b>, <c>)

     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., ‘6*u +
     4*v’).

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     ‘poissubst (<a>, <b>, <c>, <d>, <n>)’ is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands ‘cos(<d>)’ and
     ‘sin(<d>)’ to order <n> so as to provide the result of substituting
     ‘<a> + <d>’ for <b> in <c>.  The idea is that <d> is an expansion
     in terms of a small parameter.  For example, ‘poissubst (u, v,
     cos(v), %e, 3)’ yields ‘cos(u)*(1 - %e^2/2) - sin(u)*(%e -
     %e^3/6)’.

 -- Function: poistimes (<a>, <b>)

     Is functionally identical to ‘intopois (<a>*<b>)’.

 -- Function: poistrim ()

     is a reserved function name which (if the user has defined it) gets
     applied during Poisson multiplication.  It is a predicate function
     of 6 arguments which are the coefficients of the <u>, <v>, ..., <z>
     in a term.  Terms for which ‘poistrim’ is ‘true’ (for the
     coefficients of that term) are eliminated during multiplication.

 -- Function: printpois (<a>)

     Prints a Poisson series in a readable format.  In common with
     ‘outofpois’, it will convert <a> into a Poisson encoding first, if
     necessary.


File: maxima.info,  Node: Теория чисел,  Next: Symmetries,  Prev: Sums Products and Series,  Up: Top

29 Теория чисел
***************

* Menu:

* Функции и переменные для теории чисел::  


File: maxima.info,  Node: Функции и переменные для теории чисел,  Prev: Теория чисел,  Up: Теория чисел

29.1 Функции и переменные для теории чисел
==========================================

 -- Функция: bern (<n>)

     Возвращает <n>-е число Бернулли для целого <n>.  Числа Бернулли,
     равные нулю, опускаются, если ‘zerobern’ равно ‘false’.

     См.  также ‘burn’.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798

 -- Функция: bernpoly (<x>, <n>)
     Возвращает значение многочлена Бернулли порядка <n> в точке <x>.

 -- Функция: bfzeta (<s>, <n>)

     Возвращает дзэта-функцию Римана для аргумента <s>.  Возвращаемое
     значение - число с плавающей точкой повышенной точности (bfloat);
     <n> - количество цифр в возвращаемом значении.

 -- Функция: bfhzeta (<s>, <h>, <n>)

     Возвращает дзэта-функцию Гурвица для аргументов <s> и <h>.
     Возвращаемое значение - число с плавающей точкой повышенной
     точности (bfloat); <n> - количество цифр в возвращаемом значении.
     Дзэта-функция Гурвица определяется как

          sum ((k+h)^-s, k, 0, inf)

     Функцию загружает команда ‘load ("bffac")’.

 -- Функция: binomial (<x>, <y>)

     Биномиальный коэффициент ‘<x>!/(<y>! (<x> - <y>)!)’.

     Если <x> и <y> - целые, рассчитывается численное значение
     биномиального коэффициента.  Если <y> или <x - y> - целое,
     биномиальный коэффициент выражается через многочлен.

     Примеры:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)

 -- Функция: burn (<n>)

     Возвращает <n>-е число Бернулли для целого <n>.  ‘burn’ может быть
     более эффективным, чем ‘bern’ для отдельных больших <n> (возможно,
     если <n> больше 105 или в районе этого), так как ‘bern’
     рассчитывает все числа Бернулли до <n>-го перед выдачей результата.

     ‘burn’ использует выражение чисел Бернулли через дзэта-функцию
     Римана.

     Функцию загружает команда ‘load ("bffac")’.

 -- Функция: cf (<expr>)

     Преобразует <expr> в цепную дробь.  <expr> - выражение,
     составленное из цепных дробей и квадратных корней из целых чисел.
     Операнды выражения могут комбинироваться арифметическими
     операторами.  Помимо цепных дробей и квадратных корней, сомножители
     выражения должны быть целыми или рациональными числами.  Maxima не
     работает с операциями над цепными дробями вне ‘cf’.

     ‘cf’ вычисляет аргументы после установки ‘listarith’ равной
     ‘false’.  Цепная дробь ‘a + 1/(b + 1/(c + ...))’ представляется в
     виде списка ‘[a, b, c, ...]’.

     Элементы списка ‘a’, ‘b’, ‘c’, ...  должны раскрываться в целые
     числа.  <expr> может содержать ‘sqrt (n)’, где ‘n’ - целое.  В этом
     случае ‘cf’ даст число членов цепной дроби, равное произведению
     ‘cflength’ на период.  Цепная дробь может раскрываться в число
     через арифметическое представление, возвращенное ‘cfdisrep’.  См.
     также ‘cfexpand’ для другого способа вычисления цепной дроби.

     См.  также ‘cfdisrep’, ‘cfexpand’ и ‘cflength’.

     Примеры:

        • <expr> - выражение, составленное из цепных дробей и квадратных
          корней целых чисел.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        • ‘cflength’ определяет число периодов цепной дроби,
          рассчитываемых для алгебраических иррациональных чисел.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        • Цепная дробь может быть рассчитана через арифметическое
          представление, возвращаемое ‘cfdisrep’.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        • Maxima не работает с операциями над цепными дробями вне ‘cf’.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]

 -- Функция: cfdisrep (<list>)
     Возвращает простое выражение вида ‘a + 1/(b + 1/(c + ...))’ для
     списочного представления цепной дроби ‘[a, b, c, ...]’.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2

 -- Функция: cfexpand (<x>)
     Возвращает матрицу числителей и знаменателей последней (первый
     столбец) и предпоследней (второй столбец) подходящей дроби для
     цепной дроби <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902

 -- Управляющая переменная: cflength
     Значение по умолчанию: 1

     Функция ‘cf’ возвращает число членов цепной дроби, равное
     произведению ‘cflength’ на период.  Таким образом, по умолчанию
     возвращается один период.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

 -- Функция: divsum (<n>, <k>)
 -- Функция: divsum (<n>)

     ‘divsum (<n>, <k>)’ возвращает сумму делителей <n>, возведенных в
     степень <k>.

     ‘divsum (<n>)’ возвращает сумму делителей <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210

 -- Функция: euler (<n>)
     Возвращает <n>-е число Эйлера для неотрицательного целого <n>.  Для
     постоянной Эйлера-Маскерони см.  ‘%gamma’.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]

 -- Константа: %gamma
     Постоянная Эйлера-Маскерони, 0.5772156649015329 ....

 -- Функция: factorial (<x>)
     Представляет факториал <x>.  Maxima работает с ‘factorial (<x>)’
     аналогично ‘<x>!’.  См.  ‘!’.

 -- Функция: fib (<n>)

     Возвращает <n>-е число Фибоначчи.  ‘fib(0)’ равно 0, ‘fib(1)’ равно
     1, ‘fib (-<n>)’ равно ‘(-1)^(<n> + 1) * fib(<n>)’.

     После вызова ‘fib’ ‘prevfib’ равно ‘fib (<x> - 1)’, числу
     Фибоначчи, предшествующему последнему рассчитанному.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

 -- Функция: fibtophi (<expr>)

     Выражает числа Фибоначчи в <expr> через постоянную ‘%phi’, равную
     ‘(1 + sqrt(5))/2’, приблизительно 1.61803399.

     Примеры:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

 -- Функция: ifactors (<n>)

     Для целого положительного <n> возвращает факторизацию <n>.  Если
     ‘n=p1^e1..pk^nk’ есть разложение <n> на простые множители,
     ‘ifactors’ возвращает ‘[[p1, e1], ... , [pk, ek]]’.

     Используемые методы факторизации - обычное деление на простые числа
     (до 9973), ро-алгоритм Полларда и метод эллиптических кривых.

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600

 -- Функция: inrt (<x>, <n>)

     Возвращает целый <n>-й корень абсолютного значения <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]

 -- Функция: inv_mod (<n>, <m>)
     Рассчитывает число, обратное <n> по модулю <m>.  ‘inv_mod (n,m)’
     возвращает ‘false’, если <n> есть делитель нуля по модулю <m>.

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false

 -- Функция: jacobi (<p>, <q>)
     Символ Якоби для <p> и <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]

 -- Функция: lcm (<expr_1>, ..., <expr_n>)
     Возвращает наибольший общий делитель аргументов.  Аргументы могут
     быть как целыми числами, так и общими выражениями.

     Функцию загружает ‘load ("functs")’.

 -- Функция: minfactorial (<expr>)
     Проверяет <expr> на наличие двух факториалов, различающихся на
     целое число.  После этого ‘minfactorial’ заменяет выражение
     произведением многочленов.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)

 -- Функция: next_prime (<n>)
     Возвращает наименьшее простое число, большее <n>.

          (%i1) next_prime(27);
          (%o1)                       29

 -- Функция: partfrac (<expr>, <var>)
     Разлагает выражение <expr> на простые дроби относительно главной
     переменной <var>.  ‘partfrac’ делает полное разложение на простые
     дроби.  Используемый алгоритм основан на том, что знаменатели в
     разложении на простые дроби (сомножители исходного знаменателя)
     взаимно просты.  Числители могут быть записаны как линейные
     комбинации знаменателей, откуда вытекает разложение.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- Функция: power_mod (<a>, <n>, <m>)
     Использует модулярный алгоритм вычисления ‘a^n mod m’, где <a> и
     <n> - целые и <m> - положительное целое.  Если <n> отрицательно,
     для поиска обратного по модулю <m> числа используется ‘inv_mod’.

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          (%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3

 -- Функция: primep (<n>)
     Проверка на простоту.  Если ‘primep (<n>)’ возвращает ‘false’, то
     <n> является составным числом; если возвращает ‘true’, то <n> с
     большой вероятностью является простым числом.

     Для <n> меньше 341550071728321 используется детерминированная
     версия теста Миллера-Рабина.  Если ‘primep (<n>)’ возвращает
     ‘true’, то <n> есть простое число.

     Для <n> больше 34155071728321 ‘primep’ использует
     ‘primep_number_of_tests’ тестов Миллера-Рабина на псевдопростоту и
     один тест Люкаса на псевдопростоту.  Вероятность того, что <n>
     пройдет один тест Миллера-Рабина, менее 1/4.  Для значения по
     умолчанию 25 переменной ‘primep_number_of_tests’ вероятность того,
     что <n> будет составным, много меньше 10^-15.

 -- Управляющая переменная: primep_number_of_tests
     Значение по умолчанию: 25

     Число тестов Миллера-Рабина, используемых в ‘primep’.

 -- Функция: prev_prime (<n>)
     Возвращает наибольшее простое число, меньшее <n>.

          (%i1) prev_prime(27);
          (%o1)                       23

 -- Функция: qunit (<n>)
     Возвращает элемент поля ‘sqrt (<n>)’ с единичной нормой, что
     равносильно решению уравнения Пелля ‘a^2 - <n> b^2 = 1’.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1

 -- Функция: totient (<n>)
     Возвращает число целых чисел, меньших или равных <n>, которые
     взаимно просты с <n>.

 -- Управляющая переменная: zerobern
     Значение по умолчанию: ‘true’

     Если ‘zerobern’ равно ‘false’, ‘bern’ исключает числа Бернулли,
     равные нулю.  См.  ‘bern’.

 -- Функция: zeta (<n>)
     Возвращает дзэта-функцию Римана, если <n> - отрицательное целое, 0,
     1, или положительное четное число, и возвращает невычисляемую форму
     ‘zeta (<n>)’ для всех других аргументов, включая не целые
     рациональные, числа с плавающей точкой и комплексные.

     См.  также ‘bfzeta’ и ‘zeta%pi’.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90

 -- Управляющая переменная: zeta%pi
     Значение по умолчанию: ‘true’

     Значение по умолчанию: ‘true’

     Если ‘zeta%pi’ равно ‘true’, ‘zeta’ возвращает выражение,
     пропорциональное ‘%pi^n’ для целого четного ‘n’.  В противном
     случае для целого четного ‘n’ возвращается невычисляемая форма
     ‘zeta (n)’.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)


File: maxima.info,  Node: Symmetries,  Next: Groups,  Prev: Теория чисел,  Up: Top

30 Symmetries
*************

* Menu:

* Introduction to Symmetries::
* Functions and Variables for Symmetries::


File: maxima.info,  Node: Introduction to Symmetries,  Next: Functions and Variables for Symmetries,  Prev: Symmetries,  Up: Symmetries

30.1 Introduction to Symmetries
===============================

‘sym’ is a package for working with symmetric groups of polynomials.

   It was written for Macsyma-Symbolics by Annick Valibouze
(<http://www-calfor.lip6.fr/~avb/>).  The algorithms are described in
the following papers:

  1. Fonctions symétriques et changements de bases.  Annick Valibouze.
     EUROCAL’87 (Leipzig, 1987), 323–332, Lecture Notes in Comput.  Sci
     378.  Springer, Berlin, 1989.
     <http://www.stix.polytechnique.fr/publications/1984-1994.html>

  2. Résolvantes et fonctions symétriques.  Annick Valibouze.
     Proceedings of the ACM-SIGSAM 1989 International Symposium on
     Symbolic and Algebraic Computation, ISSAC’89 (Portland, Oregon).
     ACM Press, 390-399, 1989.
     <http://www-calfor.lip6.fr/~avb/DonneesTelechargeables/MesArticles/issac89ACMValibouze.pdf>

  3. Symbolic computation with symmetric polynomials, an extension to
     Macsyma.  Annick Valibouze.  Computers and Mathematics (MIT, USA,
     June 13-17, 1989), Springer-Verlag, New York Berlin, 308-320, 1989.
     <http://www.stix.polytechnique.fr/publications/1984-1994.html>

  4. Théorie de Galois Constructive.  Annick Valibouze.  Mémoire
     d’habilitation à diriger les recherches (HDR), Université P. et M.
     Curie (Paris VI), 1994.


File: maxima.info,  Node: Functions and Variables for Symmetries,  Prev: Introduction to Symmetries,  Up: Symmetries

30.2 Functions and Variables for Symmetries
===========================================

30.2.1 Changing bases
---------------------

 -- Function: comp2pui (<n>, <L>)
     implements passing from the complete symmetric functions given in
     the list <L> to the elementary symmetric functions from 0 to <n>.
     If the list <L> contains fewer than <n+1> elements, it will be
     completed with formal values of the type <h1>, <h2>, etc.  If the
     first element of the list <L> exists, it specifies the size of the
     alphabet, otherwise the size is set to <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]

 -- Function: ele2pui (<m>, <L>)
     goes from the elementary symmetric functions to the complete
     functions.  Similar to ‘comp2ele’ and ‘comp2pui’.

     Other functions for changing bases: ‘comp2ele’.

 -- Function: ele2comp (<m>, <L>)
     Goes from the elementary symmetric functions to the compete
     functions.  Similar to ‘comp2ele’ and ‘comp2pui’.

     Other functions for changing bases: ‘comp2ele’.

 -- Function: elem (<ele>, <sym>, <lvar>)
     decomposes the symmetric polynomial <sym>, in the variables
     contained in the list <lvar>, in terms of the elementary symmetric
     functions given in the list <ele>.  If the first element of <ele>
     is given, it will be the size of the alphabet, otherwise the size
     will be the degree of the polynomial <sym>.  If values are missing
     in the list <ele>, formal values of the type <e1>, <e2>, etc.  will
     be added.  The polynomial <sym> may be given in three different
     forms: contracted (‘elem’ should then be 1, its default value),
     partitioned (‘elem’ should be 3), or extended (i.e.  the entire
     polynomial, and ‘elem’ should then be 2).  The function ‘pui’ is
     used in the same way.

     On an alphabet of size 3 with <e1>, the first elementary symmetric
     function, with value 7, the symmetric polynomial in 3 variables
     whose contracted form (which here depends on only two of its
     variables) is <x^4-2*x*y> decomposes as follows in elementary
     symmetric functions:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Other functions for changing bases: ‘comp2ele’.

 -- Function: mon2schur (<L>)
     The list <L> represents the Schur function S_L: we have L = [i_1,
     i_2, ..., i_q], with i_1 <= i_2 <= ... <= i_q.  The Schur function
     S_[i_1, i_2, ..., i_q] is the minor of the infinite matrix h_[i-j],
     i <= 1, j <= 1, consisting of the q first rows and the columns 1 +
     i_1, 2 + i_2, ..., q + i_q.

     This Schur function can be written in terms of monomials by using
     ‘treinat’ and ‘kostka’.  The form returned is a symmetric
     polynomial in a contracted representation in the variables
     x_1,x_2,...

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     which means that for 3 variables this gives:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2
     Other functions for changing bases: ‘comp2ele’.

 -- Function: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     decomposes a multi-symmetric polynomial in the multi-contracted
     form <multi_pc> in the groups of variables contained in the list of
     lists <l_var> in terms of the elementary symmetric functions
     contained in <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3,
                [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Other functions for changing bases: ‘comp2ele’.

 -- Function: multi_pui
     is to the function ‘pui’ what the function ‘multi_elem’ is to the
     function ‘elem’.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3,
                [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2

 -- Function: pui (<L>, <sym>, <lvar>)
     decomposes the symmetric polynomial <sym>, in the variables in the
     list <lvar>, in terms of the power functions in the list <L>.  If
     the first element of <L> is given, it will be the size of the
     alphabet, otherwise the size will be the degree of the polynomial
     <sym>.  If values are missing in the list <L>, formal values of the
     type <p1>, <p2> , etc.  will be added.  The polynomial <sym> may be
     given in three different forms: contracted (‘elem’ should then be
     1, its default value), partitioned (‘elem’ should be 3), or
     extended (i.e.  the entire polynomial, and ‘elem’ should then be
     2).  The function ‘pui’ is used in the same way.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6
     Other functions for changing bases: ‘comp2ele’.

 -- Function: pui2comp (<n>, <lpui>)
     renders the list of the first <n> complete functions (with the
     length first) in terms of the power functions given in the list
     <lpui>.  If the list <lpui> is empty, the cardinal is <n>,
     otherwise it is its first element (as in ‘comp2ele’ and
     ‘comp2pui’).

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6
     Other functions for changing bases: ‘comp2ele’.

 -- Function: pui2ele (<n>, <lpui>)
     effects the passage from power functions to the elementary
     symmetric functions.  If the flag ‘pui2ele’ is ‘girard’, it will
     return the list of elementary symmetric functions from 1 to <n>,
     and if the flag is ‘close’, it will return the <n>-th elementary
     symmetric function.

     Other functions for changing bases: ‘comp2ele’.

 -- Function: puireduc (<n>, <lpui>)
     <lpui> is a list whose first element is an integer <m>.  ‘puireduc’
     gives the first <n> power functions in terms of the first <m>.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2

 -- Function: schur2comp (<P>, <l_var>)
     <P> is a polynomial in the variables of the list <l_var>.  Each of
     these variables represents a complete symmetric function.  In
     <l_var> the <i>-th complete symmetric function is represented by
     the concatenation of the letter ‘h’ and the integer <i>: ‘h<i>’.
     This function expresses <P> in terms of Schur functions.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3

30.2.2 Changing representations
-------------------------------

 -- Function: cont2part (<pc>, <lvar>)
     returns the partitioned polynomial associated to the contracted
     form <pc> whose variables are in <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

 -- Function: contract (<psym>, <lvar>)
     returns a contracted form (i.e.  a monomial orbit under the action
     of the symmetric group) of the polynomial <psym> in the variables
     contained in the list <lvar>.  The function ‘explose’ performs the
     inverse operation.  The function ‘tcontract’ tests the symmetry of
     the polynomial.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

 -- Function: explose (<pc>, <lvar>)
     returns the symmetric polynomial associated with the contracted
     form <pc>.  The list <lvar> contains the variables.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

 -- Function: part2cont (<ppart>, <lvar>)
     goes from the partitioned form to the contracted form of a
     symmetric polynomial.  The contracted form is rendered with the
     variables in <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

 -- Function: partpol (<psym>, <lvar>)
     <psym> is a symmetric polynomial in the variables of the list
     <lvar>.  This function returns its partitioned representation.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]

 -- Function: tcontract (<pol>, <lvar>)
     tests if the polynomial <pol> is symmetric in the variables of the
     list <lvar>.  If so, it returns a contracted representation like
     the function ‘contract’.

 -- Function: tpartpol (<pol>, <lvar>)
     tests if the polynomial <pol> is symmetric in the variables of the
     list <lvar>.  If so, it returns its partitioned representation like
     the function ‘partpol’.

30.2.3 Groups and orbits
------------------------

 -- Function: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     calculates the direct image (see M. Giusti, D. Lazard et A.
     Valibouze, ISSAC 1988, Rome) associated to the function <f>, in the
     lists of variables <lvar_1>, ..., <lvar_n>, and in the polynomials
     <p_1>, ..., <p_n> in a variable <y>.  The arity of the function <f>
     is important for the calculation.  Thus, if the expression for <f>
     does not depend on some variable, it is useless to include this
     variable, and not including it will also considerably reduce the
     amount of computation.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Finding the polynomial whose roots are the sums a+u where a is a
     root of z^2 - e_1 z + e_2 and u is a root of z^2 - f_1 z + f_2.

          (%i1) ratsimp (direct ([z^2 - e1* z + e2, z^2 - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     ‘direct’ accepts two flags: ‘elementaires’ and ‘puissances’
     (default) which allow decomposing the symmetric polynomials
     appearing in the calculation into elementary symmetric functions,
     or power functions, respectively.

     Functions of ‘sym’ used in this function:

     ‘multi_orbit’ (so ‘orbit’), ‘pui_direct’, ‘multi_elem’ (so ‘elem’),
     ‘multi_pui’ (so ‘pui’), ‘pui2ele’, ‘ele2pui’ (if the flag ‘direct’
     is in ‘puissances’).

 -- Function: multi_orbit (<P>, [<lvar_1>, <lvar_2>,..., <lvar_p>])

     <P> is a polynomial in the set of variables contained in the lists
     <lvar_1>, <lvar_2>, ..., <lvar_p>.  This function returns the orbit
     of the polynomial <P> under the action of the product of the
     symmetric groups of the sets of variables represented in these <p>
     lists.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]
     Also see: ‘orbit’ for the action of a single symmetric group.

 -- Function: multsym (<ppart_1>, <ppart_2>, <n>)
     returns the product of the two symmetric polynomials in <n>
     variables by working only modulo the action of the symmetric group
     of order <n>.  The polynomials are in their partitioned form.

     Given the 2 symmetric polynomials in <x>, <y>: ‘3*(x + y) + 2*x*y’
     and ‘5*(x^2 + y^2)’ whose partitioned forms are ‘[[3, 1], [2, 1,
     1]]’ and ‘[[5, 2]]’, their product will be

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]
     that is ‘10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)’.

     Functions for changing the representations of a symmetric
     polynomial:

     ‘contract’, ‘cont2part’, ‘explose’, ‘part2cont’, ‘partpol’,
     ‘tcontract’, ‘tpartpol’.

 -- Function: orbit (<P>, <lvar>)
     computes the orbit of the polynomial <P> in the variables in the
     list <lvar> under the action of the symmetric group of the set of
     variables in the list <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]
     See also ‘multi_orbit’ for the action of a product of symmetric
     groups on a polynomial.

 -- Function: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])

     Let <f> be a polynomial in <n> blocks of variables <lvar_1>, ...,
     <lvar_n>.  Let <c_i> be the number of variables in <lvar_i>, and
     <SC> be the product of <n> symmetric groups of degree <c_1>, ...,
     <c_n>.  This group acts naturally on <f>.  The list <orbite> is the
     orbit, denoted ‘<SC>(<f>)’, of the function <f> under the action of
     <SC>.  (This list may be obtained by the function ‘multi_orbit’.)
     The <di> are integers s.t.  c_1 <= d_1, c_2 <= d_2, ..., c_n <=
     d_n.

     Let <SD> be the product of the symmetric groups S_[d_1] x S_[d_2] x
     ... x S_[d_n].  The function ‘pui_direct’ returns the first <n>
     power functions of ‘<SD>(<f>)’ deduced from the power functions of
     ‘<SC>(<f>)’, where <n> is the size of ‘<SD>(<f>)’.

     The result is in multi-contracted form w.r.t.  <SD>, i.e.  only one
     element is kept per orbit, under the action of <SD>.

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a],
                [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]

30.2.4 Partitions
-----------------

 -- Function: kostka (<part_1>, <part_2>)
     written by P. Esperet, calculates the Kostka number of the
     partition <part_1> and <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6

 -- Function: lgtreillis (<n>, <m>)
     returns the list of partitions of weight <n> and length <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]
     Also see: ‘ltreillis’, ‘treillis’ and ‘treinat’.

 -- Function: ltreillis (<n>, <m>)
     returns the list of partitions of weight <n> and length less than
     or equal to <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]
     Also see: ‘lgtreillis’, ‘treillis’ and ‘treinat’.

 -- Function: treillis (<n>)
     returns all partitions of weight <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     See also: ‘lgtreillis’, ‘ltreillis’ and ‘treinat’.

 -- Function: treinat (<part>)
     returns the list of partitions inferior to the partition <part>
     w.r.t.  the natural order.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     See also: ‘lgtreillis’, ‘ltreillis’ and ‘treillis’.

30.2.5 Polynomials and their roots
----------------------------------

 -- Function: ele2polynome (<L>, <z>)
     returns the polynomial in <z> s.t.  the elementary symmetric
     functions of its roots are in the list ‘<L> = [<n>, <e_1>, ...,
     <e_n>]’, where <n> is the degree of the polynomial and <e_i> the
     <i>-th elementary symmetric function.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22
     The inverse: ‘polynome2ele (<P>, <z>)’.

     Also see: ‘polynome2ele’, ‘pui2polynome’.

 -- Function: polynome2ele (<P>, <x>)
     gives the list ‘<l> = [<n>, <e_1>, ..., <e_n>]’ where <n> is the
     degree of the polynomial <P> in the variable <x> and <e_i> is the
     <i>-the elementary symmetric function of the roots of <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22
     The inverse: ‘ele2polynome (<l>, <x>)’

 -- Function: prodrac (<L>, <k>)
     <L> is a list containing the elementary symmetric functions on a
     set <A>.  ‘prodrac’ returns the polynomial whose roots are the <k>
     by <k> products of the elements of <A>.

     Also see ‘somrac’.

 -- Function: pui2polynome (<x>, <lpui>)
     calculates the polynomial in <x> whose power functions of the roots
     are given in the list <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1
     See also: ‘polynome2ele’, ‘ele2polynome’.

 -- Function: somrac (<L>, <k>)
     The list <L> contains elementary symmetric functions of a
     polynomial <P> .  The function computes the polynomial whose roots
     are the <k> by <k> distinct sums of the roots of <P>.

     Also see ‘prodrac’.

30.2.6 Resolvents
-----------------

 -- Function: resolvante (<P>, <x>, <f>, [<x_1>,..., <x_d>])
     calculates the resolvent of the polynomial <P> in <x> of degree ‘n
     >= d’ by the function <f> expressed in the variables <x_1>, ...,
     <x_d>.  For efficiency of computation it is important to not
     include in the list ‘[<x_1>, ..., <x_d>]’ variables which do not
     appear in the transformation function <f>.

     To increase the efficiency of the computation one may set flags in
     ‘resolvante’ so as to use appropriate algorithms:

     If the function <f> is unitary:
        • A polynomial in a single variable,
        • linear,
        • alternating,
        • a sum,
        • symmetric,
        • a product,
        • the function of the Cayley resolvent (usable up to degree 5)

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          general,
     the flag of ‘resolvante’ may be, respectively:
        • unitaire,
        • lineaire,
        • alternee,
        • somme,
        • produit,
        • cayley,
        • generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1,
                [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840,
                                   - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvante de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     For the Cayley resolvent, the 2 last arguments are neutral and the
     input polynomial must necessarily be of degree 5.

     See also:
     ‘resolvante_bipartite’, ‘resolvante_produit_sym’,
     ‘resolvante_unitaire’, ‘resolvante_alternee1’, ‘resolvante_klein’,
     ‘resolvante_klein3’, ‘resolvante_vierer’, ‘resolvante_diedrale’.

 -- Function: resolvante_alternee1 (<P>, <x>)
     calculates the transformation ‘<P>(<x>)’ of degree <n> by the
     function product(x_i - x_j, 1 <= i < j <= n - 1).

     See also:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’, ‘resolvante_bipartite’.

 -- Function: resolvante_bipartite (<P>, <x>)
     calculates the transformation of ‘<P>(<x>)’ of even degree <n> by
     the function x_1 x_2 ... x_[n/2] + x_[n/2 + 1] ... x_n.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     See also:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’, ‘resolvante_alternee1’.

 -- Function: resolvante_diedrale (<P>, <x>)
     calculates the transformation of ‘<P>(<x>)’ by the function ‘<x_1>
     <x_2> + <x_3> <x_4>’.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     See also:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante’.

 -- Function: resolvante_klein (<P>, <x>)
     calculates the transformation of ‘<P>(<x>)’ by the function ‘<x_1>
     <x_2> <x_4> + <x_4>’.

     See also:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’.

 -- Function: resolvante_klein3 (<P>, <x>)
     calculates the transformation of ‘<P>(<x>)’ by the function ‘<x_1>
     <x_2> <x_4> + <x_4>’.

     See also:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’.

 -- Function: resolvante_produit_sym (<P>, <x>)
     calculates the list of all product resolvents of the polynomial
     ‘<P>(<x>)’.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvante produit "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     See also:
     ‘resolvante’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’,
     ‘resolvante_klein3’, ‘resolvante_vierer’,
     ‘resolvante_diedrale’.

 -- Function: resolvante_unitaire (<P>, <Q>, <x>)
     computes the resolvent of the polynomial ‘<P>(<x>)’ by the
     polynomial ‘<Q>(<x>)’.

     See also:
     ‘resolvante_produit_sym’, ‘resolvante’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’.

 -- Function: resolvante_vierer (<P>, <x>)
     computes the transformation of ‘<P>(<x>)’ by the function ‘<x_1>
     <x_2> - <x_3> <x_4>’.

     See also:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante’, ‘resolvante_diedrale’.

30.2.7 Miscellaneous
--------------------

 -- Function: multinomial (<r>, <part>)
     where <r> is the weight of the partition <part>.  This function
     returns the associate multinomial coefficient: if the parts of
     <part> are <i_1>, <i_2>, ..., <i_k>, the result is ‘<r>!/(<i_1>!
     <i_2>! ... <i_k>!)’.

 -- Function: permut (<L>)
     returns the list of permutations of the list <L>.


File: maxima.info,  Node: Groups,  Next: Окружение времени выполнения,  Prev: Symmetries,  Up: Top

31 Groups
*********

* Menu:

* Functions and Variables for Groups::


File: maxima.info,  Node: Functions and Variables for Groups,  Prev: Groups,  Up: Groups

31.1 Functions and Variables for Groups
=======================================

 -- Function: todd_coxeter
          todd_coxeter (<relations>, <subgroup>)
          todd_coxeter (<relations>)

     Find the order of G/H where G is the Free Group modulo <relations>,
     and H is the subgroup of G generated by <subgroup>.  <subgroup> is
     an optional argument, defaulting to [].  In doing this it produces
     a multiplication table for the right action of G on G/H, where the
     cosets are enumerated [H,Hg2,Hg3,...].  This can be seen internally
     in the variable ‘todd_coxeter_state’.

     Example:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20


File: maxima.info,  Node: Окружение времени выполнения,  Next: Вспомогательные опции,  Prev: Groups,  Up: Top

32 Окружение времени выполнения
*******************************

* Menu:

* Введение в окружение времени выполнения::  
* Прерывания::                  
* Функции и переменные времени выполнения::  


File: maxima.info,  Node: Введение в окружение времени выполнения,  Next: Прерывания,  Prev: Окружение времени выполнения,  Up: Окружение времени выполнения

32.1 Введение в окружение времени выполнения
============================================

Файл ‘maxima-init.mac’ загружается автоматически при каждом запуске
Maxima.  Можно использовать ‘maxima-init.mac’ для настройки своего
персонального Maxima окружения.  Файл ‘maxima-init.mac’ обычно
размещается в директории, определяемой переменной ‘maxima_userdir’, хотя
может находиться и в любой другой директории, просматриваемой функцией
‘file_search’.

   Пример содержимого файла ‘maxima-init.mac’:

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   Здесь, ‘setup_autoload’ заставляет Maxima загружать файл
‘specfun.mac’, если функции ‘ultraspherical’ или ‘assoc_legendre_p’
вызываются, но не определены в момент вызова.  При этом нет нужды
помнить о необходимости загружать соответствующий файл до вызова данных
функций.

   Команда ‘showtime: all’ устанавливает значение переменной ‘showtime’.
Файл ‘maxima-init.mac’ может содержать любые присваивания и другие
команды Maxima.


File: maxima.info,  Node: Прерывания,  Next: Функции и переменные времени выполнения,  Prev: Введение в окружение времени выполнения,  Up: Окружение времени выполнения

32.2 Прерывания
===============

Пользователь может остановить длительное вычисление, нажав на ^C
(Control-C). По умолчанию, текущее вычисление прекращается и выводится
новое приглашение.  Невозможно возобновить прерванные вычисления.

   Если Lisp переменная ‘*debugger-hook*’ установлена равной ‘nil’ при
помощи

     :lisp (setq *debugger-hook* nil)

то после получения ^C, Maxima запускает Lisp отладчик, и пользователь
может исследовать Lisp окружение.  Остановленное вычисление может быть
продолжено вводом команды ‘continue’ в Lisp отладчике .  Способы
возврата в Maxima из Lisp отладчика, другие кроме продолжение вычисления
до его завершения, различны для разных версий Lisp.

   В системах типа Unix нажатие ^Z (Сontrol-Z) вызывает полную
приостановку работы Maxima с возвращением управления в командную строку.
Команда ‘fg’ вызывает возобновление работы остановленной Maxima с точки,
на которой она была остановлена.


File: maxima.info,  Node: Функции и переменные времени выполнения,  Prev: Прерывания,  Up: Окружение времени выполнения

32.3 Функции и переменные времени выполнения
============================================

 -- Декларация: feature
     Maxima понимает два различных типа свойств: системные свойства и
     свойства, относящиеся к математическим выражениям.  См.  ‘status’
     по поводу системных свойств.  См.  ‘features’ и ‘featurep’ по
     поводу математических свойств.

     ‘feature’ само по себе не является именем функции или переменной.

 -- Функция: featurep (<a>, <f>)
     Пытается определить имеет ли объект <a> свойство <f>, используя
     факты, находящиеся в текущей базе данных.  Если да, то возвращается
     ‘true’, иначе возвращается ‘false’.

     Отметим, что ‘featurep’ возвращает ‘false’ если даже ни <f>, ни
     отрицание <f> не могут быть установлены.

     Функция ‘featurep’ вычисляет свои аргументы.

     См.  также ‘declare’ и ‘features’.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- Системная переменная: maxima_tempdir

     Переменная ‘maxima_tempdir’ обозначает директорию, в которой Maxima
     создает некоторые временные файлы.  Например, временные файлы с
     данными для графиков создаются в ‘maxima_tempdir’.

     Начальное значение ‘maxima_tempdir’ является домашней директорией
     пользователя, если Maxima может ее определить.  В противном случае
     Maxima делает догадку о расположении подходящей директории.

     Переменной ‘maxima_tempdir’ можно присвоить строку с именем
     директории.

 -- Системная переменная: maxima_userdir

     Переменная ‘maxima_userdir’ обозначает директорию, в которой Maxima
     ищет Maxima и Lisp файлы.  (Maxima ищет файлы и в некоторых других
     директориях.  Полный список определяется переменными
     ‘file_search_maxima’ и ‘file_search_lisp’.)

     Начальное значение ‘maxima_userdir’ является поддиректорией
     домашней директории пользователя, если Maxima может определить
     последнюю.  В противном случае Maxima делает догадку о расположении
     подходящей директории.

     Переменной ‘maxima_userdir’ можно присвоить строку с именем
     директории.  Однако, присваивание нового значения ‘maxima_userdir’
     не меняет автоматически ‘file_search_maxima’ и ‘file_search_lisp’.
     Значение этих переменных нужно менять отдельно.

 -- Функция: room ()
 -- Функция: room (true)
 -- Функция: room (false)
     Выводит информацию о состоянии использования памяти и стека в
     Maxima.  Команда ‘room’ вызывает одноименную Lisp функцию.

        • ‘room ()’ выводит описание среднего уровня детализации.
        • ‘room (true)’ выводит подробное описание.
        • ‘room (false)’ выводит краткое описание.

 -- Функция: status (feature)
 -- Функция: status (feature, <putative_feature>)
 -- Функция: status (status)
     Возвращает информацию о наличии или отсутствии определенных
     системно-зависимых свойств.

        • ‘status (feature)’ возвращает список системных свойств.  Что
          включает версию Lisp, тип операционной системы и т.д.  Этот
          список может варьироваться от одной версии Lisp к другой.
        • ‘status (feature, <putative_feature>)’ возвращает ‘true’, если
          <putative_feature> присутствует в списке, возвращаемом ‘status
          (feature)’, и ‘false’ в противном случае.  Функция ‘status’ не
          вычисляет свои аргументы <putative_feature>.  Оператор
          кавычка-кавычка ‘''’ может быть использован для их вычисления.
          Свойства, содержащие в именах специальные символы, такие как
          тире, могут задаваться в форме строки.  Например,‘status
          (feature, "ansi-cl")’.
        • ‘status (status)’ возвращает двухэлементный список ‘[feature,
          status]’.  ‘feature’ и ‘status’ являются двумя аргументами,
          принимаемыми функцией ‘status’.  Не ясно, имеет ли этот список
          какое-либо иное значение.

     Переменная ‘features’ содержит список свойств, применимых к
     математическим выражениям.  См.  ‘features’ и ‘featurep’ по поводу
     дополнительной информации.

 -- Функция: time (%o1, %o2, %o3, ...)
     Возвращает список времен, в секундах, вычисления результирующих
     выражений ‘%o1’, ‘%o2’, ‘%o3’, ...  .  Время является внутренним
     временем вычисления Maxima, а не временем, прошедшим по реальным
     часам.  Функция ‘time’ применима только к меткам результирующих
     выражений, для других переменных ‘time’ возвращает ‘unknown’.

     Установка ‘showtime: true’ заставляет Maxima печатать внутренее
     время вычисления и время по реальным часам для каждого результата.

 -- Функция: timedate ()
     Возвращает строку, содержащую текущее время и дату.  Строка имеет
     формат ‘HH:MM:SS Day, mm/dd/yyyy (GMT-n)’, где поля есть часы,
     минуты, секунды, день недели, месяц, день месяца, год и сдвиг
     часового пояса от GMT (Стандартное время по Гринвичу).

     Пример:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate reports current time", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)

 -- Функция: absolute_real_time ()

     Возвращает число секунд, истекших с полуночи 1 января 1900 года по
     Универсальному Координированному Времени (UTC). Значение является
     целым числом.

     См.  также ‘elapsed_real_time’ и ‘elapsed_run_time’.

     Пример:

          (%i1) absolute_real_time ();
          (%o1)                      3385045277
          (%i2) 1900 + absolute_real_time () / (365.25 * 24 * 3600);
          (%o2)                   2007.265612087104

 -- Функция: elapsed_real_time ()

     Возвращает число секунд (включая доли секунды), истекших с
     последнего запуска или перезапуска Maxima по реальным часам.
     Значение является числом с плавающей точкой.

     См.  также ‘absolute_real_time’ и ‘elapsed_run_time’.

     Пример:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087

 -- Функция: elapsed_run_time ()

     Возвращает число секунд (включая доли секунды), истекших с
     последнего запуска или перезапуска Maxima по внутренним часам
     Maxima.  Значение является числом с плавающей точкой.

     См.  также ‘absolute_real_time’ и ‘elapsed_real_time’.

     Пример:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26


File: maxima.info,  Node: Вспомогательные опции,  Next: Правила преобразования и шаблоны,  Prev: Окружение времени выполнения,  Up: Top

33 Вспомогательные опции
************************

* Menu:

* Введение в вспомогательные опции::  
* Библиотека Share::                       
* Вспомогательные функции и переменные::  


File: maxima.info,  Node: Введение в вспомогательные опции,  Next: Библиотека Share,  Prev: Вспомогательные опции,  Up: Вспомогательные опции

33.1 Введение в вспомогательные опции
=====================================

В этом разделе обсуждаются различные опции, имеющие глобальное влияние
на работу Maxima.  Также описываются различные системные списки, такие
как список всех определенных пользователем функций.


File: maxima.info,  Node: Библиотека Share,  Next: Вспомогательные функции и переменные,  Prev: Введение в вспомогательные опции,  Up: Вспомогательные опции

33.2 Библиотека Share
=====================

Maxima директория "share" содержит программы и другие полезные для
пользователей Maxima файлы, не входящие в ядро системы.  Обычно, эти
программы загружаются с помощью команд ‘load’ или ‘setup_autoload’.

   ‘:lisp *maxima-sharedir*’ указывает расположение директории "share" в
файловой системе.

   Команда ‘printfile ("share.usg")’ печатает устаревший список пакетов
share.  Возможно, более информативным будет просмотр этой директории при
помощи обычного файл-менеджера.


File: maxima.info,  Node: Вспомогательные функции и переменные,  Prev: Библиотека Share,  Up: Вспомогательные опции

33.3 Вспомогательные функции и переменные
=========================================

 -- Системная переменная: aliases
     Значение по умолчанию: ‘[]’

     ‘aliases’ – список всех атомов, котрые имеют определенные
     пользователем алиасы (определяются функциями ‘alias’, ‘ordergreat’,
     ‘orderless’ или при декларации атома ‘noun’ при помощи ‘declare’).

 -- Декларация: alphabetic
     ‘alphabetic’ является декларацией типа, распознаваемой функцией
     ‘declare’.  Декларация ‘declare(<s>, alphabetic)’ говорит Maxima
     рассматривать все символы, входящие в <s> (должен быть строкой),
     как буквенные.

     См.  также *note Идентификаторы::.

     Пример:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- Функция: apropos (<string>)
     Ищет имена объектов Maxima, содержащие <string> в качестве
     подстроки.  Например, вызов ‘apropos (exp)’ возвращает список всех
     переменных и функций, имеющих ‘exp’ в качестве части своего имени,
     такие как ‘expand’, ‘exp’ и ‘exponentialize’.  Таким образом, если
     вы помните только часть имени какого-либо объекта, то можете
     использовать эту команду для поиска полного наименования.
     Аналогично, можно использовать ‘apropos (tr_)’, для того, чтобы
     вывести список переключателей, влияющих на работу транслятора, т.к.
     имена большинства из них начинаются с ‘tr_’.

 -- Функция: args (<expr>)
     Возвращает список аргументов параметра ‘expr’, который может быть
     любым отличным от атома выражением.  Возвращаются только аргументы
     оператора самого верхнего уровня.  Подвыражения ‘expr’ появляются,
     как элементы подвыражений элементов списка аргументов.

     Порядок выражений в возвращаемом списке может зависеть от
     глобального флага ‘inflag’.

     Вызов ‘args (<expr>)’ эквивалентен ‘substpart ("[", <expr>, 0)’.
     См.  также ‘substpart’ и ‘op’.

 -- Управляющая переменная: genindex
     Значение по умолчанию: ‘i’

     ‘genindex’ – буквенный префикс, используемый для создания новой
     переменной суммирования.

 -- Управляющая переменная: gensumnum
     Значение по умолчанию: 0

     ‘gensumnum’ – числовой суффикс, используемый для создания новой
     переменной суммирования.  Если равна ‘false’, то индекс будет
     состоять только из ‘genindex’ без числового суффикса.

 -- Системная переменная: infolists
     Значение по умолчанию: ‘[]’

     ‘infolists’ – есть список имен всех информационных списков Maxima.
     А именно:

     ‘labels’
          Все имеющие значение ‘%i’, ‘%o’ и ‘%t’ метки.
     ‘values’
          Все имеющие значение атомы, определенные пользователем (не
          встроенные в Maxima управляющие переменные и переключатели),
          созданные при помощи операторов ‘:’, ‘::’ или функциональным
          присваиванием.
     ‘functions’
          Все определенные пользователем функции, созданные при помощи
          ‘:=’ или ‘define’.
     ‘arrays’
          Все объявленные и необъявленные массивы, созданные при помощи
          ‘:’, ‘::’ или ‘:=’.
     ‘macros’
          Все определенные пользователем макро-функции.
     ‘myoptions’
          Все управляющие переменные, значение которых было изменено
          пользователем, независимо от того, имеют ли они в данный
          момент значения по умолчанию или нет.
     ‘rules’
          Все определенные пользователем правила подстановок и правила
          упрощения, созданные при помощи ‘tellsimp’, ‘tellsimpafter’,
          ‘defmatch’ или ‘defrule’.
     ‘aliases’
          Все атомы, имеющие определенные пользователем алиасы,
          созданные при помощи функций ‘alias’, ‘ordergreat’,
          ‘orderless’ или при декларации атома ‘noun’ с помощью
          ‘declare’.
     ‘dependencies’
          Все атомы, имеющие функциональные зависимости, созданные с
          помощью функций ‘depends’ или ‘gradef’.
     ‘gradefs’
          Все функции, имеющие определенные пользователем производные,
          определенные при помощи функции ‘gradef’.
     ‘props’
          Все атомы, имеющие свойства, отличные от упомянутых выше,
          такие как свойства задаваемые ‘atvalue’, ‘matchdeclare’ и
          т.п., а также, свойства, установленные функцией ‘declare’.
     ‘let_rule_packages’
          Все определенные пользователем пакеты правил ‘let’ плюс
          специальный пакет ‘default_let_rule_package’.
          (‘default_let_rule_package’ – имя пакета правил, который
          используется по умолчанию, если иной не объявлен пользователем
          явно.)

 -- Функция: integerp (<expr>)
     Возвращает ‘true’, если <expr> является буквальным целым числом, и
     ‘false’ в противном случае.

     Функция ‘integerp’ возвращает ‘false’, если аргумент является
     символом, даже если этот символ объявлен целочисленным.

     Примеры:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false

 -- Управляющая переменная: m1pbranch
     Значение по умолчанию: ‘false’

     ‘m1pbranch’ определяет главную ветвь для отрицательной степени
     ‘-1’.  Величины, подобные ‘(-1)^(1/3)’ (т.е.  "нечетные"
     рациональные степени) и ‘(-1)^(1/4)’ (т.е.  "четные" рациональные
     степени) определяются следующим образом:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

 -- Функция: numberp (<expr>)
     Возвращает ‘true’, если <expr> есть буквальное целое число,
     рациональное число, число с плавающей точкой или число с плавающей
     точкой высокой точности, иначе возвращается ‘false’.

     Функция ‘numberp’ возвращает ‘false’, если параметр является
     символом, даже если он является символическим числом, таким как
     ‘%pi’ или ‘%i’, или объявлен ‘even’, ‘odd’, ‘integer’, ‘rational’,
     ‘irrational’, ‘real’, ‘imaginary’ или ‘complex’.

     Примеры:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]

 -- Функция: properties (<a>)
     Возвращает список имен всех свойств, ассоциированных с атомом <a>.

 -- Специальный символ: props
     ‘props’ – список атомов, имеющих свойства отличные от тех, что явно
     перечислены в ‘infolists’, такие как, свойства, задаваемые
     ‘atvalue’, ‘matchdeclare’ и т.п., а также свойства, задаваемые
     функцией ‘declare’.

 -- Функция: propvars (<prop>)
     Возвращает список атомов из списка ‘props’, которые имеют свойство,
     обозначаемое <prop>.  Т.е.  ‘propvars (atvalue)’ возвращает список
     атомов, имеющих свойство ‘atvalue’.

 -- Функция: put (<atom>, <value>, <indicator>)
     Присваивает атому <atom> значение свойства <indicator>, равное
     <value>.  <indicator> может быть не только системным свойством, но
     любым другим именем свойства.

     Функция ‘put’ вычисляет свои аргументы.  ‘put’ возвращает <value>.

     Примеры:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- Функция: qput (<atom>, <value>, <indicator>)
     Присваивает атому <atom> значение свойства <indicator>, равное
     <value>.  Аналогично ‘put’, но не вычисляет свои аргументы.

     Примеры:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- Функция: rem (<atom>, <indicator>)
     Удаляет свойство <indicator> у атома <atom>.

 -- Функция: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Функция: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Функция: remove ("<a>", operator)
 -- Функция: remove (<a>, transfun)
 -- Функция: remove (all, <p>)
     Удаляет свойства, ассоциированные с атомами.

     Вызов ‘remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)’ удаляет свойство
     ‘p_k’ у атома ‘a_k’.

     Вызов ‘remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)’
     удаляет свойства ‘<p_1>, ..., <p_n>’ у атомов <a_1>, ..., <a_m>.
     Может быть более чем одна пара списков.

     Вызов ‘remove (all, <p>)’ удаляет все свойства <p> у всех имеющих
     его атомов.

     Удаляемые свойства могут быть как системными, такими как
     ‘function’, ‘macro’ или ‘mode_declare’, так и пользовательскими.

     Удаление свойства ‘transfun’ удаляет транслированный Lisp вариант
     функции.  После удаления этого свойства, вместо транслированной
     Lisp версии функции будет выполняться Maxima версия.

     Вызов ‘remove ("<a>", operator)’ или, эквивалентно, ‘remove ("<a>",
     op)’, удаляет у <a> операторные свойства, декларированные функциями
     ‘prefix’, ‘infix’, ‘nary’, ‘postfix’, ‘matchfix’ или ‘nofix’.
     Отметим, что имя оператора должно быть записано в виде строки с
     двойными кавычками.

     ‘remove’ всегда возвращает ‘done’, независимо от того, имел ли атом
     требуемое свойство или нет.  Такое поведение отличается от более
     специфичных функций, удаляющих свойства, таких как ‘remvalue’,
     ‘remarray’, ‘remfunction’ и ‘remrule’.

 -- Функция: remvalue (<name_1>, ..., <name_n>)
 -- Функция: remvalue (all)
     Удаляет из системы значения пользовательских переменных <name_1>,
     ..., <name_n> (могут быть переменными с индексом).

     Вызов ‘remvalue (all)’ удаляет все значения всех переменных из
     списка определенных пользователем переменных ‘values’ (в отличии от
     переменных, автоматически определенных Maxima).

     См.  также ‘values’.

 -- Функция: rncombine (<expr>)
     Преобразует выражение <expr>, комбинируя слагаемые <expr>, имеющие
     одинаковые знаменатели или знаменатели отличающиеся только на
     числовой множитель.  Это поведение несколько отличается от
     поведения функции ‘combine’, которая собирает члены с идентичными
     знаменателями.

     Устанавливая ‘pfeformat: true’ и используя ‘combine’, можно
     получить результат более компактный, чем дает ‘rncombine’, но
     ‘rncombine’ выполняет дополнительный шаг, перемножая численные
     множители знаменателей.  Это приводит к более ясной форме и
     возможности распознать сокращения.

     Команда ‘load("rncomb")’ загружает эту функцию.

 -- Функция: scalarp (<expr>)
     Возвращает ‘true’ если <expr> является числом, константой или
     переменной, объявленной ‘scalar’ при помощи ‘declare’, или
     выражением, полностью состоящим из чисел, констант и скалярных
     переменных, но не содержащим матрицы или списки.

 -- Функция: setup_autoload (<filename>, <function_1>, ...,
          <function_n>)
     Определяет то, что если любая из функций <function_1>, ...,
     <function_n> вызывается, но еще не определена в момент вызова, то
     файл <filename> загружается при помощи ‘load’.  Файл <filename>
     обычно содержит определения указанных функций, хотя это и не
     обязательно.

     ‘setup_autoload’ не работает для функций-массивов.

     ‘setup_autoload’ не вычисляет свои аргументы.

     Примеры:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


File: maxima.info,  Node: Правила преобразования и шаблоны,  Next: Списки,  Prev: Вспомогательные опции,  Up: Top

34 Правила преобразования и шаблоны
***********************************

* Menu:

* Введение в правила преобразований и шаблоны::  
* Функции и переменные для правил преобразования и шаблонов::  


File: maxima.info,  Node: Введение в правила преобразований и шаблоны,  Next: Функции и переменные для правил преобразования и шаблонов,  Prev: Правила преобразования и шаблоны,  Up: Правила преобразования и шаблоны

34.1 Введение в правила преобразований и шаблоны
================================================

Данный раздел описывает особенности программирования правил
преобразований и шаблонов, применяемые в Maxima для упрощения выражений.
Имеется две группы функций, реализующих несколько различающиеся схемы
применения шаблонов преобразований.  К одной группе относятся функции
‘tellsimp’, ‘tellsimpafter’, ‘defmatch’, ‘defrule’,‘apply1’, ‘applyb1’ и
‘apply2’.  В другую группу входят функции ‘let’ и ‘letsimp’.  В обоих
группах шаблоны определяются через переменные шаблонов, объявляемые
функцией ‘matchdeclare’.

   Правила преобразований, определенные в процедурах ‘tellsimp’ и
‘tellsimpafter’, применяются Maxima автоматически (если управляющая
переменная ‘simp’ имеет значение ‘true’).  Правила преобразований,
определенные в процедурах ‘defmatch’, ‘defrule’ и ‘let’ применяются
только при явном вызове соответствующих функций.

   Имеются, также, дополнительные возможности использования правил
преобразований, например, при работе с полиномами в процедуре ‘tellrat’,
и для коммутативной и некоммутативной алгебры в пакете ‘affine’.


File: maxima.info,  Node: Функции и переменные для правил преобразования и шаблонов,  Prev: Введение в правила преобразований и шаблоны,  Up: Правила преобразования и шаблоны

34.2 Функции и переменные для правил преобразования и шаблонов
==============================================================

 -- Функция: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Осуществляет повторное применение правила преобразования <rule_1> к
     <expr> до тех пор пока выражение отвечает шаблону преобразования,
     затем, таким же образом осуществляется повторное применение этого
     правила ко всем подвыражениям <expr>, слева направо.  Далее, к
     полученному результату тем же способом применяется правило <rule_2>
     и так далее все последующие правила вплоть до <rule_n>.  Конечный
     результат возвращается.

     Переменная ‘maxapplydepth’ контролирует нижнюю глубину уровня
     подвыражения до которого применяются правила преобразований в
     функциях ‘apply1’ и ‘apply2’.

     См.  также <applyb1>, ‘apply2’ и ‘let’.

 -- Функция: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Если правило <rule_1> неприменимо на подвыражении <expr>, тогда
     применяется правило <rule_2> и далее по той же схеме остальные
     правила.  Только если каждое из правил является неприменимым на
     данном подвыражении <expr>, программа переходит на следующий
     уровень подвыражнния <expr>, и по той же схеме последовательно
     применяет весь набор правил, начиная с первого.  Если применение
     одного из правил оказывается успешным, тогда весь набор правил
     заново применяется к этому подвыражению.

     Переменная ‘maxapplydepth’ контролирует нижнюю глубину уровня
     подвыражения до которого применяются правила преобразований в
     функциях ‘apply1’ и ‘apply2’.

     См.  также ‘apply1’ и ‘let’.

 -- Функция: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     В отличие от ‘apply1’ применяется по восходящей, т.е., сначала на
     самом глубоком уровне <expr> повторяется применение правила
     <rule_1>.  Затем программа переходит на более высокие уровни <expr>
     и применяет данное правило по той же схеме.  После того как
     применение правила <rule_1> терпит неудачу на самом вернем уровне
     <expr> программа переходит к применению правила <rule_2> по той же
     схеме (по восходящей) и так далее, заканчивая применением правила
     <rule_n>.  После этого возвращается результат.

     Функция ‘applyb1’ аналогична ‘apply1’, но работает по восходящей.

     Переменная ‘maxapplyheight’ контролирует высоту уровня подвыражения
     до которого применяются правила преобразований в функции ‘applyb1’.

     См.  также ‘apply1’, ‘apply2’ и ‘let’.

 -- Управляющая переменная: current_let_rule_package
     Значение по умолчанию: ‘default_let_rule_package’

     ‘current_let_rule_package’ - имя пакета правил, которые, если не
     определен другой пакет правил, используются функциями из программы
     ‘let’ (такими как, ‘letsimp’, и т.д.)  Эта переменной может быть
     присвоено имя любого пакета правил преобразований, определенного
     при помощи функции ‘let’.

     При вызове ‘letsimp (expr, rule_pkg_name)’, пакет правил
     ‘rule_pkg_name’ используется только во время данного действия, при
     этом значение переменной ‘current_let_rule_package’ остается
     неизменным.

 -- Управляющая переменная: default_let_rule_package
     Значение по умолчанию: ‘default_let_rule_package’

     ‘default_let_rule_package’ - имя пакета правил, используемого по
     умолчанию, если пакет правил не был задан в явном виде при вызове
     ‘let’ или через изменение значения переменной
     ‘current_let_rule_package’.

 -- Функция: defmatch (<progname>, <pattern>, <x_1>, ..., <x_n>)
 -- Функция: defmatch (<progname>, <pattern>)
     Определяет функцию ‘<progname> (<expr>, <x_1>, ..., <x_n>)’,
     которая проверяет выражение <expr> на соответствие шаблону
     <pattern>.

     Шаблон <pattern> - выражение, содержащее аргументы шаблона <x_1>,
     ..., <x_n> (если есть) и переменные шаблона (если есть).  Аргументы
     шаблона задаются в явном виде, как аргументы функции ‘defmatch’, а
     переменные шаблона декларируются функцией ‘matchdeclare’.  Всякая
     переменная, не декларированная как переменная шаблона при помощи
     ‘mathdeclare’ или как аргумент шаблона при помощи ‘defmatch’
     соответствует только сама себе.

     Первым аргументом создаваемой функции <progname> является
     выражение, проверяемое на соответствие шаблону, а другие аргументы
     это актуальные параметры, соответствующие аргументам шаблона <x_1>,
     ..., <x_n>.

     Если проверка на соответствие шаблону оказывается успешной, то
     <progname> возвращает список уравнений, в которых левые части
     являются аргументами и переменными шаблона, а правые части -
     подвыражения <expr>, сопоставленные данным аргументам и переменным.
     Переменным шаблона, но не аргументам шаблона, присваиваются
     соответствующие значения.  В случае неудачи сопоставления
     <progname> возвращает ‘false’.

     Любая переменная, не объявленная в параметрах шаблона в
     ‘matchdeclare’ или в переменных шаблона в ‘defmatch’,
     сопоставляется только самой себе.

     Программа для буквального шаблона, т.е.  шаблона не содержащего ни
     аргументов ни переменных, в случае удачи сопоставления возвращает
     ‘true’.

     См.  также ‘matchdeclare’, ‘defrule’, ‘tellsimp’ и ‘tellsimpafter’.

     Примеры:

     Определим функцию ‘linearp (expr, x)’, которая проверяет может ли
     ‘expr’ быть представлено ввиде ‘a*x + b’, где ‘a’ и ‘b’ не содержат
     ‘x’ и ‘a’ отлично от нуля.  Эта функция сопоставима с выражениями
     линейными по любой переменной, поскольку аргумент шаблона ‘x’
     определен в ‘defmatch’.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Определим функцию ‘linearp(expr)’, которая проверяет может ли
     ‘expr’ быть представлено ввиде ‘a*x + b’, где ‘a’ и ‘b’ не содержат
     ‘x’ и ‘a’ отлично от нуля.  Эта функция сопоставима с выражениями
     линейными только по ‘x’, поскольку в ‘defmatch’ не заданы никакие
     аргументы шаблона.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Определим функцию ‘checklimits(expr)’, которая проверяет,
     определяет ли ‘expr’ интеграл.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]

 -- Функция: defrule (<rulename>, <pattern>, <replacement>)
     Определяет и именует правило преобразования для данного шаблона.
     Если правило c именем <rulename> применяется к выражению (путем
     ‘apply1’, ‘applyb1’ или ‘apply2’), то каждое подвыражение,
     удовлетворяющее шаблону, заменяется соответствующей подстановкой.
     После этого выражение упрощается.

     Правила могут рассматриваться как функции, преобразующие выражение
     путем одной операции сопоставления с шаблоном и подстановки.  При
     неудаче сопоставления, функция правила преобразования возвращает
     ‘false’.

 -- Функция: disprule (<rulename_1>, ..., <rulename_2>)
 -- Функция: disprule (all)
     Выводит правила преобразований и их имена <rulename_1>, ...,
     <rulename_n>, определенные в ‘defrule’, ‘tellsimp’ или
     ‘tellsimpafter’, или шаблоны, определенные ‘defmatch’.  Каждое
     правило выводится в форме промежуточного выражения, маркированного
     символом (‘%t’).

     Вызов ‘disprule (all)’ выводит все определенные правила.

     Функция ‘disprule’ не вычисляет свои аргументы.  Функция ‘disprule’
     возвращает список меток промежуточных выражений, соответствующих
     выведенным правилам.

     См.  также функцию ‘letrules’, которая выводит правила определенные
     ‘let’.

     Примеры:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]

 -- Функция: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Функция: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <package_name>)
     Определяет правила подстановки для функции ‘letsimp’ такие, что
     <prod> заменяется на <repl>.  <prod> является произведением
     подвыражений положительной или отрицательной степени.  Подвыражения
     могут быть следующего типа:

        • Атомы, поиск которых ‘letsimp’ ведет только по имени, если
          перед вызовом ‘letsimp’ в функции ‘matchdeclare’ не был
          определен предикат, связанный с этим атомом.  В последнем
          случае ‘letsimp’ будет сопоставлять атом с любым членом
          произведения удовлетворяющим предикату.
        • Ядра типа ‘sin(x)’, ‘n!’, ‘f(x,y)’ и т.п.  Как и в предыдущем
          случае ‘letsimp’ ищет буквальное соответствие, если в
          ‘matchdeclare’ не был определен предикат.

     Члены положительной степени будут сопоставляться только членам,
     имеющим положительную степень.  Члены отрицательной степени будут
     сопоставляться только членам, имеющим отрицательную степень.  Для
     того чтобы ‘letsimp’ работал с отрицательными степенями в <prod>
     переменная ‘letrat’ должна быть установлена равной ‘true’.  См.
     также ‘letrat’.

     Если в функцию ‘let’ включен предикат, с последующим списком
     аргументов, то подстановки осуществляются только если ‘predname
     (arg_1', ..., arg_n')’ дает ‘true’, где <arg_i’> есть значение,
     сопоставленное <arg_i>.  Переменная <arg_i> может быть именем атома
     или аргументом любого ядра, присутствующего в <prod>.  <repl> может
     быть любым рациональным выражением.  Если любой атом или аргумент
     из <prod> присутствует в <repl>, то выполняются соответствующие
     подстановки.

     Глобальная переменная ‘letrat’ управляет упрощением дробных
     выражений в ‘letsimp’.  Если ‘letrat’ равена ‘false’, то ‘letsimp’
     упрощает отдельно числитель и знаменатель выражения <expr>, но не
     упрощает их частное.  В этом случае подстановки типа ‘n!/n’ на
     ‘(n-1)!’ не будут работать.  Если ‘letrat’ равена ‘true’, тогда
     числитель, знаменатель и их частное упрощаются в данном порядке.

     Данные функции подстановок позволяют работать с несколькими
     пакетами правил одновременно.  Каждый пакет правил может содержать
     любое количество правил преобразований ‘let’ и обозначается
     некоторым заданным пользователем именем.  Вызов ‘let ([<prod>,
     <repl>, <predname>, <arg_1>, ..., <arg_n>], <package_name>)’
     добавляет правило <predname> к пакету правил <package_name>.  Вызов
     ‘letsimp (<expr>, <package_name>)’ применяет правила преобразований
     из пакета <package_name>.  Процедура ‘letsimp (<expr>,
     <package_name1>, <package_name2>, ...)’ эквивалентна применению
     функций ‘letsimp (<expr>, <package_name1>)’ и затем функции
     ‘letsimp (%, <package_name2>)’, ....

     Переменная ‘current_let_rule_package’ содержит имя текущего пакета
     правил.  Данной переменной может быть присвоено имя любого пакета
     правил, определенного при помощи ‘let’.  Вызов команды ‘let’ без
     упоминания имени пакета приводит к применению пакета, определенного
     ‘current_let_rule_package’.  При вызове типа ‘letsimp (<expr>,
     <rule_pkg_name>)’, используются правила пакета <rule_pkg_name>,
     только для данного вызова ‘lrtsimp’ а значение переменной
     ‘current_let_rule_package’ не меняется.  По умолчанию
     ‘current_let_rule_package’ равно ‘default_let_rule_package’.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1

 -- Управляющая переменная: letrat
     Значение по умолчанию: ‘false’

     Если ‘letrat’ равна ‘false’, то ‘letsimp’ упрощает отдельно
     числитель и знаменатель выражения <expr>, и не упрощает их частное.

     Если ‘letrat’ равна ‘true’, то числитель, знаменатель и их частное
     упрощаются в данном порядке.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!

 -- Функция: letrules ()
 -- Функция: letrules (<package_name>)
     Выводит правила, содержащиеся в пакете правил преобразований.
     ‘letrules ()’ выводит правила текущего пакета правил
     преобразований.  ‘letrules (<package_name>)’ выводит правила
     преобразований в пакете <package_name>.

     Текущий пакет правил определяется значением
     ‘current_let_rule_package’.  Если не определено иначе, то
     ‘current_let_rule_package’ по умолчанию равен
     ‘default_let_rule_package’.

     См.  также функцию ‘disprule’, отображающую правила, определенные
     путем ‘tellsimp’ и ‘tellsimpafter’.

 -- Функция: letsimp (<expr>)
 -- Функция: letsimp (<expr>, <package_name>)
 -- Функция: letsimp (<expr>, <package_name_1>, ..., <package_name_n>)
     Данная функция осуществляет повторное применение правил
     подстановки, определенных в ‘let’, до тех пор пока выражение <expr>
     не перестанет изменяться.

     ‘letsimp (<expr>)’ использует правила из пакета
     ‘current_let_rule_package’.

     ‘letsimp (<expr>, <package_name>)’ использует правила из пакета
     <package_name> без изменения значения переменной
     ‘current_let_rule_package’.

     ‘letsimp (<expr>, <package_name_1>, ..., <package_name_n>)’
     эквивалентно применению ‘letsimp (<expr>, <package_name_1>’, затем
     ‘letsimp (%, <package_name_2>)’ и так далее.

 -- Управляющая переменная: let_rule_packages
     Значение по умолчанию: ‘[default_let_rule_package]’

     ‘let_rule_packages’ - список определенных пользователем пакетов
     правил вместе с пакетом ‘default_let_rule_package’.

 -- Функция: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Связывает предикат <pred_k> с переменной или списком переменных
     <a_k>, так что <a_k> сопоставляется с выражениями, для которых
     предикат возвращает значение отличное от ‘false’.

     Предикат это есть имя функции, или лямбда-выражение, или вызов
     функции или лямбда-выражения без последнего аргумента, или ‘true’,
     или ‘all’.  Если предикат определен при помощи вызова функции или
     лямбда-выражения, то тестируемое выражение добавляется к списку
     аргументов; аргументы вычисляются во время вызова процедуры
     проверки на соответствие.  Если предикат определен в виде имени
     функции или лямбда-выражения, то единственным аргументом является
     тестируемое выражение.  Предикат не обязан быть определенным в
     момент вызова ‘matchdeclare’, поскольку он не вычисляется до тех
     пор пока не вызывается проверка на соответствие.

     Предикат может возвращать логическое выражение а также ‘true’ или
     ‘false’.  Логическое выражение вычисляется при помощи ‘is’ внутри
     построенной функции правила, так что нет необходимости вызывать
     ‘is’ в предикате.

     Если выражение удовлетворяет предикату, то переменной шаблона
     присваивается выражение за исключением переменных шаблона которые
     являются операндами сложения ‘+’ или умножения ‘*’.  Только
     сложение и умножение управляется специальным образом.  Другие
     n-арные операторы, (как пользовательские, так и встроенные)
     рассматриваются как обычные функции.

     В случае операторов сложения и умножения, переменной шаблона может
     быть присвоено простое выражение, которое соответствует предикату,
     а также сумма или произведение таких выражений.  Такое сложное
     сопоставление является ресурсоемким: предикаты вычисляются в
     порядке в котором, ассоциированные с ними переменные, встречаются в
     тестируемом выражении, и член, удовлетворяющий более чем одному
     предикату, сопоставляется первому соответствующему предикату.
     Каждый предикат проверяется для всех операндов суммы или
     произведения и только после этого проверяется следующий предикат.
     Кроме того, если 0 или 1 удовлетворяют предикату, а все остальные
     слагаемые выражения нет, тогда 0 или 1 присваиваются переменным
     шаблона ассоциированным с предикатом.

     Алгоритм проверки шаблонов, содержащий суммы и произведения, может
     давать разные результаты (например, шаблон, содержащий переменную
     соответствующую "всему, что угодно") в зависимости от порядка
     членов заданного шаблона и порядка членов тестируемого выражения.
     Если все операторы предикаты взаимно исключают друг друга, то
     результат не зависит от порядка, поскольку члены, соответствующие
     одному предикату, не могут соответствовать другому.

     Вызов ‘matchdeclare’ с переменной <a> в качестве аргумента изменяет
     ранее объявленные свойства ‘matchdeclare’ для <a> - при определении
     правил преобразования, учитываются только самый последний вызов
     ‘matchdeclare’.  Все последующие изменения свойства ‘matchdeclare’
     (посредством ‘matchdeclare’ или ‘remove’) не меняют существующих
     правил преобразований.

     ‘propvars (matchdeclare)’ возвращает список всех переменных,
     имеющих свойство ‘matchdeclare’.  ‘printprops (<a>, matchdeclare)’
     возвращает предикат для переменной ‘a’.  ‘printprops (all,
     matchdeclare)’ возвращает список всех предикатов для всех
     переменных ‘matchdeclare’.  ‘remove (<a>, matchdeclare)’ удаляет
     свойства ‘matchdeclare’ для переменной <a>.

     Функции ‘defmatch’, ‘defrule’, ‘tellsimp’, ‘tellsimpafter’ и ‘let’
     строят правила, которые сопоставляют выражения с шаблонами.

     Функция ‘matchdeclare’ не вычисляет свои аргументы.  Функция
     ‘matchdeclare’ всегда возвращает ‘done’.

     Примеры:

     Предикат есть имя функции, или лямбда-выражение, или вызов функции
     или лямбда-вызов без последнего аргумента, или ‘true’, или ‘all’.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Если выражение удовлетворяет предикату, то переменной шаблона
     присваивается выражение.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     В случае суммы и произведения, переменной шаблона может быть
     присвоено простое выражение, которое удовлетворяет предикату, или
     также сумма или произведение таких выражений.
          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     При сопоставлении аргументов ‘+’ и ‘*’, если все предикаты условия
     являются взаимоисключающими, то результат проверки не зависит
     порядка, так как один предикат не соответствует членам,
     соответствующим другому предикату.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     Функции ‘propvars’ и ‘printprops’ возвращают информацию о
     переменных шаблона.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]

 -- Функция: matchfix (<ldelimiter>, <rdelimiter>)
 -- Функция: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Объявляет матчфиксный (matchfix) оператор с левым и правым
     ограничителями <ldelimiter> и <rdelimiter> соответственно.
     Ограничители являются строками.

     Матчфиксный оператор является функцией любого количества аргументов
     заключенных между ограничителями <ldelimiter> и <rdelimiter>.
     Ограничителем может являться любая строка, если синтаксический
     анализатор может различить ограничители от других выражений и
     операторов.  На практике, это исключает такие ограничители, как
     ‘%’, ‘,’, ‘$’ и ‘;’, и может потребовать при вводе изолировать
     ограничители пробелами.  Правый ограничитель может совпадать с
     левым или отличаться от него.

     Левый ограничитель может быть ассоциирован только с одним правым;
     два различных матчфиксных оператора не могут иметь одинаковых левых
     ограничителя.

     Существующий оператор может быть переобъявлен, как матчфиксный
     оператор без изменения других его свойств.  Например, встроенные
     операторы сложения ‘+’ могут быть объявлены матчфиксными, однако
     операторные функции для встроенных операторов определены быть не
     могут.

     Вызов ‘matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)’
     объявляет аргумент "часть речи" <arg_pos> и результат "часть речи"
     <pos> вместе с ограничителями <ldelimiter> и <rdelimiter>.

     Термин "чать речи" по отношению к декларации операторов означает
     тип выражения.  Различаются три типа выражений: ‘expr’, ‘clause’ и
     ‘any’, что обозначает алгебраическое выражение, логическое
     выражение и выражение произвольного типа соответственно.  Maxima
     может обнаруживать некоторые синтаксические ошибки сравнивая
     объявленную часть речи с реальным выражением.

     Функция для выполнения матчфиксной операции является обычной
     пользовательской функцией.  Операторная функция определяется
     стандартным образом при помощи операторов ‘:=’ или ‘define’.
     Аргументы могут быть записаны между ограничителями или при помощи
     левого ограничителя в форме строки и последующих аргументов в
     скобках.  ‘dispfun (<ldelimiter>)’ выводит определение функции.

     Единственный встроенный матчфиксный оператор это конструктор списка
     ‘[ ]’.  Скобки ‘( )’ и двойные кавычки ‘" "’ работают как
     матчфиксные операторы, однако не обрабатываются синтаксическим
     анализатором Maxima как таковые.

     Функция ‘matchfix’ вычисляет свои аргументы.  Функция ‘matchfix’
     возвращает свой первый аргумент <ldelimiter>.

     Примеры:

        • В качестве ограничителей можно задавать практически любые
          строки.
          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

        • Матчфиксные операторы – это обычные пользовательские функции.
          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15

 -- Функция: remlet (<prod>, <name>)
 -- Функция: remlet ()
 -- Функция: remlet (all)
 -- Функция: remlet (all, <name>)
     Удаляет правило подстановки <prod> -> замена, определенное при
     самом последнем вызове функции ‘let’.  При вызове с именем правила
     в качестве аргумента удаление производится из соответствующего
     пакета правил.

     Вызовы ‘remlet()’ и ‘remlet(all)’ удаляют все правила подстановки
     из текущего пакета правил.  При указании имени, например, ‘remlet
     (all, <name>)’, пакет правил <name> также удаляется.

     Если необходимо изменить правило подстановки одного произведения,
     нет необходимости вызывать ‘remlet’, можно просто переопределить
     подстановку данного произведения при помощи функции ‘let’, с новой
     заменой и/или предикатом.  После этого вызов ‘remlet (<prod>)’
     восстанавливает исходное правило подстановки.

     См.  также функцию ‘remrule’, которая удаляет правила определенные
     функцией ‘tellsimp’ или ‘tellsimpafter’.

 -- Функция: remrule (<op>, <rulename>)
 -- Функция: remrule (<op>, all)
     Удаляет правила, определенные функциями ‘tellsimp’ или
     ‘tellsimpafter’.

     ‘remrule (<op>, <rulename>)’ удаляет правило с именем <rulename>
     для оператора <op>.  Если оператор <op> является встроенным
     оператором или определен пользователем (например, при помощи
     функций ‘infix’, ‘prefix’, и т.п.), тогда <op> и <rulename>
     необходимо заключить в двойные кавычки.

     ‘remrule (<op>, all)’ удаляет все правила для оператора <op>.

     См.  также функцию ‘remlet’, удаляющую правила, определенные при
     помощи ‘let’.

     Примеры:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@@", "@@rule1");
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]

 -- Функция: tellsimp (<pattern>, <replacement>)
     аналогична ‘tellsimpafter’, но добавляет новую информацию о
     правилах до уже существующей.  Таким образом, сначала применяются
     пользовательские правила упрощения, а потом правила, встроенные в
     систему.

     Функция ‘tellsimp’ используется, когда важно модифицировать
     выражение до того, как оно обработано упрощателем, например,
     встроенный механизм упрощения "знает" что-либо о структуре
     выражения, но возвращает результат, который вас не устраивает.
     Если встроенный механизм упрощения "знает" что-либо о главном
     операторе выражения, но работает не достаточно эффективно - можно
     попробовать использовать ‘tellsimpafter’.

     Шаблон не может быть суммой, произведением, одиночной переменной
     или числом.

     ‘rules’ - список правил определенный функциями ‘defrule’,
     ‘defmatch’, ‘tellsimp’ и ‘tellsimpafter’.

     Примеры:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)

 -- Функция: tellsimpafter (<pattern>, <replacement>)
     Определяет правило упрощения, которое встроенный в Maxima механизм
     упрощения применяет после встроенных правил упрощения.  <pattern> -
     выражение, включающее переменные шаблона (объявленные в
     ‘matchdeclare’) и другие атомы и операторы, которые рассматриваются
     как константы с точки зрения сопоставления с шаблоном.
     <replacement> подставляется вместо первоначального выражения,
     удовлетворяющего шаблону <pattern>; переменным шаблона из в
     <replacement> присваиваются соответствующие подвыражения из
     реального выражения.

     <pattern> может быть любым составным выражением в котором имя
     главного оператор не входит в число переменных шаблона; правило
     упрощения связывается с именем главного оператора.  Имена функций
     (за исключением приведенных ниже), списки и массивы могут
     присутствовать в шаблоне <pattern> в качестве основного оператора
     только, как литералы (не переменные шаблона); это исключает шаблоны
     вида ‘aa(x)’ и ‘bb[y]’, если ‘aa’ и ‘bb’ являются переменными
     шаблона.  Имена функций, списки и массивы, которые являются
     переменными шаблона могут входить в качестве не основных операторов
     в описание шаблона <pattern>.

     Есть одно исключение к указанному правилу, касающееся имен функций.
     Имена функций с индексом в выражениях типа ‘aa[x](y)’ могут быть
     переменными шаблона, поскольку в этом случае главный оператор не
     ‘aa’, а Lisp-атом ‘mqapply’.  Это является следствием представления
     выражений, включающих функции с индексом.

     Правила упрощения применяются после вычисления (если вычисления не
     запрещены либо экранированием выражения, либо ключом ‘noeval’).
     Правила введенные ‘tellsimpafter’ применяются в том порядке в
     котором они были определены после всех встроенных правил.
     Преобразования применяются "снизу-вверх", т.е., сначала к
     подвыражению, перед обработкой выражения в целом.  Иногда для того,
     чтобы обеспечить, что применены все правила, необходимо повторное
     упрощение результата (например, при применении оператора
     кавычка-кавычка ‘''’ или ключа ‘infeval’).

     Переменные шаблона рассматриваются как локальные переменные в
     правилах упрощения.  Как только правило определено, значение
     переменной шаблона не влияет на правило, и наоборот, правило не
     влияет на значение переменной.  Присваивание значений переменным
     шаблона, происходящее в результате успешного сопоставления шаблона,
     не влияет на текущие значения (или их отсутствие) переменных
     шаблона.  Однако, как и у всех атомов в Maxima, свойства переменных
     шаблона (объявленные оператором ‘put’ и подобными функциями)
     являются глобальными.

     Правило, построенное с помощью ‘tellsimpafter’, обозначаеся именем
     главного оператора <pattern>.  Правила для встроенных операторов и
     пользовательских функций, определенных при помощи ‘infix’,
     ‘prefix’, ‘postfix’, ‘matchfix’ и ‘nofix’, имеют имена, являющиеся
     Lisp-идентификаторами.  Правила для других функций имеют имена,
     являющиеся идентификаторами Maxima.

     Обработка вычисляемых и не вычисляемых форм немного неоднозначна.
     Если правило определено для невычисляемой (или вычисляемой) формы
     выражения, а правило для соответствующей вычисляемой (или
     невычисляемой) уже существует, то новое правило применяется к обеим
     формам выражения (вычисляемой и невычисляемой).  Если правило для
     соответствующей вычисляемой (или невычисляемой) не существует, то
     новое правило применяется к невычисляемой (или вычисляемой) форме
     выражения.

     Правило, построенное с помощью ‘tellsimpafter’, является обычной
     Lisp- функцией.  Если имя правила - ‘$foorule1’, то конструкция
     ‘:lisp (trace $foorule1)’ дает трассировку ее вызовов, а ‘:lisp
     (symbol-function '$foorule1’ выводит ее определение.

     Функция ‘tellsimpafter’ не вычисляет свои аргументы.  Функция
     ‘tellsimpafter’ возвращает список правил для основного оператора
     шаблона <pattern>, включая вновь объявленные правила.

     См.  также ‘matchdeclare’, ‘defmatch’, ‘defrule’, ‘tellsimp’,
     ‘let’, ‘kill’, ‘remrule’ и ‘clear_rules’.

     Примеры:

     <pattern> может быть любым неатомарным выражением в котором главный
     оператор не является переменной шаблона.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Правила применяются в том порядке в котором они были определены.
     Если два правила соответствуют выражению, то первым применяется то,
     которое было определено раньше.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Переменные шаблона являются локальными переменные правил упрощения.
     (Сравни с функцией ‘defmatch’, которая рассматривает переменные
     шаблона, как глобальные).

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Как и у всех атомов, свойства переменных шаблона являются
     глобальными даже если их значение локально.  В данном примере
     свойство объявляется при помощи ‘define_variable’.  Это свойство
     атома ‘bb’ является глобальным.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Правила именуются по имени основного оператора.  Имена правил для
     встроенных и пользовательских операторов являются
     Lisp-идентификаторами, тогда как имена других функций являются
     идентификаторами Maxima.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) remrule (foo, foorule1);
          (%o10)                         foo
          (%i11) remrule ("^", ?\^rule1);
          (%o11)                          ^
          (%i12) rules;
          (%o12)        [foorule2, foorule3, +rule1, *rule1]

     Рабочий пример: антикоммутативное умножение.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0

 -- Функция: clear_rules ()
     Исполняет ‘kill (rules)’ и обнуляет счетчик, т.е.  новое правило
     будет иметь номер ‘1’ вслед за встроенными правилами для операторов
     суммы ‘+’, умножения ‘*’ и степени ‘^’.


File: maxima.info,  Node: Списки,  Next: Множества,  Prev: Правила преобразования и шаблоны,  Up: Top

35 Списки
*********

* Menu:

* Ведение в работу со списками::
* Функции и переменные для работы со списками::


File: maxima.info,  Node: Ведение в работу со списками,  Next: Функции и переменные для работы со списками,  Prev: Списки,  Up: Списки

35.1 Ведение в работу со списками
=================================

Списки являются основными строительными блоками в Maxima и Lisp.  Все
типы данных, за исключением массивов, хеш-таблиц и чисел, представлены,
как Lisp списки.  Эти списки имеют вид

     ((MPLUS) $A 2)

для обозначения ‘a+2’.  На уровне Maxima мы увидим в инфиксной нотации
‘a+2’.  Maxima тоже имеет свои собственные списки, которые печатаются
как

     [1, 2, 7, x+y]

для списка из 4 элементов.  Внутренне, это выражение соответствует Lisp
списку

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

Флаг, который обозначает тип выражения Maxima, сам является списком, и
после упрощения, данный список приобретет вид

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Функции и переменные для работы со списками,  Prev: Ведение в работу со списками,  Up: Списки

35.2 Функции и переменные для работы со списками
================================================

 -- Функция: append (<list_1>, ..., <list_n>)
     Возвращает новый список элементов <list_1> с последующими
     элементами <list_2> и т.д.  ‘append’ работает и с выражениями
     общего вида, например, ‘append (f(a,b), f(c,d,e));’ дает
     ‘f(a,b,c,d,e)’.

     См.  ‘example(append);’ для примера.

 -- Функция: assoc (<key>, <list>, <default>)
 -- Функция: assoc (<key>, <list>)
     Эта функция ищет ключ <key> в правых частях списка <list>, имеющего
     форму ‘[x,y,z,...]’, где каждый элемент <list> есть выражение с
     бинарным оператором и двумя операндами.  Например, ‘x=1’, ‘2^3’,
     ‘[a,b]’ и т.д.  Ключ <key> сравнивается с первым операндом.  Если
     ключ ‘key’ найден, то ‘assoc’ возвращает второй операнд.  В
     противном случае возвращается значение <default>.  Параметр
     <default> не обязателен и по умолчанию равен ‘false’.

 -- Функция: atom (<expr>)
     Возвращает ‘true’ если <expr> является атомарным (т.е.  число, имя
     или строка) и ‘false’ в противном случае.  Т.е.  ‘atom(5)’ равно
     ‘true’, тогда как ‘atom(a[1])’ и ‘atom(sin(x))’ равны ‘false’
     (предполагая, что ‘a[1]’ и ‘x’ не имеют значения).

 -- Функция: cons (<expr>, <list>)
     Возвращает новый список, составленный из первого элемента равного
     <expr> с последующими элементами <list>.  Функция ‘cons’ работает и
     с произвольными выражениями, например, ‘cons(x, f(a,b,c));’ ->
     ‘f(x,a,b,c)’.

 -- Функция: copylist (<list>)
     Возвращает копию списка <list>.

 -- Функция: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)

     Создает список, вычисляя выражение <form> с <x_1> последовательно
     равным элементам <list_1>, <x_2> последовательно равным элементам
     <list_2> и т.д.  Общее число элементов в результирующем списке
     равно произведению числа элементов во всех списках.  Каждая
     переменная <x_i> должна быть символом.  Переменные не вычисляются.
     Списки вычисляются однажды в начале итерации.

          (%i1) create_list(x^i,i,[1,3,7]);
                           3   7
          (%o1)       [x, x , x ]

     Двойная итерация:

          (%i1) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     Вместо списка <list_i> можно использовать два параметра, которые
     должны иметь числовые значения.  Они будут рассматриваться как
     нижняя и верхняя границы итерации (включительно).

          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

     Отметим, что пределы для переменной ‘j’ могут зависеть от ‘i’.

 -- Функция: delete (<expr_1>, <expr_2>)
 -- Функция: delete (<expr_1>, <expr_2>, <n>)
     Удаляет все элементы, равные <expr_1>, из <expr_2>.  При этом
     <expr_1> может быть слагаемым <expr_2> (если это сумма) или
     множителем <expr_2> (если это произведение).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     Вызов ‘delete(<expr_1>, <expr_2>, <n>)’ удаляет первые <n> случаев
     <expr_1> из <expr_2>.  Если число включений <expr_1> в <expr_2>
     меньше <n>, то будут удалены все.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)

 -- Функция: eighth (<expr>)
     Возвращает восьмой элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: endcons (<expr>, <list>)
     Возвращает новый список, состоящий из элементов ‘list’ с
     последующим <expr>.  Функция ‘endcons’ работает и с общими
     выражениями, например, ‘endcons(x, f(a,b,c));’ -> ‘f(a,b,c,x)’.

 -- Функция: fifth (<expr>)
     Возвращает пятый элемент выражения или списка <expr>.  См.  ‘first’
     по поводу подробностей.

 -- Функция: first (<expr>)
     Возвращает первый элемент <expr>, что может быть первым элементом
     списка, первой строкой в матрице, первым слагаемым суммы и т.д.
     Заметим, что ‘first’ и другие подобные функции, такие как ‘rest’ и
     ‘last’, работают с внешней (печатной) формой выражения <expr>, а не
     с тем, как это выражение было введено.  Если значение ‘inflag’
     равно ‘true’, то эти функции будут работать с внутренним
     представлением выражения <expr>.  Отметим, что упрощатель изменяет
     порядок членов в выражениях.  Так, ‘first(x+y)’ будет равно ‘x’,
     если ‘inflag’ равна ‘true’, и ‘y’, если ‘inflag’ равна ‘false’
     (‘first(y+x)’ даст одинаковый результат в обоих случаях).  Функции
     ‘second’ ..  ‘tenth’ дают со второго по десятый элемент выражения.

 -- Функция: fourth (<expr>)
     Возвращает четвертый элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: get (<a>, <i>)
     Возвращает определенное пользователем свойство атома <a>,
     обозначенное <i>, или ‘false’, если атом не имеет свойства <i>.

     Функция ‘get’ вычисляет свои аргументы.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- Функция: join (<l>, <m>)
     Возвращает новый список, состоящий из чередующихся элементов
     списков <l> и <m>.  Результат будет иметь вид ‘[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]’.  Списки <l> и <m> могут иметь элементы
     любого типа.

     Если списки имеют разную длину, то ‘join’ отбросит последние
     элементы более длинного списка.

     Ситуация, когда либо <l>, либо <m> не является списком, считается
     ошибкой.

     Примеры:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]

 -- Функция: last (<expr>)
     Возвращает последний элемент <expr> (элемент, слагаемое, множитель,
     строку и т.п.).

 -- Функция: length (<expr>)
     По умолчанию возвращает число частей внешней (печатной) формы
     выражения <expr>.  Для списка – это число элементов, для матрицы –
     число строк, для суммы – число слагаемых (см.  ‘dispform’).

     Результат ‘length’ зависит от переключателя ‘inflag’.  Например,
     ‘length(a/(b*c));’ дает 2, если ‘inflag’ равен ‘false’
     (предполагается, что ‘exptdispflag’ равна ‘true’), и дает 3, если
     ‘inflag’ равен ‘true’, т.к.  внутренние представление есть
     ‘a*b^-1*c^-1’.

 -- Управляющая переменная: listarith
     Значение по умолчанию: ‘true’ Если равна ‘false’, то все
     арифметические операции со списками не работают.  Если равна
     ‘true’, то все операции список-матрица вызывают преобразование
     списков в матрицы и дают результат матричного типа.  Однако,
     операции список-список продолжают давать списки.

 -- Функция: listp (<expr>)
     Возвращает ‘true’, если <expr> является списком и ‘false’ в
     противном случае.

 -- Функция: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Функция: makelist (<expr>, <x>, <list>)
     Создает и возвращает список, каждый элемент которого построен из
     выражения <expr>.

     Вызов ‘makelist (<expr>, <i>, <i_0>, <i_1>)’ возвращает список, с
     ‘j’-м элементом равным ‘ev (<expr>, <i>=j)’ для ‘j’, пробегающего
     значения от <i_0> до <i_1>.

     Вызов ‘makelist (<expr>, <x>, <list>)’ возвращает список, с ‘j’-м
     элементом равным ‘ev (<expr>, <x>=<list>[j])’ для ‘j’, пробегающего
     значения от 1 до ‘length (<list>)’.

     Примеры:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]

 -- Функция: member (<expr_1>, <expr_2>)

     Возвращает ‘true’ если ‘is(<expr_1> = <a>)’, для некоторого
     элемента <a> из ‘args(<expr_2>)’, и ‘false’ в противном случае.

     Обычно, ‘expr_2’ является списком.  В этом случае ‘args(<expr_2>) =
     <expr_2>’ и ‘is(<expr_1> = <a>)’ для некоторого элемента <a> из
     ‘expr_2’.

     Функция ‘member’ не анализирует составные части аргументов
     ‘expr_2’, и может возвратить ‘false’ даже если ‘expr_1’ является
     частью какого-либо из аргументов ‘expr_2’.

     См.  также ‘elementp’.

     Примеры:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true

 -- Функция: ninth (<expr>)
     Возвращает девятый элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: unique (<L>)

     Возвращает уникальные элементы списка <L>.

     Если все элементы списка <L> уникальны, то ‘unique’ возвращает
     копию верхнего уровня списка <L>, а не сам список <L>.

     Если <L> не является списком, то ‘unique’ возвращает <L>.

     Пример:

          (%i1) unique ([1, %pi, a + b, 2, 1, %e, %pi, a + b, [1]]);
          (%o1)              [1, 2, %e, %pi, [1], b + a]

 -- Функция: rest (<expr>, <n>)
 -- Функция: rest (<expr>)
     Возвращает <expr> без первых <n> элементов, если <n> положительно,
     или без последних ‘- <n>’ элементов, если <n> отрицательно.  Если
     <n> равен 1, то он может быть опущен.  Выражение <expr> может быть
     списком, матрицей или выражением.

 -- Функция: reverse (<list>)
     Изменяет порядок членов <list> (но не сами члены) на обратный.
     Функция ‘reverse’ также работает с выражениями общего вида,
     например, ‘reverse(a=b);’ дает ‘b=a’.

 -- Функция: second (<expr>)
     Возвращает второй элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: seventh (<expr>)
     Возвращает седьмой элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: sixth (<expr>)
     Возвращает шестой элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: sublist_indices (<L>, <P>)

     Возвращает список индексов элементов ‘x’ списка <L>, для которых
     предикат ‘maybe(<P>(x))’ возвращает ‘true’, за исключением
     элементов ‘unknown’ и ‘false’.  Параметр <P> может быть именем
     функции или лямбда-выражением.  Параметр <L> должен быть списком.

     Примеры:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                                 lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0],
                                 identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]

 -- Функция: tenth (<expr>)
     Возвращает десятый элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.

 -- Функция: third (<expr>)
     Возвращает третий элемент выражения или списка <expr>.  См.
     ‘first’ по поводу подробностей.


File: maxima.info,  Node: Множества,  Next: Определение функций,  Prev: Списки,  Up: Top

36 Множества
************

* Menu:

* Введение в работу с множествами::       
* Функции и переменные для работы с множествами::       


File: maxima.info,  Node: Введение в работу с множествами,  Next: Функции и переменные для работы с множествами,  Prev: Множества,  Up: Множества

36.1 Введение в работу с множествами
====================================

Maxima предоставляет функции, такие как пересечение или объединение, для
работы с конечными множествами, определяемыми перечислением элементов.
Maxima трактует списки и множества как различные объекты.  Это позволяет
работать с множествами, элементами которых сами могут быть списками или
множествами.

   В дополнение к функциям для работы конечными множествами Maxima
определяет некоторые функции, относящиеся к комбинаторике, что включает:
числа Стирлинга первого и второго рода, числа Белла, мультиномиальные
коэффициенты, разбиения неотрицательных целых чисел и некоторые другие.
Maxima также определяет дельта-функцию Кронекера.

36.1.1 Использование
--------------------

Для того, чтобы задать множество с элементами ‘a_1, ..., a_n’, следует
написать ‘set(a_1, ..., a_n)’ или ‘{a_1, ..., a_n}’; для пустого
множества надо написать ‘set()’ или ‘{}’.  При вводе формы ‘set(...)’ и
‘{ ... }’ эквивалентны.  При выводе множества всегда печатаются с
фигурными скобками.

   Если элемент множества присутствует более одного раза, то упрощение
удалит повторяющиеся элементы.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Два элемента <x> и <y> являются повторяющимися (т.е.  рассматриваются
совпадающими с точки зрения включения в множество), тогда и только
тогда, когда ‘is(<x> = <y>)’ дает ‘true’.  Заметим, что ‘is(equal(<x>,
<y>))’ может давать ‘true’, тогда как ‘is(<x> = <y>)’ дает ‘false’.  В
этом случае элементы <x> и <y> считаются различными.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Для того, чтобы создать множество из элементов списка, используется
‘setify’.

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   Элементы множества ‘x’ и ‘y’ равны если ‘is(x = y)’ вычисляется в
‘true’.  Тогда ‘rat(x)’ и ‘x’ являются равными элементами множества, и,
следовательно

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   Далее, поскольку ‘is((x - 1)*(x + 1) = x^2 - 1)’ вычисляется в
‘false’, то ‘(x - 1)*(x + 1)’ и ‘x^2 - 1’ есть различные элементы, и

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Для приведения этого множества к одноэлементному следует применить
‘rat’ к каждому элементу:

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Для удаления повторов из множеств другого вида может потребоваться
применение других упрощающих функций.  Вот пример, использующий
‘trigsimp’:

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   Множество является упрощенным, если его элементы не повторяются и
упорядочены.  Текущая реализация Maxima функций для работы с множествами
использует функцию ‘orderlessp’ для упорядочения, однако будущие версии
могут использовать другую упорядочивающую функцию.

   Некоторые операции над множествами, такие как подстановки, вызывают
автоматическое упрощение.  Например,

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima рассматривает списки и множества как различные объекты;
функции, подобные ‘union’ и ‘intersection’, сигнализируют об ошибке если
их аргументы не являются множествами.  Если необходимо применить функцию
для работы с множествами к списку, то надо сначала использовать ‘setify’
для преобразования списка в множество.  Таким образом

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   Для того, чтобы получить все элементы множества ‘s’, удовлетворяющие
предикату ‘f’, используйте ‘subset(s, f)’ (предикат – функция, дающая
логическое значение).  Например, чтобы найти в заданном множестве
уравнения, которые не зависят от переменной ‘z’, используйте

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                         lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   Раздел *note Функции и переменные для работы с множествами:: содержит
полный список функций Maxima, предназначенных для работы с множествами.

36.1.2 Итерация по элементам множества
--------------------------------------

Существует два способа организации цикла по элементам множества.  Один
способ – использовать ‘map’, например:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   Другой способ – использовать ‘for <x> in <s> do’

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   Maxima функции ‘first’ и ‘rest’ правильно работают с множествами.
Примененная к множеству, ‘first’ возвращает первый элемент множества,
какой именно – может зависеть от реализации.  Если ‘s’ является
множеством, то ‘rest(s)’ эквивалентно ‘disjoin(first(s), s)’.  В
настоящий момент есть другие функции Maxima, корректно работающие с
множествами.  В будущих версиях функции ‘first’ и ‘rest’ могут работать
на множествах иначе или не работать вовсе.

36.1.3 Ошибки
-------------

Функции для работы с множествами используют Maxima функцию ‘orderlessp’
для сортировки элементов множества и Lisp функцию ‘like’ для проверки
равенства элементов.  Обе эти функции имеют известные ошибки, которые
проявляются при попытке использовать множества, элементы которых
являются списками или матрицами, включающими выражения в канонической
рациональной форме (КРВ). Например

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Это выражение вызывает ошибку (сообщение об ошибке зависит от версии
Lisp и Maxima).  Другой пример

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Эти ошибки вызваны ошибками в ‘orderlessp’ и ‘like’, а не ошибками в
реализации функций работы с множествами.  Для иллюстрации попробуем
следующие выражения

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   До тех пор, пока эти ошибки не исправлены, не следует использовать
множества с элементами в виде списков и матриц, содержащих выражения в
формате КРВ. Множества, просто содержащие выражения КРВ в качестве
элементов, не создают проблем.

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   Maxima функция ‘orderlessp’ имеет еще одну ошибку, которая может
создать проблемы при работе с множествами.  А именно, упорядочивающий
предикат ‘orderlessp’ не является транзитивным.  Простейший известный
пример, демонстрирующий это

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   Эта ошибка вызывает проблемы со всеми функциями для работы с
множествами и даже с другими функциями Maxima.  Возможно, но точно не
известно, что эту ошибку можно обойти, если все элементы множества или
являются КРВ, или упрощены с помощью ‘ratsimp’.

   Механизмы Maxima ‘orderless’ и ‘ordergreat’ не совместимы с функциями
для работы с множествами.  Если требуется использовать либо ‘orderless’,
либо ‘ordergreat’, то следует вызывать эти функции до формирования
множеств, и не следует использовать ‘unorder’.

   Если вы встретите что-то, что может быть ошибкой в функциях работы с
множествами, пожалуйста, сообщите об этом в базу данных ошибок Maxima.
См.  ‘bug_report’.

36.1.4 Авторы
-------------

Функции для работы с множествами Maxima и документация к ним написаны
Ставросом Макракисом (Stavros Macrakis of Cambridge, Massachusetts) и
Бартоном Уиллисом (Barton Willis of the University of Nebraska at
Kearney (UNK)).


File: maxima.info,  Node: Функции и переменные для работы с множествами,  Prev: Введение в работу с множествами,  Up: Множества

36.2 Функции и переменные для работы с множествами
==================================================

 -- Функция: adjoin (<x>, <a>)

     Возвращает объединение множества <a> с ‘{<x>}’.

     Функция ‘adjoin’ вызывает ошибку, если <a> не является множеством.

     Вызовы ‘adjoin(<x>, <a>)’ и ‘union(set(<x>), <a>)’ эквивалентны,
     однако ‘adjoin’ может быть несколько быстрее, чем ‘union’.

     См.  также ‘disjoin’.

     Примеры:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}

 -- Функция: belln (<n>)

     Представляет n-ое число Белла.  ‘belln(n)’ есть число разбиений
     множества с <n> элементами.

     Для неотрицательного целого <n>, ‘belln(<n>)’ упрощается в n-ое
     число Белла.  Для других значений аргумента ‘belln’ не упрощается.

     Функция ‘belln’ дистрибутивна по отношению к уравнениям, спискам,
     матрицам и множествам.

     Примеры:

     Функция ‘belln’, примененная к неотрицательным целым числам.

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                                 belln (6));
          (%o3)                         true

     Функция ‘belln’, примененная к аргументам, не являющимися
     неотрицательными целыми числами.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- Функция: cardinality (<a>)

     Возвращает число различных элементов множества <a>.

     Функция ‘cardinality’ игнорирует повторяющиеся элементы даже если
     упрощение отключено.

     Примеры:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- Функция: cartesian_product (<b_1>, ... , <b_n>)
     Возвращает множество списков формы ‘[<x_1>, ..., <x_n>]’, где
     <x_1>, ..., <x_n> есть элементы множеств <b_1>, ...  , <b_n>
     соответственно.

     Функция ‘cartesian_product’ вызывает ошибку, если хотя бы один из
     ее аргументов не является множеством.

     Примеры:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Функция: disjoin (<x>, <a>)
     Возвращает множество <a> без элемента <x>.  Если <x> не является
     элементом <a>, то <a> возвращается неизменным.

     Функция ‘disjoin’ вызывает ошибку, если <a> не является множеством.

     ‘disjoin(<x>, <a>)’, ‘delete(<x>, <a>)’ и ‘setdifference(<a>,
     set(<x>))’ эквивалентны.  Из этих вариантов ‘disjoin’ обычно
     быстрее других.

     Примеры:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- Функция: disjointp (<a>, <b>)
     Возвращает ‘true’ тогда и только тогда, когда множества <a> и <b>
     не пересекаются.

     Функция ‘disjointp’ вызывает ошибку, если <a> или <b> не являются
     множествами.

     Примеры:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- Функция: divisors (<n>)

     Представляет множество делителей <n>.

     Функция ‘divisors(<n>)’ упрощается до множества целых чисел, при
     этом <n> является ненулевым целым числом.  Множество делителей
     включает 1 и <n>.  Делители отрицательного числа совпадают с
     таковыми для его абсолютного значения.

     Функция ‘divisors’ дистрибутивна по отношению к уравнениям,
     спискам, матрицам и множествам.

     Примеры:

     Мы можем проверить, что число 28 является совершенным, т.е.  сумма
     делителей, за исключением самого числа, равна 28.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     Функция ‘divisors’ является упрощающей.  Подстановка 8 для ‘a’ в
     ‘divisors(a)’ дает делители без перевычисления ‘divisors(8)’.

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     Функция ‘divisors’ дистрибутивна по отношению к уравнениям,
     спискам, матрицам и множествам.

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- Функция: elementp (<x>, <a>)
     Возвращает ‘true’ тогда и только тогда, когда <x> является
     элементом множества <a>.

     Функция ‘elementp’ вызывает ошибку, если <a> не является
     множеством.

     Примеры:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- Функция: emptyp (<a>)
     Возвращает ‘true’ тогда и только тогда, когда <a> есть пустое
     множество или список.

     Примеры:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- Функция: equiv_classes (<s>, <F>)
     Возвращает множество классов эквивалентности множества <s> по
     отношению эквивалентности <F>.

     <F> – есть функция двух переменных, определенная на Декартовом
     произведении <s> на <s>.  Возвращаемое <F> значение есть ‘true’ или
     ‘false’, либо выражение <expr> такое, что ‘is(<expr>)’ дает ‘true’
     или ‘false’.

     Если <F> не является отношением эквивалентности, то ‘equiv_classes’
     применит его без возражения, но результат будет скорее всего
     неправильным.

     Примеры:

     Отношение эквивалентности является лямбда-выражением, возвращающим
     ‘true’ или ‘false’.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                  lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Отношение эквивалентности есть имя реляционной функции ‘is’, дающей
     ‘true’ или ‘false’.

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     Классы эквивалентности – числа отличающиеся на несколько чисел 3.

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                               lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Функция: every (<f>, <s>)
 -- Функция: every (<f>, <L_1>, ..., <L_n>)

     Возвращает ‘true’, если предикат <f> дает ‘true’ для всех
     аргументов.

     Если второй аргумент является множеством, то ‘every(<f>, <s>)’
     возвращает ‘true’, если ‘is(<f>(<a_i>))’ возвращает ‘true’ для всех
     <a_i> в <s>.  ‘every’ может вычислять <f> для всех <a_i> в <s>, а
     может и не для всех.  Т.к.  множества не упорядочены, то ‘every’
     может вычислять ‘<f>(<a_i>)’ в произвольном порядке.

     Примененная к одному или нескольким спискам, ‘every(<f>, <L_1>,
     ..., <L_n>)’ возвращает ‘true’, если ‘is(<f>(<x_1>, ..., <x_n>))’
     возвращает ‘true’ для всех <x_1>, ..., <x_n> в <L_1>, ..., <L_n>
     соответственно.  ‘every’ может вычислять <f> для всех комбинаций
     <x_1>, ..., <x_n>, а может и не для всех.  ‘every’ вычисляет списки
     в порядке возрастания индекса.

     Для пустого множества ‘{}’ и пустого списка ‘[]’ ‘every’ возвращает
     ‘false’.

     Если глобальный флаг ‘maperror’ равен ‘true’, то все списки <L_1>,
     ..., <L_n> должны иметь одинаковую длину.  Если ‘maperror’ равен
     ‘false’, то списки обрезаются до длины самого короткого.

     Значение предиката <f>, который вычисляется посредством ‘is’ в
     значение, отличное от ‘true’ или ‘false’, управляется глобальным
     флагом ‘prederror’.  Если ‘prederror’ равен ‘true’, то данные
     значения рассматриваются как ‘false’, и возвращаемое ‘every’
     значение есть ‘false’.  Если ‘prederror’ равен ‘false’, то такие
     значения рассматриваются как ‘unknown’, и возвращаемое ‘every’
     значение равно ‘unknown’.

     Примеры:

     ‘every’, примененная к одному списку.  Предикат является функцией
     одного аргумента.

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     ‘every’, примененная к двум спискам.  Предикат – функция двух
     аргументов.

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Значение предиката <f>, вычисляемого в значение, отличное от ‘true’
     или ‘false’, управляется глобальным флагом ‘prederror’.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- Функция: extremal_subset (<s>, <f>, max)
 -- Функция: extremal_subset (<s>, <f>, min)

     Возвращает подмножество <s>, на котором функция <f> принимает
     минимальное или максимальное значение.

     ‘extremal_subset(<s>, <f>, max)’ возвращает подмножество множества
     или списка <s>, для которого вещественнозначная функция <f>
     принимает максимальное значение.

     ‘extremal_subset(<s>, <f>, min)’ возвращает подмножество множества
     или списка <s>, для которого вещественнозначная функция <f>
     принимает минимальное значение.

     Примеры:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- Функция: flatten (<expr>)

     Собирает аргументы подвыражений, имеющих оператор верхнего уровня
     такой же как у <expr>, и строит выражение из этих собранных
     аргументов.

     Аргументы, имеющие оператор верхнего уровня отличный от главного
     оператора ‘expr’, копируются без модификации даже если они, в свою
     очередь, имеют некоторые подвыражения с главным оператором ‘expr’.

     Возможно, что ‘flatten’ построит выражение с числом аргументов
     недопустимым для данного типа оператора, что может привести к
     ошибке упрощателя или вычислителя.  Функция ‘flatten’ не пытается
     определить подобные ситуации.

     Выражения, имеющие специальные представления, например,
     канонические рациональные выражения (КРВ), не обрабатываются
     ‘flatten’.  В этом случае ‘flatten’ возвращает аргумент без
     изменения.

     Примеры:

     Примененная к списку, ‘flatten’ собирает все элементы, являющиеся
     списками.

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     Примененная к множеству, ‘flatten’ собирает все элементы,
     являющиеся множествами.

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     Функция ‘flatten’ похожа на объявление оператора n-арным.  Однако
     ‘flatten’ не влияет на подвыражения, имеющие оператор, отличный от
     главного оператора выражения, тогда как декларация оператора
     n-арным действует на них.

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     ‘flatten’ трактует функции с индексом также как любые другие
     операторы.

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     Функция ‘flatten’ может составить выражение, в котором число
     аргументов отличается от объявленного числа аргументов оператора.

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Функция: full_listify (<a>)
     Заменяет в <a> все множества на списки и возвращает результат.
     ‘full_listify’ заменяет операторы множества на операторы списка во
     вложенных подвыражениях, даже если главный оператор не есть ‘set’.

     Функция ‘listify’ заменяет только главный оператор.

     Примеры:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- Функция: fullsetify (<a>)
     Если <a> является списком, то ‘fullsetify’ заменяет оператор списка
     на оператор множества и применяет ‘fullsetify’ ко всем членам этого
     множества.  Если аргумент <a> не является списком, то он
     возвращается неизменным.

     Функция ‘setify’ заменяет только главный оператор.

     Примеры:

     В строке ‘(%o2)’ аргумент ‘f’ не преобразован в множество, т.к.
     главный оператор не является списком ‘f([b])’.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- Функция: identity (<x>)

     Возвращает <x> для любого аргумента <x>.

     Примеры:

     Функция ‘identity’ может использоваться как предикат, если
     параметры уже являются логическими значениями.

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Функция: integer_partitions (<n>)
 -- Функция: integer_partitions (<n>, <len>)

     Возвращает целочисленные разбиения <n>, т.е.  списки целых чисел,
     сумма которых равна <n>.

     Функция ‘integer_partitions(<n>)’ возвращает множество всех
     разбиений <n>.  Каждое разбиение есть список, отсортированный от
     большего значения к меньшему.

     Вызов ‘integer_partitions(<n>, <len>)’ возвращает все разбиения
     длины <len> или менее.  В этом случае к разбиениям, имеющим число
     членов меньшее, чем <len>, добавляются нули, чтобы сделать все
     возвращаемые разбиения одинаковой длины <len>.

     Список [a_1, ..., a_m] есть разбиение неотрицательного целого числа
     n, если (1) каждое a_i есть ненулевое положительное число и (2) a_1
     + ... + a_m = n.  Таким образом, 0 не имеет разбиений.

     Примеры:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Для того, чтобы найти все разбиения, удовлетворяющие определенному
     условию, можно использовать функцию ‘subset’.  В следующем примере
     находятся все разбиения 10, состоящие из простых чисел.

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- Функция: intersect (<a_1>, ..., <a_n>)

     Функция ‘intersect’ идентична ‘intersection’.

 -- Функция: intersection (<a_1>, ..., <a_n>)
     Возвращает множество, содержащие элементы, общие для всех множеств
     <a_1>, ..., <a_n>.

     Функция ‘intersection’ вызывает ошибку, если хотя бы один из
     аргументов не является множеством.

     Примеры:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- Функция: kron_delta (<x>, <y>)

     Дельта-функция Кронекера.

     ‘kron_delta’ упрощается в 1, если <x> и <y> идентичны или очевидно
     эквивалентны, и упрощается в 0, если <x> и <y> очевидно не
     эквивалентны.  Иначе, если эквивалентность или неэквивалентность
     <x> и <y> не ясна, то ‘kron_delta’ упрощается в невычисляемую форму
     (noun).  По отношению к числам с плавающей точкой ‘kron_delta’
     реализует осторожный подход.  Если разница ‘<x> - <y>’ является
     числом с плавающей точкой, то ‘kron_delta’ упрощается в
     невычисляемую форму, даже когда <x> по-видимому эквивалентно <y>.

     Функция ‘kron_delta(<x>, <y>)’ упрощается в 1, если ‘is(x = y)’
     равно ‘true’.  ‘kron_delta’ тоже упрощается в 1, если ‘sign(abs(<x>
     - <y>))’ есть ‘zero’ и ‘<x> - <y>’ не является числом с плавающей
     точкой (ни обычное число с плавающей точкой, ни число с плавающей
     точкой повышенной точности).  ‘kron_delta’ упрощается в 0, если
     ‘sign(abs(<x> - <y>))’ равно ‘pos’.

     Если же ‘sign(abs(<x> - <y>))’ дает что-то отличное от ‘pos’ или
     ‘zero’, или ‘zero’ но ‘<x> - <y>’ есть число с плавающей точкой, то
     ‘kron_delta’ возвращает невычисляемое выражение.

     Функция ‘kron_delta’ объявлена симметричной.  Т.е.
     ‘kron_delta(<x>, <y>)’ равно ‘kron_delta(<y>, <x>)’.

     Примеры:

     Аргументы ‘kron_delta’ идентичны.  ‘kron_delta’ упрощается в 1.

          (%i1) kron_delta (a, a);
          (%o1)                           1
          (%i2) kron_delta (x^2 - y^2, x^2 - y^2);
          (%o2)                           1
          (%i3) float (kron_delta (1/10, 0.1));
          (%o3)                           1

     Аргументы ‘kron_delta’ эквивалентны, и их разница не есть число с
     плавающей точкой.  ‘kron_delta’ упрощается в 1.

          (%i1) assume (equal (x, y));
          (%o1)                     [equal(x, y)]
          (%i2) kron_delta (x, y);
          (%o2)                           1

     Аргументы ‘kron_delta’ не эквивалентны.  ‘kron_delta’ упрощается в
     0.

          (%i1) kron_delta (a + 1, a);
          (%o1)                           0
          (%i2) assume (a > b)$
          (%i3) kron_delta (a, b);
          (%o3)                           0
          (%i4) kron_delta (1/5, 0.7);
          (%o4)                           0

     Аргументы ‘kron_delta’ могут быть, а могут и не быть эквивалентны.
     ‘kron_delta’ упрощается в невычисляемое выражение.

          (%i1) kron_delta (a, b);
          (%o1)                   kron_delta(a, b)
          (%i2) assume(x >= y)$
          (%i3) kron_delta (x, y);
          (%o3)                   kron_delta(x, y)

     Аргументы ‘kron_delta’ эквивалентны, но их разница является числом
     с плавающей точкой.  ‘kron_delta’ упрощается в невычисляемое
     выражение.

          (%i1) 1/4 - 0.25;
          (%o1)                          0.0
          (%i2) 1/10 - 0.1;
          (%o2)                          0.0
          (%i3) 0.25 - 0.25b0;
          Warning:  Float to bigfloat conversion of 0.25
          (%o3)                         0.0b0
          (%i4) kron_delta (1/4, 0.25);
                                            1
          (%o4)                  kron_delta(-, 0.25)
                                            4
          (%i5) kron_delta (1/10, 0.1);
                                            1
          (%o5)                  kron_delta(--, 0.1)
                                            10
          (%i6) kron_delta (0.25, 0.25b0);
          Warning:  Float to bigfloat conversion of 0.25
          (%o6)               kron_delta(0.25, 2.5b-1)

     Функция ‘kron_delta’ симметрична.

          (%i1) kron_delta (x, y);
          (%o1)                   kron_delta(x, y)
          (%i2) kron_delta (y, x);
          (%o2)                   kron_delta(x, y)
          (%i3) kron_delta (x, y) - kron_delta (y, x);
          (%o3)                           0
          (%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
          (%o4)                         true
          (%i5) is (kron_delta (x, y) = kron_delta (y, x));
          (%o5)                         true

 -- Функция: listify (<a>)

     Возвращает список с элементами <a>, если <a> есть множество.  В
     противном случае ‘listify’ возвращает <a>.

     Функция ‘full_listify’ заменяет все операторы множества в <a> на
     операторы списка.

     Примеры:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- Функция: lreduce (<F>, <s>)
 -- Функция: lreduce (<F>, <s>, <s_0>)

     Расширяет бинарную функцию <F> до n-арной методом композиции.
     Аргумент <s> является списком.

     ‘lreduce(<F>, <s>)’ возвращает ‘F(... F(F(s_1, s_2), s_3), ...
     s_n)’.  Если присутствует необязательный аргумент <s_0>, то
     результат эквивалентен ‘lreduce(<F>, cons(<s_0>, <s>))’.

     Функция <F> сначала применяется к левой паре элементов списка,
     откуда происходит название "lreduce" (left reduce).

     См.  также ‘rreduce’, ‘xreduce’ и ‘tree_reduce’.

     Примеры:

     ‘lreduce’ без необязательного аргумента.

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     ‘lreduce’ с необязательным аргументом.

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     ‘lreduce’ примененная к встроенным бинарным операторам.  ‘/’ – есть
     оператор деления.

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d

 -- Функция: makeset (<expr>, <x>, <s>)

     Возвращает множество с элементами, сгенерированными из выражения
     <expr>, где <x> есть список переменных <expr>, а <s> есть множество
     или список списков.  Для определения элемента результирующего
     списка выражение <expr> вычисляется при переменных <x>, равным
     значениям из <s> (параллельное присваивание).

     Каждый член <s> должен иметь ту же длину, что и <x>.  Список
     переменных <x> должен быть списком символов без индексов.  Даже
     если символ только один, то <x> должен быть одноэлементным списком,
     а каждый член <s> должен быть одноэлементным списком.

     См.  также ‘makelist’.

     Примеры:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- Функция: moebius (<n>)

     Представляет функцию Мебиуса.

     Если <n> есть произведение k различных простых чисел, то
     ‘moebius(<n>)’ упрощается до (-1)^k.  Если <n> = 1, то функция
     упрощается в 1.  Для всех остальных положительных целых функция
     упрощается в 0.

     Функция ‘moebius’ дистрибутивна по отношению к уравнениям, спискам,
     матрицам и множествам.

     Примеры:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- Функция: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Функция: multinomial_coeff ()

     Возвращает мультиномиальный коэффициент.

     Если каждое <a_k> есть неотрицательное целое число, то
     мультиномиальный коэффициент дает число способов положить ‘<a_1> +
     ... + <a_n>’ различных объектов в n ящиков с <a_k> элементами в
     k-ом ящике.  В целом, ‘multinomial_coeff (<a_1>, ..., <a_n>)’ равна
     ‘(<a_1> + ... + <a_n>)!/(<a_1>! ... <a_n>!)’.

     ‘multinomial_coeff()’ (без аргументов) дает 1.

     ‘minfactorial’ может упрощать значения, возвращаемые
     ‘multinomial_coeff’.

     Примеры:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Функция: num_distinct_partitions (<n>)
 -- Функция: num_distinct_partitions (<n>, list)

     Возвращает число целочисленных разбиений с различными частями для
     <n>, если <n> – неотрицательное целое.  Иначе
     ‘num_distinct_partitions’ возвращает невычисляемую форму.

     ‘num_distinct_partitions(<n>, list)’ возвращает список чисел
     целочисленных разбиений с различными частями для 1, 2, 3, ..., <n>
     .

     Разбиение числа <n> с различными частями есть список различных
     положительных целых k_1, ..., k_m, таких что <n> = k_1 + ... + k_m.

     Примеры:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- Функция: num_partitions (<n>)
 -- Функция: num_partitions (<n>, list)

     Возвращает число целочисленных разбиений числа <n>, если <n> –
     неотрицательное целое.  Иначе ‘num_partitions’ возвращает
     невычисляемую форму.

     ‘num_partitions(<n>, list)’ возвращает список чисел целочисленных
     разбиений для 1, 2, 3, ..., <n>.

     Для неотрицательного целого <n>, ‘num_partitions(<n>)’ равна
     ‘cardinality(integer_partitions(<n>))’.  На самом деле
     ‘num_partitions’ не строит полное множество разбиений и поэтому
     работает значительно быстрее.

     Примеры:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- Функция: partition_set (<a>, <f>)

     Разбивает множество <a> в соответствии с предикатом <f>.

     Функция ‘partition_set’ возвращает список двух множеств.  Первое
     множество состоит из элементов <a>, для которых <f> равен ‘false’,
     а второе включает все остальные элементы <a>.  Функция
     ‘partition_set’ не применяет ‘is’ к возвращаемым <f> значениям.

     ‘partition_set’ вызывает ошибку, если <a> не является множеством.

     См.  также ‘subset’.

     Примеры:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                               lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Функция: permutations (<a>)

     Возвращает множество различных перестановок членов списка или
     множества <a>.  Каждая перестановка является списком.

     Если <a> является списком, то повторные члены <a> включаются в
     перестановки.

     ‘permutations’ вызывает ошибку, если <a> не является списком или
     множеством.

     См.  также ‘random_permutation’.

     Примеры:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- Функция: powerset (<a>)
 -- Функция: powerset (<a>, <n>)

     Возвращает множество всех подмножеств <a> или подмножество этого
     множества подмножеств.

     ‘powerset(<a>)’ возвращает множество всех подмножеств множества
     <a>.  ‘powerset(<a>)’ имеет ‘2^cardinality(<a>)’ членов.

     ‘powerset(<a>, <n>)’ возвращает множество подмножеств <a>, которые
     имеют мощность <n>.

     ‘powerset’ вызывает ошибку, если <a> не является множеством или <n>
     не есть целое число.

     Примеры:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- Функция: random_permutation (<a>)

     Возвращает случайную перестановку множества или списка <a>,
     построенную при помощи алгоритма тасования Кнута.

     Возвращаемое значение есть новый список, который отличен от
     исходного аргумента даже если все элементы совпадают.  Однако
     элементы списка не копируются.

     Примеры:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]

 -- Функция: rreduce (<F>, <s>)
 -- Функция: rreduce (<F>, <s>, <s_{n + 1}>)

     Расширяет бинарную функцию <F> до n-арной методом композиции.
     Аргумент <s> является списком.

     ‘rreduce(<F>, <s>)’ возвращает ‘F(s_1, ... F(s_{n - 2}, F(s_{n -
     1}, s_n)))’.  Если присутствует необязательный аргумент <s_{n +
     1}>, то результат эквивалентен ‘rreduce(<F>, endcons(<s_{n + 1}>,
     <s>))’.

     Функция <F> сначала применяется к правой паре элементов списка,
     откуда происходит название "rreduce" (right reduce).

     См.  также ‘lreduce’, ‘tree_reduce’ и ‘xreduce’.

     Примеры:

     ‘rreduce’ без необязательного аргумента.

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     ‘rreduce’ с необязательным аргументом.

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     ‘rreduce’ примененный к встроенным операторам.  ‘/’ – есть оператор
     деления.

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- Функция: setdifference (<a>, <b>)

     Возвращает множество, содержащее элементы множества <a>, которые
     отсутствуют в множестве <b>.

     ‘setdifference’ вызывает ошибку, если <a> или <b> не являются
     множествами.

     Примеры:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- Функция: setequalp (<a>, <b>)

     Возвращает ‘true’ если <a> и <b> имеют одинаковое количество
     элементов, и ‘is(<x> = <y>)’ равно ‘true’ для ‘x’ из <a> и ‘y’ из
     <b>, в порядке, определяемом ‘listify’.  Иначе ‘setequalp’
     возвращает ‘false’.

     Примеры:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- Функция: setify (<a>)

     Составляет множество из элементов списка <a>.  Повторяющиеся
     элементы списка <a> удаляются, а элементы результирующего множества
     сортируются в соответствии с предикатом ‘orderlessp’.

     ‘setify’ вызывает ошибку, если <a> не является списком.

     Примеры:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- Функция: setp (<a>)

     Возвращает ‘true’ тогда и только тогда, когда <a> является Maxima
     множеством.

     ‘setp’ возвращает ‘true’ как для неупрощенных множеств (т.е.
     содержащих излишние элементы), так и для упрощенных множеств.

     ‘setp’ is equivalent to the Maxima function ‘setp(a) := not atom(a)
     and op(a) = 'set’.

     Примеры:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- Функция: set_partitions (<a>)
 -- Функция: set_partitions (<a>, <n>)

     Возвращает множество разбиений <a> или подмножество этого
     множества.

     ‘set_partitions(<a>, <n>)’ возвращает множество всех разбиений <a>
     в <n> непустых непересекающихся подмножеств.

     ‘set_partitions(<a>)’ возвращает множество всех разбиений.

     ‘stirling2’ возвращает мощность множества всех разбиений множества.

     Множество множеств P есть разбиение множества S, если

       1. каждый элемент P есть непустое множество,
       2. различные члены P не пересекаются,
       3. объединение всех членов P равно S.

     Примеры:

     Пустое множество есть разбиение самого себя, т.к.  условия 1 и 2
     очевидно выполняются.

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     Мощность множества разбиений может быть определена при помощи
     ‘stirling2’.

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     Каждый элемент ‘p’ должен иметь <n> = 3 члена.  Проверим:

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     Наконец, для каждого члена ‘p’ объединение всех членов должно
     совпадать с ‘s’.  Проверим:

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- Функция: some (<f>, <a>)
 -- Функция: some (<f>, <L_1>, ..., <L_n>)

     Возвращает ‘true’, если предикат <f> дает ‘true’ для одного или
     более аргументов.

     Если второй параметр является множеством, то ‘some(<f>, <s>)’
     возвращает ‘true’, если ‘is(<f>(<a_i>))’ дает ‘true’ для одного или
     более <a_i> из <s>.  ‘some’ может вычислять <f> для всех или не для
     всех <a_i> из <s>.  Т.к.  множества не упорядочены, то ‘some’ может
     вычислять ‘<f>(<a_i>)’ в любом порядке.

     Если аргументы являются одним или несколькими списками, то
     ‘some(<f>, <L_1>, ..., <L_n>)’ возвращает ‘true’, если
     ‘is(<f>(<x_1>, ..., <x_n>))’ дает ‘true’ для одного или более
     <x_1>, ..., <x_n> из <L_1>, ..., <L_n> соответственно.  ‘some’
     может вычислять, а может и не вычислять <f> для некоторых
     комбинаций <x_1>, ..., <x_n>.  ‘some’ вычисляет списки в порядке
     возрастания индекса.

     Для пустого множества ‘{}’ или списка ‘[]’ ‘some’ возвращает
     ‘false’.

     Если глобальный флаг ‘maperror’ равен ‘true’, то все списки <L_1>,
     ..., <L_n> должны иметь одинаковую длину.  Если ‘maperror’ равен
     ‘false’, то списки обрезаются до длины самого короткого.

     Значения предиката <f> (вычисляемое посредством ‘is’) отличное от
     ‘true’ или ‘false’ управляется глобальным флагом ‘prederror’.  Если
     ‘prederror’ равен ‘true’, то такие значения трактуются как ‘false’.
     Если ‘prederror’ равен ‘false’, то такие значения трактуются как
     ‘unknown’.

     Примеры:

     Функция ‘some’, примененная к одному множеству.  Предикат есть
     функция одного аргумента.

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     Функция ‘some’, примененная к спискам.  Предикат есть функция двух
     аргументов.

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     Значение предиката <f>, отличное от ‘true’ или ‘false’, управляется
     глобальным флагом ‘prederror’.

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- Функция: stirling1 (<n>, <m>)

     Представляет число Стирлинга первого рода.

     Для неотрицательных целых <n> и <m> величина ‘stirling1 (<n>, <m>)’
     есть число перестановок множества из <n> элементов, имеющих <m>
     циклов.  См.  книгу Graham, Knuth и Patashnik Concrete Mathematics
     по поводу деталей.  Для определения ‘stirling1 (<n>, <m>)’ с <m>,
     меньшим нуля, Maxima использует рекуррентное соотношение.  Для <n>
     меньших нуля и нецелых аргументов функция не определена.

     ‘stirling1’ является упрощающей функцией.  Maxima знает следующие
     тождества.

       1. stirling1(0, n) = kron_delta(0, n) (См.  [1])
       2. stirling1(n, n) = 1 (См.  [1])
       3. stirling1(n, n - 1) = binomial(n, 2) (См.  [1])
       4. stirling1(n + 1, 0) = 0 (См.  [1])
       5. stirling1(n + 1, 1) = n! (См.  [1])
       6. stirling1(n + 1, 2) = 2^n - 1 (См.  [1])

     Эти тождества применяются, если аргументы являются целыми или
     символами, которые объявлены целыми, и первый аргумент
     неотрицателен.  Функция ‘stirling1’ не упрощается для нецелых
     аргументов.

     Ссылки:

     [1] Donald Knuth, The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     Примеры:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     Функция ‘stirling1’ не упрощается для нецелых аргументов.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima применяет тождества для ‘stirling1’.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Функция: stirling2 (<n>, <m>)

     Представляет число Стирлинга второго рода.

     Для неотрицательных целых <n> и <m> число ‘stirling2 (<n>, <m>)’
     есть число способов, которыми множество мощности <n> может быть
     разбито на <m> непересекающихся подмножеств.  Для определения
     ‘stirling2 (<n>, <m>)’ с <m>, меньшим нуля, Maxima использует
     рекуррентное соотношение.  Для <n> меньших нуля и нецелых
     аргументов функция не определена.

     ‘stirling2’ является упрощающей функцией.  Maxima знает следующие
     тождества.

       1. stirling2(0, n) = kron_delta(0, n) (См.  [1])
       2. stirling2(n, n) = 1 (См.  [1])
       3. stirling2(n, n - 1) = binomial(n, 2) (См.  [1])
       4. stirling2(n + 1, 1) = 1 (См.  [1])
       5. stirling2(n + 1, 2) = 2^n - 1 (См.  [1])
       6. stirling2(n, 0) = kron_delta(n, 0) (См.  [2])
       7. stirling2(n, m) = 0 when m > n (См.  [2])
       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m! если m и n целые и n неотрицательно.  (См.  [3])

     Эти тождества применяются, если аргументы являются целыми или
     символами, которые объявлены целыми, и первый аргумент
     неотрицателен.  Функция ‘stirling2’ не упрощается для нецелых
     аргументов.

     Ссылки:

     [1] Donald Knuth.  The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     [2] Graham, Knuth, and Patashnik.  Concrete Mathematics, Table 264.

     [3] Abramowitz and Stegun.  Handbook of Mathematical Functions,
     Section 24.1.4.

     Примеры:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     Функция ‘stirling2’ не упрощается для нецелых аргументов.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima применяет тождества для ‘stirling2’.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Функция: subset (<a>, <f>)

     Возвращает подмножество множества <a>, которое удовлетворяет
     предикату <f>.

     Функция ‘subset’ возвращает множество, состоящее из элементов <a>,
     для которых <f> возвращает любое значение, отличное от ‘false’.
     Функция ‘subset’ не применяет ‘is’ к значению, возвращаемому <f>.

     Функция ‘subset’ вызывает ошибку, если <a> не является множеством.

     См.  также ‘partition_set’.

     Примеры:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- Функция: subsetp (<a>, <b>)

     Возвращает ‘true’ тогда и только тогда, когда <a> есть подмножество
     <b>.

     Функция ‘subsetp’ вызывает ошибку, если <a> или <b> не являются
     множествами.

     Примеры:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- Функция: symmdifference (<a_1>, ..., <a_n>)

     Возвращает симметричную разницу, т.е.  множество, элементы которого
     присутствуют только в одном множестве <a_k>.

     При задании двух аргументов, ‘symmdifference(<a>, <b>)’
     эквивалентно ‘union ( setdifference (<a>, <b> ), setdifference
     (<b>, <a>))’.

     Функция ‘symmdifference’ вызывает ошибку, если любой из ее
     аргументов не является множеством.

     Примеры:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1, z}

 -- Функция: tree_reduce (<F>, <s>)
 -- Функция: tree_reduce (<F>, <s>, <s_0>)

     Расширяет бинарную функцию <F> до n-арной методом композиции.
     Аргумент <s> является множеством или списком.

     Функция ‘tree_reduce’ действует следующим образом: <F> применяется
     к последовательным парам элементов, чтобы сформировать новый список
     ‘[<F>(<s_1>, <s_2>), <F>(<s_3>, <s_4>), ...]’.  При этом если число
     элементов нечетно, то последний элемент остается неизменным.  Затем
     процесс повторяется до тех пор, пока не останется только один
     элемент списка, который и возвращается в качестве значения.

     Если присутствует необязательный элемент <s_0>, то результат
     эквивалентен ‘tree_reduce(<F>, cons(<s_0>, <s>)’.

     Для сложения чисел с плавающей точкой ‘tree_reduce’ может
     возвращать сумму с меньшей ошибкой округления, чем ‘rreduce’ или
     ‘lreduce’.

     Элементы <s> и частичные результаты могут быть представлены в виде
     бинарного дерева минимальной глубины, откуда происходит название
     "tree_reduce".

     Примеры:

     Функция ‘tree_reduce’, примененная к списку с четным числом
     элементов.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     Функция ‘tree_reduce’, примененная к списку с нечетным числом
     элементов.

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- Функция: union (<a_1>, ..., <a_n>)
     Возвращает объединение множеств от <a_1> до <a_n>.

     Вызов ‘union()’ (без аргументов) возвращает пустое множество.

     Функция ‘union’ возвращает ошибку, если любой из ее аргументов не
     является множеством.

     Примеры:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- Функция: xreduce (<F>, <s>)
 -- Функция: xreduce (<F>, <s>, <s_0>)

     Расширяет функцию <F> до n-арной методом композиции или, если <F>
     уже n-арная, применяет <F> к <s>.  Если <F> не является n-арной, то
     ‘xreduce’ работает также, как ‘lreduce’.  Аргумент <s> является
     списком.

     Известны следующие n-арные функции: сложение ‘+’, умножение ‘*’,
     ‘and’, ‘or’, ‘max’, ‘min’ и ‘append’.  Функции могут быть объявлены
     n-арными при помощи ‘declare(<F>, nary)’.  Для таких функций,
     ‘xreduce’ работает быстрее, чем ‘rreduce’ или ‘lreduce’.

     Если задан необязательный аргумент <s_0>, то результат эквивалентен
     ‘xreduce(<s>, cons(<s_0>, <s>))’.

     Сложение чисел с плавающей точкой, строго говоря, не является
     ассоциативным.  Функция ‘xreduce’ применяет n-арное сложение, если
     <s> содержит числа с плавающей точкой.

     Примеры:

     Функция ‘xreduce’, примененная к n-арной функции.  ‘F’ вызывается
     однажды со всеми аргументами.

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     Функция ‘xreduce’, примененная к не n-арной функции.  ‘G’
     вызывается несколько раз с двумя аргументами каждый раз.

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]

