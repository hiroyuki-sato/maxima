This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.

This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Введение в Maxima,  Prev: (dir),  Up: (dir)

Maxima Manual
*************

Maxima – система аналитических вычислений, написанная на Lisp.

   Maxima происходит от системы аналитических вычислений Macsyma,
разрабатывавшейся в MIT в период 1968 по 1982 в рамках проекта MAC. В
1982 году MIT передала копию исходного кода Macsyma Министерству
энергетики США (Department of Energy).  Данная версия известна как DOE
Macsyma.  Копия DOE Macsyma поддерживалась профессором Вильямом Шелтером
(William F. Schelter) из Техасского Университета с 1982 года вплоть до
его смерти в 2001 году.  В 1998 году Шелтер получил разрешение выпустить
исходный код DOE Macsyma под публичной лицензией GNU и в 2000 году
инициировал проект Maxima на SourceForge для поддержки и развития DOE
Macsyma, переименованной в Maxima.

* Menu:

Структура Maxima

* Введение в Maxima::                Пример сессии Maxima.
* Работа с ошибками::                Обнаружение ошибок и, как сообщить
                                     об ошибках в Maxima.
* Справка::                          Справочная система в сессии Maxima.
* Командная строка::                 Синтаксис командной строки Maxima.
* Операторы::                        Операторы, используемые в выражениях Maxima.
* Выражения::                        Выражения в Maxima.
* Simplification::                   Simplifying expressions.
* Plotting::                         2D and 3D graphical output.
* Ввод и вывод::                     Ввод и вывод файлов.
* Контексты::                        Наборы известных фактов.

Поддержка специальных разделов математики

* Polynomials::                      Standard forms for polynomials, and
                                     functions operating on them.
* Константы::                        Числовые и логические константы.
* Тригонометрия::                    Работа с выражениями, содержащими
                                     тригонометрические и братные
                                     тригонометрические функции.
* Special Functions::                Special functions
* Эллиптические функции::            Эллиптические функции и интегралы.
* Пределы::                          Вычисление пределов выражений.
* Differentiation::                  Differential calculus.
* Integration::                      Integral calculus.
* Equations::                        Defining and solving equations.
* Дифференциальные уравнения::       Определение и решение дифференциальных
                                     уравнений.
* Numerical::                        Numerical integration, Fourier
                                     transforms, etc.
* Массивы::                          Создание массивов и работа с ними.
* Matrices and Linear Algebra::      Matrix operations.
* Пакет affine::                      
* Пакет itensor::                    Индексные тензорные вычисления.
* Пакет ctensor::                    Компонентные тензорные вычисления.
* Пакет atensor::                    Вычисления с тензорными алгебрами.
* Sums Products and Series::         Taylor and power series.
* Теория чисел::                     Теория чисел.
* Symmetries::                  
* Groups::                           Abstract algebra.

Продвинутые возможности и программирование

* Окружение времени выполнения::     Настройка окружения времени выполнения
                                     Maxima.
* Вспомогательные опции::            Опции, имеющие глобальное влияние
                                     на работу Maxima.
* Правила преобразования и шаблоны:: Определяемые пользователем правила
                                     сопоставления с образцом и правила
                                     упрощения.
* Списки::                           Работа со списками.
* Множества::                        Работа с множествами.
* Определение функций::              Определение функций.
* Программы Maxima::                 Написание программ на языке Maxima.
* Отладка::                          Отладка Maxima программ.

Дополнительные пакеты

* Пакет augmented_lagrangian::    Пакет augmented_lagrangian.
* Пакет bode::                    Амплитудные и фазовые диаграммы Боде.
* Пакет contrib_ode::             Дополнительные процедуры для решения ОДУ.
* Пакет descriptive::             Описательная статистика.
* Пакет diag::                    Жордановы матрицы.
* Пакет distrib::                 Распределения вероятности.
* Пакет draw::                    Интерфейс Maxima к прогрпмме Gnuplot.
* Пакет dynamics::                Графика для динамических систем и фракталов.
* Пакет f90::                     Транслятор из Maxima в Fortran.
* ggf-pkg::                       Generating function of sequences.
* Пакет graphs::                  Теория графов.
* Пакет grobner::                 Функции для работы с базисом Гребнера.
* Пакет impdiff::                 Неявные производные.
* Пакет implicit_plot::           Графики неявных функций.
* Пакет interpol::                Интерполяция.
* lapack-pkg::                    LAPACK functions for linear algebra.
* lbfgs-pkg::                     L-BFGS unconstrained minimization package.
* lindstedt-pkg::                 Lindstedt package.
* linearalgebra-pkg::             Functions for linear algebra.
* lsquares-pkg::                  Least squares.
* makeOrders-pkg::                Polynomial utility.
* mnewton-pkg::                   Newton’s method.
* numericalio-pkg::               Reading and writing files.
* opsubst-pkg::                   Substitutions utility.
* orthopoly-pkg::                 Orthogonal polynomials.
* romberg-pkg::                   Romberg method for numerical integration.
* simplex-pkg::                   Linear programming.
* simplification-pkg::            Simplification rules and functions.
* solve_rec-pkg::                 Linear recurrences.
* stats-pkg::                     Statistical inference package.
* Пакет stirling::                Формула Стирлинга.
* stringproc-pkg::                String processing.
* unit-pkg::                      Units and dimensions package.
* zeilberger-pkg::                Functions for hypergeometric summation.


Индекс

* Указатель функций и переменных:: Указатель.

 — The Detailed Node Listing —

Введение

* Введение в Maxima::

Справка

* Lisp и Maxima::            
* Сборка мусора::          
* Документация::               
* Справочная система::        

Командная строка

* Введение в командную строку::  
* Функции и переменные для работы в командной строке::  

Операторы

* N-арные операторы (nary)::                        
* Безфиксные операторы (nofix)::                       
* Постфиксные операторы (postfix)::                     
* Префиксные операторы (prefix)::                      
* Арифметические операторы::   
* Операторы отношения::   
* Общие операторы::   

Выражения

* Основные сведения о выражениях::  
* Комплексные выражения::                     
* Невычисляемые и вычисляемые формы::
* Идентификаторы::
* Строки::
* Неравенства::                  
* Синтаксис::                      
* Функции и переменные для выражений::  

Simplification

* Functions and Variables for Simplification::  

Plotting

* Functions and Variables for Plotting::    

Ввод и вывод

* Комментарии::
* Файлы::                       
* Функции и переменные для ввода и вывода::

Контексты

* Функции для работы с контекстами::    

Polynomials

* Introduction to Polynomials::  
* Functions and Variables for Polynomials::  

Константы

* Математические константы::   

Тригонометрия

* Тригонометрия в Maxima::  
* Функции и переменные для тригонометрии::  

Special Functions

* Introduction to Special Functions::  
* Functions and Variables for Special Functions::  

Эллиптические функции

* Эллиптические функции и интегралы в Maxima::
* Функции и переменные для эллиптических функций::
* Функции и переменные для эллиптических интегралов::

Пределы

* Функции для работы с пределами::      

Differentiation

* Functions and Variables for Differentiation::  

Integration

* Introduction to Integration::  
* Functions and Variables for Integration::  

Equations

* Functions and Variables for Equations::   

Дифференциальные уравнения

* Дифференциальные уравнения в Maxima::  
* Функции и переменные для дифференциальных уравнений::  

Numerical

* Introduction to fast Fourier transform::                     
* Functions and Variables for fast Fourier transform::
* Functions and Variables for FFTPACK5::
* Functions for numerical solution of equations::
* Introduction to numerical solution of differential equations::
* Functions for numerical solution of differential equations::

Массивы

* Функции и переменные для работы с массивами::  

Matrices and Linear Algebra

* Introduction to Matrices and Linear Algebra::  
* Dot::                         
* Vectors::                     
* eigen::
* Functions and Variables for Matrices and Linear Algebra::  

Пакет affine

* Введение в пакет affine::      
* Функции и переменные пакета affine::      

Пакет itensor

* Введение в пакет itensor::      
* Функции и переменные пакета itensor::      

Пакет ctensor

* Введение в пакет ctensor::     
* Функции и переменные пакета ctensor::     

Пакет atensor

* Введение в пакет atensor::     
* Функции и переменные пакета atensor::     

Sums Products and Series

* Introduction to Series::      
* Functions and Variables for Series::      

Теория чисел

* Функции и переменные для теории чисел::  

Symmetries

* Functions and Variables for Symmetries::  

Groups

* Functions and Variables for Groups::      

Окружение времени выполнения

* Введение в окружение времени выполнения::  
* Прерывания::                  
* Функции и переменные времени выполнения::  

Вспомогательные опции

* Введение в вспомогательные опции::  
* Библиотека Share::                       
* Вспомогательные функции и переменные::  

Правила преобразования и шаблоны

* Введение в правила преобразований и шаблоны::  
* Функции и переменные для правил преобразования и шаблонов::  

Списки

* Ведение в работу со списками::
* Функции и переменные для работы со списками::

Множества

* Введение в работу с множествами::
* Функции и переменные для работы с множествами::

Определение функций

* Введение в определение функций::  
* Функции::                    
* Макросы::                      
* Функции и переменные для определения функций::  

Программы Maxima

* Введение в программирование на Maxima::  
* Функции и переменные для программирования на Maxima::  

Отладка

* Функции и переменные для отладки::   


Пакет augmented_lagrangian

* Функции и переменные пакета augmented_lagrangian::

Пакет bode

* Функции и переменные пакета bode::

Пакет contrib_ode

* Введение в пакет contrib_ode::
* Функции и переменные пакета contrib_ode::
* Возможные улучшения пакета contrib_ode::
* Тесты пакета contrib_ode::
* Ссылки для пакета contrib_ode::

Пакет descriptive

* Введение в пакет descriptive::
* Функции и переменные для манипулирования данными::
* Функции и переменные для описательной статистики::
* Функции и переменные для многомерной описательной статистики::
* Функции и переменные для статистических графиков::

Пакет diag

* Функции и переменные пакета diag::

Пакет distrib

* Введение в пакет distrib::
* Функции и переменные для непрерывных распределений::
* Функции и переменные для дискретных распределений::

Пакет draw

* Введение в пакет draw::
* Функции и переменные пакета draw::
* Функции и переменные для картин::
* Функции и переменные для карты мира::

Пакет dynamics

* Введение в пакет dynamics::
* Функции и переменные пакета dynamics::

Пакет f90

* Функции и переменные пакета f90::

ggf

* Functions and Variables for ggf::

Пакет graphs

* Введение в пакет graphs::
* Функции и переменные пакета graphs::

Пакет grobner

* Введение в пакет grobner::
* Функции и переменные пакета grobner::

Пакет impdiff

* Функции и переменные пакета impdiff::

Пакет implicit_plot

* Функции и переменные пакета implicit_plot::

Пакет interpol

* Введение в пакет interpol::
* Функции и переменные пакета interpol::

lapack

* Introduction to lapack::
* Functions and Variables for lapack::

lbfgs

* Introduction to lbfgs::
* Functions and Variables for lbfgs::

lindstedt

* Functions and Variables for lindstedt::

linearalgebra

* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::

lsquares

* Functions and Variables for lsquares::

makeOrders

* Functions and Variables for makeOrders::

mnewton

* Functions and Variables for mnewton::

numericalio

* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::

opsubst

* Functions and Variables for opsubst::

orthopoly

* Introduction to orthogonal polynomials::
* Functions and Variables for orthogonal polynomials::

romberg

* Functions and Variables for romberg::

simplex

* Introduction to simplex::
* Functions and Variables for simplex::

simplification

* Introduction to simplification::
* Package absimp::
* Package facexp::
* Package functs::
* Package ineq::
* Package rducon::
* Package scifac::

solve_rec

* Introduction to solve_rec::
* Functions and Variables for solve_rec::

stats

* Introduction to stats::
* Functions and Variables for inference_result::
* Functions and Variables for stats::
* Functions and Variables for special distributions::

Пакет stirling

* Формула Стирлинга::

stringproc

* Introduction to String Processing::
* String Input and Output::
* Characters::
* String Processing::
* Octets and Utilities for Cryptography::

unit

* Introduction to Units::       
* Functions and Variables for Units::

zeilberger

* Introduction to zeilberger::
* Functions and Variables for zeilberger::


File: maxima.info,  Node: Введение в Maxima,  Next: Работа с ошибками,  Prev: Top,  Up: Top

1 Введение в Maxima
*******************

Запустите Maxima с помощью команды "maxima".  Maxima покажет информацию
о версии и приглашение на ввод.  Завершайте каждую команду Maxima
символом ";" (или "$" в случае, если хотите подавить вывод команды).
Завершите сессию командой "quit();".  Пример сессии:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima может искать в info страницах.  Используйте команду ‘describe’
для того, чтобы получить информацию об определенной команде или показать
все команды и переменные, содержащие в имени заданную строку.  Знак
вопроса ‘?’ (точный поиск) и двойной вопрос ‘??’ (поиск по подстроке)
являются аббревиатурами для команды ‘describe’:

     (%i1) ?? integ
      0: Functions and Variables for Elliptic Integrals
      1: Functions and Variables for Integration
      2: Introduction to Elliptic Functions and Integrals
      3: Introduction to Integration
      4: askinteger  (Functions and Variables for Simplification)
      5: integerp  (Functions and Variables for Miscellaneous Options)
      6: integer_partitions  (Functions and Variables for Sets)
      7: integrate  (Functions and Variables for Integration)
      8: integrate_use_rootsof  (Functions and Variables for Integration)
      9: integration_constant_counter  (Functions and Variables for
         Integration)
      10: nonnegintegerp  (Functions and Variables for linearalgebra)
     Enter space-separated numbers, `all' or `none': 5 4

      -- Function: integerp (<expr>)
          Returns `true' if <expr> is a literal numeric integer, otherwise
          `false'.

          `integerp' returns false if its argument is a symbol, even if the
          argument is declared integer.

          Examples:

               (%i1) integerp (0);
               (%o1)                         true
               (%i2) integerp (1);
               (%o2)                         true
               (%i3) integerp (-17);
               (%o3)                         true
               (%i4) integerp (0.0);
               (%o4)                         false
               (%i5) integerp (1.0);
               (%o5)                         false
               (%i6) integerp (%pi);
               (%o6)                         false
               (%i7) integerp (n);
               (%o7)                         false
               (%i8) declare (n, integer);
               (%o8)                         done
               (%i9) integerp (n);
               (%o9)                         false


      -- Function: askinteger (<expr>, integer)
      -- Function: askinteger (<expr>)
      -- Function: askinteger (<expr>, even)
      -- Function: askinteger (<expr>, odd)
          `askinteger (<expr>, integer)' attempts to determine from the
          `assume' database whether <expr> is an integer.  `askinteger'
          prompts the user if it cannot tell otherwise, and attempt to
          install the information in the database if possible.  `askinteger
          (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

          `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
          likewise attempt to determine if <expr> is an even integer or odd
          integer, respectively.

     (%o1)                                true

   Для того, чтобы использовать результат в последующих вычислениях, Вы
можете присвоить его переменной или ссылаться на него через
автоматически создаваемую ссылку.  Кроме того, символ ‘%’ относится к
последнему вычисленному результату:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima знает о комплексных числах и численных константах:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima может производить дифференциальные и интегральные вычисления:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima может решать линейные системы и кубические уравнения:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima может решать нелинейные системы уравнений.  Напомним, что если
Вы не хотите, чтобы результат печатался, Вы можете завершить ввод
символом ‘$’ вместо ‘;’.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima может строить графики одной и более функций:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12],
           [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Работа с ошибками,  Next: Справка,  Prev: Введение в Maxima,  Up: Top

2 Работа с ошибками
*******************

* Menu:

* Функции и переменные для работы с ошибками::


File: maxima.info,  Node: Функции и переменные для работы с ошибками,  Up: Работа с ошибками

2.1 Функции и переменные для работы с ошибками
==============================================

 -- Функция: run_testsuite ()
 -- Функция: run_testsuite (<boolean>)
 -- Функция: run_testsuite (<boolean>, <boolean>)
 -- Функция: run_testsuite (<boolean>, <boolean>, <list>)
     Запускает встроенный набор тестов программы Maxima.  Тесты, дающие
     ожидаемый результат, рассматриваются как успешные.  Сюда относятся
     также тесты не дающие ожидаемый результат но помеченные как
     "известные ошибки".

     ‘run_testsuite ()’ показывает только неуспешные тесты.

     ‘run_testsuite (true)’ показывает неуспешные тесты и тесты
     помеченные как известные ошибки.

     ‘run_testsuite (true, true)’ показывает все тесты.

     Если задан необязательный третий аргумент, то выполняется указанное
     подмножество тестов, определяемое списком имен.  Полный список
     тестов хранится в переменной ‘testsuite_files’.

     Выполнение ‘run_testsuite’ изменяет окружение Maxima.  Обычно тест
     сначала выполняет ‘kill’, чтобы восстановить стандартное окружение
     (окружение без определенных пользователем функций и переменных), и
     после этого определяет функции и переменные, необходимые для теста.

     ‘run_testsuite’ возвращает ‘done’.

 -- Управляющая переменная: testsuite_files

     ‘testsuite_files’ набор тестов выполняемых ‘run_testsuite’.  Это
     список имен файлов содержащих соответствующие тесты.  Если
     известно, что определенные тесты дают неверный результат, то вместо
     имени файла используется список, содержащий имя файла и номера
     заведомо ошибочных тестов.

     Например, это часть стандартного набора тестов

           ["rtest13s", ["rtest14", 57, 63]]

     которая состоит из тестов находящихся в файлах "rtest13s" и
     "rtest14".  При этом "rtest14" содержит два заведомо ошибочных
     теста с номерами 57 и 63.

 -- Функция: bug_report ()
     Печатает версию Maxima, версию используемого Lisp и ссылку на
     интернет страницу где можно заполнить сообщение об ошибке.
     Информация о версиях программ та же, что дается функцией
     ‘build_info’.  При заполнении сообщения об ошибке желательно
     указать данную информацию.

     ‘bug_report’ возвращает пустую строку ‘""’.

 -- Функция: build_info ()
     Печатает информацию о сборке Maxima.

     ‘build_info’ возвращает пустую строку ‘""’.


File: maxima.info,  Node: Справка,  Next: Командная строка,  Prev: Работа с ошибками,  Up: Top

3 Справка
*********

* Menu:

* Lisp и Maxima::            
* Сборка мусора::          
* Документация::               
* Справочная система::        


File: maxima.info,  Node: Lisp и Maxima,  Next: Сборка мусора,  Prev: Справка,  Up: Справка

3.1 Lisp и Maxima
=================

Maxima написана на Lisp, поэтому легко получить доступ к Lisp функциям и
переменным из Maxima и наоборот.  Lisp и Maxima символы различают с
помощью соглашения об именах.  Lisp символ, который начинается со знака
‘$’ соответствует Maxima символу без знака доллара.  Maxima символ,
который начинается со знака ‘?’ соответствует Lisp символу без знака
вопроса.  Например, Maxima символ ‘foo’ соответствует Lisp символу
‘$foo’, в то время как Maxima символ ‘?foo’ соответствует Lisp символу
‘foo’, Заметим, что ‘?foo’ записано без пробелов между ‘?’ и ‘foo’;
иначе можно перепутать с ‘describe ("foo")’.

   ‘-’, ‘*’, и другие специальные знаки в Lisp символах должны быть
экранированы ‘\’ везде, где они появляются в коде Maxima.  Например,
Lisp идентификатор ‘*foo-bar*’ записывается как ‘?\*foo\-bar\*’ в
Maxima.

   Lisp код может быть выполнен из Maxima сессии.  Простая строка с Lisp
кодом (содержащая одну и более форм) может быть выполнена с помощью
специальной команды ‘:lisp’.  Например,

     (%i1) :lisp (foo $x $y)

вызывает Lisp функцию ‘foo’ с Maxima переменными ‘x’ и ‘y’ в качестве
аргументов.  ‘:lisp’ конструкция может появляться в интерактивном
приглашении или в файле, исполняемом командой ‘batch’ или ‘demo’, но
только не в файле исполняемом командами ‘load’, ‘batchload’,
‘translate_file’, или ‘compile_file’.

   Функция ‘to_lisp()’ открывает интегративную Lisp сессию.  Ввод
‘(to-maxima)’ закрывает Lisp сессию и возвращает к Maxima.

   Lisp функции и переменные, которые, как известно, видны в Maxima как
функции и переменные с обычными именами (без специальной пунктуации)
должны иметь Lisp имена, начинающиеся со знака ‘$’.

   Maxima чувствительна к регистру символов, различая буквы в нижнем и
верхнем регистрах, в идентификаторах, в то время как Lisp - нет.
Существуют некоторые правила, управляющие переводом имен между Lisp и
Maxima.

  1. Lisp идентификатор не заключенный в вертикальные черты
     соответствует Maxima идентификатору в нижнем регистре.  Является ли
     Lisp идентификатор в верхнем, нижнем, или смешанном регистре,
     регистр игнорируется.  То есть, Lisp ‘$foo’, ‘$FOO’, и ‘$Foo’ - все
     соответствуют Maxima ‘foo’.
  2. Lisp идентификатор, имеющий все знаки в нижнем или все знаки в
     верхнем регистре и заключенный в вертикальные черты, соответствует
     Maxima идентификатору с именем в обратном регистре.  То есть,
     верхний регистр меняется в нижний и нижний регистр - в верхний.
     Например, Lisp ‘|$FOO|’ и ‘|$foo|’ соответствуют Maxima ‘foo’ и
     ‘FOO’, в указанном порядке.
  3. Lisp идентификатор, который записан в смешанном регистре и
     заключенный в вертикальные черты соответствует Maxima
     идентификатору в том же регистре.  Например, Lisp ‘|$Foo|’
     соответствует Maxima ‘Foo’.

   ‘#$’ Lisp макрооператор позволяет использовать Maxima выражения в
Lisp коде.  ‘#$<expr>$’ превращается в Lisp выражение, эквивалентное
Maxima выражению <expr>.

     (msetq $foo #$[x, y]$)

   Это имеет тот же самый эффект как при вводе:

     (%i1) foo: [x, y];

Lisp функция ‘displa’ печатает выражение в Maxima форме.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Функции, заданные в Maxima не являются обычными Lisp функциями.  Lisp
функция ‘mfuncall’ вызывает Maxima функцию.  Например:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Некоторые Lisp функции скрыты в Maxima пакете, а именно такие как:

   ‘complement’, ‘continue’, ‘//’, ‘float’, ‘functionp’, ‘array’, ‘exp’,
‘listen’, ‘signum’, ‘atan’, ‘asin’, ‘acos’, ‘asinh’, ‘acosh’, ‘atanh’,
‘tanh’, ‘cosh’, ‘sinh’, ‘tan’, ‘break’ и ‘gcd’.


File: maxima.info,  Node: Сборка мусора,  Next: Документация,  Prev: Lisp и Maxima,  Up: Справка

3.2 Сборка мусора
=================

Вычисление в символьном виде имеют тенденцию создавать много “мусора”, и
эффективное управление этим мусором может стать решающим для успешного
выполнения некоторых программ.

   Под GCL, на UNIX системах, где доступны вызовы системы “mprotect”,
(включая SUN OS 4.0 и некоторые версии BSD) доступна прямая сборка
мусора.  Это ограничивает сборку страницами, в которые недавно
производилась запись.  См.  документацию по GCL по ключевым словам
ALLOCATE и GBC. На уровне Lisp, установка (setq si::*notify-gbc* t)
поможет вам определить, какие области памяти, возможно, требуют больше
пространства.


File: maxima.info,  Node: Документация,  Next: Справочная система,  Prev: Сборка мусора,  Up: Справка

3.3 Документация
================

Руководство пользователя Maxima можно просматривать в различных
форматах.  Из интерактивного приглашения Maxima, руководство
пользователя просматривается как обычный текст командой ‘?’ (то есть,
функция ‘describe’).  Руководство пользователя просматривается как
‘info’ гипертекст с помощью ‘info’ просмотрщиком и как веб-страница с
помощью обычного веб-браузера.

   ‘example’ показывает примеры для многих Maxima функций.  Например,

     (%i1) example (integrate);

   дает

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   и дополнительный вывод.


File: maxima.info,  Node: Справочная система,  Prev: Документация,  Up: Справка

3.4 Справочная система
======================

 -- Функция: demo (<filename>)
     вычисляет Maxima выражения в <filename> и показывает результаты.
     ‘demo’ останавливается после вычислений каждого выражения и
     продолжает после того, как пользователь нажмет “Enter”.  (Если
     запущена Xmaxima, ‘demo’ необходимо перед вводом ставить ‘;’).

     ‘demo’ просматривает список директорий ‘file_search_demo’, чтобы
     найти ‘filename’.  Если файл имеет расширение ‘dem’, то его можно
     опустить.  См.  также ‘file_search’.

     ‘demo’ вычисляет свои аргументы.  ‘demo’ возвращает имя
     демонстрационного файла.

     Пример:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load("disol")

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load("rncomb")

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)

 -- Функция: describe (<string>)
 -- Функция: describe (<string>, exact)
 -- Функция: describe (<string>, inexact)

     ‘describe(<string>)’ эквивалентно ‘describe(<string>, exact)’.

     ‘describe(<string>, exact)’ ищет элемент, с заголовком равным
     (независимо от регистра) <string>, если такой элемент есть.

     ‘describe(<string>, inexact)’ ищет все документированные элементы,
     которые содержат <string> в своих заголовках.  Если есть более чем
     один такой элемент, Maxima спросит пользователя выбрать элемент или
     несколько элементов для отображения.

     В интерактивном приглашении, ‘? foo’ (с пробелом между ‘?’ и ‘foo’)
     эквивалентно ‘describe("foo", exact)’, и ‘?? foo’ эквивалентно
     ‘describe("foo", inexact)’.

     ‘describe("", inexact)’ дает список всех тем, документированных в
     руководстве пользователя.

     ‘describe’ не вычисляет свой аргумент.  ‘describe’ возвращает
     ‘true’ если документация найдена, ‘false’ в противном случае.

     См.  также *note Документация::.

     Пример:

          (%i1) ?? integ
           0: Functions and Variables for Elliptic Integrals
           1: Functions and Variables for Integration
           2: Introduction to Elliptic Functions and Integrals
           3: Introduction to Integration
           4: askinteger  (Functions and Variables for Simplification)
           5: integerp  (Functions and Variables for Miscellaneous Options)
           6: integer_partitions  (Functions and Variables for Sets)
           7: integrate  (Functions and Variables for Integration)
           8: integrate_use_rootsof  (Functions and Variables for
              Integration)
           9: integration_constant_counter  (Functions and Variables for
              Integration)
           10: nonnegintegerp  (Functions and Variables for linearalgebra)
          Enter space-separated numbers, `all' or `none': 7 8

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a
               definite integral, [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of
               a rational function cannot be factored, `integrate' returns
               the integral in a form which is a sum over the roots (not yet
               known) of the denominator.
               [...]

     В этом примере, были выбраны элементы 7 и 8 (вывод команды
     сокращен, что обозначено ‘[...]’).  Все элементы или ни один из
     элементов могут быть выбраны при помощи ‘all’ или ‘none’, что можно
     также сократить до ‘a’ и ‘n’ соотвественно.

 -- Функция: example (<topic>)
 -- Функция: example ()
     ‘example (<topic>)’ показывает некоторые примеры для символа
     <topic> (не строки).  Большинство <topic> являются именами функций.
     ‘example ()’ возвращает список всех доступных <topic>.

     Имя файла содержащего эти примеры задано глобальной переменной
     ‘manual_demo’, которая исходно равна ‘"manual.demo"’.

     ‘example’ не вычисляет свой аргумент.  ‘example’ возвращает ‘done’
     только если нет ошибки или отсутствия аргумента.  ‘example’
     возвращает список всех подходящих тем.

     Примеры:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done


File: maxima.info,  Node: Командная строка,  Next: Операторы,  Prev: Справка,  Up: Top

4 Командная строка
******************

* Menu:

* Введение в командную строку::
* Функции и переменные для работы в командной строке::


File: maxima.info,  Node: Введение в командную строку,  Next: Функции и переменные для работы в командной строке,  Prev: Командная строка,  Up: Командная строка

4.1 Введение в командную строку
===============================

 -- Оператор: '
     Оператор "одиночная кавычка" ‘'’ предотвращает вычисление, иными
     словами "экранирует" свой аргумент.

     Примененный к символу, оператор "одиночная кавычка" предотвращает
     вычисление этого символа.

     Примененный к вызову функции, оператор "одиночная кавычка"
     предотвращает вычисление этой функции, но не вычисление ее
     аргументов (если оно не предотвращено по другим причинам).
     Результатом является невычисляемая (noun) форма вызова функции.

     Примененный к выражению в скобках, предотвращает вычисление всех
     функций и символов внутри скобок.  Например, ‘'(f(x))’ означает –
     не вычислять выражение ‘f(x)’, тогда как ‘'f(x)’ (кавычка
     примененная к ‘f’ а не к ‘f(x)’) означает – невычисляемая форма
     ‘f’, примененная к ‘[x]’.

     Одиночная кавычка не предотвращает упрощение.

     Когда глобальный флаг ‘noundisp’ имеет значение ‘true’,
     невычисляемые формы функций выводятся с одиночной кавычкой.  Этот
     переключатель всегда установлен равным ‘true’ при печати
     определений функций.

     См.  также оператор "кавычка-кавычка" ‘''’ и ‘nouns’.

     Примеры:

     Примененный к символу, оператор "одиночная кавычка" предотвращает
     вычисление этого символа.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Примененный к вызову функции, оператор "одиночная кавычка"
     предотвращает вычисление этой функции.  Результатом является
     невычисляемая форма вызова функции.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Примененный к выражению в скобках, предотвращает вычисление всех
     функций и символов внутри скобок.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     Одиночная кавычка не предотвращает упрощение.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

 -- Оператор: ''
     Оператор "кавычка-кавычка" ‘''’ (две одиночные кавычки) изменяет
     вычисление вводимого выражения.

     Примененный к выражению общего вида <expr>, кавычка-кавычка
     вызывает подстановку значения <expr> вместо <expr> в вводимом
     выражении.

     Примененный к оператору в выражении, кавычка-кавычка изменяет
     невычисляемую форму оператора на вычисляемую (если она не является
     таковой).

     Оператор кавычка-кавычка применяется при синтаксическом анализе
     вводимого выражения и не сохраняется как часть этого выражения.
     Оператор кавычка-кавычка применяется сразу после распознавания и не
     может быть экранирован.

     Оператор кавычка-кавычка распознается функциями ‘batch’ и ‘load’.

     См.  также оператор "кавычка" ‘'’ и ‘nouns’.

     Примеры:

     Примененный к выражению общего вида <expr>, кавычка-кавычка
     вызывает подстановку значения <expr> вместо <expr> в вводимом
     выражении.

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     Примененный к оператору в выражении, кавычка-кавычка изменяет
     невычисляемую форму оператора на вычисляемую (если она не является
     таковой).

          (%i1) sin (1);
          (%o1)                        sin(1)
          (%i2) ''sin (1);
          (%o2)                    0.8414709848079
          (%i3) declare (foo, noun);
          (%o3)                         done
          (%i4) foo (x) := x - 1729;
          (%o4)                 ''foo(x) := x - 1729
          (%i5) foo (100);
          (%o5)                       foo(100)
          (%i6) ''foo (100);
          (%o6)                        - 1629

     Оператор кавычка-кавычка применяется при синтаксическом анализе
     вводимого выражения и не сохраняется как часть этого выражения.

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     Оператор кавычка-кавычка вызывает вычисление в случаях когда оно
     заблокировано, таких как определения функций, лямбда-выражения и
     выражения, экранированные оператором кавычка ‘'’.

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i4) integrate (log (x), x);
          (%o4)                     x log(x) - x
          (%i5) foo_2a (x) := ''%;
          (%o5)               foo_2a(x) := x log(x) - x
          (%i6) foo_2b (x) := %;
          (%o6)                    foo_2b(x) := %
          (%i7) dispfun (foo_2a, foo_2b);
          (%t7)               foo_2a(x) := x log(x) - x

          (%t8)                    foo_2b(x) := %

          (%o8)                      [%t7, %t8]
          (%i8) F : lambda ([u], diff (sin (u), u));
          (%o8)             lambda([u], diff(sin(u), u))
          (%i9) G : lambda ([u], ''(diff (sin (u), u)));
          (%o9)                  lambda([u], cos(u))
          (%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o11)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1


File: maxima.info,  Node: Функции и переменные для работы в командной строке,  Prev: Введение в командную строку,  Up: Командная строка

4.2 Функции и переменные для работы в командной строке
======================================================

 -- Функция: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     создает альтернативное имя для пользовательской или системной
     функции, переменной, массива и т.п.  Данная функция может иметь
     любое число парных аргументов.

 -- Управляющая переменная: debugmode
     Значение по умолчанию: ‘false’

     Если во время работы Maxima возникла ошибка, Maxima запускает
     отладчик если значение переключателя ‘debugmode’ равно ‘true’.  В
     отладчике пользователь может исследовать значения стека, установить
     точки останова, просматривать код и т.д.  См.  ‘debugging’ для
     списка команд отладчика.

     Отладчик Maxima, включаемый с помощью ‘debugmode’, не обрабатывает
     ошибки на уровне Lisp.

 -- Функция: ev (<expr>, <arg_1>, ..., <arg_n>)
     Вычисляет выражение <expr> в окружении определяемом аргументами
     <arg_1>, ..., <arg_n>.  Данные аргументы могут быть переключателями
     (логические флаги), присваиваниями, уравнениями и функциями.  ‘ev’
     возвращает результат вычисления (выражение).

     Вычисление осуществляется в несколько шагов.

       1. Сначала окружение устанавливается в соответствии с
          аргументами, которые могут быть одним из следующего:

             • ‘simp’ вызывает упрощение выражения <expr> вне
               зависимости от текущего значения переключателя ‘simp’
               (отключает упрощение если равен ‘false’).
             • ‘noeval’ отключает вычисление для данной стадии ‘ev’ (см.
               шаг (4) ниже).  Это может быть полезно в комбинации с
               другими переключателями и вызывает повторное упрощение
               <expr> без перевычисления.
             • ‘nouns’ вызывает вычисление невычисляемых (noun) форм
               (обычно это невычисляемые функции, такие как ‘'integrate’
               или ‘'diff’) в <expr>.
             • ‘expand’ вызывает раскрытие скобок.
             • ‘expand (<m>,<n>)’ вызывает раскрытие скобок при
               ‘maxposex’ и ‘maxnegex’ равным <m> и <n> соответственно.
             • ‘detout’ при вычислении обратных матриц в <expr>,
               сохраняет определитель матрицы как общий множитель вместо
               того чтобы делить на него каждый элемент матрицы в
               отдельности.
             • ‘diff’ вызывает вычисление всех производных в <expr>.
             • ‘derivlist (<x>, <y>, <z>, ...)’ вызовет вычисление
               производных только относительно указанных переменных.
             • ‘float’ вызывает преобразование нецелых рациональных
               чисел в числа с плавающей точкой.
             • ‘numer’ вызывает численное вычисление математических
               функций (включая экспоненты), имеющих числовые аргументы.
               Вызывает замену переменных, имеющих числовые значения
               (см.  ‘numerval’), этими значениями.  Устанавливает
               значение переключателя ‘float’ равным ‘true’.
             • ‘pred’ вызывает вычисление предикатов (выражений,
               значение которых ‘true’ или ‘false’).
             • ‘eval’ вызывает дополнительное пост-вычисление <expr>
               (см.  шаг (5) ниже).  ‘eval’ может встречаться несколько
               раз.  Для каждого ‘eval’ выражение вычисляется еще раз.
             • ‘A’, где ‘A’ есть атом, являющийся флагом вычисления (см.
               ‘evflag’), устанавливает значение ‘A’ равным ‘true’ в
               процессе вычисления <expr>.
             • ‘V: expression’ (или альтернативно ‘V=expression’)
               присваивает ‘V’ значение ‘expression’ в процессе
               вычисления <expr>.  Если ‘V’ является управляющей
               переменной (опцией) Maxima, тогда значение ‘expression’
               используется в качестве значения опции в процессе
               вычисления <expr>.  Если имеется более одного аргумента
               ‘ev’ данного типа, то присваивание осуществляется
               параллельно.  Если ‘V’ является не атомарным выражением,
               то вместо присваивания осуществляется подстановка.
             • ‘F’, где ‘F’ есть имя функции, являющейся функцией
               вычисления (см.  ‘evfun’) вызывает применение ‘F’ к
               <expr>.
             • Любые другие имена функций (скажем ‘sum’) вызывают
               вычисление этих функций в <expr>, так как если бы они
               имели вычисляемую форму.
             • Кроме того, встречающаяся в <expr> функция (скажем
               ‘F(x)’) может быть локально определена для вычисления
               <expr>, путем задания аргумента в форме ‘F(x) :=
               expression’.
             • Если в качестве аргумента указан любой, не указанный выше
               атом, или переменная с индексом, или выражение с
               индексом, то данный аргумент вычисляется.  Если
               результатом вычисления является уравнение или
               присваивание, то выполняется соответствующее присваивание
               или подстановка.  Если результатом вычисления является
               список, то элементы этого списка трактуются как
               дополнительные аргументы ‘ev’.  Это, в частности,
               позволяет использовать список уравнений (например ‘[X=1,
               Y=A**2]’), или список имен уравнений (например ‘[%t1,
               %t2]’, где ‘%t1’ и ‘%t2’ являются результатом работы
               функции ‘solve’.

          Аргументы ‘ev’ могут быть указаны в произвольном порядке за
          исключением уравнений, которые выполняются последовательно
          слева направо, и составных вычисляющих функций (например ‘ev
          (<expr>, ratsimp, realpart)’ выполняется как ‘realpart
          (ratsimp (<expr>))’).

          Переключатели ‘simp’, ‘numer’, ‘float’ и ‘pred’ могут быть
          установлены локально в блоке, или глобально.  В последнем
          случае они будут действовать до переопределения.

          Если выражение <expr> является каноническим рациональным
          выражением (КРВ, canonical rational expression (CRE)), тогда
          результатом ‘ev’ тоже является КРВ, если только переключатели
          ‘numer’ и ‘float’ оба не равны ‘true’.

       2. На шаге (1), составляется список не-индексированных переменных
          входящих в левые части аргументов, являющихся уравнениями, или
          в значения аргументов, если эти значения являются уравнениями.
          Переменные (индексированные, которые не имеют соответствующих
          функций массивов, и не-индексированные) в выражении <expr>
          заменяются на свои глобальные значения, за исключением тех,
          которые входят в вышеуказанный список.  Обычно, <expr> это
          просто метка ‘%’ (как ‘%i2’ в примере ниже), так что на данном
          шаге просто получается выражение, обозначаемое данной меткой.

       3. Если среди аргументов имеются подстановки, то они выполняются.

       4. Полученное выражение снова вычисляется (если одним из
          аргументов не является ‘noeval’) и упрощается в соответствии с
          заданными аргументами.  Все вызовы функций в <expr>
          выполняются после вычисления переменных.  Таким образом
          ‘ev(F(x))’ трактуется как ‘F(ev(x))’.

       5. Для каждого ‘eval’, шаги (3) и (4) повторяются.

     Примеры:

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Имеется альтернативный синтаксис функции ‘ev’, который может
     использоваться только на верхнем уровне: аргументы ‘ev()’
     перечисляются через запятую после выражения.  Т.е.  можно просто
     написать

          <expr>, <arg_1>, ..., <arg_n>

     Такая конструкция недопустима как часть другого выражения, функции,
     блока и т.п.

     Обратите внимание на параллельное присваивание в следующих
     примерах.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true

 -- Свойство: evflag
     Если символ <x> имеет свойство ‘evflag’, то выражения ‘ev(<expr>,
     <x>)’ и ‘<expr>, <x>’ (в интерактивной командной строке)
     эквивалентны ‘ev(<expr>, <x> = true)’.  Т.е.  <x> имеет значение
     ‘true’ в процессе вычисления <expr>.

     Выражение ‘declare(<x>, evflag)’ устанавливает свойство ‘evflag’
     для переменной <x>.

     Следующие переключатели имеют по умолчанию свойство ‘evflag’:
     ‘algebraic’, ‘cauchysum’, ‘demoivre’, ‘dotscrules’, ‘%emode’,
     ‘%enumer’, ‘exponentialize’, ‘exptisolate’, ‘factorflag’, ‘float’,
     ‘halfangles’, ‘infeval’, ‘isolate_wrt_times’, ‘keepfloat’,
     ‘letrat’, ‘listarith’, ‘logabs’, ‘logarc’, ‘logexpand’,
     ‘lognegint’, ‘lognumer’, ‘m1pbranch’, ‘numer_pbranch’,
     ‘programmode’, ‘radexpand’, ‘ratalgdenom’, ‘ratfac’, ‘ratmx’,
     ‘ratsimpexpons’, ‘simp’, ‘simpsum’, ‘sumexpand’ и ‘trigexpand’.

     Примеры:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES

 -- Свойство: evfun
     Если функция <F> имеет свойство ‘evfun’, то выражения ‘ev(<expr>,
     <F>)’ и ‘<expr>, <F>’ (в интерактивной командной строке)
     эквивалентны ‘<F>(ev(<expr>))’.

     Если заданы две или более ‘evfun’ функций <F>, <G>, то функции
     применяются в порядке задания.

     Выражение ‘declare(<F>, evfun)’ устанавливает свойство ‘evfun’ для
     функции <F>.

     Следующие функции имеют по умолчанию свойство ‘evfun’: ‘bfloat’,
     ‘factor’, ‘fullratsimp’, ‘logcontract’, ‘polarform’, ‘radcan’,
     ‘ratexpand’, ‘ratsimp’, ‘rectform’, ‘rootscontract’, ‘trigexpand’ и
     ‘trigreduce’.

     Примеры:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))

 -- Управляющая переменная: infeval
     Включает режим "бесконечного вычисления".  ‘ev’ вычисляет выражение
     повторно до тех пор пока оно не перестает изменяться.  Чтобы
     предотвратить вычисление отдельной переменной, скажем ‘X’, в данном
     режиме следует указать ‘X='X’ в качестве аргумента ‘ev’.
     Разумеется, выражения вроде ‘ev (X, X=X+1, infeval)’ приводят к
     бесконечному циклу.

 -- Функция: kill (<a_1>, ..., <a_n>)
 -- Функция: kill (labels)
 -- Функция: kill (inlabels, outlabels, linelabels)
 -- Функция: kill (<n>)
 -- Функция: kill ([<m>, <n>])
 -- Функция: kill (values, functions, arrays, ...)
 -- Функция: kill (all)
 -- Функция: kill (allbut (<a_1>, ..., <a_n>))

     Удаляет все связи (значение, функцию, массив или правило)
     аргументов <a_1>, ..., <a_n>.  Аргумент <a_k> может быть символом
     или отдельным элементом массива.  Если <a_k> является отдельным
     элементом массива, то ‘kill’ удаляет значение одного этого элемента
     и не затрагивает другие элементы массива.

     Распознается несколько специальных форм аргументов.  При этом
     аргументы различных типов могут быть скомбинированы, например ‘kill
     (inlabels, functions, allbut (foo, bar))’.

     ‘kill (labels)’ очищает значение меток ввода, результата и меток
     промежуточных выражений, определенных на момент вызова.  ‘kill
     (inlabels)’ очищает значение меток ввода, имена которых начинаются
     с текущего значения ‘inchar’.  Аналогично, ‘kill (outlabels)’
     очищает значение меток результата, имена которых начинаются с
     текущего значения ‘outchar’, и ‘kill (linelabels)’ очищает значение
     меток промежуточных выражений, имена которых начинаются с текущего
     значения ‘linechar’.

     ‘kill (<n>)’, где <n> является целым числом, очищает значение <n>
     первых меток ввода и результата.

     ‘kill ([<m>, <n>])’ очищает метки ввода и результата с номерами от
     <m> до <n> включительно.

     ‘kill (<infolist>)’, где <infolist> есть один из информационных
     списков ‘infolists’ (например ‘values’, ‘functions’ или ‘arrays’),
     очищает значение всех элементов в <infolist>.  См.  также
     ‘infolists’.

     ‘kill (all)’ очищает значения всех элементов во всех информационных
     списках (infolists).  ‘kill (all)’ не восстанавливает стандартные
     значения глобальных переменных.  См.  ‘reset’ по поводу
     восстановления стандартных значений глобальных переменных.

     ‘kill (allbut (<a_1>, ..., <a_n>))’ очищает все элементы во всех
     информационных списках кроме <a_1>, ..., <a_n>.  ‘kill (allbut
     (<infolist>))’ очищает все элементы кроме тех, которые принадлежат
     информационному списку <infolist>, где <infolist> есть ‘values’,
     ‘functions’, ‘arrays’ и т.д.

     Отметим, что для освобождения памяти, занимаемой значением символа,
     необходимо очистить все объекты ссылающиеся на это значение.
     Необходимо не только очистить сам символ, но и результирующую метку
     указывающую на его значение.

     Функция ‘kill’ не вычисляет свои аргументы.  Для их вычисления
     можно использовать оператор кавычка-кавычка ‘''’.

     ‘kill (<symbol>)’ очищает все свойства символа <symbol> в отличии
     от ‘remvalue’, ‘remfunction’, ‘remarray’ и ‘remrule’, которые
     очищают только определенное свойство.

     ‘kill’ всегда возвращает ‘done’ даже если аргументы не имели
     значения.

 -- Функция: labels (<symbol>)
 -- Системная переменная: labels
     Возвращает список меток ввода, результата или меток промежуточных
     выражений, имена которых начинаются с символа <symbol>.  Обычно
     <symbol> это значение ‘inchar’, ‘outchar’ или ‘linechar’.  Значение
     <symbol> может быть указано с или без знака процента, например ‘i’
     и ‘%i’ дадут одинаковый результат.

     Если ни одна из меток не начинается с <symbol>, то возвращается
     пустой список.

     Функция ‘labels’ не вычисляет свои аргументы.  Для их вычисления
     можно использовать оператор кавычка-кавычка ‘''’.  Например,
     ‘labels (''inchar)’ возвращает список меток ввода, имена которых
     начинаются с текущего значения символа ввода.

     Переменная ‘labels’ есть список всех меток ввода, результата и
     меток промежуточных выражений, включая все предыдущие метки если
     значение ‘inchar’, ‘outchar’ или ‘linechar’ изменялось.

     По умолчанию Maxima выводит результат каждого входного выражения
     присваивая ему результирующую метку.  Печать результата можно
     подавить используя для окончания выражения символ ‘$’ вместо
     обычного ‘;’.  В этом случае метка результата создается но сам
     результат вычисления не печатается.  Тем не менее значение метки
     результата запоминается и в дальнейшем может быть использовано как
     обычно.  См.  также ‘%’, ‘%%’ и ‘%th’.

     Метки промежуточных выражений создаются некоторыми функциями.
     Переключатель ‘programmode’ определяет будет ли команда ‘solve’, и
     некоторые другие функции, создавать промежуточные метки или
     возвращать список выражений.  Некоторые другие функции, такие как
     ‘ldisplay’, всегда создают метки промежуточных выражений.

     См.  также ‘inchar’, ‘outchar’, ‘linechar’ и ‘infolists’.

 -- Системная переменная: linenum
     Порядковый номер текущей пары входного и результирующего выражений.

 -- Системная переменная: myoptions
     Значение по умолчанию: ‘[]’

     ‘myoptions’ есть список всех переключателей (флагов)
     переопределенных пользователем вне зависимости от того имеет ли в
     данный момент переключатель значение по умолчанию или нет.

 -- Управляющая переменная: nolabels
     Значение по умолчанию: ‘false’

     Если ‘nolabels’ равна ‘true’, то метки ввода и результата (‘%i’ и
     ‘%o’, соответственно) печатаются но результирующее значение этим
     меткам не присваивается а сами метки не добавляются к списку
     ‘labels’.  Поскольку результаты вычислений не присваиваются меткам,
     то сборщик мусора может освободить занимаемую ими память для
     дальнейшего использования.

     В противном случае меткам ввода и меткам результата присваиваются
     соответствующие значения а сами метки добавляются к списку
     ‘labels’.

     Флаг ‘nolabels’ не влияет на метки промежуточных выражений (‘%t’).
     Независимо от значения ‘nolabels’ равного ‘true’ или ‘false’,
     меткам промежуточных выражений присваиваются значение и они
     добавляются к списку ‘labels’.

     См.  также ‘batch’, ‘load’ и ‘labels’.

 -- Управляющая переменная: optionset
     Значение по умолчанию: ‘false’

     Если ‘optionset’ равно ‘true’, Maxima печатает сообщение при
     изменении значения любого переключателя (опция, флаг) Maxima.  Это
     может быть полезно, когда пользователь не уверен в написании
     названия опции и хочет быть уверен, что он переопределил значение
     правильной переменной.

 -- Функция: playback ()
 -- Функция: playback (<n>)
 -- Функция: playback ([<m>, <n>])
 -- Функция: playback ([<m>])
 -- Функция: playback (input)
 -- Функция: playback (slow)
 -- Функция: playback (time)
 -- Функция: playback (grind)
     Выводит значения входных, результирующих и промежуточных выражений
     без их перевычисления.  ‘playback’ выводит только выражения
     связанные с метками – любой другой вывод (текст выведенный ‘print’
     или ‘describe’, сообщения об ошибках) не отображается.  См.  также
     ‘labels’.

     Функция ‘playback’ не вычисляет свои аргументы.  Для их вычисления
     можно использовать оператор кавычка-кавычка ‘''’.  ‘playback’
     возвращает значение ‘done’.

     ‘playback ()’ (без аргументов) печатает все входные, результирующие
     и промежуточные выражения.  Результирующие выражения печатаются
     даже в случае, когда во время первоначальных вычислений
     использовался ‘$’ для подавления печати результата.

     ‘playback (<n>)’ печатает <n> последних выражений.  Каждое входное,
     результирующее и промежуточное выражение считается за одно.

     ‘playback ([<m>, <n>])’ печатает входные, результирующие и
     промежуточные выражения с номерами от <m> до <n> включительно.

     ‘playback ([<m>])’ эквивалентно ‘playback ([<m>, <m>])’ и обычно
     печатает одну пару из входного и результирующего выражений.

     ‘playback (input)’ печатает все входные выражения.

     ‘playback (slow)’ останавливается между выражениями и ожидает пока
     пользователь нажмет "ввод" (‘enter’).  Данное поведение аналогично
     команде ‘demo’.  ‘playback (slow)’ полезно в сочетании с ‘save’ или
     ‘stringout’ для выбора выражений, которые надо сохранить в файле.

     ‘playback (time)’ показывает время вычисления для каждого
     выражения.

     ‘playback (grind)’ печатает входные выражения в формате функции
     ‘grind’.  На результирующие выражения данная опция не влияет.  См.
     ‘grind’.

     Аргументы функции ‘playback’ могут быть скомбинированы, например
     ‘playback ([5, 10], grind, time, slow)’.

 -- Функция: printprops (<a>, <i>)
 -- Функция: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Функция: printprops (all, <i>)
     Печатает свойство с именем <i>, ассоциированное с атомом <a>.  <a>
     может быть списком атомов или ‘all’.  В последнем случае будут
     использованы все атомы имеющие данное свойство.  Например,
     ‘printprops ([f, g], atvalue)’.  Функция ‘printprops’ предназначена
     для свойств, которые не могут быть отображены другим способом,
     например для ‘atvalue’, ‘atomgrad’, ‘gradef’ и ‘matchdeclare’.

 -- Управляющая переменная: prompt
     Значение по умолчанию: ‘_’

     ‘prompt’ символ приглашения для функции ‘demo’, ‘playback (slow)’ и
     диалога прерывания Maxima (break loop) (см.  ‘break’).

 -- Функция: quit ()
     Завершает сессию Maxima.  Команда должна быть введена именно как
     ‘quit();’ или ‘quit()$’, а не просто ‘quit’.

     Для прерывания длительных вычислений можно нажать ‘control-C’.  При
     этом по умолчанию Maxima возвращается на верхний уровень к
     приглашению ввода следующей команды.  Если значение Lisp-переменной
     ‘*debugger-hook*’ равно ‘nil’, тогда нажатие ‘control-C’ запускает
     Lisp отладчик.  См.  также ‘debugging’.

 -- Функция: remfunction (<f_1>, ..., <f_n>)
 -- Функция: remfunction (all)
     Удаляет определенные пользователем функции <f_1>, ..., <f_n>.
     Аргументы могут быть именами обычных функций, созданных при помощи
     ‘:=’ или ‘define’, или макро функций, созданных при помощи ‘::=’.

     ‘remfunction (all)’ – удаляет все определенные пользователем
     функции.

     ‘remfunction’ не вычисляет свои аргументы.

     ‘remfunction’ возвращает список символов, для которых было удалено
     определение функции.  Для символов, у которых не было
     соответствующих определений функций, возвращается ‘false’.

     Функция ‘remfunction’ не применима к функциям массивам и переменным
     с индексом, к этим типам функций применима ‘remarray’.

 -- Функция: reset ()
     Восстанавливает значения по умолчанию для глобальных переменных,
     опций и некоторых других переменных.

     ‘reset’ восстанавливает значения переменных хранящихся в Lisp
     списке ‘*variable-initial-values*’.  Lisp макрос ‘defmvar’
     добавляет переменные в этот список (вместе с выполнением других
     действий).  Многие, но не все, глобальные переменные и опции
     определены с помощью ‘defmvar’; некоторые, определенные с помощью
     ‘defmvar’ переменные, не являются глобальными переменными или
     опциями.

 -- Управляющая переменная: showtime
     Значение по умолчанию: ‘false’

     Если ‘showtime’ равно ‘true’ Maxima печатает время вычисления для
     каждого результирующего выражения.

     Время вычисления всегда запоминается, так что ‘time’ и ‘playback’
     могут показать это время даже если ‘showtime’ равно ‘false’.

     См.  также ‘timer’.

 -- Функция: sstatus (<feature>, <package>)
     Устанавливает статус <feature> в <package>.  После выполнения
     ‘sstatus (<feature>, <package>)’, ‘status (<feature>, <package>)’
     возвращает ‘true’.  Этот механизм может быть полезен при работе с
     пакетами для того, чтобы иметь возможность проверять какие опции
     пакета загружены.

 -- Функция: to_lisp ()
     Запускает интерпретатор используемой Lisp системы.  Lisp функция
     ‘(to-maxima)’ возвращает на уровень командной строки Maxima.

 -- Function: eval_string_lisp (<str>)

     Sequentially read lisp forms from the string <str> and evaluate
     them.  Any values produced from the last form are returned as a
     Maxima list.

     Examples:

          (%i1) eval_string_lisp ("");
          (%o1) []
          (%i2) eval_string_lisp ("(values)");
          (%o2) []
          (%i3) eval_string_lisp ("69");
          (%o3) [69]
          (%i4) eval_string_lisp ("1 2 3");
          (%o4) [3]
          (%i5) eval_string_lisp ("(values 1 2 3)");
          (%o5) [1,2,3]
          (%i6) eval_string_lisp ("(defun $foo (x) (* 2 x))");
          (%o6) [foo]
          (%i7) foo (5);
          (%o7) 10

     See also *note eval_string::.

 -- Системная переменная: values
     Начальное значение: ‘[]’

     ‘values’ содержит список всех пользовательских переменных, которым
     присвоено значение (не Maxima опций и переключателей).  Этот список
     состоит из символов, которым было присвоено значение при помощи
     операторов ‘:’, ‘::’ или ‘:=’.


File: maxima.info,  Node: Операторы,  Next: Выражения,  Prev: Командная строка,  Up: Top

5 Операторы
***********

* Menu:

* N-арные операторы (nary)::                        
* Безфиксные операторы (nofix)::                       
* Постфиксные операторы (postfix)::                     
* Префиксные операторы (prefix)::                      
* Арифметические операторы::   
* Операторы отношения::   
* Общие операторы::   


File: maxima.info,  Node: N-арные операторы (nary),  Next: Безфиксные операторы (nofix),  Prev: Операторы,  Up: Операторы

5.1 N-арные операторы (nary)
============================

N-арный ‘nary’ оператор используется для того, чтобы задать функцию
любого числа аргументов, каждый из которых разделен оператором, например
A+B или A+B+C. Функция ‘nary("x")’ - синтаксическое расширение функции
для объявления ‘x’ как n-арный оператор.  Функции могут быть объявлены
n-арными.  Если ‘declare(j,nary);’ выполнено, это указывает упрощателю
(simplifier) то, что требуется упрощение, то есть, например,
‘j(j(a,b),j(c,d))’ упростится до ‘j(a, b, c, d)’.

   См.  также ‘Синтаксис’.


File: maxima.info,  Node: Безфиксные операторы (nofix),  Next: Постфиксные операторы (postfix),  Prev: N-арные операторы (nary),  Up: Операторы

5.2 Безфиксные операторы (nofix)
================================

Безфиксные операторы (‘nofix’, операторы без аргументов) используются,
чтобы обозначить функции без аргументов.  Простое присутствие такого
оператора в команде вызовет то, что соответствующая функция будет
вычислена.  Например, когда набирают "exit;" для выхода из Maxima,
"exit" ведет себя аналогично безфиксному оператору.  Функция
‘nofix("x")’ - это функция расширения, которая объявляет ‘x’ как
безфиксный оператор.

   См.  также ‘Синтаксис’.


File: maxima.info,  Node: Постфиксные операторы (postfix),  Next: Префиксные операторы (prefix),  Prev: Безфиксные операторы (nofix),  Up: Операторы

5.3 Постфиксные операторы (postfix)
===================================

Постфиксные операторы (‘postfix’), как и префиксные операторы,
обозначают функции одного аргумента, но в этом случае этот аргумент
непосредственно предшествует появлению этого оператора в входной строке,
например 3!.  Функция ‘postfix("x")’ - это функция синтаксического
расширения, которая объявлять ‘x’ как постфиксный оператор.

   См.  также ‘Синтаксис’.


File: maxima.info,  Node: Префиксные операторы (prefix),  Next: Арифметические операторы,  Prev: Постфиксные операторы (postfix),  Up: Операторы

5.4 Префиксные операторы (prefix)
=================================

Префиксный оператор (‘prefix’) обозначает функцию одного аргумента,
который непосредственно идет за вхождением оператора.  ‘prefix("x")’ -
это функция синтаксического расширения, которая объявляет ‘x’ как
префиксный оператор.

   См.  также ‘Синтаксис’.


File: maxima.info,  Node: Арифметические операторы,  Next: Операторы отношения,  Prev: Префиксные операторы (prefix),  Up: Операторы

5.5 Арифметические операторы
============================

 -- Оператор: +
 -- Оператор: -
 -- Оператор: *
 -- Оператор: /
 -- Оператор: ^

     Символы ‘+’, ‘*’, ‘/’ и ‘^’ обозначают суммирование, умножение,
     деление и возведение в степень, соответственно.  Имена этих
     операторов ‘"+"’, ‘"*"’, ‘"/"’ и ‘"^"’ могут появляться там, где
     требуется имя функции или оператора.

     Символы ‘+’ и ‘-’ представляют унарное суммирование и вычитание,
     соответственно, и имена этих операторов: ‘"+"’ и ‘"-"’,
     соответственно.

     Вычитание ‘a - b’ представляется в Maxima как суммирование ‘a + (-
     b)’.  Выражения, такие как ‘a + (- b)’, отображаются как вычитание.
     Maxima распознает ‘"-"’ только как имя унарного оператора
     вычитания, а не как имя бинарного оператора вычитания.

     Деление ‘a / b’ представляется в Maxima как умножение, ‘a * b^(-
     1)’.  Выражения, такие как ‘a * b^(- 1)’, отображаются как деление.
     Maxima распознает ‘"/"’ как имя оператора деления.

     Суммирование и умножение - n-арные (n-ary), коммутативные
     операторы.  Деление и возведение в степень - бинарные,
     некоммутативные операторы.

     Maxima сортирует операнды коммутативных операторов для
     конструирования канонического представления.  Во внутреннем
     хранилище упорядочивание управляется с помощью ‘orderlessp’.  Для
     отображения, упорядочивание при суммировании управляется с помощью
     ‘ordergreatp’, а для умножения, флаг тот же, что и для внутреннего
     упорядочивания.

     Арифметические вычисления выполняются для буквальных чисел (целых,
     рациональных, обыкновенных чисел с плавающей точкой и чисел с
     плавающей точкой повышенной точности (bigfloat)).  За исключением
     возведения в степень, все арифметические операции для чисел
     упрощаются до чисел.  Возведение в степень упрощается до числа, в
     случае если, либо операнд является обыкновенным числом с плавающей
     точкой или числом с плавающей точкой повышенной точности
     (bigfloat), или если результат есть точное целое или рациональное
     число; иначе возведение в степень может быть упрощено до ‘sqrt’ или
     другого возведения в степень, или оставлено неизменным.

     В арифметических вычислениях имеет место приведение типов значений
     результата: если любой операнд есть bigfloat, то результат будет
     bigfloat; или же, если любой операнд есть обыкновенное число с
     плавающей точкой, результат будет обыкновенным числом с плавающей
     точкой; или же, если операнды являются рациональными или целыми
     значениями, то результат будет рациональным или целым.

     Арифметические вычисления являются упрощением, а не в вычислением.
     Таким образом, арифметические операции выполняется в экранированных
     (но упрощенных) выражениях.

     Арифметические операции применяются элемент-за-элементом к спискам,
     когда глобальный флаг ‘listarith’ есть ‘true’, и всегда применяется
     элемент-за-элементом к матрицам.  Когда один операнд есть список
     или матрица и другой есть операнд некоторого другого типа, то
     другой операнд объединяется с каждым из элементом списка или
     матрицы.

     Примеры:

     Суммирование и умножение являются n-арными (n-ary) коммутативными
     операторами.  Maxima сортирует операнды для того, чтобы
     сконструировать каноническое представление.  Имена этих операторов
     ‘"+"’ и ‘"*"’.

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     Деление и возведение в степень - бинарные, некоммутативные
     операторы.  Имена этих операторов ‘"/"’ и ‘"^"’.

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     Вычитание и деление внутренне представляются в терминах
     суммирования и умножения, соответственно.

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     Вычисления выполняются над буквальными числами.  Выполняется
     приведение типов значений результата.

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     Арифметические вычисления являются упрощением, а не вычислением.

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     Арифметические операции выполняется элемент-за-элементом для
     списков (в зависимости от значения ‘listarith’) и матриц.

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);
                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]

 -- Оператор: **
     Оператор возведения в степень.  Maxima распознает ‘**’ как тот же
     оператор, что и ‘^’ при вводе, и он отображается как ‘^’ в 1D
     (одномерном) выводе, или в виде показателя степени как верхний
     индекс в 2D (двумерном) выводе.

     Функция ‘fortran’ выводит оператор возведения в степень как ‘**’,
     не в зависимости от того, как он был задан при вводе, как ‘**’ или
     ‘^’.

     Примеры:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done


File: maxima.info,  Node: Операторы отношения,  Next: Общие операторы,  Prev: Арифметические операторы,  Up: Операторы

5.6 Операторы отношения
=======================

 -- Оператор: <
 -- Оператор: <=
 -- Оператор: >=
 -- Оператор: >

     Символы ‘<’ , ‘<=’ , ‘>=’ и ‘>’ представляют отношения меньше,
     меньше или равно, больше или равно и больше, соответственно.  Имена
     этих операторов есть ‘"<"’ , ‘"<="’ , ‘">="’ и ‘">"’.  Эти имена
     могут применяться в случае, если требуется имя функции или
     оператора.

     Данные операторы отношения являются бинарными.  Конструкции типа ‘a
     < b < c’ недопустимы в Maxima.

     Операторы отношения вычисляются до логических значений функциями
     ‘is’ и ‘maybe’, и программными конструкциями ‘if’, ‘while’ и
     ‘unless’.  В других случаях операторы отношения не вычисляются или
     упрощаются до логических значений, хотя аргументы операторов
     отношения вычисляются (если вычисление не блокировано при помощи
     оператора кавычка).

     Если выражение отношения не может быть вычислено до логического
     значения ‘true’ или ‘false’, то поведение ‘is’ и ‘if’ управляется
     глобальным флагом ‘prederror’.  Если значение ‘prederror’ равно
     ‘true’, то ‘is’ и ‘if’ вызывает ошибку.  Если значение ‘prederror’
     равно ‘false’, то ‘is’ возвращает ‘unknown’ а ‘if’ возвращает
     частично-вычисленное условное выражение.

     ‘maybe’ всегда ведет себя так, если бы ‘prederror’ равнялось
     ‘false’, а ‘while’ и ‘unless’ всегда ведут себя так, если бы
     ‘prederror’ равнялось ‘true’.

     Операторы отношения не дистрибутивны по отношению к спискам и
     другим конструкциям.

     См.  также ‘=’ , ‘#’ , ‘equal’ и ‘notequal’.

     Примеры:

     Операторы отношения вычисляются до логических значений некоторыми
     функциями и программными конструкциями.

          (%i1) [x, y, z] : [123, 456, 789];
          (%o1)                    [123, 456, 789]
          (%i2) is (x < y);
          (%o2)                         true
          (%i3) maybe (y > z);
          (%o3)                         false
          (%i4) if x >= z then 1 else 0;
          (%o4)                           0
          (%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i, return (S));
          (%o5)                         5050

     Во всех других случаях операторы отношения не вычисляются или
     упрощаются до логических значений, хотя их аргументы вычисляются.

          (%o1)                    [123, 456, 789]
          (%i2) [x < y, y <= z, z >= y, y > z];
          (%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
          (%i3) map (is, %);
          (%o3)               [true, true, true, false]


File: maxima.info,  Node: Общие операторы,  Prev: Операторы отношения,  Up: Операторы

5.7 Общие операторы
===================

 -- Оператор: ^^

     Оператор некоммутативного возведение в степень.  ‘^^’ - оператор
     некоммутативного возведение в степень, соответствующий
     некоммутативному умножению ‘.’, ровно так же как обычный оператор
     возведение в степень ‘^’ соответствует коммутативному умножению
     ‘*’.

     Некоммутативное возведение в степень отображается как ‘^^’ в 1D
     (одномерном) выводе, и в виде показателя степени как верхний индекс
     в угловых скобка ‘< >’ в 2D (двумерном) выводе.

     Примеры:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3

 -- Оператор: !
     Оператор факториала.  Для всех комплексных чисел ‘x’ (включая
     целые, рациональные, и вещественные числа), за исключением
     отрицательных целых, ‘x!’ задается как ‘gamma(x+1)’.

     Для целого ‘x’, ‘x!’ упрощается до произведения целых чисел от 1 до
     ‘x’ включительно.  ‘0!’ упрощается до 1.  Для чисел с плавающей
     точкой ‘x’, ‘x!’ упрощается до значения ‘gamma (x+1)’.  Для ‘x’
     равных ‘n/2’, где ‘n’ - нечетное целое, ‘x!’ упрощается до
     рационального множителя, умноженного на ‘sqrt (%pi)’ (т.  к.
     ‘gamma (1/2)’ равно ‘sqrt (%pi)’).  Если ‘x’ - что то еще, то ‘x!’
     не упрощается.

     Переменные ‘factlim’, ‘minfactorial’ и ‘factcomb’ управляют
     упрощением выражений, содержащих факториалы.

     Функции ‘gamma’, ‘bffac’ и ‘cbffac’ являются разновидностями гамма
     функции.  ‘makegamma’ заменяет ‘gamma’ для факториалов и связанных
     функций.

     См.  также ‘binomial’.

     Факториал целого, полуцелого или аргумента с плавающей точкой,
     упрощается если операнд не больше чем ‘factlim’.

          (%i1) factlim : 10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
                      105 sqrt(%pi)
          (%o2)   [1, -------------, 81.44668037931199, 40320, 20!]
                           16

     Факториал комплексного числа, известной константы, или выражение
     общего вида не упрощается.  Но в этом случае возможно упростить
     факториал после вычисления операнда.

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [(%i + 1)!, 7.188082728976037, 4.260820476357,
                                                         1.227580202486819]

     Факториал символа, не имеющего значения, не упрощается.

          (%i1) kill (foo);
          (%o1)                         done
          (%i2) foo!;
          (%o2)                         foo!

     Факториалы упрощаются, а не вычисляются.  Таким образом, ‘x!’ можно
     заменять даже в экранированном (quoted) выражении.

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]

 -- Оператор: !!
     Оператор двойного факториала.

     Для целого, числа с плавающей точкой или рационального числа ‘n’,
     ‘n!!’ вычисляется как произведение ‘n (n-2) (n-4) (n-6) ... (n - 2
     (k-1))’ где ‘k’ равно ‘entier (n/2)’, то есть, наибольшее целое
     меньше или равное ‘n/2’.  Заметим, что это определение не совпадает
     с другими опубликованными определениями для нецелых аргументов.

     Для четного (или нечетного) целого ‘n’, ‘n!!’ вычисляется как
     произведение всех последовательных четных (или нечетных) целых от 2
     (или 1) до ‘n’ включительно.

     Для аргумента ‘n’, который не является целым, числом с плавающей
     точкой, или рациональным числом, ‘n!!’ дает невычисляемую форму
     ‘genfact (n, n/2, 2)’.

 -- Оператор: #
     Обозначает отрицание синтаксического равенства ‘=’.

     Заметим, что из-за правил для вычисления предикатных выражений (в
     частности из-за того, что ‘not <expr>’ вызывает вычисление <expr>),
     ‘not <a> = <b>’ эквивалентно ‘is(<a> # <b>)’, вместо ‘<a> # <b>’.

     Примеры:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true

 -- Оператор: .
     Оператор "точка" предназначен для матричного (некоммутативного)
     умножения.  Когда ‘"."’ используется таким образом, пробелы должны
     присутствовать с обеих сторон, то есть ‘A . B’.  Это позволяет
     различать оператор от десятичной точки в числе с плавающей точкой.

     См.  также ‘dot’, ‘dot0nscsimp’, ‘dot0simp’, ‘dot1simp’,
     ‘dotassoc’, ‘dotconstrules’, ‘dotdistrib’, ‘dotexptsimp’,
     ‘dotident’, и ‘dotscrules’.

 -- Оператор: :
     Оператор присваивания.

     Если левая сторона есть простая переменная (не переменная с
     индексом), то ‘:’ вычисляет правую сторону присваивания и
     присваивает значение с левой частью.

     Если левая строна есть индексированный элемент списка, матрица,
     объявленного Maxima массива или Lisp массива, то значение правой
     части присваивается этому элементу.  Индекс должен выделять
     существующий элемент.  Подобные конструкции нельзя расширить на
     несуществующие элементы.

     Если левая сторона есть индексированный элемент необъявленного
     массива, то значение правой части присваивается этому элементу,
     если таковой уже существует, или вновь созданному объекту, если он
     еще не существует.

     Если левая строна присваивания есть список простых переменных и/или
     переменных с индексом, то правая часть должна вычисляться в список,
     и элементы этого списка присваиваются элементам левой части
     параллельно.

     См.  также ‘kill’ и ‘remvalue’, которые отменяют присваивание.

     Примеры:

     Присваивание простой переменной.

          (%i1) a;
          (%o1)                           a
          (%i2) a : 123;
          (%o2)                          123
          (%i3) a;
          (%o3)                          123

     Присваивание элементу списка.

          (%i1) b : [1, 2, 3];
          (%o1)                       [1, 2, 3]
          (%i2) b[3] : 456;
          (%o2)                          456
          (%i3) b;
          (%o3)                      [1, 2, 456]

     Присваивание создает необъявленный массив.

          (%i1) c[99] : 789;
          (%o1)                          789
          (%i2) c[99];
          (%o2)                          789
          (%i3) c;
          (%o3)                           c
          (%i4) arrayinfo (c);
          (%o4)                   [hashed, 1, [99]]
          (%i5) listarray (c);
          (%o5)                         [789]

     Множественные присваивания.

          (%i1) [a, b, c] : [45, 67, 89];
          (%o1)                     [45, 67, 89]
          (%i2) a;
          (%o2)                          45
          (%i3) b;
          (%o3)                          67
          (%i4) c;
          (%o4)                          89

     Множественные присваивания выполняются параллельно.  В этом примере
     переменные ‘a’ и ‘b’ обмениваются значениями.

          (%i1) [a, b] : [33, 55];
          (%o1)                       [33, 55]
          (%i2) [a, b] : [b, a];
          (%o2)                       [55, 33]
          (%i3) a;
          (%o3)                          55
          (%i4) b;
          (%o4)                          33

 -- Оператор: ::
     Оператор присваивания.

     Оператор ‘::’ аналогичен оператору присваивания ‘:’ за исключением
     того, что ‘::’ вычисляет свою левую часть наряду с вычислением
     правой части.

     Примеры:

          (%i1) x : 'foo;
          (%o1)                          foo
          (%i2) x :: 123;
          (%o2)                          123
          (%i3) foo;
          (%o3)                          123
          (%i4) x : '[a, b, c];
          (%o4)                       [a, b, c]
          (%i5) x :: [11, 22, 33];
          (%o5)                     [11, 22, 33]
          (%i6) a;
          (%o6)                          11
          (%i7) b;
          (%o7)                          22
          (%i8) c;
          (%o8)                          33

 -- Оператор: ::=
     Оператор определения макро функции.  ‘::=’ задает функцию
     (называемую "макрос" по историческим причинам) которое экранирует
     (quote) свои аргументы, и выражение, которое она возвращает
     (называемое "макро расширение"), вычисляется в том контексте, из
     которого этот макрос был вызван.  В других отношениях макро функция
     такая же как и обыкновенная функция.

     Функция ‘macroexpand’ возвращает макро расширение (без ее
     вычисления).  ‘macroexpand (foo (x))’ следующее за ‘''%’
     эквивалентно ‘foo (x)’, где ‘foo’ есть макро функция.

     Оператор ‘::=’ помещает имя новой макро функции в глобальный список
     ‘macros’.  Функции ‘kill’, ‘remove’ и ‘remfunction’ удаляет
     определения макро функций и удаляет имена из ‘macros’.

     Функции ‘fundef’ или ‘dispfun’, соответственно, возвращает
     определение макро функции или присваивает его метке.

     Макро функции обычно содержат ‘buildq’ и ‘splice’ выражения для
     конструирования выражения, которое затем вычисляется.

     Примеры.

     Макро функция экранирует свои аргументы, так что сообщение (1)
     показывает выражение ‘y - z’, а не значение ‘y - z’.  Макро
     расширение (экранированное выражение ‘'(print ("(2) x равно ", x))’
     вычисляется в том контексте, из которого этот макрос был вызван,
     печатая сообщение (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)));
          (%o4) printq1(x) ::= block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                          %pi

     Обыкновенная функция вычисляет свои аргументы, так что сообщение
     (1) показывает значение ‘y - z’.  Возвращаемое значение не
     вычисляется, так что сообщение (2) не печатается до момента явного
     вычисления ‘''%’.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)));
          (%o4) printe1(x) := block(print("(1) x is equal to", x),
                                          '(print("(2) x is equal to", x)))
          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)              print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                          %pi

     Функция ‘macroexpand’ возвращает макро расширение.  Выражение
     ‘macroexpand (foo (x))’, идущее перед ‘''%’ эквивалентно ‘foo (x)’,
     когда ‘foo’ есть макро функция.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x));
          (%o4)    g(x) ::= buildq([x], print("x is equal to", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                     1234 - 1729 w

 -- Оператор: :=

     Оператор определения функции.

     ‘<f>(<x_1>, ..., <x_n>) := <expr>’ определяет функцию с именем <f>,
     аргументами <x_1>, ..., <x_n> и телом функции <expr>.  Оператор
     ‘:=’ никогда не вычисляет тело функции (если только вычисление не
     задано явно оператором кавычка-кавычка ‘''’).  Функция заданная
     таким образом может быть обыкновенной Maxima функцией (с
     аргументами, заключенными в скобки) или функцией массивом (с
     аргументами, заключенными в квадратные скобки).

     Когда последний или единственный аргумент функции <x_n> есть список
     из одного элемента, функция, заданная ‘:=’ принимает переменное
     число аргументов.  Фактические аргументы присваиваются один-в-один
     формальным аргументам <x_1>, ..., <x_(n - 1)>, и любые дальнейшие
     фактические аргументы, если присутствуют, присваиваются к <x_n> как
     список.

     Все определения функций появляются в том же пространстве имен;
     задав функцию ‘f’ внутри другой функции ‘g’, определение не
     ограничивает зону видимости ‘f’ в ‘g’.

     Если некоторый формальный аргумент <x_k> есть экранированный
     (quoted) символ, функция, заданная с помощью ‘:=’, не вычисляет
     соответствующий фактический аргумент.  В противном случае, все
     фактические аргументы вычисляются.

     См.  также ‘define’ и ‘::=’.

     Примеры:

     ‘:=’ никогда не вычисляет тело функции (если только явно не задано
     вычисление).

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     Функция, заданная ‘:=’, может быть обыкновенной Maxima функцией или
     функцией массивом.

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     Когда последний или единственный аргумент функции <x_n> есть список
     из одного элемента, функция, заданная ‘:=’, принимает переменное
     число аргументов.

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

 -- Оператор: =
     Оператор равенства.

     Выражение ‘<a> = <b>’, само по себе, представляет собой
     невычисляемое уравнение, которое может или может не выполняться.
     Невычисляемые уравнения могут появляться как аргументы в ‘solve’ и
     ‘algsys’, или в некоторых других функциях.

     Функция ‘is’ вычисляет ‘=’ до логического значения.  ‘is(<a> =
     <b>)’ вычисляет ‘<a> = <b>’ в ‘true’, когда <a> и <b> тождественны.
     То есть, <a> и <b> есть атомы, которые идентичны, или они не атомы
     и их операторы идентичны и их аргументы идентичны.  В противном
     случае, ‘is(<a> = <b>)’ вычисляется в ‘false’; он никогда не
     вычисляется в ‘unknown’.  Когда ‘is(<a> = <b>)’ есть ‘true’,
     говорят что <a> и <b> синтаксически равны, в противоположность
     эквивалентным выражениям, для которых ‘is(equal(<a>, <b>))’ есть
     ‘true’.  Выражения могут быть равны, но синтаксически не равны.

     Отрицание ‘=’ представляется как ‘#’.  Как и в случае с ‘=’,
     выражение ‘<a> # <b>’, само по себе, не вычисляется.  ‘is(<a> #
     <b>)’ вычисляется ‘<a> # <b>’ до ‘true’ или ‘false’.

     Кроме ‘is’, некоторые другие операторы вычисляют ‘=’ и ‘#’ до
     ‘true’ или ‘false’, а именно ‘if’, ‘and’, ‘or’ и ‘not’.

     Заметим, что из-за правил для вычисления предикатных выражений (в
     частности из-за того, что ‘not <expr>’ вызывает вычисление <expr>),
     ‘not <a> = <b>’ эквивалентно ‘is(<a> # <b>)’, а не ‘<a> # <b>’.

     ‘rhs’ и ‘lhs’ возвращают правую и левую часть уравнения или
     неравенства соответственно.

     См.  также ‘equal’ или ‘notequal’.

     Примеры:

     Выражение ‘<a> = <b>’, само по себе, представляет невычисляемое
     уравнение, которое может или может не выполняться.

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     ‘is(<a> = <b>)’ вычисляет ‘<a> = <b>’ в ‘true’, когда <a> и <b>
     тождественны (синтаксически равны).  Выражения могут быть равны, но
     синтаксически не равны.

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     Некоторые операторы вычисляют ‘=’ и ‘#’ до ‘true’ или ‘false’.

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
                BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     Из-за того, что ‘not <expr>’ вызывает вычисление <expr>, ‘not <a> =
     <b>’ эквивалентно ‘is(<a> # <b>)’.

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true

 -- Оператор: and
     Оператор логического умножения.  Оператор ‘and’ есть n-арный
     инфиксный оператор.  Его операнды есть логические выражения и его
     результат есть логическое значение.

     Оператор ‘and’ вызывает вычисление (как и ‘is’) одного или более
     операндов, и может вызвать вычисление всех операндов.

     Операнды вычисляются в том же порядка, к котором они встречаются.
     Оператор ‘and’ вычисляет только столько своих операндов, сколько
     необходимо для того, чтобы определить результат.  Если хотя бы один
     операнд есть ‘false’, результат есть ‘false’, и более ни один из
     операндов не вычисляется.

     Глобальный флаг ‘prederror’ управляет поведением ‘and’, когда
     вычисляемый операнд не может быть определен как ‘true’ или ‘false’.
     Оператор ‘and’ печатает сообщение об ошибке, когда ‘prederror’ есть
     ‘true’.  Иначе, операнды, которые не могут быть вычислены как
     ‘true’ или ‘false’, принимаются, и результат есть логическое
     выражение.

     Оператор ‘and’ не является коммутативным: ‘a and b’ может быть не
     равно ‘b and a’ из-за трактовки неопределенных операндов.

 -- Оператор: or
     Оператор логического сложения.  ‘or’ есть n-арный инфиксный
     оператор.  Его операнды есть логические выражения и его результат
     есть логическое значение.

     ‘or’ вызывает вычисление (как и ‘is’) одного или более операндов, и
     может вызвать вычисление всех операндов.

     Операнды вычисляются в том же порядка, к котором они встречаются.
     ‘or’ вычисляет только столько своих операндов, сколько необходимо
     для того, чтобы определить результат.  Если хотя бы один операнд
     есть ‘true’, результат есть ‘true’, и более ни один из операндов не
     вычисляется.

     Глобальный флаг ‘prederror’ управляет поведением ‘or’, когда
     вычисляемый операнд не может быть определен как ‘true’ или ‘false’.
     Оператор ‘or’ печатает сообщение об ошибке, когда ‘prederror’ есть
     ‘true’.  Иначе, операнды, которые не могут быть вычислены как
     ‘true’ или ‘false’, принимаются, и результат есть логическое
     выражение.

     Оператор ‘or’ не является коммутативным: ‘a or b’ может быть не
     равно ‘b or a’ из-за трактовки неопределенных операндов.

 -- Оператор: not
     Оператор логического отрицания.  Оператор ‘not’ есть префиксный
     оператор.  Его операнд есть логическое выражение и его результат
     есть логическое значение.

     Оператор ‘not’ вызывает вычисление (как и ‘is’) своего операнда.

     Глобальный флаг ‘prederror’ управляет поведением ‘not’, когда его
     операнд не может быть определен как значения ‘true’ или ‘false’.
     Оператор ‘not’ печатает сообщение об ошибке, когда ‘prederror’ есть
     ‘true’.  Иначе, операнды, которые не могут быть вычислены как
     ‘true’ или ‘false’, принимаются, и результат есть логическое
     выражение.

 -- Функция: abs (<expr>)
     Возвращает абсолютное значение <expr> (модуль выражения).  Если
     <expr> - комплексное, возвращается комплексный модуль <expr>.

 -- Ключевое слово: additive
     Если ‘declare(f,additive)’ было выполнено, то:

     (1) Если ‘f’ одномерно, пока упрощение не столкнулось с ‘f’
     примененному к сумме, ‘f’ будет распространено вдоль этой суммы.
     То есть, ‘f(y+x)’ будет упрощено как ‘f(y)+f(x)’.

     (2) Если ‘f’ есть функция двух или более аргументов, аддитивность
     задается как аддитивность по первому аргументу ‘f’, как в случае
     ‘sum’ или ‘integrate’, то есть ‘f(h(x)+g(x),x)’ будет упрощено как
     ‘f(h(x),x)+f(g(x),x)’.  Это упрощение не произойдет, когда ‘f’
     применена к выражению вида ‘sum(x[i],i,lower-limit,upper-limit)’.

 -- Ключевое слово: allbut
     Работает с командами ‘part’ (например, ‘part’, ‘inpart’,
     ‘substpart’, ‘substinpart’, ‘dpart’ и ‘lpart’).  Например:

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     хотя

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     ‘allbut’ также распознается ‘kill’.

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     ‘kill(allbut(<a_1>, <a_2>, ...))’ имеет тот же эффект, что
     ‘kill(all)’ за исключением того, что это не очищает символы <a_1>,
     <a_2>, ...  .

 -- Декларация: antisymmetric
     Если ‘declare(h,antisymmetric)’ выполнена, этот говорит упрощателю,
     что ‘h’ - антисимметричная.  Например, ‘h(x,z,y)’ упростится до ‘-
     h(x, y, z)’.  То есть, это дает (-1)^n умноженное на ‘symmetric’
     или ‘commutative’ результат, где n есть число перестановок двух
     аргументов необходимых для того, чтобы перевести к конечной форме.

 -- Функция: cabs (<expr>)
     Возвращает комплексное абсолютное значение (комплексный модуль)
     <expr>.

 -- Функция: ceiling (<x>)

     Когда <x> есть вещественное число - возвращает наименьшее целое,
     которое больше чем или равно <x>.

     Если <x> - константное выражение (‘10 * %pi’, например), ‘ceiling’
     вычисляет <x> используя большие числа с плавающей точкой и
     применяет ‘ceiling’ к конечному большому числу с плавающей точкой.
     Из-за того, что ‘ceiling’ использует вычисления с числами с
     плавающей точкой, возможно, хотя маловероятно, что ‘ceiling’ может
     вернуть ошибочное значение для константных входных данных.  Чтобы
     защититься от ошибок, вычисление с числами с плавающей точкой
     выполняется с использованием трех значений для ‘fpprec’.

     Для неконстантных входных данных, ‘ceiling’ пытается вернуть
     упрощенное значение.  Вот примеры упрощений, о которых ‘ceiling’
     знает:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     Функция ‘ceiling’ автоматически не распространяется (map) для
     списков или матриц.  Наконец, для всех входных данных, которые
     объявлены комплексными, ‘ceiling’ возвращает невычисляемую форму.

     Если диапазон функции есть подмножество целых, она может быть
     объявлена как ‘integervalued’.  Обе функции ‘ceiling’ и ‘floor’
     могут использовать эту информацию.  Например:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- Функция: charfun (<p>)

     Возвращает 0, когда предикат <p> вычисляется как ‘false’;
     возвращает 1, когда предикат вычисляется как ‘true’.  Когда
     предикат вычисляется до чего-то другого, чем ‘true’ или ‘false’
     (unknown), возвращает невычисляемую форму.

     Примеры:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]

 -- Декларация: commutative
     Если ‘declare(h,commutative)’ выполнено, это говорит упрощателю,
     что ‘h’ есть коммутативная функция.  То есть ‘h(x,z,y)’ упроститься
     до ‘h(x, y, z)’.  Это тоже самое, что и ‘symmetric’.

 -- Функция: compare (<x>, <y>)

     Возвращает оператор отношения <op> (‘<’, ‘<=’, ‘>’, ‘>=’, ‘=’ или
     ‘#’) так что ‘is (<x> <op> <y>)’ вычисляется до ‘true’; когда <x>
     или <y> зависит от ‘%i’ и ‘<x> # <y>’, возвращает ‘notcomparable’;
     когда нет такого оператора или Maxima не может определить оператор,
     возвращает ‘unknown’.

     Примеры:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     Функция ‘compare’ не пытается определить, действительно ли области
     определения ее аргументов непусты.  Таким образом

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

     Действительная область определения ‘acos (x^2 + 1)’ пуста.

 -- Функция: entier (<x>)
     Возвращает наибольшее целое меньше или равное чем <x>, где <x> -
     численное.  Функция ‘fix’ (как и в ‘fixnum’) есть синоним, так что
     ‘fix(<x>)’ в точности тоже самое.

 -- Функция: equal (<a>, <b>)
     Представляет эквивалентность, то есть, равное значение.

     Само по себе, ‘equal’ не вычисляется или упрощается.  Функция ‘is’
     пытается вычислить ‘equal’ до логического значения.  Функция
     ‘is(equal(<a>, <b>))’ возвращает ‘true’ (или ‘false’), если и
     только если, <a> и <b> равны (или не равны) для всех возможных
     значений своих переменных, как определено вычислением ‘ratsimp(<a>
     - <b>)’.  Если ‘ratsimp’ возвращает 0, два выражения
     рассматриваются эквивалентными.  Два выражения могут быть
     эквивалентными даже если они не являются синтаксически равными (то
     есть, идентичными).

     Когда ‘is’ не может упростить ‘equal’ до ‘true’ или ‘false’,
     результат управляется глобальным флагом ‘prederror’.  Когда
     ‘prederror’ есть ‘true’, ‘is’ выдает сообщение об ошибке.  Иначе,
     ‘is’ возвращает ‘unknown’.

     В добавление к ‘is’, некоторые другие операторы вычисляют ‘equal’ и
     ‘notequal’ до ‘true’ или ‘false’, а именно ‘if’, ‘and’, ‘or’ и
     ‘not’.

     Отрицанием ‘equal’ является ‘notequal’.

     Примеры:

     Само по себе, ‘equal’ не вычисляет и не упрощает.

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     Функция ‘is’ пытается вычислить ‘equal’ до логического значения.
     ‘is(equal(<a>, <b>))’ возвращает ‘true’ когда ‘ratsimp(<a> - <b>)’
     возвращает 0.  Два выражения могут быть эквивалентными даже если
     они синтаксически не равны (то есть, не идентичны).

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     Когда ‘is’ не может упростить ‘equal’ до ‘true’ или ‘false’,
     результат управляется глобальным флагом ‘prederror’.

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     Некоторые операторы вычисляют ‘equal’ или ‘notequal’ до ‘true’ или
     ‘false’.

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     Из-за того, что ‘not <expr>’ вызывает вычисление <expr>, ‘not
     equal(<a>, <b>)’ эквивалентно ‘is(notequal(<a>, <b>))’.

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- Функция: floor (<x>)

     Когда <x> есть вещественное число - возвращает наибольшее целое,
     которое меньше или равно <x>.

     Если <x> есть константное выражение (‘10 * %pi’, например), ‘floor’
     вычисляет <x> используя большие числа с плавающей точкой и
     применяет ‘floor’ к результирующему значению.  Из-за того, что
     ‘floor’ использует вычисления с числами с плавающей точкой,
     возможно, хотя маловероятно, что ‘floor’ может вернуть ошибочное
     значение для константных входных данных.  Чтобы застраховаться от
     ошибок, вычисление с числами с плавающей точкой выполняется,
     используя три значения для ‘fpprec’.

     Для неконстантных входных данных, ‘floor’ пытается вернуть
     упрощенное значение.  Вот примеры упрощений, о которых ‘floor’
     знает:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     Функция ‘floor’ автоматически не распространяется (map) для списков
     или матриц.  Наконец, для всех входных данных, которые заданы как
     комплексные, ‘floor’ возвращает невычисляемую форму.

     Если диапазон функции есть подмножество целых, она может быть
     объявлена как ‘integervalued’.  Обе функции ‘ceiling’ и ‘floor’
     могут использовать эту информацию.  Например:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- Функция: notequal (<a>, <b>)
     Представляет собой отрицание ‘equal(<a>, <b>)’.

     Примеры:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true

 -- Оператор: eval
     Как аргумент в вызове к ‘ev (<expr>)’, ‘eval’ вызывает
     дополнительное вычисление <expr>.  См.  ‘ev’.

 -- Функция: evenp (<expr>)
     Возвращает ‘true’ если <expr> есть четное целое.  ‘false’
     возвращается во всех других случаях.

 -- Функция: fix (<x>)
     Синоним для ‘entier (<x>)’.

 -- Функция: fullmap (<f>, <expr_1>, ...)
     Аналогично ‘map’, но ‘fullmap’ продолжает процедуру распространения
     для всех подвыражений до тех пор, пока основные операторы более не
     остаются теми же самыми.

     Функция ‘fullmap’ используется Maxima упрощателем для некоторых
     матричных манипуляций.  Таким образом, Maxima иногда генерирует
     сообщение об ошибке, касающееся ‘fullmap’ хотя ‘fullmap’ явно не
     вызывалась пользователем.

     Примеры:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)

 -- Функция: fullmapl (<f>, <list_1>, ...)
     Аналогично ‘fullmap’, но ‘fullmapl’ только распространяется на
     списки и матрицы.

     Пример:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]

 -- Функция: is (<expr>)
     Пытается определить, является ли предикат <expr> доказуемым из
     фактов в базе данных ‘assume’.

     Если этот предикат является доказуемым как ‘true’ или ‘false’, ‘is’
     возвращает ‘true’ или ‘false’, соответственно.  Иначе, возвращаемое
     значение управляется глобальным флагом ‘prederror’.  Когда
     ‘prederror’ есть ‘true’, ‘is’ выдает сообщение об ошибке.  Иначе,
     ‘is’ возвращает ‘unknown’.

     Выражение ‘ev(<expr>, pred)’ (который можно переписать как ‘<expr>,
     pred’ в интерактивной строке) эквивалентно ‘is(<expr>)’.

     См.  также ‘assume’, ‘facts’ и ‘maybe’.

     Примеры:

     ‘is’ вызывает вычисление предикатов.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     ‘is’ пытается вывести предикаты из базы данных ‘assume’.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     Если ‘is’ не может доказать или опровергнуть предикат из базы
     данных ‘assume’, глобальный флаг ‘prederror’ управляет поведением
     ‘is’.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown

 -- Функция: maybe (<expr>)
     Пытается определить, является ли предикат <expr> доказуемым исходя
     из фактов в базе данных ‘assume’.

     Если этот предикат доказуем как ‘true’ или ‘false’, ‘maybe’
     возвращает ‘true’ или ‘false’, соответственно.  Иначе, ‘maybe’
     возвращает ‘unknown’.

     ‘maybe’ функционально эквивалентен ‘is’ с ‘prederror: false’, но
     результат вычислен без реального присвоение значения ‘prederror’.

     См.  также ‘assume’, ‘facts’ и ‘is’.

     Примеры:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true

 -- Функция: isqrt (<x>)
     Возвращает "целый квадратный корень" абсолютного значения <x>,
     которое есть целое.

 -- Функция: lmax (<L>)

     Когда <L> есть список или множество, возвращает ‘apply ('max, args
     (<L>))’.  Когда <L> не является списком или множеством, выдает
     ошибку.

 -- Функция: lmin (<L>)

     Когда <L> есть список или множество, возвращает ‘apply ('min, args
     (<L>))’.  Когда <L> не является списком или множеством, выдает
     ошибку.

 -- Функция: max (<x_1>, ..., <x_n>)

     Возвращает упрощенное значение максимума выражений от <x_1> до
     <x_n>.  Когда ‘get (trylevel, maxmin)’ есть 2 или больше, ‘max’
     использует упрощение ‘max (e, -e) --> |e|’.  Когда ‘get (trylevel,
     maxmin)’ есть 3 или больше, <max> старается исключить выражения,
     заключенные по значению между двумя другими аргументами.  Например,
     ‘max (x, 2*x, 3*x) --> max (x, 3*x)’.  Для установки значения
     ‘trylevel’ в 2, используется ‘put (trylevel, 2, maxmin)’.

 -- Функция: min (<x_1>, ..., <x_n>)

     Возвращает упрощенное значение минимума выражений от <x_1> до
     <x_n>.  Когда ‘get (trylevel, maxmin)’ есть 2 или больше, ‘min’
     использует упрощение ‘min (e, -e) --> -|e|’.  Когда ‘get (trylevel,
     maxmin)’ есть 3 или больше, <min> старается исключить выражения,
     заключенные по значению между двумя другими аргументами.  Например,
     ‘min (x, 2*x, 3*x) --> min (x, 3*x)’.  Для установки значения
     ‘trylevel’ в 2, используется ‘put (trylevel, 2, maxmin)’.

 -- Функция: polymod (<p>)
 -- Функция: polymod (<p>, <m>)
     Конвертирует многочлен <p> в модулярное представление, с учетом
     текущего модуля, которое является значением переменной ‘modulus’.

     ‘polymod (<p>, <m>)’ определяет модуль <m>, который будет
     использоваться вместо текущего значения ‘modulus’.

     См.  ‘modulus’.

 -- Функция: mod (<x>, <y>)

     Если <x> и <y> есть вещественные числа и <y> не отрицательно,
     возвращает ‘<x> - <y> * floor(<x> / <y>)’.  Далее для всех
     вещественных <x> имеем ‘mod (<x>, 0) = <x>’.  Подробное обсуждение
     определения ‘mod (<x>, 0) = <x>’ есть в разделе 3.4 "Concrete
     Mathematics," авторов Graham, Knuth и Patashnik.  Функция ‘mod
     (<x>, 1)’ есть пилообразная функция с периодом 1, ‘mod (1, 1) = 0’
     и ‘mod (0, 1) = 0’.

     Чтобы найти главный аргумент (число в интервале ‘(-%pi, %pi]’) для
     комплексного числа, используется функция ‘<x> |-> %pi - mod (%pi -
     <x>, 2*%pi)’, где <x> есть аргумент.

     Когда <x> и <y> есть константные выражения (например ‘10 * %pi’),
     ‘mod’ использует то же вычисления с числами с плавающей точкой
     повышенной точности, что и, ‘floor’ и ‘ceiling’.  Опять же,
     возможно, хотя маловероятно, что ‘mod’ может вернуть ошибочное
     значение в таких случаях.

     Для не численных аргументов <x> или <y>, ‘mod’ знает несколько
     правил упрощения:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0

 -- Функция: oddp (<expr>)
     есть ‘true’ если <expr> есть нечетное целое.  ‘false’ возвращается
     во всех других случаях.

 -- Оператор: pred
     В качестве аргумента в вызове ‘ev (<expr>)’, ‘pred’ вызывает
     вычисление предикатов (выражений, которые вычисляются в ‘true’ или
     ‘false’) .  См.  ‘ev’.

 -- Функция: make_random_state (<n>)
 -- Функция: make_random_state (<s>)
 -- Функция: make_random_state (true)
 -- Функция: make_random_state (false)

     Объект случайного состояния представляет собой состояние генератора
     случайных чисел.  Оно содержит 627 32-битных слова.

     ‘make_random_state (<n>)’ возвращает новое случайное состояние
     объекта созданного из затравочного целого числа, равного <n> по
     модулю 2^32.  <n> может быть отрицательным.

     ‘make_random_state (<s>)’ возвращает копию случайного состояния
     <s>.

     ‘make_random_state (true)’ возвращает новое случайное состояние
     объекта, используя текущее значение часов компьютера в качестве
     затравочного числа.

     ‘make_random_state (false)’ возвращает копию текущего состояния
     генератора случайных чисел.

 -- Функция: set_random_state (<s>)
     Копирует <s> в состояние генератора случайных чисел.

     ‘set_random_state’ всегда возвращает ‘done’.

 -- Функция: random (<x>)
     Возвращает псевдослучайное число.  Если <x> есть целое, ‘random
     (<x>)’ возвращает целое в пределах от 0 до ‘<x> - 1’ включительно.
     Если <x> есть число с плавающей точкой, ‘random (<x>)’ возвращает
     неотрицательное число с плавающей точкой меньше чем <x>.  Функция
     ‘random’ выдает сообщение об ошибке, если <x> не есть целое, или не
     число с плавающей точкой, или если <x> неположительное.

     Функции ‘make_random_state’ и ‘set_random_state’ сохраняют
     состояние генератора случайных чисел.

     Генератор случайных чисел Maxima - это реализация Mersenne twister
     MT 19937.

     Примеры:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853

 -- Функция: rationalize (<expr>)

     Конвертирует все числа с плавающей точкой двойной точности и
     повышенной точности в выражении <expr> в рациональные эквивалентны.
     Если вы не знакомы с бинарным представлением чисел с плавающей
     точкой, вы может быть удивлены тем, что ‘rationalize (0.1)’ не
     равно 1/10.  Это поведение имеет место не только в Maxima – число
     1/10 имеет периодическое, не заканчивающееся, двоичное
     представление.

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     Пример использования:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then
                 error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf));
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then
             error("The input to 'unitfrac' must be a rational number"),
                                            1
          while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                1
                                        ceiling(-)
                                                r
          reverse(uf))
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37

 -- Функция: round (<x>)

     Если <x> является вещественным числом, то возвращает ближайшее к
     <x> целое.  Числа, кратные 1/2, округляются до ближайшего четного
     целого.  Вычисление <x> аналогично функциям ‘floor’ и ‘ceiling’.

 -- Функция: sign (<expr>)
     Пытается определить знак <expr> на основе фактов в текущей базе
     данных.  Она возвращает один из следующих ответов: ‘pos’
     (положительное), ‘neg’ (отрицательное), ‘zero’ (нулевое), ‘pz’
     (положительное или ноль), ‘nz’ (отрицательное или ноль), ‘pn’
     (положительное или отрицательное), или ‘pnz’ (положительное,
     отрицательное или ноль, т.е.  ничего не известно).

 -- Функция: signum (<x>)
     Для численного значения <x>, возвращает 0, если <x> есть 0, иначе
     возвращает -1 или +1, когда <x> меньше чем или больше чем 0,
     соответственно.

     Если <x> не есть численное значение, то возвращается эквивалентная,
     но упрощенная форма.  Например, ‘signum(-x)’ дает ‘-signum(x)’.

 -- Функция: sort (<L>, <P>)
 -- Функция: sort (<L>)
     Сортирует список <L> согласно предикату ‘P’ двух аргументов, так
     чтобы ‘<P> (<L>[k], <L>[k + 1])’ было равно ‘true’ для любых двух
     последовательных элементов.  Предикат может быть задан как имя
     функции или бинарный инфиксный оператор, или как лямбда-выражение.
     Если он задан как имя оператора, это имя берется в "двойные
     кавычки".

     Отсортированный список возвращается как новый объект; аргумент <L>
     не изменяется.  При возврате значения, ‘sort’ делает копию верхнего
     уровня (shallow copy) элементов <L>.

     Если предикат <P> не задает полное упорядочивание элементов <L>, то
     ‘sort’ может пробежать до конца без ошибки, но результат будет
     неопределенный.  ‘sort’ выдает сообщение, если предикат вычисляется
     до чего-то отличного от ‘true’ или ‘false’.

     ‘sort (<L>)’ эквивалентно ‘sort (<L>, orderlessp)’.  То есть,
     порядок сортировки по умолчанию будет восходящим, как определено
     для ‘orderlessp’.  Все Maxima атомы и выражения сравнимы по
     ‘orderlessp’, хотя есть отдельные примеры выражений, для которых
     ‘orderlessp’ не транзитивна (это ошибка).

     Примеры:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c,
                19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9*c, 19 - 3*x],
                ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list: [[aa,hh,uu], [ee,cc], [zz,xx,mm,cc], [%pi,%e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a),
                reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]

 -- Функция: sqrt (<x>)
     Квадратный корень <x>.  Внутренне представляется как ‘<x>^(1/2)’.
     См.  также ‘rootscontract’.

     ‘radexpand’, если ‘true’, вызовет то, что n-ные корни множителей
     произведения, которые есть степени n, будут вынесены за пределы
     радикала.  Например, ‘sqrt(16*x^2)’ станет ‘4*x’, только если
     ‘radexpand’ есть ‘true’.

 -- Управляющая переменная: sqrtdispflag
     Значение по умолчанию: ‘true’

     Когда ‘sqrtdispflag’ есть ‘false’, то ‘sqrt’ выводится как степень
     с показателем 1/2.

 -- Функция: sublis (<list>, <expr>)
     Производит множественные параллельные подстановки в выражение.

     Переменная ‘sublis_apply_lambda’ управляет упрощением после
     ‘sublis’.

     Пример:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)

 -- Функция: sublist (<list>, <p>)
     Возвращает список элементов <list>, для которого предикат ‘p’
     возвращает ‘true’.

     Пример:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]

 -- Управляющая переменная: sublis_apply_lambda
     Значение по умолчанию: ‘true’

     Управляет, будет ли подстановки для ‘lambda’ применены в упрощении,
     после того как используется ‘sublis’ или нужно ли выполнить ‘ev’,
     чтобы эти элементы применились.  ‘true’ означает - выполнить
     применение.

 -- Функция: subst (<a>, <b>, <c>)
     Делает подстановку <a> для <b> в <c>.  <b> должен быть атомом или
     полным подвыражением в <c>.  Например, ‘x+y+z’ есть полное
     подвыражение ‘2*(x+y+z)/w’, а ‘x+y’ нет.  Когда <b> не имеет эти
     характеристики, можно иногда использовать ‘substpart’ или
     ‘ratsubst’ (см.  ниже).  Альтернативно, если <b> задано в форме
     ‘e/f’, то можно использовать ‘subst (a*f, e, c)’, в то время как,
     если <b> задано в форме ‘e^(1/f)’, то можно использовать ‘subst
     (a^f, e, c)’.  ‘subst’ также различает ‘x^y’ в ‘x^-y’, так что
     ‘subst (a, sqrt(x), 1/sqrt(x))’ дает ‘1/a’.  Аргументы <a> и <b>
     могут также быть операторами выражения, заключенными в двойные
     кавычки ‘"’, или могут быть именами функций.  Если есть желание
     подставить независимую переменную в производных формах, то следует
     использовать функцию ‘at’ (см.  ниже).

     ‘subst’ - это псевдоним для ‘substitute’.

     Выражения ‘subst (<eq_1>, <expr>)’ или ‘subst ([<eq_1>, ...,
     <eq_k>], <expr>)’ - есть другие допустимые формы.  <eq_i> -
     уравнения, указывающие какие подстановки нужно сделать.  Для
     каждого уравнения, правая сторона будет подставлена вместо левой в
     выражении <expr>.

     Если ‘exptsubst’ равно ‘true’, то позволяются подстановки, на
     подобии ‘y’ для ‘%e^x’ в ‘%e^(a*x)’.

     Когда ‘opsubst’ есть ‘false’, ‘subst’ не пытается подставить в
     оператор выражения.  Например, ‘(opsubst: false, subst (x^2, r,
     r+r[0]))’ будет работать.

     Примеры:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Чтобы узнать о других примерах, выполните ‘example (subst)’.

 -- Функция: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Аналогично ‘substpart’, но ‘substinpart’ работает с внутренним
     представление <expr>.

     Примеры:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     Если последний аргумент функции ‘part’ есть список индексов, то
     будут выбраны несколько подвыражений, каждый из которых будет
     соответствовать индексу в списке.  Таким образом

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     Переменная ‘piece’ содержит значение последнего выражения,
     выбранного при использовании функции ‘part’.  Оно устанавливается
     во время выполнения функции и, таким образом, может быть передано в
     саму функцию как показано ниже.  Если ‘partswitch’ равно ‘true’, то
     ‘end’ возвращается когда выбранная часть выражения не существует,
     иначе выдается сообщение об ошибке.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Также, установка опции ‘inflag’ в ‘true’ и вызов ‘part’ или
     ‘substpart’ есть тоже самое, что и вызов ‘inpart’ или
     ‘substinpart’.

 -- Функция: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Делает подстановку <x> в подвыражение, выбираемое последними
     аргументами, как в ‘part’.  Возвращает новое значение <expr>.  <x>
     может быть некоторым оператором для подстановки вместо оператора в
     <expr>.  В некоторых случаях <x> нужно заключать в двойной кавычки
     ‘"’ (Например, ‘substpart ("+", a*b, 0)’ дает ‘b + a’).

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f(b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Также, установка опции ‘inflag’ в ‘true’ и вызов ‘part’ или
     ‘substpart’, есть тоже самое, что и вызов ‘inpart’ или
     ‘substinpart’.

 -- Функция: subvarp (<expr>)
     Возвращает ‘true’, если <expr> есть переменная с индексом, например
     ‘a[i]’.

 -- Функция: symbolp (<expr>)
     Возвращает ‘true’, если <expr> есть символ, иначе ‘false’.  На
     самом деле, ‘symbolp(x)’ эквивалентно предикату ‘atom(x) and not
     numberp(x)’.

     См.  также *note Идентификаторы::.

 -- Функция: unorder ()
     Блокирует связывания, созданные последним вызовом упорядочивающих
     команд ‘ordergreat’ и ‘orderless’.  ‘ordergreat’ и ‘orderless’ не
     могут использоваться больше одного раза каждый, без вызова
     ‘unorder’.  См.  также ‘ordergreat’ и ‘orderless’.

     Примеры:

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
           %th(1) - %th(3);
                                       2
          (%o4)                       a  + b x
          (%i5) unorder();
                                        2    2
          (%o5)                        a  - a

 -- Функция: vectorpotential (<givencurl>)
     Возвращает векторный потенциал заданного вектора кручения, в
     текущей системе координат.  ‘potentialzeroloc’ имеет аналогичную
     роль для ‘potential’, но порядок левосторонних частей уравнений
     должен быть циклической перестановкой координатных переменных.

 -- Функция: xthru (<expr>)
     Объединяет все члены <expr> (которое должно быть суммой) для общего
     знаменателя без раскрытия произведений и степеней сумм, что делает
     ‘ratsimp’.  Функция ‘xthru’ сокращает общие множители в числителе и
     знаменателе рациональных выражений, но только если эти множители
     явные.

     Иногда лучше использовать ‘xthru’ перед выражением, упрощенным с
     помощью ‘ratsimp’, для того чтобы вызывать сокращение явных
     множителей наибольшего общего делителя числителя и знаменателя,
     таким образом, упрощая выражение перед ‘ratsimp’.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)

 -- Функция: zeroequiv (<expr>, <v>)
     Проверяет эквивалентно ли выражение <expr> в переменной <v> нулю,
     возвращает ‘true’, ‘false’ или ‘dontknow’.

     ‘zeroequiv’ имеет следующие ограничения:
       1. Не используйте функции, для которых Maxima не знает как их
          дифференцировать и вычислять.
       2. Если выражение имеет полюсы на вещественной прямой, могут быть
          ошибки в результате (это может произойти с малой
          вероятностью).
       3. Если выражение содержит функции, который не являются решением
          дифференциальных уравнений первого порядка (например, функции
          Бесселя), могут быть некорректные результаты.
       4. Этот алгоритм использует вычисление в случайно выбранных
          точках для аккуратно выбранных подвыражений.  Это всегда, в
          некотором смысле, рискованное дело, хотя алгоритм пытается
          минимизировать возможность ошибки.

     Например ‘zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)’ возвращает
     ‘true’ и ‘zeroequiv (%e^x + x, x)’ возвращает ‘false’.  С другой
     стороны ‘zeroequiv (log(a*b) - log(a) - log(b), a)’ возвращает
     ‘dontknow’ из-за присутствия дополнительного параметра ‘b’.


File: maxima.info,  Node: Выражения,  Next: Simplification,  Prev: Операторы,  Up: Top

6 Выражения
***********

* Menu:

* Основные сведения о выражениях::  
* Комплексные выражения::                     
* Невычисляемые и вычисляемые формы::
* Идентификаторы::
* Строки::
* Неравенства::                  
* Синтаксис::                      
* Функции и переменные для выражений::  


File: maxima.info,  Node: Основные сведения о выражениях,  Next: Комплексные выражения,  Prev: Выражения,  Up: Выражения

6.1 Основные сведения о выражениях
==================================

Есть некоторое число зарезервированных слов, которые не могут быть
использованы как имена переменных.  Их использование может вызвать
скрытую синтаксическую ошибку.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Большинство сущностей в Maxima являются выражениями.
Последовательность выражений может превратиться в одно выражение, если
элементы последовательности разделены запятыми и последовательность
взята в скобки.  Это аналогично подобным выражениям последовательного
вычисления (comma expressions) в языке программирования C.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Даже циклы в Maxima являются выражениями, хотя то значение, которое
они возвращают, не слишком полезное ‘done’.

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   То, что Вы действительно хотите получить, нужно включить как третий
аргумент в выражение последовательного вычисления, который в
действительности возвращает значение.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Комплексные выражения,  Next: Невычисляемые и вычисляемые формы,  Prev: Основные сведения о выражениях,  Up: Выражения

6.2 Комплексные выражения
=========================

Комплексное выражение задается в Maxima добавлением к вещественной части
выражения ‘%i’, умноженного на мнимую часть.  Таким образом, корни
уравнения ‘x^2 - 4*x + 13 = 0’ равны ‘2 + 3*%i’ и ‘2 - 3*%i’.  Заметим,
что упрощение произведений комплексных выражений может произойти после
раскрытия произведения.  Упрощение отношений, корней и других функций
комплексных выражений, обычно, может быть произведено, с использованием
функций ‘realpart’, ‘imagpart’, ‘rectform’, ‘polarform’, ‘abs’ и ‘carg’.


File: maxima.info,  Node: Невычисляемые и вычисляемые формы,  Next: Идентификаторы,  Prev: Комплексные выражения,  Up: Выражения

6.3 Невычисляемые и вычисляемые формы
=====================================

Maxima различает операторы, которые являются невычисляемыми (nouns) и
операторы, который являются вычисляемыми (verbs).  Вычисляемым является
оператор, который может быть выполнен.  Невычисляемым является оператор,
который встречается как символ в выражении, без вычисления.  По
умолчанию, имена функций является вычисляемыми.  Вычисляемая форма может
быть переведена в невычисляемую, экранированием (quoting) имени функции
или применением функции ‘nounify’.  Невычисляемая форма может быть
переведена в вычисляемую, применением функции ‘verbify’.  Флаг
вычисления ‘nouns’ вызывает функцию ‘ev’ для вычисления невычисляемых
форм в выражении.

   Вычисляемая форма отличается первым знаком доллара ‘$’ в
соответствующем Lisp-символе.  Невычисляемая форма, наоборот, отличается
первым знаком процента ‘%’ в соответствующем Lisp-символе.  Некоторые
невычисляемые формы, такие как ‘'integrate’ и ‘'derivative’
(возвращаемые ‘diff’), имеют специальные свойства вывода, но не всегда.
По умолчанию, невычисляемые и вычисляемые формы функции идентичны при
выводе.  Глобальный флаг ‘noundisp’ вызывает то, что Maxima выводит
невычисляемые формы с предшествующей одиночной кавычкой ‘'’.

   См.  также ‘noun’, ‘nouns’, ‘nounify’ и ‘verbify’.

   Примеры:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Идентификаторы,  Next: Строки,  Prev: Невычисляемые и вычисляемые формы,  Up: Выражения

6.4 Идентификаторы
==================

Идентификаторы Maxima могут содержать буквы алфавита, плюс цифры от 0 до
9, плюс любые специальные символы, с предшествующим знаком ‘\’.

   Цифра может быть первым символом идентификатора, если ей предшествует
бэкслеш ‘\’.  Для цифр, которые являются вторыми или последующими
символами, бэкслеш не нужен.

   Специальный символ может быть объявлен алфавитным, с помощью функции
‘declare’.  Если это так, его не нужно экранировать бэкслешом в
идентификаторе.  Изначально к алфавитным символам относятся ‘A’ до ‘Z’,
‘a’ до ‘z’, ‘%’ и ‘_’.

   Maxima чувствительна к регистру символов.  Идентификаторы ‘foo’,
‘FOO’ и ‘Foo’ различны.  Для дальнейших сведений по этому вопросу
смотрите *note Lisp и Maxima::.

   Maxima идентификатор является Lisp-символом, который начинается со
знака доллар ‘$’.  Любой другой Lisp-символ, когда он встречается в
Maxima, предваряется знаком вопроса ‘?’.  См.  *note Lisp и Maxima:: для
более подробной информации по этому вопросу.

   Примеры:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Строки,  Next: Неравенства,  Prev: Идентификаторы,  Up: Выражения

6.5 Строки
==========

Строки (последовательности символов в кавычках) заключаются в двойные
кавычки ‘"’ при вводе и выводятся с или без кавычек, в зависимости от
значения глобальной переменной ‘stringdisp’.

   Строки могут содержать любые символы, включая символы табуляции,
новой строки и возврат каретки.  Последовательность ‘\"’ распознается
как литерал двойной кавычки, а ‘\\’ как литерал бэкслеша.  Когда бэкслеш
появляется в конце строки, то бэкслеш и символ завершение строки (либо
новая строка, либо возврат каретки) игнорируются, так что данная строка
продолжается со следующей строки.  Никакие другие специальные комбинации
бэкслеша с другим символом не распознаются.  Если бэкслеш появляется
перед любым символом, отличным от ‘"’, ‘\’, или конец строки, то он
игнорируется.  Нет других способов для представления специальных
символов (таких как табуляция, новая строка или возврат каретки) кроме
как вставка этого символа в строку.

   В Maxima нет типа одиночный символ.  Одиночный символ представляется
как одно-символьная строка.

   Дополнительный пакет ‘stringproc’ содержит много функций для работы
со строками.

   Примеры:

     (%i1) s_1 : "This is a string.";
     (%o1)               This is a string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)                   This is a string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)                  "This is a string."


File: maxima.info,  Node: Неравенства,  Next: Синтаксис,  Prev: Строки,  Up: Выражения

6.6 Неравенства
===============

Maxima имеет операторы неравенства ‘<’, ‘<=’, ‘>=’, ‘>’, ‘#’ и
‘notequal’.  См.  ‘if’ для описания условных выражений.


File: maxima.info,  Node: Синтаксис,  Next: Функции и переменные для выражений,  Prev: Неравенства,  Up: Выражения

6.7 Синтаксис
=============

Возможно определять новые операторы с заданным приоритетом, удалять
определения существующих операторов или переопределять приоритет
существующих операторов.  Оператор может быть унарным префиксным или
унарным постфиксным, бинарным инфиксным, n-арным (n-ary) инфиксным,
матчфиксным (matchfix) или безфиксным (nofix).  Матчфиксный (matchfix)
обозначает пару символов, которые заключают между собой свой аргумент
или аргументы, а безфиксный (nofix) означает оператор, который не
принимает аргументы.  Следующие примеры демонстрируют различные типы
операторов.

унарный префиксный
     изменение знака ‘- a’
унарный постфиксный
     факториал ‘a!’
бинарный инфиксный
     экспонента ‘a^b’
n-арный инфиксный
     сложение ‘a + b’
матчфиксный
     список ‘[a, b]’

   (Встроенных безфиксных операторов нет; для примера такого оператора
см.  ‘nofix’.)

   Механизм определения нового оператора прост.  Необходимо только
объявить функцию как оператор; сама функция оператора может быть
определена или нет.

   Вот пример определенных пользователем операторов.  Заметим, что явный
вызов функции ‘"dd" (a)’ эквивалентен ‘dd a’, также как ‘"<-" (a, b)’
эквивалентно ‘a <- b’.  Заметим также, что функции ‘"dd"’ и ‘"<-"’ не
определены в этом примере.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   Maxima функции, которые определяют новые операторы, сведены в
нижеследующей таблице, с установленными по умолчанию левыми и правыми
степенями связывания (lbp и rbp, соответственно).  (Степень связывания
определяет приоритет операторов.  Однако, так как левые и правые степени
связывания могут отличаться, степень связывания - это что-то более
сложное чем приоритет.)  Некоторые функции определения операций
принимают дополнительные аргументы, см.  описания этих функций для более
полного описания деталей.

‘prefix’
     rbp=180
‘postfix’
     lbp=180
‘infix’
     lbp=180, rbp=180
‘nary’
     lbp=180, rbp=180
‘matchfix’
     (степень связывания не применима)
‘nofix’
     (степень связывания не применима)

   Для сравнения, приведем некоторые встроенные операторы, и их левые и
правые степени связывания.

     Operator   lbp     rbp

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   ‘remove’ и ‘kill’ удаляют свойства оператора из атома.  ‘remove
("<a>", op)’ удаляет только свойства оператора <a>.  ‘kill ("<a>")’
удаляет все свойства <a>, включая свойства оператора.  Заметим, что имя
оператора должно быть взято в кавычки.

     (%i1) infix ("@");
     (%o1)                           @
     (%i2) "@" (a, b) := a^b;
                                          b
     (%o2)                      a @ b := a
     (%i3) 5 @ 3;
     (%o3)                          125
     (%i4) remove ("@", op);
     (%o4)                         done
     (%i5) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i5) "@" (5, 3);
     (%o5)                          125
     (%i6) infix ("@");
     (%o6)                           @
     (%i7) 5 @ 3;
     (%o7)                          125
     (%i8) kill ("@");
     (%o8)                         done
     (%i9) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i9) "@" (5, 3);
     (%o9)                        @(5, 3)


File: maxima.info,  Node: Функции и переменные для выражений,  Prev: Синтаксис,  Up: Выражения

6.8 Функции и переменные для выражений
======================================

 -- Функция: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Функция: at (<expr>, <eqn>)
     Вычисляет выражение <expr>, предполагая значения для переменных,
     заданные в списке уравнений ‘[<eqn_1>, ..., <eqn_n>]’ или одном
     уравнении <eqn>.

     Если подвыражение зависит от переменных, для которых заданы
     значения, но нет, заданного при помощи ‘atvalue’ значения, или оно
     не может быть вычислено иным способом, то возвращается
     невычисляемая форма ‘at’, которая выводится в двумерном формате.

     Функция ‘at’ выполняет множественные подстановки последовательно,
     не параллельно.

     См.  также ‘atvalue’.  Для описания других функций, которые
     выполняют подстановки, см.  также ‘subst’ и ‘ev’.

     Примеры:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Функция: box (<expr>)
 -- Функция: box (<expr>, <a>)
     Возвращает <expr>, заключенное в бокс (box).  Возвращаемое значение
     есть выражение с ‘box’ в качестве оператора и <expr> как аргумент.
     Бокс изображается при выводе, когда ‘display2d’ есть ‘true’.

     ‘box (<expr>, <a>)’ заключает <expr> в бокс, обозначенный символом
     <a>.  Эта метка обрезается, если она длиннее чем ширина бокса.

     ‘box’ вычисляет свои аргументы.  Однако, выражение, взятое в бокс,
     не вычисляется до его содержимого, так что выражения в боксе
     эффективно исключается из вычислений.

     ‘boxchar’ есть символ, используемый для отображения бокса в
     функциях ‘box’, в ‘dpart’ и в ‘lpart’.

     Примеры:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------

 -- Управляющая переменная: boxchar
     Значение по умолчанию: ‘"’

     ‘boxchar’ есть символ, который используется для изображения бокса в
     функциях ‘box’, в ‘dpart’ и в ‘lpart’ .

     Все боксы в выражении изображаются с текущим значением ‘boxchar’.
     Изображаемый символ не сохраняется в выражении бокса.

 -- Функция: carg (<z>)
     Возвращает комплексный аргумент <z>.  Этот комплексный аргумент
     есть угол ‘theta’ в пределах ‘(-%pi, %pi]’ такой что ‘r exp (theta
     %i) = <z>’, где ‘r’ есть модуль <z>.

     ‘carg’ есть вычислительная функция, но не функция упрощения.

     ‘carg’ игнорирует декларацию ‘declare (<x>, complex)’ и
     рассматривает <x> как вещественную переменную.  Это ошибка.

     См.  также ‘abs’ (комплексный модуль), ‘polarform’, ‘rectform’,
     ‘realpart’ и ‘imagpart’.

     Примеры:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2

 -- Специальный оператор: constant
     ‘declare (<a>, constant)’ объявляет <a> как константу.  См.
     ‘declare’.

 -- Функция: constantp (<expr>)
     Возвращает ‘true’, если <expr> есть константное выражение, иначе
     возвращает ‘false’.

     Выражение рассматривается как константное, если его аргументы есть
     числа (включая рациональные числа, которые отображаются с помощью
     ‘/R/’), символьные константы, такие как ‘%pi’, ‘%e’ и ‘%i’,
     переменные, равные константами, или объявленные константами с
     помощью ‘declare’, или функции, чьи аргументы есть константы.

     ‘constantp’ вычисляет свои аргументы.

     Примеры:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- Функция: declare (<a_1>, <p_1>, <a_2>, <p_2>, ...)
     Присваивает атому или списку атомов <a_i> свойство или список
     свойств <p_i>.  Когда <a_i> и/или <p_i> есть списки, каждый из
     атомом получает все свойства.

     ‘declare’ не вычисляет свои аргументы.  ‘declare’ всегда возвращает
     ‘done’.

     Как отмечено в описании для каждого флага декларации, для некоторых
     флагов ‘featurep(<object>, <feature>)’ возвращает ‘true’, если
     <object> был объявлен, как имеющий <feature>.  Однако, ‘featurep’
     не распознает некоторые флаги.  Это ошибка.

     См.  также ‘features’.

     ‘declare’ распознает следующие свойства:

     ‘evfun’
          Делает <a_i> известным для ‘ev’ так, что эта функция названная
          как <a_i>, применяется когда <a_i> появляется как флаговый
          аргумент ‘ev’.  См.  ‘evfun’.

     ‘evflag’
          Делает <a_i> известным для функции ‘ev’ так, что <a_i>
          связывается с ‘true’ во время выполнение ‘ev’, когда <a_i>
          появляется как флаговый аргумент ‘ev’.  См.  ‘evflag’.

     ‘bindtest’
          Указывает Maxima то, что следует вызвать ошибку, когда при
          вычислении значение <a_i> не определено.

     ‘noun’
          Указывает Maxima считать <a_i> невычисляемой формой.  Эффект
          состоит в замене <a_i> на ‘'<a_i>’ или ‘nounify(<a_i>)’, в
          зависимости от контекста.

     ‘constant’
          Указывает Maxima рассматривать <a_i> как символьную константу.

     ‘scalar’
          Указывает Maxima рассматривать <a_i> как скалярную переменную.

     ‘nonscalar’
          Указывает Maxima рассматривать <a_i> как нескалярную
          переменную.  Обычное применение состоит в том, чтобы объявлять
          переменная как символьный вектор или матрицу.

     ‘mainvar’
          Указывает Maxima рассматривать <a_i> как "главную переменную"
          (‘mainvar’).  ‘ordergreatp’ определяет упорядочивание атомов
          таким образом:

          (главные переменные) > (другие переменные) > (скалярный
          переменные) > (константы) > (числа)

     ‘alphabetic’
          Указывает Maxima рассматривать <a_i> как алфавитный символ.

     ‘feature’
          Указывает Maxima рассматривать <a_i> как имя свойства.  Тогда
          другие атомы могут иметь свойство <a_i>.

     ‘rassociative’, ‘lassociative’
          Указывает Maxima рассматривать <a_i> как право-ассоциативную
          или лево-ассоциативную функцию.

     ‘nary’
          Указывает Maxima рассматривать <a_i> как n-арную функцию.

          Декларация ‘nary’ это не тоже, что вызов функции ‘nary’.
          Единственный эффект ‘declare(foo, nary)’ состоит в том, чтобы
          обучить упрощатель Maxima упрощать вложенные выражения,
          например, чтобы ‘foo(x, foo(y, z))’ упрощалось до ‘foo(x, y,
          z)’.

     ‘symmetric’, ‘antisymmetric’, ‘commutative’
          Указывает Maxima рассматривать <a_i> как симметричную или
          антисимметричную функцию.  ‘commutative’ это тоже самое, что
          ‘symmetric’.

     ‘oddfun’, ‘evenfun’
          Указывает Maxima рассматривать <a_i> как нечетную или четную
          функцию.

     ‘outative’
          Указывает Maxima упрощать выражения с <a_i> путем выноса
          константных множителей за пределы первого аргумента.

          Когда <a_i> имеет один аргумент, множитель рассматривается
          константным, если он есть литерал или объявлен константой.

          Когда <a_i> имеет два или более аргументов, множитель
          рассматривается константой, если второй аргумент есть символ и
          этот множитель свободен от этого второго аргумента.

     ‘multiplicative’
          Указывает Maxima упрощать выражения <a_i> путем подстановки
          ‘<a_i>(x * y * z * ...)’  ‘-->’ ‘<a_i>(x) * <a_i>(y) *
          <a_i>(z) * ...’.  Эта подстановка выполняется только для
          первого аргумента.

     ‘additive’
          Указывает Maxima упрощать <a_i> выражения путем подстановки
          ‘<a_i>(x + y + z + ...)’  ‘-->’ ‘<a_i>(x) + <a_i>(y) +
          <a_i>(z) + ...’.  Эта подстановка выполняется только для
          первого аргумента.

     ‘linear’
          Эквивалентно объявлению <a_i> совместно ‘outative’ и
          ‘additive’.

     ‘integer’, ‘noninteger’
          Указывает Maxima рассматривать <a_i> как целую или нецелую
          переменную.

     ‘even’, ‘odd’
          Указывает Maxima рассматривать <a_i> как четную или нечетную
          целую переменную.

     ‘rational’, ‘irrational’
          Указывает Maxima рассматривать <a_i> как рациональную или
          иррациональную вещественную переменную.

     ‘real’, ‘imaginary’, ‘complex’
          Указывает Maxima рассматривать <a_i> как вещественную, чисто
          мнимую или комплексную переменную.

     ‘increasing’, ‘decreasing’
          Указывает Maxima рассматривать <a_i> как растущую или
          убывающую функцию.

     ‘posfun’
          Указывает Maxima рассматривать <a_i> как положительную
          функцию.

     ‘integervalued’
          Указывает Maxima рассматривать <a_i> как целочисленную
          функцию.

     Примеры:

     Декларации ‘evfun’ и ‘evflag’.
          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     Декларация ‘bindtest’.
          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     Декларация ‘noun’.
          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     Декларации ‘constant’, ‘scalar’, ‘nonscalar’ и ‘mainvar’.

     Декларация ‘alphabetic’.
          (%i1) xx\~yy : 1729;
          (%o1)                         1729
          (%i2) declare ("~", alphabetic);
          (%o2)                         done
          (%i3) xx~yy + yy~xx + ~xx~~yy~;
          (%o3)                ~xx~~yy~ + yy~xx + 1729

     Декларация ‘feature’.
          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     Декларации ‘rassociative’ и ‘lassociative’.

     Декларация ‘nary’.
          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     Декларации ‘symmetric’ и ‘antisymmetric’.
          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     Декларации ‘oddfun’ и ‘evenfun’.
          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     Декларация ‘outative’.
          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     Декларация ‘multiplicative’.
          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     Декларация ‘additive’.
          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     Декларация ‘linear’.
          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- Функция: disolate (<expr>, <x_1>, ..., <x_n>)
     аналогична ‘isolate (<expr>, <x>)’, за исключением того, что она
     дает возможность пользователю изолировать более чем одну переменную
     одновременно.  Это может быть полезно, например, если пользователь
     пытается заменить переменные в многократном интегрировании и эта
     замена переменных включает две или более переменных интегрирования.
     Данная функция автоматически загружается из
     ‘simplification/disol.mac’.  Демонстрация доступна по
     ‘demo("disol")$’.

 -- Функция: dispform (<expr>)
     Возвращает внешнее представление <expr> по отношению к его главному
     оператору.  Это может быть полезно в сочетании с ‘part’, которая
     также имеет дело с внешним представлением.  Предположим <expr> есть
     -A. Тогда внутреннее представление <expr> есть "*"(-1,A), в то
     время как внешнее представление есть "-"(A). ‘dispform (<expr>,
     all)’ конвертирует все выражение (не только верхний уровень) в
     внешний формат.  Например, если ‘expr: sin (sqrt (x))’, то ‘freeof
     (sqrt, expr)’ и ‘freeof (sqrt, dispform (expr))’ дают ‘true’, в то
     время как ‘freeof (sqrt, dispform (expr, all))’ дает ‘false’.

 -- Функция: distrib (<expr>)
     Распространяет суммы над произведениями.  Она отличается от
     ‘expand’ тем, что она работает только на самом верхнем уровне
     выражения, то есть она не рекурсивная и работает быстрее чем
     ‘expand’.  Она отличается от ‘multthru’ тем, что раскрывает все
     суммы на этом уровне.

     Примеры:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c

 -- Функция: dpart (<expr>, <n_1>, ..., <n_k>)
     Выбирает тоже подвыражение что и ‘part’, но вместо только
     возвращения этого подвыражения как значения, она возвращает все
     выражение с выбранным подвыражением, изображенным внутри бокса.
     Данный бокс в действительности является частью выражения.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """

 -- Функция: exp (<x>)
     Представляет собой экспоненциальную функцию.  Все экземпляры ‘exp
     (<x>)’ при вводе упрощаются до ‘%e^<x>’.  ‘exp’ не присутствует в
     упрощенных выражениях.

     Если ‘demoivre’ равно ‘true’, то ‘%e^(a + b %i)’ упрощается до
     ‘%e^(a (cos(b) + %i sin(b)))’, если ‘b’ свободна от ‘%i’.  См.
     ‘demoivre’.

     Если ‘%emode’, равно ‘true’, то ‘%e^(%pi %i x)’ упрощается.  См.
     ‘%emode’.

     Если ‘%enumer’, равно ‘true’, то ‘%e’ заменяется на 2.718..., когда
     ‘numer’ есть ‘true’.  См.  ‘%enumer’.

 -- Управляющая переменная: %emode
     Значение по умолчанию: ‘true’

     Когда ‘%emode’ есть ‘true’, то ‘%e^(%pi %i x)’ упрощается следующим
     образом.

     ‘%e^(%pi %i x)’ упрощается до ‘cos (%pi x) + %i sin (%pi x)’, если
     ‘x’ есть число с плавающей точкой, целое или произведение 1/2, 1/3,
     1/4 или 1/6 и тогда в дальнейшем упрощается.

     Для других численных ‘x’, ‘%e^(%pi %i x)’ упрощается до ‘%e^(%pi %i
     y)’, где ‘y’ есть ‘x - 2 k’ для некоторых целых ‘k’, таких что
     ‘abs(y) < 1’.

     Когда ‘%emode’ есть ‘false’, специальное упрощение ‘%e^(%pi %i x)’
     не выполняется.

 -- Управляющая переменная: %enumer
     Значение по умолчанию: ‘false’

     Когда ‘%enumer’ есть ‘true’, то ‘%e’ заменяется своим численным
     значением 2.718..., когда ‘numer’ есть ‘true’.

     Когда ‘%enumer’ есть ‘false’, эта подстановка выполняется только
     если экспонента в ‘%e^x’ вычисляется до численного значения.

     См.  также ‘ev’ и ‘numer’.

 -- Управляющая переменная: exptisolate
     Значение по умолчанию: ‘false’

     Если ‘exptisolate’ равно ‘true’, то ‘isolate (expr, var)’ исследует
     показатели атомов (таких как ‘%e’), которые содержат ‘var’.

 -- Управляющая переменная: exptsubst
     Значение по умолчанию: ‘false’

     Если ‘exptsubst’ равно ‘true’, то позволяется выполнять
     подстановки, такие как ‘y’ для ‘%e^x’ в ‘%e^(a x)’.

 -- Функция: freeof (<x_1>, ..., <x_n>, <expr>)
     ‘freeof (<x_1>, <expr>)’ Возвращает ‘true’, если никакое
     подвыражение <expr> не равно <x_1> или если <x_1> возникает только
     как немая переменная в <expr>, иначе возвращает ‘false’.

     ‘freeof (<x_1>, ..., <x_n>, <expr>)’ эквивалентно ‘freeof (<x_1>,
     <expr>) and ... and freeof (<x_n>, <expr>)’.

     Аргументы <x_1>, ..., <x_n> могут быть именами функций или
     переменных, именами с индексами, операторами (заключенными в
     двойные кавычки) или выражениями общего вида.  ‘freeof’ вычисляет
     свои аргументы.

     ‘freeof’ действует только на <expr> в том виде, в как оно есть,
     (после упрощения и вычисления) и не пытается определить, может ли
     некоторое эквивалентное выражение дать другой результат.  В
     частности, упрощение может давать эквивалентное, но другое
     выражение, которое содержит некоторые различные элементы чем
     исходная форма <expr>.

     Переменная является немой переменной в некотором выражении, если
     она не имеет значения за пределами выражения.  Немые переменные,
     распознаваемые ‘freeof’, есть индекс суммы или произведения,
     переменная предела в ‘limit’, переменная интегрирования в
     определенном интеграле ‘integrate’, исходная переменная в
     ‘laplace’, формальные переменные в выражениях ‘at’ и аргументы в
     ‘lambda’ выражениях.  Локальные переменные в ‘block’ не
     распознаются ‘freeof’ как немые переменные.  Это ошибка.

     Неопределенное интегрирование ‘integrate’ не свободно от переменной
     интегрирования.

        • Аргументы есть имена функций, переменные, имена с индексами,
          операторы и выражения.  ‘freeof (a, b, expr)’ эквивалентно
          ‘freeof (a, expr) and freeof (b, expr)’.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        • ‘freeof’ вычисляет свои аргументы.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        • ‘freeof’ не учитывает эквивалентные выражения.  Упрощение
          может дать эквивалентное, но отличное выражение.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        • Суммирование или определенный интеграл свободно от своих немых
          переменных.  Неопределенный интеграл не свободен от своей
          переменной интегрирования.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false

 -- Функция: genfact (<x>, <y>, <z>)
     Возвращает обобщенный факториал, заданный как ‘x (x-z) (x - 2 z)
     ... (x - (y - 1) z)’.  Таким образом, для целого <x>, ‘genfact (x,
     x, 1) = x!’ и ‘genfact (x, x/2, 2) = x!!’.

 -- Функция: imagpart (<expr>)
     Возвращает мнимую часть выражения <expr>.

     ‘imagpart’ есть вычислительная функция, а не функция упрощения.

     См.  также ‘abs’, ‘carg’, ‘polarform’, ‘rectform’ и ‘realpart’.

 -- Функция: infix (<op>)
 -- Функция: infix (<op>, <lbp>, <rbp>)
 -- Функция: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Объявляет <op> инфиксным оператором.  Инфиксный оператор есть
     функция двух аргументов, с именем функции, записанным между этими
     аргументами.  Например, оператор вычитания ‘-’ есть инфиксный
     оператор.

     ‘infix (<op>)’ объявляет <op> инфиксным оператором со степенями
     связывания по умолчанию (левая и правая, обе равны 180) и частями
     речи по умолчанию (левая и правая, обе равны ‘any’).

     ‘infix (<op>, <lbp>, <rbp>)’ объявляет <op> инфиксным оператором с
     указанными левой и правой степени связывания и частями речи по
     умолчанию (левая и правая, обе равны ‘any’).

     ‘infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)’ объявляет <op>
     инфиксным оператором с указанными левой и правой степенями
     связывания и частями речи <lpos>, <rpos> и <pos> для левого
     операнда, правого операнда и результата соответственно.

     Термин "часть речи" по отношению к объявлению операторов, означает
     тип выражения.  Различается три типа: ‘expr’, ‘clause’ и ‘any’,
     которые означают алгебраическое выражение, логическое выражение и
     выражение произвольного типа соответственно.  Maxima может
     обнаружить некоторые синтаксические ошибки, сравнивая объявленные
     для оператора части речи с актуальными выражениями.

     Приоритет <op> по отношению к другим операторам выводится из левой
     и правой степеней связывания рассматриваемых операторов.  Если
     левые и правые степени связывания <op> обе больше левых и правых
     степеней связывания другого оператора, то <op> имеет более высокий
     приоритет чем этот оператор.  Если степени связывания обе не больше
     или меньше, то имеют место некоторые более сложные соотношения.

     Ассоциативность <op> зависит от его степени связывания.  Большая
     левая степень связывания (<lbp>) означает, что <op> вычисляется до
     других операторов, стоящих слева от него в выражении, в то время
     как большая правая степень связывания (<rbp>) означает, что <op>
     вычисляется до других операторов, стоящих справа от него в
     выражении.  Таким образом, большее <lbp> делает <op>
     право-ассоциативным, в то время как большее <rbp> делает <op>
     лево-ассоциативным.  Если <lbp> равно <rbp>, то <op> является
     лево-ассоциативный.

     См.  также ‘Syntax’.

     Примеры:

        • Если левые и правые степени связывания <op> обе больше левых и
          правых степеней связывания другого оператора, то <op> имеет
          более высокий приоритет чем этот оператор.
          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) :lisp (get '$+ 'lbp)
          100
          (%i2) :lisp (get '$+ 'rbp)
          100
          (%i2) infix ("@", 101, 101)$
          (%i3) 1 + a@b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("@", 99, 99)$
          (%i5) 1 + a@b + 2;
          (%o5)                       (a+1,b+2)

        • Большее <lbp> делает <op> право-ассоциативным, в том время как
          большее <rbp> делает <op> лево-ассоциативным.
          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) infix ("@", 100, 99)$
          (%i3) foo @ bar @ baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("@", 100, 101)$
          (%i5) foo @ bar @ baz;
          (%o5)                    ((foo,bar),baz)

     Maxima может обнаружить некоторые синтаксические ошибки, сравнивая
     объявленные для оператора части речи с актуальными выражениями.

          (%i1) infix ("##", 100, 99, expr, expr, expr);
          (%o1)                          ##
          (%i2) if x ## y then 1 else 0;
          Incorrect syntax: Found algebraic expression where logical expression expected
          if x ## y then
                       ^
          (%i2) infix ("##", 100, 99, expr, expr, clause);
          (%o2)                          ##
          (%i3) if x ## y then 1 else 0;
          (%o3)                if x ## y then 1 else 0

 -- Управляющая переменная: inflag
     Значение по умолчанию: ‘false’

     Когда ‘inflag’ есть ‘true’, функции для извлечения частей выражения
     работает с внутренней формой ‘expr’.

     Заметим, что упрощатель переупорядочивает выражения.  Таким
     образом, ‘first (x + y)’ возвращает ‘x’ если ‘inflag’ есть ‘true’,
     и ‘y’, если ‘inflag’ есть ‘false’ (‘first (y + x)’ дает те же
     результаты.)

     Также, установка ‘inflag’ равным ‘true’ и вызов ‘part’ или
     ‘substpart’ есть тоже самое, что вызов ‘inpart’ или ‘substinpart’.

     Функции, на которые влияет значение ‘inflag’: ‘part’, ‘substpart’,
     ‘first’, ‘rest’, ‘last’, ‘length’, конструкция ‘for’ ...  ‘in’,
     ‘map’, ‘fullmap’, ‘maplist’, ‘reveal’ и ‘pickapart’.

 -- Функция: inpart (<expr>, <n_1>, ..., <n_k>)
     аналогична ‘part’, но работает с внутренним представлением
     выражения, а не с выводимой формой, и, таким образом, может быть
     быстрее, так как форматирование не выполняется.  Нужно быть
     осторожным по отношению к порядку подвыражений в суммах и
     произведениях (так как этот порядок переменных в внутренней форме
     часто отличается от порядка в выводимой форме) и в работе с унарным
     минусом, вычитанием и делением (так как эти операторы удаляются из
     выражения).  ‘part (x+y, 0)’ или ‘inpart (x+y, 0)’ дает ‘+’, хотя
     для ссылки на оператор он должен быть заключен в двойные кавычки.
     Например ‘... if inpart (%o9,0) = "+" then ...’.

     Примеры:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)

 -- Функция: isolate (<expr>, <x>)
     Возвращает <expr> с подвыражениями, которые есть суммы, и которые
     не содержат переменную <var>, замененные метками промежуточных
     выражений (атомарными символами, такими как ‘%t1’, ‘%t2’, ...).
     Это часто бывает полезно, чтобы избежать ненужного раскрытия
     подвыражений, которые не содержат интересующих переменных.  Так как
     данные метки промежуточных выражений имеют подвыражения в качестве
     своих значений, то они могут быть подставлены обратно вычислением
     этого выражения.

     Если ‘exptisolate’ (значение по умолчанию: ‘false’) равно ‘true’,
     то ‘isolate’ исследует показатели атомов (таких как ‘%e’), которые
     содержат переменную <var>.

     Если ‘isolate_wrt_times’ равно ‘true’, то ‘isolate’ изолирует также
     по отношению к произведениям.  См.  ‘isolate_wrt_times’.

     Выполните ‘example (isolate)’ для других примеров.

 -- Управляющая переменная: isolate_wrt_times
     Значение по умолчанию: ‘false’

     Когда ‘isolate_wrt_times’ равно ‘true’, то ‘isolate’ также
     изолирует по отношению к произведениям.  Например, сравнивает обе
     установки

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4

 -- Управляющая переменная: listconstvars
     Значение по умолчанию: ‘false’

     Когда ‘listconstvars’ есть ‘true’, то в список, возвращаемый
     ‘listofvars’, включаются ‘%e’, ‘%pi’, ‘%i’ и другие переменные,
     объявленные константами.  По умолчанию они опускаются.

 -- Управляющая переменная: listdummyvars
     Значение по умолчанию: ‘true’

     Когда ‘listdummyvars’ есть ‘false’, "немые переменные" в выражении
     не будут включаться в список, возвращаемый ‘listofvars’.  (Смысл
     "немых переменных" тот же, что и в ‘freeof’.  "Немые переменные" –
     это математические объекты, такие как индекс суммы или
     произведения, переменная предела и переменная интегрирования в
     определенном интеграле).

     Пример:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]

 -- Функция: listofvars (<expr>)
     Возвращает список переменных в <expr>.

     Когда ‘listconstvars’ есть ‘true’, то в список, возвращаемый
     ‘listofvars’, включаются ‘%e’, ‘%pi’, ‘%i’ и другие переменные,
     объявленные константами.  По умолчанию они опускаются.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1

 -- Функция: lfreeof (<list>, <expr>)
     Для каждого члена <m> списка <list>, вызывает ‘freeof (<m>,
     <expr>)’.  Возвращает ‘false’, если какой либо из вызовов ‘freeof’
     дает ‘false’, иначе возвращает ‘true’.

 -- Функция: lopow (<expr>, <x>)
     Возвращает наименьший показатель степени <x>, который явно
     присутствует в <expr>.  Таким образом,

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- Функция: lpart (<label>, <expr>, <n_1>, ..., <n_k>)
     Аналогично ‘dpart’, но использует помеченный бокс.  Помеченный бокс
     аналогичен боксу сделанному с помощью ‘dpart’, но имеет имя в
     верхней строке.

 -- Функция: multthru (<expr>)
 -- Функция: multthru (<expr_1>, <expr_2>)
     Умножает множитель <expr> (который должен быть суммой) на другие
     множители <expr>.  То есть, <expr> есть ‘<f_1> <f_2> ... <f_n>’,
     где по крайней мере один множитель, скажем <f_i>, есть сумма
     членов.  Каждый член в той сумме умножается на остальные множители
     в этом произведении.  (А именно на все множители, за исключением
     <f_i>).  ‘multthru’ не раскрывает суммы, возведенные в степень.
     Эта функция есть самый быстрый способ распространять произведения
     (коммутативные или некоммутативные) на суммы.  Так как дроби
     представляются как произведения, то ‘multthru’ может также
     использоваться для деления сумм на произведения.

     ‘multthru (<expr_1>, <expr_2>)’ умножает каждый член в <expr_2>
     (который должен быть суммой или уравнением) на <expr_1>.  Если
     <expr_1> сам по себе не является суммой, то эта форма эквивалентна
     ‘multthru (<expr_1>*<expr_2>)’.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b

 -- Функция: nounify (<f>)
     Возвращает невычисляемую форму функции с именем <f>.  Это
     необходимо, если требуется представить имя вычисляемой функции так,
     если бы она была невычисляемой.  Заметим, что некоторые вычисляемые
     функции возвращают их невычисляемые формы, если они не могут быть
     вычислены для определенных значений аргументов.  Невычисляемая
     форма возвращается также в случае, если перед функцией стоит
     кавычка.

 -- Функция: nterms (<expr>)
     Возвращает число членов, которое выражение <expr> имело бы, если
     оно было бы полностью раскрыто и не возникло бы сокращений или
     комбинаций членов.  Заметим, что выражения такие как ‘sin
     (<expr>)’, ‘sqrt (<expr>)’, ‘exp (<expr>)’ и др.  считаются только
     как один член, вне независимости от того, как много членов <expr>
     имеет (если оно сумма).

 -- Функция: op (<expr>)
     Возвращает главный оператор выражения <expr>.  ‘op (<expr>)’
     эквивалентно ‘part (<expr>, 0)’.

     ‘op’ возвращает строку, если главный оператор встроенный или
     определенный пользователем префиксный, бинарный или n-арный
     инфиксный, постфиксный, матчфиксный или безфиксный оператор.  Иначе
     ‘op’ возвращает символ.

     ‘op’ следит за значением глобального флага ‘inflag’.

     ‘op’ вычисляет свой аргумент.

     См.  также ‘args’.

     Примеры:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"

 -- Функция: operatorp (<expr>, <op>)
 -- Функция: operatorp (<expr>, [<op_1>, ..., <op_n>])

     ‘operatorp (<expr>, <op>)’ возвращает ‘true’, если <op> равен
     оператору <expr>.

     ‘operatorp (<expr>, [<op_1>, ..., <op_n>])’ возвращает ‘true’, если
     какой-нибудь элемент <op_1>, ..., <op_n> равен оператору <expr>.

 -- Функция: optimize (<expr>)
     Возвращает выражение, которое выдает тоже самое значение и побочные
     эффекты, как и <expr>, но выполняется более эффективно за счет
     устранения лишних повторных вычислений общих подвыражений.
     ‘optimize’ также имеет побочный эффект "сворачивания" своего
     аргумента так что все общие подвыражения используются совместно.
     Выполните ‘example (optimize)’ для примеров.

 -- Управляющая переменная: optimprefix
     Значение по умолчанию: ‘%’

     ‘optimprefix’ это префикс, используемый для генерации символов
     командой ‘optimize’.

 -- Функция: ordergreat (<v_1>, ..., <v_n>)
     Устанавливает синонимы для переменных <v_1>, ..., <v_n>, такие, что
     <v_1> > <v_2> > ...  > <v_n>, и <v_n> > любой другой переменной, не
     включенной в аргументы.

     См.  также ‘orderless’.

 -- Функция: ordergreatp (<expr_1>, <expr_2>)
     Возвращает ‘true’, если <expr_2> предшествует <expr_1> в
     упорядочивании, установленном с помощью функции ‘ordergreat’.

 -- Функция: orderless (<v_1>, ..., <v_n>)
     Устанавливает синонимы для переменных <v_1>, ..., <v_n>, такие, что
     <v_1> < <v_2> < ...  < <v_n>, и <v_n> < любой другой переменная, не
     включенной в аргументы.

     Таким образом, полная шкала упорядочивания такова: численные
     константы < объявленные константы < объявленные скаляры < первый
     аргумент ‘orderless’ < ...  < последний аргумент ‘orderless’ <
     переменные, которые начинаются с A < ...  < переменные, которые
     начинаются с Z < последний аргумент ‘ordergreat’ < ...  < первый
     аргумент ‘ordergreat’ < объявленные главные переменные ‘mainvar’.

     См.  также ‘ordergreat’ и ‘mainvar’.

 -- Функция: orderlessp (<expr_1>, <expr_2>)
     Возвращает ‘true’, если <expr_1> предшествует <expr_2> в
     упорядочивании, установленном командой ‘orderless’.

 -- Функция: part (<expr>, <n_1>, ..., <n_k>)
     Возвращает части внешней формы ‘expr’.  Функция получает часть
     ‘expr’, которая определена индексами <n_1>, ..., <n_k>.  Когда
     первая часть <n_1> ‘expr’ взята, берется часть <n_2> от нее и т.д.
     Результат есть часть <n_k> от ...  части <n_2>, от части <n_1>
     выражения ‘expr’.

     ‘part’ может быть использована для того, чтобы получить элемент
     списка, строку матрицы и т.п.

     Если последний аргумент функции ‘part’ есть список индексов, то
     выбираются несколько подвыражений, каждое из которых соответствует
     индексу в списке.  Таким образом, ‘part (x + y + z, [1, 3])’ есть
     ‘z+x’.

     ‘piece’ запоминает последнее выражение, выбранное при использовании
     функции ‘part’.  Оно доступно во время выполнения этой функция и,
     таким образом, может быть использовано в самой функции, как
     показано ниже.

     Если ‘partswitch’ установлен равным ‘true’, то ‘end’ возвращается
     когда выбранная часть выражения не существует, иначе выдается
     сообщение об ошибке.

     Пример: ‘part (z+2*y, 2, 1)’ дает 2.

     ‘example (part)’ показывает дополнительные примеры.

 -- Функция: partition (<expr>, <x>)
     Возвращает список из двух выражений.  Они есть (1) множители <expr>
     (если оно произведение), члены <expr> (если оно является суммой),
     или список (если оно является списком), которые не содержит <x> и,
     (2) те множители, члены или список, которые содержат.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]

 -- Управляющая переменная: partswitch
     Значение по умолчанию: ‘false’

     Когда ‘partswitch’ есть ‘true’, то ‘end’ возвращается, если
     выбранная часть выражения не существует, иначе выдается сообщение
     об ошибке.

 -- Функция: pickapart (<expr>, <n>)
     Присваивает меткам промежуточных выражений все подвыражения <expr>
     глубины <n> (целое число).  Подвыражения большей или меньшей глубин
     меткам не присваиваются.  ‘pickapart’ возвращает выражение в
     терминах промежуточных выражений эквивалентное исходному <expr>.

     См.  также ‘part’, ‘dpart’, ‘lpart’, ‘inpart’ и ‘reveal’.

     Примеры:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2

 -- Системная переменная: piece
     Содержит последнее выражение, выбранное при использовании функции
     ‘part’.  Оно доступно во время выполнения функции и, таким образом,
     может быть в ней использовано.

 -- Функция: polarform (<expr>)
     Возвращает выражение ‘r %e^(%i theta)’ эквивалентное <expr>, такое,
     что ‘r’ и ‘theta’ чисто вещественные.

 -- Функция: powers (<expr>, <x>)
     Выдает степени <x>, встречающиеся в <expr>.

     ‘load ("powers")’ загружает эту функцию.

 -- Функция: product (<expr>, <i>, <i_0>, <i_1>)
     Представляет произведение значений <expr> с индексом <i>,
     меняющимся от <i_0> до <i_1>.  Невычисляемая форма ‘'product’
     изображается как заглавная буква пи.

     ‘product’ вычисляет <expr> и нижний и верхний пределы <i_0> и
     <i_1>, ‘product’ не вычисляет индекс <i>.

     Если верхний и нижний пределы различаются на целое число, <expr>
     вычисляется для каждого значения индекса <i>, и результат есть
     точное произведение.

     Иначе, диапазон индекса является неопределенным.  Для упрощения
     произведения применяются некоторые правила.  Когда глобальная
     переменная ‘simpproduct’ есть ‘true’, применяются дополнительные
     правила.  В некоторых случаях, упрощение дает результат, который не
     является произведением, иначе, результат есть невычисляемая форма
     ‘'product’.

     См.  также ‘nouns’ и ‘evflag’.

     Примеры:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- Функция: realpart (<expr>)
     Возвращает вещественную часть <expr>.  ‘realpart’ и ‘imagpart’
     будут работать для выражений, включающих тригонометрические и
     гипергеометрические функции, также как и квадратный корень,
     логарифм и возведение в степень.

 -- Функция: rectform (<expr>)
     Возвращает выражение ‘a + b %i’, эквивалентное <expr>, такое, что
     <a> и <b> чисто вещественные.

 -- Функция: rembox (<expr>, unlabelled)
 -- Функция: rembox (<expr>, <label>)
 -- Функция: rembox (<expr>)
     Удаляет боксы из <expr>.

     ‘rembox (<expr>, unlabelled)’ удаляет все непомеченные боксы из
     <expr>.

     ‘rembox (<expr>, <label>)’ удаляет только боксы, содержащие
     <label>.

     ‘rembox (<expr>)’ удаляет все боксы, помеченные и непомеченные.

     Боксы рисуются функциями ‘box’, ‘dpart’ и ‘lpart’.

     Примеры:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h

 -- Функция: sum (<expr>, <i>, <i_0>, <i_1>)
     Представляет собой суммирование значений <expr> для индекса <i>,
     изменяющегося от <i_0> до <i_1>.  Невычисляемая форма ‘'sum’
     изображается как заглавная буква сигма.

     ‘sum’ вычисляет свое слагаемое <expr> и нижний и верхний пределы
     <i_0> и <i_1>, ‘sum’ не вычисляет индекс <i>.

     Если верхний и нижний пределы отличаются на целое число, слагаемое
     <expr> вычисляется для каждого значения индекса суммирования <i>, и
     результат есть точная сумма.

     Иначе, диапазон индекса является неопределенным.  Для упрощения
     суммирования применяются некоторые правила.  Когда глобальная
     переменная ‘simpsum’ есть ‘true’, дополнительные правила
     применяются.  В некоторых случаях, упрощение дает результат,
     который не есть суммирование, иначе, результат есть невычисляемая
     форма ‘'sum’.

     Когда ‘evflag’ (флаг вычисления) ‘cauchysum’ есть ‘true’,
     произведение суммирования выражается как произведение Коши, в
     котром индекс внутреннего суммирования есть функция индекса
     внешнего суммирования, а не меняющейся независимо индекс.

     Глобальная переменная ‘genindex’ есть буквенный префикс,
     используемый для генерации следующего индекса суммирования, если
     требуется автоматически сгенерированный индекс.

     ‘gensumnum’ есть численный суффикс, используемый для генерирования
     следующего используемый для генерации следующего индекса
     суммирования, если требуется автоматически сгенерированный индекс.
     Когда ‘gensumnum’ есть ‘false’, автоматически сгенерированный
     индекс есть только ‘genindex’ без численного суффикса.

     См.  также ‘sumcontract’, ‘intosum’, ‘bashindices’, ‘niceindices’,
     ‘nouns’, ‘evflag’ и ‘zeilberger’.

     Примеры:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- Функция: lsum (<expr>, <x>, <L>)
     Представляет собой сумму <expr> для каждого элемента <x> в <L>.

     Невычисляемая форма ‘'lsum’ возвращается, если аргумент <L> не
     вычисляется до списка.

     Примеры:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1, x)

 -- Функция: verbify (<f>)
     Возвращает вычисляемую форму функции с именем <f>.

     См.  также ‘verb’, ‘noun’ и ‘nounify’.

     Примеры:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO

