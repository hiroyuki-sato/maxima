This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Константы,  Next: Тригонометрия,  Prev: Polynomials,  Up: Top

12 Константы
************

* Menu:

* Математические константы::


File: maxima.info,  Node: Математические константы,  Prev: Константы,  Up: Константы

12.1 Математические константы
=============================

 -- Константа: %e
     ‘%e’ представляет основание натурального логарифма, также известное
     как число Эйлера.  Численное значение ‘%e’ является числом с
     плавающей точкой двойной точности 2.718281828459045d0.

 -- Константа: %i
     ‘%i’ представляет мнимую единицу, sqrt(-1).

 -- Константа: false
     ‘false’ – логическая константа "ложь".  В Maxima ‘false’
     представляется значением ‘NIL’ в Lisp.

 -- Константа: ind

     ‘ind’ представляет конечный, неопределенный результат.

     См.  также ‘limit’.

     Пример:

          (%i1) limit (sin(1/x), x, 0);
          (%o1)                          ind

 -- Константа: inf
     ‘inf’ представляет вещественную положительную бесконечность.

 -- Константа: infinity
     ‘infinity’ представляет комплексную бесконечность.

 -- Константа: minf
     ‘minf’ представляет вещественную минус (т.е.  отрицательную)
     бесконечность.

 -- Константа: %phi

     ‘%phi’ представляет так называемое золотое сечение, (1 +
     sqrt(5))/2.  Численное значение ‘%phi’ является числом с плавающей
     точкой двойной точности 1.618033988749895d0.

     ‘fibtophi’ выражает числа Фибоначчи ‘fib(n)’ в терминах ‘%phi’.

     По умолчанию Maxima не знает алгебраические свойства ‘%phi’.  После
     выполнения ‘tellrat(%phi^2 - %phi - 1)’ и ‘algebraic: true’,
     ‘ratsimp’ может упрощать некоторые выражения, содержащие ‘%phi’.

     Примеры:

     ‘fibtophi’ выражает числа Фибоначчи ‘fib(n)’ в терминах ‘%phi’.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     По умолчанию Maxima не знает алгебраические свойства ‘%phi’.  После
     выполнения ‘tellrat(%phi^2 - %phi - 1)’ и ‘algebraic: true’,
     ‘ratsimp’ может упрощать некоторые выражения, содержащие ‘%phi’.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0

 -- Константа: %pi
     ‘%pi’ представляет отношение длины окружности к ее диаметру.
     Численное значение ‘%pi’ является числом с плавающей точкой двойной
     точности 3.141592653589793d0.

 -- Константа: true
     ‘true’ – логическая константа "истина".  В Maxima ‘true’
     представляется значением ‘T’ в Lisp.

 -- Константа: und

     ‘und’ представляет неопределенный результат.

     См.  также ‘limit’.

     Пример:

          (%i1) limit (1/x, x, 0);
          (%o1)                          und


File: maxima.info,  Node: Тригонометрия,  Next: Special Functions,  Prev: Константы,  Up: Top

13 Тригонометрия
****************

* Menu:

* Тригонометрия в Maxima::  
* Функции и переменные для тригонометрии::  


File: maxima.info,  Node: Тригонометрия в Maxima,  Next: Функции и переменные для тригонометрии,  Prev: Тригонометрия,  Up: Тригонометрия

13.1 Тригонометрия в Maxima
===========================

В Maxima определено много тригонометрических функций.
Запрограммированны не все тригонометрические тождества, но пользователь
может добавить большинство из них благодаря возможностям системы по
поиску совпадений с шаблонами (подстановки).  В Maxima определены
следующие тригонометрические функции ‘acos’, ‘acosh’, ‘acot’, ‘acoth’,
‘acsc’, ‘acsch’, ‘asec’, ‘asech’, ‘asin’, ‘asinh’, ‘atan’, ‘atanh’,
‘cos’, ‘cosh’, ‘cot’, ‘coth’, ‘csc’, ‘csch’, ‘sec’, ‘sech’, ‘sin’,
‘sinh’, ‘tan’ и ‘tanh’.  Для работы с тригонометрическими функциями есть
ряд особых команд, см.  ‘trigexpand’, ‘trigreduce’ и ‘trigsign’.  Два
встроенных пакета расширяют правила упрощения Maxima: ‘ntrig’ и
‘atrig1’.  Для подробностей запустите ‘describe(<command>)’.


File: maxima.info,  Node: Функции и переменные для тригонометрии,  Prev: Тригонометрия в Maxima,  Up: Тригонометрия

13.2 Функции и переменные для тригонометрии
===========================================

 -- Управляющая переменная: %piargs
     Значение по умолчанию: ‘true’

     Если ‘%piargs’ равно ‘true’, то тригонометрические функции
     упрощаются до алгебраических констант, если аргумент кратен %pi,
     %pi/2, %pi/3, %pi/4 или %pi/6.

     Maxima использует некоторые тождества, применимые, если %pi
     домножается на целую переменную (символ, определенный как целое
     число).

     Примеры:

          (%i1) %piargs : false;
          (%o1)                         false
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true;
          (%o4)                         true
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3), cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Некоторые тождества применяются, если ‘%pi’ и ‘%pi/2’ домножается
     на целую переменную (символ, определенный как целое число):

          (%i1) declare (n, integer, m, even);
          (%o1)                         done
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m), cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]

 -- Управляющая переменная: %iargs
     Значение по умолчанию: ‘true’

     Если ‘%iargs’ равно ‘true’, то тригонометрические функции
     упрощаются до гиперболических, если аргумент явно домножается на
     мнимую единицу %i.

     Упрощение производится, даже если аргумент явно является
     вещественным; Maxima лишь проверяет, просматривается ли явно в
     аргументе множитель %i.

     Примеры:

          (%i1) %iargs : false;
          (%o1)                         false
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true;
          (%o3)                         true
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     Упрощение проводится, даже если аргумент явно является
     вещественным:

          (%i1) declare (x, imaginary);
          (%o1)                         done
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)

 -- Функция: acos (<x>)
     - Арккосинус.

 -- Функция: acosh (<x>)
     - Ареакосинус (гиперболический арккосинус).

 -- Функция: acot (<x>)
     - Арккотангенс.

 -- Функция: acoth (<x>)
     - Ареакотангенс (гиперболический арккотангенс).

 -- Функция: acsc (<x>)
     - Арккосеканс.

 -- Функция: acsch (<x>)
     - Ареакосеканс (гиперболический арккосеканс).

 -- Функция: asec (<x>)
     - Арксеканс.

 -- Функция: asech (<x>)
     - Ареасеканс (гиперболический арксеканс).

 -- Функция: asin (<x>)
     - Арксинус.

 -- Функция: asinh (<x>)
     - Ареасинус (гиперболический арксинус).

 -- Функция: atan (<x>)
     - Арктангенс.

 -- Функция: atan2 (<y>, <x>)
     - соответствует значению ‘atan(<y>/<x>)’ на интервале (‘-%pi’,
     ‘%pi’).

 -- Функция: atanh (<x>)
     - Ареатангенс (гиперболический арктангенс).

 -- Пакет: atrig1
     Пакет ‘atrig1’ содержит несколько дополнительных правил упрощения
     для обратных тригонометрических функций.  Вместе с уже известными
     Maxima правилами, полностью реализована работа с углами ‘0’,
     ‘%pi/6’, ‘%pi/4’, ‘%pi/3’ и ‘%pi/2’, а также соответствующими
     углами в трех других четвертях.  Для использования пакета выполните
     ‘load("atrig1");’.

 -- Функция: cos (<x>)
     - Косинус.

 -- Функция: cosh (<x>)
     - Ареакосинус (гиперболический арккосинус).

 -- Функция: cot (<x>)
     - Котангенс.

 -- Функция: coth (<x>)
     - Ареакотангенс (гиперболический арккотангенс).

 -- Функция: csc (<x>)
     - Косеканс.

 -- Функция: csch (<x>)
     - Ареакосеканс (гиперболический арккосеканс).

 -- Управляющая переменная: halfangles
     Значение по умолчанию: ‘false’

     Если ‘halfangles’ равно ‘true’, то тригонометрические функции
     аргументов ‘<expr>/2’ упрощаются в функции от <expr>.

     Примеры:

          (%i1) halfangles : false;
          (%o1)                         false
          (%i2) sin (x / 2);
                                           x
          (%o2)                        sin(-)
                                           2
          (%i3) halfangles : true;
          (%o3)                         true
          (%i4) sin (x / 2);
                                  sqrt(1 - cos(x))
          (%o4)                   ----------------
                                      sqrt(2)

 -- Пакет: ntrig
     Пакет ‘ntrig’ содержит набор правил упрощения для
     тригонометрических функций с аргументами вида ‘<f>(<n> %pi/10)’,
     где <f> - одна из функций ‘sin’, ‘cos’, ‘tan’, ‘csc’, ‘sec’ и
     ‘cot’.

 -- Функция: sec (<x>)
     - Секанс.

 -- Функция: sech (<x>)
     - Гиперболический секанс.

 -- Функция: sin (<x>)
     - Синус.

 -- Функция: sinh (<x>)
     - Гиперболический синус.

 -- Функция: tan (<x>)
     - Тангенс.

 -- Функция: tanh (<x>)
     - Гиперболический тангенс.

 -- Функция: trigexpand (<expr>)
     Раскрывает тригонометрические и гиперболические функции суммы или
     произведения углов в <expr>.  Для получения лучших результатов
     нужно сначала раскрыть <expr>.  Для повышения пользовательского
     контроля за упрощением функция раскрывает только один уровень
     сумм/произведений за раз.  Для полного раскрытия в синусы и
     косинусы укажите ‘trigexpand: true’.

     ‘trigexpand’ управляется следующими глобальными флагами:

     ‘trigexpand’
          Раскрывать все получающиеся в последствии выражения с синусами
          и косинусами.
     ‘halfangles’
          Раскрывать функции половинных углов в функции полных углов.
     ‘trigexpandplus’
          Раскрывать функции сумм аргументов (например, ‘sin(x + y)’).
     ‘trigexpandtimes’
          Раскрывать функции кратных аргументов (например, ‘sin(2 x)’).

     Примеры:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- Управляющая переменная: trigexpandplus
     Значение по умолчанию: ‘true’

     ‘trigexpandplus’ управляет раскрытием функций от сумм аргументов в
     ‘trigexpand’ (если ‘trigexpand’ равно ‘true’, либо в функции
     ‘trigexpand’), например, ‘sin(x+y)’.  Упрощение производится,
     только если ‘trigexpandplus’ равно ‘true’.

 -- Управляющая переменная: trigexpandtimes
     Значение по умолчанию: ‘true’

     ‘trigexpandplus’ управляет раскрытием функций от произведений
     аргументов в ‘trigexpand’ (если ‘trigexpand’ равно ‘true’, либо в
     функции ‘trigexpand’), например, ‘sin(2*x)’.  Упрощение
     производится, только если ‘trigexpandtimes’ равно ‘true’.

 -- Управляющая переменная: triginverses
     Значение по умолчанию: ‘all’

     ‘triginverses’ управляет раскрытием композиций тригонометрических и
     гиперболических функций со своими обратными функциями.

     Если ‘all’, то и ‘atan(tan(<x>))’, и ‘tan(atan(<x>))’ упрощается в
     <x>.

     Если ‘true’, то упрощение ‘<arcfun>(<fun>(<x>))’ не производится.

     Если ‘false’, то ни ‘<arcfun>(<fun>(<x>))’, ни
     ‘<fun>(<arcfun>(<x>))’ не будет упрощено.

 -- Функция: trigreduce (<expr>, <x>)
 -- Функция: trigreduce (<expr>)

     Раскрывает произведения и степени ‘sin’, ‘cos’, ‘sinh’, ‘cosh’ в
     функции кратных аргументов <x>.  Также производится попытка
     исключить такие функции из знаменателей.  Если <x> не указано,
     будут использоваться все переменные из <expr>.

     См.  также ‘poissimp’.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     В некоторых простых случаях команды упрощения используют информацию
     о переменных, объявленную следующим образом:

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)

 -- Управляющая переменная: trigsign
     Значение по умолчанию: ‘true’

     Если ‘trigsign’ равно ‘true’, допускается упрощение отрицательных
     аргументов тригонометрических функций.  Например, ‘sin(-x)’
     раскроется в ‘-sin(x)’.

 -- Функция: trigsimp (<expr>)
     Применяет тождества sin(x)^2 + cos(x)^2 = 1 и cosh(x)^2 - sinh(x)^2
     = 1 для упрощения выражений с ‘tan’, ‘sec’, и так далее, до
     выражений с ‘sin’, ‘cos’, ‘sinh’, ‘cosh’.

     Результат может упрощаться далее с ‘trigreduce’, ‘ratsimp’, и
     ‘radcan’.

     ‘demo ("trgsmp.dem")’ показывает несколько примеров для ‘trigsimp’.

 -- Функция: trigrat (<expr>)
     Возвращает канонический упрощенный квазилинейный вид
     тригонометрического выражения; <expr> - рациональная дробь с
     функциями ‘sin’, ‘cos’ или ‘tan’, аргументы которых - линейные
     формы некоторых переменных и ‘%pi/<n>’ (<n> - целое) с целыми
     коэффициентами.  Результат - упрощенная дробь с линейным числителем
     и знаменателем с ‘sin’ и ‘cos’.  Таким образом, ‘trigrat’ переходит
     к линейному виду, только если это возможно.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     Следующий пример взят из раздела 1.5.5, "Теорема Морлея", книги
     Davenport, Siret, Tournier, Calcul Formel, изд-во Masson
     (английский перевод - Addison-Wesley).

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4


File: maxima.info,  Node: Special Functions,  Next: Эллиптические функции,  Prev: Тригонометрия,  Up: Top

14 Special Functions
********************

* Menu:

* Introduction to Special Functions::
* Bessel Functions::
* Airy Functions::
* Gamma and factorial Functions::
* Exponential Integrals::
* Error Function::
* Struve Functions::
* Hypergeometric Functions::
* Parabolic Cylinder Functions::
* Functions and Variables for Special Functions::  


File: maxima.info,  Node: Introduction to Special Functions,  Next: Bessel Functions,  Prev: Special Functions,  Up: Special Functions

14.1 Introduction to Special Functions
======================================

Special function notation follows:

     bessel_j (index, expr)         Bessel function, 1st kind
     bessel_y (index, expr)         Bessel function, 2nd kind
     bessel_i (index, expr)         Modified Bessel function, 1st kind
     bessel_k (index, expr)         Modified Bessel function, 2nd kind

     hankel_1 (v,z)                 Hankel function of the 1st kind
     hankel_2 (v,z)                 Hankel function of the 2nd kind
     struve_h (v,z)                 Struve H function
     struve_l (v,z)                 Struve L function

     assoc_legendre_p[v,u] (z)      Legendre function of degree v and order u
     assoc_legendre_q[v,u] (z)      Legendre function, 2nd kind

     %f[p,q] ([], [], expr)         Generalized Hypergeometric function
     gamma (z)                      Gamma function
     gamma_incomplete_lower (a,z)   Lower incomplete gamma function
     gamma_incomplete (a,z)         Tail of incomplete gamma function
     hypergeometric (l1, l2, z)     Hypergeometric function
     slommel
     %m[u,k] (z)                    Whittaker function, 1st kind
     %w[u,k] (z)                    Whittaker function, 2nd kind
     erfc (z)                       Complement of the erf function

     expintegral_e (v,z)            Exponential integral E
     expintegral_e1 (z)             Exponential integral E1
     expintegral_ei (z)             Exponential integral Ei
     expintegral_li (z)             Logarithmic integral Li
     expintegral_si (z)             Exponential integral Si
     expintegral_ci (z)             Exponential integral Ci
     expintegral_shi (z)            Exponential integral Shi
     expintegral_chi (z)            Exponential integral Chi

     kelliptic (z)                  Complete elliptic integral of the first
                                    kind (K)
     parabolic_cylinder_d (v,z)     Parabolic cylinder D function


File: maxima.info,  Node: Bessel Functions,  Next: Airy Functions,  Prev: Introduction to Special Functions,  Up: Special Functions

14.2 Bessel Functions
=====================

 -- Function: bessel_j (<v>, <z>)

     The Bessel function of the first kind of order v and argument z.

     ‘bessel_j’ is defined as

                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     although the infinite series is not used for computations.

 -- Function: bessel_y (<v>, <z>)

     The Bessel function of the second kind of order v and argument z.

     ‘bessel_y’ is defined as
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     when v is not an integer.  When v is an integer n, the limit as v
     approaches n is taken.

 -- Function: bessel_i (<v>, <z>)

     The modified Bessel function of the first kind of order v and
     argument z.

     ‘bessel_i’ is defined as
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     although the infinite series is not used for computations.

 -- Function: bessel_k (<v>, <z>)

     The modified Bessel function of the second kind of order v and
     argument z.

     ‘bessel_k’ is defined as
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     when v is not an integer.  If v is an integer n, then the limit as
     v approaches n is taken.

 -- Function: hankel_1 (<v>, <z>)

     The Hankel function of the first kind of order v and argument z
     (A&S 9.1.3).  ‘hankel_1’ is defined as

             bessel_j(v,z) + %i * bessel_y(v,z)

     Maxima evaluates ‘hankel_1’ numerically for a complex order v and
     complex argument z in float precision.  The numerical evaluation in
     bigfloat precision is not supported.

     When ‘besselexpand’ is ‘true’, ‘hankel_1’ is expanded in terms of
     elementary functions when the order v is half of an odd integer.
     See ‘besselexpand’.

     Maxima knows the derivative of ‘hankel_1’ wrt the argument z.

     Examples:

     Numerical evaluation:

          (%i1) hankel_1(1,0.5);
          (%o1)        0.24226845767487 - 1.471472392670243 %i
          (%i2) hankel_1(1,0.5+%i);
          (%o2)       - 0.25582879948621 %i - 0.23957560188301

     Expansion of ‘hankel_1’ when ‘besselexpand’ is ‘true’:

          (%i1) hankel_1(1/2,z),besselexpand:true;
                         sqrt(2) sin(z) - sqrt(2) %i cos(z)
          (%o1)          ----------------------------------
                                 sqrt(%pi) sqrt(z)

     Derivative of ‘hankel_1’ wrt the argument z.  The derivative wrt
     the order v is not supported.  Maxima returns a noun form:

          (%i1) diff(hankel_1(v,z),z);
                       hankel_1(v - 1, z) - hankel_1(v + 1, z)
          (%o1)        ---------------------------------------
                                          2
          (%i2) diff(hankel_1(v,z),v);
                                 d
          (%o2)                  -- (hankel_1(v, z))
                                 dv

 -- Function: hankel_2 (<v>, <z>)

     The Hankel function of the second kind of order v and argument z
     (A&S 9.1.4).  ‘hankel_2’ is defined as

             bessel_j(v,z) - %i * bessel_y(v,z)

     Maxima evaluates ‘hankel_2’ numerically for a complex order v and
     complex argument z in float precision.  The numerical evaluation in
     bigfloat precision is not supported.

     When ‘besselexpand’ is ‘true’, ‘hankel_2’ is expanded in terms of
     elementary functions when the order v is half of an odd integer.
     See ‘besselexpand’.

     Maxima knows the derivative of ‘hankel_2’ wrt the argument z.

     For examples see ‘hankel_1’.

 -- Option variable: besselexpand
     Default value: ‘false’

     Controls expansion of the Bessel functions when the order is half
     of an odd integer.  In this case, the Bessel functions can be
     expanded in terms of other elementary functions.  When
     ‘besselexpand’ is ‘true’, the Bessel function is expanded.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                                  sin(z)   cos(z)
                                 sqrt(2) sqrt(z) (------ - ------)
                                                     2       z
                                                    z
          (%o4)                  ---------------------------------
                                             sqrt(%pi)

 -- Function: scaled_bessel_i (<v>, <z>)

     The scaled modified Bessel function of the first kind of order v
     and argument z.  That is, scaled\_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  This function is particularly useful
     for calculating bessel_i for large z, which is large.  However,
     maxima does not otherwise know much about this function.  For
     symbolic work, it is probably preferable to work with the
     expression ‘exp(-abs(z))*bessel_i(v, z)’.

 -- Function: scaled_bessel_i0 (<z>)

     Identical to ‘scaled_bessel_i(0,z)’.

 -- Function: scaled_bessel_i1 (<z>)

     Identical to ‘scaled_bessel_i(1,z)’.

 -- Function: %s [<u>,<v>] (<z>)
     Lommel’s little s[u,v](z) function.  Probably Gradshteyn & Ryzhik
     8.570.1.


File: maxima.info,  Node: Airy Functions,  Next: Gamma and factorial Functions,  Prev: Bessel Functions,  Up: Special Functions

14.3 Airy Functions
===================

The Airy functions Ai(x) and Bi(x) are defined in Abramowitz and Stegun,
Handbook of Mathematical Functions, Section 10.4.

   ‘y = Ai(x)’ and ‘y = Bi(x)’ are two linearly independent solutions of
the Airy differential equation ‘diff (y(x), x, 2) - x y(x) = 0’.

   If the argument ‘x’ is a real or complex floating point number, the
numerical value of the function is returned.

 -- Function: airy_ai (<x>)
     The Airy function Ai(x).  (A&S 10.4.2)

     The derivative ‘diff (airy_ai(x), x)’ is ‘airy_dai(x)’.

     See also ‘airy_bi’, ‘airy_dai’, ‘airy_dbi’.

 -- Function: airy_dai (<x>)
     The derivative of the Airy function Ai ‘airy_ai(x)’.

     See ‘airy_ai’.

 -- Function: airy_bi (<x>)
     The Airy function Bi(x).  (A&S 10.4.3)

     The derivative ‘diff (airy_bi(x), x)’ is ‘airy_dbi(x)’.

     See ‘airy_ai’, ‘airy_dbi’.

 -- Function: airy_dbi (<x>)
     The derivative of the Airy Bi function ‘airy_bi(x)’.

     See ‘airy_ai’ and ‘airy_bi’.


File: maxima.info,  Node: Gamma and factorial Functions,  Next: Exponential Integrals,  Prev: Airy Functions,  Up: Special Functions

14.4 Gamma and factorial Functions
==================================

The gamma function and the related beta, psi and incomplete gamma
functions are defined in Abramowitz and Stegun, Handbook of Mathematical
Functions, Chapter 6.

 -- Function: bffac (<expr>, <n>)

     Bigfloat version of the factorial (shifted gamma) function.  The
     second argument is how many digits to retain and return, it’s a
     good idea to request a couple of extra.

 -- Function: bfpsi (<n>, <z>, <fpprec>)
 -- Function: bfpsi0 (<z>, <fpprec>)

     ‘bfpsi’ is the polygamma function of real argument <z> and integer
     order <n>.  ‘bfpsi0’ is the digamma function.  ‘bfpsi0 (<z>,
     <fpprec>)’ is equivalent to ‘bfpsi (0, <z>, <fpprec>)’.

     These functions return bigfloat values.  <fpprec> is the bigfloat
     precision of the return value.

 -- Function: cbffac (<z>, <fpprec>)
     Complex bigfloat factorial.

     ‘load ("bffac")’ loads this function.

 -- Function: gamma (<z>)

     The basic definition of the gamma function (A&S 6.1.1) is

                                   inf
                                  /
                                  [     z - 1   - t
                       gamma(z) = I    t      %e    dt
                                  ]
                                  /
                                   0

     Maxima simplifies ‘gamma’ for positive integer and positive and
     negative rational numbers.  For half integral values the result is
     a rational number times ‘sqrt(%pi)’.  The simplification for
     integer values is controlled by ‘factlim’.  For integers greater
     than ‘factlim’ the numerical result of the factorial function,
     which is used to calculate ‘gamma’, will overflow.  The
     simplification for rational numbers is controlled by ‘gammalim’ to
     avoid internal overflow.  See ‘factlim’ and ‘gammalim’.

     For negative integers ‘gamma’ is not defined.

     Maxima can evaluate ‘gamma’ numerically for real and complex values
     in float and bigfloat precision.

     ‘gamma’ has mirror symmetry.

     When ‘gamma_expand’ is ‘true’, Maxima expands ‘gamma’ for arguments
     ‘z+n’ and ‘z-n’ where ‘n’ is an integer.

     Maxima knows the derivative of ‘gamma’.

     Examples:

     Simplification for integer, half integral, and rational numbers:

          (%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
          (%o1)        [1, 1, 2, 6, 24, 120, 720, 5040, 40320]
          (%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                              sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
          (%o2)   [sqrt(%pi), ---------, -----------, ------------]
                                  2           4            8
          (%i3) map('gamma,[2/3,5/3,7/3]);
                                            2           1
                                    2 gamma(-)  4 gamma(-)
                                2           3           3
          (%o3)          [gamma(-), ----------, ----------]
                                3       3           9

     Numerical evaluation for real and complex values:

          (%i4) map('gamma,[2.5,2.5b0]);
          (%o4)     [1.329340388179137, 1.3293403881791370205b0]
          (%i5) map('gamma,[1.0+%i,1.0b0+%i]);
          (%o5) [0.498015668118356 - .1549498283018107 %i,
                    4.9801566811835604272b-1 - 1.5494982830181068513b-1 %i]

     ‘gamma’ has mirror symmetry:

          (%i6) declare(z,complex)$
          (%i7) conjugate(gamma(z));
          (%o7)                  gamma(conjugate(z))

     Maxima expands ‘gamma(z+n)’ and ‘gamma(z-n)’, when ‘gamma_expand’
     is ‘true’:

          (%i8) gamma_expand:true$

          (%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                         gamma(z)
          (%o9)             [z gamma(z), --------, z + 1]
                                          z - 1

     The derivative of ‘gamma’:

          (%i10) diff(gamma(z),z);
          (%o10)                  psi (z) gamma(z)
                                     0

     See also ‘makegamma’.

     The Euler-Mascheroni constant is ‘%gamma’.

 -- Function: log_gamma (<z>)

     The natural logarithm of the gamma function.

 -- Function: gamma_incomplete_lower (<a>, <z>)

     The lower incomplete gamma function (A&S 6.5.2):

                                              z
                                             /
                                             [  a - 1   - t
              gamma_incomplete_lower(a, z) = I t      %e    dt
                                             ]
                                             /
                                              0

     See also ‘gamma_incomplete’ (upper incomplete gamma function).

 -- Function: gamma_incomplete (<a>, <z>)

     The incomplete upper gamma function (A&S 6.5.3):

                                        inf
                                       /
                                       [     a - 1   - t
              gamma_incomplete(a, z) = I    t      %e    dt
                                       ]
                                       /
                                        z

     See also ‘gamma_expand’ for controlling how ‘gamma_incomplete’ is
     expressed in terms of elementary functions and ‘erfc’.

     Also see the related functions ‘gamma_incomplete_regularized’ and
     ‘gamma_incomplete_generalized’.

 -- Function: gamma_incomplete_regularized (<a>, <z>)

     The regularized incomplete upper gamma function (A&S 6.5.1):

          gamma_incomplete_regularized(a, z) =
                                                  gamma_incomplete(a, z)
                                                  ----------------------
                                                         gamma(a)

     See also ‘gamma_expand’ for controlling how ‘gamma_incomplete’ is
     expressed in terms of elementary functions and ‘erfc’.

     Also see ‘gamma_incomplete’.

 -- Function: gamma_incomplete_generalized (<a>, <z1>, <z1>)

     The generalized incomplete gamma function.

          gamma_incomplete_generalized(a, z1, z2) =
                                                         z2
                                                        /
                                                        [    a - 1   - t
                                                        I   t      %e    dt
                                                        ]
                                                        /
                                                         z1

     Also see ‘gamma_incomplete’ and ‘gamma_incomplete_regularized’.

 -- Option variable: gamma_expand
     Default value: ‘false’

     ‘gamma_expand’ controls expansion of ‘gamma_incomplete’.  When
     ‘gamma_expand’ is ‘true’, ‘gamma_incomplete(v,z)’ is expanded in
     terms of ‘z’, ‘exp(z)’, and ‘gamma_incomplete’ or ‘erfc(z)’ when
     possible.

          (%i1) gamma_incomplete(2,z);
          (%o1)                       gamma_incomplete(2, z)
          (%i2) gamma_expand:true;
          (%o2)                                true
          (%i3) gamma_incomplete(2,z);
                                                     - z
          (%o3)                            (z + 1) %e
          (%i4) gamma_incomplete(3/2,z);
                                        - z   sqrt(%pi) erfc(sqrt(z))
          (%o4)               sqrt(z) %e    + -----------------------
                                                         2
          (%i5) gamma_incomplete(4/3,z);
                                                              1
                                             gamma_incomplete(-, z)
                                 1/3   - z                    3
          (%o5)                 z    %e    + ----------------------
                                                       3
          (%i6) gamma_incomplete(a+2,z);
                       a               - z
          (%o6)       z  (z + a + 1) %e    + a (a + 1) gamma_incomplete(a, z)
          (%i7) gamma_incomplete(a-2, z);
                  gamma_incomplete(a, z)    a - 2         z            1      - z
          (%o7)   ---------------------- - z      (--------------- + -----) %e
                     (1 - a) (2 - a)               (a - 2) (a - 1)   a - 2

 -- Option variable: gammalim
     Default value: 10000

     ‘gammalim’ controls simplification of the gamma function for
     integral and rational number arguments.  If the absolute value of
     the argument is not greater than ‘gammalim’, then simplification
     will occur.  Note that the ‘factlim’ switch controls simplification
     of the result of ‘gamma’ of an integer argument as well.

 -- Function: makegamma (<expr>)
     Transforms instances of binomial, factorial, and beta functions in
     <expr> into gamma functions.

     See also ‘makefact’.

 -- Function: beta (<a>, <b>)
     The beta function is defined as ‘gamma(a) gamma(b)/gamma(a+b)’ (A&S
     6.2.1).

     Maxima simplifies the beta function for positive integers and
     rational numbers, which sum to an integer.  When
     ‘beta_args_sum_to_integer’ is ‘true’, Maxima simplifies also
     general expressions which sum to an integer.

     For <a> or <b> equal to zero the beta function is not defined.

     In general the beta function is not defined for negative integers
     as an argument.  The exception is for <a=-n>, <n> a positive
     integer and <b> a positive integer with ‘b<=n’, it is possible to
     define an analytic continuation.  Maxima gives for this case a
     result.

     When ‘beta_expand’ is ‘true’, expressions like ‘beta(a+n,b)’ and
     ‘beta(a-n,b)’ or ‘beta(a,b+n)’ and ‘beta(a,b-n)’ with ‘n’ an
     integer are simplified.

     Maxima can evaluate the beta function for real and complex values
     in float and bigfloat precision.  For numerical evaluation Maxima
     uses ‘log_gamma’:

                     - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
                   %e

     Maxima knows that the beta function is symmetric and has mirror
     symmetry.

     Maxima knows the derivatives of the beta function with respect to
     <a> or <b>.

     To express the beta function as a ratio of gamma functions see
     ‘makegamma’.

     Examples:

     Simplification, when one of the arguments is an integer:

          (%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                                         1   9      1
          (%o1)                         [--, -, ---------]
                                         12  4  a (a + 1)

     Simplification for two rational numbers as arguments which sum to
     an integer:

          (%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                                    3 %pi   2 %pi
          (%o2)                    [-----, -------, sqrt(2) %pi]
                                      8    sqrt(3)

     When setting ‘beta_args_sum_to_integer’ to ‘true’ more general
     expression are simplified, when the sum of the arguments is an
     integer:

          (%i3) beta_args_sum_to_integer:true$
          (%i4) beta(a+1,-a+2);
                                          %pi (a - 1) a
          (%o4)                         ------------------
                                        2 sin(%pi (2 - a))

     The possible results, when one of the arguments is a negative
     integer:

          (%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                              1  1    1
          (%o5)                            [- -, -, - -]
                                              3  6    3

     ‘beta(a+n,b)’ or ‘beta(a-n)’ with ‘n’ an integer simplifies when
     ‘beta_expand’ is ‘true’:

          (%i6) beta_expand:true$
          (%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                              a beta(a, b)  beta(a, b) (b + a - 1)  a
          (%o7)              [------------, ----------------------, -]
                                 b + a              a - 1           b

     Beta is not defined, when one of the arguments is zero:

          (%i7) beta(0,b);
          beta: expected nonzero arguments; found 0, b
           -- an error.  To debug this try debugmode(true);

     Numerical evaluation for real and complex arguments in float or
     bigfloat precision:

          (%i8) beta(2.5,2.3);
          (%o8) .08694748611299981

          (%i9) beta(2.5,1.4+%i);
          (%o9) 0.0640144950796695 - .1502078053286415 %i

          (%i10) beta(2.5b0,2.3b0);
          (%o10) 8.694748611299969b-2

          (%i11) beta(2.5b0,1.4b0+%i);
          (%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i

     Beta is symmetric and has mirror symmetry:

          (%i14) beta(a,b)-beta(b,a);
          (%o14)                                 0
          (%i15) declare(a,complex,b,complex)$
          (%i16) conjugate(beta(a,b));
          (%o16)                 beta(conjugate(a), conjugate(b))

     The derivative of the beta function wrt ‘a’:

          (%i17) diff(beta(a,b),a);
          (%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                                0             0

 -- Function: beta_incomplete (<a>, <b>, <z>)

     The basic definition of the incomplete beta function (A&S 6.6.1) is

                  z
                 /
                 [         b - 1  a - 1
                 I  (1 - t)      t      dt
                 ]
                 /
                  0

     This definition is possible for realpart(a)>0 and realpart(b)>0 and
     abs(z)<1.  For other values the incomplete beta function can be
     defined through a generalized hypergeometric function:

             gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z

     (See <https://functions.wolfram.com> for a complete definition of
     the incomplete beta function.)

     For negative integers a = -n and positive integers b=m with m<=n
     the incomplete beta function is defined through

                                      m - 1           k
                                      ====  (1 - m)  z
                                n - 1 \            k
                               z       >    -----------
                                      /     k! (n - k)
                                      ====
                                      k = 0

     Maxima uses this definition to simplify ‘beta_incomplete’ for <a> a
     negative integer.

     For <a> a positive integer, ‘beta_incomplete’ simplifies for any
     argument <b> and <z> and for <b> a positive integer for any
     argument <a> and <z>, with the exception of <a> a negative integer.

     For z=0 and realpart(a)>0, ‘beta_incomplete’ has the specific value
     zero.  For <z=1> and realpart(b)>0, ‘beta_incomplete’ simplifies to
     the beta function ‘beta(a,b)’.

     Maxima evaluates ‘beta_incomplete’ numerically for real and complex
     values in float or bigfloat precision.  For the numerical
     evaluation an expansion of the incomplete beta function in
     continued fractions is used.

     When the option variable ‘beta_expand’ is ‘true’, Maxima expands
     expressions like ‘beta_incomplete(a+n,b,z)’ and
     ‘beta_incomplete(a-n,b,z)’ where n is a positive integer.

     Maxima knows the derivatives of ‘beta_incomplete’ with respect to
     the variables <a>, <b> and <z> and the integral with respect to the
     variable <z>.

     Examples:

     Simplification for <a> a positive integer:

          (%i1) beta_incomplete(2,b,z);
                                                 b
                                      1 - (1 - z)  (b z + 1)
          (%o1)                       ----------------------
                                            b (b + 1)

     Simplification for <b> a positive integer:

          (%i2) beta_incomplete(a,2,z);
                                                         a
                                        (a (1 - z) + 1) z
          (%o2)                         ------------------
                                            a (a + 1)

     Simplification for <a> and <b> a positive integer:

          (%i3) beta_incomplete(3,2,z);
                                                         3
                                        (3 (1 - z) + 1) z
          (%o3)                         ------------------
                                                12

     <a> is a negative integer and b<=(-a), Maxima simplifies:

          (%i4) beta_incomplete(-3,1,z);
                                                 1
          (%o4)                              - ----
                                                  3
                                               3 z

     For the specific values z=0 and z=1, Maxima simplifies:

          (%i5) assume(a>0,b>0)$
          (%i6) beta_incomplete(a,b,0);
          (%o6)                                 0
          (%i7) beta_incomplete(a,b,1);
          (%o7)                            beta(a, b)

     Numerical evaluation in float or bigfloat precision:

          (%i8) beta_incomplete(0.25,0.50,0.9);
          (%o8)                          4.594959440269333
          (%i9)  fpprec:25$
          (%i10) beta_incomplete(0.25,0.50,0.9b0);
          (%o10)                    4.594959440269324086971203b0

     For abs(z)>1 ‘beta_incomplete’ returns a complex result:

          (%i11) beta_incomplete(0.25,0.50,1.7);
          (%o11)              5.244115108584249 - 1.45518047787844 %i

     Results for more general complex arguments:

          (%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
          (%o14)             2.726960675662536 - .3831175704269199 %i
          (%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
          (%o15)             13.04649635168716 %i - 5.802067956270001
          (%i16)

     Expansion, when ‘beta_expand’ is ‘true’:

          (%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                                 b  a
                             a beta_incomplete(a, b, z)   (1 - z)  z
          (%o23)             -------------------------- - -----------
                                       b + a                 b + a

          (%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                                 b  a - 1
                 beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
          (%o24) -------------------------------------- - ---------------
                                 1 - a                         1 - a

     Derivative and integral for ‘beta_incomplete’:

          (%i34) diff(beta_incomplete(a, b, z), z);
                                        b - 1  a - 1
          (%o34)                 (1 - z)      z
          (%i35) integrate(beta_incomplete(a, b, z), z);
                        b  a
                 (1 - z)  z
          (%o35) ----------- + beta_incomplete(a, b, z) z
                    b + a
                                                 a beta_incomplete(a, b, z)
                                               - --------------------------
                                                           b + a
          (%i36) factor(diff(%, z));
          (%o36)              beta_incomplete(a, b, z)

 -- Function: beta_incomplete_regularized (<a>, <b>, <z>)

     The regularized incomplete beta function (A&S 6.6.2), defined as

          beta_incomplete_regularized(a, b, z) =
                                                beta_incomplete(a, b, z)
                                                ------------------------
                                                       beta(a, b)

     As for ‘beta_incomplete’ this definition is not complete.  See
     <https://functions.wolfram.com> for a complete definition of
     ‘beta_incomplete_regularized’.

     ‘beta_incomplete_regularized’ simplifies <a> or <b> a positive
     integer.

     For z=0 and realpart(a)>0, ‘beta_incomplete_regularized’ has the
     specific value 0.  For <z=1> and realpart(b)>0,
     ‘beta_incomplete_regularized’ simplifies to 1.

     Maxima can evaluate ‘beta_incomplete_regularized’ for real and
     complex arguments in float and bigfloat precision.

     When ‘beta_expand’ is ‘true’, Maxima expands
     ‘beta_incomplete_regularized’ for arguments a+n or a-n, where n is
     an integer.

     Maxima knows the derivatives of ‘beta_incomplete_regularized’ with
     respect to the variables <a>, <b>, and <z> and the integral with
     respect to the variable <z>.

     Examples:

     Simplification for <a> or <b> a positive integer:

          (%i1) beta_incomplete_regularized(2,b,z);
                                                 b
          (%o1)                       1 - (1 - z)  (b z + 1)

          (%i2) beta_incomplete_regularized(a,2,z);
                                                         a
          (%o2)                         (a (1 - z) + 1) z

          (%i3) beta_incomplete_regularized(3,2,z);
                                                         3
          (%o3)                         (3 (1 - z) + 1) z

     For the specific values z=0 and z=1, Maxima simplifies:

          (%i4) assume(a>0,b>0)$
          (%i5) beta_incomplete_regularized(a,b,0);
          (%o5)                                 0
          (%i6) beta_incomplete_regularized(a,b,1);
          (%o6)                                 1

     Numerical evaluation for real and complex arguments in float and
     bigfloat precision:

          (%i7) beta_incomplete_regularized(0.12,0.43,0.9);
          (%o7)                         .9114011367359802
          (%i8) fpprec:32$
          (%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
          (%o9)               9.1140113673598075519946998779975b-1
          (%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
          (%o10)             .2865367499935403 %i - 0.122995963334684
          (%i11) fpprec:20$
          (%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
          (%o12)      2.8653674999354036142b-1 %i - 1.2299596333468400163b-1

     Expansion, when ‘beta_expand’ is ‘true’:

          (%i13) beta_incomplete_regularized(a+1,b,z);
                                                               b  a
                                                        (1 - z)  z
          (%o13) beta_incomplete_regularized(a, b, z) - ------------
                                                        a beta(a, b)
          (%i14) beta_incomplete_regularized(a-1,b,z);
          (%o14) beta_incomplete_regularized(a, b, z)
                                                               b  a - 1
                                                        (1 - z)  z
                                                   - ----------------------
                                                     beta(a, b) (b + a - 1)

     The derivative and the integral wrt <z>:

          (%i15) diff(beta_incomplete_regularized(a,b,z),z);
                                        b - 1  a - 1
                                 (1 - z)      z
          (%o15)                 -------------------
                                     beta(a, b)
          (%i16) integrate(beta_incomplete_regularized(a,b,z),z);
          (%o16) beta_incomplete_regularized(a, b, z) z
                                                                     b  a
                                                              (1 - z)  z
                    a (beta_incomplete_regularized(a, b, z) - ------------)
                                                              a beta(a, b)
                  - -------------------------------------------------------
                                             b + a

 -- Function: beta_incomplete_generalized (<a>, <b>, <z1>, <z2>)

     The basic definition of the generalized incomplete beta function is

                       z2
                     /
                     [          b - 1  a - 1
                     I   (1 - t)      t      dt
                     ]
                     /
                      z1

     Maxima simplifies ‘beta_incomplete_regularized’ for <a> and <b> a
     positive integer.

     For realpart(a)>0 and z1=0 or z2=0, Maxima simplifies
     ‘beta_incomplete_generalized’ to ‘beta_incomplete’.  For
     realpart(b)>0 and z1=1 or <z2=1>, Maxima simplifies to an
     expression with ‘beta’ and ‘beta_incomplete’.

     Maxima evaluates ‘beta_incomplete_regularized’ for real and complex
     values in float and bigfloat precision.

     When ‘beta_expand’ is ‘true’, Maxima expands
     ‘beta_incomplete_generalized’ for a+n and a-n, <n> a positive
     integer.

     Maxima knows the derivative of ‘beta_incomplete_generalized’ with
     respect to the variables <a>, <b>, <z1>, and <z2> and the integrals
     with respect to the variables <z1> and <z2>.

     Examples:

     Maxima simplifies ‘beta_incomplete_generalized’ for <a> and <b> a
     positive integer:

          (%i1) beta_incomplete_generalized(2,b,z1,z2);
                             b                      b
                     (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
          (%o1)      -------------------------------------------
                                      b (b + 1)
          (%i2) beta_incomplete_generalized(a,2,z1,z2);
                                        a                      a
                     (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
          (%o2)      -------------------------------------------
                                      a (a + 1)
          (%i3) beta_incomplete_generalized(3,2,z1,z2);
                        2      2                       2      2
                (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
          (%o3) -----------------------------------------------------------
                                            12

     Simplification for specific values z1=0, z2=0, z1=1, or z2=1:

          (%i4) assume(a > 0, b > 0)$
          (%i5) beta_incomplete_generalized(a,b,z1,0);
          (%o5)                    - beta_incomplete(a, b, z1)

          (%i6) beta_incomplete_generalized(a,b,0,z2);
          (%o6)                    - beta_incomplete(a, b, z2)

          (%i7) beta_incomplete_generalized(a,b,z1,1);
          (%o7)              beta(a, b) - beta_incomplete(a, b, z1)

          (%i8) beta_incomplete_generalized(a,b,1,z2);
          (%o8)              beta_incomplete(a, b, z2) - beta(a, b)

     Numerical evaluation for real arguments in float or bigfloat
     precision:

          (%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
          (%o9)                        .09638178086368676

          (%i10) fpprec:32$
          (%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
          (%o10)               9.6381780863686935309170054689964b-2

     Numerical evaluation for complex arguments in float or bigfloat
     precision:

          (%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
          (%o11)           - .09625463003205376 %i - .003323847735353769
          (%i12) fpprec:20$
          (%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
          (%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3

     Expansion for a+n or a-n, <n> a positive integer, when
     ‘beta_expand’ is ‘true’:

          (%i14) beta_expand:true$

          (%i15) beta_incomplete_generalized(a+1,b,z1,z2);

                         b   a           b   a
                 (1 - z1)  z1  - (1 - z2)  z2
          (%o15) -----------------------------
                             b + a
                                a beta_incomplete_generalized(a, b, z1, z2)
                              + -------------------------------------------
                                                   b + a
          (%i16) beta_incomplete_generalized(a-1,b,z1,z2);

                 beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
          (%o16) -------------------------------------------------------
                                          1 - a
                                              b   a - 1           b   a - 1
                                      (1 - z2)  z2      - (1 - z1)  z1
                                    - -------------------------------------
                                                      1 - a

     Derivative wrt the variable <z1> and integrals wrt <z1> and <z2>:

          (%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                         b - 1   a - 1
          (%o17)               - (1 - z1)      z1
          (%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
          (%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                            + beta_incomplete(a + 1, b, z1)
          (%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
          (%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                            - beta_incomplete(a + 1, b, z2)

 -- Option variable: beta_expand
     Default value: false

     When ‘beta_expand’ is ‘true’, ‘beta(a,b)’ and related functions are
     expanded for arguments like a+n or a-n, where n is an integer.

 -- Option variable: beta_args_sum_to_integer
     Default value: false

     When ‘beta_args_sum_to_integer’ is ‘true’, Maxima simplifies
     ‘beta(a,b)’, when the arguments <a> and <b> sum to an integer.

 -- Function: psi [<n>](<x>)

     The derivative of ‘log (gamma (<x>))’ of order ‘<n>+1’.  Thus,
     ‘psi[0](<x>)’ is the first derivative, ‘psi[1](<x>)’ is the second
     derivative, etc.

     Maxima does not know how, in general, to compute a numerical value
     of ‘psi’, but it can compute some exact values for rational args.
     Several variables control what range of rational args ‘psi’ will
     return an exact value, if possible.  See ‘maxpsiposint’,
     ‘maxpsinegint’, ‘maxpsifracnum’, and ‘maxpsifracdenom’.  That is,
     <x> must lie between ‘maxpsinegint’ and ‘maxpsiposint’.  If the
     absolute value of the fractional part of <x> is rational and has a
     numerator less than ‘maxpsifracnum’ and has a denominator less than
     ‘maxpsifracdenom’, ‘psi’ will return an exact value.

     The function ‘bfpsi’ in the ‘bffac’ package can compute numerical
     values.

 -- Option variable: maxpsiposint
     Default value: 20

     ‘maxpsiposint’ is the largest positive value for which ‘psi[n](x)’
     will try to compute an exact value.

 -- Option variable: maxpsinegint
     Default value: -10

     ‘maxpsinegint’ is the most negative value for which ‘psi[n](x)’
     will try to compute an exact value.  That is if <x> is less than
     ‘maxnegint’, ‘psi[n](<x>)’ will not return simplified answer, even
     if it could.

 -- Option variable: maxpsifracnum
     Default value: 6

     Let <x> be a rational number less than one of the form ‘p/q’.  If
     ‘p’ is greater than ‘maxpsifracnum’, then ‘psi[<n>](<x>)’ will not
     try to return a simplified value.

 -- Option variable: maxpsifracdenom
     Default value: 6

     Let <x> be a rational number less than one of the form ‘p/q’.  If
     ‘q’ is greater than ‘maxpsifracdenom’, then ‘psi[<n>](<x>)’ will
     not try to return a simplified value.

 -- Function: makefact (<expr>)
     Transforms instances of binomial, gamma, and beta functions in
     <expr> into factorials.

     See also ‘makegamma’.

 -- Function: numfactor (<expr>)
     Returns the numerical factor multiplying the expression <expr>,
     which should be a single term.

     ‘content’ returns the greatest common divisor (gcd) of all terms in
     a sum.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8


File: maxima.info,  Node: Exponential Integrals,  Next: Error Function,  Prev: Gamma and factorial Functions,  Up: Special Functions

14.5 Exponential Integrals
==========================

The Exponential Integral and related functions are defined in Abramowitz
and Stegun, Handbook of Mathematical Functions, Chapter 5

 -- Function: expintegral_e1 (<z>)
     The Exponential Integral E1(z) (A&S 5.1.1) defined as

     integrate(exp(-t)/t, t, z, inf) with abs(arg z) < %pi.

 -- Function: expintegral_ei (<z>)
     The Exponential Integral Ei(z) (A&S 5.1.2)

 -- Function: expintegral_li (<z>)
     The Exponential Integral Li(z) (A&S 5.1.3)

 -- Function: expintegral_e (<n>,<z>)
     The Exponential Integral En(z) (A&S 5.1.4) defined as

     integrate(exp(-z*t)/t^n, t, 1, inf) with real(x) > 1 and n a
     non-negative integer.

 -- Function: expintegral_si (<z>)
     The Exponential Integral Si(z) (A&S 5.2.1) defined as

     integrate(sin(t)/t, t, 0, z)

 -- Function: expintegral_ci (<z>)
     The Exponential Integral Ci(z) (A&S 5.2.2) defined as

     %gamma + log(z) + integrate((cos(t) - 1)/t, t, 0, z)

     with abs(arg z) < %pi

 -- Function: expintegral_shi (<z>)
     The Exponential Integral Shi(z) (A&S 5.2.3) defined as

     integrate(sinh(t)/t, t, 0, z)

 -- Function: expintegral_chi (<z>)
     The Exponential Integral Chi(z) (A&S 5.2.4) defined as

     %gamma + log(z) + integrate((cosh(t) - 1)/t, t, 0, z)

     with abs(arg z) < %pi

 -- Option variable: expintrep
     Default value: false

     Change the representation of one of the exponential integrals,
     <expintegral_e(m, z)>, <expintegral_e1>, or <expintegral_ei> to an
     equivalent form if possible.

     Possible values for <expintrep> are <false>, <gamma_incomplete>,
     <expintegral_e1>, <expintegral_ei>, <expintegral_li>,
     <expintegral_trig>, or <expintegral_hyp>.

     <false> means that the representation is not changed.  Other values
     indicate the representation is to be changed to use the function
     specified where <expintegral_trig> means <expintegral_si>,
     <expintegral_ci>, and <expintegral_hyp> means <expintegral_shi> or
     <expintegral_chi>.

 -- Option variable: expintexpand
     Default value: false

     Expand the Exponential Integral E[n](z) for half integral values in
     terms of Erfc or Erf and for positive integers in terms of Ei


File: maxima.info,  Node: Error Function,  Next: Struve Functions,  Prev: Exponential Integrals,  Up: Special Functions

14.6 Error Function
===================

The Error function and related functions are defined in Abramowitz and
Stegun, Handbook of Mathematical Functions, Chapter 7

 -- Function: erf (<z>)

     The Error Function erf(z) (A&S 7.1.1)

     See also flag ‘erfflag’.

 -- Function: erfc (<z>)
     The Complementary Error Function erfc(z) (A&S 7.1.2)

     ‘erfc(z) = 1-erf(z)’

 -- Function: erfi (<z>)
     The Imaginary Error Function.

     ‘erfi(z) = -%i*erf(%i*z)’

 -- Function: erf_generalized (<z1>,<z2>)
     Generalized Error function Erf(z1,z2)

 -- Function: fresnel_c (<z>)
     The Fresnel Integral C(z) = integrate(cos((%pi/2)*t^2),t,0,z).
     (A&S 7.3.1)

     The simplification fresnel_c(-x) = -fresnel_c(x) is applied when
     flag ‘trigsign’ is true.

     The simplification fresnel_c(%i*x) = %i*fresnel_c(x) is applied
     when flag ‘%iargs’ is true.

     See flags ‘erf_representation’ and ‘hypergeometric_representation’.

 -- Function: fresnel_s (<z>)
     The Fresnel Integral S(z) = integrate(sin((%pi/2)*t^2),t,0,z).
     (A&S 7.3.2)

     The simplification fresnel_s(-x) = -fresnel_s(x) is applied when
     flag ‘trigsign’ is true.

     The simplification fresnel_s(%i*x) = -%i*fresnel_s(x) is applied
     when flag ‘%iargs’ is true.

     See flags ‘erf_representation’ and ‘hypergeometric_representation’.

 -- Option variable: erf_representation
     Default value: false

     When T erfc, erfi, erf_generalized, fresnel_s and fresnel_c are
     transformed to erf.

 -- Option variable: hypergeometric_representation
     Default value: false

     Enables transformation to a Hypergeometric representation for
     fresnel_s and fresnel_c


File: maxima.info,  Node: Struve Functions,  Next: Hypergeometric Functions,  Prev: Error Function,  Up: Special Functions

14.7 Struve Functions
=====================

The Struve functions are defined in Abramowitz and Stegun, Handbook of
Mathematical Functions, Chapter 12.

 -- Function: struve_h (<v>, <z>)
     The Struve Function H of order v and argument z.  (A&S 12.1.1)

 -- Function: struve_l (<v>, <z>)
     The Modified Struve Function L of order v and argument z.  (A&S
     12.2.1)


File: maxima.info,  Node: Hypergeometric Functions,  Next: Parabolic Cylinder Functions,  Prev: Struve Functions,  Up: Special Functions

14.8 Hypergeometric Functions
=============================

The Hypergeometric Functions are defined in Abramowitz and Stegun,
Handbook of Mathematical Functions, Chapters 13 and 15.

   Maxima has very limited knowledge of these functions.  They can be
returned from function ‘hgfred’.

 -- Function: %m [<k>,<u>] (<z>)
     Whittaker M function ‘M[k,u](z) =
     exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)’.  (A&S 13.1.32)

 -- Function: %w [<k>,<u>] (<z>)
     Whittaker W function.  (A&S 13.1.33)

 -- Function: %f [<p>,<q>] (<[a],[b],z>)
     The pFq(a1,a2,..ap;b1,b2,..bq;z) hypergeometric function, where ‘a’
     a list of length ‘p’ and ‘b’ a list of length ‘q’.

 -- Function: hypergeometric ([<a1>, ..., <ap>],[<b1>, ... ,<bq>], x)
     The hypergeometric function.  Unlike Maxima’s ‘%f’ hypergeometric
     function, the function ‘hypergeometric’ is a simplifying function;
     also, ‘hypergeometric’ supports complex double and big floating
     point evaluation.  For the Gauss hypergeometric function, that is p
     = 2 and q = 1, floating point evaluation outside the unit circle is
     supported, but in general, it is not supported.

     When the option variable ‘expand_hypergeometric’ is true (default
     is false) and one of the arguments ‘a1’ through ‘ap’ is a negative
     integer (a polynomial case), ‘hypergeometric’ returns an expanded
     polynomial.

     Examples:

          (%i1)  hypergeometric([],[],x);
          (%o1) %e^x

     Polynomial cases automatically expand when ‘expand_hypergeometric’
     is true:

          (%i2) hypergeometric([-3],[7],x);
          (%o2) hypergeometric([-3],[7],x)

          (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
          (%o3) -x^3/504+3*x^2/56-3*x/7+1

     Both double float and big float evaluation is supported:

          (%i4) hypergeometric([5.1],[7.1 + %i],0.42);
          (%o4)       1.346250786375334 - 0.0559061414208204 %i
          (%i5) hypergeometric([5,6],[8], 5.7 - %i);
          (%o5)     .007375824009774946 - .001049813688578674 %i
          (%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
          (%o6) 7.37582400977494674506442010824b-3
                                    - 1.04981368857867315858055393376b-3 %i


File: maxima.info,  Node: Parabolic Cylinder Functions,  Next: Functions and Variables for Special Functions,  Prev: Hypergeometric Functions,  Up: Special Functions

14.9 Parabolic Cylinder Functions
=================================

The Parabolic Cylinder Functions are defined in Abramowitz and Stegun,
Handbook of Mathematical Functions, Chapter 19.

   Maxima has very limited knowledge of these functions.  They can be
returned from function ‘hgfred’.

 -- Function: parabolic_cylinder_d (<v>, <z>)
     The parabolic cylinder function ‘parabolic_cylinder_d(v,z)’.  (A&S
     19.3.1)


File: maxima.info,  Node: Functions and Variables for Special Functions,  Prev: Parabolic Cylinder Functions,  Up: Special Functions

14.10 Functions and Variables for Special Functions
===================================================

 -- Function: specint (exp(- s*<t>) * <expr>, <t>)

     Compute the Laplace transform of <expr> with respect to the
     variable <t>.  The integrand <expr> may contain special functions.
     The parameter <s> maybe be named something else; it is determined
     automatically, as the examples below show where <p> is used in some
     places.

     The following special functions are handled by ‘specint’:
     incomplete gamma function, error functions (but not the error
     function ‘erfi’, it is easy to transform ‘erfi’ e.g.  to the error
     function ‘erf’), exponential integrals, bessel functions (including
     products of bessel functions), hankel functions, hermite and the
     laguerre polynomials.

     Furthermore, ‘specint’ can handle the hypergeometric function
     ‘%f[p,q]([],[],z)’, the whittaker function of the first kind
     ‘%m[u,k](z)’ and of the second kind ‘%w[u,k](z)’.

     The result may be in terms of special functions and can include
     unsimplified hypergeometric functions.

     When ‘laplace’ fails to find a Laplace transform, ‘specint’ is
     called.  Because ‘laplace’ knows more general rules for Laplace
     transforms, it is preferable to use ‘laplace’ and not ‘specint’.

     ‘demo("hypgeo")’ displays several examples of Laplace transforms
     computed by ‘specint’.

     Examples:
          (%i1) assume (p > 0, a > 0)$
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

     Examples for exponential integrals:

          (%i4) assume(s>0,a>0,s-a>0)$
          (%i5) ratsimp(specint(%e^(a*t)
                                *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                                       log(s)
          (%o5)                        ------
                                       s - a
          (%i6) logarc:true$

          (%i7) gamma_expand:true$

          radcan(specint((cos(t)*expintegral_si(t)
                               -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                                       log(s)
          (%o8)                        ------
                                        2
                                       s  + 1
          ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                                -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                                         2    2
                                    log(s  + a )
          (%o9)                     ------------
                                          2
                                         s

     Results when using the expansion of ‘gamma_incomplete’ and when
     changing the representation to ‘expintegral_e1’:

          (%i10) assume(s>0)$
          (%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                                      1
                                      gamma_incomplete(-, k s)
                                                      2
          (%o11)                      ------------------------
                                         sqrt(%pi) sqrt(s)

          (%i12) gamma_expand:true$
          (%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                        erfc(sqrt(k) sqrt(s))
          (%o13)                        ---------------------
                                               sqrt(s)

          (%i14) expintrep:expintegral_e1$
          (%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                                        a s
                                  a s %e    expintegral_e1(a s) - 1
          (%o15)                - ---------------------------------
                                                  a

 -- Function: hypergeometric_simp (<e>)

     ‘hypergeometric_simp’ simplifies hypergeometric functions by
     applying ‘hgfred’ to the arguments of any hypergeometric functions
     in the expression <e>.

     Only instances of ‘hypergeometric’ are affected; any ‘%f’, ‘%w’,
     and ‘%m’ in the expression <e> are not affected.  Any unsimplified
     hypergeometric functions are returned unchanged (instead of
     changing to ‘%f’ as ‘hgfred’ would).

     ‘load("hypergeometric");’ loads this function.

     See also ‘hgfred’.

     Examples:

          (%i1) load ("hypergeometric") $
          (%i2) foo : [hypergeometric([1,1], [2], z), hypergeometric([1/2], [1], z)];
          (%o2) [hypergeometric([1, 1], [2], z),
                                                               1
                                               hypergeometric([-], [1], z)]
                                                               2
          (%i3) hypergeometric_simp (foo);
                           log(1 - z)              z    z/2
          (%o3)         [- ----------, bessel_i(0, -) %e   ]
                               z                   2
          (%i4) bar : hypergeometric([n], [m], z + 1);
          (%o4)            hypergeometric([n], [m], z + 1)
          (%i5) hypergeometric_simp (bar);
          (%o5)            hypergeometric([n], [m], z + 1)

 -- Function: hgfred (<a>, <b>, <t>)

     Simplify the generalized hypergeometric function in terms of other,
     simpler, forms.  <a> is a list of numerator parameters and <b> is a
     list of the denominator parameters.

     If ‘hgfred’ cannot simplify the hypergeometric function, it returns
     an expression of the form ‘%f[p,q]([a], [b], x)’ where <p> is the
     number of elements in <a>, and <q> is the number of elements in
     <b>.  This is the usual ‘pFq’ generalized hypergeometric function.

          (%i1) assume(not(equal(z,0)));
          (%o1)                          [notequal(z, 0)]
          (%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                               v/2                               %i z
                              4    bessel_j(v, z) gamma(v + 1) %e
          (%o2)               ---------------------------------------
                                                 v
                                                z
          (%i3) hgfred([1,1],[2],z);

                                             log(1 - z)
          (%o3)                            - ----------
                                                 z
          (%i4) hgfred([a,a+1/2],[3/2],z^2);

                                         1 - 2 a          1 - 2 a
                                  (z + 1)        - (1 - z)
          (%o4)                   -------------------------------
                                           2 (1 - 2 a) z

     It can be beneficial to load orthopoly too as the following example
     shows.  Note that <L> is the generalized Laguerre polynomial.

          (%i5) load("orthopoly")$
          (%i6) hgfred([-2],[a],z);

                                              (a - 1)
                                           2 L       (z)
                                              2
          (%o6)                            -------------
                                             a (a + 1)
          (%i7) ev(%);

                                            2
                                           z        2 z
          (%o7)                         --------- - --- + 1
                                        a (a + 1)    a

 -- Function: lambert_w (<z>)
     The principal branch of Lambert’s W function W(z), the solution of
     ‘z = W(z) * exp(W(z))’.  (DLMF 4.13)

 -- Function: generalized_lambert_w (<k>, <z>)
     The <k>-th branch of Lambert’s W function W(z), the solution of ‘z
     = W(z) * exp(W(z))’.  (DLMF 4.13)

     The principal branch, denoted Wp(z) in DLMF, is ‘lambert_w(z) =
     generalized_lambert_w(0,z)’.

     The other branch with real values, denoted Wm(z) in DLMF, is
     ‘generalized_lambert_w(-1,z)’.

 -- Function: nzeta (<z>)
     The Plasma Dispersion Function ‘nzeta(z) =
     %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))’

 -- Function: nzetar (<z>)
     Returns ‘realpart(nzeta(z))’.

 -- Function: nzetai (<z>)
     Returns ‘imagpart(nzeta(z))’.


File: maxima.info,  Node: Эллиптические функции,  Next: Пределы,  Prev: Special Functions,  Up: Top

15 Эллиптические функции
************************

* Menu:

* Эллиптические функции и интегралы в Maxima::
* Функции и переменные для эллиптических функций::
* Функции и переменные для эллиптических интегралов::


File: maxima.info,  Node: Эллиптические функции и интегралы в Maxima,  Next: Функции и переменные для эллиптических функций,  Up: Top

15.1 Эллиптические функции и интегралы в Maxima
===============================================

Maxima поддерживает работу с эллиптическими функциями Якоби, а также
полными и неполными эллиптическими интегралами - как символьную
манипуляцию, так и численные расчеты.  Определение этих функций и
множество их свойств можно найти в главах 16, 17 справочника Abramowitz,
Stegun.  Мы используем определения и отношения из книги Абрамовица и
Стиган там, где это возможно.

   В частности, все эллиптические функции и нтегралы используют параметр
m вместо модуля k или амплитуды \alpha.  Это единственное расхождение с
Амбрамовицем и Стиган, которые используют для эллиптических функций
амплитуду.  Действуют следующие отношения: m = k^2 и k = \sin(\alpha)

   В первую очередь упор делался на символьные вычисления с
эллиптическими функциями и интегралами.  Поэтому известно большинство
производных для функций и интегралов.  Однако, если в какчестве
параметра заданы числа с плавающей точкой, то возвращается численное
значение.

   Поддержка большинства других свойств эллиптических функций и
интегралов, помимо выражения их производных, еще не реализована.

   Несколько примеров для эллиптических функций:
     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Несколько примеров для эллиптических интегралов:
     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Поддержку эллиптических функций и интегралов реализовал Реймонд Той,
и его код доступен под лицензии GPL, как и весь код Maxima.


File: maxima.info,  Node: Функции и переменные для эллиптических функций,  Next: Функции и переменные для эллиптических интегралов,  Prev: Эллиптические функции и интегралы в Maxima,  Up: Top

15.2 Функции и переменные для эллиптических функций
===================================================

 -- Функция: jacobi_sn (<u>, <m>)
     Эллиптическая функция Якоби sn(u,m).

 -- Функция: jacobi_cn (<u>, <m>)
     Эллиптическая функция Якоби cn(u,m).

 -- Функция: jacobi_dn (<u>, <m>)
     Эллиптическая функция Якоби dn(u,m).

 -- Функция: jacobi_ns (<u>, <m>)
     Эллиптическая функция Якоби ns(u,m) = 1/sn(u,m).

 -- Функция: jacobi_sc (<u>, <m>)
     Эллиптическая функция Якоби sc(u,m) = sn(u,m)/cn(u,m).

 -- Функция: jacobi_sd (<u>, <m>)
     Эллиптическая функция Якоби sd(u,m) = sn(u,m)/dn(u,m).

 -- Функция: jacobi_nc (<u>, <m>)
     Эллиптическая функция Якоби nc(u,m) = 1/cn(u,m).

 -- Функция: jacobi_cs (<u>, <m>)
     Эллиптическая функция Якоби cs(u,m) = cn(u,m)/sn(u,m).

 -- Функция: jacobi_cd (<u>, <m>)
     Эллиптическая функция Якоби cd(u,m) = cn(u,m)/dn(u,m).

 -- Функция: jacobi_nd (<u>, <m>)
     Эллиптическая функция Якоби nc(u,m) = 1/cn(u,m).

 -- Функция: jacobi_ds (<u>, <m>)
     Эллиптическая функция Якоби ds(u,m) = dn(u,m)/sn(u,m).

 -- Функция: jacobi_dc (<u>, <m>)
     Эллиптическая функция Якоби dc(u,m) = dn(u,m)/cn(u,m).

 -- Функция: inverse_jacobi_sn (<u>, <m>)
     Обратная эллиптическая функция Якоби для sn(u,m).

 -- Функция: inverse_jacobi_cn (<u>, <m>)
     Обратная эллиптическая функция Якоби для cn(u,m).

 -- Функция: inverse_jacobi_dn (<u>, <m>)
     Обратная эллиптическая функция Якоби для dn(u,m).

 -- Функция: inverse_jacobi_ns (<u>, <m>)
     Обратная эллиптическая функция Якоби для ns(u,m).

 -- Функция: inverse_jacobi_sc (<u>, <m>)
     Обратная эллиптическая функция Якоби для sc(u,m).

 -- Функция: inverse_jacobi_sd (<u>, <m>)
     Обратная эллиптическая функция Якоби для sd(u,m).

 -- Функция: inverse_jacobi_nc (<u>, <m>)
     Обратная эллиптическая функция Якоби для nc(u,m).

 -- Функция: inverse_jacobi_cs (<u>, <m>)
     Обратная эллиптическая функция Якоби для cs(u,m).

 -- Функция: inverse_jacobi_cd (<u>, <m>)
     Обратная эллиптическая функция Якоби для cd(u,m).

 -- Функция: inverse_jacobi_nd (<u>, <m>)
     Обратная эллиптическая функция Якоби для nc(u,m).

 -- Функция: inverse_jacobi_ds (<u>, <m>)
     Обратная эллиптическая функция Якоби для ds(u,m).

 -- Функция: inverse_jacobi_dc (<u>, <m>)
     Обратная эллиптическая функция Якоби для dc(u,m).


File: maxima.info,  Node: Функции и переменные для эллиптических интегралов,  Next: Функции и переменные для эллиптических функций,  Prev: Top

15.3 Функции и переменные для эллиптических интегралов
======================================================

 -- Функция: elliptic_f (<phi>, <m>)
     Неполный эллиптический интеграл первого рода, заданный в виде

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     См.  также *note elliptic_e:: и *note elliptic_kc::.

 -- Функция: elliptic_e (<phi>, <m>)
     Неполный эллиптический интеграл второго рода, заданный в виде

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     См.  также *note elliptic_e:: и *note elliptic_ec::.

 -- Функция: elliptic_eu (<u>, <m>)
     Неполный эллиптический интеграл второго рода, заданный в виде

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     где tau = sn(u,m)

     Это связано с elliptic_e отношением elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) См.  также *note elliptic_e::.

 -- Функция: elliptic_pi (<n>, <phi>, <m>)
     Неполный эллиптический интеграл третьего рода, заданный в виде

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Для Maxima известна только производная по phi.

 -- Функция: elliptic_kc (<m>)
     Полный эллиптический интеграл первого рода, заданный в виде

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Для конкретных значений m значение интеграла выражается через
     гамма-функцию.  Для вычисления используйте ‘makegamma’.

 -- Функция: elliptic_ec (<m>)
     Полный эллиптический интеграл второго рода, заданный в виде

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Для конкретных значений m значение интеграла выражается через
     гамма-функцию.  Для вычисления используйте ‘makegamma’.


File: maxima.info,  Node: Пределы,  Next: Differentiation,  Prev: Эллиптические функции,  Up: Top

16 Пределы
**********

* Menu:

* Функции для работы с пределами::


File: maxima.info,  Node: Функции для работы с пределами,  Prev: Пределы,  Up: Пределы

16.1 Функции для работы с пределами
===================================

 -- Управляющая переменная: lhospitallim
     Значение по умолчанию: 4

     ‘lhospitallim’ есть максимальное число применений правила Лопиталя
     в ‘limit’.  Это предотвращает зацикливание в случаях вроде ‘limit
     (cot(x)/csc(x), x, 0)’.

 -- Функция: limit (<expr>, <x>, <val>, <dir>)
 -- Функция: limit (<expr>, <x>, <val>)
 -- Функция: limit (<expr>)
     Рассчитывает предел <expr> при стремлении вещественной переменной
     <x> к <val> по направлению <dir>.  <dir> может иметь значение
     ‘plus’ для предела справа, ‘minus’ для предела слева, либо
     опускаться (будет рассчитан двусторонний предел).

     ‘limit’ использует специальные символы: ‘inf’ (плюс бесконечность)
     и ‘minf’ (минус бесконечность).  Вывод может использовать ‘und’
     (неопределенность), ‘ind’ (неопределенность, но ограниченность) и
     ‘infinity’ (комплексная бесконечность).

     ‘lhospitallim’ есть максимальное число применений правила Лопиталя
     в ‘limit’.  Это предотвращает зацикливание в случаях вроде ‘limit
     (cot(x)/csc(x), x, 0)’.

     Если ‘tlimswitch’ равно ‘true’, команда ‘limit’ использует
     разложение в ряды Тейлора там, где это возможно.

     ‘limsubst’ предотвращает подстановки над неизвестными формами в
     ‘limit’.  Это позволяет избежать ошибок, когда выражение вида
     ‘limit (f(n)/f(n+1), n, inf)’ дает 1.  Подобные подстановки будут
     использоваться, если ‘limsubst’ равно ‘true’.

     ‘limit’ с одним аргументом часто вызывается для упрощения
     константных выражений, например ‘limit (inf-1)’.

     ‘example (limit)’ выводит некоторые примеры.

     Относительно метода см.  Wang, P., "Evaluation of Definite
     Integrals by Symbolic Manipulation", Ph.D. thesis, MAC TR-92,
     October 1971.

 -- Управляющая переменная: limsubst
     Значение по умолчанию: ‘false’ – предотвращает подстановки над
     неизвестными формами в ‘limit’.  Это позволяет избежать ошибок,
     когда выражение вида ‘limit (f(n)/f(n+1), n, inf)’ дает 1.
     Подобные подстановки будут использоваться, если ‘limsubst’ равно
     ‘true’.

 -- Функция: tlimit (<expr>, <x>, <val>, <dir>)
 -- Функция: tlimit (<expr>, <x>, <val>)
 -- Функция: tlimit (<expr>)
     Вычисляет предел разложения выражения ‘expr’ в ряд Тейлора в точке
     ‘x’ равной ‘val’ с направления ‘dir’.

 -- Управляющая переменная: tlimswitch
     Значение по умолчанию: ‘true’

     Если значение ‘tlimswitch’ равно ‘true’, то команда ‘limit’ будет
     использовать разложение в ряд Тейлора, если предел выражения не
     может быть вычислен непосредственно.  Это позволяет вычислять
     пределы типа ‘limit(x/(x-1)-1/log(x),x,1,plus)’.  Если значение
     ‘tlimswitch’ равно ‘false’ и предел выражения не может быть
     вычислен непосредственно, то ‘limit’ возвращает исходное выражение
     предела невычисленным.


File: maxima.info,  Node: Differentiation,  Next: Integration,  Prev: Пределы,  Up: Top

17 Differentiation
******************

* Menu:

* Functions and Variables for Differentiation::  


File: maxima.info,  Node: Functions and Variables for Differentiation,  Prev: Differentiation,  Up: Differentiation

17.1 Functions and Variables for Differentiation
================================================

 -- Function: antid (<expr>, <x>, <u(x)>)

     Returns a two-element list, such that an antiderivative of <expr>
     with respect to <x> can be constructed from the list.  The
     expression <expr> may contain an unknown function <u> and its
     derivatives.

     Let <L>, a list of two elements, be the return value of ‘antid’.
     Then ‘<L>[1] + 'integrate (<L>[2], <x>)’ is an antiderivative of
     <expr> with respect to <x>.

     When ‘antid’ succeeds entirely, the second element of the return
     value is zero.  Otherwise, the second element is nonzero, and the
     first element is nonzero or zero.  If ‘antid’ cannot make any
     progress, the first element is zero and the second nonzero.

     ‘load ("antid")’ loads this function.  The ‘antid’ package also
     defines the functions ‘nonzeroandfreeof’ and ‘linear’.

     ‘antid’ is related to ‘antidiff’ as follows.  Let <L>, a list of
     two elements, be the return value of ‘antid’.  Then the return
     value of ‘antidiff’ is equal to ‘<L>[1] + 'integrate (<L>[2], <x>)’
     where <x> is the variable of integration.

     Examples:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- Function: antidiff (<expr>, <x>, <u>(<x>))

     Returns an antiderivative of <expr> with respect to <x>.  The
     expression <expr> may contain an unknown function <u> and its
     derivatives.

     When ‘antidiff’ succeeds entirely, the resulting expression is free
     of integral signs (that is, free of the ‘integrate’ noun).
     Otherwise, ‘antidiff’ returns an expression which is partly or
     entirely within an integral sign.  If ‘antidiff’ cannot make any
     progress, the return value is entirely within an integral sign.

     ‘load ("antid")’ loads this function.  The ‘antid’ package also
     defines the functions ‘nonzeroandfreeof’ and ‘linear’.

     ‘antidiff’ is related to ‘antid’ as follows.  Let <L>, a list of
     two elements, be the return value of ‘antid’.  Then the return
     value of ‘antidiff’ is equal to ‘<L>[1] + 'integrate (<L>[2], <x>)’
     where <x> is the variable of integration.

     Examples:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- Function: at
          at (<expr>, [<eqn_1>, …, <eqn_n>])
          at (<expr>, <eqn>)

     Evaluates the expression <expr> with the variables assuming the
     values as specified for them in the list of equations ‘[<eqn_1>,
     ..., <eqn_n>]’ or the single equation <eqn>.

     If a subexpression depends on any of the variables for which a
     value is specified but there is no ‘atvalue’ specified and it can’t
     be otherwise evaluated, then a noun form of the ‘at’ is returned
     which displays in a two-dimensional form.

     ‘at’ carries out multiple substitutions in parallel.

     See also ‘atvalue’.  For other functions which carry out
     substitutions, see also ‘subst’ and ‘ev’.

     Examples:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                      !
                           2              d           !
          (%o5)        16 a  - 2 u(0, 1) (-- (u(x, 1))!     )
                                          dx          !
                                                      !x = 0

     Note that in the last line ‘y’ is treated differently to ‘x’ as ‘y’
     isn’t used as a differentiation variable.

     The difference between ‘subst’, ‘at’ and ‘ev’ can be seen in the
     following example:

          (%i1) e1:I(t)=C*diff(U(t),t)$
          (%i2) e2:U(t)=L*diff(I(t),t)$
          (%i3) at(e1,e2);
                                         !
                                d        !
          (%o3)       I(t) = C (-- (U(t))!                    )
                                dt       !          d
                                         !U(t) = L (-- (I(t)))
                                                    dt
          (%i4) subst(e2,e1);
                                      d      d
          (%o4)             I(t) = C (-- (L (-- (I(t)))))
                                      dt     dt
          (%i5) ev(e1,e2,diff);
                                            2
                                           d
          (%o5)                I(t) = C L (--- (I(t)))
                                             2
                                           dt

 -- Property: atomgrad

     ‘atomgrad’ is the atomic gradient property of an expression.  This
     property is assigned by ‘gradef’.

 -- Function: atvalue
          atvalue (<expr>, [<x_1> = <a_1>, …, <x_m> = <a_m>], <c>)
          atvalue (<expr>, <x_1> = <a_1>, <c>)

     Assigns the value <c> to <expr> at the point ‘<x> = <a>’.
     Typically boundary values are established by this mechanism.

     <expr> is a function evaluation, ‘<f>(<x_1>, ..., <x_m>)’, or a
     derivative, ‘diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ...,
     <x_n>, <n_m>)’ in which the function arguments explicitly appear.
     <n_i> is the order of differentiation with respect to <x_i>.

     The point at which the atvalue is established is given by the list
     of equations ‘[<x_1> = <a_1>, ..., <x_m> = <a_m>]’.  If there is a
     single variable <x_1>, the sole equation may be given without
     enclosing it in a list.

     ‘printprops ([<f_1>, <f_2>, ...], atvalue)’ displays the atvalues
     of the functions ‘<f_1>, <f_2>, ...’ as specified by calls to
     ‘atvalue’.  ‘printprops (<f>, atvalue)’ displays the atvalues of
     one function <f>.  ‘printprops (all, atvalue)’ displays the
     atvalues of all functions for which atvalues are defined.

     The symbols ‘@1’, ‘@2’, … represent the variables <x_1>, <x_2>, …
     when atvalues are displayed.

     ‘atvalue’ evaluates its arguments.  ‘atvalue’ returns <c>, the
     atvalue.

     See also ‘at’.

     Examples:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                      !
                           2              d           !
          (%o5)        16 a  - 2 u(0, 1) (-- (u(x, 1))!     )
                                          dx          !
                                                      !x = 0

 -- Function: cartan

     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     ‘cartan’ package implements the functions ‘ext_diff’ and
     ‘lie_diff’, along with the operators ‘~’ (wedge product) and ‘|’
     (contraction of a form with a vector.)  Type ‘demo ("tensor")’ to
     see a brief description of these commands along with examples.

     ‘cartan’ was implemented by F.B. Estabrook and H.D. Wahlquist.

 -- Function: init_cartan ([<x_1>, ..., <x_n>])

     ‘init_cartan([<x_1>, ..., <x_n>])’ initializes global variables for
     the ‘cartan’ package.  The sole argument is a list of symbols, from
     which the Cartan basis is constructed.

     ‘init_cartan’ returns the basis which is constructed.

     ‘init_cartan’ assigns values to the following global variables:
     ‘cartan_coords’, ‘cartan_dim’, ‘extdim’, and ‘cartan_basis’.  In
     addition, the following arrays are assigned: ‘extsub’ and
     ‘extsubb’.

     Note: Because of the internal implementation of the ‘cartan’
     package, it is necessary for ‘init_cartan’ to be called before any
     expression containing the Cartan coordinates ‘<x_1>, ..., <x_n>’ is
     parsed.

 -- Function: del (<x>)

     ‘del (<x>)’ represents the differential of the variable x.

     ‘diff’ returns an expression containing ‘del’ if an independent
     variable is not specified.  In this case, the return value is the
     so-called "total differential".

     See also ‘diff’, ‘del’ and ‘derivdegree’.

     Examples:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)

 -- Function: delta (<t>)

     The Dirac Delta function.

     Currently only ‘laplace’ knows about the ‘delta’ function.

     Example:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e

 -- System variable: dependencies
 -- Function: dependencies (<f_1>, …, <f_n>)

     The variable ‘dependencies’ is the list of atoms which have
     functional dependencies, assigned by ‘depends’, the function
     ‘dependencies’, or ‘gradef’.  The ‘dependencies’ list is
     cumulative: each call to ‘depends’, ‘dependencies’, or ‘gradef’
     appends additional items.  The default value of ‘dependencies’ is
     ‘[]’.

     The function ‘dependencies(<f_1>, …, <f_n>)’ appends <f_1>, …,
     <f_n>, to the ‘dependencies’ list, where <f_1>, …, <f_n> are
     expressions of the form ‘<f>(<x_1>, …, <x_m>)’, and <x_1>, …, <x_m>
     are any number of arguments.

     ‘dependencies(<f>(<x_1>, …, <x_m>))’ is equivalent to ‘depends(<f>,
     [<x_1>, …, <x_m>])’.

     See also ‘depends’ and ‘gradef’.

          (%i1) dependencies;
          (%o1)                          []
          (%i2) depends (foo, [bar, baz]);
          (%o2)                    [foo(bar, baz)]
          (%i3) depends ([g, h], [a, b, c]);
          (%o3)               [g(a, b, c), h(a, b, c)]
          (%i4) dependencies;
          (%o4)        [foo(bar, baz), g(a, b, c), h(a, b, c)]
          (%i5) dependencies (quux (x, y), mumble (u));
          (%o5)                [quux(x, y), mumble(u)]
          (%i6) dependencies;
          (%o6) [foo(bar, baz), g(a, b, c), h(a, b, c), quux(x, y),
                                                                 mumble(u)]
          (%i7) remove (quux, dependency);
          (%o7)                         done
          (%i8) dependencies;
          (%o8)  [foo(bar, baz), g(a, b, c), h(a, b, c), mumble(u)]

 -- Function: depends (<f_1>, <x_1>, …, <f_n>, <x_n>)

     Declares functional dependencies among variables for the purpose of
     computing derivatives.  In the absence of declared dependence,
     ‘diff (f, x)’ yields zero.  If ‘depends (f, x)’ is declared, ‘diff
     (f, x)’ yields a symbolic derivative (that is, a ‘diff’ noun).

     Each argument <f_1>, <x_1>, etc., can be the name of a variable or
     array, or a list of names.  Every element of <f_i> (perhaps just a
     single element) is declared to depend on every element of <x_i>
     (perhaps just a single element).  If some <f_i> is the name of an
     array or contains the name of an array, all elements of the array
     depend on <x_i>.

     ‘diff’ recognizes indirect dependencies established by ‘depends’
     and applies the chain rule in these cases.

     ‘remove (<f>, dependency)’ removes all dependencies declared for
     <f>.

     ‘depends’ returns a list of the dependencies established.  The
     dependencies are appended to the global variable ‘dependencies’.
     ‘depends’ evaluates its arguments.

     ‘diff’ is the only Maxima command which recognizes dependencies
     established by ‘depends’.  Other functions (‘integrate’, ‘laplace’,
     etc.)  only recognize dependencies explicitly represented by their
     arguments.  For example, ‘integrate’ does not recognize the
     dependence of ‘f’ on ‘x’ unless explicitly represented as
     ‘integrate (f(x), x)’.

     ‘depends(<f>, [<x_1>, …, <x_n>])’ is equivalent to
     ‘dependencies(<f>(<x_1>, …, <x_n>))’.

     See also ‘diff’, ‘del’, ‘derivdegree’ and ‘derivabbrev’.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt

 -- Option variable: derivabbrev
     Default value: ‘false’

     When ‘derivabbrev’ is ‘true’, symbolic derivatives (that is, ‘diff’
     nouns) are displayed as subscripts.  Otherwise, derivatives are
     displayed in the Leibniz notation ‘dy/dx’.

 -- Function: derivdegree (<expr>, <y>, <x>)

     Returns the highest degree of the derivative of the dependent
     variable <y> with respect to the independent variable <x> occurring
     in <expr>.

     Example:

          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2

 -- Function: derivlist (<var_1>, …, <var_k>)

     Causes only differentiations with respect to the indicated
     variables, within the ‘ev’ command.

 -- Option variable: derivsubst
     Default value: ‘false’

     When ‘derivsubst’ is ‘true’, a non-syntactic substitution such as
     ‘subst (x, 'diff (y, t), 'diff (y, t, 2))’ yields ‘'diff (x, t)’.

 -- Function: diff
          diff (<expr>, <x_1>, <n_1>, …, <x_m>, <n_m>)
          diff (<expr>, <x>, <n>)
          diff (<expr>, <x>)
          diff (<expr>)

     Returns the derivative or differential of <expr> with respect to
     some or all variables in <expr>.

     ‘diff (<expr>, <x>, <n>)’ returns the <n>’th derivative of <expr>
     with respect to <x>.

     ‘diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)’ returns the mixed
     partial derivative of <expr> with respect to <x_1>, …, <x_m>.  It
     is equivalent to ‘diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)’.

     ‘diff (<expr>, <x>)’ returns the first derivative of <expr> with
     respect to the variable <x>.

     ‘diff (<expr>)’ returns the total differential of <expr>, that is,
     the sum of the derivatives of <expr> with respect to each its
     variables times the differential ‘del’ of each variable.  No
     further simplification of ‘del’ is offered.

     The noun form of ‘diff’ is required in some contexts, such as
     stating a differential equation.  In these cases, ‘diff’ may be
     quoted (as ‘'diff’) to yield the noun form instead of carrying out
     the differentiation.

     When ‘derivabbrev’ is ‘true’, derivatives are displayed as
     subscripts.  Otherwise, derivatives are displayed in the Leibniz
     notation, ‘dy/dx’.

     See also ‘depends’, ‘del’, ‘derivdegree’ and ‘derivabbrev’.

     Examples:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

     (1) The derivatives of any indexed objects in <expr> will have the
     variables <x_i> appended as additional arguments.  Then all the
     derivative indices will be sorted.

     (2) The <x_i> may be integers from 1 up to the value of the
     variable ‘dimension’ [default value: 4].  This will cause the
     differentiation to be carried out with respect to the <x_i>’th
     member of the list ‘coordinates’ which should be set to a list of
     the names of the coordinates, e.g., ‘[x, y, z, t]’.  If
     ‘coordinates’ is bound to an atomic variable, then that variable
     subscripted by <x_i> will be used for the variable of
     differentiation.  This permits an array of coordinate names or
     subscripted names like ‘X[1]’, ‘X[2]’, … to be used.  If
     ‘coordinates’ has not been assigned a value, then the variables
     will be treated as in (1) above.

 -- Special symbol: diff

     When ‘diff’ is present as an ‘evflag’ in call to ‘ev’, all
     differentiations indicated in ‘expr’ are carried out.

 -- Function: express (<expr>)

     Expands differential operator nouns into expressions in terms of
     partial derivatives.  ‘express’ recognizes the operators ‘grad’,
     ‘div’, ‘curl’, ‘laplacian’.  ‘express’ also expands the cross
     product ‘~’.

     Symbolic derivatives (that is, ‘diff’ nouns) in the return value of
     express may be evaluated by including ‘diff’ in the ‘ev’ function
     call or command line.  In this context, ‘diff’ acts as an ‘evfun’.

     ‘load ("vect")’ loads this function.

     Examples:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]

 -- Function: gradef
          gradef (<f>(<x_1>, …, <x_n>), <g_1>, …, <g_m>)
          gradef (<a>, <x>, <expr>)

     Defines the partial derivatives (i.e., the components of the
     gradient) of the function <f> or variable <a>.

     ‘gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)’ defines
     ‘d<f>/d<x_i>’ as <g_i>, where <g_i> is an expression; <g_i> may be
     a function call, but not the name of a function.  The number of
     partial derivatives <m> may be less than the number of arguments
     <n>, in which case derivatives are defined with respect to <x_1>
     through <x_m> only.

     ‘gradef (<a>, <x>, <expr>)’ defines the derivative of variable <a>
     with respect to <x> as <expr>.  This also establishes the
     dependence of <a> on <x> (via ‘depends (<a>, <x>)’).

     The first argument ‘<f>(<x_1>, ..., <x_n>)’ or <a> is quoted, but
     the remaining arguments <g_1>, ..., <g_m> are evaluated.  ‘gradef’
     returns the function or variable for which the partial derivatives
     are defined.

     ‘gradef’ can redefine the derivatives of Maxima’s built-in
     functions.  For example, ‘gradef (sin(x), sqrt (1 - sin(x)^2))’
     redefines the derivative of ‘sin’.

     ‘gradef’ cannot define partial derivatives for a subscripted
     function.

     ‘printprops ([<f_1>, ..., <f_n>], gradef)’ displays the partial
     derivatives of the functions <f_1>, ..., <f_n>, as defined by
     ‘gradef’.

     ‘printprops ([<a_n>, ..., <a_n>], atomgrad)’ displays the partial
     derivatives of the variables <a_n>, ..., <a_n>, as defined by
     ‘gradef’.

     ‘gradefs’ is the list of the functions for which partial
     derivatives have been defined by ‘gradef’.  ‘gradefs’ does not
     include any variables for which partial derivatives have been
     defined by ‘gradef’.

     Gradients are needed when, for example, a function is not known
     explicitly but its first derivatives are and it is desired to
     obtain higher order derivatives.

 -- System variable: gradefs
     Default value: ‘[]’

     ‘gradefs’ is the list of the functions for which partial
     derivatives have been defined by ‘gradef’.  ‘gradefs’ does not
     include any variables for which partial derivatives have been
     defined by ‘gradef’.

 -- Function: laplace (<expr>, <t>, <s>)

     Attempts to compute the Laplace transform of <expr> with respect to
     the variable <t> and transform parameter <s>.  The Laplace
     transform of the function ‘f(t)’ is the one-sided transform defined
     by
          F(s) = integrate(f(t) * exp(-s*t), t, 0, inf)
     where ‘F(s)’ is the transform of ‘f(t)’.

     ‘laplace’ recognizes in <expr> the functions ‘delta’, ‘exp’, ‘log’,
     ‘sin’, ‘cos’, ‘sinh’, ‘cosh’, and ‘erf’, as well as ‘derivative’,
     ‘integrate’, ‘sum’, and ‘ilt’.  If laplace fails to find a
     transform the function ‘specint’ is called.  ‘specint’ can find the
     laplace transform for expressions with special functions like the
     bessel functions ‘bessel_j’, ‘bessel_i’, … and can handle the
     ‘unit_step’ function.  See also ‘specint’.

     If ‘specint’ cannot find a solution too, a noun ‘laplace’ is
     returned.

     <expr> may also be a linear, constant coefficient differential
     equation in which case ‘atvalue’ of the dependent variable is used.
     The required atvalue may be supplied either before or after the
     transform is computed.  Since the initial conditions must be
     specified at zero, if one has boundary conditions imposed elsewhere
     he can impose these on the general solution and eliminate the
     constants by solving the general solution for them and substituting
     their values back.

     ‘laplace’ recognizes convolution integrals of the form ‘integrate
     (f(x) * g(t - x), x, 0, t)’; other kinds of convolutions are not
     recognized.

     Functional relations must be explicitly represented in <expr>;
     implicit relations, established by ‘depends’, are not recognized.
     That is, if <f> depends on <x> and <y>, ‘f (x, y)’ must appear in
     <expr>.

     See also ‘ilt’, the inverse Laplace transform.

     Examples:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s),
                   simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)


File: maxima.info,  Node: Integration,  Next: Equations,  Prev: Differentiation,  Up: Top

18 Integration
**************

* Menu:

* Introduction to Integration::
* Functions and Variables for Integration::
* Introduction to QUADPACK::
* Functions and Variables for QUADPACK::


File: maxima.info,  Node: Introduction to Integration,  Next: Functions and Variables for Integration,  Prev: Integration,  Up: Integration

18.1 Introduction to Integration
================================

Maxima has several routines for handling integration.  The ‘integrate’
function makes use of most of them.  There is also the ‘antid’ package,
which handles an unspecified function (and its derivatives, of course).
For numerical uses, there is a set of adaptive integrators from
QUADPACK, named ‘quad_qag’, ‘quad_qags’, etc., which are described under
the heading ‘QUADPACK’.  Hypergeometric functions are being worked on,
see ‘specint’ for details.  Generally speaking, Maxima only handles
integrals which are integrable in terms of the "elementary functions"
(rational functions, trigonometrics, logs, exponentials, radicals, etc.)
and a few extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as ‘g(x)’ and ‘h(x)’.


File: maxima.info,  Node: Functions and Variables for Integration,  Next: Introduction to QUADPACK,  Prev: Introduction to Integration,  Up: Integration

18.2 Functions and Variables for Integration
============================================

 -- Function: changevar (<expr>, <f(x,y)>, <y>, <x>)

     Makes the change of variable given by ‘<f(x,y)> = 0’ in all
     integrals occurring in <expr> with integration with respect to <x>.
     The new variable is <y>.

     The change of variable can also be written ‘<f(x)> = <g(y)>’.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     An expression containing a noun form, such as the instances of
     ‘'integrate’ above, may be evaluated by ‘ev’ with the ‘nouns’ flag.
     For example, the expression returned by ‘changevar’ above may be
     evaluated by ‘ev (%o3, nouns)’.

     ‘changevar’ may also be used to changes in the indices of a sum or
     product.  However, it must be realized that when a change is made
     in a sum or product, this change must be a shift, i.e., ‘i = j+
     ...’, not a higher degree function.  E.g.,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2

 -- Function: dblint (<f>, <r>, <s>, <a>, <b>)

     A double-integral routine which was written in top-level Maxima and
     then translated and compiled to machine code.  Use ‘load
     ("dblint")’ to access this package.  It uses the Simpson’s rule
     method in both the x and y directions to calculate

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     The function <f> must be a translated or compiled function of two
     variables, and <r> and <s> must each be a translated or compiled
     function of one variable, while <a> and <b> must be floating point
     numbers.  The routine has two global variables which determine the
     number of divisions of the x and y intervals: ‘dblint_x’ and
     ‘dblint_y’, both of which are initially 10, and can be changed
     independently to other integer values (there are ‘2*dblint_x+1’
     points computed in the x direction, and ‘2*dblint_y+1’ in the y
     direction).  The routine subdivides the X axis and then for each
     value of X it first computes ‘<r>(x)’ and ‘<s>(x)’; then the Y axis
     between ‘<r>(x)’ and ‘<s>(x)’ is subdivided and the integral along
     the Y axis is performed using Simpson’s rule; then the integral
     along the X axis is done using Simpson’s rule with the function
     values being the Y-integrals.  This procedure may be numerically
     unstable for a great variety of reasons, but is reasonably fast:
     avoid using it on highly oscillatory functions and functions with
     singularities (poles or branch points in the region).  The Y
     integrals depend on how far apart ‘<r>(x)’ and ‘<s>(x)’ are, so if
     the distance ‘<s>(x) - <r>(x)’ varies rapidly with X, there may be
     substantial errors arising from truncation with different
     step-sizes in the various Y integrals.  One can increase ‘dblint_x’
     and ‘dblint_y’ in an effort to improve the coverage of the region,
     at the expense of computation time.  The function values are not
     saved, so if the function is very time-consuming, you will have to
     wait for re-computation if you change anything (sorry).  It is
     required that the functions <f>, <r>, and <s> be either translated
     or compiled prior to calling ‘dblint’.  This will result in orders
     of magnitude speed improvement over interpreted code in many cases!

     ‘demo ("dblint")’ executes a demonstration of ‘dblint’ applied to
     an example problem.

 -- Function: defint (<expr>, <x>, <a>, <b>)

     Attempts to compute a definite integral.  ‘defint’ is called by
     ‘integrate’ when limits of integration are specified, i.e., when
     ‘integrate’ is called as ‘integrate (<expr>, <x>, <a>, <b>)’.  Thus
     from the user’s point of view, it is sufficient to call
     ‘integrate’.

     ‘defint’ returns a symbolic expression, either the computed
     integral or the noun form of the integral.  See ‘quad_qag’ and
     related functions for numerical approximation of definite
     integrals.

 -- Option variable: erfflag
     Default value: ‘true’

     When ‘erfflag’ is ‘false’, prevents ‘risch’ from introducing the
     ‘erf’ function in the answer if there were none in the integrand to
     begin with.

 -- Function: ilt (<expr>, <s>, <t>)

     Computes the inverse Laplace transform of <expr> with respect to
     <s> and parameter <t>.  <expr> must be a ratio of polynomials whose
     denominator has only linear and quadratic factors; there is an
     extension of ‘ilt’, called ‘pwilt’ (Piece-Wise Inverse Laplace
     Transform) that handles several other cases where ‘ilt’ fails.

     By using the functions ‘laplace’ and ‘ilt’ together with the
     ‘solve’ or ‘linsolve’ functions the user can solve a single
     differential or convolution integral equation or a set of them.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a

 -- Option variable: intanalysis
     Default value: ‘true’

     When ‘true’, definite integration tries to find poles in the
     integrand in the interval of integration.  If there are, then the
     integral is evaluated appropriately as a principal value integral.
     If intanalysis is ‘false’, this check is not performed and
     integration is done assuming there are no poles.

     See also ‘ldefint’.

     Examples:

     Maxima can solve the following integrals, when ‘intanalysis’ is set
     to ‘false’:

          (%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                          1
                                         /
                                         [       1
          (%o1)                          I  ----------- dx
                                         ]  sqrt(x) + 1
                                         /
                                          0

          (%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
          (%o2)                            2 - 2 log(2)

          (%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
          The number 1 isn't in the domain of atanh
           -- an error. To debug this try: debugmode(true);

          (%i4) intanalysis:false$
          (%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                                %pi
          (%o5)                                 ---
                                                 2

 -- Function: integrate
          integrate (<expr>, <x>)
          integrate (<expr>, <x>, <a>, <b>)

     Attempts to symbolically compute the integral of <expr> with
     respect to <x>.  ‘integrate (<expr>, <x>)’ is an indefinite
     integral, while ‘integrate (<expr>, <x>, <a>, <b>)’ is a definite
     integral, with limits of integration <a> and <b>.  The limits
     should not contain <x>, although ‘integrate’ does not enforce this
     restriction.  <a> need not be less than <b>.  If <b> is equal to
     <a>, ‘integrate’ returns zero.

     See ‘quad_qag’ and related functions for numerical approximation of
     definite integrals.  See ‘residue’ for computation of residues
     (complex integration).  See ‘antid’ for an alternative means of
     computing indefinite integrals.

     The integral (an expression free of ‘integrate’) is returned if
     ‘integrate’ succeeds.  Otherwise the return value is the noun form
     of the integral (the quoted operator ‘'integrate’) or an expression
     containing one or more noun forms.  The noun form of ‘integrate’ is
     displayed with an integral sign.

     In some circumstances it is useful to construct a noun form by
     hand, by quoting ‘integrate’ with a single quote, e.g., ‘'integrate
     (<expr>, <x>)’.  For example, the integral may depend on some
     parameters which are not yet computed.  The noun may be applied to
     its arguments by ‘ev (<i>, nouns)’ where <i> is the noun form of
     interest.

     ‘integrate’ handles definite integrals separately from indefinite,
     and employs a range of heuristics to handle each case.  Special
     cases of definite integrals include limits of integration equal to
     zero or infinity (‘inf’ or ‘minf’), trigonometric functions with
     limits of integration equal to zero and ‘%pi’ or ‘2 %pi’, rational
     functions, integrals related to the definitions of the ‘beta’ and
     ‘psi’ functions, and some logarithmic and trigonometric integrals.
     Processing rational functions may include computation of residues.
     If an applicable special case is not found, an attempt will be made
     to compute the indefinite integral and evaluate it at the limits of
     integration.  This may include taking a limit as a limit of
     integration goes to infinity or negative infinity; see also
     ‘ldefint’.

     Special cases of indefinite integrals include trigonometric
     functions, exponential and logarithmic functions, and rational
     functions.  ‘integrate’ may also make use of a short table of
     elementary integrals.

     ‘integrate’ may carry out a change of variable if the integrand has
     the form ‘f(g(x)) * diff(g(x), x)’.  ‘integrate’ attempts to find a
     subexpression ‘g(x)’ such that the derivative of ‘g(x)’ divides the
     integrand.  This search may make use of derivatives defined by the
     ‘gradef’ function.  See also ‘changevar’ and ‘antid’.

     If none of the preceding heuristics find the indefinite integral,
     the Risch algorithm is executed.  The flag ‘risch’ may be set as an
     ‘evflag’, in a call to ‘ev’ or on the command line, e.g., ‘ev
     (integrate (<expr>, <x>), risch)’ or ‘integrate (<expr>, <x>),
     risch’.  If ‘risch’ is present, ‘integrate’ calls the ‘risch’
     function without attempting heuristics first.  See also ‘risch’.

     ‘integrate’ works only with functional relations represented
     explicitly with the ‘f(x)’ notation.  ‘integrate’ does not respect
     implicit dependencies established by the ‘depends’ function.

     ‘integrate’ may need to know some property of a parameter in the
     integrand.  ‘integrate’ will first consult the ‘assume’ database,
     and, if the variable of interest is not there, ‘integrate’ will ask
     the user.  Depending on the question, suitable responses are ‘yes;’
     or ‘no;’, or ‘pos;’, ‘zero;’, or ‘neg;’.

     ‘integrate’ is not, by default, declared to be linear.  See
     ‘declare’ and ‘linear’.

     ‘integrate’ attempts integration by parts only in a few special
     cases.

     Examples:

        • Elementary indefinite and definite integrals.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        • Use of ‘assume’ and interactive query.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        • Change of variable.  There are two changes of variable in this
          example: one using a derivative established by ‘gradef’, and
          one using the derivation ‘diff(r(x))’ of an unspecified
          function ‘r(x)’.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        • Return value contains the ‘'integrate’ noun form.  In this
          example, Maxima can extract one factor of the denominator of a
          rational function, but cannot factor the remainder or
          otherwise find its integral.  ‘grind’ shows the noun form
          ‘'integrate’ in the result.  See also ‘integrate_use_rootsof’
          for more on integrals of rational functions.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        • Defining a function in terms of an integral.  The body of a
          function is not evaluated when the function is defined.  Thus
          the body of ‘f_1’ in this example contains the noun form of
          ‘integrate’.  The quote-quote operator ‘''’ causes the
          integral to be evaluated, and the result becomes the body of
          ‘f_2’.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600

 -- System variable: integration_constant
     Default value: ‘%c’

     When a constant of integration is introduced by indefinite
     integration of an equation, the name of the constant is constructed
     by concatenating ‘integration_constant’ and
     ‘integration_constant_counter’.

     ‘integration_constant’ may be assigned any symbol.

     Examples:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3

 -- System variable: integration_constant_counter
     Default value: 0

     When a constant of integration is introduced by indefinite
     integration of an equation, the name of the constant is constructed
     by concatenating ‘integration_constant’ and
     ‘integration_constant_counter’.

     ‘integration_constant_counter’ is incremented before constructing
     the next integration constant.

     Examples:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o3)                     -- = x + %c3
                                    3
          (%i4) reset (integration_constant_counter);
          (%o4)            [integration_constant_counter]
          (%i5) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o5)                     -- = x + %c1
                                    3

 -- Option variable: integrate_use_rootsof
     Default value: ‘false’

     When ‘integrate_use_rootsof’ is ‘true’ and the denominator of a
     rational function cannot be factored, ‘integrate’ returns the
     integral in a form which is a sum over the roots (not yet known) of
     the denominator.

     For example, with ‘integrate_use_rootsof’ set to ‘false’,
     ‘integrate’ returns an unsolved integral of a rational function in
     noun form:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Now we set the flag to be true and the unsolved part of the
     integral will be expressed as a summation over the roots of the
     denominator of the rational function:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                  3      2
                %r4 in rootsof(%r4  - %r4  + 1, %r4)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     Alternatively the user may compute the roots of the denominator
     separately, and then express the integrand in terms of these roots,
     e.g., ‘1/((x - a)*(x - b)*(x - c))’ or ‘1/((x^2 - (a+b)*x + a*b)*(x
     - c))’ if the denominator is a cubic polynomial.  Sometimes this
     will help Maxima obtain a more useful result.

 -- Function: ldefint (<expr>, <x>, <a>, <b>)

     Attempts to compute the definite integral of <expr> by using
     ‘limit’ to evaluate the indefinite integral of <expr> with respect
     to <x> at the upper limit <b> and at the lower limit <a>.  If it
     fails to compute the definite integral, ‘ldefint’ returns an
     expression containing limits as noun forms.

     ‘ldefint’ is not called from ‘integrate’, so executing ‘ldefint
     (<expr>, <x>, <a>, <b>)’ may yield a different result than
     ‘integrate (<expr>, <x>, <a>, <b>)’.  ‘ldefint’ always uses the
     same method to evaluate the definite integral, while ‘integrate’
     may employ various heuristics and may recognize some special cases.

 -- Function: pwilt (<expr>, <s>, <t>)

     Computes the inverse Laplace transform of <expr> with respect to
     <s> and parameter <t>.  Unlike ‘ilt’, ‘pwilt’ is able to return
     piece-wise and periodic functions and can also handle some cases
     with polynomials of degree greater than 3 in the denominator.

     Two examples where ‘ilt’ fails:
          (%i1) pwilt (exp(-s)*s/(s^3-2*s-s+2), s, t);
                                                 t - 1       - 2 (t - 1)
                                       (t - 1) %e        2 %e
          (%o1)         hstep(t - 1) (--------------- - ---------------)
                                              3                 9

          (%i2) pwilt ((s^2+2)/(s^2-1), s, t);
                                                   t       - t
                                               3 %e    3 %e
          (%o2)                    delta(t) + ----- - -------
                                                 2        2

 -- Function: potential (<givengradient>)

     The calculation makes use of the global variable
     ‘potentialzeroloc[0]’ which must be ‘nonlist’ or of the form

          [indeterminatej=expressionj, indeterminatek=expressionk, ...]

     the former being equivalent to the nonlist expression for all
     right-hand sides in the latter.  The indicated right-hand sides are
     used as the lower limit of integration.  The success of the
     integrations may depend upon their values and order.
     ‘potentialzeroloc’ is initially set to 0.

 -- Function: residue (<expr>, <z>, <z_0>)

     Computes the residue in the complex plane of the expression <expr>
     when the variable <z> assumes the value <z_0>.  The residue is the
     coefficient of ‘(<z> - <z_0>)^(-1)’ in the Laurent series for
     <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6

 -- Function: risch (<expr>, <x>)

     Integrates <expr> with respect to <x> using the transcendental case
     of the Risch algorithm.  (The algebraic case of the Risch algorithm
     has not been implemented.)  This currently handles the cases of
     nested exponentials and logarithms which the main part of
     ‘integrate’ can’t do.  ‘integrate’ will automatically apply ‘risch’
     if given these cases.

     ‘erfflag’, if ‘false’, prevents ‘risch’ from introducing the ‘erf’
     function in the answer if there were none in the integrand to begin
     with.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)

 -- Function: tldefint (<expr>, <x>, <a>, <b>)

     Equivalent to ‘ldefint’ with ‘tlimswitch’ set to ‘true’.


File: maxima.info,  Node: Introduction to QUADPACK,  Next: Functions and Variables for QUADPACK,  Prev: Functions and Variables for Integration,  Up: Integration

18.3 Introduction to QUADPACK
=============================

QUADPACK is a collection of functions for the numerical computation of
one-dimensional definite integrals.  It originated from a joint project
of R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), and D. Kahaner
(4).

   The QUADPACK library included in Maxima is an automatic translation
(via the program ‘f2cl’) of the Fortran source code of QUADPACK as it
appears in the SLATEC Common Mathematical Library, Version 4.1 (5).  The
SLATEC library is dated July 1993, but the QUADPACK functions were
written some years before.  There is another version of QUADPACK at
Netlib (6); it is not clear how that version differs from the SLATEC
version.

   The QUADPACK functions included in Maxima are all automatic, in the
sense that these functions attempt to compute a result to a specified
accuracy, requiring an unspecified number of function evaluations.
Maxima’s Lisp translation of QUADPACK also includes some non-automatic
functions, but they are not exposed at the Maxima level.

   Further information about QUADPACK can be found in the QUADPACK book
(7).

18.3.1 Overview
---------------

‘quad_qag’
     Integration of a general function over a finite interval.
     ‘quad_qag’ implements a simple globally adaptive integrator using
     the strategy of Aind (Piessens, 1973).  The caller may choose among
     6 pairs of Gauss-Kronrod quadrature formulae for the rule
     evaluation component.  The high-degree rules are suitable for
     strongly oscillating integrands.

‘quad_qags’
     Integration of a general function over a finite interval.
     ‘quad_qags’ implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

‘quad_qagi’
     Integration of a general function over an infinite or semi-infinite
     interval.  The interval is mapped onto a finite interval and then
     the same strategy as in ‘quad_qags’ is applied.

‘quad_qawo’
     Integration of cos(omega x) f(x) or sin(omega x) f(x) over a finite
     interval, where omega is a constant.  The rule evaluation component
     is based on the modified Clenshaw-Curtis technique.  ‘quad_qawo’
     applies adaptive subdivision with extrapolation, similar to
     ‘quad_qags’.

‘quad_qawf’
     Calculates a Fourier cosine or Fourier sine transform on a
     semi-infinite interval.  The same approach as in ‘quad_qawo’ is
     applied on successive finite intervals, and convergence
     acceleration by means of the Epsilon algorithm (Wynn, 1956) is
     applied to the series of the integral contributions.

‘quad_qaws’
     Integration of w(x) f(x) over a finite interval [a, b], where w is
     a function of the form (x - a)^alpha (b - x)^beta v(x) and v(x) is
     1 or log(x - a) or log(b - x) or log(x - a) log(b - x), and alpha >
     -1 and beta > -1.

     A globally adaptive subdivision strategy is applied, with modified
     Clenshaw-Curtis integration on the subintervals which contain a or
     b.

‘quad_qawc’
     Computes the Cauchy principal value of f(x)/(x - c) over a finite
     interval (a, b) and specified c.  The strategy is globally
     adaptive, and modified Clenshaw-Curtis integration is used on the
     subranges which contain the point x = c.

‘quad_qagp’
     Basically the same as ‘quad_qags’ but points of singularity or
     discontinuity of the integrand must be supplied.  This makes it
     easier for the integrator to produce a good solution.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut für Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) <https://www.netlib.org/slatec>

   (6) <https://www.netlib.org/quadpack>

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Functions and Variables for QUADPACK,  Prev: Introduction to QUADPACK,  Up: Integration

18.4 Functions and Variables for QUADPACK
=========================================

 -- Function: quad_qag
          quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])
          quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])

     Integration of a general function over a finite interval.
     ‘quad_qag’ implements a simple globally adaptive integrator using
     the strategy of Aind (Piessens, 1973).  The caller may choose among
     6 pairs of Gauss-Kronrod quadrature formulae for the rule
     evaluation component.  The high-degree rules are suitable for
     strongly oscillating integrands.

     ‘quad_qag’ computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.  <key> is the integrator to be used and should be an
     integer between 1 and 6, inclusive.  The value of <key> selects the
     order of the Gauss-Kronrod integration rule.  High-order rules are
     suitable for strongly oscillating integrands.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The numerical integration is done adaptively by subdividing the
     integration region into sub-intervals until the desired accuracy is
     achieved.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit> is the maximum number of
          subintervals to use.  Default is 200.

     ‘quad_qag’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          if no problems were encountered;
     ‘1’
          if too many sub-intervals were done;
     ‘2’
          if excessive roundoff error is detected;
     ‘3’
          if extremely bad integrand behavior occurs;
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Function: quad_qags
          quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
          quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>, <limit>])

     Integration of a general function over a finite interval.
     ‘quad_qags’ implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

     ‘quad_qags’ computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit> is the maximum number of
          subintervals to use.  Default is 200.

     ‘quad_qags’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘4’
          failed to converge
     ‘5’
          integral is probably divergent or slowly convergent
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note that ‘quad_qags’ is more accurate and efficient than
     ‘quad_qag’ for this integrand.

 -- Function: quad_qagi
          quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
          quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>, <limit>])

     Integration of a general function over an infinite or semi-infinite
     interval.  The interval is mapped onto a finite interval and then
     the same strategy as in ‘quad_qags’ is applied.

     ‘quad_qagi’ evaluates one of the following integrals

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, minf, inf)

     using the Quadpack QAGI routine.  The function to be integrated is
     <f(x)>, with dependent variable <x>, and the function is to be
     integrated over an infinite range.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     One of the limits of integration must be infinity.  If not, then
     ‘quad_qagi’ will just return the noun form.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit> is the maximum number of
          subintervals to use.  Default is 200.

     ‘quad_qagi’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘4’
          failed to converge
     ‘5’
          integral is probably divergent or slowly convergent
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32

 -- Function: quad_qawc
          quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
          quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])

     Computes the Cauchy principal value of f(x)/(x - c) over a finite
     interval.  The strategy is globally adaptive, and modified
     Clenshaw-Curtis integration is used on the subranges which contain
     the point x = c.

     ‘quad_qawc’ computes the Cauchy principal value of

     integrate (f(x)/(x - c), x, a, b)

     using the Quadpack QAWC routine.  The function to be integrated is
     ‘<f(x)>/(<x> - <c>)’, with dependent variable <x>, and the function
     is to be integrated over the interval <a> to <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit> is the maximum number of
          subintervals to use.  Default is 200.

     ‘quad_qawc’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917

 -- Function: quad_qawf
          quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
          quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>, <limit>,
          <maxp1>, <limlst>])

     Calculates a Fourier cosine or Fourier sine transform on a
     semi-infinite interval using the Quadpack QAWF function.  The same
     approach as in ‘quad_qawo’ is applied on successive finite
     intervals, and convergence acceleration by means of the Epsilon
     algorithm (Wynn, 1956) is applied to the series of the integral
     contributions.

     ‘quad_qawf’ computes the integral

     integrate (f(x)*w(x), x, a, inf)

     The weight function w is selected by <trig>:

     ‘cos’
          w(x) = cos (omega x)
     ‘sin’
          w(x) = sin (omega x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsabs’
          Desired absolute error of approximation.  Default is 1d-10.
     ‘limit’
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.
     ‘maxp1’
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.
     ‘limlst’
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     ‘quad_qawf’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714

 -- Function: quad_qawo
          quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>, [<epsrel>,
          <epsabs>, <limit>, <maxp1>, <limlst>])
          quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, [<epsrel>,
          <epsabs>, <limit>, <maxp1>, <limlst>])

     Integration of cos (omega x) f(x) or sin (omega x) f(x) over a
     finite interval, where omega is a constant.  The rule evaluation
     component is based on the modified Clenshaw-Curtis technique.
     ‘quad_qawo’ applies adaptive subdivision with extrapolation,
     similar to ‘quad_qags’.

     ‘quad_qawo’ computes the integral using the Quadpack QAWO routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <trig>:

     ‘cos’
          w(x) = cos (omega x)
     ‘sin’
          w(x) = sin (omega x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit>/2 is the maximum number
          of subintervals to use.  Default is 200.
     ‘maxp1’
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.
     ‘limlst’
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     ‘quad_qawo’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716

 -- Function: quad_qaws
          quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
          quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])

     Integration of w(x) f(x) over a finite interval, where w(x) is a
     certain algebraic or logarithmic function.  A globally adaptive
     subdivision strategy is applied, with modified Clenshaw-Curtis
     integration on the subintervals which contain the endpoints of the
     interval of integration.

     ‘quad_qaws’ computes the integral using the Quadpack QAWS routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <wfun>:

     ‘1’
          w(x) = (x - a)^alpha (b - x)^beta
     ‘2’
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)
     ‘3’
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)
     ‘4’
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit>is the maximum number of
          subintervals to use.  Default is 200.

     ‘quad_qaws’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829

 -- Function: quad_qagp
          quad_qagp (<f(x)>, <x>, <a>, <b>, <points>, [<epsrel>,
          <epsabs>, <limit>])
          quad_qagp (<f>, <x>, <a>, <b>, <points>, [<epsrel>, <epsabs>,
          <limit>])

     Integration of a general function over a finite interval.
     ‘quad_qagp’ implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

     ‘quad_qagp’ computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     To help the integrator, the user must supply a list of points where
     the integrand is singular or discontinuous.

     The keyword arguments are optional and may be specified in any
     order.  They all take the form ‘key=val’.  The keyword arguments
     are:

     ‘epsrel’
          Desired relative error of approximation.  Default is 1d-8.
     ‘epsabs’
          Desired absolute error of approximation.  Default is 0.
     ‘limit’
          Size of internal work array.  <limit> is the maximum number of
          subintervals to use.  Default is 200.

     ‘quad_qagp’ returns a list of four elements:

        • an approximation to the integral,
        • the estimated absolute error of the approximation,
        • the number integrand evaluations,
        • an error code.

     The error code (fourth element of the return value) can have the
     values:

     ‘0’
          no problems were encountered;
     ‘1’
          too many sub-intervals were done;
     ‘2’
          excessive roundoff error is detected;
     ‘3’
          extremely bad integrand behavior occurs;
     ‘4’
          failed to converge
     ‘5’
          integral is probably divergent or slowly convergent
     ‘6’
          if the input is invalid.

     Examples:

          (%i1) quad_qagp(x^3*log(abs((x^2-1)*(x^2-2))),x,0,3,[1,sqrt(2)]);
          (%o1)   [52.74074838347143, 2.6247632689546663e-7, 1029, 0]
          (%i2) quad_qags(x^3*log(abs((x^2-1)*(x^2-2))), x, 0, 3);
          (%o2)   [52.74074847951494, 4.088443219529836e-7, 1869, 0]

     The integrand has singularities at ‘1’ and ‘sqrt(2)’ so we supply
     these points to ‘quad_qagp’.  We also note that ‘quad_qagp’ is more
     accurate and more efficient that ‘quad_qags’.

 -- Function: quad_control (<parameter>, [<value>])

     Control error handling for quadpack.  The parameter should be one
     of the following symbols:

     ‘current_error’
          The current error number
     ‘control’
          Controls if messages are printed or not.  If it is set to zero
          or less, messages are suppressed.
     ‘max_message’
          The maximum number of times any message is to be printed.

     If <value> is not given, then the current value of the <parameter>
     is returned.  If <value> is given, the value of <parameter> is set
     to the given value.


File: maxima.info,  Node: Equations,  Next: Дифференциальные уравнения,  Prev: Integration,  Up: Top

19 Equations
************

* Menu:

* Functions and Variables for Equations::   


File: maxima.info,  Node: Functions and Variables for Equations,  Prev: Equations,  Up: Equations

19.1 Functions and Variables for Equations
==========================================

 -- System variable: %rnum
     Default value: ‘0’

     ‘%rnum’ is the counter for the ‘%r’ variables introduced in
     solutions by ‘solve’ and ‘algsys’..  The next ‘%r’ variable is
     numbered ‘%rnum+1’.

     See also ‘%rnum_list’.

 -- System variable: %rnum_list
     Default value: ‘[]’

     ‘%rnum_list’ is the list of variables introduced in solutions by
     ‘solve’ and ‘algsys’.  ‘%r’ variables are added to ‘%rnum_list’ in
     the order they are created.  This is convenient for doing
     substitutions into the solution later on.

     See also ‘%rnum’.

     It’s recommended to use this list rather than doing ‘concat ('%r,
     j)’.

          (%i1) solve ([x + y = 3], [x,y]);
          (%o1)              [[x = 3 - %r1, y = %r1]]
          (%i2) %rnum_list;
          (%o2)                       [%r1]
          (%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
          (%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
          (%i4) %rnum_list;
          (%o4)                     [%r2, %r3]
          (%i5) for i : 1 thru length (%rnum_list) do
                  sol : subst (t[i], %rnum_list[i], sol)$
          (%i6) sol;
          (%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                               2      1           2       1

 -- Option variable: algepsilon
     Default value: 10^8

     ‘algepsilon’ is used by ‘algsys’.

 -- Option variable: algexact
     Default value: ‘false’

     ‘algexact’ affects the behavior of ‘algsys’ as follows:

     If ‘algexact’ is ‘true’, ‘algsys’ always calls ‘solve’ and then
     uses ‘realroots’ on ‘solve’’s failures.

     If ‘algexact’ is ‘false’, ‘solve’ is called only if the eliminant
     was not univariate, or if it was a quadratic or biquadratic.

     Thus ‘algexact: true’ does not guarantee only exact solutions, just
     that ‘algsys’ will first try as hard as it can to give exact
     solutions, and only yield approximations when all else fails.

 -- Function: algsys
          algsys ([<expr_1>, …, <expr_m>], [<x_1>, …, <x_n>])
          algsys ([<eqn_1>, …, <eqn_m>], [<x_1>, …, <x_n>])

     Solves the simultaneous polynomials <expr_1>, …, <expr_m> or
     polynomial equations <eqn_1>, …, <eqn_m> for the variables <x_1>,
     …, <x_n>.  An expression <expr> is equivalent to an equation
     ‘<expr> = 0’.  There may be more equations than variables or vice
     versa.

     ‘algsys’ returns a list of solutions, with each solution given as a
     list of equations stating values of the variables <x_1>, …, <x_n>
     which satisfy the system of equations.  If ‘algsys’ cannot find a
     solution, an empty list ‘[]’ is returned.

     The symbols ‘%r1’, ‘%r2’, …, are introduced as needed to represent
     arbitrary parameters in the solution; these variables are also
     appended to the list ‘%rnum_list’.

     The method is as follows:

       1. First the equations are factored and split into subsystems.

       2. For each subsystem <S_i>, an equation <E> and a variable <x>
          are selected.  The variable is chosen to have lowest nonzero
          degree.  Then the resultant of <E> and <E_j> with respect to
          <x> is computed for each of the remaining equations <E_j> in
          the subsystem <S_i>.  This yields a new subsystem <S_i’> in
          one fewer variables, as <x> has been eliminated.  The process
          now returns to (1).

       3. Eventually, a subsystem consisting of a single equation is
          obtained.  If the equation is multivariate and no
          approximations in the form of floating point numbers have been
          introduced, then ‘solve’ is called to find an exact solution.

          In some cases, ‘solve’ is not be able to find a solution, or
          if it does the solution may be a very large expression.

          If the equation is univariate and is either linear, quadratic,
          or biquadratic, then again ‘solve’ is called if no
          approximations have been introduced.  If approximations have
          been introduced or the equation is not univariate and neither
          linear, quadratic, or biquadratic, then if the switch
          ‘realonly’ is ‘true’, the function ‘realroots’ is called to
          find the real-valued solutions.  If ‘realonly’ is ‘false’,
          then ‘allroots’ is called which looks for real and
          complex-valued solutions.

          If ‘algsys’ produces a solution which has fewer significant
          digits than required, the user can change the value of
          ‘algepsilon’ to a higher value.

          If ‘algexact’ is set to ‘true’, ‘solve’ will always be called.

       4. Finally, the solutions obtained in step (3) are substituted
          into previous levels and the solution process returns to (1).

     When ‘algsys’ encounters a multivariate equation which contains
     floating point approximations (usually due to its failing to find
     exact solutions at an earlier stage), then it does not attempt to
     apply exact methods to such equations and instead prints the
     message: "‘algsys’ cannot solve - system too complicated."

     Interactions with ‘radcan’ can produce large or complicated
     expressions.  In that case, it may be possible to isolate parts of
     the result with ‘pickapart’ or ‘reveal’.

     Occasionally, ‘radcan’ may introduce an imaginary unit ‘%i’ into a
     solution which is actually real-valued.

     Examples:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3

 -- Function: allroots
          allroots (<expr>)
          allroots (<eqn>)

     Computes numerical approximations of the real and complex roots of
     the polynomial <expr> or polynomial equation <eqn> of one variable.

     The flag ‘polyfactor’ when ‘true’ causes ‘allroots’ to factor the
     polynomial over the real numbers if the polynomial is real, or over
     the complex numbers, if the polynomial is complex.

     ‘allroots’ may give inaccurate results in case of multiple roots.
     If the polynomial is real, ‘allroots (%i*<p>)’ may yield more
     accurate approximations than ‘allroots (<p>)’, as ‘allroots’
     invokes a different algorithm in that case.

     ‘allroots’ rejects non-polynomials.  It requires that the numerator
     after ‘rat’’ing should be a polynomial, and it requires that the
     denominator be at most a complex number.  As a result of this
     ‘allroots’ will always return an equivalent (but factored)
     expression, if ‘polyfactor’ is ‘true’.

     For complex polynomials an algorithm by Jenkins and Traub is used
     (Algorithm 419, Comm.  ACM, vol.  15, (1972), p.  97).  For real
     polynomials the algorithm used is due to Jenkins (Algorithm 493,
     ACM TOMS, vol.  1, (1975), p.178).

     Examples:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)

 -- Function: bfallroots
          bfallroots (<expr>)
          bfallroots (<eqn>)

     Computes numerical approximations of the real and complex roots of
     the polynomial <expr> or polynomial equation <eqn> of one variable.

     In all respects, ‘bfallroots’ is identical to ‘allroots’ except
     that ‘bfallroots’ computes the roots using bigfloats.  See
     ‘allroots’ for more information.

 -- Option variable: backsubst
     Default value: ‘true’

     When ‘backsubst’ is ‘false’, prevents back substitution in
     ‘linsolve’ after the equations have been triangularized.  This may
     be helpful in very big problems where back substitution would cause
     the generation of extremely large expressions.

          (%i1) eq1 : x + y + z = 6$
          (%i2) eq2 : x - y + z = 2$
          (%i3) eq3 : x + y - z = 0$
          (%i4) backsubst : false$
          (%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o5)             [x = z - y, y = 2, z = 3]
          (%i6) backsubst : true$
          (%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o7)               [x = 1, y = 2, z = 3]

 -- Option variable: breakup
     Default value: ‘true’

     When ‘breakup’ is ‘true’, ‘solve’ expresses solutions of cubic and
     quartic equations in terms of common subexpressions, which are
     assigned to intermediate expression labels (‘%t1’, ‘%t2’, etc.).
     Otherwise, common subexpressions are not identified.

     ‘breakup: true’ has an effect only when ‘programmode’ is ‘false’.

     Examples:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3
                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54
                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]

 -- Function: dimension
          dimension (<eqn>)
          dimension (<eqn_1>, …, <eqn_n>)

     ‘dimen’ is a package for dimensional analysis.  ‘load ("dimen")’
     loads this package.  ‘demo ("dimen")’ displays a short
     demonstration.

 -- Option variable: dispflag
     Default value: ‘true’

     If set to ‘false’ within a ‘block’ will inhibit the display of
     output generated by the solve functions called from within the
     ‘block’.  Termination of the ‘block’ with a dollar sign, ‘$’, sets
     ‘dispflag’ to ‘false’.

 -- Function: funcsolve (<eqn>, <g>(<t>))

     Returns ‘[<g>(<t>) = ...]’ or ‘[]’, depending on whether or not
     there exists a rational function ‘<g>(<t>)’ satisfying <eqn>, which
     must be a first order, linear polynomial in (for this case)
     ‘<g>(<t>)’ and ‘<g>(<t>+1)’

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
                (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Warning: this is a very rudimentary implementation – many safety
     checks and obvious generalizations are missing.

 -- Option variable: globalsolve
     Default value: ‘false’

     When ‘globalsolve’ is ‘true’, solved-for variables are assigned the
     solution values found by ‘linsolve’, and by ‘solve’ when solving
     two or more linear equations.

     When ‘globalsolve’ is ‘false’, solutions found by ‘linsolve’ and by
     ‘solve’ when solving two or more linear equations are expressed as
     equations, and the solved-for variables are not assigned.

     When solving anything other than two or more linear equations,
     ‘solve’ ignores ‘globalsolve’.  Other functions which solve
     equations (e.g., ‘algsys’) always ignore ‘globalsolve’.

     Examples:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y

 -- Function: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)

     ‘inteqn’ is a package for solving integral equations.  ‘load
     ("inteqn")’ loads this package.

     <ie> is the integral equation; <unk> is the unknown function;
     <tech> is the technique to be tried from those given in the lists
     below; (<tech> = ‘first’ means: try the first technique which finds
     a solution; <tech> = ‘all’ means: try all applicable techniques);
     <n> is the maximum number of terms to take for ‘taylor’, ‘neumann’,
     ‘firstkindseries’, or ‘fredseries’ (it is also the maximum depth of
     recursion for the differentiation method); <guess> is the initial
     guess for ‘neumann’ or ‘firstkindseries’.

     Two types of equations are considered.  A second-kind equation of
     the following form,
                                     b(x)
                                    /
                                    [
                  p(x) = q(x, p(x), I     w(x, u, p(x), p(u)) du)
                                    ]
                                    /
                                     a(x)

     and a first-kind equation with the form
                                   b(x)
                                  /
                                  [
                           f(x) = I     w(x, u, p(u)) du
                                  ]
                                  /
                                   a(x)

     The different solution techniques used require particular forms of
     the expressions <q> and <w>.  The techniques available are the
     following:

     Second-kind equations
        • ‘flfrnk2nd’: For fixed-limit, finite-rank integrands.
        • ‘vlfrnk’: For variable-limit, finite-rank integrands.
        • ‘transform’: Laplace transform for convolution types.
        • ‘fredseries’: Fredholm-Carleman series for linear equations.
        • ‘tailor’: Taylor series for quasi-linear variable-limit
          equations.
        • ‘neumann’: Neumann series for quasi-second kind equations.
        • ‘collocate’: Collocation using a power series form for p(x)
          evaluated at equally spaced points.

     First-kind equations
        • ‘flfrnk1st’: For fixed-limit, finite-rank integrands.
        • ‘vlfrnk’: For variable-limit, finite-rank integrands.
        • ‘abel’: For singular integrands
        • ‘transform’: See above
        • ‘collocate’: See above
        • ‘firstkindseries’: Iteration technique similar to neumann
          series.

     The default values for the 2nd thru 5th parameters in the calling
     form are:

     <unk>: ‘<p>(<x>)’, where <p> is the first function encountered in
     an integrand which is unknown to Maxima and <x> is the variable
     which occurs as an argument to the first occurrence of <p> found
     outside of an integral in the case of ‘secondkind’ equations, or is
     the only other variable besides the variable of integration in
     ‘firstkind’ equations.  If the attempt to search for <x> fails, the
     user will be asked to supply the independent variable.  <tech>:
     ‘first’.  <n>: 1.  <guess>: ‘none’ which will cause ‘neumann’ and
     ‘firstkindseries’ to use ‘<f>(<x>)’ as an initial guess.

     Examples:
          (%i1) load("inteqn")$

          (%i2) e: p(x) - 1 -x + cos(x) + 'integrate(cos(x-u)*p(u),u,0,x)$

          (%i3) ieqn(e, p(x), 'transform);
          default 4th arg, number of iterations or coll. parms.:  1
          default 5th arg, initial guess:  none

          (%t3)                           [x, transform]
          (%o3)                               [%t3]
          (%i4) e: 2*'integrate(p(x*sin(u)), u, 0, %pi/2) - a*x - b$

          (%i5) ieqn(e, p(x), 'firstkindseries);
          default 4th arg, number of iterations or coll. parms.:  1
          default 5th arg, initial guess:  none

          (%t5)          [2 a x + %pi b, firstkindseries, 1, approximate]
          (%o5)                               [%t5]

 -- Option variable: ieqnprint
     Default value: ‘true’

     ‘ieqnprint’ governs the behavior of the result returned by the
     ‘ieqn’ command.  When ‘ieqnprint’ is ‘false’, the lists returned by
     the ‘ieqn’ function are of the form

     [<solution>, <technique used>, <nterms>, <flag>]

     where <flag> is absent if the solution is exact.

     Otherwise, it is the word ‘approximate’ or ‘incomplete’
     corresponding to an inexact or non-closed form solution,
     respectively.  If a series method was used, <nterms> gives the
     number of terms taken (which could be less than the n given to
     ‘ieqn’ if an error prevented generation of further terms).

 -- Function: lhs (<expr>)

     Returns the left-hand side (that is, the first argument) of the
     expression <expr>, when the operator of <expr> is one of the
     relational operators ‘< <= = # equal notequal >= >’, one of the
     assignment operators ‘:= ::= : ::’, or a user-defined binary infix
     operator, as declared by ‘infix’.

     When <expr> is an atom or its operator is something other than the
     ones listed above, ‘lhs’ returns <expr>.

     See also ‘rhs’.

     Examples:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
                 lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa

 -- Function: linsolve ([<expr_1>, …, <expr_m>], [<x_1>, …, <x_n>])

     Solves the list of simultaneous linear equations for the list of
     variables.  The expressions must each be polynomials in the
     variables and may be equations.  If the length of the list of
     variables doesn’t match the number of linearly-independent
     equations to solve the result will be an empty list.

     When ‘globalsolve’ is ‘true’, each solved-for variable is bound to
     its value in the solution of the equations.

     When ‘backsubst’ is ‘false’, ‘linsolve’ does not carry out back
     substitution after the equations have been triangularized.  This
     may be necessary in very big problems where back substitution would
     cause the generation of extremely large expressions.

     When ‘linsolve_params’ is ‘true’, ‘linsolve’ also generates the
     ‘%r’ symbols used to represent arbitrary parameters described in
     the manual under ‘algsys’.  Otherwise, ‘linsolve’ solves an
     under-determined system of equations with some variables expressed
     in terms of others.

     When ‘programmode’ is ‘false’, ‘linsolve’ displays the solution
     with intermediate expression (‘%t’) labels, and returns the list of
     labels.

     See also ‘algsys’, ‘eliminate’.  and ‘solve’.

     Examples:
          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]

 -- Option variable: linsolvewarn
     Default value: ‘true’

     When ‘linsolvewarn’ is ‘true’, ‘linsolve’ prints a message
     "Dependent equations eliminated".

 -- Option variable: linsolve_params
     Default value: ‘true’

     When ‘linsolve_params’ is ‘true’, ‘linsolve’ also generates the
     ‘%r’ symbols used to represent arbitrary parameters described in
     the manual under ‘algsys’.  Otherwise, ‘linsolve’ solves an
     under-determined system of equations with some variables expressed
     in terms of others.

 -- System variable: multiplicities
     Default value: ‘not_set_yet’

     ‘multiplicities’ is set to a list of the multiplicities of the
     individual solutions returned by ‘solve’ or ‘realroots’.

 -- Function: nroots (<p>, <low>, <high>)

     Returns the number of real roots of the real univariate polynomial
     <p> in the half-open interval ‘(<low>, <high>]’.  The endpoints of
     the interval may be ‘minf’ or ‘inf’.

     ‘nroots’ uses the method of Sturm sequences.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4

 -- Function: nthroot (<p>, <n>)

     where <p> is a polynomial with integer coefficients and <n> is a
     positive integer returns ‘q’, a polynomial over the integers, such
     that ‘q^n = p’ or prints an error message indicating that <p> is
     not a perfect nth power.  This routine is much faster than ‘factor’
     or even ‘sqfr’.

 -- Option variable: polyfactor
     Default value: ‘false’

     The option variable ‘polyfactor’ when ‘true’ causes ‘allroots’ and
     ‘bfallroots’ to factor the polynomial over the real numbers if the
     polynomial is real, or over the complex numbers, if the polynomial
     is complex.

     See ‘allroots’ for an example.

 -- Option variable: programmode
     Default value: ‘true’

     When ‘programmode’ is ‘true’, ‘solve’, ‘realroots’, ‘allroots’, and
     ‘linsolve’ return solutions as elements in a list.  (Except when
     ‘backsubst’ is set to ‘false’, in which case ‘programmode: false’
     is assumed.)

     When ‘programmode’ is ‘false’, ‘solve’, etc.  create intermediate
     expression labels ‘%t1’, ‘%t2’, etc., and assign the solutions to
     them.

 -- Option variable: realonly
     Default value: ‘false’

     When ‘realonly’ is ‘true’, ‘algsys’ returns only those solutions
     which are free of ‘%i’.

 -- Function: realroots
          realroots (<expr>, <bound>)
          realroots (<eqn>, <bound>)
          realroots (<expr>)
          realroots (<eqn>)

     Computes rational approximations of the real roots of the
     polynomial <expr> or polynomial equation <eqn> of one variable, to
     within a tolerance of <bound>.  Coefficients of <expr> or <eqn>
     must be literal numbers; symbol constants such as ‘%pi’ are
     rejected.

     ‘realroots’ assigns the multiplicities of the roots it finds to the
     global variable ‘multiplicities’.

     ‘realroots’ constructs a Sturm sequence to bracket each root, and
     then applies bisection to refine the approximations.  All
     coefficients are converted to rational equivalents before searching
     for roots, and computations are carried out by exact rational
     arithmetic.  Even if some coefficients are floating-point numbers,
     the results are rational (unless coerced to floats by the ‘float’
     or ‘numer’ flags).

     When <bound> is less than 1, all integer roots are found exactly.
     When <bound> is unspecified, it is assumed equal to the global
     variable ‘rootsepsilon’.

     When the global variable ‘programmode’ is ‘true’, ‘realroots’
     returns a list of the form ‘[x = <x_1>, x = <x_2>, ...]’.  When
     ‘programmode’ is ‘false’, ‘realroots’ creates intermediate
     expression labels ‘%t1’, ‘%t2’, …, assigns the results to them, and
     returns the list of labels.

     Examples:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]

 -- Function: rhs (<expr>)

     Returns the right-hand side (that is, the second argument) of the
     expression <expr>, when the operator of <expr> is one of the
     relational operators ‘< <= = # equal notequal >= >’, one of the
     assignment operators ‘:= ::= : ::’, or a user-defined binary infix
     operator, as declared by ‘infix’.

     When <expr> is an atom or its operator is something other than the
     ones listed above, ‘rhs’ returns 0.

     See also ‘lhs’.

     Examples:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
                 rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb

 -- Option variable: rootsconmode
     Default value: ‘true’

     ‘rootsconmode’ governs the behavior of the ‘rootscontract’ command.
     See ‘rootscontract’ for details.

 -- Function: rootscontract (<expr>)

     Converts products of roots into roots of products.  For example,
     ‘rootscontract (sqrt(x)*y^(3/2))’ yields ‘sqrt(x*y^3)’.

     When ‘radexpand’ is ‘true’ and ‘domain’ is ‘real’, ‘rootscontract’
     converts ‘abs’ into ‘sqrt’, e.g., ‘rootscontract (abs(x)*sqrt(y))’
     yields ‘sqrt(x^2*y)’.

     There is an option ‘rootsconmode’ affecting ‘rootscontract’ as
     follows:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     When ‘rootsconmode’ is ‘false’, ‘rootscontract’ contracts only with
     respect to rational number exponents whose denominators are the
     same.  The key to the ‘rootsconmode: true’ examples is simply that
     2 divides into 4 but not into 3.  ‘rootsconmode: all’ involves
     taking the least common multiple of the denominators of the
     exponents.

     ‘rootscontract’ uses ‘ratsimp’ in a manner similar to
     ‘logcontract’.

     Examples:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
          (%o13)                          0

 -- Option variable: rootsepsilon
     Default value: 1.0e-7

     ‘rootsepsilon’ is the tolerance which establishes the confidence
     interval for the roots found by the ‘realroots’ function.

 -- Function: solve
          solve (<expr>, <x>)
          solve (<expr>)
          solve ([<eqn_1>, …, <eqn_n>], [<x_1>, …, <x_n>])

     Solves the algebraic equation <expr> for the variable <x> and
     returns a list of solution equations in <x>.  If <expr> is not an
     equation, the equation ‘<expr> = 0’ is assumed in its place.  <x>
     may be a function (e.g.  ‘f(x)’), or other non-atomic expression
     except a sum or product.  <x> may be omitted if <expr> contains
     only one variable.  <expr> may be a rational expression, and may
     contain trigonometric functions, exponentials, etc.

     The following method is used:

     Let <E> be the expression and <X> be the variable.  If <E> is
     linear in <X> then it is trivially solved for <X>.  Otherwise if
     <E> is of the form ‘A*X^N + B’ then the result is ‘(-B/A)^1/N)’
     times the ‘N’’th roots of unity.

     If <E> is not linear in <X> then the gcd of the exponents of <X> in
     <E> (say <N>) is divided into the exponents and the multiplicity of
     the roots is multiplied by <N>.  Then ‘solve’ is called again on
     the result.  If <E> factors then ‘solve’ is called on each of the
     factors.  Finally ‘solve’ will use the quadratic, cubic, or quartic
     formulas where necessary.

     In the case where <E> is a polynomial in some function of the
     variable to be solved for, say ‘F(X)’, then it is first solved for
     ‘F(X)’ (call the result <C>), then the equation ‘F(X)=C’ can be
     solved for <X> provided the inverse of the function <F> is known.

     ‘breakup’ if ‘false’ will cause ‘solve’ to express the solutions of
     cubic or quartic equations as single expressions rather than as
     made up of several common subexpressions which is the default.

     ‘multiplicities’ - will be set to a list of the multiplicities of
     the individual solutions returned by ‘solve’, ‘realroots’, or
     ‘allroots’.  Try ‘apropos (solve)’ for the switches which affect
     ‘solve’.  ‘describe’ may then by used on the individual switch
     names if their purpose is not clear.

     ‘solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])’ solves a
     system of simultaneous (linear or non-linear) polynomial equations
     by calling ‘linsolve’ or ‘algsys’ and returns a list of the
     solution lists in the variables.  In the case of ‘linsolve’ this
     list would contain a single list of solutions.  It takes two lists
     as arguments.  The first list represents the equations to be
     solved; the second list is a list of the unknowns to be determined.
     If the total number of variables in the equations is equal to the
     number of equations, the second argument-list may be omitted.

     When ‘programmode’ is ‘false’, ‘solve’ displays solutions with
     intermediate expression (‘%t’) labels, and returns the list of
     labels.

     When ‘globalsolve’ is ‘true’ and the problem is to solve two or
     more linear equations, each solved-for variable is bound to its
     value in the solution of the equations.

     Examples:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          solve: using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]

          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i
           - .1331240357358706, y = .07678378523787788
           - 3.608003221870287 %i], [x = - .5202594388652008 %i
           - .1331240357358706, y = 3.608003221870287 %i
           + .07678378523787788], [x = - 1.733751846381093,
          y = - .1535675710019696]]

          (%i5) solve (1 + a*x + x^3, x);

                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

     The symbols ‘%r’ are used to denote arbitrary constants in a
     solution.

          (%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

          solve: dependent equations eliminated: (2)
          (%o1)                      [[x = 1 - %r1, y = %r1]]

     See ‘algsys’ and ‘%rnum_list’ for more information.

 -- Option variable: solvedecomposes
     Default value: ‘true’

     When ‘solvedecomposes’ is ‘true’, ‘solve’ calls ‘polydecomp’ if
     asked to solve polynomials.

 -- Option variable: solveexplicit
     Default value: ‘false’

     When ‘solveexplicit’ is ‘true’, inhibits ‘solve’ from returning
     implicit solutions, that is, solutions of the form ‘F(x) = 0’ where
     ‘F’ is some function.

 -- Option variable: solvefactors
     Default value: ‘true’

     When ‘solvefactors’ is ‘false’, ‘solve’ does not try to factor the
     expression.  The ‘false’ setting may be desired in some cases where
     factoring is not necessary.

 -- Option variable: solvenullwarn
     Default value: ‘true’

     When ‘solvenullwarn’ is ‘true’, ‘solve’ prints a warning message if
     called with either a null equation list or a null variable list.
     For example, ‘solve ([], [])’ would print two warning messages and
     return ‘[]’.

 -- Option variable: solveradcan
     Default value: ‘false’

     When ‘solveradcan’ is ‘true’, ‘solve’ calls ‘radcan’ which makes
     ‘solve’ slower but will allow certain problems containing
     exponentials and logarithms to be solved.

 -- Option variable: solvetrigwarn
     Default value: ‘true’

     When ‘solvetrigwarn’ is ‘true’, ‘solve’ may print a message saying
     that it is using inverse trigonometric functions to solve the
     equation, and thereby losing solutions.


File: maxima.info,  Node: Дифференциальные уравнения,  Next: Numerical,  Prev: Equations,  Up: Top

20 Дифференциальные уравнения
*****************************

* Menu:

* Дифференциальные уравнения в Maxima::  
* Функции и переменные для дифференциальных уравнений::  


File: maxima.info,  Node: Дифференциальные уравнения в Maxima,  Next: Функции и переменные для дифференциальных уравнений,  Prev: Дифференциальные уравнения,  Up: Дифференциальные уравнения

20.1 Дифференциальные уравнения в Maxima
========================================

Этот раздел описывает функции Maxima для аналитического решения
некоторых типов дифференциальных уравнений первого и второго порядка.
Для получения численного решения системы дифференциальных уравнений
используйте дополнительный пакет ‘dynamics’, для графического
представления в фазовом пространстве - пакет ‘plotdf’.


File: maxima.info,  Node: Функции и переменные для дифференциальных уравнений,  Prev: Дифференциальные уравнения в Maxima,  Up: Дифференциальные уравнения

20.2 Функции и переменные для дифференциальных уравнений
========================================================

 -- Функция: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)

     Решает краевую задачу для дифференциального уравнения второго
     порядка.  Здесь <solution> - общее решение уравнения, полученное
     ‘ode2’; <xval1> задает значение независимой переменной в начальной
     точке в виде ‘<x> = <x1>’ и <yval1> задает значение зависимой
     переменной в этой точке в виде ‘<y> = <y1>’.  Выражения <xval2> и
     <yval2> определяют значения для этих переменных во второй точке,
     используя ту же запись.

     Пример использования см.  в ‘ode2’.

 -- Функция: desolve (<eqn>, <x>)
 -- Функция: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Функция ‘desolve’ решает линейные системы обыкновенных
     дифференциальных уравнений при помощи преобразования Лапласа.
     Здесь <eqn> - дифференциальные уравнения со связанными переменными
     <x_1>, ..., <x_n>.  Функциональная зависимость между <x_1>, ...,
     <x_n> или от независимой переменной, например, <x>, должна явно
     задаваться в переменных и их производных.  Например, следующее
     определение двух уравнений неверно:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     Правильная запись -

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     Тогда вызов функции ‘desolve’ будет иметь вид
          desolve([eqn_1, eqn_2], [f(x),g(x)]);

     Если известны начальные условия в ‘x=0’, то при помощи ‘atvalue’ их
     можно дополнительно определить до вызова ‘desolve’.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Если ‘desolve’ не может получить решение, возвращается ‘false’.

 -- Функция: ic1 (<solution>, <xval>, <yval>)

     Решает задачи с начальными условиями для дифференциальных уравнений
     первого порядка.  Здесь <solution> - общее решение уравнения,
     полученное ‘ode2’; <xval> задает начальное значение независимой
     переменной в виде ‘<x> = <x0>’, и <yval> задает начальное значение
     зависимой переменной в виде ‘<y> = <y0>’.

     Пример использования см.  в ‘ode2’.

 -- Функция: ic2 (<solution>, <xval>, <yval>, <dval>)

     Решает задачи с начальными условиями для дифференциальных уравнений
     второго порядка.  Здесь <solution> - общее решение уравнения,
     полученное ‘ode2’; <xval> задает начальное значение независимой
     переменной в виде ‘<x> = <x0>’, <yval> задает начальное значение
     зависимой переменной в виде ‘<y> = <y0>’, и <dval> задает начальное
     значение для первой производной зависимой переменной по независимой
     в виде ‘diff(<y>,<x>) = <dy0>’ (перед ‘diff’ не нужно ставить
     кавычку).

     Пример использования см.  в ‘ode2’.

 -- Функция: ode2 (<eqn>, <dvar>, <ivar>)

     Функция ‘ode2’ решает обыкновенное дифференциальное уравнение (ОДУ)
     первого или второго порядка.  Она принимает три аргумента: ОДУ
     <eqn>, зависимую переменную <dvar> и независимую переменную <ivar>.
     При удачном результате возвращается явное или неявное решение
     относительно зависимой переменной.  ‘%c’ используется для
     представления константы интегрирования в случае уравнений первого
     порядка; ‘%k1’ и ‘%k2’ - константы в решениях уравнений второго
     порядка.  Зависимость зависимой переменной от независимой не
     требуется указывать явно, как в случае с ‘desolve’, но независимая
     переменная должна всегда указываться в качестве третьего аргумента.

     Если по каким-то причинам ‘ode2’ не может получить решение,
     возвращается ‘false’, и, возможно, печатается сообщение об ошибке.
     Методы решения уравнений первого порядка (в том порядке, в каком
     Maxima пытается их применять): линейный, разделение переменных,
     явный - возможно, используется интегрирующий множитель, однородное
     уравнение, уравнение Бернулли и обобщенный однородный метод.

     Типы решаемых уравнений второго порядка: уравнение с постоянными
     коэффициентами, явное, линейное однородное с непостоянными
     коэффициентами, преобразующимися к постоянным, уравнение Эйлера
     (или равноразмерное), уравнения, решаемые методом вариации
     переменных, а также уравнения без независимой или зависимой
     переменной, сводимые для последующего решения к линейным уравнениям
     первого порядка.

     В ходе решения ОДУ чисто для справки устанавливается несколько
     переменных: ‘method’ указывает на использованный метод решения
     (например, ‘linear’), ‘intfactor’ - использованный интегрирующий
     множитель, ‘odeindex’ - коэффициент, примененный в методе Бернулли
     или обобщенном однородном методе, а ‘yp’ - частное решение для
     метода вариации переменных.

     Для решения задач с начальными условиями для уравнений первого и
     второго порядка доступны функции ‘ic1’ и ‘ic2’, а для решения
     краевых задач может использоваться функция ‘bc2’.

     Пример:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2


File: maxima.info,  Node: Numerical,  Next: Массивы,  Prev: Дифференциальные уравнения,  Up: Top

21 Numerical
************

* Menu:

* Introduction to fast Fourier transform::                     
* Functions and Variables for fast Fourier transform::
* Functions and Variables for FFTPACK5::
* Functions for numerical solution of equations::
* Introduction to numerical solution of differential equations::
* Functions for numerical solution of differential equations::


File: maxima.info,  Node: Introduction to fast Fourier transform,  Next: Functions and Variables for fast Fourier transform

21.1 Introduction to fast Fourier transform
===========================================

The ‘fft’ package comprises functions for the numerical (not symbolic)
computation of the fast Fourier transform.  This is limited to sequences
whit length that is a power of two.  For more general lengths, consider
the ‘fftpack5’ package that supports sequences of any length, but is
most efficient if the length is a product of small primes.


File: maxima.info,  Node: Functions and Variables for fast Fourier transform,  Next: Functions and Variables for FFTPACK5,  Prev: Introduction to fast Fourier transform

21.2 Functions and Variables for fft
====================================

 -- Function: polartorect (<r>, <t>)

     Translates complex values of the form ‘r %e^(%i t)’ to the form ‘a
     + b %i’, where <r> is the magnitude and <t> is the phase.  <r> and
     <t> are 1-dimensional arrays of the same size.  The array size need
     not be a power of 2.

     The original values of the input arrays are replaced by the real
     and imaginary parts, ‘a’ and ‘b’, on return.  The outputs are
     calculated as

          a = r cos(t)
          b = r sin(t)

     ‘polartorect’ is the inverse function of ‘recttopolar’.

     ‘load("fft")’ loads this function.  See also ‘fft’.

 -- Function: recttopolar (<a>, <b>)

     Translates complex values of the form ‘a + b %i’ to the form ‘r
     %e^(%i t)’, where <a> is the real part and <b> is the imaginary
     part.  <a> and <b> are 1-dimensional arrays of the same size.  The
     array size need not be a power of 2.

     The original values of the input arrays are replaced by the
     magnitude and angle, ‘r’ and ‘t’, on return.  The outputs are
     calculated as

          r = sqrt(a^2 + b^2)
          t = atan2(b, a)

     The computed angle is in the range ‘-%pi’ to ‘%pi’.

     ‘recttopolar’ is the inverse function of ‘polartorect’.

     ‘load("fft")’ loads this function.  See also ‘fft’.

 -- Function: inverse_fft (<y>)

     Computes the inverse complex fast Fourier transform.  <y> is a list
     or array (named or unnamed) which contains the data to transform.
     The number of elements must be a power of 2.  The elements must be
     literal numbers (integers, rationals, floats, or bigfloats) or
     symbolic constants, or expressions ‘a + b*%i’ where ‘a’ and ‘b’ are
     literal numbers or symbolic constants.

     ‘inverse_fft’ returns a new object of the same type as <y>, which
     is not modified.  Results are always computed as floats or
     expressions ‘a + b*%i’ where ‘a’ and ‘b’ are floats.  If bigfloat
     precision is needed the function ‘bf_inverse_fft’ can be used
     instead as a drop-in replacement of ‘inverse_fft’ that is slower,
     but supports bfloats.

     The inverse discrete Fourier transform is defined as follows.  Let
     ‘x’ be the output of the inverse transform.  Then for ‘j’ from 0
     through ‘n - 1’,

          x[j] = sum(y[k] exp(-2 %i %pi j k / n), k, 0, n - 1)

     As there are various sign and normalization conventions possible,
     this definition of the transform may differ from that used by other
     mathematical software.

     ‘load("fft")’ loads this function.

     See also ‘fft’ (forward transform), ‘recttopolar’, and
     ‘polartorect’.

     Examples:

     Real data.

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [0.0, 14.49 %i - .8284, 0.0, 2.485 %i + 4.828, 0.0,
                                 4.828 - 2.485 %i, 0.0, - 14.49 %i - .8284]
          (%i5) L2 : fft (L1);
          (%o5) [1.0, 2.0 - 2.168L-19 %i, 3.0 - 7.525L-20 %i,
          4.0 - 4.256L-19 %i, - 1.0, 2.168L-19 %i - 2.0,
          7.525L-20 %i - 3.0, 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Complex data.

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [4.0, 2.711L-19 %i + 4.0, 2.0 %i - 2.0,
          - 2.828 %i - 2.828, 0.0, 5.421L-20 %i + 4.0, - 2.0 %i - 2.0,
          2.828 %i + 2.828]
          (%i5) L2 : fft (L1);
          (%o5) [4.066E-20 %i + 1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          1.55L-19 %i - 1.0, - 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.0 - 7.368L-20 %i]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.841L-17

 -- Function: fft (<x>)

     Computes the complex fast Fourier transform.  <x> is a list or
     array (named or unnamed) which contains the data to transform.  The
     number of elements must be a power of 2.  The elements must be
     literal numbers (integers, rationals, floats, or bigfloats) or
     symbolic constants, or expressions ‘a + b*%i’ where ‘a’ and ‘b’ are
     literal numbers or symbolic constants.

     ‘fft’ returns a new object of the same type as <x>, which is not
     modified.  Results are always computed as floats or expressions ‘a
     + b*%i’ where ‘a’ and ‘b’ are floats.  If bigfloat precision is
     needed the function ‘bf_fft’ can be used instead as a drop-in
     replacement of ‘fft’ that is slower, but supports bfloats.  In
     addition if it is known that the input consists of only real values
     (no imaginary parts), ‘real_fft’ can be used which is potentially
     faster.

     The discrete Fourier transform is defined as follows.  Let ‘y’ be
     the output of the transform.  Then for ‘k’ from 0 through ‘n - 1’,

          y[k] = (1/n) sum(x[j] exp(+2 %i %pi j k / n), j, 0, n - 1)

     As there are various sign and normalization conventions possible,
     this definition of the transform may differ from that used by other
     mathematical software.

     When the data <x> are real, real coefficients ‘a’ and ‘b’ can be
     computed such that

          x[j] = sum(a[k]*cos(2*%pi*j*k/n)+b[k]*sin(2*%pi*j*k/n), k, 0, n/2)

     with

          a[0] = realpart (y[0])
          b[0] = 0

     and, for k from 1 through n/2 - 1,

          a[k] = realpart (y[k] + y[n - k])
          b[k] = imagpart (y[n - k] - y[k])

     and

          a[n/2] = realpart (y[n/2])
          b[n/2] = 0

     ‘load("fft")’ loads this function.

     See also ‘inverse_fft’ (inverse transform), ‘recttopolar’, and
     ‘polartorect’..  See ‘real_fft’ for FFTs of a real-valued input,
     and ‘bf_fft’ and ‘bf_real_fft’ for operations on bigfloat values.
     Finally, for transforms of any size (but limited to float values),
     see ‘fftpack5_fft’ and ‘fftpack5_real_fft’.

     Examples:

     Real data.

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : fft (L);
          (%o4) [0.0, 1.811 %i - .1036, 0.0, 0.3107 %i + .6036, 0.0,
                                   0.6036 - 0.3107 %i, 0.0, (- 1.811 %i) - 0.1036]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 2.168L-19 %i + 2.0, 7.525L-20 %i + 3.0,
          4.256L-19 %i + 4.0, - 1.0, - 2.168L-19 %i - 2.0,
          - 7.525L-20 %i - 3.0, - 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Complex data.

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fft (L);
          (%o4) [0.5, 0.5, 0.25 %i - 0.25, (- 0.3536 %i) - 0.3536, 0.0, 0.5,
                                                  (- 0.25 %i) - 0.25, 0.3536 %i + 0.3536]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i, - 1.0, - 1.0, 1.0 - 1.0 %i,
                                                                       1.0 %i + 1.0, 1.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       0.0

     Computation of sine and cosine coefficients.

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, 5, 6, 7, 8] $
          (%i4) n : length (L) $
          (%i5) x : make_array (any, n) $
          (%i6) fillarray (x, L) $
          (%i7) y : fft (x) $
          (%i8) a : make_array (any, n/2 + 1) $
          (%i9) b : make_array (any, n/2 + 1) $
          (%i10) a[0] : realpart (y[0]) $
          (%i11) b[0] : 0 $
          (%i12) for k : 1 thru n/2 - 1 do
             (a[k] : realpart (y[k] + y[n - k]),
              b[k] : imagpart (y[n - k] - y[k]));
          (%o12)                        done
          (%i13) a[n/2] : y[n/2] $
          (%i14) b[n/2] : 0 $
          (%i15) listarray (a);
          (%o15)          [4.5, - 1.0, - 1.0, - 1.0, - 0.5]
          (%i16) listarray (b);
          (%o16)           [0, - 2.414, - 1.0, - .4142, 0]
          (%i17) f(j) := sum (a[k]*cos(2*%pi*j*k/n) + b[k]*sin(2*%pi*j*k/n),
                              k, 0, n/2) $
          (%i18) makelist (float (f (j)), j, 0, n - 1);
          (%o18)      [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]

 -- Function: real_fft (<x>)

     Computes the fast Fourier transform of a real-valued sequence <x>.
     This is equivalent to performing ‘fft(x)’, except that only the
     first ‘N/2+1’ results are returned, where ‘N’ is the length of <x>.
     ‘N’ must be power of two.

     No check is made that <x> contains only real values.

     The symmetry properties of the Fourier transform of real sequences
     to reduce he complexity.  In particular the first and last output
     values of ‘real_fft’ are purely real.  For larger sequences,
     ‘real_fft’ may be computed more quickly than ‘fft’.

     Since the output length is short, the normal ‘inverse_fft’ cannot
     be directly used.  Use ‘inverse_real_fft’ to compute the inverse.

 -- Function: inverse_real_fft (<y>)
     Computes the inverse Fourier transform of <y>, which must have a
     length of ‘N/2+1’ where ‘N’ is a power of two.  That is, the input
     <x> is expected to be the output of ‘real_fft’.

     No check is made to ensure that the input has the correct format.
     (The first and last elements must be purely real.)

 -- Function: bf_inverse_fft (<y>)

     Computes the inverse complex fast Fourier transform.  This is the
     bigfloat version of ‘inverse_fft’ that converts the input to
     bigfloats and returns a bigfloat result.

 -- Function: bf_fft (<y>)

     Computes the forward complex fast Fourier transform.  This is the
     bigfloat version of ‘fft’ that converts the input to bigfloats and
     returns a bigfloat result.

 -- Function: bf_real_fft (<x>)

     Computes the forward fast Fourier transform of a real-valued input
     returning a bigfloat result.  This is the bigfloat version of
     ‘real_fft’.

 -- Function: bf_inverse_real_fft (<y>)
     Computes the inverse fast Fourier transform with a real-valued
     bigfloat output.  This is the bigfloat version of
     ‘inverse_real_fft’.


File: maxima.info,  Node: Functions and Variables for FFTPACK5,  Next: Functions for numerical solution of equations,  Prev: Functions and Variables for fast Fourier transform

21.3 Functions and Variables for FFTPACK5
=========================================

‘FFTPACK5’ provides several routines to compute Fourier transforms for
both real and complex sequences and their inverses.  The forward
transform is defined the same as for ‘fft’.  The major difference is the
length of the sequence is not constrained to be a power of two.  In
fact, any length is supported, but it is most efficient when the length
has the form 2^r*3^s*5^t.

   ‘load("fftpack5")’ loads this function.

 -- Function: fftpack5_fft (<x>)

     Like ‘fft’ (‘fft’), this computes the fast Fourier transform of a
     complex sequence.  However, the length of <x> is not limited to a
     power of 2.

     ‘load("fftpack5")’ loads this function.

     Examples:

     Real data.

          (%i1) load("fftpack5") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2 ,-3, -4] $
          (%i4) L1 : fftpack5_fft(L);
          (%o4) [0.0, 1.811 %i - 0.1036, 0.0, 0.3107 %i + 0.6036, 0.0,
                                          0.6036 - 0.3107 %i, 0.0, (- 1.811 %i) - 0.1036]
          (%i5) L2 : fftpack5_inverse_fft(L1);
          (%o5) [1.0, 4.441e-16 %i + 2.0, 1.837e-16 %i + 3.0, 4.0 - 4.441e-16 %i,
               - 1.0, (- 4.441e-16 %i) - 2.0, (- 1.837e-16 %i) - 3.0, 4.441e-16
                 %i - 4.0]
          (%i6) lmax (abs (L2-L));
          (%o6)                       4.441e-16
          (%i7) L : [1, 2, 3, 4, 5, 6]$
          (%i8) L1 : fftpack5_fft(L);
          (%o8) [3.5, (- 0.866 %i) - 0.5, (- 0.2887 %i) - 0.5, (- 1.48e-16 %i) - 0.5,
                                                         0.2887 %i - 0.5, 0.866
                                                                %%i - 0.5]
          (%i9) L2 : fftpack5_inverse_fft (L1);
          (%o9) [1.0 - 1.48e-16 %i, 3.701e-17 %i + 2.0, 3.0 - 1.48e-16 %i,
                               4.0 - 1.811e-16 %i, 5.0 - 1.48e-16 %i, 5.881e-16
                                     %i + 6.0]
          (%i10) lmax (abs (L2-L));
          (%o10)                             9.064e-16

     Complex data.

          (%i1) load("fftpack5") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fftpack5_inverse_fft (L);
          (%o4) [4.0, 2.828 %i + 2.828, (- 2.0 %i) - 2.0, 4.0, 0.0,
                                                 (- 2.828 %i) - 2.828, 2.0 %i - 2.0, 4.0]
          (%i5) L2 : fftpack5_fft(L1);
          (%o5) [1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i, (- 2.776e-17 %i) - 1.0, - 1.0,
                                          1.0 - 1.0 %i, 1.0 %i + 1.0, 1.0 -
                                                    %2.776e-17 %i]
          (%i6) lmax(abs(L2-L));
          (%o6)                              1.11e-16

 -- Function: fftpack5_inverse_fft (<y>)

     Computes the inverse complex Fourier transform, like ‘inverse_fft’,
     but is not constrained to be a power of two.

 -- Function: fftpack5_real_fft (<x>)

     Computes the fast Fourier transform of a real-valued sequence <x>,
     just like ‘real_fft’, except the length is not constrained to be a
     power of two.

     Examples:

          (%i1) fpprintprec : 4 $
          (%i2) L : [1, 2, 3, 4, 5, 6] $
          (%i3) L1 : fftpack5_real_fft(L);
          (%o3)       [3.5, (- 0.866 %i) - 0.5, (- 0.2887 %i) - 0.5, - 0.5]
          (%i4) L2 : fftpack5_inverse_real_fft(L1, 6);
          (%o4)                  [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]
          (%i5) lmax(abs(L2-L));
          (%o5)                            1.332e-15
          (%i6) fftpack5_inverse_real_fft(L1, 7);
          (%o6)            [0.5, 2.083, 2.562, 3.7, 4.3, 5.438, 5.917]

     The last example shows how important it to set the length correctly
     for ‘fftpack5_inverse_real_fft’.

 -- Function: fftpack5_inverse_real_fft (<y>, <n>)

     Computes the inverse Fourier transform of <y>, which must have a
     length of ‘floor(n/2) + 1’.  The length of sequence produced by the
     inverse transform must be specified by <n>.  This is required
     because the length of <y> does not uniquely determine <n>.  The
     last element of <y> is always real if <n> is even, but it can be
     complex when <n> is odd.


File: maxima.info,  Node: Functions for numerical solution of equations,  Next: Introduction to numerical solution of differential equations,  Prev: Functions and Variables for FFTPACK5

21.4 Functions for numerical solution of equations
==================================================

 -- Function: horner
          horner (<expr>, <x>)
          horner (<expr>)

     Returns a rearranged representation of <expr> as in Horner’s rule,
     using <x> as the main variable if it is specified.  ‘x’ may be
     omitted in which case the main variable of the canonical rational
     expression form of <expr> is used.

     ‘horner’ sometimes improves stability if ‘expr’ is to be
     numerically evaluated.  It is also useful if Maxima is used to
     generate programs to be run in Fortran.  See also ‘stringout’.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)             1.e-155 x  - 5.5 x + 5.2e+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)         1.0 ((1.e-155 x - 5.5) x + 5.2e+155)
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           arithmetic error FLOATING-POINT-OVERFLOW signalled

          Automatically continuing.
          To enable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                 7.00000000000001e+154

 -- Function: find_root (<expr>, <x>, <a>, <b>, [<abserr>, <relerr>])
 -- Function: find_root (<f>, <a>, <b>, [<abserr>, <relerr>])
 -- Function: bf_find_root (<expr>, <x>, <a>, <b>, [<abserr>, <relerr>])
 -- Function: bf_find_root (<f>, <a>, <b>, [<abserr>, <relerr>])
 -- Option variable: find_root_error
 -- Option variable: find_root_abs
 -- Option variable: find_root_rel

     Finds a root of the expression <expr> or the function <f> over the
     closed interval [<a>, <b>].  The expression <expr> may be an
     equation, in which case ‘find_root’ seeks a root of ‘lhs(<expr>) -
     rhs(<expr>)’.

     Given that Maxima can evaluate <expr> or <f> over [<a>, <b>] and
     that <expr> or <f> is continuous, ‘find_root’ is guaranteed to find
     the root, or one of the roots if there is more than one.

     ‘find_root’ initially applies binary search.  If the function in
     question appears to be smooth enough, ‘find_root’ applies linear
     interpolation instead.

     ‘bf_find_root’ is a bigfloat version of ‘find_root’.  The function
     is computed using bigfloat arithmetic and a bigfloat result is
     returned.  Otherwise, ‘bf_find_root’ is identical to ‘find_root’,
     and the following description is equally applicable to
     ‘bf_find_root’.

     The accuracy of ‘find_root’ is governed by ‘abserr’ and ‘relerr’,
     which are optional keyword arguments to ‘find_root’.  These keyword
     arguments take the form ‘key=val’.  The keyword arguments are

     ‘abserr’
          Desired absolute error of function value at root.  Default is
          ‘find_root_abs’.
     ‘relerr’
          Desired relative error of root.  Default is ‘find_root_rel’.

     ‘find_root’ stops when the function in question evaluates to
     something less than or equal to ‘abserr’, or if successive
     approximants <x_0>, <x_1> differ by no more than ‘relerr *
     max(abs(x_0), abs(x_1))’.  The default values of ‘find_root_abs’
     and ‘find_root_rel’ are both zero.

     ‘find_root’ expects the function in question to have a different
     sign at the endpoints of the search interval.  When the function
     evaluates to a number at both endpoints and these numbers have the
     same sign, the behavior of ‘find_root’ is governed by
     ‘find_root_error’.  When ‘find_root_error’ is ‘true’, ‘find_root’
     prints an error message.  Otherwise ‘find_root’ returns the value
     of ‘find_root_error’.  The default value of ‘find_root_error’ is
     ‘true’.

     If <f> evaluates to something other than a number at any step in
     the search algorithm, ‘find_root’ returns a partially-evaluated
     ‘find_root’ expression.

     The order of <a> and <b> is ignored; the region in which a root is
     sought is [min(<a>, <b>), max(<a>, <b>)].

     Examples:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981
          (%i6) find_root (exp(x) = y, x, 0, 100);
                                      x
          (%o6)           find_root(%e  = y, x, 0.0, 100.0)
          (%i7) find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o7)                   2.302585092994046
          (%i8) log (10.0);
          (%o8)                   2.302585092994046
          (%i9) fpprec:32;
          (%o9)                           32
          (%i10) bf_find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o10)                  2.3025850929940456840179914546844b0
          (%i11) log(10b0);
          (%o11)                  2.3025850929940456840179914546844b0

 -- Function: newton (<expr>, <x>, <x_0>, <eps>)

     Returns an approximate solution of ‘<expr> = 0’ by Newton’s method,
     considering <expr> to be a function of one variable, <x>.  The
     search begins with ‘<x> = <x_0>’ and proceeds until ‘abs(<expr>) <
     <eps>’ (with <expr> evaluated at the current value of <x>).

     ‘newton’ allows undefined variables to appear in <expr>, so long as
     the termination test ‘abs(<expr>) < <eps>’ evaluates to ‘true’ or
     ‘false’.  Thus it is not necessary that <expr> evaluate to a
     number.

     ‘load("newton1")’ loads this function.

     See also ‘realroots’, ‘allroots’, ‘find_root’ and ‘mnewton’.

     Examples:

          (%i1) load ("newton1");
          (%o1)  /maxima/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033529e-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958e-4 a


File: maxima.info,  Node: Introduction to numerical solution of differential equations,  Next: Functions for numerical solution of differential equations,  Prev: Functions for numerical solution of equations

21.5 Introduction to numerical solution of differential equations
=================================================================

The Ordinary Differential Equations (ODE) solved by the functions in
this section should have the form,
            dy
            -- = F(x,y)
            dx
   which is a first-order ODE. Higher order differential equations of
order <n> must be written as a system of <n> first-order equations of
that kind.  For instance, a second-order ODE should be written as a
system of two equations
            dx               dy
            -- = G(x,y,t)    -- = F(x,y,t)
            dt               dt

   The first argument in the functions will be a list with the
expressions on the right-side of the ODE’s.  The variables whose
derivatives are represented by those expressions should be given in a
second list.  In the case above those variables are <x> and <y>.  The
independent variable, <t> in the examples above, might be given in a
separated option.  If the expressions given do not depend on that
independent variable, the system is called autonomous.


File: maxima.info,  Node: Functions for numerical solution of differential equations,  Prev: Introduction to numerical solution of differential equations

21.6 Functions for numerical solution of differential equations
===============================================================

 -- Function: plotdf
          plotdf (<dydx>, options…)
          plotdf (<dvdu>, [<u>,<v>], options…)
          plotdf ([<dxdt>,c<dydt>], options…)
          plotdf ([<dudt>,c<dvdt>], [<u>,c<v>], options…)

     The function ‘plotdf’ creates a two-dimensional plot of the
     direction field (also called slope field) for a first-order
     Ordinary Differential Equation (ODE) or a system of two autonomous
     first-order ODE’s.

     Plotdf requires Xmaxima, even if its run from a Maxima session in a
     console, since the plot will be created by the Tk scripts in
     Xmaxima.  If Xmaxima is not installed plotdf will not work.

     <dydx>, <dxdt> and <dydt> are expressions that depend on <x> and
     <y>.  <dvdu>, <dudt> and <dvdt> are expressions that depend on <u>
     and <v>.  In addition to those two variables, the expressions can
     also depend on a set of parameters, with numerical values given
     with the ‘parameters’ option (the option syntax is given below), or
     with a range of allowed values specified by a <sliders> option.

     Several other options can be given within the command, or selected
     in the menu.  Integral curves can be obtained by clicking on the
     plot, or with the option ‘trajectory_at’.  The direction of the
     integration can be controlled with the ‘direction’ option, which
     can have values of _forward_, _backward_ or _both_.  The number of
     integration steps is given by ‘nsteps’; at each integration step
     the time increment will be adjusted automatically to produce
     displacements much smaller than the size of the plot window.  The
     numerical method used is 4th order Runge-Kutta with variable time
     steps.

     Plot window menu:

     The menu bar of the plot window has the following seven icons:

     An X. Can be used to close the plot window.

     A wrench and a screwdriver.  Opens the configuration menu with
     several fields that show the ODE(s) in use and various other
     settings.  If a pair of coordinates are entered in the field
     _Trajectory at_ and the <enter> key is pressed, a new integral
     curve will be shown, in addition to the ones already shown.

     Two arrows following a circle.  Replots the direction field with
     the new settings defined in the configuration menu and replots only
     the last integral curve that was previously plotted.

     Hard disk drive with an arrow.  Used to save a copy of the plot, in
     Postscript format, in the file specified in a field of the box that
     appears when that icon is clicked.

     Magnifying glass with a plus sign.  Zooms in the plot.

     Magnifying glass with a minus sign.  Zooms out the plot.  The plot
     can be displaced by holding down the right mouse button while the
     mouse is moved.

     Icon of a plot.  Opens another window with a plot of the two
     variables in terms of time, for the last integral curve that was
     plotted.

     Plot options:

     Options can also be given within the ‘plotdf’ itself, each one
     being a list of two or more elements.  The first element in each
     option is the name of the option, and the remainder is the value or
     values assigned to the option.

     The options which are recognized by ‘plotdf’ are the following:

        • "nsteps" defines the number of steps that will be used for the
          independent variable, to compute an integral curve.  The
          default value is 100.

        • "direction" defines the direction of the independent variable
          that will be followed to compute an integral curve.  Possible
          values are ‘forward’, to make the independent variable
          increase ‘nsteps’ times, with increments ‘tstep’, ‘backward’,
          to make the independent variable decrease, or ‘both’ that will
          lead to an integral curve that extends ‘nsteps’ forward, and
          ‘nsteps’ backward.  The keywords ‘right’ and ‘left’ can be
          used as synonyms for ‘forward’ and ‘backward’.  The default
          value is ‘both’.

        • "tinitial" defines the initial value of variable <t> used to
          compute integral curves.  Since the differential equations are
          autonomous, that setting will only appear in the plot of the
          curves as functions of <t>.  The default value is 0.

        • "versus_t" is used to create a second plot window, with a plot
          of an integral curve, as two functions <x>, <y>, of the
          independent variable <t>.  If ‘versus_t’ is given any value
          different from 0, the second plot window will be displayed.
          The second plot window includes another menu, similar to the
          menu of the main plot window.  The default value is 0.

        • "trajectory_at" defines the coordinates <xinitial> and
          <yinitial> for the starting point of an integral curve.  The
          option is empty by default.

        • "parameters" defines a list of parameters, and their numerical
          values, used in the definition of the differential equations.
          The name and values of the parameters must be given in a
          string with a comma-separated sequence of pairs ‘name=value’.

        • "sliders" defines a list of parameters that will be changed
          interactively using slider buttons, and the range of variation
          of those parameters.  The names and ranges of the parameters
          must be given in a string with a comma-separated sequence of
          elements ‘name=min:max’

        • "xfun" defines a string with semi-colon-separated sequence of
          functions of <x> to be displayed, on top of the direction
          field.  Those functions will be parsed by Tcl and not by
          Maxima.

        • "x" should be followed by two numbers, which will set up the
          minimum and maximum values shown on the horizontal axis.  If
          the variable on the horizontal axis is not <x>, then this
          option should have the name of the variable on the horizontal
          axis.  The default horizontal range is from -10 to 10.

        • "y" should be followed by two numbers, which will set up the
          minimum and maximum values shown on the vertical axis.  If the
          variable on the vertical axis is not <y>, then this option
          should have the name of the variable on the vertical axis.
          The default vertical range is from -10 to 10.

        • "xaxislabel" will be used to identify the horizontal axis.
          Its default value is the name of the first state variable.

        • "yaxislabel" will be used to identify the vertical axis.  Its
          default value is the name of the second state variable.

        • "number_of_arrows" should be set to a square number and
          defines the approximate density of the arrows being drawn.
          The default value is 225.

     *Examples:*

        • To show the direction field of the differential equation y' =
          exp(-x) + y and the solution that goes through (2, -0.1):
               (%i1) plotdf(exp(-x)+y,[trajectory_at,2,-0.1])$

        • To obtain the direction field for the equation diff(y,x) = x -
          y^2 and the solution with initial condition y(-1) = 3, we can
          use the command:
               (%i1) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                        [trajectory_at,-1,3], [direction,forward],
                        [y,-5,5], [x,-4,16])$

          The graph also shows the function y = sqrt(x).

        • The following example shows the direction field of a harmonic
          oscillator, defined by the two equations dz/dt = v and dv/dt =
          -k*z/m, and the integral curve through (z,v) = (6,0), with a
          slider that will allow you to change the value of m
          interactively (k is fixed at 2):
               (%i1) plotdf([v,-k*z/m], [z,v], [parameters,"m=2,k=2"],
                          [sliders,"m=1:5"], [trajectory_at,6,0])$

        • To plot the direction field of the Duffing equation,
          m*x''+c*x'+k*x+b*x^3 = 0, we introduce the variable y=x' and
          use:
               (%i1) plotdf([y,-(k*x + c*y + b*x^3)/m],
                            [parameters,"k=-1,m=1.0,c=0,b=1"],
                            [sliders,"k=-2:2,m=-1:1"],[tstep,0.1])$

        • The direction field for a damped pendulum, including the
          solution for the given initial conditions, with a slider that
          can be used to change the value of the mass m, and with a plot
          of the two state variables as a function of time:

               (%i1) plotdf([w,-g*sin(a)/l - b*w/m/l], [a,w],
                       [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                       [trajectory_at,1.05,-9],[tstep,0.01],
                       [a,-10,2], [w,-14,14], [direction,forward],
                       [nsteps,300], [sliders,"m=0.1:1"], [versus_t,1])$

 -- Function: ploteq (<exp>, ...options...)

     Plots equipotential curves for <exp>, which should be an expression
     depending on two variables.  The curves are obtained by integrating
     the differential equation that define the orthogonal trajectories
     to the solutions of the autonomous system obtained from the
     gradient of the expression given.  The plot can also show the
     integral curves for that gradient system (option fieldlines).

     This program also requires Xmaxima, even if its run from a Maxima
     session in a console, since the plot will be created by the Tk
     scripts in Xmaxima.  By default, the plot region will be empty
     until the user clicks in a point (or gives its coordinate with in
     the set-up menu or via the trajectory_at option).

     Most options accepted by plotdf can also be used for ploteq and the
     plot interface is the same that was described in plotdf.

     Example:

          (%i1) V: 900/((x+1)^2+y^2)^(1/2)-900/((x-1)^2+y^2)^(1/2)$
          (%i2) ploteq(V,[x,-2,2],[y,-2,2],[fieldlines,"blue"])$

     Clicking on a point will plot the equipotential curve that passes
     by that point (in red) and the orthogonal trajectory (in blue).

 -- Function: rk
          rk (<ODE>, <var>, <initial>, <domain>)
          rk ([<ODE1>, …, <ODEm>], [<v1>, …, <vm>], [<init1>, …,
          <initm>], <domain>)

     The first form solves numerically one first-order ordinary
     differential equation, and the second form solves a system of m of
     those equations, using the 4th order Runge-Kutta method.  <var>
     represents the dependent variable.  <ODE> must be an expression
     that depends only on the independent and dependent variables and
     defines the derivative of the dependent variable with respect to
     the independent variable.

     The independent variable is specified with ‘domain’, which must be
     a list of four elements as, for instance:
          [t, 0, 10, 0.1]
     the first element of the list identifies the independent variable,
     the second and third elements are the initial and final values for
     that variable, and the last element sets the increments that should
     be used within that interval.

     If <m> equations are going to be solved, there should be <m>
     dependent variables <v1>, <v2>, ..., <vm>.  The initial values for
     those variables will be <init1>, <init2>, ..., <initm>.  There will
     still be just one independent variable defined by ‘domain’, as in
     the previous case.  <ODE1>, ..., <ODEm> are the expressions that
     define the derivatives of each dependent variable in terms of the
     independent variable.  The only variables that may appear in those
     expressions are the independent variable and any of the dependent
     variables.  It is important to give the derivatives <ODE1>, ...,
     <ODEm> in the list in exactly the same order used for the dependent
     variables; for instance, the third element in the list will be
     interpreted as the derivative of the third dependent variable.

     The program will try to integrate the equations from the initial
     value of the independent variable until its last value, using
     constant increments.  If at some step one of the dependent
     variables takes an absolute value too large, the integration will
     be interrupted at that point.  The result will be a list with as
     many elements as the number of iterations made.  Each element in
     the results list is itself another list with <m>+1 elements: the
     value of the independent variable, followed by the values of the
     dependent variables corresponding to that point.

     See also ‘drawdf’, ‘desolve’ and ‘ode2’.

     Examples:

     To solve numerically the differential equation

                    dx/dt = t - x^2

     With initial value x(t=0) = 1, in the interval of t from 0 to 8 and
     with increments of 0.1 for t, use:

          (%i1) results: rk(t-x^2,x,1,[t,0,8,0.1])$
          (%i2) plot2d ([discrete, results])$

     the results will be saved in the list ‘results’ and the plot will
     show the solution obtained, with <t> on the horizontal axis and <x>
     on the vertical axis.

     To solve numerically the system:

                  dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

     for t between 0 and 4, and with values of -1.25 and 0.75 for x and
     y at t=0:

          (%i1) sol: rk([4-x^2-4*y^2, y^2-x^2+1], [x, y], [-1.25, 0.75],
                        [t, 0, 4, 0.02])$
          (%i2) plot2d([discrete, makelist([p[1], p[3]], p, sol)], [xlabel, "t"],
                       [ylabel, "y"])$

     The plot will show the solution for variable <y> as a function of
     <t>.


File: maxima.info,  Node: Массивы,  Next: Matrices and Linear Algebra,  Prev: Numerical,  Up: Top

22 Массивы
**********

* Menu:

* Функции и переменные для работы с массивами::  


File: maxima.info,  Node: Функции и переменные для работы с массивами,  Prev: Массивы,  Up: Массивы

22.1 Функции и переменные для работы с массивами
================================================

 -- Функция: array (<name>, <dim_1>, ..., <dim_n>)
 -- Функция: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Функция: array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)

     Создает n-мерный массив.  Значение n должно быть меньше или равно
     5.  i-й индекс может принимать целочисленное значение от 0 до
     <dim_i>.

     ‘array (<name>, <dim_1>, ..., <dim_n>)’ – создает массив общего
     вида.

     ‘array (<name>, <type>, <dim_1>, ..., <dim_n>)’ – создает массив,
     элементы которого имеют определенный тип.  <type> может быть
     ‘fixnum’ для целых чисел ограниченной точности и ‘flonum’ для чисел
     с плавающей точкой.

     ‘array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)’ –
     создает m массивов одинаковой размерности.

     Если пользователь присваивает значение переменной с индексом до
     того, как соответствующий массив объявлен, тогда создается
     необъявленный массив.  Необъявленные массивы, также известные как
     хеш-массивы (т.к.  для хранения элементов применяется хеширование),
     являются более общими чем объявленные массивы.  Пользователь не
     определяет их максимальный размер, и они растут динамически по мере
     присваивания значений их элементам.  Индексы необъявленных массивов
     даже не обязаны быть целочисленными.  Однако, за исключением случая
     когда массив сильно разряжен, объявленный массив, обычно, более
     эффективен чем необъявленный.  Функция ‘array’ может преобразовать
     необъявленный массив в объявленный.

 -- Функция: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Вычисляет значение ‘<A> [<i_1>, ..., <i_n>]’, где <A> – массив, а
     <i_1>, ..., <i_n> целые числа.

     Данная функция похожа на ‘apply’, только первый аргумент является
     массивом а не функцией.

 -- Функция: arrayinfo (<A>)
     Возвращает информацию о массиве <A>.  Аргумент <A> может быть
     объявленным массивом, необъявленным (хеш-) массивом,
     функцией-массивом или функцией с индексом.

     Для объявленного массива ‘arrayinfo’ возвращает список состоящий из
     атома ‘declared’, размерности массива и размера каждого из
     измерений.  Элементы массива, как имеющие значение, так и не
     имеющие значения, возвращаются функцией ‘listarray’.

     Для необъявленных массивов (хеш-массивов) ‘arrayinfo’ возвращает
     список состоящий из атома ‘hashed’, числа индексов и индексов всех
     элементов, которые имеют значение.  Значения массива возвращаются
     функцией ‘listarray’.

     Для функций-массивов ‘arrayinfo’ возвращает список состоящий из
     атома ‘hashed’, числа индексов и индексов всех элементов, которые
     содержат функциональные значения.  Функциональные значения
     возвращаются функцией ‘listarray’.

     Для функций с индексом ‘arrayinfo’ возвращает список состоящий из
     атома ‘hashed’, числа индексов и индексов всех элементов, которые
     содержат лямбда-выражения.  Лямбда-выражения возвращаются функцией
     ‘listarray’.

     Примеры:

     ‘arrayinfo’ и ‘listarray’ примененные к объявленному массиву.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     ‘arrayinfo’ и ‘listarray’ примененные к необъявленному (хеш)
     массиву.

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     ‘arrayinfo’ и ‘listarray’ примененные к функции-массиву.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     ‘arrayinfo’ и ‘listarray’ примененные к функции с индексом.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Функция: arraymake (<A>, [<i_1>, ..., <i_n>])
     Возвращает выражение ‘<A>[<i_1>, ..., <i_n>]’.  Этот результат
     является не вычисленной ссылкой на элемент массива.

     Функция ‘arraymake’ похожа на ‘funmake’, за исключеним того, что
     возвращает не вычисленный элемент массива вместо от не вычисленного
     вызова функции.

     Примеры:

          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9

 -- Системная переменная: arrays
     Значение по умолчанию: ‘[]’

     Список ‘arrays’ содержит всех существующих массивов.  Что
     составляет: массивы, объявленные при помощи ‘array’; хеш-массивы,
     созданные при помощи неявных определение (присваиванием чего-либо
     элементу массива); функции-массивы, определенные с помощью ‘:=’ и
     ‘define’.  Массивы, созданные при помощи ‘make_array’, в список не
     включаются.

     См.  также ‘array’, ‘arrayapply’, ‘arrayinfo’, ‘arraymake’,
     ‘fillarray’, ‘listarray’, and ‘rearray’.

     Примеры:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]

 -- Функция: bashindices (<expr>)
     Преобразует выражение <expr> присваивая каждому суммированию или
     произведению уникальный индекс.  Индекс имеет форму ‘j<number>’.
     Величина <number> определяется значением переменной ‘gensumnum’,
     которое может быть установлено пользователем.  Например
     ‘gensumnum:0$’, инициализирует эту переменную.

 -- Функция: fillarray (<A>, <B>)
     Заполняет массив <A> элементами из <B>, являющимся списком или
     массивом.

     Если для массива <A> в момент создания был задан тип элементов, то
     он может быть заполнен только элементами данного типа и попытка
     заполнения элементами другого типа является ошибкой.

     Если размерность массивов не совпадает, тогда <A> заполняется
     построчно.  Если число элементов <B> недостаточно, то последний
     элемент используется для заполнения остатка <A>.  Если число
     элементов <B> слишком велико, тогда излишние отбрасываются.

     ‘fillarray’ возвращает свой первый аргумент.

     Примеры:

     Создается массив из 9 элементов и заполняется из списка.

          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     Если недостаточно элементов для заполнения массива, то последний
     элемент повторяется.  Если элементов слишком много, то излишние
     элементы игнорируются.

          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     Многомерные массивы заполняются построчно.

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}

 -- Функция: listarray (<A>)
     Возвращает список элементов массива <A>.  Аргумент <A> должен быть
     объявленным массивом, необъявленным (хеш) массивом,
     функцией-массивом или функцией с индексами.

     Элементы помещаются в список построчно.  Т.е.  сначала помещаются
     элементы по первому индексу, затем по второму и т.д.  Порядок
     значений индексов тот же, что установлен при помощи ‘orderless’.

     Для необъявленных массивов, функций-массивов и функций с индексом,
     возвращаются элементы соответствующие индексам возвращаемым
     функцией ‘arrayinfo’.

     Для объявленных массивов общего типа (т.е не ‘fixnum’ или ‘flonum’)
     элементы не имеющие значения возвращаются как ‘#####’.  Не
     присвоенные элементы объявленных ‘fixnum’ или ‘flonum’ массивов
     возвращаются как 0 или 0.0 соответственно.  Не присвоенные элементы
     необъявленных массивов, функций-массивов и функций с индексом не
     возвращаются.

     Примеры:

     ‘listarray’ и ‘arrayinfo’ примененные к объявленному массиву.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     ‘arrayinfo’ и ‘listarray’ примененные к необъявленному (хеш)
     массиву.

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     ‘arrayinfo’ и ‘listarray’ примененные к функции-массиву.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     ‘arrayinfo’ и ‘listarray’ примененные к функции с индексом.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]

 -- Функция: make_array (<type>, <dim_1>, ..., <dim_n>)
     Создает и возвращает Lisp-массив.  <type> может быть ‘any’,
     ‘flonum’, ‘fixnum’, ‘hashed’ или ‘functional’.

     Массив имеет n индексов, i-й индекс может принимать значение от 0
     до <dim_i>-1.

     Преимущество ‘make_array’ по сравнению с ‘array’ состоит в том, что
     возвращаемый Lisp-массив не имеет имени.  И как только ссылка на
     него исчезает, занимаемое им место освобождается.  Например, если
     ‘y: make_array (...)’, тогда ‘y’ ссылается на объект (массив),
     занимающий место в памяти.  Но после присваивания ‘y: false’, ‘y’
     больше не ссылается на данный массив и занимаемое им место будет
     освобождено при сборке мусора.

     Примеры:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12

 -- Функция: rearray (<A>, <dim_1>, ..., <dim_n>)
     Изменяет размерность массива.  Новый массив будет заполнен
     элементами старого построчно.  Если исходный массив слишком мал,
     тогда остаток заполняется ‘false’, ‘0.0’ или ‘0’, в зависимости от
     типа массива.  Тип массива не может быть изменен.

 -- Функция: remarray (<A_1>, ..., <A_n>)
 -- Функция: remarray (all)
     Удаляет массив, все ассоциированные с ним функции и освобождает
     занимаемую им память.  Аргументы должны быть: объявленными
     массивами, необъявленными (хеш) массивами, функциями-массивами или
     функциями с индексом.

     ‘remarray (all)’ удаляет все элементы в глобальном списке ‘arrays’.

     Использование ‘remarray’ может требоваться если необходимо
     переопределить значения элементов необъявленного (хеш) массива.

     ‘remarray’ возвращает список удаленных массивов.

 -- Функция: subvar (<x>, <i>)
     Вычисляет выражение с индексом ‘<x>[<i>]’.

     ‘subvar’ вычисляет свои аргументы.

     ‘arraymake (<x>, [<i>]’ составляет выражение ‘<x>[<i>]’, но не
     вычисляет его.

     Примеры:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc

 -- Управляющая переменная: use_fast_arrays
     – если ‘true’, тогда используются только два типа массивов.

     1) Art-q массивы (t в Common Lisp), которые имеют несколько
     целочисленных индексов, и могут содержать любые Lisp или Maxima
     объекты.  Для создания таких массивов используется функция
     ‘make_array’.  Например ‘a:make_array(any,3,4);’.  Значение ‘a’ –
     массив из 12 элементов.  Отсчет индексов ведется с 0.

     2) Hash_table массивы, создающиеся по умолчанию если выполняется
     присваивания ‘b[x+1]:y^2’ если ‘b’ еще пока не является массивом,
     списком или матрицей (во всех этих случаях должна возникнуть ошибка
     т.к.  ‘x+1’ в общем случае не является допустимым индексом для
     art-q массива, списка или матрицы).  Индексом такого массива (также
     называется ключем) может быть произвольный объект.  Используется
     только один ключ одновременно, так в ‘b[x+1,u]:y’ игнорирует ‘u’ а
     соответствие устанавливается по ‘b[x+1] ==> y^2’.  Разумеется ключ
     может быть списком, например ‘b[[x+1,u]]:y’ вполне допустимо.  Это
     не совместимо со старыми хешируемыми массивами, но экономит память.

     Преимущество хранения массивов в значении переменной состоит в том,
     что в этом случае массивы следуют обычным соглашениям о локальных
     переменных.  Кроме того Hash_table массивы более эффективны и
     используют меньше памяти, чем старые хешируемые массивы.  Для
     одинакового поведения в интерпретируемом и компилируемом коде
     необходимо установить значение ‘translate_fast_arrays’ равным
     ‘true’.

