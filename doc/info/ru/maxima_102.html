<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Maxima Manual: Функции и переменные пакета itensor</title>

<meta name="description" content="Maxima Manual: Функции и переменные пакета itensor">
<meta name="keywords" content="Maxima Manual: Функции и переменные пакета itensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" rel="index" title="Указатель функций и переменных">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_100.html#g_t_041f_0430_043a_0435_0442-itensor" rel="up" title="Пакет itensor">
<link href="maxima_103.html#g_t_041f_0430_043a_0435_0442-ctensor" rel="next" title="Пакет ctensor">
<link href="maxima_101.html#g_t_0412_0432_0435_0434_0435_043d_0438_0435-_0432-_043f_0430_043a_0435_0442-itensor" rel="previous" title="Введение в пакет itensor">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="ru" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="g_t_0424_0443_043d_043a_0446_0438_0438-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_043f_0430_043a_0435_0442_0430-itensor"></a>
<div class="header">
<p>
Previous: <a href="maxima_101.html#g_t_0412_0432_0435_0434_0435_043d_0438_0435-_0432-_043f_0430_043a_0435_0442-itensor" accesskey="p" rel="previous">Введение в пакет itensor</a>, Up: <a href="maxima_100.html#g_t_041f_0430_043a_0435_0442-itensor" accesskey="u" rel="up">Пакет itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" title="Index" rel="index">Index</a>]</p>
</div>

<a name="Funkcii-i-peremennye-paketa-itensor"></a>
<h3 class="section">25.2 Функции и переменные пакета <code>itensor</code></h3>
<a name="Manipulirovanie-indeksnymi-obwektami"></a>
<h4 class="subsection">25.2.1 Манипулирование индексными объектами</h4>

<a name="Item_003a-Itensor_002fdeffn_002fentertensor"></a><dl>
<dt><a name="index-entertensor"></a>Функция: <strong>entertensor</strong> <em>(<var>name</var>)</em></dt>
<dd>
<p>это интерактивная функция, которая позволяет создать индексный объект с
именем <var>name</var>, содержащий заданные пользователем списки
ковариантных и контравариантных индексов и индексы производных.
Отдельный индекс или список индексов (возможно пустой) считаются
допустимым вводом (см. пример в секции <code>covdiff</code>).
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fchangename"></a><dl>
<dt><a name="index-changename"></a>Функция: <strong>changename</strong> <em>(<var>old</var>, <var>new</var>, <var>expr</var>)</em></dt>
<dd>
<p>заменяет имя тензора со старого <var>old</var> на новое <var>new</var>
в выражении <var>expr</var>. <var>old</var> может быть как простым символом,
так и списком в форме <code>[<var>name</var>, <var>m</var>, <var>n</var>]</code>.
В последнем случае переименовываются только индексные объекты
с именем <var>name</var> с <var>m</var> ковариантным и <var>n</var>
контравариантным индексами.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flistoftens"></a><dl>
<dt><a name="index-listoftens"></a>Функция: <strong>listoftens</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>в качестве результата возвращает список всех тензоров выражения
<var>expr</var>. Например,
</p>
<div class="example">
<pre class="example">
(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fishow"></a><dl>
<dt><a name="index-ishow"></a>Функция: <strong>ishow</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>печатает выражение <var>expr</var>, содержащее индексные объекты,
в виде, где ковариантные индексы изображены в нижней позиции,
а контравариантные в верхней.  Индексы производной изображаются после
ковариантных индексов и отделены запятой (примеры вывода данной
функции можно найти практически в любой части этого документа).
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002findices"></a><dl>
<dt><a name="index-indices"></a>Функция: <strong>indices</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Возвращает список из двух элементов.  Первый &ndash; список свободных
индексов, не участвующих в свертке, в  <var>expr</var>. Второй &ndash;
список немых индексов, участвующих в свертках.  Например,
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre></div>

<p>Тензорное произведение в котором один и тот же немой индекс
встречается более чем два раза является синтаксически
неправильным. При работе с ним Maxima выдаст ошибку.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002frename"></a><dl>
<dt><a name="index-rename"></a>Функция: <strong>rename</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-rename-1"></a>Функция: <strong>rename</strong> <em>(<var>expr</var>, <var>count</var>)</em></dt>
<dd>
<p>Возвращает выражение эквивалентное исходному <var>expr</var>, но в
котором все немые индексы переименованы и пронумерованы. Имена берутся из списка
<code>[%1, %2, ...]</code>. В качестве опции можно задать номер <var>count</var>
с которого начинается список пронумерованных индексов. По умолчанию
немые индексы нумеруются от текущей величины <var>count</var>. Все немые
индексы в произведении встречаются ровно 2 раза. В случае ошибки
пользователя, когда в исходном выражении одно и тоже имя немого индекса
встречается более двух раз, Maxima выдаст ошибку и остановит вычисления.
Для суммы тензорных произведений, <code>rename</code> применяется к каждому
члену суммы при этом счетчик <var>count</var> каждый раз обнуляется при переходе к следующему
слагаемому.  В этом случае функция <code>rename</code> может служить
для упрощения тензорных выражений.  Кроме того, если <code>allsym</code> равно
<code>true</code>, то индексы сортируются в алфавитном порядке.
Если значение <code>flipflag</code> равно <code>false</code>, то переименование
и сортировка осуществляется относительно порядка контравариантных индексов.
В случае если значение <code>flipflag</code> равно  <code>true</code> переименование и сортировка
производится относительно порядка ковариантных индексов. Часто
бывает, что комбинированный эффект двух применений  <code>rename</code> с
переменой значения флага  <code>flipflag</code> позволяет существенно
упростить исходное выражение. Например,
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

        %1 %2  %3 %4      %6         %5         %7        u
     - g      g      ichr2      ichr2      ichr2     ichr2
                          %1 %3      %2 %6      %4 r      %5 %7
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fflipflag"></a><dl>
<dt><a name="index-flipflag"></a>Управляющая переменная: <strong>flipflag</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если значение <code>flipflag</code> равно <code>false</code>, то сортировка и переименование индексов
осуществляется  относительно порядка контравариантных индексов, в
противном случае  &ndash; относительно порядка ковариантных индексов.
Значение флага  <code>flipflag</code> влияет на результат применения функции
<code>rename()</code> следующим образом: если  <code>flipflag</code> равно
<code>false</code> то <code>rename</code> формирует список немых индексов по списку контравариантных
индексов, по мере поступления, слева направо (если значение флага равно
<code>true</code>, тогда используется список ковариантных индексов). Первый
немой индекс в списке переименовывается в  <code>%1</code>, следующий в
<code>%2</code> и т.д.). Затем индексы сортируются (см. пример в  <code>rename()</code>).
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fdefcon"></a><dl>
<dt><a name="index-defcon"></a>Функция: <strong>defcon</strong> <em>(<var>tensor_1</var>)</em></dt>
<dt><a name="index-defcon-1"></a>Функция: <strong>defcon</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</em></dt>
<dd><p>задает свойства тензорной свертки тензора <var>tensor_1</var> с <var>tensor_3</var> так, что в
результате получается <var>tensor_3</var> с соответствующими индексами.
Если задан единственный аргумент, <var>tensor_1</var>, тогда свертка любого
другого тензора (скажем <code>my_tensor</code>) с  <var>tensor_1</var> дает тот
же тензор (<code>my_tensor</code>), но с новым набором индексов в
соответствии с операцией свертки.  В этом случае, <var>tensor_1</var>
может быть использован для подъема или опускания индексов.
</p>
<p>Например, пусть <code>imetric:g</code>, тогда путем <code>defcon(g)</code> можно
реализовать подъем и опускание индексов тензора, сворачивая его с метрическим тензором.
</p>
<p>Для одного и того же индексного объекта может быть задано более одного
правила свертки.  В этом случае, для одинаковых объектов
используется правило свертки заданное последним.
<code>contractions</code>  содержит список индексных объектов с заданными,
посредством <code>defcon</code>, правилами  свертки.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fremcon"></a><dl>
<dt><a name="index-remcon"></a>Функция: <strong>remcon</strong> <em>(<var>tensor_1</var> , ..., <var>tensor_n</var>)</em></dt>
<dd><p>удаляет все правила свертки для объектов <var>tensor_i</var>.
<code>remcon(all)</code> удаляет все правила свертки для всех
индексных объектов.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fcontract"></a><dl>
<dt><a name="index-contract"></a>Функция: <strong>contract</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Выполняет свертку тензорного выражения <var>expr</var>, которое само по себе может быть
произвольной комбинацией сумм и произведений тензоров. Правила свертки должны
быть предварительно заданы с помощью <code>defcon</code>.
Для наилучших результатов, в выражении <var>expr</var>, необходимо раскрыть
все скобки. Если коэффициенты при тензорах в <var>expr</var>
не содержат дробей, то  наиболее эффективный и быстрый способ
раскрытия скобок в <var>expr</var> состоит в применении функции
<code>ratexpand</code>. При этом, флаг <code>gcd</code> можно положить равным
<code>false</code>, чтобы программа не пыталась искать сокращение
множителей, используя GCD алгоритмы.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002findexed_005ftensor"></a><dl>
<dt><a name="index-indexed_005ftensor"></a>Функция: <strong>indexed_tensor</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>Данная операция необходима всяких раз, когда пользователь собирается
присвоить новые индексные выражения компонентам тензора
<var>tensor</var>, для которого в системе уже предусмотрено свое
индексное представление.  Примером могут служить символы Кристоффеля 1-го и 2-го рода
<code>ichr1</code>, <code>ichr2</code>, выраженные через компоненты метрики, или
тензор кривизны Римана <code>icurvature</code>. См. пример в
пункте <code>icurvature</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fcomponents"></a><dl>
<dt><a name="index-components"></a>Функция: <strong>components</strong> <em>(<var>tensor</var>, <var>expr</var>)</em></dt>
<dd>
<p>Данная функция присваивает тензору <var>tensor</var> индексное выражение
<var>expr</var>. Это приводит к тому, что при последующих вычислениях
индексные выражения <var>tensor</var> автоматически заменяются на
соответствующие <var>expr</var>. <var>tensor</var> должен иметь вид <code>t([...],[...])</code>,
где каждый из списков может быть пустым. <var>expr</var> может быть любым
индексным выражением имеющим тот же набор свободных индексов (не
участвующих в свертке), что и <var>tensor</var>. Если <var>expr</var> содержит
свертки, то необходимо быть внимательным в выборе значений немых
индексов, чтобы избежать повторных немых индексов. В
этом случае можно рекомендовать другой способ присваивания
компонент, заключающийся в использовании конструкций <code>defrule</code>
(см. пример ниже).  Функция <code>remcomps</code> очищает использованное
ранее определение компонент тензора.
</p>
<p>Важно понимать, что для <code>components</code> важна только валентность
тензора а не порядок индексов.  Присваивание значения
<code>x([i,-j],[])</code>, <code>x([-j,i],[])</code> или <code>x([i],[j])</code>
приводит к одному результату &ndash; значение присваивается
тензору с именем <code>x</code> и валентностью <code>(1,1)</code>.
</p>

<p>Любому индексному выражению можно присвоить любое другое индексное
представление и компоненты 4-мя различными способами, 2 способа
включают использование, рассмотренной выше функции  <code>components</code>:
</p>
<p>1) Присваивание одного индексного выражения другому:
</p>
<div class="example">
<pre class="example">
(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre></div>

<p>2) В виде матрицы компонент:
</p>
<div class="example">
<pre class="example">
(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([3,3],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

</pre></div>

<p>3) Путем определения функции. В примере ниже, тензор
<code>h</code> равен  <code>kdelta</code> если  <code>h</code> имеет одинаковое
количество ковариантных и контравариантных индексов, а индексы
производной отсутствуют. В любом другом случае, тензор <code>h</code>
равен тензору <code>g</code>:
</p>
<div class="example">
<pre class="example">
(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

</pre></div>

<p>4) Последний пример связан с использованием конструкций
типа <code>defrule</code>.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fremcomps"></a><dl>
<dt><a name="index-remcomps"></a>Функция: <strong>remcomps</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>Удаляет из системы значения компонент тензора
<code>tensor</code>, присвоенных при помощи функции <code>components</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fshowcomps"></a><dl>
<dt><a name="index-showcomps"></a>Функция: <strong>showcomps</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>Печатает значение компонент тензора, которые были присвоены с
помощью <code>components</code>.
Данная функция особенно полезна в случае, когда компоненты
тензора были заданы с помощью матрицы, как в данном примере:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(&quot;itensor&quot;);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

</pre></div>

<p>Функция <code>showcomps</code> может также печатать компоненты тензоров
ранга выше чем 2.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fidummy"></a><dl>
<dt><a name="index-idummy"></a>Функция: <strong>idummy</strong> <em>()</em></dt>
<dd>
<p>Увеличивает значение счетчика <code>icounter</code> немых индексов на 1 и возвращает
значение индекса в форме <code>%n</code>, где n это положительное целое число.
Применение <code>idummy</code> гарантирует, что немые индексы, встречающиеся в
текущем выражении? не будут конфликтовать с уже использованными
(см. пример в секции <code>indices</code>).
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fidummyx"></a><dl>
<dt><a name="index-idummyx"></a>Управляющая переменная: <strong>idummyx</strong></dt>
<dd><p>Значение по умолчанию: <code>%</code>
</p>
<p>Данная переменная задает приставку (префикс) для генерируемых немых индексов
(см. пример в секции <code>indices</code>).
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002ficounter"></a><dl>
<dt><a name="index-icounter"></a>Управляющая переменная: <strong>icounter</strong></dt>
<dd><p>Значение по умолчанию: <code>1</code>
</p>
<p>Определяет численный суффикс для генерируемого
немого индекса. Приставка (префикс) определяется
переменной <code>idummyx</code>
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fkdelta"></a><dl>
<dt><a name="index-kdelta"></a>Функция: <strong>kdelta</strong> <em>(<var>l1</var>, <var>l2</var>)</em></dt>
<dd><p>Обобщенный символ Кронекера, где  <var>l1</var> и <var>l2</var> &ndash; списки ковариантных и
контравариантных индексов соответственно. <code>kdelta([i],[j])</code> возвращает обычный
дельта-символ Кронекера. Команда <code>ev(<var>expr</var>,kdelta)</code> вычисляет <var>expr</var>, заменяя
все конструкции вида <code>kdelta([],[])</code> (след <code>kdelta</code>) на размерность многообразия.
</p>
<p><code>itensor</code> также позволяет использование в <code>kdelta()</code> c  двумя ковариантными или
двумя контравариантными индексами. Эта дает возможность задать единичную ко(нтра)-вариантную
матрицу. Данная конструкция предусмотрена только для целей программирования. Следует помнить,
что в <code>itensor</code>  <code>kdelta([i,j],[])</code> не является разрешенным тензорным объектом.
Будьте готовы,что при операциях с <code>kdelta([i,j],[])</code> Maxima может
пожаловаться на неправильный индексный объект и отказаться от дальнейших вычислений.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fkdels"></a><dl>
<dt><a name="index-kdels"></a>Функция: <strong>kdels</strong> <em>(<var>l1</var>, <var>l2</var>)</em></dt>
<dd>
<p>Симметризованная версия обобщенного дельта-символа Кронекера. Введена для удобства вычислений.
Свертка выражения с этим тензором приводит к его симметризации. Примеры:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flevi_005fcivita"></a><dl>
<dt><a name="index-levi_005fcivita"></a>Функция: <strong>levi_civita</strong> <em>(<var>l</var>)</em></dt>
<dd><p>Перестановочный тензор Леви-Чивита, который дает 1 если список <var>l</var>
является четной перестановкой целых чисел, -1 для нечетной
перестановки, и 0 когда встречаются повторяющиеся индексы.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002flc2kdt"></a><dl>
<dt><a name="index-lc2kdt"></a>Функция: <strong>lc2kdt</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Приводит к упрощению выражений содержащих символы Леви-Чивита (произведения этих символов
заменяются на соответствующие дельта-символы Кронекера). Основная разница между действием
данной функции и непосредственным вычислением перестановочного тензора состоит в том,
что прямое вычисление тензора Леви-Чивита часто приводит к выражениям
содержащим дельта-символы с  целочисленными значения индексов, что затрудняет
дальнейшие операции. Применение функции <code>lc2kdt</code> позволяет избежать этих проблем.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

</pre></div>

<p>Для использования <code>lc2kdt()</code> необходимо задать метрический тензор
(для случая когда, встречаются произведения перестановочных тензоров одинакового
ранга и типа).  Если метрика не была задана заранее (с помощью
<code>imetric</code>), то можно столкнуться с ошибкой.
</p>
<div class="example">
<pre class="example">
(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i      l i
(%t11)                           a    - a g

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002flc_005fl"></a><dl>
<dt><a name="index-lc_005fl"></a>Функция: <strong>lc_l</strong></dt>
<dd>
<p>Правило упрощения выражений содержащих индексные символы Леви-Чивита
(<code>levi_civita</code>). Данное правило преобразования использует свойства антисимметрии
перестановочного тензора. Например:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
(%t4)                                  0
(%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
(%t5)                                  0

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flc_005fu"></a><dl>
<dt><a name="index-lc_005fu"></a>Функция: <strong>lc_u</strong></dt>
<dd>
<p>Правило упрощения выражений содержащих индексные символы Леви-Чивита
(<code>levi_civita</code>), аналогично <code>lc_l</code>, данное правило преобразования
использует свойства антисимметрии перестановочного тензора
(см. пример в секции  <code>lc_l</code>).
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcanten"></a><dl>
<dt><a name="index-canten"></a>Функция: <strong>canten</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Функция предназначена для упрощения тензорных выражений путем переименования
и перестановки немых индексов. Область применения <code>canten</code> ограничена. Данная функция
применима только для сумм тензорных произведений в которых отсутствуют индексы производной
и не встречаются символы Леви-Чивита. Ввиду этих ограничений, следует избегать
ее использования. Вместо нее рекомендуется применять  <code>canform</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fconcan"></a><dl>
<dt><a name="index-concan"></a>Функция: <strong>concan</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Аналогична <code>canten</code> но дополнительно производит
свертку индексов.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Simmetrii-tenzorov"></a>
<h4 class="subsection">25.2.2 Симметрии тензоров</h4>

<a name="Item_003a-Itensor_002fdefvr_002fallsym"></a><dl>
<dt><a name="index-allsym"></a>Управляющая переменная: <strong>allsym</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если данной переменной присвоить  <code>true</code>, тогда все индексные
объекты будут считаться симметричными
по всем ковариантным и контравариантным индексам. Если <code>allsym</code> равно
<code>false</code>, все тензора не имеют никаких свойств симметрии априори,
пока симметрии не будут объявлены. Индексы производной предполагаются симметричными,
до тех пор пока не объявлено, что <code>iframe_flag</code> равен <code>true</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fdecsym"></a><dl>
<dt><a name="index-decsym"></a>Функция: <strong>decsym</strong> <em>(<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, ...], [<var>contr_1</var>, <var>contr_2</var>, ...])</em></dt>
<dd>
<p>Объявляет свойства симметрии тензора <var>tensor</var> по <var>m</var> ковариантному и
<var>n</var> контравариантным индексам, где <var>cov_i</var> и <var>contr_i</var> &ndash;
псевдофункции, выражающие соотношения перестановочных симметрий по ковариантным и
контравариантным индексам соответственно. Данные псевдофункции
записываются в форме <code>symoper(<var>index_1</var>, <var>index_2</var>, ...)</code>, где
переменная <code>symoper</code> принимает  одно из следующих: <code>sym</code>,
<code>anti</code> или <code>cyc</code>, которые означают соответственно, симметрию,
антисимметрию или цикличность индексов. Переменная
<var>index_i</var> принимает целочисленные значения и указывает на позицию
индекса в  <var>tensor</var>, для которого объявляются свойства симметрии.
Определения вида <code>symoper(all)</code> также дозволены, означая, что все
индексы удовлетворяют выбранному свойству симметрии.
Например, рассмотрим тензорный объект <code>b</code> с 5-ю ковариантными
индексами. Команда
 <code>decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code> объявляет <code>b</code>
симметричным по первому и второму индексу, антисимметричным по 3 и 4
ковариантным индексам и циклическим по всем контравариантным индексам.
Список декларирующий симметрии может быть пустым. Функция <code>canform</code>
использует декларированные свойства симметрии для упрощения тензорных
выражений. Примеры даны ниже.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract( expand( a([i1, j1, k1], [])
           *kdels([i, j, k], [i1, j1, k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fremsym"></a><dl>
<dt><a name="index-remsym"></a>Функция: <strong>remsym</strong> <em>(<var>tensor</var>, <var>m</var>, <var>n</var>)</em></dt>
<dd>
<p>Удаляет все свойства симметрии тензора <var>tensor</var>, имеющего <var>m</var>
ковариантных и <var>n</var> контравариантных индексов.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fcanform"></a><dl>
<dt><a name="index-canform"></a>Функция: <strong>canform</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-canform-1"></a>Функция: <strong>canform</strong> <em>(<var>expr</var>, <var>rename</var>)</em></dt>
<dd><p>Упрощает выражение <var>expr</var>, используя
переименование немых индексов и сортировку всех индексов с учетом
объявленных свойств симметрии. Если <code>allsym</code> равен <code>true</code>,
тогда все индексные выражения подразумеваются симметричными по всем
индексам. В противном случае используется свойства , объявленные при помощи <code>decsym</code>.
Немые индексы переименовываются таким же образом, как и при
использовании <code>rename</code>.
Следует иметь ввиду, что упрощение громоздких выражений может потребовать
значительного количества вычислительного времени и ресурсов
памяти. Иногда затраты на вычисления можно уменьшить если сначала
переименовать индексы при помощи <code>rename</code>.
См. примеры в пункте <code>decsym</code>. Заметим, что <code>canform</code> не
всегда приводит выражение к простейшей форме.
В тоже время <code>canform</code> всегда возвращает математически
корректный результат.
</p>
<p>Если значение второго необязательного параметра <var>rename</var> равно <code>false</code>, 
то переименование не производится.
</p>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Operacii-nad-indeksami-tenzorov"></a>
<h4 class="subsection">25.2.3 Операции над индексами тензоров</h4>


<a name="Item_003a-Itensor_002fdeffn_002fdiff"></a><dl>
<dt><a name="index-diff-1"></a>Функция: <strong>diff</strong> <em>(<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</em></dt>
<dd><p>Стандартная функция дифференцирования Maxima, которая в пакете <code>itensor</code> имеет
дополнительные свойства. Данная конструкция означает взятие
производной выражения <var>expr</var> по переменной <var>v_1</var>, <var>n_1</var>
раз, по <var>v_2</var>, <var>n_2</var>раз и т.д.
В применении к тензорным объектам, функция дифференцирования
модифицирована таким образом, что <code>v_i</code> может иметь целочисленные
значения от 1 до <code>dim</code>. В этом случае дифференцирование выполняется
по отношению к <code>v_i</code>-ому элементу списка <code>vect_coords</code>. Если
<code>vect_coords</code> является атомом, тогда переменная
индексированная именем <code>v_i</code> будет использована как переменная для
дифференцирования. Это допускает использование массива имен координат или индексированных
имен типа <code>x[1]</code>, <code>x[2]</code>, в качестве переменных
дифференцирования.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fidiff"></a><dl>
<dt><a name="index-idiff"></a>Функция: <strong>idiff</strong> <em>(<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</em></dt>
<dd><p>Индексное дифференцирование. В отличие от функции <code>diff</code>, которая
дифференцирует в отношении некоторой независимой переменной, <code>idiff</code> может
быть использован при дифференцировании по координате. Для индексного
объекта, такое дифференцирование добавляет <code>v_i</code> к индексам
производной (он добавляется последовательно к ковариантным индексам
после запятой). В дальнейшем индексы производной могут сортироваться
если переменная <code>iframe_flag</code> не равна <code>true</code>.
</p>
<p><code>idiff</code> можно использовать при дифференцировании детерминанта
метрического тензора. Таким образом, если метрика <code>imetric</code>
обозначена через <code>g</code>, тогда <code>idiff(determinant(g),k)</code> возвращает
<code>2*determinant(g)*ichr2([%i,k],[%i])</code>, где немой индекс <code>%i</code>
пробегает соответствующие значения.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fliediff"></a><dl>
<dt><a name="index-liediff"></a>Функция: <strong>liediff</strong> <em>(<var>v</var>, <var>tensor</var>)</em></dt>
<dd>
<p>Вычисляет производную Ли от тензорного выражения <var>tensor</var> в отношении
векторного поля <var>v</var>. <var>tensor</var> может быть произвольным тензорным
объектом, а <var>v</var> &ndash; имя векторного поля (без индексов). Например:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre></div>


<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>



<a name="Item_003a-Itensor_002fdeffn_002frediff"></a><dl>
<dt><a name="index-rediff"></a>Функция: <strong>rediff</strong> <em>(<var>ten</var>)</em></dt>
<dd>
<p>Вычисляет все команды <code>idiff</code> в выражении <var>ten</var>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fundiff"></a><dl>
<dt><a name="index-undiff"></a>Функция: <strong>undiff</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Возвращает выражение эквивалентное <var>expr</var>, но в котором все
производные индексных объектов заменяются на  не вычисляемую форму
функции <code>idiff</code> с такими аргументами, чтобы при дифференцировании
получился бы соответствующий индексный объект. Это бывает полезно, когда
желательно провести некоторые замены в продифференцированных индексных
объектах. После этого дифференцирование выполняется при помощи
<code>ev(<var>expr</var>, idiff)</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fevundiff"></a><dl>
<dt><a name="index-evundiff"></a>Функция: <strong>evundiff</strong></dt>
<dd>
<p>Эквивалентно применению <code>undiff</code>, затем <code>ev</code> и
<code>rediff</code>.
</p>
<p>При помощи этой функции можно легко вычислять выражения,
дифференциальную форму которых иначе
невозможно вычислить. Например, следующее выражение приводит к ошибке:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]: 
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre></div>

<p>Однако, если сначала ввести <code>icurvature</code> в не вычисляемой форме, а
затем применить <code>evundiff</code>, то получим желаемый результат:
</p>
<div class="example">
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
</pre></div>

<p>ЗАМЕЧАНИЕ: В ранних версиях Maxima, операции производных в определениях
символов Кристоффеля всегда должны были вводится в не вычисляемой
форме. Сейчас это исправлено и надобность в процедуре <code>evundiff</code>
в этом случае отпала. Например:
</p>
<div class="example">
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre></div>


<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fflush"></a><dl>
<dt><a name="index-flush"></a>Функция: <strong>flush</strong> <em>(<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd><p>Обнуляет в <var>expr</var> все объекты  <var>tensor_i</var>, не имеющие индексов
производной.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fflushd"></a><dl>
<dt><a name="index-flushd"></a>Функция: <strong>flushd</strong> <em>(<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd><p>Обнуляет в <var>expr</var> все объекты  <var>tensor_i</var>, имеющие индексы
производной.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflushnd"></a><dl>
<dt><a name="index-flushnd"></a>Функция: <strong>flushnd</strong> <em>(<var>expr</var>, <var>tensor</var>, <var>n</var>)</em></dt>
<dd><p>Обнуляет в <var>expr</var> все объекты  <var>tensor</var>, имеющие <var>n</var> и больше индексов
производной. Например,
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fcoord"></a><dl>
<dt><a name="index-coord"></a>Функция: <strong>coord</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd>
<p>Дает тензорам <var>tensor_i</var> свойства координатного дифференцирования,
такие что производная контравариантного вектора, имя которого  совпадает
с одним из <var>tensor_i</var>, дает дельта-символ Кронекера. Например, если
<code>coord(x)</code>, тогда  вычисление <code>idiff(x([],[i]),j)</code> дает <code>kdelta([i],[j])</code>.
<code>coord</code> это список всех индексных объектов имеющих это свойство.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcoord"></a><dl>
<dt><a name="index-remcoord"></a>Функция: <strong>remcoord</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd>
<p>Удаляет свойства координатного дифференцирования для объектов <var>tensor_i</var>.
<code>remcoord(all)</code> удаляет свойства координатного дифференцирования
для всех индексных объектов.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fmakebox"></a><dl>
<dt><a name="index-makebox"></a>Функция: <strong>makebox</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Служит для цели аналогичной <code>ishow</code>. В дополнение,
все  даламбертианы, встречающиеся в <var>expr</var> отображаются символом <code>[]</code>.
Например, <code>[]p([m],[n])</code> представляет сокращение для
<code>g([],[i,j])*p([m],[n],i,j)</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fconmetderiv"></a><dl>
<dt><a name="index-conmetderiv"></a>Функция: <strong>conmetderiv</strong> <em>(<var>expr</var>, <var>tensor</var>)</em></dt>
<dd><p>Используется для упрощения выражений, содержащих
частные производные ковариантных и контравариантных форм метрического
тензора.
Например, при помощи <code>conmetderiv</code> можно связать частные
производные  метрического тензора с символами Кристоффеля:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fsimpmetderiv"></a><dl>
<dt><a name="index-simpmetderiv"></a>Функция: <strong>simpmetderiv</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-simpmetderiv-1"></a>Функция: <strong>simpmetderiv</strong> <em>(<var>expr</var> [, <var>stop</var>])</em></dt>
<dd>
<p>Упрощает выражения, содержащие произведения производных метрического
тензора.  В частности <code>simpmetderiv</code> использует два тождества:
</p>
<div class="example">
<pre class="example">
   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre></div>

<p>откуда
</p>
<div class="example">
<pre class="example">
   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre></div>

<p>и
</p>
<div class="example">
<pre class="example">
  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre></div>

<p>которое следует из симметрии символов Кристоффеля.
</p>
<p>Функция <code>simpmetderiv</code> имеет один необязательный аргумент,
который, если присутствует, вызывает прекращение работы функции
сразу после первой успешной подстановки.
Функция <code>simpmetderiv</code> использует глобальную опцию
<var>flipflag</var>, которая определяет каким образом следует выбирать
&quot;канонический&quot; порядок индексов произведения.
</p>
<p>В целом, данные возможности позволяют осуществлять упрощения,
которые невозможно реализовать другими способами,
что демонстрируется в следующем примере:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre></div>

<p>См. также <code>weyl.dem</code>, для примера совместного применения <code>simpmetderiv</code>
и <code>conmetderiv</code> для упрощения тензора Вейля.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fflush1deriv"></a><dl>
<dt><a name="index-flush1deriv"></a>Функция: <strong>flush1deriv</strong> <em>(<var>expr</var>, <var>tensor</var>)</em></dt>
<dd>
<p>Обнуляет все производные первого порядка от <var>tensor</var> в <var>expr</var>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Tenzory-v-iskrivlennom-prostranstve"></a>
<h4 class="subsection">25.2.4 Тензоры в искривленном пространстве</h4>


<a name="Item_003a-Itensor_002fdeffn_002fimetric"></a><dl>
<dt><a name="index-imetric"></a>Функция: <strong>imetric</strong> <em>(<var>g</var>)</em></dt>
<dt><a name="index-imetric-1"></a>Системная переменная: <strong>imetric</strong></dt>
<dd>
<p>Определяет имя метрического тензора, присваивая соответствующее значение
переменной <code>imetric</code>, <code>imetric:<var>g</var></code>. В дополнение к этому программа
устанавливает соответствующие свойства свертки для данной метрики:
<code>defcon(<var>g</var>)</code>, <code>defcon(<var>g</var>,<var>g</var>,kdelta)</code>.
По умолчанию переменная <code>imetric</code> не имеет значения.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fichr1"></a><dl>
<dt><a name="index-ichr1"></a>Функция: <strong>ichr1</strong> <em>([<var>i</var>, <var>j</var>, <var>k</var>])</em></dt>
<dd><p>Дает значение символа Кристоффеля первого рода, которое по определению равно:
</p>
<div class="example">
<pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre></div>
<p>Перед тем как использовать явные выражения для символов Кристоффеля
необходимо определить имя метрического тензора, присвоив соответствующее
значение переменной <code>imetric</code>, см. пример ниже в разделе <code>covdiff</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fichr2"></a><dl>
<dt><a name="index-ichr2"></a>Функция: <strong>ichr2</strong> <em>([<var>i</var>, <var>j</var>],[<var>k</var>])</em></dt>
<dd><p>Дает значение символа Кристоффеля 2-го рода, которые по определению равны:
</p>
<div class="example">
<pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002ficurvature"></a><dl>
<dt><a name="index-icurvature"></a>Функция: <strong>icurvature</strong> <em>([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</em></dt>
<dd><p>Дает выражение для тензора кривизны Римана через символы Кристоффеля
2-го рода (<code>ichr2</code>).  Используется следующее определение:
</p><div class="example">
<pre class="example">            h             h            h         %1         h
  icurvature     = - ichr2      - ichr2     ichr2    + ichr2
            i j k         i k,j        %1 j      i k        i j,k
                            h          %1
                     + ichr2      ichr2
                            %1 k       i j
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fcovdiff"></a><dl>
<dt><a name="index-covdiff"></a>Функция: <strong>covdiff</strong> <em>(<var>expr</var>, <var>v_1</var>, <var>v_2</var>, ...)</em></dt>
<dd><p>Вычисляет ковариантную производную от <var>expr</var> по переменным
<var>v_i</var> используя символы Кристоффеля
2-го рода (<code>ichr2</code>).  Для получения явных выражений ковариантной
производной через компоненты метрики необходимо использовать
<code>ev(<var>expr</var>,ichr2)</code>, определив предварительно метрический тензор.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;

(%o4)                                  g
(%i5) ishow(ev(%t3,ichr2))$

         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002florentz_005fgauge"></a><dl>
<dt><a name="index-lorentz_005fgauge"></a>Функция: <strong>lorentz_gauge</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Налагает условие Лоренцевой калибровки на все индексные объекты в <var>expr</var>,
приравнивая к нулю те, в которых индекс производной совпадает с
одним из контравариантных индексов.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002figeodesic_005fcoords"></a><dl>
<dt><a name="index-igeodesic_005fcoords"></a>Функция: <strong>igeodesic_coords</strong> <em>(<var>expr</var>, <var>name</var>)</em></dt>
<dd>
<p>Позволяет пользователю обнулить не дифференцированные символы
Кристоффеля и первые производные метрического тензора в <var>expr</var> (подразумевая
&quot;нормальные&quot; координаты). Переменная <var>name</var> в
функции <code>igeodesic_coords</code> может относится, или к имени метрики (если таковая
присутствует в явном виде в <var>expr</var>), или к имени связности
в качестве которых используются фиксированные имена <code>ichr1</code> и (или)
<code>ichr2</code>. В следующем примере, при помощи
<code>igeodesic_coords</code>), проверяется свойство цикличности
тензора Римана.
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Vychisleniya-v-podvizhnom-bazise"></a>
<h4 class="subsection">25.2.5 Вычисления в подвижном базисе</h4>

<p>В Maxima существует возможность проводить вычисления с использованием
подвижных базисов в качестве которых можно выбирать, либо
ортонормированный  базис типа тетрады либо произвольный базис.
</p>
<p>Для использования подвижного базиса переменной <code>iframe_flag</code>
необходимо присвоить значение <code>true</code>. В этом случае символы
Кристоффеля  <code>ichr1</code> и <code>ichr2</code> заменяются более общими
коэффициентами связности <code>icc1</code> и <code>icc2</code> соответственно.
Выражения для  <code>covdiff</code> и <code>icurvature</code> также заменяются более
общими.
</p>
<p>Базис определяется двумя тензорами: полем дуального базиса (<code>ifri</code>),
и метрическим тензором <code>ifg</code>. Для ортонормированного базиса
метрический тензор совпадает с единичной матрицей или Лоренцевой
метрикой для пространства-времени Минковского. Дуальный базис
определяется базисом векторов (единичных). Явный вид дуального базиса и
его метрики не обязателен. По умолчанию все
вычисления проводятся в общем виде без использования явных выражений для
<code>ifri</code> и <code>ifg</code>.
</p>
<p>При <code>iframe_flag</code> равном <code>true</code>, во многих случаях для
опускания и подъема индексов вместо стандартной метрики <code>imetric</code>
используется метрика тетрады <code>ifg</code>.
</p>
<p>ВАЖНО: Присвоение <code>iframe_flag</code> значения <code>true</code> не отменяет
свойства свертки обычной метрики, определенные ранее командами
<code>defcon</code> или <code>imetric</code>. Если используется тетрадный
формализм, то определение стандартной метрики лучше всего ввести с
помощью присвоения соответствующего имени переменной
<code>imetric</code>. Команду <code>imetric</code> лучше НЕ использовать.
</p>
<p>Maxima использует  поле дуального базиса (<code>ifri</code>)
и метрический тензор <code>ifg</code> для определения структурных коэффициентов базиса (<code>ifc1</code>
и <code>ifc2</code>), которые в дальнейшем используются для вычисления
коэффициентов связности (<code>icc1</code>
и <code>icc2</code>), как показано в следующем примере:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                        %1      i           i        i
(%t4)                  v   (ifc2     + ichr2    ) + v
                                %1 j        %1 j     ,j
(%i5) ishow(ev(%,ifc2))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t5)      -------------------------------------------------- + v
                                   2                             ,j
(%i6) ishow(ifb([a,b,c]))$
                       %5    %4
(%t6)               ifr   ifr   (ifri        - ifri       )
                       a     b       c %4,%5       c %5,%4

</pre></div>

<p>Когда переменной <code>iframe_bracket_form</code> присвоено
<code>false</code>, то  используется альтернативный метод для вычисления
коммутатора тетрады (<code>ifb</code>).
</p>
<div class="example">
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                       %7    %6        %6      %7
(%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                       a     b,%7      a,%7    b       c %6

</pre></div>


<a name="Item_003a-Itensor_002fdeffn_002fiframes"></a><dl>
<dt><a name="index-iframes"></a>Функция: <strong>iframes</strong> <em>()</em></dt>
<dd>
<p>Поскольку в данной версии Maxima свойства свертки для <code>ifr</code> и
<code>ifri</code>, а также (<code>ifb</code>) определены всегда, то
данная функция не выполняет никаких действий.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifb"></a><dl>
<dt><a name="index-ifb"></a>Переменная: <strong>ifb</strong></dt>
<dd>
<p>Скобка тетрады (коммутатор). Вклад метрического тензора тетрады в
коэффициенты связности выражается через коммутатор тетрады.
</p>
<div class="example">
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre></div>

<p>Сам по себе коммутатор вычисляется через компоненты тетрады и
метрический тензор тетрады. В зависимости от значения
<code>frame_bracket_form</code> вычисление скобки тетрады дает разный
результат. При <code>frame_bracket_form</code> равном <code>true</code>
получим:
</p>
<div class="example">
<pre class="example">
          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre></div>

<p>А при <code>itorsion_flag</code> равном <code>true</code>:
</p>
<div class="example">
<pre class="example">             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002ficc1"></a><dl>
<dt><a name="index-icc1"></a>Переменная: <strong>icc1</strong></dt>
<dd>
<p>Коэффициенты связности первого рода. В <code>itensor</code>, определяется как:
</p>
<div class="example">
<pre class="example">
icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre></div>

<p>В этом выражении, если <code>iframe_flag</code> равно <code>true</code>, символы Кристоффеля
<code>ichr1</code> заменяются коэффициентами связности тетрады <code>ifc1</code>.
Если <code>itorsion_flag</code> равно <code>false</code>, то <code>ikt1</code>
опускается. <code>ikt1</code> опускается и в случае если используется базис
тетрады, так как кручение уже вычислено, как часть скобки тетрады.
Наконец, если <code>inonmet_flag</code> равен <code>false</code>, то
<code>inmc1</code>, также опускается при вычислениях.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002ficc2"></a><dl>
<dt><a name="index-icc2"></a>Переменная: <strong>icc2</strong></dt>
<dd>
<p>Коэффициенты связности второго рода. В <code>itensor</code>, определяются как,
</p>
<div class="example">
<pre class="example">
    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre></div>

<p>В этом выражении, если <code>iframe_flag</code> равно <code>true</code>, символы Кристоффеля
<code>ichr2</code> заменяются коэффициентами связности тетрады <code>ifc2</code>.
Если <code>itorsion_flag</code> равно <code>false</code>, то <code>ikt2</code>
опускается. <code>ikt2</code> опускается и в случае, если используется базис
тетрады, так как кручение уже вычислено, как часть скобки тетрады.
Наконец, если <code>inonmet_flag</code> равен <code>false</code>, то
<code>inmc2</code>, также опускается при вычислениях.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifc1"></a><dl>
<dt><a name="index-ifc1"></a>Переменная: <strong>ifc1</strong></dt>
<dd>
<p>Структурные коэффициенты 1-го рода, известные, также, как коэффициенты
вращения Риччи. Этот тензор выражает  вклад метрики тетрады в
коэффициенты связности 1-го рода.  Определяется как:
</p>
<div class="example">
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifc2"></a><dl>
<dt><a name="index-ifc2"></a>Переменная: <strong>ifc2</strong></dt>
<dd>
<p>Структурные коэффициенты 2-го рода. Получаются сверткой структурных
коэффициентов 1-го рода и метрики тетрады:
</p>
<div class="example">
<pre class="example">
    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifr"></a><dl>
<dt><a name="index-ifr"></a>Переменная: <strong>ifr</strong></dt>
<dd>
<p>Базис тетрады. Произведение с дуальным базисом (<code>ifri</code>) дает
метрику тетрады.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifri"></a><dl>
<dt><a name="index-ifri"></a>Переменная: <strong>ifri</strong></dt>
<dd>
<p>Дуальный базис тетрады. Определяется набором векторов.
Вместе с тензором тетрадной метрики <code>ifg</code> образует основу тетрадного
формализма реализованного в <code>itensor</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifg"></a><dl>
<dt><a name="index-ifg"></a>Переменная: <strong>ifg</strong></dt>
<dd>
<p>Тензор тетрадной метрики. По умолчанию равен <code>kdelta</code>. Пользователь может
определить свой, используя <code>components</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fifgi"></a><dl>
<dt><a name="index-ifgi"></a>Переменная: <strong>ifgi</strong></dt>
<dd>
<p>Обратная тетрадная метрика. Свертка с <code>ifg</code> дает  <code>kdelta</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fiframe_005fbracket_005fform"></a><dl>
<dt><a name="index-iframe_005fbracket_005fform"></a>Управляющая переменная: <strong>iframe_bracket_form</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Определяет метод вычисления скобки тетрады <code>ifb</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Kruchenie-i-nemetrichnostx"></a>
<h4 class="subsection">25.2.6 Кручение и неметричность</h4>

<p>Maxima умеет учитывать кручение и неметричность. Вклад кручения в
коэффициенты связности вычисляется, если <code>itorsion_flag</code> равен
<code>true</code>. Аналогично, компоненты  неметричности будут учтены, если
<code>inonmet_flag</code> равен <code>true</code>.
</p>

<a name="Item_003a-Itensor_002fdefvr_002finm"></a><dl>
<dt><a name="index-inm"></a>Переменная: <strong>inm</strong></dt>
<dd>
<p>Вектор неметричности.  Конформная неметричность определяется через
ковариантную производную метрического тензора, которая в обычном случае
равна нулю. Если <code>inonmet_flag</code> равен <code>true</code>, то вычисление
ковариантной производной метрики дает:
</p>
<div class="example">
<pre class="example">
g     =- g  inm
 ij;k     ij   k

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002finmc1"></a><dl>
<dt><a name="index-inmc1"></a>Переменная: <strong>inmc1</strong></dt>
<dd>
<p>Ковариантная перестановка компонент вектора неметричности. Определяется путем:
</p>
<div class="example">
<pre class="example">
           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre></div>

<p>В тетрадном формализме вместо <code>g</code> используется <code>ifg</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002finmc2"></a><dl>
<dt><a name="index-inmc2"></a>Переменная: <strong>inmc2</strong></dt>
<dd>
<p>Контравариантная перестановка компонент вектора
неметричности. Применяется когда <code>inonmet_flag</code> равен <code>true</code>.
Определяется путем:
</p>

<div class="example">
<pre class="example">
                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre></div>

<p>В тетрадном формализме вместо <code>g</code> используется <code>ifg</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fikt1"></a><dl>
<dt><a name="index-ikt1"></a>Переменная: <strong>ikt1</strong></dt>
<dd>
<p>Ковариантная перестановка тензора кручения.
Вычисляется посредством:
</p>
<div class="example">
<pre class="example">
                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre></div>

<p>В тетрадном формализме вместо <code>g</code> используется <code>ifg</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fikt2"></a><dl>
<dt><a name="index-ikt2"></a>Переменная: <strong>ikt2</strong></dt>
<dd>
<p>Контравариантная перестановка тензора кручения.
Вычисляется посредством:
</p>
<div class="example">
<pre class="example">
    c     cd
ikt2   = g   ikt1
    ab           abd

</pre></div>

<p>В тетрадном формализме вместо <code>g</code> используется <code>ifg</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002fitr"></a><dl>
<dt><a name="index-itr"></a>Переменная: <strong>itr</strong></dt>
<dd>
<p>Тензор кручения. Для метрики с кручением индексы ковариантной
производной не коммутируют. Пример:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>

<a name="Vneshnyaya-algebra"></a>
<h4 class="subsection">25.2.7 Внешняя алгебра</h4>

<p>В <code>itensor</code> реализованы возможности для операций с полностью
антисимметричными ковариантными тензорными объектами (внешние формы).
Полностью антисимметричное тензорное поле ранга
(0,L) соответствует внешней (дифференциальной) L-форме. Грассманова
алгебра L-форм включает операции внешнего (косого) произведения.
</p>
<p>Операция внешнего произведения не имеет общепринятого определения.
Некоторые авторы определяют внешнее произведение способом, который
соответствует операции антисимметризации. Например,
</p>
<div class="example">
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre></div>

<p>В более общем случае, внешнее произведение p-формы и q-формы можно
определить путем:
</p>
<div class="example">
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>где <code>D</code> обозначает дельта-символ Кронекера.
</p>
<p>Другие авторы предпочитают  &quot;геометрическое&quot; определение,
соответствующее понятию элемента объема:
</p>
<div class="example">
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre></div>

<p>В более общем случае имеем:
</p>
<div class="example">
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>С алгебраической точки зрения первое определение выглядит
более естественным для <code>itensor</code>. С другой стороны, во многих приложения
более принято следовать &quot;геометрическому&quot; определению. У пользователя
есть выбор &ndash; какое из двух определений использовать.  При
<code>igeowedge_flag</code> равном <code>false</code> (по умолчанию), используется
антисимметризация.  В противном случае применяется &quot;геометрическое&quot; определение.
</p>

<a name="Item_003a-Itensor_002fdefvr_002f_007e"></a><dl>
<dt><a name="index-_007e"></a>Оператор: <strong>~</strong></dt>
<dd>
<p>Обозначает операцию внешнего произведения. Это бинарная операция.
В качестве аргументов можно использовать выражения, включающие
скаляры, ковариантные тензоры 1-го ранга или антисимметричные
ковариантные тензоры ранга  <code>l</code> (предварительно объявленные, как
антисимметричные по всем ковариантным индексам).
</p>
<p>Результат внешнего произведения контролируется флагом
<code>igeowedge_flag</code>. Например:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;<a href="maxima_263.html#Category_003a-_041e_043f_0435_0440_0430_0442_043e_0440_044b">Операторы</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002f_007c"></a><dl>
<dt><a name="index-_007c"></a>Оператор: <strong>|</strong></dt>
<dd>
<p>Бинарная операция, обозначающая &quot;внутреннее&quot; произведение &ndash; свертку с
контравариантным вектором. При этой операции
результат не зависит от векторных индексов, участвующих в
свертке. Поэтому вектор можно задать только именем.
</p>
<p>В пакете <code>itensor</code>, &quot;внутренняя&quot; свертка с вектором всегда выполняется по
первому (в отношении алфавитного порядка) индексу. Это позволяет
проводить  более эффективные упрощения выражений, включающих
&quot;внутренние&quot; свертки. Например:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre></div>

<p>Заметим, что &quot;внутренняя&quot; свертка определена только для  полностью
антисимметричных объектов. В противном случае результат вычисления будет неправильным.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;<a href="maxima_263.html#Category_003a-_041e_043f_0435_0440_0430_0442_043e_0440_044b">Операторы</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fextdiff"></a><dl>
<dt><a name="index-extdiff"></a>Функция: <strong>extdiff</strong> <em>(<var>expr</var>, <var>ind</var>)</em></dt>
<dd>
<p>Внешнее дифференцирование <var>expr</var> по индексу <var>ind</var>.
В <code>itensor</code> оператор внешней производной определен как внешнее
произведение оператора производной и формы. Таким образом, результат
вычисления, также зависит от значения флага <code>igeowedge_flag</code>.
Например:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                      a      - a      + a
                            j k,i    i k,j    i j,k
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fhodge"></a><dl>
<dt><a name="index-hodge"></a>Функция: <strong>hodge</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Вычисляет форму дуальную <var>expr</var>. Например:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002figeowedge_005fflag"></a><dl>
<dt><a name="index-igeowedge_005fflag"></a>Переменная: <strong>igeowedge_flag</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Контролирует результат вычисления внешнего произведения или внешней
производной. При <code>igeowedge_flag</code> равном <code>false</code> (по
умолчанию), понятие  внешней (дифференциальной) формы соответствует
полностью антисимметричному ковариантному тензорному полю.
В противном случае внешняя форма будет согласована с понятием элемента объема.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;</div></dd></dl>


<a name="Eksport-v-TeX"></a>
<h4 class="subsection">25.2.8 Экспорт в TeX</h4>

<p>В <code>itensor</code> имеется некоторая поддержка экспорта тензорных выражений в
формат TeX. Поскольку на базовом уровне Maxima тензорные выражения
представлены как вызов некоторых функций, то вызов команды,
<code>tex()</code> не даст желаемого результата. Для экспорта тензорных
выражений в TeX можно использовать команду <code>tentex</code>.
</p>
<a name="Item_003a-Itensor_002fdeffn_002ftentex"></a><dl>
<dt><a name="index-tentex"></a>Функция: <strong>tentex</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>Команда экспорта тензорных
выражений в TeX. Перед использованием необходимо загрузить необходимый
подпакет, <code>load(&quot;tentex&quot;)</code>. Например:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(&quot;tentex&quot;);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

</pre></div>

<p>Заметим, что данном примере <code>idummyx</code> равен <code>m</code>, для того
чтобы избежать символов % в TeX-овских выражениях.
</p>
<p>ЗАМЕЧАНИЕ: Текущая версия <code>tentex</code> является экспериментальной.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;<a href="maxima_263.html#Category_003a-_0412_044b_0432_043e_0434-_0432-_0444_043e_0440_043c_0430_0442_0435-TeX">Вывод в формате TeX</a>
&middot;</div></dd></dl>

<a name="Vzaimodeistvie-s-paketom-ctensor"></a>
<h4 class="subsection">25.2.9 Взаимодействие с пакетом <code>ctensor</code></h4>

<p>В пакет <code>itensor</code> заложены возможности для генерации кода Maxima
 для компонент тензорных выражений для последующего использования в
 <code>ctensor</code>. Эта задача выполняется вызовом команды <code>ic_convert()</code>.
</p>

<a name="Item_003a-Itensor_002fdeffn_002fic_005fconvert"></a><dl>
<dt><a name="index-ic_005fconvert"></a>Функция: <strong>ic_convert</strong> <em>(<var>eqn</var>)</em></dt>
<dd>
<p>Конвертирует тензорное выражение <var>eqn</var> из формата <code>itensor</code> в
компоненты для использования в <code>ctensor</code>. При этом суммирование по немым
индексам выполняется в явном виде, используя соответствующие замены
индексных объектов в массивы; индексы производной заменяются
не вычисляемую форму <code>diff</code>; символы Кристоффеля <code>ichr1</code> и <code>ichr2</code>
заменяются на <code>lcs</code> и <code>mcs</code>, соответственно и если флаг
<code>metricconvert</code> равен <code>true</code>, тогда ковариантные
(контравариантные) выражения для метрического тензора везде
заменяется на  <code>lg</code> (или <code>ug</code>). Кроме того, для суммирования по
всем немым индексам вводится <code>do</code>. Полученное выражение можно
вычислить  (загрузив предварительно пакет <code>ctensor</code>), используя
<code>ev</code>.  Пример:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-itensor">Пакет itensor</a>
&middot;<a href="maxima_263.html#Category_003a-_041f_0430_043a_0435_0442-ctensor">Пакет ctensor</a>
&middot;</div></dd></dl>

<a name="Zarezervirovannye-imena-peremennykh"></a>
<h4 class="subsection">25.2.10 Зарезервированные имена переменных</h4>

<p>Следующие имена переменных зарезервированы для использования
в пакете <code>itensor</code>. Следует избегать их переопределения.
</p>
<div class="example">
<pre class="example">
  Имя        Комментарий
  ------------------------------------------
  indices2() Внутренняя версия indices()
  conti      Список контравариантных индексов
  covi       Список ковариантных индексов
  deri       Список индексов производной
  name       Возвращает имя индексного объекта
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc

</pre></div>

<a name="Zamechaniya-razrabotchika"></a>
<h4 class="subsection">25.2.11 Замечания разработчика</h4>

<p>Я (Viktor Toth) добавил поддержку тетрадного формализма,
кручения и неметричности в <code>itensor</code>
в ноябре, 2004.  Эти возможности были реконструированы на основе описаний
данных в руководстве коммерческой версии Macsyma, а также с
использованием результатов исполнения демонстрационных файлов Macsyma.
</p>
<p>Данная функциональность должна рассматриваться как
экспериментальная. Следует учесть, что доступная документация  Macsyma содержала
несколько очевидных ошибок, например, неправильные комбинации
индексов. Кроме того, результаты демонстрационных расчетов
показали, что функциональность  тетрадного формализма  в Macsyma
далеко не полна. Моей цель состоит не в том, чтобы механически воспроизвести все
возможности Macsyma, включая ошибки, а в том, чтобы в итоге получить
математически корректную поддержку данных видов вычислений в <code>itensor</code>.
Выполнение этой задачи займет некоторое время.
</p>

<hr>
<div class="header">
<p>
Previous: <a href="maxima_101.html#g_t_0412_0432_0435_0434_0435_043d_0438_0435-_0432-_043f_0430_043a_0435_0442-itensor" accesskey="p" rel="previous">Введение в пакет itensor</a>, Up: <a href="maxima_100.html#g_t_041f_0430_043a_0435_0442-itensor" accesskey="u" rel="up">Пакет itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
