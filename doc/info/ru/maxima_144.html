<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Maxima Manual: Функции и переменные для определения функций</title>

<meta name="description" content="Maxima Manual: Функции и переменные для определения функций">
<meta name="keywords" content="Maxima Manual: Функции и переменные для определения функций">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" rel="index" title="Указатель функций и переменных">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_140.html#g_t_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439" rel="up" title="Определение функций">
<link href="maxima_145.html#g_t_041f_0440_043e_0433_0440_0430_043c_043c_044b-Maxima" rel="next" title="Программы Maxima">
<link href="maxima_143.html#g_t_041c_0430_043a_0440_043e_0441_044b" rel="previous" title="Макросы">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="ru" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="g_t_0424_0443_043d_043a_0446_0438_0438-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0434_043b_044f-_043e_043f_0440_0435_0434_0435_043b_0435_043d_0438_044f-_0444_0443_043d_043a_0446_0438_0439"></a>
<div class="header">
<p>
Previous: <a href="maxima_143.html#g_t_041c_0430_043a_0440_043e_0441_044b" accesskey="p" rel="previous">Макросы</a>, Up: <a href="maxima_140.html#g_t_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439" accesskey="u" rel="up">Определение функций</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Funkcii-i-peremennye-dlya-opredeleniya-funkcii"></a>
<h3 class="section">37.4 Функции и переменные для определения функций</h3>

<a name="Item_003a-Function_002fdeffn_002fapply"></a><dl>
<dt><a name="index-apply"></a>Функция: <strong>apply</strong> <em>(<var>F</var>, [<var>x_1</var>, ..., <var>x_n</var>])</em></dt>
<dd><p>Составляет и вычисляет выражение <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
</p>
<p>Функция <code>apply</code> не пытается различить функцию-массив и обычную функцию, и
если <var>F</var> есть имя функции-массива, то <code>apply</code> вычисляет <code><var>F</var>(...)</code>
(т.е. обычный вызов функции с круглыми а не с квадратными скобками).
Функция <code>arrayapply</code> вычисляет вызов функции с квадратными скобками.
</p>
<p>Примеры:
</p>
<p>Функция <code>apply</code> вычисляет свои аргументы.
В этом примере, <code>min</code> применяется к значению <code>L</code>.
</p>
<div class="example">
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre></div>

<p>Функция <code>apply</code> вычисляет свои аргументы даже если функция <var>F</var> не вычисляет их.
</p>
<div class="example">
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
</pre></div>

<p>Функция <code>apply</code> вычисляет имя функции <var>F</var>.
Одиночная кавычка <code>'</code> блокирует это вычисление.
<code>demoivre</code> является именем глобальной переменной и, одновременно, именем функции.
</p>
<div class="example">
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0438_043c_0435_043d_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Применение функций</a>
&middot;</div>
</dd></dl>


<a name="Item_003a-Function_002fdeffn_002fblock"></a><dl>
<dt><a name="index-block"></a>Функция: <strong>block</strong> <em>([<var>v_1</var>, ..., <var>v_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-block-1"></a>Функция: <strong>block</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Функция <code>block</code> последовательно вычисляет <var>expr_1</var>, ..., <var>expr_n</var> 
и возвращает значение последнего вычисленного выражения.
Последовательность вычисления может быть изменена при помощи функций <code>go</code>, <code>throw</code> и <code>return</code>.
Последнее выражение <var>expr_n</var> вычисляется если не используется <code>return</code> или вычисляется выражение,
содержащие <code>throw</code>.
Некоторые переменные <var>v_1</var>, ..., <var>v_m</var> могут быть объявлены локальными в блоке, и они
отличаются от глобальных переменных с теми же именами.
Если не требуется определять локальные переменные, то список может быть опущен.
Внутри блока, все другие переменные, отличные от <var>v_1</var>, ..., <var>v_m</var>,
являются глобальными.
</p>
<p><code>block</code> сохраняет текущие значения переменных <var>v_1</var>, ..., <var>v_m</var> (если таковые существуют)
при входе в блок, и затем удаляет их значения, так чтобы эти переменные вычислялись сами в себя.
Локальные переменные могут принимать любые значения внутри блока, но пр выходе из него
сохраненные значения восстанавливаются, а локальные в блоке значения теряются.
</p>
<p>Блок может существовать внутри другого блока.
Локальные переменные определяются всякий раз как вычисляется новый <code>block</code>.
Локальные переменные объемлющего блока выглядят как глобальные для внутреннего блока.
Если переменная не локальна в блоке, то ее значение равно последнему, присвоенному 
в объемлющем блоке, если таковое существует, и значению переменной
в глобальном окружении в противном случае.
Эта политика совпадает с обычным понятием &quot;динамической области определения&quot;.
</p>
<p>Если необходимо сохранять и восстанавливать другие локальные свойства, кроме <code>value</code>, 
такие как <code>array</code> (кроме полных массивов),
<code>function</code>, <code>dependencies</code>, <code>atvalue</code>, <code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code> и 
<code>nonscalar</code>, то следует использовать функцию <code>local</code> внутри блока с именем функции в
качестве параметра.
</p>
<p>Значением блока является значение последнего выражения или значение аргумента функции 
<code>return</code>, которая может быть использована для явного выхода из блока.
Функция <code>go</code> используется для передачи управления на команду блока, помеченную аргументом <code>go</code>.  
Для того, чтобы пометить команду нужно поместить перед ней метку в виде атома.  Например:
<code>block ([x], x:1, loop, x: x+1, ..., go(loop), ...)</code>.  Аргументом <code>go</code> должна быть
метка, определенная в текущем блоке.  Невозможно использовать <code>go</code> для
передачи управления в блок отличный от того, в котором находится вызов <code>go</code>.
</p>
<p>Блоки обычно применяются в правых частях определения функций, но могут быть
использованы и в других местах.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0412_044b_0440_0430_0436_0435_043d_0438_044f">Выражения</a>
&middot;<a href="maxima_263.html#Category_003a-_041f_0440_043e_0433_0440_0430_043c_043c_0438_0440_043e_0432_0430_043d_0438_0435">Программирование</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fbreak"></a><dl>
<dt><a name="index-break"></a>Функция: <strong>break</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Вычисляет и печатает выражения <var>expr_1</var>, ..., <var>expr_n</var> и затем 
вызывает прерывание Maxima с тем, чтобы пользователь мог исследовать и изменить
окружение.  Ввод <code>exit;</code> возобновляет вычисление.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_0442_043b_0430_0434_043a_0430">Отладка</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fcatch"></a><dl>
<dt><a name="index-catch"></a>Функция: <strong>catch</strong> <em>(<var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Вычисляет <var>expr_1</var>, ..., <var>expr_n</var> одно за другими и, если одно из них
приводит к вычислению выражения <code>throw (arg)</code>, то значением <code>catch</code> 
становится значение аргумента <code>throw (arg)</code>, и дальнейшее вычисление не производится.
Такой &quot;нелокальный возврат&quot; осуществляется из любого уровня вложенности до первого
объемлющего <code>catch</code>.
Если нет объемлющего <code>catch</code>, то <code>throw</code> вызывает ошибку.
</p>
<p>Если вычисление аргументов не приводит к вычислению <code>throw</code>,
то значение <code>catch</code> равно значению <var>expr_n</var>.
</p>
<div class="example">
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre></div>

<p>Здесь, если список <code>l</code> содержит только неотрицательные числа, то функция <code>g</code> возвращает 
список функций <code>f</code>, примененных к элементам <code>l</code>, иначе, <code>g</code> &quot;ловит&quot; первое
отрицательное число в <code>l</code> и &quot;бросает&quot; его вверх.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_043e_0433_0440_0430_043c_043c_0438_0440_043e_0432_0430_043d_0438_0435">Программирование</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fcompfile"></a><dl>
<dt><a name="index-compfile"></a>Функция: <strong>compfile</strong> <em>(<var>filename</var>, <var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-compfile-1"></a>Функция: <strong>compfile</strong> <em>(<var>filename</var>, functions)</em></dt>
<dt><a name="index-compfile-2"></a>Функция: <strong>compfile</strong> <em>(<var>filename</var>, all)</em></dt>
<dd>
<p>Транслирует функции Maxima в Lisp 
и записывает полученный код в файл <var>filename</var>.
</p>
<p>Вызов <code>compfile(<var>filename</var>, <var>f_1</var>, ..., <var>f_n</var>)</code> транслирует только
заданные функции.
Вызов <code>compfile(<var>filename</var>, functions)</code> или вызов <code>compfile(<var>filename</var>, all)</code>
транслирует все определенные пользователем функции.
</p>
<p>Код Lisp не вычисляется, а результирующий файл не обрабатывается компилятором Lisp.
Функция <code>translate</code> создает и вычисляет Lisp код.
Функция <code>compile_file</code> транслирует код Maxima в Lisp, и затем выполняет компилятор Lisp. 
</p>
<p>См. также <code>translate</code>, <code>translate_file</code> и <code>compile_file</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>


<a name="Item_003a-Function_002fdeffn_002fcompile"></a><dl>
<dt><a name="index-compile"></a>Функция: <strong>compile</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-compile-1"></a>Функция: <strong>compile</strong> <em>(functions)</em></dt>
<dt><a name="index-compile-2"></a>Функция: <strong>compile</strong> <em>(all)</em></dt>
<dd><p>Транслирует определения Maxima функций <var>f_1</var>, ..., <var>f_n</var> в Lisp, вычисляет Lisp код и 
вызывает Lisp функцию <code>COMPILE</code> на каждую транслированную функцию.
Функция <code>compile</code> возвращает список скомпилированных функций.
</p>
<p>Вызов <code>compile (all)</code> или <code>compile (functions)</code> компилирует все определенные
пользователем функции.
</p>
<p>Функция <code>compile</code> не вычисляет свои аргументы.
Оператор кавычка-кавычка <code>'<!-- /@w -->'</code> может быть использован
для их вычисления.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fdefine"></a><dl>
<dt><a name="index-define"></a>Функция: <strong>define</strong> <em>(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>), <var>expr</var>)</em></dt>
<dt><a name="index-define-1"></a>Функция: <strong>define</strong> <em>(<var>f</var>[<var>x_1</var>, ..., <var>x_n</var>], <var>expr</var>)</em></dt>
<dt><a name="index-define-2"></a>Функция: <strong>define</strong> <em>(funmake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</em></dt>
<dt><a name="index-define-3"></a>Функция: <strong>define</strong> <em>(arraymake (<var>f</var>, [<var>x_1</var>, ..., <var>x_n</var>]), <var>expr</var>)</em></dt>
<dt><a name="index-define-4"></a>Функция: <strong>define</strong> <em>(ev (<var>expr_1</var>), <var>expr_2</var>)</em></dt>
<dd>
<p>Определяет функцию с именем <var>f</var>, аргументами <var>x_1</var>, ..., <var>x_n</var> и телом функции <var>expr</var>.
Функция <code>define</code> всегда вычисляет свой второй аргумент (если вычисление не экранировано, т.е. блокировано явным образом).
Функция, определенная данным образом, может быть обычной функцией Maxima (с аргументами в круглых скобках)
или функцией-массивом (с аргументам в квадратных скобках).
</p>
<p>Если последний аргумент <var>x_n</var> является одноэлементным списком,
то функция, определенная <code>define</code>, принимает произвольное число аргументов.
Фактические параметры присваиваются по одному формальным параметрам <var>x_1</var>, ..., <var>x_(n - 1)</var>,
а все последующие фактические параметры, если таковые есть, присваиваются <var>x_n</var> одним списком.
</p>
<p>Если первый параметр <code>define</code> имеет форму
<code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> или <code><var>f</var>[<var>x_1</var>, ..., <var>x_n</var>]</code>, то
аргументы функции вычисляются, а <var>f</var> нет,
даже если уже есть функция или переменная с таким именем.
</p>
<p>Если же первый параметр является выражением с оператором <code>funmake</code>, <code>arraymake</code> или <code>ev</code>,
то первый аргумент вычисляется.  Это позволяет вычислять как имя функции так и ее тело.
</p>
<p>Все определяемые функции действуют в одном пространстве имен, т.е. если 
функция <code>f</code> определена внутри другой функции <code>g</code>, то 
действие <code>f</code> не ограничено функцией <code>g</code>.
</p>
<p>Если некоторый формальный параметр <var>x_k</var> является экранированным символом (после вычисления),
то функция, определенная <code>define</code>, не будет вычислять соответствующий фактический параметр.
Все остальные фактические параметры вычисляются.
</p>
<p>См. также <code>:=</code> и <code>::=</code>.
</p>
<p>Примеры:
</p>
<p>Функция <code>define</code> всегда вычисляет свой второй аргумент (если вычисление не блокировано явным образом).
</p>
<div class="example">
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre></div>

<p>Функция, определяемая <code>define</code>, может быть обычной функцией Maxima или функцией-массивом.
</p>
<div class="example">
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre></div>

<p>Если последний аргумент <var>x_n</var> является одноэлементным списком,
то определенная <code>define</code> функция принимает произвольное число аргументов.
</p>
<div class="example">
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre></div>

<p>Если первый параметр является выражением с оператором <code>funmake</code>, <code>arraymake</code> или <code>ev</code>,
то первый аргумент вычисляется.
</p>
<div class="example">
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Определение функций</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fdefine_005fvariable"></a><dl>
<dt><a name="index-define_005fvariable"></a>Функция: <strong>define_variable</strong> <em>(<var>name</var>, <var>default_value</var>, <var>mode</var>)</em></dt>
<dd>
<p>Определяет глобальную переменную.
<code>define_variable</code> полезна в пользовательских пакетах, которые часто 
транслируются или компилируются.
</p>
<p>Функция <code>define_variable</code> выполняет следующие шаги:
</p>
<ol>
<li> <code>mode_declare (<var>name</var>, <var>mode</var>)</code> декларирует тип переменной <var>name</var> для транслятора.
См. <code>mode_declare</code> для списка возможных типов.

</li><li> Если переменная не имеет значения, то <var>default_value</var> устанавливается равным <var>name</var>.

</li><li> <code>declare (<var>name</var>, special)</code> объявляет переменную специальной.

</li><li> Ассоциирует имя <var>name</var> с тестовой функцией, чтобы обеспечить, что 
<var>name</var> будут присваиваться значения только объявленного типа.
</li></ol>



<p>Свойство <code>value_check</code> может быть установлено для любой переменной,
определенной при помощи <code>define_variable</code> с типом отличным от <code>any</code>.
Значение свойства <code>value_check</code> является лямбда-выражением или именем функции одной переменной.
Эта функция вызывается всякий раз, как производится попытка присвоить
значение данной переменной.  Параметром функции <code>value_check</code> является 
предполагаемое новое значение переменной.
</p>
<p>Функция <code>define_variable</code> вычисляет <code>default_value</code> и не вычисляет <code>name</code> и <code>mode</code>.
Функция <code>define_variable</code> возвращает текущее значение <code>name</code>,
что есть <code>default_value</code> если <code>name</code> не имела значения до декларации
и значение <code>name</code> в противном случае.
</p>
<p>Примеры:
</p>
<p><code>foo</code> &ndash; логическая переменная с начальным значением <code>true</code>.
</p><div class="example">
<pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre></div>

<p><code>bar</code> &ndash; целочисленная переменная, которая должна быть простым числом.
</p><div class="example">
<pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre></div>

<p><code>baz_quux</code> &ndash; переменная, которой нельзя присвоить значение.
Тип <code>any_check</code> аналогичен <code>any</code>, но позволяет 
применять механизм <code>value_check</code>, в то время как тип <code>any</code> этого не позволяет.
</p><div class="example">
<pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
                 error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fdispfun"></a><dl>
<dt><a name="index-dispfun"></a>Функция: <strong>dispfun</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-dispfun-1"></a>Функция: <strong>dispfun</strong> <em>(all)</em></dt>
<dd><p>Выводит определения пользовательских функций <var>f_1</var>, ..., <var>f_n</var>.
Каждый аргумент должен быть именем: макроса (определенного при помощи <code>::=</code>),
обычной функции (определенной <code>:=</code> или <code>define</code>),
функции-массива (определенной <code>:=</code> или <code>define</code>,
но с аргументами в квадратных скобках <code>[ ]</code>),
функцией с индексом (определенной <code>:=</code> или <code>define</code>,
но с частью аргументов в квадратных скобках а с другими в круглых <code>( )</code>),
одним из элементов функции с индексом с определенным значением индекса,
или функцией с постоянным индексом.
</p>
<p>Вызов <code>dispfun (all)</code> выводит все пользовательские функции, которые определяются
списками <code>functions</code>, <code>arrays</code> и <code>macros</code>,
кроме функций с постоянным индексом.
</p>
<p>Функция <code>dispfun</code> создает метки промежуточных выражений (<code>%t1</code>, <code>%t2</code> и т.д.)
для каждой выводимой функции и присваивает определения функций этим меткам.
В отличии от этого, <code>fundef</code> возвращает определение функции.
</p>
<p>Функция <code>dispfun</code> не вычисляет свои аргументы. 
Оператор кавычка-кавычка <code>'<!-- /@w -->'</code> может быть использован для их вычисления.
Функция <code>dispfun</code> возвращает список меток промежуточных выражений, соответствующих
выведенным функциям.
</p>
<p>Примеры:
</p>
<div class="example">
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Определение функций</a>
&middot;<a href="maxima_263.html#Category_003a-_0424_0443_043d_043a_0446_0438_0438-_0432_044b_0432_043e_0434_0430">Функции вывода</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ffunctions"></a><dl>
<dt><a name="index-functions"></a>Системная переменная: <strong>functions</strong></dt>
<dd><p>Значение по умолчанию: <code>[]</code>
</p>
<p>Переменная <code>functions</code> есть список всех обычных функций Maxima в текущей сессии.
Обычные функции &ndash; это функции, определенные при помощи <code>define</code> или <code>:=</code>, 
и вызываемые с аргументами в круглых скобках <code>()</code>.
Функция может быть определена в командной строке Maxima или в файле,
загруженном при помощи <code>load</code> или <code>batch</code>.
</p>
<p>Функции-массивы (вызываемые с квадратными скобками, т.е. <code>F[x]</code>)
и функции с индексом (вызываемые с круглыми и квадратными скобками, т.е. <code>F[x](y)</code>)
перечислены в глобальной переменной <code>arrays</code>, а не в <code>functions</code>.
</p>
<p>Lisp функции не включаются в список.
</p>
<p>Примеры:
</p>
<div class="example">
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Определение функций</a>
&middot;<a href="maxima_263.html#Category_003a-_0413_043b_043e_0431_0430_043b_044c_043d_044b_0435-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0435">Глобальные переменные</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002ffundef"></a><dl>
<dt><a name="index-fundef"></a>Функция: <strong>fundef</strong> <em>(<var>f</var>)</em></dt>
<dd><p>Возвращает определение функции <var>f</var>.
</p>
<p>Аргумент должен быть именем: макроса (определенного при помощи <code>::=</code>),
обычной функции (определенной <code>:=</code> или <code>define</code>),
функции-массива (определенной <code>:=</code> или <code>define</code>,
но с аргументами в квадратных скобках <code>[ ]</code>),
функцией с индексом (определенной <code>:=</code> или <code>define</code>,
но с частью аргументов в квадратных скобках а с другими в круглых <code>( )</code>),
одним из элементов функции с индексом с определенным значением индекса,
или функцией с постоянным индексом.
</p>
<p>Функция <code>fundef</code> не вычисляет свои аргументы.
Оператор кавычка-кавычка <code>'<!-- /@w -->'</code> может быть использован для их вычисления.
</p>
<p>Вызов <code>fundef (<var>f</var>)</code> возвращает определение функции <var>f</var>.
В отличии от этого, <code>dispfun (<var>f</var>)</code> присваивает определения функций
меткам промежуточных выражений.
</p>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Определение функций</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002ffunmake"></a><dl>
<dt><a name="index-funmake"></a>Функция: <strong>funmake</strong> <em>(<var>F</var>, [<var>arg_1</var>, ..., <var>arg_n</var>])</em></dt>
<dd><p>Возвращает выражение <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>.
Это выражение упрощается но не вычисляется, т.е. функция <var>F</var> 
не вызывается, даже если она определена.
</p>
<p>Функция <code>funmake</code> не различает обычные функции и функции-массивы.
Если <var>F</var> есть имя функции-массива, то <code>funmake</code> все равно
возвращает <code><var>F</var>(...)</code>
(т.е вызов функции с круглыми а не с квадратными скобками).
Для функций-массивом следует использовать <code>arraymake</code>.
</p>
<p>Функция <code>funmake</code> вычисляет свои аргументы.
</p>
<p>Примеры:
</p>
<p>Функция <code>funmake</code>, примененная к обычной Maxima функции.
</p>
<div class="example">
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre></div>

<p>Функция <code>funmake</code>, примененная к макросу.
</p>
<div class="example">
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre></div>

<p>Функция <code>funmake</code>, примененная к функции с индексом.
</p>
<div class="example">
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre></div>

<p>Функция <code>funmake</code>, примененная к символу, не являющемуся функцией какого-либо типа.
</p>
<div class="example">
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre></div>

<p>Функция <code>funmake</code> вычисляет аргументы, но не результат.
</p>
<div class="example">
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre></div>

<p>Maxima упрощает возвращаемое <code>funmake</code> значение.
</p>
<div class="example">
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0438_043c_0435_043d_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Применение функций</a>
&middot;<a href="maxima_263.html#Category_003a-_0412_044b_0440_0430_0436_0435_043d_0438_044f">Выражения</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002flambda"></a><dl>
<dt><a name="index-lambda"></a>Функция: <strong>lambda</strong> <em>([<var>x_1</var>, ..., <var>x_m</var>], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-lambda-1"></a>Функция: <strong>lambda</strong> <em>([[<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dt><a name="index-lambda-2"></a>Функция: <strong>lambda</strong> <em>([<var>x_1</var>, ..., <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, ..., <var>expr_n</var>)</em></dt>
<dd><p>Определяет и возвращает лямбда-выражение (т.е. функцию без имени).
Функция может иметь обязательные параметры <var>x_1</var>, ..., <var>x_m</var>
и/или необязательные параметры <var>L</var>, представляемые в форме списка.
Значение, возвращаемое функцией, равно <var>expr_n</var>.
Лямбда-выражение может быть присвоено переменной и вычислено, как обычная функция.
Лямбда-выражение может использоваться в тех же контекстах, где ожидается
имя функции.
</p>
<p>При вычислении функции, создаются неинициализированные
локальные переменные <var>x_1</var>, ..., <var>x_m</var>.
<code>lambda</code> может использоваться внутри <code>block</code> или другого <code>lambda</code>,
и локальные переменные создаются каждый раз, как вычисляется новый блок <code>block</code> или <code>lambda</code>.
Локальные переменные выглядят как глобальные для каждого внутреннего блока <code>block</code> или <code>lambda</code>.
Если переменная не является локальной, то ее значение равно последнему, присвоенному 
в объемлющем блоке <code>block</code> или <code>lambda</code>, если таковое существует, 
и значению переменной в глобальном окружении в противном случае.
Эта политика совпадает с обычным понятием &quot;динамической области определения&quot;.
</p>
<p>После определения локальных переменных, выражения с <var>expr_1</var> по <var>expr_n</var> 
последовательно вычисляются.
Специальная переменная <code>%%</code> обозначает значение предыдущего выражения.
Среди выражение могут применяться <code>throw</code> и <code>catch</code>.
</p>
<p>Команда возврата <code>return</code> не может использоваться в лямбда-выражении если только
она не заключена в блоке <code>block</code>.  В этом случае <code>return</code> определяет
значение блока а не лямбда-выражения в целом, за исключением случая, когда блок является 
последним выражением <var>expr_n</var>.
Аналогично, <code>go</code> не может использоваться в лямбда-выражении без объемлющего блока <code>block</code>.
</p>
<p>Функция <code>lambda</code> не вычисляет свои параметры.
Оператор кавычка-кавычка <code>'<!-- /@w -->'</code> может быть использован для их вычисления.
</p>
<p>Примеры:
</p>
<ul>
<li> Лямбда-выражение может быть присвоено переменной и вычислено, как обычная функция.
</li></ul>
<div class="example">
<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre></div>
<ul>
<li> Лямбда-выражение может использоваться в тех же контекстах, где ожидается
вычисление функции.
</li></ul>
<div class="example">
<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre></div>
<ul>
<li> Параметры являются локальными переменными.
Все остальные переменные глобальны.
Глобальные переменные вычисляются в момент вычисления лямбда-выражения, за исключением
случая, когда вычисление специально вызвано каким-либо способом, например, оператором  <code>'<!-- /@w -->'</code>.
</li></ul>
<div class="example">
<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre></div>
<ul>
<li> Лямбда-выражения могут быть вложены.
Локальные переменные объемлющего лямбда-выражения выглядят глобальными для внутреннего, если
только во внутреннем лямбда-выражении не определены локальные переменные с теми же именами.
</li></ul>
<div class="example">
<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre></div>
<ul>
<li> Поскольку <code>lambda</code> не вычисляет аргументы, нижеприведенное лямбда-выражение <code>i</code>  
не определяет функцию &quot;умножить на <code>a</code>&quot;.
Такая функция может быть определена с помощью <code>buildq</code>, как сделано в лямбда-выражении <code>i2</code>.
</li></ul>
<div class="example">
<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre></div>
<ul>
<li> Лямбда-выражение может иметь переменное число аргументов,
что обозначается <code>[<var>L</var>]</code> в качестве единственного или последнего параметра.
Фактические параметры представлены внутри функции в виде списка.
</li></ul>
<div class="example">
<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Определение функций</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002flocal"></a><dl>
<dt><a name="index-local"></a>Функция: <strong>local</strong> <em>(<var>v_1</var>, ..., <var>v_n</var>)</em></dt>
<dd><p>Объявляет переменные <var>v_1</var>, ..., <var>v_n</var> локальными по отношению ко всем
свойствам в выражении, где используется <code>local</code>.
</p>
<p>Функция <code>local</code> не вычисляет свои аргументы.
Функция <code>local</code> возвращает <code>done</code>.
</p>
<p>Функция <code>local</code> может использоваться только внутри блока <code>block</code>, в теле функции или 
лямбда-выражении <code>lambda</code>, в функции <code>ev</code>, и только один раз в каждом случае.
</p>
<p><code>local</code> независима от <code>context</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Определение функций</a>
&middot;<a href="maxima_263.html#Category_003a-_041f_0440_043e_0433_0440_0430_043c_043c_0438_0440_043e_0432_0430_043d_0438_0435">Программирование</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002fmacroexpansion"></a><dl>
<dt><a name="index-macroexpansion"></a>Управляющая переменная: <strong>macroexpansion</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Переменная <code>macroexpansion</code> управляет тем, подставляется ли макро-расширение 
(т.е. возвращаемое значением) вместо вызова макро-функции.
Подстановка может ускорить последующие вычисления но за счет увеличения
памяти для хранения выражений.
</p>
<dl compact="compact">
<dt><code>false</code></dt>
<dd><p>Макро-расширение не подставляется вместо вызова макро-функции.
</p></dd>
<dt><code>expand</code></dt>
<dd><p>При первом вызове макро-функции, макро-расширение
сохраняется.
Для последующих вызовов, макро-расширение не перевычисляется.
Побочные эффекты (такие как <code>print</code> или присваивание глобальных переменных) 
осуществляются только при первом вычислении макро-функции.
Макро-расширение в выражении не влияет на другие выражения, имеющие 
такой же вызов макро-функции.
</p></dd>
<dt><code>displace</code></dt>
<dd><p>При первом вызове макро-функции, макро-расширение
подставляется вместо вызова, изменяя выражение, из которого
макро-функция вызывается.
Для последующих вызовов, макро-расширение не перевычисляется.
Побочные эффекты осуществляются только при первом вычислении макро-функции.
Макро-расширение в выражении не влияет на другие выражения, имеющие 
такой же вызов макро-функции.
</p></dd>
</dl>

<p>Примеры:
</p>
<p>Если <code>macroexpansion</code> равна <code>false</code>,
то макро-функция вызывается всякий раз, как вычисляется вызывающее выражение,
и вызывающее выражение не изменяется.
</p>
<div class="example">
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></div>

<p>Если <code>macroexpansion</code> равна <code>expand</code>, то
макро-функция вызывается один раз, и взывающее 
выражение не изменяется.
</p>
<div class="example">
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></div>

<p>Если <code>macroexpansion</code> равна <code>expand</code>, то
макро-функция вызывается один раз, и взывающее 
выражение изменяется.
</p>
<div class="example">
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre></div>

<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0440_0438_043c_0435_043d_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439">Применение функций</a>
&middot;<a href="maxima_263.html#Category_003a-_0413_043b_043e_0431_0430_043b_044c_043d_044b_0435-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0435">Глобальные переменные</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002fmode_005fcheckp"></a><dl>
<dt><a name="index-mode_005fcheckp"></a>Управляющая переменная: <strong>mode_checkp</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Если  <code>mode_checkp</code> равна <code>true</code>, то <code>mode_declare</code> проверяет
типы переменных, имеющих значение до вызова <code>mode_declare</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002fmode_005fcheck_005ferrorp"></a><dl>
<dt><a name="index-mode_005fcheck_005ferrorp"></a>Управляющая переменная: <strong>mode_check_errorp</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если <code>mode_check_errorp</code> равна <code>true</code>, то <code>mode_declare</code> 
вызывает ошибку.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002fmode_005fcheck_005fwarnp"></a><dl>
<dt><a name="index-mode_005fcheck_005fwarnp"></a>Управляющая переменная: <strong>mode_check_warnp</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Если <code>mode_check_warnp</code> равна <code>true</code>, то выводятся
предупреждения о ошибках типизации.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fmode_005fdeclare"></a><dl>
<dt><a name="index-mode_005fdeclare"></a>Функция: <strong>mode_declare</strong> <em>(<var>y_1</var>, <var>mode_1</var>, ..., <var>y_n</var>, <var>mode_n</var>)</em></dt>
<dd><p>Функция <code>mode_declare</code> используется для определения типов переменных или
функций для последующей трансляции и компиляции.
Вызов <code>mode_declare</code> обычно располагается в начале определения функции, 
в начале  Maxima-программы или выполняется интерактивно в командной строке.
</p>
<p>Параметры <code>mode_declare</code> являются парами, состоящими из переменной и ее типа, 
который может быть <code>boolean</code>, <code>fixnum</code>, <code>number</code>, <code>rational</code> или <code>float</code>.
Вместо переменной можно использовать список переменных, которые 
все будут объявлены однотипными.
</p>
<p>Если переменная является массивом, и каждый элемент этого массива, на который будут ссылаться,
имеет значение, то для первой декларации границ массива следует использовать
<code>array (yi, complete, dim1, dim2, ...)</code>
а не
</p><div class="example">
<pre class="example">array(yi, dim1, dim2, ...)
</pre></div>
<p>Если все элементы массива имеют тип <code>fixnum</code> (<code>float</code>), то следует
использовать <code>fixnum</code> (<code>float</code>) вместо <code>complete</code>.
Кроме того, если все элементы массива имеют один тип, скажем <code>m</code>, то
для эффективной трансляции следует использовать 
</p>
<div class="example">
<pre class="example">mode_declare (completearray (yi), m))
</pre></div>

<p>Численный код с использованием массивов может работать быстрее
при объявлении ожидаемого размера массива, как сделано в
</p>
<div class="example">
<pre class="example">mode_declare (completearray (a [10, 10]), float)
</pre></div>

<p>для массива с плавающей точкой размера 10 x 10.
</p>
<p>Можно определить тип результата функции при помощи <code>function (f_1, f_2, ...)</code>,
где <code>f_1</code>, <code>f_2</code>, ... есть имена функций.  
Например, выражение
</p>
<div class="example">
<pre class="example">mode_declare ([function (f_1, f_2, ...)], fixnum)
</pre></div>

<p>объявляет значения, возвращаемые функциями <code>f_1</code>, <code>f_2</code>, ..., целыми числами 
длиной одно слово.
</p>
<p>Функция <code>modedeclare</code> является синонимом <code>mode_declare</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fmode_005fidentity"></a><dl>
<dt><a name="index-mode_005fidentity"></a>Функция: <strong>mode_identity</strong> <em>(<var>arg_1</var>, <var>arg_2</var>)</em></dt>
<dd><p>Специальная форма, используемая вместе с <code>mode_declare</code> и
<code>macros</code> для объявления, например, списка списков чисел с плавающей точкой или 
других подобных составных объектов.
Первый аргумент <code>mode_identity</code> есть имя типа, как в <code>mode_declare</code> 
(т.е. одно из  <code>float</code>, <code>fixnum</code>, <code>number</code>,
<code>list</code> или <code>any</code>), а второй аргумент есть выражение, которое вычисляется и 
возвращается как значение <code>mode_identity</code>.  Если возвращаемое значение недопустимо
для декларации типа, указанного в первом аргументе, то случается ошибка или 
печатается предупреждение.  Важно то, что тип выражения для транслятора Maxima в Lisp
будет всегда определяться первым аргументом, вне зависимости от того, что
происходит со вторым.
Например, <code>x: 3.3; mode_identity (fixnum, x);</code> дает ошибку а <code>mode_identity (flonum, x)</code>
возвращает 3.3. 
С этим связан ряд проблем, например, если известно, что <code>first (l)</code> возвращает число,
то можно написать <code>mode_identity (number, first (l))</code>.  
Но более эффективно будет определить новый примитив 
</p>
<div class="example">
<pre class="example">firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));
</pre></div>

<p>и использовать <code>firstnumb</code> всякий раз при обращении
к первому элементу списка чисел.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftranscompile"></a><dl>
<dt><a name="index-transcompile"></a>Управляющая переменная: <strong>transcompile</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Если <code>transcompile</code> равно <code>true</code>, то <code>translate</code> и <code>translate_file</code> 
создают декларации, которые делают транслируемый код более удобным для компиляции.
</p>
<p>Функция <code>compfile</code> устанавливает <code>transcompile: true</code> на время своей работы.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002ftranslate"></a><dl>
<dt><a name="index-translate"></a>Функция: <strong>translate</strong> <em>(<var>f_1</var>, ..., <var>f_n</var>)</em></dt>
<dt><a name="index-translate-1"></a>Функция: <strong>translate</strong> <em>(functions)</em></dt>
<dt><a name="index-translate-2"></a>Функция: <strong>translate</strong> <em>(all)</em></dt>
<dd><p>Транслирует определенные пользователем функции
<var>f_1</var>, ..., <var>f_n</var> из языка Maxima в Lisp и вычисляет
результат трансляции.
Обычно, транслированные функции работают быстрее оригиналов.
</p>
<p>Вызов <code>translate (all)</code> или <code>translate (functions)</code> транслирует все
определенные пользователем функции.
</p>
<p>Транслируемые функции должны, где это возможно, содержать в начале кода вызовы <code>mode_declare</code>, 
для генерации более эффективного кода.  
</p>
<p>Например:
</p>
<div class="example">
<pre class="example">f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
</pre></div>


<p>где <var>x_1</var>, <var>x_2</var>, ... &ndash; параметры функции, а <var>v_1</var>, <var>v_2</var>, ... 
&ndash; локальные переменные.
</p>
<p>Имена транслированных функций удаляются из списка <code>functions</code> если значение <code>savedef</code> 
равно <code>false</code> (см. ниже) и добавляются к списку <code>props</code>.
</p>
<p>Не следует транслировать недостаточно отлаженные функции.
</p>
<p>При трансляции, выражения предполагаются уже упрощенными.
Если это не так, то будет сгенерирован правильный но неоптимальный код.
Таким образом, не следует устанавливать переключатель <code>simp</code> равным <code>false</code>,
что подавляет упрощение транслируемых выражений.
</p>
<p>Если переключатель <code>translate</code> равен <code>true</code>, то все определяемые пользователем функции
автоматически транслируются в Lisp.
</p>
<p>Отметим, что транслируемые функции могут работать не совсем так,
как до трансляции, т.к. существуют некоторые несовместимости
между Lisp и Maxima версиями функции.  Главным образом, функция <code>rat</code>, имеющая более одного
параметра, и функция <code>ratvars</code> не должны использоваться, если некоторые 
переменные объявлены <code>mode_declare</code> каноническими рациональными выражениями (КРВ).
Кроме того, <code>prederror: false</code> не транслируется.
</p>
<p>Если <code>savedef</code> равна <code>true</code>, то Maxima версия сохраняется при трансляции.
Это позволяет выводить определение функции при помощи <code>dispfun</code> и редактировать его.
</p>
<p>Если <code>transrun</code> равна <code>false</code>, то интерпретируемые 
варианты будут выполняться (если они еще доступны) вместо транслированных для всех вызовов функций.
</p>
<p>Функция <code>translate</code> возвращает список транслированных функций.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002ftranslate_005ffile"></a><dl>
<dt><a name="index-translate_005ffile"></a>Функция: <strong>translate_file</strong> <em>(<var>maxima_filename</var>)</em></dt>
<dt><a name="index-translate_005ffile-1"></a>Функция: <strong>translate_file</strong> <em>(<var>maxima_filename</var>, <var>lisp_filename</var>)</em></dt>
<dd><p>Транслирует файл кода Maxima в файлд кода Lisp.
Функция <code>translate_file</code> возвращает список трех имен файлов:
имя файла Maxima, имя файла Lisp и имя файла, содержащего дополнительную
информацию о трансляции.
Функция <code>translate_file</code> вычисляет свои аргументы.
</p>
<p>Команды <code>translate_file (&quot;foo.mac&quot;); load(&quot;foo.LISP&quot;)</code> дают тот же
результат, что и <code>batch (&quot;foo.mac&quot;)</code> за исключением некоторых
ограничений, например, на использование <code>'<!-- /@w -->'</code> и <code>%</code>.
</p>
<p>Вызов <code>translate_file (<var>maxima_filename</var>)</code> транслирует файл Maxima <var>maxima_filename</var>
в Lisp файл с аналогичным именем.  Например, <code>foo.mac</code> транслируется в <code>foo.LISP</code>.
Имя файла Maxima может включать имена директорий, и результирующий Lisp файл
будет записан в ту же директорию, где располагается исходный файл Maxima.
</p>
<p>Вызов <code>translate_file (<var>maxima_filename</var>, <var>lisp_filename</var>)</code> транслирует файл 
Maxima <var>maxima_filename</var> в Lisp файл <var>lisp_filename</var>.
<code>translate_file</code> игнорирует расширение имени файла для <code>lisp_filename</code>,
если таковое задано.
Расширение Lisp файла всегда будет <code>LISP</code>.
Имя Lisp файла может содержать имена директорий, и в этом случае файл будет записан
в заданную директорию.
</p>
<p><code>translate_file</code> также записывает файл предупреждений транслятора, разной 
степени важности.
Расширение имени этого файла &ndash; <code>UNLISP</code>.
Этот файл может содержать ценную информацию, возможно туманную,
для обнаружения ошибок в транслированном коде.
Файл <code>UNLISP</code> всегда записывается в ту же директорию, где
расположен исходный файл Maxima.
</p>
<p><code>translate_file</code> генерирует код, в котором некоторые
декларации и определения вступают в силу сразу в процессе 
компиляции Lisp кода.
См. также  <code>compile_file</code> по этому поводу.
</p>
<p>См. также <code>tr_array_as_ref</code>,
<code>tr_bound_function_applyp</code>,
<code>tr_exponent</code>,
<code>tr_file_tty_messagesp</code>, 
<code>tr_float_can_branch_complex</code>,
<code>tr_function_call_default</code>, 
<code>tr_numer</code>,
<code>tr_optimize_max_loop</code>, 
<code>tr_semicompile</code>,
<code>tr_state_vars</code>, 
<code>tr_warnings_get</code>,
<code>tr_warn_bad_function_calls</code>,
<code>tr_warn_fexpr</code>, 
<code>tr_warn_meval</code>,
<code>tr_warn_mode</code>,
<code>tr_warn_undeclared</code>, 
<code>tr_warn_undefined_variable</code>
и <code>tr_windy</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftransrun"></a><dl>
<dt><a name="index-transrun"></a>Управляющая переменная: <strong>transrun</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Если <code>transrun</code> равна <code>false</code>, то для всех функций интерпретируемые 
варианты будут выполняться (если они еще доступны) вместо транслированных.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005farray_005fas_005fref"></a><dl>
<dt><a name="index-tr_005farray_005fas_005fref"></a>Управляющая переменная: <strong>tr_array_as_ref</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Если <code>translate_fast_arrays</code> равна <code>false</code>, то ссылки на массивы в Lisp коде,
созданном <code>translate_file</code>, зависят от  <code>tr_array_as_ref</code>.
Если <code>tr_array_as_ref</code> равна <code>true</code>, то имена массивов вычисляются,
иначе они рассматриваются в транслированном коде как буквальные символы.
</p>
<p><code>tr_array_as_ref</code> не действует если <code>translate_fast_arrays</code> равна <code>true</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fbound_005ffunction_005fapplyp"></a><dl>
<dt><a name="index-tr_005fbound_005ffunction_005fapplyp"></a>Управляющая переменная: <strong>tr_bound_function_applyp</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Если <code>tr_bound_function_applyp</code> равна <code>true</code>, то Maxima выдает предупреждение,
если имеющая значение переменная (такая, как аргумент функции) используется как 
имя функции.
</p>
<p>Например, выражение <code>g (f, x) := f (x+1)</code> вызовет предупреждение.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005ffile_005ftty_005fmessagesp"></a><dl>
<dt><a name="index-tr_005ffile_005ftty_005fmessagesp"></a>Управляющая переменная: <strong>tr_file_tty_messagesp</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если <code>tr_file_tty_messagesp</code> равна <code>true</code>, то сообщения,
генерируемые <code>translate_file</code> в процессе трансляции, отображаются на консоли
и выводятся в UNLISP файл. 
Если <code>false</code>, то сообщения выводятся только в UNLISP файл.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005ffloat_005fcan_005fbranch_005fcomplex"></a><dl>
<dt><a name="index-tr_005ffloat_005fcan_005fbranch_005fcomplex"></a>Управляющая переменная: <strong>tr_float_can_branch_complex</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>Сообщает Maxima-Lisp транслятору, что функции  
<code>acos</code>, <code>asin</code>, <code>asec</code> и <code>acsc</code> могут возвращать
комплексные значения.
</p>
<p>Эффект <code>tr_float_can_branch_complex</code> заключается в следующем.
Хотя, явного влияния на результат трансляции нет, но  
если этот флаг равен <code>true</code>, то <code>acos(x)</code> имеет тип <code>any</code>,
даже если <code>x</code> имеет тип <code>float</code> (как определено <code>mode_declare</code>).
Если ли же он равен <code>false</code>, то <code>acos(x)</code> имеет тип <code>float</code> тогда и тоько тогда,
когда <code>x</code> имеет тип <code>float</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005ffunction_005fcall_005fdefault"></a><dl>
<dt><a name="index-tr_005ffunction_005fcall_005fdefault"></a>Управляющая переменная: <strong>tr_function_call_default</strong></dt>
<dd><p>Значение по умолчанию: <code>general</code>
</p>
<p>Если равна <code>false</code>, то следует вызывать <code>meval</code>;
если <code>expr</code>, то предполагать Lisp функцию с фиксированными аргументами; если <code>general</code>,
то генерируется код, подходящий для <code>mexprs</code> и <code>mlexprs</code> но не <code>macros</code>.
<code>general</code> обеспечивает правильное связывание переменных в компилируемом коде.  
В режиме <code>general</code>, при трансляции F(X), если F является связанной переменной, то 
предполагается <code>apply (f, [x])</code>, и в таком виде транслируется с печатью соответствующего
предупреждения.  Нет необходимости выключать этот механизм.  С установками по умолчанию,
отсутствие предупреждений не означает полную совместимость транслированного и
интерпретируемого кода.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fnumer"></a><dl>
<dt><a name="index-tr_005fnumer"></a>Управляющая переменная: <strong>tr_numer</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если <code>tr_numer</code> равна <code>true</code>, то для атомов, имеющих свойство <code>numer</code>, 
например, <code>%pi</code>, это свойство принимается во внимание транслятором.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005foptimize_005fmax_005floop"></a><dl>
<dt><a name="index-tr_005foptimize_005fmax_005floop"></a>Управляющая переменная: <strong>tr_optimize_max_loop</strong></dt>
<dd><p>Значение по умолчанию: 100
</p>
<p><code>tr_optimize_max_loop</code> есть максимальное число раз, которое 
цикл макро-расширения и оптимизации транслятора будет повторен
при трансляции формы.  Данный предел установлен для обнаружения
ошибок макро-расширения и зацикливания оптимизатора.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fsemicompile"></a><dl>
<dt><a name="index-tr_005fsemicompile"></a>Управляющая переменная: <strong>tr_semicompile</strong></dt>
<dd><p>Значение по умолчанию: <code>false</code>
</p>
<p>Если <code>tr_semicompile</code> равна <code>true</code>, то <code>translate_file</code> и <code>compfile</code>
генерируют формы, которые будут макро-расширены но не скомпилированы в машинный код 
Lisp компилятором.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fstate_005fvars"></a><dl>
<dt><a name="index-tr_005fstate_005fvars"></a>Системная переменная: <strong>tr_state_vars</strong></dt>
<dd><p>Значение по умолчанию:
</p><div class="example">
<pre class="example">[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
</pre></div>

<p>Список переключателей, которые влияют на форму транслированного кода.
Эта информация полезна для отладки транслятора.  
Сравнивая результат трансляции с ожидаемым для данного состояния результатом,
можно обнаружить ошибки транслятора.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002ftr_005fwarnings_005fget"></a><dl>
<dt><a name="index-tr_005fwarnings_005fget"></a>Функция: <strong>tr_warnings_get</strong> <em>()</em></dt>
<dd><p>Печатает список предупреждений, сгенерированных транслятором в процессе текущей
трансляции.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwarn_005fbad_005ffunction_005fcalls"></a><dl>
<dt><a name="index-tr_005fwarn_005fbad_005ffunction_005fcalls"></a>Управляющая переменная: <strong>tr_warn_bad_function_calls</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>&ndash; выдает предупреждение в случае вызова функции, который может быть неверным
из-за неправильных деклараций, сделанных во время трансляции.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwarn_005ffexpr"></a><dl>
<dt><a name="index-tr_005fwarn_005ffexpr"></a>Управляющая переменная: <strong>tr_warn_fexpr</strong></dt>
<dd><p>Значение по умолчанию: <code>compfile</code>
</p>
<p>&ndash; выдает предупреждение если встречается FEXPR.  Обычно, FEXPR не должны присутствовать 
в транслированном коде.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwarn_005fmeval"></a><dl>
<dt><a name="index-tr_005fwarn_005fmeval"></a>Управляющая переменная: <strong>tr_warn_meval</strong></dt>
<dd><p>Значение по умолчанию: <code>compfile</code>
</p>
<p>&ndash; выдает предупреждение при вызове функции <code>meval</code>.  Вызов <code>meval</code> означает проблему
в транслированном коде.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwarn_005fmode"></a><dl>
<dt><a name="index-tr_005fwarn_005fmode"></a>Управляющая переменная: <strong>tr_warn_mode</strong></dt>
<dd><p>Значение по умолчанию: <code>all</code>
</p>
<p>&ndash; выдает предупреждение, когда переменной присваивается значение, несовместимое
с ее типом.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwarn_005fundeclared"></a><dl>
<dt><a name="index-tr_005fwarn_005fundeclared"></a>Управляющая переменная: <strong>tr_warn_undeclared</strong></dt>
<dd><p>Значение по умолчанию: <code>compile</code>
</p>
<p>&ndash; управляет тем, когда печатать сообщения о
необъявленных переменных.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwarn_005fundefined_005fvariable"></a><dl>
<dt><a name="index-tr_005fwarn_005fundefined_005fvariable"></a>Управляющая переменная: <strong>tr_warn_undefined_variable</strong></dt>
<dd><p>Значение по умолчанию: <code>all</code>
</p>
<p>&ndash; печатает предупреждение, когда встречается необъявленная переменная.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdefvr_002ftr_005fwindy"></a><dl>
<dt><a name="index-tr_005fwindy"></a>Управляющая переменная: <strong>tr_windy</strong></dt>
<dd><p>Значение по умолчанию: <code>true</code>
</p>
<p>&ndash; вызывает печать полезных комментариев и советов по программированию.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_041f_0435_0440_0435_043c_0435_043d_043d_044b_0435-_0438-_0444_043b_0430_0433_0438-_0442_0440_0430_043d_0441_043b_044f_0446_0438_0438">Переменные и флаги трансляции</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fcompile_005ffile"></a><dl>
<dt><a name="index-compile_005ffile"></a>Функция: <strong>compile_file</strong> <em>(<var>filename</var>)</em></dt>
<dt><a name="index-compile_005ffile-1"></a>Функция: <strong>compile_file</strong> <em>(<var>filename</var>, <var>compiled_filename</var>)</em></dt>
<dt><a name="index-compile_005ffile-2"></a>Функция: <strong>compile_file</strong> <em>(<var>filename</var>, <var>compiled_filename</var>, <var>lisp_filename</var>)</em></dt>
<dd><p>Транслирует файл Maxima <var>filename</var> в Lisp,
выполняет компилятор Lisp и, если трансляция и компиляция успешны, 
то загружает скомпилированный код в Maxima.
</p>
<p><code>compile_file</code> возвращает список имен четырех файлов:
изначального файла кода Maxima, транслированного Lisp файла, файла замечаний по трансляции и файла
скомпилированного кода.  Если компиляция неуспешна, то последний элемент равен <code>false</code>.
</p>
<p>Некоторые декларации и определения активизируются сразу в процессе
компиляции Lisp кода (без загрузки скомпилированного кода).
Сюда относятся функции, определенные при помощи оператора <code>:=</code>,
макросы, определенные при помощи <code>::=</code>, <code>alias</code>, <code>declare</code>,
<code>define_variable</code>,  <code>mode_declare</code>
и
<code>infix</code>, <code>matchfix</code>,
<code>nofix</code>, <code>postfix</code>, <code>prefix</code> а также
<code>compfile</code>.
</p>
<p>Присваивания и вызовы функций не вычисляются до загрузки скомпилированного файла.
В частности, присваивания флагам трансляции (<code>tr_numer</code> и т.п.) внутри Maxima файла не оказывают
влияния на результат трансляции.
</p>

<p>Файл <var>filename</var> не может содержать специальные <code>:lisp</code> команды.
</p>
<p>Функция <code>compile_file</code> вычисляет свои аргументы.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Function_002fdeffn_002fdeclare_005ftranslated"></a><dl>
<dt><a name="index-declare_005ftranslated"></a>Функция: <strong>declare_translated</strong> <em>(<var>f_1</var>, <var>f_2</var>, ...)</em></dt>
<dd><p>При трансляции кода Maxima в код Lisp, транслятору важно знать, какие функции
следует вызывать как транслированные или компилированные, а какие как обычные Maxima 
функции или неопределенные.  Данная декларация, помещенная в начале транслируемого
файла, дает транслятору информацию, что хотя <var>f_n</var> и не имеет свойство Lisp функции
во время трансляции, но будет иметь таковое в момент вызова.
Если транслятор не знает, что <code>fn</code> будет Lisp функцией, то
генерируется код <code>(MFUNCTION-CALL fn arg1 arg2 ...)</code>.
</p>
<div class=categorybox>
Категории:<a href="maxima_263.html#Category_003a-_0422_0440_0430_043d_0441_043b_044f_0446_0438_044f-_0438-_043a_043e_043c_043f_0438_043b_044f_0446_0438_044f">Трансляция и компиляция</a>
&middot;</div>
</dd></dl>


<hr>
<div class="header">
<p>
Previous: <a href="maxima_143.html#g_t_041c_0430_043a_0440_043e_0441_044b" accesskey="p" rel="previous">Макросы</a>, Up: <a href="maxima_140.html#g_t_041e_043f_0440_0435_0434_0435_043b_0435_043d_0438_0435-_0444_0443_043d_043a_0446_0438_0439" accesskey="u" rel="up">Определение функций</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_262.html#g_t_0423_043a_0430_0437_0430_0442_0435_043b_044c-_0444_0443_043d_043a_0446_0438_0439-_0438-_043f_0435_0440_0435_043c_0435_043d_043d_044b_0445" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
