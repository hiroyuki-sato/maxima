<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Number Theory</TITLE>
<link href="maxima_32.html" rel=Next>
<link href="maxima_30.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_30.html">previous</A>, <A HREF="maxima_32.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC98" HREF="maxima_toc.html#TOC98">Number Theory</A></H1>



<H2><A NAME="SEC99" HREF="maxima_toc.html#TOC99">Definitions for Number Theory</A></H2>
<P>
<DL>
<DT><U>Function:</U> <B>BERN</B> <I>(x)</I>
<DD><A NAME="IDX780"></A>
gives the Xth Bernoulli number for integer X.
ZEROBERN[TRUE] if set to FALSE excludes the zero BERNOULLI numbers.
(See also BURN).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BERNPOLY</B> <I>(v, n)</I>
<DD><A NAME="IDX781"></A>
generates the nth Bernoulli polynomial in the
variable v.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BFZETA</B> <I>(exp,n)</I>
<DD><A NAME="IDX782"></A>
BFLOAT version of the Riemann Zeta function.  The 2nd
argument is how many digits to retain and return, it's a good idea to
request a couple of extra.  This function is available by doing
LOAD(BFFAC); .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BGZETA</B> <I>(S, FPPREC)</I>
<DD><A NAME="IDX783"></A>
BGZETA is like BZETA, but avoids arithmetic
overflow errors on large arguments, is faster on medium size arguments
(say S=55, FPPREC=69), and is slightly slower on small arguments.  It
may eventually replace BZETA.  BGZETA is available by doing
LOAD(BFAC);.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BHZETA</B> <I>(S,H,FPPREC)</I>
<DD><A NAME="IDX784"></A>
gives FPPREC digits of

<PRE>
SUM((K+H)^-S,K,0,INF)
</PRE>

<P>
This is available by doing LOAD(BFFAC);.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BINOMIAL</B> <I>(X, Y)</I>
<DD><A NAME="IDX785"></A>
the binomial coefficient X*(X-1)*...*(X-Y+1)/Y!. If X
and Y are integers, then the numerical value of the binomial
coefficient is computed.  If Y, or the value X-Y, is an integer, the
binomial coefficient is expressed as a polynomial.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BURN</B> <I>(N)</I>
<DD><A NAME="IDX786"></A>
is like BERN(N), but without computing all of the uncomputed
Bernoullis of smaller index.  So BURN works efficiently for large,
isolated N.  (BERN(402) takes about 645 secs vs 13.5 secs for
BURN(402).  BERN's time growth seems to be exponential, while BURN's
is about cubic.  But if next you do BERN(404), it only takes 12 secs,
since BERN remembers all in an array, whereas BURN(404) will take
maybe 14 secs or maybe 25, depending on whether MACSYMA needs to
BFLOAT a better value of %PI.)  BURN is available by doing LOAD(BFFAC);.
BURN uses an observation of WGD that (rational) Bernoulli numbers can be
approximated by (transcendental) zetas with tolerable efficiency.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BZETA</B>
<DD><A NAME="IDX787"></A>
 - This function is obsolete, see BFZETA.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CF</B> <I>(exp)</I>
<DD><A NAME="IDX788"></A>
converts exp into a continued fraction.  exp is an expression
composed of arithmetic operators and lists which represent continued
fractions.  A continued fraction a+1/(b+1/(c+...)) is represented by
the list [a,b,c,...]. a,b,c,.. must be integers.  Exp may also involve
SQRT(n) where n is an integer.  In this case CF will give as many
terms of the continued fraction as the value of the variable
CFLENGTH[1] times the period.  Thus the default is to give one period.
(CF binds LISTARITH to FALSE so that it may carry out its function.)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CFDISREP</B> <I>(list)</I>
<DD><A NAME="IDX789"></A>
converts the continued fraction represented by list
into general representation.

<PRE>
(C1) CF([1,2,-3]+[1,-2,1]);
(D1)                 [1, 1, 1, 2]
(C2) CFDISREP(%);
                            1
(D2)                1 + ---------
                              1
                        1 + -----
                                1
                            1 + -
                                2

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CFEXPAND</B> <I>(x)</I>
<DD><A NAME="IDX790"></A>
gives a matrix of the numerators and denominators of the
next-to-last and last convergents of the continued fraction x.

<PRE>
(C1) CF(SQRT(3));
(D1)                 [1, 1, 2, 1, 2, 1, 2, 1]
(C2) CFEXPAND(%);
                             [71  97]
(D2)                         [      ]
                             [41  56]
(C3) D2[1,2]/D2[2,2],NUMER;
(D3)                        1.7321429

</PRE>

</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>CFLENGTH</B>
<DD><A NAME="IDX791"></A>
 default: [1] controls the number of terms of the continued
fraction the function CF will give, as the value CFLENGTH[1] times the
period.  Thus the default is to give one period.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CGAMMA</B>
<DD><A NAME="IDX792"></A>
 - The Gamma function in the complex plane.  Do LOAD(CGAMMA) to
use these functions.  Functions Cgamma, Cgamma2, and LogCgamma2.
These functions evaluate the Gamma function over the complex plane
using the algorithm of Kuki, CACM algorithm 421.  Calculations are
performed in single precision and the relative error is typically
around 1.0E-7; evaluation at one point costs less than 1 msec.  The
algorithm provides for an error estimate, but the Macsyma
implementation currently does not use it.
Cgamma is the general function and may be called with a symbolic or
numeric argument.  With symbolic arguments, it returns as is; with
real floating or rational arguments, it uses the Macsyma Gamma
function; and for complex numeric arguments, it uses the Kuki
algorithm.
Cgamma2 of two arguments, real and imaginary, is for numeric arguments
only; LogCgamma2 is the same, but the log-gamma function is
calculated.  These two functions are somewhat more efficient.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CGAMMA2</B>
<DD><A NAME="IDX793"></A>
 - See CGAMMA.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DIVSUM</B> <I>(n,k)</I>
<DD><A NAME="IDX794"></A>
adds up all the factors of n raised to the kth power.  If
only one argument is given then k is assumed to be 1.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EULER</B> <I>(X)</I>
<DD><A NAME="IDX795"></A>
gives the Xth Euler number for integer X.  For the
Euler-Mascheroni constant, see %GAMMA.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FACTORIAL</B> <I>(X)</I>
<DD><A NAME="IDX796"></A>
The factorial function.  FACTORIAL(X) = X! .
See also MINFACTORIAL and FACTCOMB.  The factorial operator is !,
and the double factorial operator is !!.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FIB</B> <I>(X)</I>
<DD><A NAME="IDX797"></A>
the Xth Fibonacci number with FIB(0)=0, FIB(1)=1, and
FIB(-N)=(-1)^(N+1) *FIB(N).  PREVFIB is FIB(X-1), the Fibonacci number
preceding the last one computed.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FIBTOPHI</B> <I>(exp)</I>
<DD><A NAME="IDX798"></A>
converts FIB(n) to its closed form definition.
This involves the constant %PHI (= (SQRT(5)+1)/2 = 1.618033989).
If you want the Rational Function Package to know 
About %PHI do TELLRAT(%PHI^2-%PHI-1)$  ALGEBRAIC:TRUE$ .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>INRT</B> <I>(X,n)</I>
<DD><A NAME="IDX799"></A>
takes two integer arguments, X and n, and returns the
integer nth root of the absolute value of X.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>JACOBI</B> <I>(p,q)</I>
<DD><A NAME="IDX800"></A>
is the Jacobi symbol of p and q.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LCM</B> <I>(exp1,exp2,...)</I>
<DD><A NAME="IDX801"></A>
returns the Least Common Multiple of its arguments.
Do LOAD(FUNCTS); to access this function.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>MAXPRIME</B>
<DD><A NAME="IDX802"></A>
 default: [489318] - the largest number which may be given to
the PRIME(n) command, which returns the nth prime.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MINFACTORIAL</B> <I>(exp)</I>
<DD><A NAME="IDX803"></A>
examines exp for occurrences of two factorials
which differ by an integer.  It then turns one into a polynomial times
the other.  If exp involves binomial coefficients then they will be
converted into ratios of factorials.

<PRE>
(C1) N!/(N+1)!;
                                    N!
(D1)                             --------
                                 (N + 1)!
(C2) MINFACTORIAL(%);
                                     1
(D2)                               -----
                                   N + 1

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PARTFRAC</B> <I>(exp, var)</I>
<DD><A NAME="IDX804"></A>
expands the expression exp in partial fractions
with respect to the main variable, var.  PARTFRAC does a complete
partial fraction decomposition.  The algorithm employed is based on
the fact that the denominators of the partial fraction expansion (the
factors of the original denominator) are relatively prime.  The
numerators can be written as linear combinations of denominators, and
the expansion falls out.  See EXAMPLE(PARTFRAC); for examples.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PRIME</B> <I>(n)</I>
<DD><A NAME="IDX805"></A>
gives the nth prime. MAXPRIME[489318] is the largest number
accepted as argument.  Note:  The PRIME command does not work in
maxima, since it required a large file of primes, which most users
do not want.    PRIMEP does work however.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PRIMEP</B> <I>(n)</I>
<DD><A NAME="IDX806"></A>
returns TRUE if n is a prime, FALSE if not.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>QUNIT</B> <I>(n)</I>
<DD><A NAME="IDX807"></A>
gives the principal unit of the real quadratic number field
SQRT(n) where n is an integer, i.e.  the element whose norm is unity.
This amounts to solving Pell's equation A**2- n*B**2=1.

<PRE>
(C1) QUNIT(17);
(D1)              SQRT(17)+4
(C2)  EXPAND(%*(SQRT(17)-4));
(D2)               1

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>TOTIENT</B> <I>(n)</I>
<DD><A NAME="IDX808"></A>
is the number of integers less than or equal to n which
are relatively prime to n.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>ZEROBERN</B>
<DD><A NAME="IDX809"></A>
 default: [TRUE] - if set to FALSE excludes the zero
BERNOULLI numbers.  (See the BERN function.)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ZETA</B> <I>(X)</I>
<DD><A NAME="IDX810"></A>
gives the Riemann zeta function for certain integer values
of X.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>ZETA%PI</B>
<DD><A NAME="IDX811"></A>
 default: [TRUE] - if FALSE, suppresses ZETA(n) giving
coeff*%PI^n for n even.

</P>
</DL>

<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_30.html">previous</A>, <A HREF="maxima_32.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
