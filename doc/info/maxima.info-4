This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Lists,  Prev: Introduction to Lists,  Up: Lists

38.2 Definitions for Lists
==========================

 -- Function: append (<list_1>, ..., <list_n>)
     Returns a single list of the elements of <list_1> followed by the
     elements of <list_2>, ...  `append' also works on general
     expressions, e.g. `append (f(a,b), f(c,d,e));' yields
     `f(a,b,c,d,e)'.

     Do `example(append);' for an example.


 -- Function: assoc (<key>, <list>, <default>)
 -- Function: assoc (<key>, <list>)
     This function searches for the <key> in the left hand side of the
     input <list> of the form `[x,y,z,...]' where each of the <list>
     elements is an expression of a binary operand and 2 elements.  For
     example `x=1', `2^3', `[a,b]' etc.  The <key> is checked againts
     the first operand.  `assoc' returns the second operand if the
     `key' is found.  If the `key' is not found it either returns the
     <default> value.  <default> is optional and defaults to `false'.


 -- Function: atom (<expr>)
     Returns `true' if <expr> is atomic (i.e. a number, name or string)
     else `false'.  Thus `atom(5)' is `true' while `atom(a[1])' and
     `atom(sin(x))' are `false' (asuming `a[1]' and `x' are unbound).


 -- Function: cons (<expr>, <list>)
     Returns a new list constructed of the element <expr> as its first
     element, followed by the elements of <list>.  `cons' also works on
     other expressions, e.g. `cons(x, f(a,b,c));'  ->  `f(x,a,b,c)'.


 -- Function: copylist (<list>)
     Returns a copy of the list <list>.


 -- Function: create_list (<form>, <x_1>, <list_1>, ..., <x_n>,
          <list_n>)
     Create a list by evaluating <form> with <x_1> bound to each
     element of <list_1>, and for each such binding bind <x_2> to each
     element of <list_2>, ....  The number of elements in the result
     will be the product of the number of elements in each list.  Each
     variable <x_i> must actually be a symbol - it will not be
     evaluated.  The list arguments will be evaluated once at the
     beginning of the iteration.

          (%i1) create_list(x^i,i,[1,3,7]);
                           3   7
          (%o1)       [x, x , x ]

     With a double iteration:

          (%i1) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     Instead of <list_i> two args may be supplied each of which should
     evaluate to a number.  These will be the inclusive lower and upper
     bounds for the iteration.

          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

     Note that the limits or list for the <j> variable can depend on
     the current value of <i>.


 -- Function: delete (<expr_1>, <expr_2>)
 -- Function: delete (<expr_1>, <expr_2>, <n>)
     Removes all occurrences of <expr_1> from <expr_2>.  <expr_1> may
     be a term of <expr_2> (if it is a sum) or a factor of <expr_2> (if
     it is a product).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     `delete(<expr_1>, <expr_2>, <n>)' removes the first <n>
     occurrences of <expr_1> from <expr_2>.  If there are fewer than <n>
     occurrences of <expr_1> in <expr_2> then all occurrences will be
     deleted.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)


 -- Function: eighth (<expr>)
     Returns the 8'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: endcons (<expr>, <list>)
     Returns a new list consisting of the elements of `list' followed
     by <expr>.  `endcons' also works on general expressions, e.g.
     `endcons(x, f(a,b,c));'  ->  `f(a,b,c,x)'.


 -- Function: fifth (<expr>)
     Returns the 5'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: first (<expr>)
     Returns the first part of <expr> which may result in the first
     element of a list, the first row of a matrix, the first term of a
     sum, etc.  Note that `first' and its related functions, `rest' and
     `last', work on the form of <expr> which is displayed not the form
     which is typed on input.  If the variable `inflag' is set to
     `true' however, these functions will look at the internal form of
     <expr>.  Note that the simplifier re-orders expressions.  Thus
     `first(x+y)' will be `x' if `inflag' is `true' and `y' if `inflag'
     is `false' (`first(y+x)' gives the same results).  The functions
     `second' .. `tenth' yield the second through the tenth part of
     their input argument.


 -- Function: fourth (<expr>)
     Returns the 4'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: get (<a>, <i>)
     Retrieves the user property indicated by <i> associated with atom
     <a> or returns `false' if a doesn't have property <i>.

     `get' evaluates its arguments.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Function: join (<l>, <m>)
     Creates a new list containing the elements of lists <l> and <m>,
     interspersed.  The result has elements `[<l>[1], <m>[1], <l>[2],
     <m>[2], ...]'.  The lists <l> and <m> may contain any type of
     elements.

     If the lists are different lengths, `join' ignores elements of the
     longer list.

     Maxima complains if <L_1> or <L_2> is not a list.

     Examples:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Function: last (<expr>)
     Returns the last part (term, row, element, etc.) of the <expr>.


 -- Function: length (<expr>)
     Returns (by default) the number of parts in the external
     (displayed) form of <expr>.  For lists this is the number of
     elements, for matrices it is the number of rows, and for sums it
     is the number of terms (see `dispform').

     The `length' command is affected by the `inflag' switch.  So, e.g.
     `length(a/(b*c));' gives 2 if `inflag' is `false' (Assuming
     `exptdispflag' is `true'), but 3 if `inflag' is `true' (the
     internal representation is essentially `a*b^-1*c^-1').


 -- Option variable: listarith
     default value: `true' - if `false' causes any arithmetic operations
     with lists to be suppressed; when `true', list-matrix operations
     are contagious causing lists to be converted to matrices yielding
     a result which is always a matrix.  However, list-list operations
     should return lists.


 -- Function: listp (<expr>)
     Returns `true' if <expr> is a list else `false'.


 -- Function: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Function: makelist (<expr>, <x>, <list>)
     Constructs and returns a list, each element of which is generated
     from <expr>.

     `makelist (<expr>, <i>, <i_0>, <i_1>)' returns a list, the `j''th
     element of which is equal to `ev (<expr>, <i>=j)' for `j' equal to
     <i_0> through <i_1>.

     `makelist (<expr>, <x>, <list>)' returns a list, the `j''th
     element of which is equal to `ev (<expr>, <x>=<list>[j])' for `j'
     equal to 1 through `length (<list>)'.

     Examples:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Function: member (<expr>, <list>)
     Returns `true' if <expr> occurs as a member of <list> (not within
     a member).  Otherwise `false' is returned.  `member' also works on
     non-list expressions, e.g. `member(b,f(a,b,c));'  ->  `true'.


 -- Function: ninth (<expr>)
     Returns the 9'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: rest (<expr>, <n>)
 -- Function: rest (<expr>)
     Returns <expr> with its first <n> elements removed if <n> is
     positive and its last `- <n>' elements removed if <n> is negative.
     If <n> is 1 it may be omitted.  <expr> may be a list, matrix, or
     other expression.


 -- Function: reverse (<list>)
     Reverses the order of the members of the <list> (not the members
     themselves).  `reverse' also works on general expressions, e.g.
     `reverse(a=b);' gives `b=a'.


 -- Function: second (<expr>)
     Returns the 2'nd item of expression or list <expr>.  See `first'
     for more details.


 -- Function: seventh (<expr>)
     Returns the 7'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: sixth (<expr>)
     Returns the 6'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: tenth (<expr>)
     Returns the 10'th item of expression or list <expr>.  See `first'
     for more details.


 -- Function: third (<expr>)
     Returns the 3'rd item of expression or list <expr>.  See `first'
     for more details.



File: maxima.info,  Node: Sets,  Next: Function Definition,  Prev: Lists,  Up: Top

39 Sets
*******

* Menu:

* Introduction to Sets::
* Definitions for Sets::


File: maxima.info,  Node: Introduction to Sets,  Next: Definitions for Sets,  Prev: Sets,  Up: Sets

39.1 Introduction to Sets
=========================

Maxima provides set functions, such as intersection and union, for
finite sets that are defined by explicit enumeration.  Maxima treats
lists and sets as distinct objects. This feature makes it possible to
work with sets that have members that are either lists or sets.

   In addition to functions for finite sets, Maxima provides some
functions related to combinatorics; these include the Stirling numbers
of the first and second kind, the Bell numbers, multinomial
coefficients, partitions of nonnegative integers, and a few others.
Maxima also defines a Kronecker delta function.

39.1.1 Usage
------------

To construct a set with members `a_1, ..., a_n', write `set(a_1, ...,
a_n)' or `{a_1, ..., a_n}'; to construct the empty set, write `set()'
or `{}'.  In input, `set (...)' and `{ ... }' are equivalent.  Sets are
always displayed with curly braces.

   If a member is listed more than once, the simplification process
eliminates the redundant member.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   Two would-be elements <x> and <y> are redundant (i.e., considered
the same for the purposes of set construction) if and only if `is (<x>
= <y>)' yields `true'.  Note that `is (equal (<x>, <y>))' can yield
`true' while `is (<x> = <y>)' yields `false'; in that case the elements
<x> and <y> are considered distinct.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) set (x, y, z);
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   To construct a set from the elements of a list, use  `setify'.

     (%i1) setify([b, a]);
     (%o1)                        {a, b}

   Set members `x' and `y' are equal provided `is(x = y)' evaluates to
true. Thus `rat(x)' and `x' are equal as set members; consequently,

     (%i1) set(x, rat(x));
     (%o1)                          {x}

   Further, since `is((x-1)*(x+1) = x^2 - 1)' evaluates to false,
`(x-1)*(x+1)' and `x^2-1' are distinct set members; thus

     (%i1) set((x - 1)*(x + 1), x^2 - 1);
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   To reduce this set to a singleton set, apply `rat' to each set
member:

     (%i1) set((x - 1)*(x + 1), x^2 - 1);
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map(rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   To remove redundancies from other sets, you may need to use other
simplification functions.  Here is an example that uses `trigsimp':

     (%i1) set(1, cos(x)^2 + sin(x)^2);
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map(trigsimp, %);
     (%o2)                          {1}

   A set is simplified when its members are non-redundant and sorted.
The current version of the set functions uses the Maxima function
`orderlessp' to order sets; however, future versions of the set
functions might use a different ordering function.

   Some operations on sets, such as substitution, automatically force a
re-simplification; for example,

     (%i1) s: set (a, b, c)$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima treats lists and sets as distinct objects; functions such as
`union' and `intersection' will signal an error if any argument is a
list.  If you need to apply a set function to a list, use the `setify'
function to convert it to a set.  Thus

     (%i1) union ([1, 2], set (a, b));
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), set (a, b));
     (%o2)                     {1, 2, a, b}

   To extract all set elements of a set `s' that satisfy a predicate
`f', use `subset(s,f)'. (A predicate is a boolean-valued function.) For
example, to find the equations in a given set that do not depend on a
variable `z', use

     (%i1) subset (set (x + y + z, x - y + 4, x + y - 5), lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   The section *Note Definitions for Sets:: has a complete list of the
set functions in Maxima.

39.1.2 Set Member Iteration
---------------------------

There two ways to to iterate over set members.  One way is the use
`map'; for example:

     (%i1) map (f, set (a, b, c));
     (%o1)                  {f(a), f(b), f(c)}

   The other way is to use `for <x> in <s> do'

     (%i1) s: set (a, b, c);
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   The Maxima functions `first' and `rest' work correctly on sets.
Applied to a set, `first' returns the first displayed element of a set;
which element that is may be implementation-dependent. If `s' is a set,
then `rest(s)' is equivalent to `disjoin (first(s), s)'.  Currently,
there are other Maxima functions that work correctly on sets.  In
future versions of the set functions, `first' and `rest' may function
differently or not at all.

39.1.3 Bugs
-----------

The set functions use the Maxima function `orderlessp' to order set
members and the (Lisp-level) function `like' to test for set member
equality.  Both of these functions have known bugs that may manifest if
you attempt to use sets with members that are lists or matrices that
contain expressions in CRE form. An example is

     (%i1) set ([x], [rat (x)]);
     Maxima encountered a Lisp error:

      CAR: #:X13129 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   This command causes Maxima to halt with an error (the error message
depends on which version of Lisp your Maxima uses). Another example is

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

      CAR: #:A13129 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   These bugs are caused by bugs in `orderlessp' and `like'; they are
not caused by bugs in the set functions. To illustrate, try the commands

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

      CAR: #:B13130 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Until these bugs are fixed, do not construct sets with members that
are lists or matrices containing expressions in CRE form; a set with a
member in CRE form, however, shouldn't be a problem:

     (%i1) set (x, rat (x));
     (%o1)                          {x}

   Maxima's `orderlessp' has another bug that can cause problems with
set functions, namely that the ordering predicate `orderlessp' is not
transitive. The simplest known example that shows this is

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   This bug can cause trouble will all set functions as well as with
Maxima functions in general. It's likely, but not certain, that if all
set members are either in CRE form or have been simplified using
`ratsimp', this bug will not manifest.

   Maxima's `orderless' and `ordergreat' mechanisms are incompatible
with the set functions. If you need to use either `orderless' or
`ordergreat', issue these commands before constructing any sets and do
not use the `unorder' command.

   Maxima's sign function has a bug that may cause the Kronecker delta
function to misbehave; for example:

     (%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
     (%o1)                           0

   The correct value is 1; the bug is related to the `sign' bug

     (%i1) sign (1/sqrt(2) - sqrt(2)/2);
     (%o1)                          pos

   If you find something that you think might be a set function bug,
please report it to the Maxima bug database. See `bug_report'.

39.1.4 Authors
--------------

Stavros Macrakis of Cambridge, Massachusetts and Barton Willis of the
University of Nebraska at Kearney (UNK) wrote the Maxima set functions
and their documentation.


File: maxima.info,  Node: Definitions for Sets,  Prev: Introduction to Sets,  Up: Sets

39.2 Definitions for Sets
=========================

 -- Function: adjoin (<x>, <a>)
     Adjoin <x> to the set <a> and return a set. Thus `adjoin(<x>, <a>)'
     and `union(set(x),a)' are equivalent; however, using `adjoin' may
     be somewhat faster than using `union'. If <a> isn't a set, signal
     an error.

          (%i1) adjoin (c, set (a, b));
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, set (a, b));
          (%o2)                        {a, b}

     See also `disjoin'.

 -- Function: belln (<n>)
     For nonnegative integers <n>, return the n-th Bell number. If `s'
     is a set with `n' members,  `belln(n)' is the number of partitions
     of `s'.  For example:

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions (set ())) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions (set (1, 2, 3, 4, 5, 6))) = belln (6));
          (%o3)                         true

     When <n> isn't a nonnegative integer, `belln(n)' doesn't simplify.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

     The function `belln' threads over equalities, lists, matrices, and
     sets.

 -- Function: cardinality (<a>)
     Return the number of distinct elements of the set <a>.

          (%i1) cardinality (set ());
          (%o1)                           0
          (%i2) cardinality (set (a, a, b, c));
          (%o2)                           3
          (%i3) cardinality (set (a, a, b, c)), simp: false;
          (%o3)                           3

     In line (%o3), we see that cardinality works correctly even when
     simplification has been turned off.

 -- Function: cartesian_product (<b_1>, ... , <b_n>)
     Return a set of lists of the form `[<x_1>, ..., <x_n>]', where
     `<x_1> in <b_1>', ..., `<x_n> in <b_n>'.  Signal an error when any
     <b_k> isn't a set.

          (%i1) cartesian_product (set (0, 1));
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product (set (0, 1), set (0, 1));
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product (set (x), set (y), set (z));
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product (set (x), set (-1, 0, 1));
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Function: disjoin (<x>, <a>)
     Remove <x> from the set <a> and return a set.  If <x> isn't a
     member of <a>, return <a>. Each of the following do the same
     thing: `disjoin(<x>, <a>)', `delete(<x>, <a>)', and
     `setdifference(<a>,set(<x>))'; however, `disjoin' is generally the
     fastest way to remove a member from a set.  Signal an error if <a>
     isn't a set.

 -- Function: disjointp (<a>, <b>)
     Return `true' if the sets <a> and <b> are disjoint. Signal an
     error if either <a> or <b> isn't a set.

 -- Function: divisors (<n>)
     When <n> is a nonzero integer, return the set of its divisors.
     The set of divisors includes the members 1 and <n>.  The divisors
     of a negative integer are the divisors of its absolute value.

     We can verify that 28 is a perfect number.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     The function divisors works by simplification; you shouldn't need
     to manually re-evaluate after a substitution. For example:

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     The function divisors threads over equalities, lists, matrices, and
     sets. Here is an example of threading over a list and an equality.

          (%i1) divisors ([a, b, c=d]);
          (%o1) [divisors(a), divisors(b), divisors(c) = divisors(d)]

 -- Function: elementp (<x>, <a>)
     Return `true' if and only if  <x> is a member of the set <a>.
     Signal an error if <a> isn't a set.

 -- Function: emptyp (<a>)
     Return `true' if and only if <a> is the empty set or the empty
     list.

          (%i1) map (emptyp, [set (), []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, set (set ()), %pi]);
          (%o2)                 [false, false, false]

 -- Function: equiv_classes (<s>, <f>)
     Return a set of the equivalence classes of <s> with respect to the
     equivalence relation <f>. The function <f> should be a
     boolean-valued function defined on the cartesian product of <s>
     with <s>. Further, the function <f> should be an equivalence
     relation; `equiv_classes', however, doesn't check that it is.

          (%i1) equiv_classes (set (a, b, c), lambda ([x, y], is (x=y)));
          (%o1)                    {{a}, {b}, {c}}

     Actually, `equiv_classes (<s>, <f>)' automatically applies the
     Maxima function `is' after applying the function <f>; accordingly,
     we can restate the previous example more briefly.

          (%i1) equiv_classes (set (a, b, c), "=");
          (%o1)                    {{a}, {b}, {c}}

     Here is another example.

          (%i1) equiv_classes (set (1, 2, 3, 4, 5, 6, 7), lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Function: every (<f>, <a>)
 -- Function: every (<f>, <L_1>, ..., <L_n>)
     The first argument <f> should be a predicate (a function that
     evaluates to true, false, or unknown).

     Given one set as the second argument, `every (<f>, <a>)' returns
     `true' if `<f>(<a_i>)' returns `true' for all <a_i> in <a>.  Since
     sets are unordered, `every' is free to evaluate `<f>(<a_i>)' in any
     order. `every' may or may not evaluate <f> for all <a_i> in <a>.
     Because the order of evaluation isn't specified, the predicate <f>
     should not have side-effects or signal errors for any input.

     Given one or more lists as arguments, `every (<f>, <L_1>, ...,
     <L_n>)' returns `true' if `<f>(<x_1>, ..., <x_n>)' returns `true'
     for all <x_1>, ..., <x_n> in <L_1>, ..., <L_n>, respectively.
     `every' may or may not evaluate <f> for every combination <x_1>,
     ..., <x_n>.  Since lists are ordered, `every' evaluates in the
     order of increasing index.

     To use `every' on multiple set arguments, they should first be
     converted to an ordered sequence so that their relative alignment
     becomes well-defined.

     If the global flag `maperror' is `true' (the default), all lists
     <L_1>, ..., <L_n> must have equal lengths - otherwise, `every'
     signals an error.  When `maperror' is false, the list arguments are
     effectively truncated each to the length of the shortest list.

     The Maxima function `is' automatically applied after evaluating the
     predicate <f>.

          (%i1) every ("=", [a, b], [a, b]);
          (%o1)                         true
          (%i2) every ("#", [a, b], [a, b]);
          (%o2)                         false

 -- Function: extremal_subset (<s>, <f>, max)
 -- Function: extremal_subset (<s>, <f>, min)
     When the third argument is max, return the subset of the set or
     list <s> for which the real-valued function <f> takes on its
     greatest value; when the third argument is min, return the subset
     for which <f> takes on its least value.

          (%i1) extremal_subset (set (-2, -1, 0, 1, 2), abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset (set (sqrt(2), 1.57, %pi/2), sin, min);
          (%o2)                       {sqrt(2)}

 -- Function: flatten (<e>)
     Flatten essentially evaluates an expression as if its main
     operator had been declared n-ary; there is, however, one
     difference - flatten doesn't recurse into other function
     arguments.  For example:

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     Applied to a set, flatten gathers all members of set elements that
     are sets; for example:

          (%i1) flatten (set (a, set (b), set (set (c))));
          (%o1)                       {a, b, c}
          (%i2) flatten (set (a, set ([a], set (a))));
          (%o2)                       {a, [a]}

     Flatten works correctly when the main operator is a subscripted
     function

          (%i1) flatten (f[5] (f[5] (x)));
          (%o1)                         f (x)
                                         5

     To flatten an expression, the main operator must be defined for
     zero or more arguments;  if this isn't the case, Maxima will halt
     with an error.  Expressions with special representations, for
     example CRE expressions, can't be flattened; in this case, flatten
     returns its argument unchanged.

 -- Function: full_listify (<a>)
     If <a> is a set, convert <a> to a list and apply `full_listify' to
     each list element.

     To convert just the top-level operator of a set to a list, see
     *Note listify::.

 -- Function: fullsetify (<a>)
     If <a> is a list, convert <a> to a set and apply `fullsetify' to
     each set member.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

     In line (%o2), the argument of `f' isn't converted to a set
     because the main operator of `f([b])' isn't a list.

     To convert just the top-level operator of a list to a set, see
     *Note setify::.

 -- Function: identity (<x>)
     The identity function evaluates to its argument for all inputs.  To
     determine if every member of a set is `true', you can use

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Function: integer_partitions (<n>)
 -- Function: integer_partitions (<n>, <len>)
     If the optional second argument <len> isn't specified, return the
     set of all partitions of the integer <n>.  When <len> is specified,
     return all partitions that have length <len> or less; in this
     case, zeros are appended to each partition with fewer than <len>
     terms to make each partition have exactly <len> terms.  In either
     case, each partition is a list sorted from greatest to least.

     We say a list [a_1, ..., a_m] is a partition of a nonnegative
     integer n provided (1) each a_i is a nonzero integer and (2) a_1 +
     ... + a_m  = n.  Thus 0 has no partitions.

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     To find all partitions that satisfy a condition, use the function
     `subset'; here is an example that finds all partitions of 10 that
     consist of prime numbers.

          (%i1) s: integer_partitions (10)$
          (%i2) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i3) subset (s, lambda ([x], every (xprimep, x)));
          (%o3) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

     (Notice that `primep(1)' is true in Maxima. This disagrees with
     most definitions of prime.)

 -- Function: intersect (<a_1>, ..., <a_n>)
     Return a set containing the elements that are common to the sets
     <a_1> through <a_n>. The function `intersect' must receive one or
     more arguments. Signal an error if any of <a_1> through <a_n>
     isn't a set.  See also *Note intersection::.

 -- Function: intersection (<a_1>, ..., <a_n>)
     Return a set containing the elements that are common to the sets
     <a_1> through <a_n>. The function `intersection' must receive one
     or more arguments. Signal an error if any of <a_1> through <a_n>
     isn't a set.  See also *Note intersect::.

 -- Function: kron_delta (<x>, <y>)
     The Kronecker delta function; `kron_delta (<x>, <y>)' simplifies to
     1 when `is(x = y)' is true and it simplifies to zero when `sign
     (|<x> - <y>|)' is `pos'.  When `sign (|<x> - <y>|)' is zero and
     `<x> - <y>' isn't a floating point number (neither a double nor a
     bfloat), return 0. Otherwise, return a noun form.

     The function, `kron_delta' is declared to be symmetric; thus, for
     example, `kron_delta(x, y) - kron_delta(y, x)' simplifies to zero.

     Here are a few examples.

          (%i1) [kron_delta (a, a), kron_delta (a + 1, a)];
          (%o1)                        [1, 0]
          (%i2) kron_delta (a, b);
          (%o2)                   kron_delta(a, b)

     Assuming that `a > b' makes `sign (|a - b|)' evaluate to `pos';
     thus

          (%i1) assume (a > b)$
          (%i2) kron_delta (a, b);
          (%o2)                           0

     If we instead assume that `x >= y', then `sign (|x - y|)' evaluates
     to `pz'; in this case, `kron_delta (x, y)' doesn't simplify

          (%i1) assume(x >= y)$
          (%i2) kron_delta (x, y);
          (%o2)                   kron_delta(x, y)

     Finally, since `1/10 - 0.1' evaluates to a floating point number,
     we have

          (%i1) kron_delta (1/10, 0.1);
                                            1
          (%o1)                  kron_delta(--, 0.1)
                                            10

     If you want `kron_delta (1/10, 0.1)' to evaluate to 1, apply
     `float'.

          (%i1) float (kron_delta (1/10, 0.1));
          (%o1)                           1

 -- Function: listify (<a>)
     If <a> is a set, return a list containing the members of <a>; when
     <a> isn't a set, return <a>.  To convert a set and all of its
     members to lists, see *Note full_listify::.


 -- Function: lreduce (<f>, <s>)
 -- Function: lreduce (<f>, <s>, <init>)
     The function `lreduce' (left reduce) extends a 2-arity function to
     an n-arity function by composition; an example should make this
     clear. When the optional argument <init> isn't defined, we have

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     Notice that the function <f> is first applied to the `leftmost'
     list elements (thus the name lreduce).  When <init> is defined,
     the second argument to the inner most function evaluation is
     <init>; for example:

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     The function `lreduce' makes it easy to find the product or sum of
     the elements of a list.

          (%i1) lreduce ("+", args (set (a, b)));
          (%o1)                         b + a
          (%i2) lreduce ("*", args (set (1, 2, 3, 4, 5)));
          (%o2)                          120

     See also *Note rreduce::, *Note xreduce::, and *Note tree_reduce::.

 -- Function: makeset (<e>, <v>, <s>)
     This function is similar to `makelist', but `makeset' allows
     multiple substitutions. The first argument <e> is an expression;
     the second argument <v> is a list of variables; and <s> is a list
     or set of values for the variables <v>. Each member of <s> must
     have the same length as <v>. We have `makeset (<e>, <v>, <s>)' is
     the set `{z | z = substitute(v -> s_i) and s_i in s}'.

          (%i1) makeset (i/j, [i, j], [[a, b], [c, d]]);
                                        a  c
          (%o1)                        {-, -}
                                        b  d
          (%i2) ind: set (0, 1, 2, 3)$
          (%i3) makeset (i^2 + j^2 + k^2, [i, j, k], cartesian_product (ind, ind, ind));
          (%o3) {0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 17, 18,
                                                                19, 22, 27}

 -- Function: moebius (<n>)
     The Moebius function; when <n> is product of k distinct primes,
     `moebius(<n>)' evaluates to (-1)^k; it evaluates to 1 when <n> =
     1; and it evaluates to 0 for all other positive integers.  The
     Moebius function threads over equalities, lists, matrices, and
     sets.

 -- Function: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Function: multinomial_coeff ()
     Return the multinomial coefficient.  When each <a_k> is a
     nonnegative integer, the multinomial coefficient gives the number
     of ways of placing `<a_1> + ... + <a_n>' distinct objects into n
     boxes with <a_k> elements in the k'th box. In general,
     `multinomial (<a_1>, ..., <a_n>)' evaluates to `(<a_1> + ... +
     <a_n>)!/(<a_1>! ... <a_n>!)'. Given no arguments, `multinomial()'
     evaluates to 1. A user may use `minfactorial' to simplify the
     value returned by `multinomial_coeff'; for example:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Function: num_distinct_partitions (<n>)
 -- Function: num_distinct_partitions (<n>, <a>)
     When <n> is a nonnegative integer, return the number of distinct
     integer partitions of <n>.

     If the optional parameter <a> has the value `list', return a list
     of the number of distinct partitions of 1,2,3, ... , n.  If <n>
     isn't a nonnegative integer, return a noun form.

     Definition: If <n> = k_1 + ... + k_m, where k_1 through k_m  are
     distinct positive integers, we call k_1 + ... + k_m a distinct
     partition of <n>.

 -- Function: num_partitions (<n>)
 -- Function: num_partitions (<n>, <a>)
     When <n> is a nonnegative integer, return the number of partitions
     of <n>. If the optional parameter <a> has the value `list', return
     a list of the number of partitions of 1,2,3, ... , n.  If <n>
     isn't a nonnegative integer, return a noun form.

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

     For a nonnegative integer <n>, `num_partitions (<n>)' is equal to
     `cardinality (integer_partitions (<n>))'; however, calling
     `num_partitions' is much faster.

 -- Function: partition_set (<a>, <f>)
     Return a list of two sets; the first set is the subset of <a> for
     which the predicate <f> evaluates to false and the second is the
     subset of <a> for which <f> evaluates to true.  If <a> isn't a
     set, signal an error.  See also *Note subset::.

          (%i1) partition_set (set (2, 7, 1, 8, 2, 8), evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set (set (x, rat(y), rat(y) + z, 1), lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Function: permutations (<a>)
     Return a set of all distinct permutations of the members of the
     list or set <a>. (Each permutation is a list, not a set.)  When
     <a> is a list, duplicate members of <a> are not deleted before
     finding the permutations. Thus

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

     If <a> isn't a list or set, signal an error.

 -- Function: powerset (<a>)
 -- Function: powerset (<a>, <n>)
     When the optional second argument <n> isn't defined, return the set
     of all subsets of the set <a>.  `powerset(<a>)' has
     `2^cardinality(<a>)' members.  Given a second argument,
     `powerset(<a>,<n>)' returns the set of all subsets of <a> that have
     cardinality <n>. Signal an error if <a> isn't a set; additionally
     signal an error if <n> isn't a positive integer.

 -- Function: rreduce (<f>, <s>)
 -- Function: rreduce (<f>, <s>, <init>)
     The function `rreduce' (right reduce) extends a 2-arity function
     to an n-arity function by composition; an example should make this
     clear. When the optional argument <init> isn't defined, we have

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     Notice that the function <f> is first applied to the rightmost list
     elements (thus the name rreduce). When <init> is defined, the
     second argument to the inner most function evaluation is <init>;
     for example:

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     The function `rreduce' makes it easy to find the product or sum of
     the elements of a list.

          (%i1) rreduce ("+", args (set (a, b)));
          (%o1)                         b + a
          (%i2) rreduce ("*", args (set (1, 2, 3, 4, 5)));
          (%o2)                          120

     See also *Note lreduce::, *Note tree_reduce::, and *Note xreduce::.

 -- Function: setdifference (<a>, <b>)
     Return a set containing the elements in the set <a> that are not
     in the set <b>.  Signal an error if <a> or <b> is not a set.

 -- Function: setequalp (<a>, <b>)
     Returns `true' if sets <a> and <b> have the same number of elements
     and `is (<x> = <y>)' is `true' for `x' in the elements of <a> and
     `y' in the elements of <b>, considered in the order determined by
     `listify'.  Otherwise, `setequalp' returns `false'.

     `setequalp' complains when <a> or <b> is not a set.


 -- Function: setify (<a>)
     Construct a set from the elements of the list <a>.  Duplicate
     elements of the list <a> are deleted and the elements are sorted
     according to the predicate `orderlessp'.  Signal an error if `a'
     isn't a list.

 -- Function: setp (<a>)
     Return true if and only if <a> is a Maxima set.  The function
     `setp' checks that the operator of its argument is set; it doesn't
     check that its argument is a simplified set. Thus

          (%i1) setp (set (a, a)), simp: false;
          (%o1)                         true

     The function `setp' could be coded in Maxima as `setp(a) := is
     (inpart (a, 0) = set)'.


 -- Function: set_partitions (<a>)
 -- Function: set_partitions (<a>, <n>)
     When the optional argument <n> is defined, return a set of all
     decompositions of <a> into <n> <nonempty> disjoint subsets. When
     <n> isn't defined, return the set of all partitions.

     We say a set P is a partition of a set S provided

       1. each member of P is a nonempty set,

       2. distinct members of P are disjoint,

       3. the union of the members of P equals S.

     The empty set is a partition of itself (the conditions 1 and 2
     being vacuously true); thus

          (%i1) set_partitions (set ());
          (%o1)                         {{}}

     The cardinality of the set of partitions of a set can be found
     using `stirling2'; thus

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                        90 = 90
          (%i4) cardinality(p) = stirling2 (6, 3);

     Each member of `p' should have 3 members; let's check.

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                          {3}
          (%i4) map (cardinality, p);

     Finally, for each member of `p', the union of its members should
     equal `s'; again let's check.

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                 {{0, 1, 2, 3, 4, 5}}
          (%i4) map (lambda ([x], apply (union, listify (x))), p);

 -- Function: some (<f>, <a>)
 -- Function: some (<f>, <L_1>, ..., <L_n>)
     The first argument <f> should be a predicate (a function that
     evaluates to true, false, or unknown).

     Given one set as the second argument, `some (<f>, <a>)' returns
     `true' if `<f>(<a_i>)' returns `true' for at least one <a_i> in
     <a>.  Since sets are unordered, `some' is free to evaluate
     `<f>(<a_i>)' in any order. `some' may or may not evaluate  <f> for
     all <a_i> in <a>. Because the order of evaluation isn't specified,
     the predicate <f> should not have side-effects or signal errors
     for any input.  To use `some' on multiple set arguments, they
     should first be converted to an ordered sequence so that their
     relative alignment becomes well-defined.

     Given one or more lists as arguments, `some (<f>, <L_1>, ...,
     <L_n>)' returns `true' if `<f>(<x_1>, ..., <x_n>)' returns `true'
     for at least one <x_1>, ..., <x_n> in <L_1>, ..., <L_n>,
     respectively.  `some' may or may not evaluate <f> for every
     combination <x_1>, ..., <x_n>.  Since lists are ordered, `some'
     evaluates in the order of increasing index.

     If the global flag `maperror' is true (the default), all lists
     <L_1>, ..., <L_n> must have equal lengths - otherwise, `some'
     signals an error.  When `maperror' is false, the list arguments are
     effectively truncated each to the length of the shortest list.

     The Maxima function `is' is automatically applied after evaluating
     the predicate <f>.

          (%i1) some ("<", [a, b, 5], [1, 2, 8]);
          (%o1)                         true
          (%i2) some ("=", [2, 3], [2, 7]);
          (%o2)                         true

 -- Function: stirling1 (<n>, <m>)
     The Stirling number of the first kind.  When <n> and <m> are
     nonnegative integers, the magnitude of `stirling1 (<n>, <m>)' is
     the number of permutations of a set with <n> members that have <m>
     cycles.  For details, see Graham, Knuth and Patashnik Concrete
     Mathematics.  We use a recursion relation to define `stirling1
     (<n>, <m>)' for <m> less than 0; we do not extend it for <n> less
     than 0 or for non-integer arguments.

     The function `stirling1' works by simplification; it knows the
     basic special values (see Donald Knuth, The Art of Computer
     Programming, third edition, Volume 1,  Section 1.2.6, Equations
     48, 49, and 50).  For Maxima to apply these rules, the arguments
     must be declared to be integer and the first argument must
     nonnegative. For example:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' does not simplify for non-integer arguments.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima knows a few other special values; for example:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Function: stirling2 (<n>, <m>)
     The Stirling number of the second kind. When <n> and <m> are
     nonnegative integers, `stirling2 (<n>, <m>)' is the number of ways
     a set with cardinality <n> can be partitioned into <m> disjoint
     subsets.  We use a recursion relation to define `stirling2 (<n>,
     <m>)' for <m> less than 0; we do not extend it for <n> less than 0
     or for non-integer arguments.

     The function `stirling2' works by simplification; it knows the
     basic special values (see Donald Knuth, The Art of Computer
     Programming, third edition, Volume 1,  Section 1.2.6, Equations
     48, 49, and 50).  For Maxima to apply these rules, the arguments
     must be declared to be integer and the first argument must
     nonnegative. For example:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' does not simplify for non-integer arguments.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima knows a few other special values.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Function: subset (<a>, <f>)
     Return the subset of the set <a> that satisfies the predicate <f>.
     For example:

          (%i1) subset (set (1, 2, x, x + y, z, x + y + z), atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset (set (1, 2, 7, 8, 9, 14), evenp);
          (%o2)                      {2, 8, 14}

     The second argument to `subset' must be a predicate (a
     boolean-valued function of one argument) if the first argument to
     `subset' isn't a set, signal an error. See also *Note
     partition_set::.

 -- Function: subsetp (<a>, <b>)
     Return true if and only if the set <a> is a subset of <b>.  Signal
     an error if <a> or <b> is not a set.

 -- Function: symmdifference (<a_1>, ..., <a_n>)
     Return the set of members that occur in exactly one set <a_k>.
     Signal an error if any argument <a_k> isn't a set. Given two
     arguments, `symmdifference (<a>, <b>)' is the same as `union
     (setdifference (<a>, <b>), setdifference (<b>, <a>))'.

 -- Function: tree_reduce (<f>, <s>)
 -- Function: tree_reduce (<f>, <s>, <init>)
     The function `tree_reduce' extends a associative binary operator f
     : S x S -> S from two arguments to any number of arguments using a
     minimum depth tree.  An example should make this clear.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     Given an odd number of arguments, `tree_reduce' favors the left
     side of the tree; for example:

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

     For addition of floating point numbers, using `tree_reduce' may
     give a sum that has a smaller rounding error than using either
     `rreduce' or `lreduce'.

 -- Function: union (<a_1>, ..., <a_n>)
     Return the union of the sets <a_1> through <a_n>.  When `union'
     receives no arguments, it returns the empty set. Signal an error
     when one or more arguments to `union' is not a set.

 -- Function: xreduce (<f>, <s>)
 -- Function: xreduce (<f>, <s>, <init>)
     This function is similar to both `lreduce' and `rreduce' except
     that `xreduce' is free to use either left or right associativity;
     in particular when <f> is an associative function and Maxima has a
     built-in evaluator for it, `xreduce' may use the n-ary function;
     these n-ary functions include addition `+', multiplication `*',
     `and', `or', `max', `min', and `append'. For these operators, we
     generally expect using `xreduce' to be faster than using either
     `rreduce' or `lreduce'.  When <f> isn't n-ary, `xreduce' uses
     left-associativity.

     Floating point addition is not associative; nevertheless, `xreduce'
     uses Maxima's n-ary addition when the set or list <s> contains
     floating point numbers.



File: maxima.info,  Node: Function Definition,  Next: Program Flow,  Prev: Sets,  Up: Top

40 Function Definition
**********************

* Menu:

* Introduction to Function Definition::
* Function::
* Macros::
* Definitions for Function Definition::


File: maxima.info,  Node: Introduction to Function Definition,  Next: Function,  Prev: Function Definition,  Up: Function Definition

40.1 Introduction to Function Definition
========================================


File: maxima.info,  Node: Function,  Next: Macros,  Prev: Introduction to Function Definition,  Up: Function Definition

40.2 Function
=============

To define a function in Maxima you use the := operator.  E.g.

     f(x) := sin(x)

defines a function `f'.  Anonmyous functions may also be created using
`lambda'.  For example

     lambda ([i, j], ...)

can be used instead of `f' where

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

would return a list with 1 added to each term.

   You may also define a function with a variable number of arguments,
by having a final argument which is assigned to a list of the extra
arguments:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   The right hand side of a function is an expression.  Thus if you
want a sequence of expressions, you do

     f(x) := (expr1, expr2, ...., exprn);

   and the value of <exprn> is what is returned by the function.

   If you wish to make a `return' from some expression inside the
function then you must use `block' and `return'.

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   is itself an expression, and so could take the place of the right
hand side of a function definition.  Here it may happen that the return
happens earlier than the last expression.

   The first `[]' in the block, may contain a list of variables and
variable assignments, such as `[a: 3, b, c: []]', which would cause the
three variables `a',`b',and `c' to not refer to their global values,
but rather have these special values for as long as the code executes
inside the `block', or inside functions called from inside the `block'.
This is called dynamic binding, since the variables last from the
start of the block to the time it exits.  Once you return from the
`block', or throw out of it, the old values (if any) of the variables
will be restored.   It is certainly a good idea to protect your
variables in this way.   Note that the assignments in the block
variables, are done in parallel.   This means, that if you had used `c:
a' in the above, the value of `c' would have been the value of `a' at
the time you just entered the block, but before `a' was bound.   Thus
doing something like

     block ([a: a], expr1, ... a: a+3, ..., exprn)

   will protect the external value of `a' from being altered, but would
let you access what that value was.   Thus the right hand side of the
assignments, is evaluated in the entering context, before any binding
occurs.  Using just `block ([x], ...' would cause the `x' to have itself
as value, just as if it would have if you entered a fresh Maxima
session.

   The actual arguments to a function are treated in exactly same way as
the variables in a block.  Thus in

     f(x) := (expr1, ..., exprn);

   and

     f(1);

   we would have a similar context for evaluation of the expressions as
if we had done

     block ([x: 1], expr1, ..., exprn)

   Inside functions, when the right hand side of a definition, may be
computed at runtime, it is useful to use `define' and possibly `buildq'.


File: maxima.info,  Node: Macros,  Next: Definitions for Function Definition,  Prev: Function,  Up: Function Definition

40.3 Macros
===========

 -- Function: buildq (<L>, <expr>)
     Substitutes variables named by the list <L> into the expression
     <expr>, in parallel, without evaluating <expr>.  The resulting
     expression is simplified, but not evaluated, after `buildq'
     carries out the substitution.

     The elements of <L> are symbols or assignment expressions
     `<symbol>: <value>', evaluated in parallel.  That is, the binding
     of a variable on the right-hand side of an assignment is the
     binding of that variable in the context from which `buildq' was
     called, not the binding of that variable in the variable list <L>.
     If some variable in <L> is not given an explicit assignment, its
     binding in `buildq' is the same as in the context from which
     `buildq' was called.

     Then the variables named by <L> are substituted into <expr> in
     parallel.  That is, the substitution for every variable is
     determined before any substitution is made, so the substitution
     for one variable has no effect on any other.

     If any variable <x> appears as `splice (<x>)' in <expr>, then <x>
     must be bound to a list, and the list is spliced (interpolated)
     into <expr> instead of substituted.

     Any variables in <expr> not appearing in <L> are carried into the
     result verbatim, even if they have bindings in the context from
     which `buildq' was called.

     Examples

     `a' is explicitly bound to `x', while `b' has the same binding
     (namely 29) as in the calling context, and `c' is carried through
     verbatim.  The resulting expression is not evaluated until the
     explicit evaluation `''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' is bound to a list, which appears as such in the arguments of
     `foo', and interpolated into the arguments of `bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     The result is simplified after substitution.  If simplification
     were applied before substitution, these two results would be the
     same.
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     The variables in <L> are bound in parallel; if bound sequentially,
     the first result would be `foo (b, b)'.  Substitutions are carried
     out in parallel; compare the second result with the result of
     `subst', which carries out substitutions sequentially.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Construct a list of equations with some variables or expressions
     on the left-hand side and their values on the right-hand side.
     `macroexpand' shows the expression returned by `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)              [a = 17, b = 29, c = 1729]


 -- Function: macroexpand (<expr>)
     Returns the macro expansion of <expr> without evaluating it, when
     `expr' is a macro function call.  Otherwise, `macroexpand' returns
     <expr>.

     If the expansion of <expr> yields another macro function call,
     that macro function call is also expanded.

     `macroexpand' quotes its argument.  However, if the expansion of a
     macro function call has side effects, those side effects are
     executed.

     See also `::=', `macros', and `macroexpand1'.

     Examples

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Function: macroexpand1 (<expr>)
     Returns the macro expansion of <expr> without evaluating it, when
     `expr' is a macro function call.  Otherwise, `macroexpand1'
     returns <expr>.

     `macroexpand1' quotes its argument.  However, if the expansion of
     a macro function call has side effects, those side effects are
     executed.

     If the expansion of <expr> yields another macro function call,
     that macro function call is not expanded.

     See also `::=', `macros', and `macroexpand'.

     Examples

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Global variable: macros
     Default value: `[]'

     `macros' is the list of user-defined macro functions.  The macro
     function definition operator `::=' puts a new macro function onto
     this list, and `kill', `remove', and `remfunction' remove macro
     functions from the list.

     See also `infolists'.


 -- Function: splice (<a>)
     Splices (interpolates) the list named by the atom <a> into an
     expression, but only if `splice' appears within `buildq';
     otherwise, `splice' is treated as an undefined function.  If
     appearing within `buildq' as <a> alone (without `splice'), <a> is
     substituted (not interpolated) as a list into the result.  The
     argument of `splice' can only be an atom; it cannot be a literal
     list or an expression which yields a list.

     Typically `splice' supplies the arguments for a function or
     operator.  For a function `f', the expression `f (splice (<a>))'
     within `buildq' expands to `f (<a>[1], <a>[2], <a>[3], ...)'.  For
     an operator `o', the expression `"o" (splice (<a>)' within `buildq'
     expands to `"o" (<a>[1], <a>[2], <a>[3], ...)', where `o' may be
     any type of operator (typically one which takes multiple
     arguments).  Note that the operator must be enclosed in double
     quotes `"'.

     Examples

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Definitions for Function Definition,  Prev: Macros,  Up: Function Definition

40.4 Definitions for Function Definition
========================================

 -- Function: apply (<f>, [<x_1>, ..., <x_n>])
     Returns the result of applying the function <f> to the list of
     arguments <x_1>, ..., <x_n>.  <f> is the name of a function or a
     lambda expression.

     This is useful when it is desired to compute the arguments to a
     function before applying that function.  For example, if `l' is
     the list `[1, 5, -10.2, 4, 3]', then `apply (min, l)' gives -10.2.
     `apply' is also useful when calling functions which do not have
     their arguments evaluated if it is desired to cause evaluation of
     them.  For example, if `filespec' is a variable bound to the list
     `[test, case]' then `apply (closefile, filespec)' is equivalent to
     `closefile (test, case)'.  In general the first argument to
     `apply' should be preceded by a ' to make it evaluate to itself.
     Since some atomic variables have the same name as certain
     functions the values of the variable would be used rather than the
     function because `apply' has its first argument evaluated as well
     as its second.


 -- Function: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Function: block (<expr_1>, ..., <expr_n>)
     `block' evaluates <expr_1>, ..., <expr_n> in sequence and returns
     the value of the last expression evaluated.  The sequence can be
     modified by the `go', `throw', and `return' functions.  The last
     expression is <expr_n> unless `return' or an expression containing
     `throw' is evaluated.  Some variables <v_1>, ..., <v_m> can be
     declared local to the block; these are distinguished from global
     variables of the same names.  If no variables are declared local
     then the list may be omitted.  Within the block, any variable
     other than <v_1>, ..., <v_m> is a global variable.

     `block' saves the current values of the variables <v_1>, ...,
     <v_m> (if any) upon entry to the block, then unbinds the variables
     so that they evaluate to themselves.  The local variables may be
     bound to arbitrary values within the block but when the block is
     exited the saved values are restored, and the values assigned
     within the block are lost.

     `block' may appear within another `block'.  Local variables are
     established each time a new `block' is evaluated.  Local variables
     appear to be global to any enclosed blocks.  If a variable is
     non-local in a block, its value is the value most recently
     assigned by an enclosing block, if any, otherwise, it is the value
     of the variable in the global environment.  This policy may
     coincide with the usual understanding of "dynamic scope".

     If it is desired to save and restore other local properties
     besides `value', for example `array' (except for complete arrays),
     `function', `dependencies', `atvalue', `matchdeclare', `atomgrad',
     `constant', and `nonscalar' then the function `local' should be
     used inside of the block with arguments being the names of the
     variables.

     The value of the block is the value of the last statement or the
     value of the argument to the function `return' which may be used
     to exit explicitly from the block. The function `go' may be used
     to transfer control to the statement of the block that is tagged
     with the argument to `go'.  To tag a statement, precede it by an
     atomic argument as another statement in the block.  For example:
     `block ([x], x:1, loop, x: x+1, ..., go(loop), ...)'.  The
     argument to `go' must be the name of a tag appearing within the
     block.  One cannot use `go' to transfer to a tag in a block other
     than the one containing the `go'.

     Blocks typically appear on the right side of a function definition
     but can be used in other places as well.


 -- Function: break (<expr_1>, ..., <expr_n>)
     Evaluates and prints <expr_1>, ..., <expr_n> and then causes a
     Maxima break at which point the user can examine and change his
     environment.  Upon typing `exit;' the computation resumes.


 -- Function: catch (<expr_1>, ..., <expr_n>)
     Evaluates <expr_1>, ..., <expr_n> one by one; if any leads to the
     evaluation of an expression of the form `throw (arg)', then the
     value of the `catch' is the value of `throw (arg)', and no further
     expressions are evaluated.  This "non-local return" thus goes
     through any depth of nesting to the nearest enclosing `catch'.  If
     there is no `catch' enclosing a `throw', an error message is
     printed.

     If the evaluation of the arguments does not lead to the evaluation
     of any `throw' then the value of `catch' is the value of <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     The function `g' returns a list of `f' of each element of `l' if
     `l' consists only of non-negative numbers; otherwise, `g'
     "catches" the first negative element of `l' and "throws" it up.


 -- Function: compfile (<filename>, <f_1>, ..., <f_n>)
     Translates Maxima functions <f_1>, ..., <f_n> into Lisp and writes
     the translated code into the file <filename>.

     The Lisp translations are not evaluated, nor is the output file
     processed by the Lisp compiler.  `translate' creates and evaluates
     Lisp translations.  `compile_file' translates Maxima into Lisp,
     and then executes the Lisp compiler.

     See also `translate', `translate_file', and `compile_file'.


 -- Function: compile (<f_1>, ..., <f_n>)
 -- Function: compile (functions)
 -- Function: compile (all)
     Translates Maxima functions <f_1>, ..., <f_n> into Lisp, evaluates
     the Lisp translations, and calls the Lisp function `COMPILE' on
     each translated function.  `compile' returns a list of the names
     of the compiled functions.

     `compile (all)' or `compile (functions)' compiles all user-defined
     functions.

     `compile' quotes its arguments; the double-single-quotes operator
     `''' defeats quotation.


 -- Function: define (<f>(<x_1>, ..., <x_n>), <expr>)
     Defines a function named <f> with arguments <x_1>, ..., <x_n> and
     function body <expr>.

     `define' quotes its first argument in most cases, and evaluates
     its second argument unless explicitly quoted.  However, if the
     first argument is an expression of the form `ev (<expr>)',
     `funmake (<expr>)', or `arraymake (<expr>)', the first argument is
     evaluated; this allows for the function name to be computed, as
     well as the body.

     `define' is similar to the function definition operator `:=', but
     when `define' appears inside a function, the definition is created
     using the value of `expr' at execution time rather than at the
     time of definition of the function which contains it.

     All function definitions appear in the same namespace; defining a
     function `f' within another function `g' does not limit the scope
     of `f' to `g'.

     Examples:

          (%i1) foo: 2^bar;
                                         bar
          (%o1)                         2
          (%i2) g(x) := (f_1 (y) :=   foo*x*y,
                         f_2 (y) := ''foo*x*y,
                 define (f_3 (y),     foo*x*y),
                 define (f_4 (y),   ''foo*x*y));
                                                       bar
          (%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y,
                                                                  bar
                         define(f_3(y), foo x y), define(f_4(y), 2    x y))
          (%i3) functions;
          (%o3)                        [g(x)]
          (%i4) g(a);
                                              bar
          (%o4)                  f_4(y) := a 2    y
          (%i5) functions;
          (%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
          (%i6) dispfun (f_1, f_2, f_3, f_4);
          (%t6)                   f_1(y) := foo x y

                                            bar
          (%t7)                  f_2(y) := 2    x y

                                              bar
          (%t8)                  f_3(y) := a 2    y

                                              bar
          (%t9)                  f_4(y) := a 2    y

          (%o9)                         done

 -- Function: define_variable (<name>, <default_value>, <mode>)
     Introduces a global variable into the Maxima environment.
     `define_variable' is useful in user-written packages, which are
     often translated or compiled.

     `define_variable' carries out the following steps:

       1. `mode_declare (<name>, <mode>)' declares the mode of <name>
          to the translator.  See `mode_declare' for a list of the
          possible modes.

       2. If the variable is unbound, <default_value> is assigned to
          <name>.

       3. `declare (<name>, special)' declares it special.

       4. Associates <name> with a test function to ensure that <name>
          is only assigned values of the declared mode.

     The `value_check' property can be assigned to any variable which
     has been defined via `define_variable' with a mode other than
     `any'.  The `value_check' property is a lambda expression or the
     name of a function of one variable, which is called when an
     attempt is made to assign a value to the variable.  The argument
     of the `value_check' function is the would-be assigned value.

     `define_variable' evaluates `default_value', and quotes `name' and
     `mode'.  `define_variable' returns the current value of `name',
     which is `default_value' if `name' was unbound before, and
     otherwise it is the previous value of `name'.

     Examples:

     `foo' is a Boolean variable, with the initial value `true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' is an integer variable, which must be prime.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 is not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' is a variable which cannot be assigned a value.  The
     mode `any_check' is like `any', but `any_check' enables the
     `value_check' mechanism, and `any' does not.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux


 -- Function: dispfun (<f_1>, ..., <f_n>)
 -- Function: dispfun (all)
     Displays the definition of the user-defined functions <f_1>, ...,
     <f_n>.  Each argument may be the name of a macro (defined with
     `::='), an ordinary function (defined with `:=' or `define'), an
     array function (defined with `:=' or `define', but enclosing
     arguments in square brackets `[ ]'), a subscripted function,
     (defined with `:=' or `define', but enclosing some arguments in
     square brackets and others in parentheses `( )') one of a family
     of subscripted functions selected by a particular subscript value,
     or a subscripted function defined with a constant subscript.

     `dispfun (all)' displays all user-defined functions as given by
     the `functions', `arrays', and `macros' lists, omitting
     subscripted functions defined with constant subscripts.

     `dispfun' creates an intermediate expression label (`%t1', `%t2',
     etc.)  for each displayed function, and assigns the function
     definition to the label.  In contrast, `fundef' returns the
     function definition.

     `dispfun' quotes its arguments; the double-single-quote operator
     `''' defeats quotation.  `dispfun' returns the list of
     intermediate expression labels corresponding to the displayed
     functions.

     Examples:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10


 -- System variable: functions
     Default value: `[]'

     `functions' is the list of user-defined Maxima functions in the
     current session.  A user-defined function is a function
     constructed by `define' or `:='.  A function may be defined at the
     Maxima prompt or in a Maxima file loaded by `load' or `batch'.
     Lisp functions, however, are not added to `functions'.


 -- Function: fundef (<f>)
     Returns the definition of the function <f>.

     The argument may be the name of a macro (defined with `::='), an
     ordinary function (defined with `:=' or `define'), an array
     function (defined with `:=' or `define', but enclosing arguments
     in square brackets `[ ]'), a subscripted function, (defined with
     `:=' or `define', but enclosing some arguments in square brackets
     and others in parentheses `( )') one of a family of subscripted
     functions selected by a particular subscript value, or a
     subscripted function defined with a constant subscript.

     `fundef' quotes its argument; the double-single-quote operator
     `''' defeats quotation.

     `fundef (<f>)' returns the definition of <f>.  In contrast,
     `dispfun (<f>)' creates an intermediate expression label and
     assigns the definition to the label.


 -- Function: funmake (<name>, [<arg_1>, ..., <arg_n>])
     Returns an expression `<name> (<arg_1>, ..., <arg_n>)'.  The
     return value is simplified, but not evaluated, so the function is
     not called.

     `funmake' evaluates its arguments.

     Examples:

        * `funmake' evaluates its arguments, but not the return value.
               (%i1) det(a,b,c) := b^2 -4*a*c$
               (%i2) x: 8$
               (%i3) y: 10$
               (%i4) z: 12$
               (%i5) f: det$
               (%i6) funmake (f, [x, y, z]);
               (%o6)                    det(8, 10, 12)
               (%i7) ''%;
               (%o7)                         - 284

        * Maxima simplifies `funmake''s return value.
               (%i1) funmake (sin, [%pi/2]);
               (%o1)                           1


 -- Function: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Function: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Function: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ...,
          <expr_n>)
     Defines and returns a lambda expression (that is, an anonymous
     function).  The function may have required arguments <x_1>, ...,
     <x_m> and/or optional arguments <L>, which appear within the
     function body as a list.  The return value of the function is
     <expr_n>.  A lambda expression can be assigned to a variable and
     evaluated like an ordinary function.  A lambda expression may
     appear in some contexts in which a function name is expected.

     When the function is evaluated, unbound local variables <x_1>,
     ..., <x_m> are created.  `lambda' may appear within `block' or
     another `lambda'; local variables are established each time
     another `block' or `lambda' is evaluated.  Local variables appear
     to be global to any enclosed `block' or `lambda'.  If a variable
     is not local, its value is the value most recently assigned in an
     enclosing `block' or `lambda', if any, otherwise, it is the value
     of the variable in the global environment.  This policy may
     coincide with the usual understanding of "dynamic scope".

     After local variables are established, <expr_1> through <expr_n>
     are evaluated in turn.  The special variable `%%', representing
     the value of the preceding expression, is recognized.  `throw' and
     `catch' may also appear in the list of expressions.

     `return' cannot appear in a lambda expression unless enclosed by
     `block', in which case `return' defines the return value of the
     block and not of the lambda expression, unless the block happens
     to be <expr_n>.  Likewise, `go' cannot appear in a lambda
     expression unless enclosed by `block'.

     `lambda' quotes its arguments; the double-single-quote operator
     `''' defeats quotation.

     Examples:

        * A lambda expression can be assigned to a variable and
          evaluated like an ordinary function.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

        * A lambda expression may appear in contexts in which a
          function evaluation is expected.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

        * Argument variables are local variables.  Other variables
          appear to be global variables.  Global variables are
          evaluated at the time the lambda expression is evaluated,
          unless some special evaluation is forced by some means, such
          as `'''.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

        * Lambda expressions may be nested.  Local variables within the
          outer lambda expression appear to be global to the inner
          expression unless masked by local variables of the same names.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

        * Since `lambda' quotes its arguments, lambda expression `i'
          below does not define a "multiply by `a'" function.  Such a
          function can be defined via `buildq', as in lambda expression
          `i2' below.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

        * A lambda expression may take a variable number of arguments,
          which are indicated by `[<L>]' as the sole or final argument.
          The arguments appear within the function body as a list.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Function: local (<v_1>, ..., <v_n>)
     Declares the variables <v_1>, ..., <v_n> to be local with respect
     to all the properties in the statement in which this function is
     used.

     `local' quotes its arguments.  `local' returns `done'.

     `local' may only be used in `block', in the body of function
     definitions or `lambda' expressions, or in the `ev' function, and
     only one occurrence is permitted in each.

     `local' is independent of `context'.


 -- Option variable: macroexpansion
     Default value: `false'

     `macroexpansion' controls whether the expansion (that is, the
     return value) of a macro function is substituted for the macro
     function call.  A substitution may speed up subsequent expression
     evaluations, at the cost of storing the expansion.

    `false'
          The expansion of a macro function is not substituted for the
          macro function call.

    `expand'
          The first time a macro function call is evaluated, the
          expansion is stored.  The expansion is not recomputed on
          subsequent calls; any side effects (such as `print' or
          assignment to global variables) happen only when the macro
          function call is first evaluated.  Expansion in an expression
          does not affect other expressions which have the same macro
          function call.

    `displace'
          The first time a macro function call is evaluated, the
          expansion is substituted for the call, thus modifying the
          expression from which the macro function was called.  The
          expansion is not recomputed on subsequent calls; any side
          effects happen only when the macro function call is first
          evaluated.  Expansion in an expression does not affect other
          expressions which have the same macro function call.

     Examples

     When `macroexpansion' is `false', a macro function is called every
     time the calling expression is evaluated, and the calling
     expression is not modified.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     When `macroexpansion' is `expand', a macro function is called once,
     and the calling expression is not modified.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     When `macroexpansion' is `expand', a macro function is called once,
     and the calling expression is modified.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99


 -- Option variable: mode_checkp
     Default value: `true'

     When `mode_checkp' is `true', `mode_declare' checks the modes of
     bound variables.


 -- Option variable: mode_check_errorp
     Default value: `false'

     When `mode_check_errorp' is `true', `mode_declare' calls error.


 -- Option variable: mode_check_warnp
     Default value: `true'

     When `mode_check_warnp' is `true', mode errors are described.


 -- Function: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' is used to declare the modes of variables and
     functions for subsequent translation or compilation of functions.
     `mode_declare' is typically placed at the beginning of a function
     definition, at the beginning of a Maxima script, or executed at
     the interactive prompt.

     The arguments of `mode_declare' are pairs consisting of a variable
     and a mode which is one of `boolean', `fixnum', `number',
     `rational', or `float'.  Each variable may also be a list of
     variables all of which are declared to have the same mode.

     If a variable is an array, and if every element of the array which
     is referenced has a value then `array (yi, complete, dim1, dim2,
     ...)' rather than
          array(yi, dim1, dim2, ...)
     should be used when first declaring the bounds of the array.  If
     all the elements of the array are of mode `fixnum' (`float'), use
     `fixnum' (`float') instead of `complete'.  Also if every element
     of the array is of the same mode, say `m', then

          mode_declare (completearray (yi), m))

     should be used for efficient translation.

     Numeric code using arrays might run faster by declaring the
     expected size of the array, as in:

          mode_declare (completearray (a [10, 10]), float)

     for a floating point number array which is 10 x 10.

     One may declare the mode of the result of a function by using
     `function (f_1, f_2, ...)' as an argument; here `f_1', `f_2', ...
     are the names of functions.  For example the expression,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declares that the values returned by `f_1', `f_2', ... are
     single-word integers.

     `modedeclare' is a synonym for `mode_declare'.


 -- Function: mode_identity (<arg_1>, <arg_2>)
     A special form used with `mode_declare' and `macros' to declare,
     e.g., a list of lists of flonums, or other compound data object.
     The first argument to `mode_identity' is a primitive value mode
     name as given to `mode_declare' (i.e., one of `float', `fixnum',
     `number', `list', or `any'), and the second argument is an
     expression which is evaluated and returned as the value of
     `mode_identity'.  However, if the return value is not allowed by
     the mode declared in the first argument, an error or warning is
     signalled.  The important thing is that the mode of the expression
     as determined by the Maxima to Lisp translator, will be that given
     as the first argument, independent of anything that goes on in the
     second argument.  E.g., `x: 3.3; mode_identity (fixnum, x);'
     yields an error. `mode_identity (flonum, x)' returns 3.3 .  This
     has a number of uses, e.g., if you knew that `first (l)' returned a
     number then you might write `mode_identity (number, first (l))'.
     However, a more efficient way to do it would be to define a new
     primitive,

          firstnumb (x) ::= buildq ([x], mode_identity (number, x));

     and use `firstnumb' every time you take the first of a list of
     numbers.


 -- Option variable: transcompile
     Default value: `true'

     When `transcompile' is `true', `translate' and `translate_file'
     generate declarations to make the translated code more suitable
     for compilation.

     `compfile' sets `transcompile: true' for the duration.


 -- Function: translate (<f_1>, ..., <f_n>)
 -- Function: translate (functions)
 -- Function: translate (all)
     Translates the user-defined functions <f_1>, ..., <f_n> from the
     Maxima language into Lisp and evaluates the Lisp translations.
     Typically the translated functions run faster than the originals.

     `translate (all)' or `translate (functions)' translates all
     user-defined functions.

     Functions to be translated should include a call to `mode_declare'
     at the beginning when possible in order to produce more efficient
     code.  For example:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     where the <x_1>, <x_2>, ...  are the parameters to the function
     and the <v_1>, <v_2>, ... are the local variables.

     The names of translated functions are removed from the `functions'
     list if `savedef' is `false' (see below) and are added to the
     `props' lists.

     Functions should not be translated unless they are fully debugged.

     Expressions are assumed simplified; if they are not, correct but
     non- optimal code gets generated.  Thus, the user should not set
     the `simp' switch to `false' which inhibits simplification of the
     expressions to be translated.

     The switch `translate', if `true', causes automatic translation of
     a user's function to Lisp.

     Note that translated functions may not run identically to the way
     they did before translation as certain incompatabilities may exist
     between the Lisp and Maxima versions.  Principally, the `rat'
     function with more than one argument and the `ratvars' function
     should not be used if any variables are `mode_declare''d canonical
     rational expressions (CRE).  Also the `prederror: false' setting
     will not translate.

     `savedef' - if `true' will cause the Maxima version of a user
     function to remain when the function is `translate''d.  This
     permits the definition to be displayed by `dispfun' and allows the
     function to be edited.

     `transrun' - if `false' will cause the interpreted version of all
     functions to be run (provided they are still around) rather than
     the translated version.

     The result returned by `translate' is a list of the names of the
     functions translated.


 -- Function: translate_file (<maxima_filename>)
 -- Function: translate_file (<maxima_filename>, <lisp_filename>)
     Translates a file of Maxima code into a file of Lisp code.
     `translate_file' returns a list of three filenames: the name of
     the Maxima file, the name of the Lisp file, and the name of file
     containing additional information about the translation.
     `translate_file' evaluates its arguments.

     `translate_file ("foo.mac"); load("foo.LISP")' is the same as
     `batch ("foo.mac")' except for certain restrictions, the use of
     `''' and `%', for example.

     `translate_file (<maxima_filename>)' translates a Maxima file
     <maxima_filename> into a similarly-named Lisp file.  For example,
     `foo.mac' is translated into `foo.LISP'.  The Maxima filename may
     include a directory name or names, in which case the Lisp output
     file is written to the same directory from which the Maxima input
     comes.

     `translate_file (<maxima_filename>, <lisp_filename>)' translates a
     Maxima file <maxima_filename> into a Lisp file <lisp_filename>.
     `translate_file' ignores the filename extension, if any, of
     `lisp_filename'; the filename extension of the Lisp output file is
     always `LISP'.  The Lisp filename may include a directory name or
     names, in which case the Lisp output file is written to the
     specified directory.

     `translate_file' also writes a file of translator warning messages
     of various degrees of severity.  The filename extension of this
     file is `UNLISP'.  This file may contain valuable information,
     though possibly obscure, for tracking down bugs in translated code.
     The `UNLISP' file is always written to the same directory from
     which the Maxima input comes.

     `translate_file' emits Lisp code which causes some declarations
     and definitions to take effect as soon as the Lisp code is
     compiled.  See `compile_file' for more on this topic.

     See also `tr_array_as_ref', `tr_bound_function_applyp',
     `tr_exponent', `tr_file_tty_messagesp',
     `tr_float_can_branch_complex', `tr_function_call_default',
     `tr_numer', `tr_optimize_max_loop', `tr_semicompile',
     `tr_state_vars', `tr_warnings_get', `tr_warn_bad_function_calls',
     `tr_warn_fexpr', `tr_warn_meval', `tr_warn_mode',
     `tr_warn_undeclared', `tr_warn_undefined_variable', and `tr_windy'.


 -- Option variable: transrun
     Default value: `true'

     When `transrun' is `false' will cause the interpreted version of
     all functions to be run (provided they are still around) rather
     than the translated version.


 -- Option variable: tr_array_as_ref
     Default value: `true'

     If `translate_fast_arrays' is false, array references in Lisp code
     emitted by `translate_file' are affected by `tr_array_as_ref'.
     When `tr_array_as_ref' is `true', array names are evaluated,
     otherwise array names appear as literal symbols in translated code.

     `tr_array_as_ref' has no effect if `translate_fast_arrays' is
     `true'.


 -- Option variable: tr_bound_function_applyp
     Default value: `true'

     When `tr_bound_function_applyp' is `true', Maxima gives a warning
     if a bound variable (such as a function argument) is found being
     used as a function.  `tr_bound_function_applyp' does not affect
     the code generated in such cases.

     For example, an expression such as `g (f, x) := f (x+1)' will
     trigger the warning message.


 -- Option variable: tr_file_tty_messagesp
     Default value: `false'

     When `tr_file_tty_messagesp' is `true', messages generated by
     `translate_file' during translation of a file are displayed on the
     console and inserted into the UNLISP file.  When `false', messages
     about translation of the file are only inserted into the UNLISP
     file.


 -- Option variable: tr_float_can_branch_complex
     Default value: `true'

     Tells the Maxima-to-Lisp translator to assume that the functions
     `acos', `asin', `asec', and `acsc' can return complex results.

     The ostensible effect of `tr_float_can_branch_complex' is the
     following.  However, it appears that this flag has no effect on
     the translator output.

     When it is `true' then `acos(x)' is of mode `any' even if `x' is
     of mode `float' (as set by `mode_declare').  When `false' then
     `acos(x)' is of mode `float' if and only if `x' is of mode `float'.


 -- Option variable: tr_function_call_default
     Default value: `general'

     `false' means give up and call `meval', `expr' means assume Lisp
     fixed arg function.  `general', the default gives code good for
     `mexprs' and `mlexprs' but not `macros'.  `general' assures
     variable bindings are correct in compiled code.  In `general'
     mode, when translating F(X), if F is a bound variable, then it
     assumes that `apply (f, [x])' is meant, and translates a such, with
     apropriate warning. There is no need to turn this off.  With the
     default settings, no warning messages implies full compatibility of
     translated and compiled code with the Maxima interpreter.


 -- Option variable: tr_numer
     Default value: `false'

     When `tr_numer' is `true' numer properties are used for atoms
     which have them, e.g. `%pi'.


 -- Option variable: tr_optimize_max_loop
     Default value: 100

     `tr_optimize_max_loop' is the maximum number of times the
     macro-expansion and optimization pass of the translator will loop
     in considering a form.  This is to catch macro expansion errors,
     and non-terminating optimization properties.


 -- Option variable: tr_semicompile
     Default value: `false'

     When `tr_semicompile' is `true', `translate_file' and `compfile'
     output forms which will be macroexpanded but not compiled into
     machine code by the Lisp compiler.


 -- System variable: tr_state_vars
     Default value:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     The list of the switches that affect the form of the translated
     output.  This information is useful to system people when trying
     to debug the translator.  By comparing the translated product to
     what should have been produced for a given state, it is possible to
     track down bugs.


 -- Function: tr_warnings_get ()
     Prints a list of warnings which have been given by the translator
     during the current translation.


 -- Option variable: tr_warn_bad_function_calls
     Default value: `true'

     - Gives a warning when when function calls are being made which
     may not be correct due to improper declarations that were made at
     translate time.


 -- Option variable: tr_warn_fexpr
     Default value: `compfile'

     - Gives a warning if any FEXPRs are encountered.  FEXPRs should
     not normally be output in translated code, all legitimate special
     program forms are translated.


 -- Option variable: tr_warn_meval
     Default value: `compfile'

     - Gives a warning if the function `meval' gets called.  If `meval'
     is called that indicates problems in the translation.


 -- Option variable: tr_warn_mode
     Default value: `all'

     - Gives a warning when variables are assigned values inappropriate
     for their mode.


 -- Option variable: tr_warn_undeclared
     Default value: `compile'

     - Determines when to send warnings about undeclared variables to
     the TTY.


 -- Option variable: tr_warn_undefined_variable
     Default value: `all'

     - Gives a warning when undefined global variables are seen.


 -- Option variable: tr_windy
     Default value: `true'

     - Generate "helpfull" comments and programming hints.


 -- Function: compile_file (<filename>)
 -- Function: compile_file (<filename>, <compiled_filename>)
 -- Function: compile_file (<filename>, <compiled_filename>,
          <lisp_filename>)
     Translates the Maxima file <filename> into Lisp, executes the Lisp
     compiler, and, if the translation and compilation succeed, loads
     the compiled code into Maxima.

     `compile_file' returns a list of the names of four files: the
     original Maxima file, the Lisp translation, notes on translation,
     and the compiled code.  If the compilation fails, the fourth item
     is `false'.

     Some declarations and definitions take effect as soon as the Lisp
     code is compiled (without loading the compiled code).  These
     include functions defined with the `:=' operator, macros define
     with the `::=' operator, `alias', `declare', `define_variable',
     `mode_declare', and `infix', `matchfix', `nofix', `postfix',
     `prefix', and `compfile'.

     Assignments and function calls are not evaluated until the
     compiled code is loaded.  In particular, within the Maxima file,
     assignments to the translation flags (`tr_numer', etc.) have no
     effect on the translation.

     <filename> may not contain `:lisp' statements.

     `compile_file' evaluates its arguments.


 -- Function: declare_translated (<f_1>, <f_2>, ...)
     When translating a file of Maxima code to Lisp, it is important
     for the translator to know which functions it sees in the file are
     to be called as translated or compiled functions, and which ones
     are just Maxima functions or undefined.  Putting this declaration
     at the top of the file, lets it know that although a symbol does
     which does not yet have a Lisp function value, will have one at
     call time. `(MFUNCTION-CALL fn arg1 arg2 ...)' is generated when
     the translator does not know fn is going to be a Lisp function.



File: maxima.info,  Node: Program Flow,  Next: Debugging,  Prev: Function Definition,  Up: Top

41 Program Flow
***************

* Menu:

* Introduction to Program Flow::
* Definitions for Program Flow::


File: maxima.info,  Node: Introduction to Program Flow,  Next: Definitions for Program Flow,  Prev: Program Flow,  Up: Program Flow

41.1 Introduction to Program Flow
=================================

Maxima provides a `do' loop for iteration, as well as more primitive
constructs such as `go'.


File: maxima.info,  Node: Definitions for Program Flow,  Prev: Introduction to Program Flow,  Up: Program Flow

41.2 Definitions for Program Flow
=================================

 -- Function: backtrace ()
 -- Function: backtrace (<n>)
     Prints the call stack, that is, the list of functions which called
     the currently active function.

     `backtrace()' prints the entire call stack.

     `backtrace (<n>)' prints the <n> most recent functions, including
     the currently active function.

     `backtrace' can be called from a script, a function, or the
     interactive prompt (not only in a debugging context).

     Examples:

        * `backtrace()' prints the entire call stack.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * `backtrace (<n>)' prints the <n> most recent functions,
          including the currently active function.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49


 -- Special operator: do
     The `do' statement is used for performing iteration.  Due to its
     great generality the `do' statement will be described in two parts.
     First the usual form will be given which is analogous to that used
     in several other programming languages (Fortran, Algol, PL/I,
     etc.); then the other features will be mentioned.

     There are three variants of this form that differ only in their
     terminating conditions.  They are:

        * `for <variable>: <initial_value> step <increment>       thru
          <limit> do <body>'

        * `for <variable>: <initial_value> step <increment>       while
          <condition> do <body>'

        * `for <variable>: <initial_value> step <increment>
          unless <condition> do <body>'

     (Alternatively, the `step' may be given after the termination
     condition or limit.)

     <initial_value>, <increment>, <limit>, and <body> can be any
     expressions.  If the increment is 1 then "`step 1'" may be omitted.

     The execution of the `do' statement proceeds by first assigning the
     initial_value to the variable (henceforth called the
     control-variable). Then: (1) If the control-variable has exceeded
     the limit of a `thru' specification, or if the condition of the
     `unless' is `true', or if the condition of the `while' is `false'
     then the `do' terminates. (2) The body is evaluated.  (3) The
     increment is added to the control-variable.  The process from (1)
     to (3) is performed repeatedly until the termination condition is
     satisfied.  One may also give several termination conditions in
     which case the `do' terminates when any of them is satisfied.

     In general the `thru' test is satisfied when the control-variable
     is greater than the limit if the increment was non-negative, or
     when the control-variable is less than the limit if the increment
     was negative.  The increment and limit may be non-numeric
     expressions as long as this inequality can be determined.
     However, unless the increment is syntactically negative (e.g. is a
     negative number) at the time the `do' statement is input, Maxima
     assumes it will be positive when the `do' is executed.  If it is
     not positive, then the `do' may not terminate properly.

     Note that the limit, increment, and termination condition are
     evaluated each time through the loop.  Thus if any of these involve
     much computation, and yield a result that does not change during
     all the executions of the body, then it is more efficient to set a
     variable to their value prior to the `do' and use this variable in
     the `do' form.

     The value normally returned by a `do' statement is the atom `done'.
     However, the function `return' may be used inside the body to exit
     the `do' prematurely and give it any desired value.  Note however
     that a `return' within a `do' that occurs in a `block' will exit
     only the `do' and not the `block'.  Note also that the `go'
     function may not be used to exit from a `do' into a surrounding
     `block'.

     The control-variable is always local to the `do' and thus any
     variable may be used without affecting the value of a variable with
     the same name outside of the `do'.  The control-variable is unbound
     after the `do' terminates.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note that the condition `while i <= 10' is equivalent to `unless i
     > 10' and also `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     which gives 8 terms of the Taylor series for `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     This example computes the negative square root of 10 using the
     Newton- Raphson iteration a maximum of 10 times.  Had the
     convergence criterion not been met the value returned would have
     been `done'.

     Instead of always adding a quantity to the control-variable one
     may sometimes wish to change it in some other way for each
     iteration.  In this case one may use `next <expression>' instead
     of `step <increment>'.  This will cause the control-variable to be
     set to the result of evaluating expression each time through the
     loop.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     As an alternative to `for <variable>: <value> ...do...' the syntax
     `for <variable> from <value> ...do...'  may be used.  This permits
     the `from <value>' to be placed after the step or next value or
     after the termination condition.  If `from <value>' is omitted
     then 1 is used as the initial value.

     Sometimes one may be interested in performing an iteration where
     the control-variable is never actually used.  It is thus
     permissible to give only the termination conditions omitting the
     initialization and updating information as in the following
     example to compute the square-root of 5 using a poor initial guess.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     If it is desired one may even omit the termination conditions
     entirely and just give `do <body>' which will continue to evaluate
     the body indefinitely.  In this case the function `return' should
     be used to terminate execution of the `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note that `return', when executed, causes the current value of
     `x' to be returned as the value of the `do'.  The `block' is
     exited and this value of the `do' is returned as the value of the
     `block' because the `do' is the last statement in the block.)

     One other form of the `do' is available in Maxima.  The syntax is:

          for <variable> in <list> <end_tests> do <body>

     The elements of <list> are any expressions which will successively
     be assigned to the variable on each iteration of the body.  The
     optional termination tests <end_tests> can be used to terminate
     execution of the `do'; otherwise it will terminate when the list
     is exhausted or when a `return' is executed in the body.  (In
     fact, list may be any non-atomic expression, and successive parts
     are taken.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Function: errcatch (<expr_1>, ..., <expr_n>)
     Evaluates <expr_1>, ..., <expr_n> one by one and returns
     `[<expr_n>]' (a list) if no error occurs.  If an error occurs in
     the evaluation of any argument, `errcatch' prevents the error from
     propagating and returns the empty list `[]' without evaluating any
     more arguments.

     `errcatch' is useful in `batch' files where one suspects an error
     might occur which would terminate the `batch' if the error weren't
     caught.


 -- Function: error (<expr_1>, ..., <expr_n>)
 -- System variable: error
     Evaluates and prints <expr_1>, ..., <expr_n>, and then causes an
     error return to top level Maxima or to the nearest enclosing
     `errcatch'.

     The variable `error' is set to a list describing the error.  The
     first element of `error' is a format string, which merges all the
     strings among the arguments <expr_1>, ..., <expr_n>, and the
     remaining elements are the values of any non-string arguments.

     `errormsg()' formats and prints `error'.  This is effectively
     reprinting the most recent error message.


 -- Function: errormsg ()
     Reprints the most recent error message.  The variable `error'
     holds the message, and `errormsg' formats and prints it.


 -- Special operator: for
     Used in iterations. See `do' for a description of Maxima's
     iteration facilities.


 -- Function: go (<tag>)
     is used within a `block' to transfer control to the statement of
     the block which is tagged with the argument to `go'.  To tag a
     statement, precede it by an atomic argument as another statement in
     the `block'.  For example:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     The argument to `go' must be the name of a tag appearing in the
     same `block'.  One cannot use `go' to transfer to tag in a `block'
     other than the one containing the `go'.


 -- Special operator: if
     The `if' statement is used for conditional execution.  The syntax
     is:

          if <condition> then <expr_1> else <expr_2>

     The result of an `if' statement is <expr_1> if condition is `true'
     and <expr_2> otherwise.  <expr_1> and <expr_2> are any Maxima
     expressions (including nested `if' statements), and <condition> is
     an expression which evaluates to `true' or `false' and is composed
     of relational and logical operators which are as follows:

          Operation            Symbol      Type

          less than            <           relational infix
          less than            <=
            or equal to                    relational infix
          equality (syntactic) =           relational infix
          negation of =        #           relational infix
          equality (value)     equal       relational function
          negation of equal    notequal    relational function
          greater than         >=
            or equal to                    relational infix
          greater than         >           relational infix
          and                  and         logical infix
          or                   or          logical infix
          not                  not         logical prefix


 -- Function: map (<f>, <expr_1>, ..., <expr_n>)
     Returns an expression whose leading operator is the same as that
     of the expressions <expr_1>, ..., <expr_n> but whose subparts are
     the results of applying <f> to the corresponding subparts of the
     expressions.  <f> is either the name of a function of n arguments
     or is a `lambda' form of n arguments.

     `maperror' - if `false' will cause all of the mapping functions to
     (1) stop when they finish going down the shortest expi if not all
     of the expi are of the same length and (2) apply fn to [exp1,
     exp2,...]  if the expi are not all the same type of object. If
     `maperror' is `true' then an error message will be given in the
     above two instances.

     One of the uses of this function is to `map' a function (e.g.
     `partfrac') onto each term of a very large expression where it
     ordinarily wouldn't be possible to use the function on the entire
     expression due to an exhaustion of list storage space in the
     course of the computation.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Function: mapatom (<expr>)
     Returns `true' if and only if <expr> is treated by the mapping
     routines as an atom.  "Mapatoms" are atoms, numbers (including
     rational numbers), and subscripted variables.


 -- Option variable: maperror
     Default value: `true'

     When `maperror' is `false', causes all of the mapping functions,
     for example

          map (f, expr_1, expr_2, ...))

     to (1) stop when they finish going down the shortest expi if not
     all of the expi are of the same length and (2) apply `f' to
     `[expr_1, expr_2, ...]' if the `expr_i' are not all the same type
     of object.

     If `maperror' is `true' then an error message is displayed in the
     above two instances.


 -- Function: maplist (<f>, <expr_1>, ..., <expr_n>)
     Returns a list of the applications of <f> to the parts of the
     expressions <expr_1>, ..., <expr_n>.  <f> is the name of a
     function, or a lambda expression.

     `maplist' differs from `map (<f>, <expr_1>, ..., <expr_n>)' which
     returns an expression with the same main operator as <expr_i> has
     (except for simplifications and the case where `map' does an
     `apply').


 -- Option variable: prederror
     Default value: `true'

     When `prederror' is `true', an error message is displayed whenever
     the predicate of an `if' statement or an `is' function fails to
     evaluate to either `true' or `false'.

     If `false', `unknown' is returned instead in this case.  The
     `prederror: false' mode is not supported in translated code;
     however, `maybe' is supported in translated code.

     See also `is' and `maybe'.


 -- Function: return (value)
     May be used to exit explicitly from a block, bringing its
     argument.  See `block' for more information.


 -- Function: scanmap (<f>, <expr>)
 -- Function: scanmap (<f>, <expr>, bottomup)
     Recursively applies <f> to <expr>, in a top down manner.  This is
     most useful when complete factorization is desired, for example:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note the way in which `scanmap' applies the given function
     `factor' to the constituent subexpressions of <expr>; if another
     form of <expr> is presented to `scanmap' then the result may be
     different.  Thus, `%o2' is not recovered when `scanmap' is applied
     to the expanded form of exp:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Here is another example of the way in which `scanmap' recursively
     applies a given function to all subexpressions, including
     exponents:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' applies <f> to <expr> in a
     bottom-up manner.  E.g., for undefined `f',

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     In this case, you get the same answer both ways.


 -- Function: throw (<expr>)
     Evaluates <expr> and throws the value back to the most recent
     `catch'.  `throw' is used with `catch' as a nonlocal return
     mechanism.


 -- Function: outermap (<f>, <a_1>, ..., <a_n>)
     Applies the function <f> to each one of the elements of the outer
     product <a_1> cross <a_2> ... cross <a_n>.

     <f> is be the name of a function of n arguments or a lambda
     expression of n arguments.  The arguments <a_1>, ..., <a_n> may be
     lists or nonlists.  List arguments may have different lengths.
     Arguments other than lists are treated as lists of length 1 for
     the purpose of constructing the outer product.

     The result of applying <f> to the outer product is organized as a
     nested list.  The depth of nesting is equal to the number of list
     arguments (arguments other than lists do not contribute a nesting
     level).  A list at nesting depth k has the same length as the k'th
     list argument.

     `outermap' evaluates its arguments.

     See also `map', `maplist', and `apply'.

     Examples:

          (%i1) f (x, y) := x - y$
          (%i2) outermap (f, [2, 3, 5], [a, b, c, d]);
          (%o2) [[2 - a, 2 - b, 2 - c, 2 - d],
                [3 - a, 3 - b, 3 - c, 3 - d], [5 - a, 5 - b, 5 - c, 5 - d]]
          (%i3) outermap (lambda ([x, y], y/x), [55, 99], [Z, W]);
                                  Z   W     Z   W
          (%o3)                 [[--, --], [--, --]]
                                  55  55    99  99
          (%i4) g: lambda ([x, y, z], x + y*z)$
          (%i5) outermap (g, [a, b, c], %pi, [11, 17]);
          (%o5) [[a + 11 %pi, a + 17 %pi], [b + 11 %pi, b + 17 %pi],
                                                  [c + 11 %pi, c + 17 %pi]]
          (%i6) flatten (%);
          (%o6) [a + 11 %pi, a + 17 %pi, b + 11 %pi, b + 17 %pi,
                                                    c + 11 %pi, c + 17 %pi]



File: maxima.info,  Node: Debugging,  Next: Function and Variable Index,  Prev: Program Flow,  Up: Top

42 Debugging
************

* Menu:

* Source Level Debugging::
* Keyword Commands::
* Definitions for Debugging::


File: maxima.info,  Node: Source Level Debugging,  Next: Keyword Commands,  Up: Debugging

42.1 Source Level Debugging
===========================

Maxima has a built-in source level debugger.  The user can set a
breakpoint at a function, and then step line by line from there.  The
call stack may be examined, together with the variables bound at that
level.

   The command `:help' or `:h' shows the list of debugger commands.
(In general, commands may be abbreviated if the abbreviation is unique.
If not unique, the alternatives will be listed.)  Within the debugger,
the user can also use any ordinary Maxima functions to examine, define,
and manipulate variables and expressions.

   A breakpoint is set by the `:br' command at the Maxima prompt.
Within the debugger, the user can advance one line at a time using the
`:n' ("next") command.  The `:bt' ("backtrace") command shows a list of
stack frames.  The `:r' ("resume") command exits the debugger and
continues with execution.  These commands are demonstrated in the
example below.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt typed here gives a backtrace
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investigate value of u
     28

     (dbm:1) u: 33;                     <-- Change u to be 33
     33

     (dbm:1) :r                         <-- Type :r to resume the computation

     (%o2)                                1094

   The file `/tmp/foobar.mac' is the following:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USE OF THE DEBUGGER THROUGH EMACS

   If the user is running the code under GNU emacs in a shell window
(dbl shell), or is running the graphical interface version, `xmaxima',
then if he stops at a break point, he will see his current position in
the source file which will be displayed in the other half of the
window, either highlighted in red, or with a little arrow pointing at
the right line.  He can advance single lines at a time by typing M-n
(Alt-n).

   Under Emacs you should run in a `dbl' shell, which requires the
`dbl.el' file in the elisp directory.  Make sure you install the elisp
files or add the Maxima elisp directory to your path: e.g., add the
following to your `.emacs' file or the `site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   then in emacs

     M-x dbl

   should start a shell window in which you can run programs, for
example Maxima, gcl, gdb etc.   This shell window also knows about
source level debugging, and display of source code in the other window.

   The user may set a break point at a certain line of the file by
typing `C-x space'.  This figures out which function the cursor is in,
and then it sees which line of that function the cursor is on.   If the
cursor is on, say, line 2 of `foo', then it will insert in the other
window the command, "`:br foo 2'", to break `foo' at its second line.
To have this enabled, the user must have maxima-mode.el turned on in
the window in which the file `foobar.mac' is visiting.  There are
additional commands available in that file window, such as evaluating
the function into the Maxima, by typing `Alt-Control-x'.


File: maxima.info,  Node: Keyword Commands,  Next: Definitions for Debugging,  Prev: Source Level Debugging,  Up: Debugging

42.2 Keyword Commands
=====================

Keyword commands are special keywords which are not interpreted as
Maxima expressions.  A keyword command can be entered at the Maxima
prompt or the debugger prompt, although not at the break prompt.
Keyword commands start with a colon, ':'.  For example, to evaluate a
Lisp form you may type `:lisp' followed by the form to be evaluated.

     (%i1) :lisp (+ 2 3)
     5

   The number of arguments taken depends on the particular command.
Also, you need not type the whole command, just enough to be unique
among the break keywords.   Thus `:br' would suffice for `:break'.

   The keyword commands are listed below.

`:break F n'
     Set a breakpoint in function `F' at line offset `n' from the
     beginning of the function.  If `F' is given as a string, then it
     is assumed to be a file, and `n' is the offset from the beginning
     of the file.  The offset is optional. If not given, it is assumed
     to be zero (first line of the function or file).

`:bt'
     Print a backtrace of the stack frames

`:continue'
     Continue the computation

`:delete'
     Delete the specified breakpoints, or all if none are specified

`:disable'
     Disable the specified breakpoints, or all if none are specified

`:enable'
     Enable the specified breakpoints, or all if none are specified

`:frame n'
     Print stack frame `n', or the current frame if none is specified

`:help'
     Print help on a debugger command, or all commands if none is
     specified

`:info'
     Print information about item

`:lisp some-form'
     Evaluate `some-form' as a Lisp form

`:lisp-quiet some-form'
     Evaluate Lisp form `some-form' without any output

`:next'
     Like `:step', except `:next' steps over function calls

`:quit'
     Quit the current debugger level without completing the computation

`:resume'
     Continue the computation

`:step'
     Continue the computation until it reaches a new source line

`:top'
     Return to the Maxima prompt (from any debugger level) without
     completing the computation


File: maxima.info,  Node: Definitions for Debugging,  Prev: Keyword Commands,  Up: Debugging

42.3 Definitions for Debugging
==============================

 -- Option variable: refcheck
     Default value: `false'

     When `refcheck' is `true', Maxima prints a message each time a
     bound variable is used for the first time in a computation.


 -- Option variable: setcheck
     Default value: `false'

     If `setcheck' is set to a list of variables (which can be
     subscripted), Maxima prints a message whenever the variables, or
     subscripted occurrences of them, are bound with the ordinary
     assignment operator `:', the `::' assignment operator, or function
     argument binding, but not the function assignment `:=' nor the
     macro assignment `::=' operators.  The message comprises the name
     of the variable and the value it is bound to.

     `setcheck' may be set to `all' or `true' thereby including all
     variables.

     Each new assignment of `setcheck' establishes a new list of
     variables to check, and any variables previously assigned to
     `setcheck' are forgotten.

     The names assigned to `setcheck' must be quoted if they would
     otherwise evaluate to something other than themselves.  For
     example, if `x', `y', and `z' are already bound, then enter

          setcheck: ['x, 'y, 'z]$

     to put them on the list of variables to check.

     No printout is generated when a variable on the `setcheck' list is
     assigned to itself, e.g., `X: 'X'.


 -- Option variable: setcheckbreak
     Default value: `false'

     When `setcheckbreak' is `true', Maxima will present a break prompt
     whenever a variable on the `setcheck' list is assigned a new value.
     The break occurs before the assignment is carried out.  At this
     point, `setval' holds the value to which the variable is about to
     be assigned.  Hence, one may assign a different value by assigning
     to `setval'.

     See also `setcheck' and `setval'.


 -- System variable: setval
     Holds the value to which a variable is about to be set when a
     `setcheckbreak' occurs.  Hence, one may assign a different value
     by assigning to `setval'.

     See also `setcheck' and `setcheckbreak'.


 -- Function: timer (<f_1>, ..., <f_n>)
 -- Function: timer ()
     Given functions <f_1>, ..., <f_n>, `timer' puts each one on the
     list of functions for which timing statistics are collected.
     `timer(f)$ timer(g)$' puts `f' and then `g' onto the list; the
     list accumulates from one call to the next.

     With no arguments, `timer' returns the list of timed functions.

     Maxima records how much time is spent executing each function on
     the list of timed functions.  `timer_info' returns the timing
     statistics, including the average time elapsed per function call,
     the number of calls, and the total time elapsed.  `untimer'
     removes functions from the list of timed functions.

     `timer' quotes its arguments.  `f(x) := x^2$ g:f$ timer(g)$' does
     not put `f' on the timer list.

     If `trace(f)' is in effect, then `timer(f)' has no effect; `trace'
     and `timer' cannot both be in effect at the same time.

     See also `timer_devalue'.


 -- Function: untimer (<f_1>, ..., <f_n>)
 -- Function: untimer ()
     Given functions <f_1>, ..., <f_n>, `untimer' removes each function
     from the timer list.

     With no arguments, `untimer' removes all functions currently on
     the timer list.

     After `untimer (f)' is executed, `timer_info (f)' still returns
     previously collected timing statistics, although `timer_info()'
     (with no arguments) does not return information about any function
     not currently on the timer list.  `timer (f)' resets all timing
     statistics to zero and puts `f' on the timer list again.


 -- Option variable: timer_devalue
     Default value: `false'

     When `timer_devalue' is `true', Maxima subtracts from each timed
     function the time spent in other timed functions. Otherwise, the
     time reported for each function includes the time spent in other
     functions.  Note that time spent in untimed functions is not
     subtracted from the total time.

     See also `timer' and `timer_info'.


 -- Function: timer_info (<f_1>, ..., <f_n>)
 -- Function: timer_info ()
     Given functions <f_1>, ..., <f_n>, `timer_info' returns a matrix
     containing timing information for each function.  With no
     arguments, `timer_info' returns timing information for all
     functions currently on the timer list.

     The matrix returned by `timer_info' contains the function name,
     time per function call, number of function calls, total time, and
     `gctime', which meant "garbage collection time" in the original
     Macsyma but is now always zero.

     The data from which `timer_info' constructs its return value can
     also be obtained by the `get' function:

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     See also `timer'.


 -- Function: trace (<f_1>, ..., <f_n>)
 -- Function: trace ()
     Given functions <f_1>, ..., <f_n>, `trace' instructs Maxima to
     print out debugging information whenever those functions are
     called.  `trace(f)$ trace(g)$' puts `f' and then `g' onto the list
     of functions to be traced; the list accumulates from one call to
     the next.

     With no arguments, `trace' returns a list of all the functions
     currently being traced.

     The `untrace' function disables tracing.  See also `trace_options'.

     `trace' quotes its arguments. Thus, `f(x) := x^2$ g:f$ trace(g)$'
     does not put `f' on the trace list.

     When a function is redefined, it is removed from the timer list.
     Thus after `timer(f)$ f(x) := x^2$', function `f' is no longer on
     the timer list.

     If `timer (f)' is in effect, then `trace (f)' has no effect;
     `trace' and `timer' can't both be in effect for the same function.


 -- Function: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Function: trace_options (<f>)
     Sets the trace options for function <f>.  Any previous options are
     superseded.  `trace_options (<f>, ...)' has no effect unless
     `trace (<f>)' is also called (either before or after
     `trace_options').

     `trace_options (<f>)' resets all options to their default values.

     The option keywords are:

        * `noprint' Do not print a message at function entry and exit.

        * `break' Put a breakpoint before the function is entered, and
          after the function is exited. See `break'.

        * `lisp_print' Display arguments and return values as Lisp
          objects.

        * `info' Print `-> true' at function entry and exit.

        * `errorcatch' Catch errors, giving the option to signal an
          error, retry the function call, or specify a return value.

     Trace options are specified in two forms. The presence of the
     option keyword alone puts the option into effect unconditionally.
     (Note that option <foo> is not put into effect by specifying
     `<foo>: true' or a similar form; note also that keywords need not
     be quoted.) Specifying the option keyword with a predicate
     function makes the option conditional on the predicate.

     The argument list to the predicate function is always `[level,
     direction, function, item]' where `level' is the recursion level
     for the function,  `direction' is either `enter' or `exit',
     `function' is the name of the function, and `item' is the argument
     list (on entering) or the return value (on exiting).

     Here is an example of unconditional trace options:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Here is the same function, with the `break' option conditional on
     a predicate:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Function: untrace (<f_1>, ..., <f_n>)
 -- Function: untrace ()
     Given functions <f_1>, ..., <f_n>, `untrace' disables tracing
     enabled by the `trace' function.  With no arguments, `untrace'
     disables tracing for all functions.

     `untrace' returns a list of the functions for which it disabled
     tracing.


