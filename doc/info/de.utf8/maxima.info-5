This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Das ist ein Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Ein Computer Algebra System.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Exponentielle Integrale,  Next: Fehlerfunktionen,  Prev: Gammafunktionen und verwandte Funktionen,  Up: Spezielle Funktionen

22.4 Exponentielle Integrale
============================

Die Exponentiellen Integrale und verwandte Funktionen sind definiert in
Abramowitz und Stegun, Handbook of Mathematical Functions, Kapitel 5.

 -- Funktion: expintegral_e1 (<z>)
     Das Exponentielle Integral `E1(z)' (A&S 5.1.1).

 -- Funktion: expintegral_ei (<z>)
     Das Exponentielle Integral `Ei(z)' (A&S 5.1.2).

 -- Funktion: expintegral_li (<n>,<z>)
     Das Exponentielle Integral `Li(z)' (A&S 5.1.3).

 -- Funktion: expintegral_e (<n>, <z>)
     Das Exponentielle Integral `E[n](z)' (A&S 5.1.4).

 -- Funktion: expintegral_si (<z>)
     Das Exponentielle Integral `Si(z)' (A&S 5.2.1).

 -- Funktion: expintegral_ci (<z>)
     Das Exponentielle Integral `Ci(z)' (A&S 5.2.2).

 -- Funktion: expintegral_shi (<z>)
     Das Exponentielle Integral `Shi(z)' (A&S 5.2.3).

 -- Funktion: expintegral_chi (<z>)
     Das Exponentielle Integral `Chi(z)' (A&S 5.2.4).

 -- Optionsvariable: expintrep
     Standardwert: `false'

     Wechselt die Darstellung eines Exponentiellen Integrals in eine
     der anderen Funktionen `gamma_incomplete',  `expintegral_e1',

     `expintegral_ei',  `expintegral_li',

     `expintegral_si',  `expintegral_ci',

     `expintegral_shi',  oder `expintegral_chi'.


 -- Optionsvariable: expintexpand
     Standardwert: `false'

     Expandiert das Exponentielle Integral `E[n](z)' für halbzahlige,
     gerade Ordnung <n> nach den Funktionen `erfc'  und `erf'.   sowie
     für positive ganze Zahlen nach der Funktion `expintegral_ei'.



File: maxima.info,  Node: Fehlerfunktionen,  Next: Elliptische Funktionen und Integrale,  Prev: Exponentielle Integrale,  Up: Spezielle Funktionen

22.5 Fehlerfunktionen
=====================

Die Fehlerfunktion und verwandte Funktionen sind definiert in Abramowitz
und Stegun, Handbook of Mathematical Functions, Kapitel 7.

 -- Funktion: erf (<z>)
     Die Fehlerfunktion `erf(z)' (A&S 7.1.1).

     Siehe auch die Optionsvariable `erfflag'.


 -- Function: erfc (<z>)
     Die komplementäre Fehlerfunktion `erfc(z) = 1 - erf(z)' (A & S
     7.1.2).

 -- Funktion: erfi (<z>)
     Die imaginäre Fehlerfunktion `erfi(z) = -%i*erf(%i*z)'.

 -- Funktion: erf_generalized (<z1>, <z2>)
     Die verallgemeinerte Fehlerfunktion Erf(z1, z2).

 -- Funktion: fresnel_c (<z>)
     Das Fresnel-Integral, das definiert ist als (A & S 7.3.1):

                     z
                    /           2
                    [      %pi t
             C(z) = I  cos(------) dt
                    ]        2
                    /
                     0

     Hat die Optionsvariable `trigsign'  den Wert `true', vereinfacht
     Maxima `fresnel_c(-x)' zu `-fresnel_c(x)'.

     Hat die Optionsvariable `%iargs'  den Wert `true', vereinfacht
     Maxima `fresnel_c(%i*x)' zu `%i*fresnel_c(x)'.

     Siehe auch die Optionsvariable `hypergeometric_representation',  um
     die Fresnelfunktion in eine hypergeometrische Darstellung zu
     transformieren, und die Optionsvariable `erf_representation'  für
     eine Darstellung als Fehlerfunktion.

 -- Funktion: fresnel_s (<z>)
     Das Fresnel-Integral, das definiert ist als (A & S 7.3.2):

                     z
                    /           2
                    [      %pi t
             S(z) = I  sin(------) dt
                    ]        2
                    /
                     0

     Hat die Optionsvariable `trigsign'  den Wert `true', vereinfacht
     Maxima `fresnel_s(-x)' zu `-fresnel_s(x)'.

     Hat die Optionsvariable `%iargs'  den Wert `true', vereinfacht
     Maxima `fresnel_s(%i*x)' zu `%i*fresnel_s(x)'.

     Siehe auch die Optionsvariable `hypergeometric_representation',  um
     die Fresnelfunktion in eine hypergeometrische Darstellung zu
     transformieren, und die Optionsvariable `erf_representation'  für
     eine Darstellung als Fehlerfunktion.

 -- Optionsvariable: erf_representation
     Standarwert: `false'

     Hat die Optionsvariable `erf_representation' den Wert `true',
     werden die Funktionen `erfc',  `erfi',

     `erf_generalized',  `fresnel_s'  und `fresnel_c'  in eine
     Darstellung mit der Funktion `erf'  transformiert.

 -- Optionsvariable: hypergeometric_representation
     Standardwert: `false'

     Hat die Optionsvariable `hypergeometric_representation' den Wert
     `true', werden die Funktionen `fresnel_s'  und `fresnel_c'  in
     eine hypergeometrische Funktion transformiert.


File: maxima.info,  Node: Elliptische Funktionen und Integrale,  Next: Hypergeometrische Funktionen,  Prev: Fehlerfunktionen,  Up: Spezielle Funktionen

22.6 Elliptische Funktionen und Integrale
=========================================

* Menu:

* Einführung in Elliptische Funktionen und Integrale::
* Funktionen und Variablen für Elliptische Funktionen::
* Funktionen und Variablen für Elliptische Integrale::


File: maxima.info,  Node: Einführung in Elliptische Funktionen und Integrale,  Next: Funktionen und Variablen für Elliptische Funktionen,  Prev: Elliptische Funktionen und Integrale,  Up: Elliptische Funktionen und Integrale

22.6.1 Einführung in Elliptische Funktionen und Integrale
---------------------------------------------------------

Maxima unterstützt die Jacobischen elliptische Funktionen sowie die
vollständigen und unvollständigen elliptischen Integrale.  Die
Funktionen sind für das symbolische und numerische Rechnen geeignet.
Die Definition der Funktionen und viele ihrer Eigenschaften sind in
Abramowitz and Stegun, Kapitel 16 und 17 enthalten.  Die dort
beschriebenen Definitionen und Beziehungen werden so weit als möglich
verwendet.

Im besonderen nutzen alle elliptischen Funktionen und Integrale den
Parameter m anstatt den Modulus k oder den modularen Winkel \alpha.
Dies ist ein Unterschied zu der Definition von Abramowitz und Stegun.
Es gelten die folgenden Beziehungen: m = k^2 und k = \sin(\alpha)

Die elliptischen Funktionen und Integrale sind zuallererst für das
symbolische Rechnen gedacht.  Daher sind die Ableitungen und Integrale
der Funktionen im wesentlichen in Maxima bekannt.  Maxima unterstützt
jedoch auch die numerische Berechnung, wenn die Argumente
Gleitkommazahlen sind.

Viele bekannte Eigenschaften der Elliptischen Funktionen und Integrale
sind noch nicht in Maxima implementiert.

Einige Beispiele für elliptische Funktionen.

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

Einige Beispiele für elliptische Integrale.

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

Die Implementierung der elliptischen Funktionen und Integrale wurde von
Raymond Toy geschrieben.  Der Code steht wie Maxima unter der General
Public License (GPL).


File: maxima.info,  Node: Funktionen und Variablen für Elliptische Funktionen,  Next: Funktionen und Variablen für Elliptische Integrale,  Prev: Einführung in Elliptische Funktionen und Integrale,  Up: Elliptische Funktionen und Integrale

22.6.2 Funktionen und Variablen für Elliptische Funktionen
----------------------------------------------------------

 -- Funktion: jacobi_sn (<u>, <m>)
     Die Jacobische elliptische Funktion sn(u,m).

 -- Funktion: jacobi_cn (<u>, <m>)
     Die Jacobische elliptische Funktion cn(u,m).

 -- Funktion: jacobi_dn (<u>, <m>)
     Die Jacobische elliptische Funktion dn(u,m).

 -- Funktion: jacobi_ns (<u>, <m>)
     Die Jacobische elliptische Funktion ns(u,m) = 1/sn(u,m).

 -- Funktion: jacobi_sc (<u>, <m>)
     Die Jacobische elliptische Funktion sc(u,m) = sn(u,m)/cn(u,m).

 -- Funktion: jacobi_sd (<u>, <m>)
     Die Jacobische elliptische Funktion sd(u,m) = sn(u,m)/dn(u,m).

 -- Funktion: jacobi_nc (<u>, <m>)
     Die Jacobische elliptische Funktion nc(u,m) = 1/cn(u,m).

 -- Funktion: jacobi_cs (<u>, <m>)
     Die Jacobische elliptische Funktion cs(u,m) = cn(u,m)/sn(u,m).

 -- Funktion: jacobi_cd (<u>, <m>)
     Die Jacobische elliptische Funktion cd(u,m) = cn(u,m)/dn(u,m).

 -- Funktion: jacobi_nd (<u>, <m>)
     Die Jacobische elliptische Funktion nc(u,m) = 1/cn(u,m).

 -- Funktion: jacobi_ds (<u>, <m>)
     Die Jacobische elliptische Funktion ds(u,m) = dn(u,m)/sn(u,m).

 -- Funktion: jacobi_dc (<u>, <m>)
     Die Jacobische elliptische Funktion dc(u,m) = dn(u,m)/cn(u,m).

 -- Funktion: inverse_jacobi_sn (<u>, <m>)
     Die inverse Jacobische elliptische Funktion sn(u,m).

 -- Funktion: inverse_jacobi_cn (<u>, <m>)
     Die inverse Jacobische elliptische Funktion cn(u,m).

 -- Funktion: inverse_jacobi_dn (<u>, <m>)
     Die inverse Jacobische elliptische Funktion dn(u,m).

 -- Funktion: inverse_jacobi_ns (<u>, <m>)
     Die inverse Jacobische elliptische Funktion ns(u,m).

 -- Funktion: inverse_jacobi_sc (<u>, <m>)
     Die inverse Jacobische elliptische Funktion sc(u,m).

 -- Funktion: inverse_jacobi_sd (<u>, <m>)
     Die inverse Jacobische elliptische Funktion sd(u,m).

 -- Funktion: inverse_jacobi_nc (<u>, <m>)
     Die inverse Jacobische elliptische Funktion nc(u,m).

 -- Funktion: inverse_jacobi_cs (<u>, <m>)
     Die inverse Jacobische elliptische Funktion cs(u,m).

 -- Funktion: inverse_jacobi_cd (<u>, <m>)
     Die inverse Jacobische elliptische Funktion cd(u,m).

 -- Funktion: inverse_jacobi_nd (<u>, <m>)
     Die inverse Jacobische elliptische Funktion nc(u,m).

 -- Funktion: inverse_jacobi_ds (<u>, <m>)
     Die inverse Jacobische elliptische Funktion ds(u,m).

 -- Funktion: inverse_jacobi_dc (<u>, <m>)
     Die inverse Jacobische elliptische Funktion dc(u,m).


File: maxima.info,  Node: Funktionen und Variablen für Elliptische Integrale,  Prev: Funktionen und Variablen für Elliptische Funktionen,  Up: Elliptische Funktionen und Integrale

22.6.3 Funktionen und Variablen für Elliptische Integrale
---------------------------------------------------------

 -- Funktion: elliptic_f (<phi>, <m>)
     Das unvollständige elliptische Integral der ersten Art, das
     definiert ist als

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Siehe auch `elliptic_e'  und `elliptic_kc'.


 -- Funktion: elliptic_e (<phi>, <m>)
     Das unvollständige elliptische Integral der zweiten Art, das
     definiert ist als

     elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     Siehe auch `elliptic_e'  und `elliptic_ec'.


 -- Funktion: elliptic_eu (<u>, <m>)
     Das unvollständige elliptische Integral der zweiten Art, das
     definiert ist als

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     mit tau = sn(u,m).

     Dieses Integral steht in Beziehung zum elliptischen Integral
     `elliptiec_e'

     elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)

     Siehe auch `elliptic_e'.


 -- Funktion: elliptic_pi (<n>, <phi>, <m>)
     Das unvollständige elliptische Integral der dritten Art, das
     definiert ist als

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Maxima kennt nur die Ableitung nach der Variablen <phi>.

 -- Funktion: elliptic_kc (<m>)
     Das vollständige elliptische Integral der ersten Art, das
     definiert ist als

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Für einige spezielle Argumente <m> kennt Maxima Werte mit der
     Gammafunktion `gamma'.    Die Werte können mit der Funktion
     `makegamma'  berechnet werden.

 -- Funktion: elliptic_ec (<m>)
     Das vollständige elliptische Integral der zweiten Art, das
     definiert ist als

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Für einige spezielle Argumente <m> kennt Maxima Werte mit der
     Gammafunktion `gamma'.    Die Werte können mit der Funktion
     `makegamma'  berechnet werden.


File: maxima.info,  Node: Hypergeometrische Funktionen,  Next: Weitere spezielle Funktionen,  Prev: Elliptische Funktionen und Integrale,  Up: Spezielle Funktionen

22.7 Hypergeometrische Funktionen
=================================

 -- Funktion: %m [<k>, <u>] (<z>)
     Ist die Whittaker M Funktion `M[k,u](z) = exp(-z/2) * z^(1/2+u) *
     M(1/2+u-k, 1+2*u, z)'.  Siehe A & S 13.1.32 für die Definition.

 -- Funktion: %w [<k>, <u>] (<z>)
     Ist die Whittaker W Funktion.  Siehe A & S 13.1.33 für die
     Definition.

 -- Funktion: %f [<p>,<q>] (<[a], [b], z>)
     Ist die hypergeometrische Funktion `F[p,q](a_1, ..., a_p; b_1,...,
     b_q; z)'.  Das Argument <a> ist eine Liste mit den <p>-Elementen
     <a_i> und das Argument <b> die Liste mit den <q>-Elementen <b_i>.

 -- Funktion: hypergeometric ([<a_1>, ..., <a_p>], [<b_1>, ... ,<b_q>],
          z)
     Ist die hypergeometrische Funktion.  Im Unterschied zu den
     Funktionen `%f'  und `hgfred',  ist die Funktion `hypergeometric'
     eine vereinfachende Funktion.  `hypergeometric' unterstützt die
     Berechnung von numerischen Werten für reelle und komplexe
     Gleitkommazahlen in doppelter und mit beliebiger Genauigkeit.  Für
     die Gaußsche hypergeometrische Funktion ist p = 2 und q = 1.  In
     diesem Fall wird auch die numerische Berechnung außerhalb des
     Einheitskreises unterstützt.

     Hat die Optionsvariable `expand_hypergeometric' den Wert `true',
     das ist der Standardwert, und eines der Argumente `a_1', ..., `a_p'
     ist eine negative ganze Zahl, gibt `hypergeometric' ein Polynom
     zurück.

     Beispiel:

           (%i1)  hypergeometric([],[],x);
           (%o1) %e^x

     Expansion in ein Polynom für eine negative ganze Zahl, wenn die
     Optionsvariable `expand_hypergeometric' den Wert `true' hat.

           (%i2) hypergeometric([-3],[7],x);
           (%o2) hypergeometric([-3],[7],x)

           (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
           (%o3) -x^3/504+3*x^2/56-3*x/7+1

     Numerische Berechnung in doppelter und beliebiger
     Gleitkommagenauigkeit.

          (%i4) hypergeometric([5.1],[7.1 + %i],0.42);
          (%o4)       1.346250786375334 - 0.0559061414208204 %i
          (%i5) hypergeometric([5,6],[8], 5.7 - %i);
          (%o5)     .007375824009774946 - .001049813688578674 %i
          (%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
          (%o6) 7.37582400977494674506442010824b-3
                                    - 1.04981368857867315858055393376b-3 %i

 -- Funktion: parabolic_cylinder_d (<v>, <z>)
     Die parabolische Zylinderfunktion `parabolic_cylinder_d(v,z)'.

     Die parabolischen Zylinderfunktionen sind in Abramowitz and Stegun,
     Handbook of Mathematical Functions, Kapitel 19 definiert.

     Die parabolischen Zylinderfunktionen können als Ergebnis der
     Funktion `hgfred'  auftreten.  Maxima kennt keine weiteren
     Eigenschaften.


File: maxima.info,  Node: Weitere spezielle Funktionen,  Prev: Hypergeometrische Funktionen,  Up: Spezielle Funktionen

22.8 Weitere spezielle Funktionen
=================================

 -- Funktion: li [<s>] (<z>)
     Ist der Polylogarithmus der Ordnung <s> mit dem Argument <z>.  Der
     Polylogarithmus wird durch die folgende Reihe definiert werden:

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     Für <s=1> geht der Polylogarithmus in die gewöhnliche
     Logarithmusfunktion über und man erhält `-log(1-z)'.  Für <s=2>
     oder <s=3> spricht man vom Dilogarithmus oder Trilogarithmus.

     Maxima vereinfacht für <s=1> sofort zum gewöhnlichen Logarithmus.
     Für negative ganze Zahlen <s> einschließlich der Null vereinfacht
     Maxima den Polylogarithmus zu einer rationalen Funktion.

     Ist <s=2> oder <s=3> und das Argument <z> eine Gleitkommazahl,
     vereinfacht Maxima den Di- oder Trilogarithmus zu einer
     Gleitkommazahl.

     Beispiele:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]

 -- Funktion: specint (exp(- s*<t>) * <expr>, <t>)
     Berechnet die Laplace-Transformation des Ausdrucks <expr> für die
     Integrationsvariable <t>.  <s> ist der Parameter der
     Laplace-Transformation.  Der Integrand <expr> kann spezielle
     Funktionen der Mathematik enthalten.

     Die folgenden speziellen Funktionen können als Integrand
     auftreten: die unvollständige Gammafunkion `gamma_incomplete',  die
     Fehlerfunktionen `erf'  und `erfc',  nicht jedoch die Funktion
     `erfi',  die jedoch in eine andere Fehlerfunktion transformiert
     werden kann, die Exponentiellen Integrale wie zum Beispiel
     `expintegral_e1',

     die Bessel-Funktionen wie zum Beispiel `bessel_j',  einschließlich
     der Produkte von Bessel-Funktionen, Hankel-Funktionen wie zum
     Beispiel `hankel_1',  Hermite `hermite'  und Laguerre Polynome
     `laguerre'.    Weiterhin kann `specint' Integranden mit der
     Hypergeometrische Funktion `%f[p,q]([],[],z)', die Whittaker
     Funktion der ersten Art `%m[u,k](z)' und die der zweiten Art
     `%w[u,k](z)' integrieren.

     Das Ergebnis kann spezielle Funktionen und die Hypergeometrische
     Funktion enthalten.

     Kann die Funktion `laplace'  keine Laplace-Transformation finden,
     wird `specint' aufgerufen.  Da die Funktion `laplace' einige
     allgemeine Regeln kennt, um die Laplace-Transformation zu finden,
     ist es von Vorteil die Laplace-Transformation mit der Funktion
     `laplace' zu berechnen.

     `demo(hypgeo)' zeigt einige Beispiele für Laplace-Transformationen
     mit der Funktion `specint'.

     Beispiele:

          (%i1) assume (p > 0, a > 0)$
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

     Beispiel mit Exponentiellen Integralen.

          (%i4) assume(s>0,a>0,s-a>0)$
          (%i5) ratsimp(specint(%e^(a*t)
                                *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                                       log(s)
          (%o5)                        ------
                                       s - a
          (%i6) logarc:true$
          (%i7) gamma_expand:true$

          radcan(specint((cos(t)*expintegral_si(t)
                               -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                                       log(s)
          (%o8)                        ------
                                        2
                                       s  + 1
          ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                                -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                                         2    2
                                    log(s  + a )
          (%o9)                     ------------
                                          2
                                         s

     Entwicklung der unvollständigen Gammafunktion und Wechsel in eine
     Darstellung mit dem Exponentiellen Integral `expintegral_e1'.

          (%i10) assume(s>0)$
          (%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                                      1
                                      gamma_incomplete(-, k s)
                                                      2
          (%o11)                      ------------------------
                                         sqrt(%pi) sqrt(s)

          (%i12) gamma_expand:true$
          (%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                        erfc(sqrt(k) sqrt(s))
          (%o13)                        ---------------------
                                               sqrt(s)

          (%i14) expintrep:expintegral_e1$
          (%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                                        a s
                                  a s %e    expintegral_e1(a s) - 1
          (%o15)                - ---------------------------------
                                                  a

 -- Funktion: hgfred (<a>, <b>, <z>)
     Vereinfacht die Hypergeometrische Funktion zu einfacheren
     Funktionen, wie Polynome und spezielle Funktionen.  Die
     Hypergeometrische Funktion ist die verallgemeinerte geometrische
     Reihe und ist wie folgt definiert:

             F    (a_1, ... a_p; b_1, ..., b_q; z) =
              p, q

                       inf      p                    q                k
                       ====   /===\ gamma(k + a )  /===\   gamma(b ) z
                       \       ! !             i    ! !           j
                     =  >      ! !  -------------   ! !  ----------------
                       /       ! !    gamma(a )     ! !  k! gamma(k + b )
                       ====   i = 1          i     j = 1               j
                       k = 0

     Die Argumente <a> und <b> sind Listen mit den Parametern der
     Hypergeometrischen Funktion `a_1', ..., `a_p' sowie `b_1', ...,
     `b_p'.  Die Liste <a> enthält die `p'-Elemente <a_i> und die Liste
     <b> enthält die <q>-Elemente <b_i>.

     Kann `hgfred' die Hypergeomentrische Funktion nicht vereinfachen,
     wird eine Substantivform `%f[p,q]([a], [b], z)' zurückgegeben.

     Beispiele:

          (%i1) assume(not(equal(z,0)));
          (%o1)                          [notequal(z, 0)]
          (%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                               v/2                               %i z
                              4    bessel_j(v, z) gamma(v + 1) %e
          (%o2)               ---------------------------------------
                                                 v
                                                z
          (%i3) hgfred([1,1],[2],z);

                                             log(1 - z)
          (%o3)                            - ----------
                                                 z
          (%i4) hgfred([a,a+1/2],[3/2],z^2);

                                         1 - 2 a          1 - 2 a
                                  (z + 1)        - (1 - z)
          (%o4)                   -------------------------------
                                           2 (1 - 2 a) z

 -- Funktion: lambert_w (<z>)
     Der Hauptzweig der Lambert W Funktion, die Lösung von `z = W(z) *
     exp(W(z))'.

 -- Funktion: nzeta (<z>)
     Die Plasma Dispersion Funktion `nzeta(z) =
     %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))'.

 -- Funktion: nzetar (<z>)
     Gibt  `realpart(nzeta(z))' zurück.

 -- Funktion: nzetai (<z>)
     Gibt `imagpart(nzeta(z))' zurück.

 -- Funktion: %s [<u>,<v>] (<z>)
     Lommels kleine Funktion `s[u,v](z)'.  Siehe Gradshteyn & Ryzhik
     8.570.1.


File: maxima.info,  Node: Fourier-Transformationen,  Next: Muster und Regeln,  Prev: Spezielle Funktionen,  Up: Top

23 Fourier-Transformationen
***************************

* Menu:

* Einführung in die schnelle Fourier-Transformation::
* Funktionen und Variablen für die schnelle Fourier-Transformation::
* Einführung in Fourierreihen::
* Funktionen und Variablen für Fourierreihen::


File: maxima.info,  Node: Einführung in die schnelle Fourier-Transformation,  Next: Funktionen und Variablen für die schnelle Fourier-Transformation,  Prev: Fourier-Transformationen,  Up: Fourier-Transformationen

23.1 Einführung in die schnelle Fourier-Transformation
======================================================

Das Paket `fft' enthält Funktionen für die numerische Berechnung der
schnellen Fourier Transformation (FFT - "Fast Fourier Transform").


File: maxima.info,  Node: Funktionen und Variablen für die schnelle Fourier-Transformation,  Next: Einführung in Fourierreihen,  Prev: Einführung in die schnelle Fourier-Transformation,  Up: Fourier-Transformationen

23.2 Funktionen und Variablen für die schnelle Fourier-Transformation
=====================================================================

 -- Funktion: polartorect (<r>, <t>)
     Transformiert komplexe Zahlen der Form `r %e^(%i t)' in die
     Standardform `a + b %i'.  <r> ist der Betrag der komplexen Zahl
     und <t> die Phase.  Die Argumente <r> und <t> sind eindimensionale
     Arrays derselben Größe.  Die Größe der Arrays muss eine Potenz von
     2 sein.

     Die Werte der originalen Arrays werden durch den Realteil `a = r
     cos(t)' und den Imaginärteil `b = r sin(t)' ersetzt.

     `polartorect' ist die inverse Funktion zu `recttopolar'.

     Das Kommando `load(fft)' lädt die Funktion.

 -- Funktion: recttopolar (<a>, <b>)
     Transformiert komplexe Zahlen der Form `a + b %i' in die Polarform
     `r %e^(%i t)'.  <a> ist der Realteil und <b> der Imaginärteil der
     komplexen Zahl.  Die Argumente <a> und <b> sind eindimensionale
     Arrays derselben Größe.  Die Größe der Arrays muss eine Potenz von
     2 sein.

     Die Werte der originalen Arrays werden durch den Betrag `r =
     sqrt(a^2 + b^2' und die Phase `t = atan2(b, a)' ersetzt.  Die
     Phase ist ein Winkel in dem Bereich `-%pi' bis `%pi'.

     `recttoploar' ist die inverse Funktion zu `polartorect'.

     Das Kommando `load(fft)' lädt die Funktion.

 -- Funktion: inverse_fft (<y>)
     Berechnet die inverse schnelle Fourier-Transformation.  Das
     Argument <y> ist eine Liste oder ein Array mit den Daten, die zu
     transformieren sind.  Die Anzahl der Daten muss eine Potenz von 2
     sein.  Die Elemente müssen Zahlen (ganze, rationale,
     Gleitkommazahlen oder große Gleitkommazahlen) oder numerische
     Konstanten sein.  Weiterhin können die Elemente komplexe Zahlen `a
     + b*%i' sein, wobei der Realteil und der Imaginärteil wiederum
     Zahlen oder numerische Konstanten sein müssen.

     `inverse_fft' gibt ein neues Objekt vom selben Typ wie <y> zurück.
     Die Ergebnisse sind immer Gleitkommazahlen oder komplexe Zahlen `a
     + %i*b', wobei `a' und `b' Gleitkommazahlen sind.

     Die inverse diskrete Fourier-Transformation ist wie folgt
     definiert.  Wenn `x' das Ergebnis der inversen
     Fourier-Transformation ist, dann gilt für `j' von 0 bis `n-1'

          x[j] = sum(y[k] exp(2 %i %pi j k / n), k, 0, n - 1)

     Mit dem Kommando `load(fft)' wird die Funktion geladen.  Siehe auch
     `fft'  für die schnelle Fourier-Transformation.

     Beispiele:

     Reelle Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [0.0, 14.49 %i - .8284, 0.0, 2.485 %i + 4.828, 0.0,
                                 4.828 - 2.485 %i, 0.0, - 14.49 %i - .8284]
          (%i5) L2 : fft (L1);
          (%o5) [1.0, 2.0 - 2.168L-19 %i, 3.0 - 7.525L-20 %i,
          4.0 - 4.256L-19 %i, - 1.0, 2.168L-19 %i - 2.0,
          7.525L-20 %i - 3.0, 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Komplexe Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [4.0, 2.711L-19 %i + 4.0, 2.0 %i - 2.0,
          - 2.828 %i - 2.828, 0.0, 5.421L-20 %i + 4.0, - 2.0 %i - 2.0,
          2.828 %i + 2.828]
          (%i5) L2 : fft (L1);
          (%o5) [4.066E-20 %i + 1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          1.55L-19 %i - 1.0, - 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.0 - 7.368L-20 %i]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.841L-17

 -- Funktion: fft (<x>)
     Berechnet die schnelle Fourier-Transformation.  Das Argument <x>
     ist eine Liste oder ein Array mit den Daten, die zu transformieren
     sind.  Die Anzahl der Elemente muss eine Potenz von 2 sein.  Die
     Elemente müssen Zahlen (ganze, rationale, Gleitkommazahlen oder
     große Gleitkommazahlen) oder numerische Konstanten sein.
     Weiterhin können die Elemente komplexe Zahlen `a + b*%i' sein,
     wobei der Realteil und der Imaginärteil wiederum Zahlen oder
     numerische Konstanten sein müssen.

     `inverse_fft' gibt ein neues Objekt vom selben Typ wie <x> zurück.
     Die Ergebnisse sind immer Gleitkommazahlen oder komplexe Zahlen `a
     + %i*b', wobei `a' und `b' Gleitkommazahlen sind.

     Die diskrete Fourier-Transformation ist wie folgt definiert.  Wenn
     `y' das Ergebnis der Fourier-Transformation ist, dann gilt für `k'
     von 0 bis `n-1'

          y[k] = (1/n) sum(x[j] exp(-2 %i %pi j k / n), j, 0, n - 1)

     Sind die Daten <x> reelle Zahlen, dann werden die reellen
     Koeffizienten <a> und <b> so berechnet, dass gilt

          x[j] = sum (a[k] * cos (2*%pi*j*k / n)
                    + b[k] * sin (2*%pi*j*k / n), k, 0, n/2)

     wobei

          a[0] = realpart (y[0])
          b[0] = 0

     und für <k> von 1 bis `n/2-1'

          a[k] = realpart (y[k] + y[n - k])
          b[k] = imagpart (y[n - k] - y[k])

     sowie

          a[n/2] = realpart (y[n/2])
          b[n/2] = 0

     Das Kommando `load(fft)' lädt die Funktion.  Siehe auch
     `inverse_fft'  für die inverse schnelle Fourier-Transformation.

     Beispiele:

     Reelle Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : fft (L);
          (%o4) [0.0, - 1.811 %i - .1036, 0.0, .6036 - .3107 %i, 0.0,
                                   .3107 %i + .6036, 0.0, 1.811 %i - .1036]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 2.168L-19 %i + 2.0, 7.525L-20 %i + 3.0,
          4.256L-19 %i + 4.0, - 1.0, - 2.168L-19 %i - 2.0,
          - 7.525L-20 %i - 3.0, - 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     Komplexe Daten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fft (L);
          (%o4) [0.5, .3536 %i + .3536, - 0.25 %i - 0.25,
          0.5 - 6.776L-21 %i, 0.0, - .3536 %i - .3536, 0.25 %i - 0.25,
          0.5 - 3.388L-20 %i]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0 - 4.066E-20 %i, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          - 1.008L-19 %i - 1.0, 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.947L-20 %i + 1.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.83L-17

     Berechnung der Sinus- und Kosinus-Koeffizienten.

          (%i1) load (fft) $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, 5, 6, 7, 8] $
          (%i4) n : length (L) $
          (%i5) x : make_array (any, n) $
          (%i6) fillarray (x, L) $
          (%i7) y : fft (x) $
          (%i8) a : make_array (any, n/2 + 1) $
          (%i9) b : make_array (any, n/2 + 1) $
          (%i10) a[0] : realpart (y[0]) $
          (%i11) b[0] : 0 $
          (%i12) for k : 1 thru n/2 - 1 do
             (a[k] : realpart (y[k] + y[n - k]),
              b[k] : imagpart (y[n - k] - y[k]));
          (%o12)                        done
          (%i13) a[n/2] : y[n/2] $
          (%i14) b[n/2] : 0 $
          (%i15) listarray (a);
          (%o15)          [4.5, - 1.0, - 1.0, - 1.0, - 0.5]
          (%i16) listarray (b);
          (%o16)           [0, - 2.414, - 1.0, - .4142, 0]
          (%i17) f(j) := sum (a[k] * cos (2*%pi*j*k / n) + b[k]
                                   * sin (2*%pi*j*k / n), k, 0, n/2) $
          (%i18) makelist (float (f (j)), j, 0, n - 1);
          (%o18)      [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]

 -- Funktion: horner (<expr>, <x>)
 -- Funktion: horner (<expr>)
     Formt ein Polynom <expr> in das Horner-Schema um.  Mit <x> wird die
     Variable angegeben, für die das Horner-Schema zu bilden ist.  Wird
     das Argument <x> nicht angegeben, wird die Hauptvariable des
     kanonischen Ausdrucks <expr> für die Bildung des Horner-Schemas
     genutzt.

     Das Horner-Schema kann die Stabilität der numerischen Berechnung
     eines Ausdrucks verbessern.

     Beispiel:

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154

 -- Funktion: find_root (<expr>, <x>, <a>, <b>)
 -- Funktion: find_root (<f>, <a>, <b>)
 -- Optionsvariable: find_root_error
 -- Optionsvariable: find_root_abs
 -- Optionsvariable: find_root_rel
     Findet die Nullstellen eines Ausdrucks <expr> oder einer Funktion
     <f> in dem Intervall `[<a>, <b>]'.  Der Ausdruck <expr> kann eine
     Gleichung sein.  In diesem Fall sucht die Funktion `find_root' die
     Nullstellen für den Ausdruck `lhs(<expr>) - rhs(<expr>)'.

     Kann Maxima den Ausdruck <expr> oder die Funktion <f> in dem
     Intervall `[<a>, <b>]' für alle Werte auswerten und ist der
     Ausdruck <expr> oder die Funktion <f> in dem Intervall stetig,
     dann ist sicher, dass `find_root' die Nullstelle oder zumindest
     eine Nullstelle findet, wenn mehrere Nullstellen vorhanden sind.

     `find_root' beginnt mit einer binären Suche der Nullstelle.
     Erscheint die Funktion als glatt genug, wendet Maxima einen
     Algorithmus mit einer linearen Interpolation für die Suche der
     Nullstelle an.

     Die Genauigkeit der Nullstellensuche wird von den Optionsvariablen
     `find_root_abs' und `find_root_rel' kontrolliert.  `find_root'
     endet, wenn die Auswertung der Funktion ein Ergebnis hat, das
     kleiner als `find_root_abs' ist oder wenn aufeinander folgende
     Auswertungen Ergebnisse <x_0> und <x_1> haben, die sich
     voneinander weniger als `find_root_rel * max(abs(x_0), abs(x_1))'
     unterscheiden.  Der Standardwert der Optionsvariablen
     `find_root_abs' und `find_root_rel' ist Null.

     `find_root' erwartet, dass die Funktion an den Endpunkten des
     Intervalls für die Nullstellensuche ein unterschiedliches
     Vorzeichen hat.  Hat die Funktion an den Endpunkten des Intervalls
     dasselbe Vorzeichen, wird das Verhalten der Funktion `find_root'
     von der Optionsvariablen `find_root_error' kontrolliert.  Hat
     `find_root_error' den Wert `true', wird eine Fehlermeldung
     ausgegeben.  Ansonsten wird von `find_root' der Wert von
     `find_root_error' als Ergebnis zurückgegeben.  Der Standardwert
     von `find_root_error' ist `true'.

     Kann die Funktion <f> bei der Nullstellensuche nicht zu einer Zahl
     ausgewertet werden, gibt `find_root' ein teilweise ausgewertetes
     Ergebnis zurück.

     Die Reihenfolge der Grenzen des Intervalls <a> und <b> wird
     ignoriert.  `find_root' sucht die Nullstellen immer in dem
     Intervall `[min(<a>, <b>), max(<a>, <b>)]'.

     Beispiele:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981
          (%i6) find_root (exp(x) = y, x, 0, 100);
                                      x
          (%o6)           find_root(%e  = y, x, 0.0, 100.0)
          (%i7) find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o7)                   2.302585092994046
          (%i8) log (10.0);
          (%o8)                   2.302585092994046

 -- Funktion: newton (<expr>, <x>, <x_0>, <eps>)
     Gibt eine Näherungslösung der Gleichung `<expr> = 0' zurück, die
     mit dem Newton-Algorithmus berechnet wird.  Der Ausdruck <expr>
     ist eine Funktion einer Variablen <x>.  Der Anfangswert ist ` <x>
     = <x_0>'.  Der Algorithmus bricht ab, wenn `abs(<expr>) < <eps>',
     wobei der Ausdruck <expr> für den aktuellen Näherungswert <x>
     ausgewertet wird.

     `newton' erlaubt symbolische Variablen im Ausdruck <expr>, wenn der
     Ausdruck `abs(<expr>) < <eps>' zu `true' oder `false' ausgewertet
     werden kann.  Daher ist es nicht notwendig, dass der Ausdruck
     <expr> zu einer Zahl ausgewertet werden kann.

     Das Kommando `load(newton1)' lädt die Funktion.

     Siehe auch die Funktionen `realroots',  `allroots',

     `find_root'  und `mnewton'.

     Beispiele:

          (%i1) load (newton1);
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a


File: maxima.info,  Node: Einführung in Fourierreihen,  Next: Funktionen und Variablen für Fourierreihen,  Prev: Funktionen und Variablen für die schnelle Fourier-Transformation,  Up: Fourier-Transformationen

23.3 Einführung in Fourierreihen
================================

Das Paket `fourie' enthält Funktionen für die symbolische Berechnungen
von Fourierreihen.  Weiterhin enthält das Paket Funktionen, um
Fourierkoeffizienten zu berechnen und einige weitere Funktionen.


File: maxima.info,  Node: Funktionen und Variablen für Fourierreihen,  Prev: Einführung in Fourierreihen,  Up: Fourier-Transformationen

23.4 Funktionen und Variablen für Fourierreihen
===============================================

 -- Funktion: equalp (<x>, <y>)
     Gibt `true' zurück, wenn `equal(<x>, <y>)' das Ergebnis `true'
     hat.  Ansonsten ist das Ergebnis `false'.

 -- Funktion: remfun (<f>, <expr>)
 -- Funktion: remfun (<f>, <expr>, <x>)
     `remfun(<f>, <expr>' ersetzt `<f>(<arg>)' durch <arg> im Ausdruck
     <expr>.

     `remfun(<f>, <expr>, <x>)' ersetzt `<f> (<arg>)' durch <arg> im
     Ausdruck <expr> nur dann, wenn <arg> die Variable <x> enthält.

 -- Funktion: funp (<f>, <expr>)
 -- Funktion: funp (<f>, <expr>, <x>)
     `funp(<f>, <expr>)' hat das Ergebnis `true', wenn der Ausdruck
     <expr> die Funktion <f> enthält.

     `funp(<f>, <expr>, <x>)' hat das Ergebnis `true', wenn der
     Ausdruck <expr> die Funktion <f> enthÃ¤lt und die Variable <x> ein
     Argument der Funktion <f> ist.

 -- Funktion: absint (<f>, <x>, <halfplane>)
 -- Funktion: absint (<f>, <x>)
 -- Funktion: absint (<f>, <x>, <a>, <b>)
     `absint(<f>, <x>, <halfplane>)' gibt das unbestimmte Integral der
     Funktion <f> für die Variable <x> zurück.  Das Integral wird in
     der angegebenen Halbebene `pos', `neg' oder für beide Halbebenen
     mit `both' berechnet.  Der Integrand kann die Betragsfunktion
     enthalten: `abs(x)', `abs(sin(x))', `abs(a) * exp(-abs(b) *
     abs(x))'.

     `absint(<f>, <x>)' ist äquivalent zu `absint(<f>, <x>, pos)'.

     `absint(<f>, <x>, <a>, <b>)' gibt das bestimmte Integral der
     Funktion <f> für die Variable <x> in den Grenzen <a> und <b>
     zurück.  Der Integrand kann die Betragsfunktion enthalten.

 -- Funktion: fourier (<f>, <x>, <l>)
     Berechnet die Fourier-Koeffizienten `a[0]', `a[n]' und `b[n]' der
     Funktion `<f>(<x>)' für das Intervall `[-l, l]'.  Die Fourierreihe
     ist definiert als:

                   inf
                   ====
                   \             %pi n x           %pi n x
            f(x) =  >    (b  sin(-------) + a  cos(-------))
                   /       n        l        n        l
                   ====
                   n = 0

     Die Koeffizienten der Fourierreihe werden folgendermaßen berechnet:

                               l
                              /
                          - 1 [
                a  = 1/2 l    I    f(x) dx
                 0            ]
                              /
                               - l

                           l
                          /
                      - 1 [                  - 1
                a  = l    I    f(x) cos(%pi l    n x) dx
                 n        ]
                          /
                           - l

                            l
                           /
                      - 1 [                  - 1
                b  = l    I    f(x) sin(%pi l    n x) dx
                 n        ]
                          /
                           - l

     `fourier' weist die Fourier-Koeffizienten Zwischenmarken zu.  Die
     Zwischenmarken werden als eine Liste zurückgegeben.

     Der Index der Summe ist immer das Symbol <n>.  Sinus- und
     Kosinusfunktionen mit ganzzahligen Vielfachen von `%pi' werden
     nicht automatisch vereinfacht.  Dies kann mit der Funktion
     `foursimp'  erreicht werden, der als Argument die Liste der
     Fourier-Koeffizienten übergeben wird.

     Mit der Funktion `fourexpand'  kann die Fourierreihe aus den
     Fourier-Koeffizienten konstruiert werden.  Siehe auch die Funktion
     `totalfourier'.

     Mit den Funktionen `fourcos'  und `foursin'  werden jeweils die
     Koeffizienten der Kosinus- und Sinus-Entwicklung berechnet.

     Beispiel:

          (%i1) load(fourie)$

          (%i2) fourier(x, x, 1);
          (%t2)                        a  = 0
                                        0

          (%t3)                        a  = 0
                                        n

                                  sin(%pi n)   cos(%pi n)
          (%t4)           b  = 2 (---------- - ----------)
                           n          2  2       %pi n
                                   %pi  n

          (%o4)                    [%t2, %t3, %t4]
          (%i5) foursimp(%);
          (%t5)                        a  = 0
                                        0

          (%t6)                        a  = 0
                                        n

                                                 n
                                          2 (- 1)
          (%t7)                    b  = - --------
                                    n      %pi n

          (%o7)                    [%t5, %t6, %t7]
          (%i8) fourexpand(%, x, 1, inf);
                                inf
                                ====       n
                                \     (- 1)  sin(%pi n x)
                              2  >    -------------------
                                /              n
                                ====
                                n = 1
          (%o8)             - ---------------------------
                                          %pi

 -- Funktion: foursimp (<l>)
     `foursimp' wird auf das Ergebnis der Funktion `fourier'
     angewendet, um Sinus- und Kosinus-Funktionen zu vereinfachen, die
     ganzzahlige Vielfache von `%pi' enthalten.  Das Argument <l> ist
     eine Liste mit den Koeffizienten der Fourierreihe, für die die
     Vereinfachung ausgeführt werden soll.

     `sin(n %pi)' wird zu `0' vereinfacht, wenn die Optionsvariable
     `sinnpiflag'  den Wert `true' hat, und `cos(n %pi)' wird zu
     `(-1)^n', wenn die Optionsvariable `cosnpiflag'  den Wert `true'
     hat.

     Siehe die Funktion `fourier'  für ein Beispiel.

 -- Optionsvariable: sinnpiflag
     Standardwert: `true'

     Kontrolliert die Vereinfachung der Sinus-Funktion durch die
     Funktion `foursimp'.  Siehe die Funktion `foursimp'.


 -- Optionsvariable: cosnpiflag
     Standardwert: `true'

     Kontrolliert die Vereinfachung der Kosinus-Funktion durch die
     Funktion `foursimp'.  Siehe die Funktion `foursimp'.


 -- Funktion: fourexpand (<l>, <x>, <p>, <limit>)
     Konstruiert aus der Liste der Fourier-Koeffizienten <l> eine
     Fourierreihe mit <limit> Termen.  Das Argument <limit> kann `inf'
     sein.  Die Argumente <x> und <p> haben dieselbe Bedeutung wie für
     die Funktion `fourier'.

     Siehe die Funktion `fourier'  für ein Beispiel.

 -- Funktion: fourcos (<f>, <x>, <p>)
     Gibt die Kosinus-Koeffizienten einer Fourierreihe für die Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, <p>]' definiert ist.

 -- Funktion: foursin (<f>, <x>, <p>)
     Gibt die Sinus-Koeffizienten einer Fourierreihe für die Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, <p>]' definiert ist.

 -- Funktion: totalfourier (<f>, <x>, <l>)
     Gibt die Fourierreihe der Funktion <f(x)> für das Intervall
     `[<-l>, <l>]' zurück.  Das Ergebnis wird berechnet, indem die
     nacheinander die Funktionen `foursimp'  und `fourexpand'  auf das
     Ergebnis der Funktion `fourier'  angewendet werden.

     Beispiel:

          (%i1) load(fourie)$

          (%i2) totalfourier(x, x, 1);
          (%t2)                        a  = 0
                                        0

          (%t3)                        a  = 0
                                        n

                                  sin(%pi n)   cos(%pi n)
          (%t4)           b  = 2 (---------- - ----------)
                           n          2  2       %pi n
                                   %pi  n

          (%t5)                        a  = 0
                                        0

          (%t6)                        a  = 0
                                        n
                                                 n
                                          2 (- 1)
          (%t7)                    b  = - --------
                                    n      %pi n
                                inf
                                ====       n
                                \     (- 1)  sin(%pi n x)
                              2  >    -------------------
                                /              n
                                ====
                                n = 1
          (%o7)             - ---------------------------
                                          %pi


 -- Funktion: fourint (<f>, <x>)
     Konstruiert eine Liste der Fourierintegral-Koeffizienten der
     Funktion `<f>(<x>)', die auf dem Intervall `[minf, inf]' definiert
     ist.

 -- Funktion: fourintcos (<f>, <x>)
     Gibt die Koeffizienten des Kosinus-Fourierintegrals der Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, inf]' definiert ist.


 -- Funktion: fourintsin (<f>, <x>)
     Gibt die Koeffizienten des Sinus-Fourierintegrals der Funktion
     `<f>(<x>)' zurück, die auf dem Intervall `[0, inf]' definiert ist.


File: maxima.info,  Node: Muster und Regeln,  Next: Funktionsdefinitionen,  Prev: Fourier-Transformationen,  Up: Top

24 Muster und Regeln
********************

* Menu:

* Einführung in Muster und Regeln::
* Funktionen und Variablen für Muster und Regeln::


File: maxima.info,  Node: Einführung in Muster und Regeln,  Next: Funktionen und Variablen für Muster und Regeln,  Prev: Muster und Regeln,  Up: Muster und Regeln

24.1 Einführung in Muster und Regeln
====================================

Dieses Kapitel beschreibt die nutzerdefinierte Mustererkennung und
Vereinfachungsregeln.  Es gibt zwei verschiedene Gruppen an Funktionen,
die eine etwas unterschiedliche Mustererkennung implementieren.  Die
eine Gruppe enthält die Funktionen `tellsimp',  `tellsimpafter',

`defmatch',  `defrule',  `apply1',  `applyb1'  und `apply2'.    In der
anderen Gruppe sind die Funktionen `let'  und `letsimp'  enthalten.
Beide Mustererkennungsverfahren verwenden die Funktion `matchdeclare',
um Muster zu definieren.

Regeln, die mit den Funktionen `tellsimp' und `tellsimpafter' definiert
werden, werden von Maxima automatisch bei der Vereinfachung von
Ausdrücken angewendet.  Regeln die mit den Funktionen `defmatch',
`defrule' oder `let' definiert werden, werden durch den Aufruf einer
Funktion angewendet.

Es gibt zusätzliche Mechanismen wie `tellrat',  um Regeln auf Polynome
anzuwenden und weitere Funktionen der kommutativen und
nicht-kommutativen Algebra in dem `affine' -Paket.


File: maxima.info,  Node: Funktionen und Variablen für Muster und Regeln,  Prev: Einführung in Muster und Regeln,  Up: Muster und Regeln

24.2 Funktionen und Variablen für Muster und Regeln
===================================================

 -- Funktion: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Wendet die Regel <rule_1> auf den Ausdruck <expr> solange an, bis
     die Anwendung fehlschlägt.  Dann wird die Regel von links nach
     rechts auf alle Teilausdrücke von <expr> angewendet.  Ist <expr_2>
     das Ergebnis, dann wird die Regel <rule_2> auf gleiche Weise auf
     den Ausdruck <expr_2> angewendet.  Zuletzt wird die Regel <rule_n>
     angewendet.  Das letzte Ergebnis wird zurückgegeben.

     Die Optionsvariable `maxapplydepth'  ist die größte
     Verschachtelungstiefe für die die Funktionen `apply1' und `apply2'
     auf einen Ausdruck angewendet werden.

     Siehe auch `applyb1',  `apply2'  und `let'.

     Beispiele:

          (%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o1)               trig1 : tan(x) -> ------
                                                cos(x)
          (%i2) defrule(trig2, cot(x), 1/tan(x));
                                                  1
          (%o2)               trig2 : cot(x) -> ------
                                                tan(x)
          (%i3) apply1(cot(x), trig1, trig2);
                                         1
          (%o3)                        ------
                                       tan(x)
          (%i4) apply1(cot(x), trig2, trig1);
                                       cos(x)
          (%o4)                        ------
                                       sin(x)

 -- Funktion: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Zunächst werden nacheinander die Regeln <rule_1>, <rule_2>, ...
     auf einen Ausdruck angewendet.  Schlägt die Anwendung aller Regeln
     fehl, dann werden die Regeln nacheinander auf Teilausdrücke von
     <expr> angewendet.  Kann eine der Regeln erfolgreich angewendet
     werden, wird die Anwendung aller Regeln auf den Teilausdruck
     wiederholt.

     Die Optionsvariable `maxapplydepth'  ist die größte
     Verschachtelungstiefe für die die Funktionen `apply1'  und `apply2'
     auf einen Ausdruck angewendet werden.

     Siehe auch `apply1',  `applyb1'  und `let'.

     Beispiele:

          (%i1) defrule(trig1, tan(x), sin(x)/cos(x));
                                                sin(x)
          (%o1)               trig1 : tan(x) -> ------
                                                cos(x)
          (%i2) defrule(trig2, cot(x), 1/tan(x));
                                                  1
          (%o2)               trig2 : cot(x) -> ------
                                                tan(x)
          (%i3) apply2(cot(x), trig1, trig2);
                                       cos(x)
          (%o3)                        ------
                                       sin(x)
          (%i4) apply2(cot(x), trig2, trig1);
                                       cos(x)
          (%o4)                        ------
                                       sin(x)

 -- Funktion: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Wendet wiederholt die Regel <rule_1> auf den tiefsten Teilausdruck
     an.  Schlägt die Anwendung fehlt, wird der Teilausdruck eine Ebene
     höher betrachtet, bis <rule_1> auf die oberste Ebene des Ausdrucks
     <expr> angewendet wird.  Danach wird auf gleiche Weise die Regel
     <rule_2> auf den Ausdruck <expr> angewendet.  Nachdem die letzte
     Regel <rule_n> angewendet wurde, wird das Ergebnis zurückgegeben.

     `applyb1' ist vergleichbar mit `apply1'  mit dem Unterschied, dass
     die Regeln Bottum-Up angewendet werden.

     `maxapplyheight'  ist die größte Verschachtelungstiefe für die
     `applyb1' angewendet wird.

     Siehe auch `apply1',  `apply2'  und `let'.


 -- Funktion: clear_rules ()
     Führt das Kommando `kill(rules)' aus und setzt den Zähler für die
     Benennung der Regeln der Addition, der Multiplikation und der
     Exponentiation zurück.  Siehe auch `kill'.


 -- Optionsvariable: current_let_rule_package
     Standardwert: `default_let_rule_package'

     `current_let_rule_package' enthält den Namen des Regel-Paketes,
     das von den `let'-Funktionen verwendet wird.  Der Optionsvariablen
     kann jedes mit dem Kommando `let' definierte Regelpaket zugewiesen
     werden.

     Wird das Kommando `letsimp(expr, rule_pkg_name' ausgeführt, dann
     wird für das aktuelle Kommando das Paket `rule_pkg_name'
     verwendet.  Der Wert der Variablen `current_let_rule_package' wird
     nicht geändert.

 -- Optionsvariable: default_let_rule_package
     Standardwert: `default_let_rule_package'

     `default_let_rule_package' ist der Name des Regelpaketes, das
     verwendet wird, wenn kein Regelpaket mit der Funktion `let'
     explizit definiert wurde.

 -- Funktion: defmatch (<progname>, <pattern>, <x_1>, ..., <x_n>)
 -- Funktion: defmatch (<progname>, <pattern>)
     Definiert eine Aussagefunktion `<progname>(<expr>, <x_1>, ...,
     <x_n>)', die einen Ausdruck <expr> testet, um zu prüfen, ob dieser
     das Muster <pattern> enthält.

     <pattern> ist ein Ausdruck, der die Musterargumente <x_1>, ...,
     <x_n> enthält, sowie weitere Mustervariablen enthalten kann, die
     mit der Funktion `matchdeclare'  deklariert sind.  Alle Variable,
     die nicht als Musterargumente der Funktion `defmatch' oder als
     Mustervariable mit `matchdeclare' definiert sind, entsprechen sich
     selbst.

     Das erste Argument der definierten Aussagefunktion <progname> ist
     ein Ausdruck, für den das Muster geprüft wird.  Die weiteren
     Argumente sind die Variablen, die den Musterargumenten <x_1>, ...,
     <x_n> des Musters <pattern> entsprechen.

     Ist der Test erfolgreich, gibt die Aussagefunktion <progname> eine
     Liste mit Gleichungen zurück.  Die linke Seite der Gleichungen
     sind die Musterargumente und Mustervariablen und die rechte Seite
     sind die Teilausdrücke für die eine Übereinstimmung gefunden
     wurde.  Den Mustervariablen, jedoch nicht den Musterargumenten,
     werden die Ergebnisse zugewiesen.  Ist der Test nicht erfolgreich,
     ist die Rückgabe `false'.

     Ein Muster, dass keine Musterargumente oder Mustervariablen
     enthält, hat den Rückgabewert `true', wenn der Test erfolgreich
     ist.

     Siehe auch `matchdeclare',  `defrule',  `tellsimp'  und
     `tellsimpafter'.

     Beispiele:

     Definiere eine Funktion `linearp(expr, x)', die testet, ob ein
     Ausdruck <expr> die Form `a*x+b' hat, wobei `a' und `b' die
     Variable <x> nicht enthalten und `a' von Null verschieden ist.
     Die Definition enthält das Musterargument <x>, so dass die
     Linearität des Ausdrucks für eine beliebige Variable getestet
     werden kann.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)),
                              b, freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     Wie oben wird eine Testfunktion definiert, die prüft ob ein
     Ausdruck <expr> linear ist.  In diesem Fall wird kein
     Musterargument angegeben.  Der Test kann nur feststellen, ob ein
     Ausdruck linear in der Variablen <x> ist.  Eine andere Variable
     ist nicht möglich.

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     Definiere eine Testfunktion `checklimits(expr)', die prüft, ob ein
     Ausdruck <expr> ein bestimmtes Integral ist.

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]

 -- Funktion: defrule (<rulename>, <pattern>, <replacement>)
     Definiert eine Regeln, um das Muster <pattern> durch den Ausdruck
     <replacement> zu ersetzen.  Wird die Regeln mit dem Namen
     <rulename> mit den Funktionen `apply1',  `apply2'  oder `applyb1'
     auf einen Ausdruck angewendet, wird alle Teilausdrücke, die dem
     Muster <pattern> entsprechen durch den Ausdruck <replacement>
     ersetzt.

     Die Regel <rulename> kann auch als eine Funktion angewendet
     werden, die, falls vorhanden, das Muster <pattern> durch
     <replacement> ersetzt.

     Beispiele:

     Es wird eine Regel definiert, um den Ausdruck `sin(x)^2' nach
     `1-cos(x)^2' transformiert.  Diese Definition funktioniert nur für
     einen Ausdruck <sin(x)^2>.

          (%i1) defrule(trig, sin(x)^2, 1-cos(x)^2);
                                      2              2
          (%o1)             trig : sin (x) -> 1 - cos (x)
          (%i2) trig(sin(x)^2);
                                            2
          (%o2)                      1 - cos (x)
          (%i3) trig(sin(y)^2);
          (%o3)                         false

     In diesem Fall wird zunächst mit der Funktion `matchdeclare'  eine
     Mustervariable <a> definiert, der jeder Ausdruck zugewiesen werden
     kann und die als Argument der Ersetzungsregel verwendet wird.
     Jetzt kann das Argument der Sinusfunktion ein beliebiger Ausdruck
     sein.

          (%i1) matchdeclare(a, true);
          (%o1)                         done
          (%i2) defrule(trig, sin(a)^2, 1-cos(a)^2);
                                      2              2
          (%o2)             trig : sin (a) -> 1 - cos (a)
          (%i3) trig(sin(x)^2);
                                            2
          (%o3)                      1 - cos (x)
          (%i4) trig(sin(exp(x))^2);
                                           2   x
          (%o4)                     1 - cos (%e )

     Die Ersetzungsregel kann mit der Funktion `apply1'  auf
     verschachtelte Ausdrücke angewendet werden.

          (%i5) trig(exp(sin(x)^2));
          (%o5)                         false
          (%i6) apply1(exp(sin(x)^2), trig);
                                             2
                                      1 - cos (x)
          (%o6)                     %e

 -- Funktion: disprule (<rulename_1>, ..., <rulename_2>)
 -- Funktion: disprule (all)
     Zeigt die Regeln mit den Namen <rulename_1>, ..., <rulename_n> an.
     Den einzelnen Regeln werden mit einer Zwischenmarke `%t'
     angezeigt.

     Mit dem Kommando `disprule(all)' werden alle Regeln angezeigt.

     `disprule' wertet die Argumente nicht aus.  Der Rückgabewert ist
     eine Liste mit den Zwischenmarken, denen eine Regel zugewiesen
     wurde.

     Sieh auch die Funktion `letrules',  die die Regeln ausgibt, die mit
     der Funktion `let'  definiert wurden.

     Beispiele:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]

 -- Funktion: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Funktion: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <package_name>)
     Definiert eine Ersetzungsregel, die mit der Funktion `letsimp'
     auf einen Ausdruck angewendet wird, so dass <prod> durch <repl>
     ersetzt wird.  Das Argument <prod> ist ein Produkt von positiven
     oder negativen Potenzen der folgenden Terme:

        * Atome, nach denen die Funktion `letsimp' wörtlich sucht, wenn
          kein Muster mit der Funktion `matchdeclare'  definiert wurde,
          sowie Atome, denen mit der Funktion `matchdeclare' eine
          Aussagefunktion zugeordnet wurde.

        * Terme wie `sin(x)', `n!' oder `f(x,y)'.  Wie für Atome sucht
          die Funktion `letsimp' nach wörtlichen Übereinstimmungen,
          sowie nach Übereinstimmungen, die mit der Funktion
          `matchdeclare' für einen Ausdruck definiert wurde.

     Ein Term mit einer positiven Potenz stimmt mit einem Ausdruck nur
     dann überein, wenn dieser mindestens dieselbe Potenz hat.
     Entsprechend gilt für einen Term mit einer negativen Potenz, dass
     dieser dann mit einem Ausdruck übereinstimmt, wenn dieser
     mindestens dieselbe negative Potenz hat.  Für negative Potenzen
     muss weiterhin die Optionsvariable `letrat'  den Wert `true' haben.

     Hat die Funktion `let' eine Aussagefunktion <predname> als
     Argument, mit dem Argumenten <arg_1>, ..., <arg_n>, wird eine
     vorläufige Übereinstimmung dann festgestellt wenn der Ausdruck
     `predname(arg_1', ..., arg_n')' das Ergebnis `true' hat.  Die
     Argumente <arg_i> können die Namen von Variablen oder Termen sein,
     die im Ausdruck <pred> auftreten.  <repl> kann ein beliebiger
     rationaler Ausdruck sein.  Treten irgendwelche der Symbole oder
     Argumente aus <prod> im Argument <repl> auf, wird die
     entsprechende Substitution ausgeführt.

     Die Optionsvariable `letrat'  kontrolliert die Vereinfachung von
     Quotienten durch `letsimp'.    Hat `letrat' den Wert `false',
     werden der Zähler und der Nenner eines Bruches einzeln
     vereinfacht.  Der Bruch als ganzes wird dagegen nicht vereinfacht.
     Hat die Optionsvariable `letrat' den Wert `false', werden
     nacheinander der Zähler, der Nenner und dann der Bruch vereinfacht.

     Die Funktion `letsimp'  kann mit verschiedenen Regelpaketen
     arbeiten.  Jedes Regelpaket kann eine beliebige Anzahl an
     `let'-Regeln enthalten und erhält vom Nutzer einen Namen.  Das
     Kommando `let([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
     <package_name>)' fügt die Regel <predname> dem Paket
     <package_name> hinzu.  Das Kommando `letsimp(<expr>,
     <package_name1>, <package_name2>, ...)' ist äquivalent zu
     `letsimp(<expr>, <package_name1>)', dem das Kommando `letsimp(%,
     <package_name2>)', ... folgt.

     Die Optionsvariable `current_let_rule_package'  enthält den Namen
     des Regelpaketes, das aktuell von der Funktion `letsimp' verwendet
     wird.  Der Optionsvariablen kann jedes mit dem Kommando `let'
     definierte Regelpaket zugewiesen werden.  Wird mit
     `letsimp(<expr>, <package_name>)' ein Regelpaket als Argument
     übergeben, wird dieses anstatt dem in `current_let_rule_package'
     enthaltene Regelpaket für die Vereinfachung verwendet.  Wenn nicht
     anders spezifiziert, hat `current_let_rule_package' den
     Standardwert `default_let_rule_package'.

     Beispiele:

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1

 -- Optionsvariable: letrat
     Standardwert: `false'

     Hat die Optionsvariable `letrat' den Wert `false', werden der
     Zähler und der Nenner eines Bruches einzeln vereinfacht.  Der
     Bruch als ganzes wird dagegen nicht vereinfacht.

     Hat die Optionsvariable `letrat' den Wert `false', werden
     nacheinander der Zähler, der Nenner und dann der Bruch vereinfacht.

     Beispiele:

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!

 -- Funktion: letrules ()
 -- Funktion: letrules (<package_name>)
     Zeigt die Regeln eines Regel-Paketes an.  Das Kommando
     `letrules()' zeigt die Regeln des aktuellen Regel-Paketes an, das
     in der Optionsvariablen `current_let_rule_package'  enthalten ist.
     Das Kommando `letrules(<package_name>)' zeigt die Regeln des
     Paketes <package_name> an.

     Wenn der Optionsvariablen `current_let_rule_package' kein Paket
     zugewiesen wurde, enthält es den Standardwert
     `default_let_rule_package'.

     Siehe auch die Funktion `disprule',  um Regeln anzuzeigen, die mit
     `tellsimp',  `tellsimpafter'  und `defrule'  definiert wurden.

     Beispiel:

     Im folgenden Beispiel werden einem Paket mit dem Namen `trigrules'
     zwei Regeln hinzugefügt.  Die Regeln werden mit dem Kommando
     `letrules(trigrules)' angezeigt.  Wird das Paket zum aktuellen
     Paket erklärt, indem es der Variablen `current_let_rule_package'
     zugewiesen wird, dann werden die Regeln auch mit dem Kommando
     `letrules()' angezeigt.

          (%i1) let([sin(x)^2, 1-cos(x)^2], trigrules);
                                  2               2
          (%o1)                sin (x) --> 1 - cos (x)
          (%i2) let([tan(x), sin(x)/cos(x)], trigrules);
                                             sin(x)
          (%o2)                   tan(x) --> ------
                                             cos(x)
          (%i3) letrules(trigrules);
                                             sin(x)
                                  tan(x) --> ------
                                             cos(x)

                                  2               2
                               sin (x) --> 1 - cos (x)

          (%o3)                         done
          (%i4) letrules();
          (%o4)                         done
          (%i5) current_let_rule_package: trigrules;
          (%o5)                       trigrules
          (%i6) letrules();
                                             sin(x)
                                  tan(x) --> ------
                                             cos(x)

                                  2               2
                               sin (x) --> 1 - cos (x)

          (%o6)                         done

 -- Funktion: letsimp (<expr>)
 -- Funktion: letsimp (<expr>, <package_name>)
 -- Funktion: letsimp (<expr>, <package_name_1>, ..., <package_name_n>)
     Wendet die Substitutionsregeln, die mit der Funktion `let'
     definiert sind, solange an, bis sich das Argument <expr> nicht
     mehr ändert.  `letsimp(<expr>)' wendet die Regeln der
     Optionsvariablen `current_let_rule_package'  an.

     `letsimp(<expr>), <package_name>)' wendet die Regeln des
     Argumentes <package_name> an.  Die Optionsvariable
     `current_let_rule_package' ändert ihren Wert nicht.

     `letsimp(<expr>, <package_name_1>, ..., <package_name_n>)' ist
     äquivalent zum Kommando `letsimp(<expr>, <package_name_1>)' dem
     `letsimp(%, <package_name_2>)' folgt u.s.w.

 -- Optionsvariable: let_rule_packages
     Standardwert: `[default_let_rule_package]'

     `let_rule_packages' ist eine Informationsliste mit den vom Nutzer
     definierten `let'-Regeln.

 -- Funktion: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Assoziiert eine Aussage <pred_k> mit einer Variable oder eine
     Liste von Variablen <a_k>, so dass <a_k> mit Ausdrücken
     übereinstimmt, für die die Aussage ein anderes Ergebnis als
     `false' zurück gibt.

     Eine Aussage ist der Name einer Funktion, ein Lambda-Ausdruck, ein
     Funktionsaufruf, ein Lambda-Ausdruck, dem das letzte Argument
     fehlt, oder die Werte `true' oder `all'.  Ist die Aussage ein
     Funktionsaufruf oder ein Lambda-Aufruf, dann wird der zu testende
     Ausdruck an die Liste der Argumente angefügt.  Die Argumente
     werden ausgewertet, wenn die Übereinstimmung ausgewertet wird.
     Ist die Aussage der Name einer Funktion oder ein Lambda-Ausdruck,
     ist die zu testende Aussage das einzige Argument.  Eine
     Aussagefunktion braucht nicht definiert zu sein, wenn
     `matchdeclare' aufgerufen wird.  Die Aussage wird nicht eher
     ausgewertet, bevor eine Übereinstimmung getestet wird.

     Eine Aussage kann einen logischen Ausdruck oder die Werte `true'
     oder `false' zurück geben.  Logische Ausdrücke werden von `is'

     von der definierten Regel ausgewertet.  Daher ist es nicht
     notwendig, dass die Aussage selbst die Funktion `is' aufruft.

     Wenn für ein Ausdruck eine Übereinstimmung gefunden wird, wird der
     Mustervariablen der Ausdruck zugewiesen.  Jedoch nicht für
     Mustervariablen, die Argumente der Addition `+' oder
     Multiplikation `*' sind.  Diese Operatoren werden besonders
     behandelt.  Andere Maxima oder vom Nutzer definierte
     N-ary-Operatoren werden dagegen wie andere Funktionen behandelt.

     Im Falle der Addition und Multiplikation kann der Mustervariablen
     ein einzelner Term zugewiesen werden, welcher mit der Aussage
     übereinstimmt, aber auch eine Summe oder ein Produkt solcher
     Ausdrücke.  Die mehrfache Übereinstimmung ist vorrangig: Aussagen
     werden in der Reihenfolge ausgewertet, in der die Mustervariablen
     im Musterausdruck auftreten.  Stimmt ein Termin mit mehreren
     Aussagen überein, wird der Term der ersten Aussage zugeordnet, die
     zutrifft.  Jede Aussage wird zunächst auf alle Argumente einer
     Summe oder eines Produktes angewendet, bevor die nächste Aussage
     ausgewertet wird.  Wird für die Zahlen 0 oder 1 eine
     Übereinstimmung gefunden und es sind keine weiteren Terme
     vorhanden, wird der Mustervariablen 0 oder 1 zugewiesen.

     Der Algorithmus, um Muster mit der Addition und Multiplikation zu
     verarbeiten, ist für manche Übereinstimmungen abhängig von der
     Anordnung der Terme im Muster und im Ausdruck für den eine
     Übereinstimmung gesucht wird.  Solange sich jedoch die einzelnen
     Muster gegeneinander ausschließen, wird das Ergebnis nicht von der
     Reihenfolge der Argumente beeinflußt.

     Der Aufruf von `matchdeclare' für eine Variable <a> überschreibt
     einen vorhergehenden Aufruf von `matchdeclare' für diese Variable.
     Nur die letzte Definition ist wirksam, wenn eine Regel definiert
     wird.  Spätere Änderungen der `matchdeclare'-Eigenschaft eines
     Symbols haben keinen Einfluss auf definierte Regeln.

     Das Kommando `propvars(matchdeclare)' gibt eine Liste der Variablen
     zurück, für die eine `matchdeclare'-Eigenschaft definiert ist.
     `printprops(<a>, matchdeclare)' gibt die der Variable zugeordnete
     Aussage zurück.  `printprops(all, matchdeclare)' gibt die Aussagen
     aller Variablen mit einer `matchdeclare'-Eigenschaft zurück.
     `remove(<a>, matchdeclare)' entfernt die
     `matchdeclare'-Eigenschaft für die Variable <a>.

     Die Funktion `defmatch',  `defrule',  `tellsimp',

     `tellsimpafter'  und `let'  konstruieren Regeln, die Ausdrücke
     gegen Muster testen.

     `matchdeclare' wertet die Argumente nicht aus.  `matchdeclare' gibt
     immer `done' als Ergebnis zurück.

     Beispiele:

     Eine Aussage ist der Name einer Funktion, ein Lambda-Ausdruck, ein
     Funktionsaufruf, ein Lambda-Ausdruck, dem das letzte Argument
     fehlt, oder die Werte `true' oder `all'.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     Stimmt ein Ausdruck mit einer Musteraussage überein, wird der
     Ausdruck der Mustervariable zugewiesen.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     Im Falle der Addition und Multiplikation kann der Mustervariablen
     ein einzelner Term zugewiesen werden, welcher mit der Aussage
     übereinstimmt, aber auch eine Summe oder ein Produkt solcher
     Ausdrücke.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     Wird nach Übereinstimmungen für die Argumente der Operatoren `+'
     oder `*' gesucht und schließen sich die Aussagen gegeneinander
     aus, ist das Ergebnis unabhängig von der Anordnung der Terme.

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     Die Funktionen `propvars'  und `printprops'  geben Informationen
     über Mustervariablen.

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]

 -- Optionsvariable: maxapplydepth
     Standardwert: 10000

     `maxapplydepth' ist die maximale Tiefe für die die Funktionen
     `apply1'  und `apply2'  rekursiv auf einen Ausdruck angewendet
     werden.

 -- Optionsvariable: maxapplyheight
     Standardwert: 10000

     `maxapplyheight' ist die maximale Größe die `applyb1' erreichen
     kann, bevor die Funktion aufgibt.

 -- Funktion: remlet (<prod>, <package_name>)
 -- Funktion: remlet ()
 -- Funktion: remlet (all)
 -- Funktion: remlet (all, <package_name>)
     Entfernt die Ersetzungsregel <prod> -> <repl> die zuletzt mit der
     Funktion `let'  definiert wurde.  Wird mit dem Argument
     <package_name> ein Paket angegeben, wird die Regeln aus dem Paket
     entsprechenden Paket entfernt.

     `remlet()' und `remlet(all)' entfernen alle Ersetzungsregeln aus
     dem aktuellen Paket, das in `current_let_rule_package'  enthalten
     ist.  Wird ein Regelpaket als Argument angegeben, werden
     zusätzlich die Regeln dieses Paketes entfernt.

     Soll eine vorhandene Ersetzungsregel durch eine neue Definition
     ersetzt werden, muss die Regel zuvor nicht mit `remlet' entfernt
     werden.  Die neue Definition überschreibt eine vorhandene Regel.

     Siehe auch `remrule',  um Regeln zu entfernen, die mit `tellsimp'
     oder `tellsimpafter'  definiert sind.

 -- Funktion: remrule (<op>, <rulename>)
 -- Funktion: remrule (<op>, all)
     Entfernt Regeln die mit den Funktionen `tellsimp'  oder
     `tellsimpafter'.   definiert wurden.

     `remrule(<op>, <rulename>)' entfernt die Regel mit dem Namen
     <rulename> vom Operator <op>.  Ist der Operator <op> ein
     Maxima-Operator oder ein nutzerdefinierter Operator, der mit
     Funktionen wie `infix'  oder `prefix'  definiert wurde, muss der
     Name des Operators <op> in Anführungszeichen angegeben werden.

     `remrule(<op>, all)' entfernt alle Regeln des Operators <op>.

     Siehe auch die Funktion `remlet',  um Regeln zu entfernen, die mit
     der Funktion `let'  definiert sind.

     Beispiele:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", ?\+rule1);
          (%o9)                           +
          (%i10) remrule ("@@", ?\@\@rule1);
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]

 -- Systemvariable: rules
     Standardwert: `[]'

     Enthält die vom Nutzer mit den Funktionen `tellsimp',
     `tellsimpafter', `defmatch' oder `defrule' definierten Regeln.
     Siehe auch `infolists'.


 -- Funktion: tellsimp (<pattern>, <replacement>)
     `tellsimp' ist vergleichbar mit der Funktion `tellsimpafter',

     wobei `tellsimp' die Vereinfachungsregel vor der Anwendung der
     eingebauten Vereinfachungen ausgeführt wird.

     `tellsimp' wird eingesetzt, wenn Maxima Regeln für die
     Vereinfachung des Ausdruckes kennt, es jedoch notwendig ist, noch
     vor Anwendung dieser Regeln den Ausdruck auf eine andere Art zu
     modifizieren.  Für den Fall das Maxima den Ausdruck nicht
     ausreichend vereinfacht, kann es besser sein, eine
     Vereinfachungsregel mit `tellsimpafter'  zu definieren.

     Das Argument <pattern> kann keine Summe, Produkte, eine einzelne
     Variable oder eine Zahl sein.

     `rules' ist eine Informationsliste, die alle Regeln enthält die
     mit den `tellsimpafter',  `defrule',  `defmatch'  und `tellsimp'
     definiert sind.

     Beispiele:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)

 -- Funktion: tellsimpafter (<pattern>, <replacement>)
     Definiert eine Vereinfachungsregel, die nach Anwendung der
     eingebauten Regeln angewendet wird.  <pattern> ist ein Ausdruck,
     der Mustervariablen enthält, die mit der Funktion `matchdeclare'
     definiert werden und weitere Symbole und Operatoren, für die die
     wörtliche Übereinstimmung in einem Ausdruck angenommen wird.
     <replacement> wird in den Ausdruck substituiert, wenn <pattern> im
     Ausdruck gefunden wird.  Mustervariablen in <replacement> werden
     die Werte des geprüften Ausdrucks zugewiesen.

     Das Argument <pattern> kann ein beliebiger Ausdruck sein, in dem
     der Hauptoperator keine Mustervariable ist.  Die
     Vereinfachungsregel wird mit dem Hauptoperator assoziiert.  Der
     Name von Funktionen, mit einer unten beschriebenen Ausnahme,
     Listen und Arrays können in <pattern> nur als eine wörtliche
     Übereinstimmung und nicht in Mustervariablen auftreten.  Daher
     können Ausdrücke wie `aa(x)' oder `bb[y]' nicht als Muster
     verwendet werden, wenn `aa' oder `bb' Mustervariablen sind.  Die
     Namen von Funktionen, Listen und Arrays, welche Mustervariablen
     sind, können dann in <pattern> auftreten, wenn sie nicht der
     Hauptoperator sind.

     Es gibt eine Ausnahme der oben genannten Einschränkung für die
     Verwendung von Funktionsnamen.  Der Name einer indizierten
     Funktion wie `aa[x](y)' kann eine Mustervariable sein, da der
     Hauptoperator nicht `aa' ist, sondern das Lisp-Symbol `mqapply'.
     Dies ist eine Konsequenz der internen Darstellung einer
     indizierten Funktion.

     Regeln für die Vereinfachung werden nach der Auswertung eines
     Ausdrucks angewendet, sofern die Auswertung zum Beispiel mit dem
     Schalter `noeval'  nicht unterdrückt wurde.  Regeln, die mit
     `tellsimpafter' definiert sind, werden nach den vorhandenen
     Maxima-Regeln und in der Reihenfolge angewendet werden, in der sie
     definiert sind.  Die Regeln für die Vereinfachung werden zunächst
     für Teilausdrücke und zuletzt für den ganzen Ausdruck angewendet.
     Es kann notwendig sein, Regeln für die Vereinfachung mehrfach zum
     Beispiel mit dem Quote-Quote-Operator

     `''' oder dem Schalter `infeval'  anzuwenden, um sicher zu gehen,
     dass alle Regeln angewendet werden.

     Mustervariable werden als lokale Variablen in Vereinfachungsregeln
     behandelt.  Sobald eine Regel definiert ist, beeinflusst die
     Zuweisung eines Wertes an die Mustervariable nicht die Regel und
     die Variable wird nicht von der Regel beeinflusst.  Die Zuweisung
     an eine Mustervariable, die aufgrund einer erfolgreichen
     Übereinstimmung des Musters mit einem Ausdruck vorgenommen wird,
     beeinflusst nicht den aktuellen Wert der Variablen.  Jedoch sind
     die Eigenschaften der Mustervariablen, wie sie zum Beispiel auch
     mit der Funktion `put'  definiert werden können, global in Maxima.

     Die mit `tellsimpafter' definierte Regel wird nach dem
     Hauptoperator des Argumentes <pattern> benannt.  Regeln der
     Maxima-Operatoren und mit den Funktionen `infix',  `prefix',
     `postfix',

     `matchfix'  und `nofix'  definierte Operatoren haben einen
     Lisp-Bezeichner als Namen.  Alle anderen Regeln haben
     Maxima-Bezeichner als Namen.

     `tellsimpafter' werden die Argumente nicht aus.  `tellsimpafter'
     gibt eine Liste der Regeln des Hauptoperators des Argumentes
     <pattern> einschließlich der neu definierten Regeln zurück.

     Siehe auch `matchdeclare',  `defmatch',  `defrule',

     `tellsimp',  `kill',  `remrule'  und `clear_rules'.

     Beispiele:

     Das Muster <pattern> kann ein beliebiger Ausdruck sein, in dem der
     Hauptoperator nicht die Mustervariable ist.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regeln werden in der Reihenfolge angewendet, in der sie definiert
     wurden.  Können zwei Regeln mit einem Ausdruck übereinstimmen,
     wird die zuerst definierte Regel angewendet.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Mustervariable werden als lokale Variable in Vereinfachungsregeln
     behandelt.  Im Unterschied dazu behandelt `defmatch'
     Mustervariable als globale Variable.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Die Eigenschaften von Mustervariablen sind global, auch wenn die
     Werte lokal sind.  In diesem Beispiel wird eine Eigenschaft für
     die Zuweisung an eine Variable mit der Funktion `define_variable'
     definiert.  Die Eigenschaft des Symbols `bb' ist global in Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regeln werden nach dem Hauptoperator benannt.  Die Namen der
     Regeln für Maxima-Funktionen und nutzerdefinierten Operatoren sind
     Lisp-Bezeichner.  Alle anderen Namen sind Maxima-Bezeichner.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) remrule (foo, foorule1);
          (%o10)                         foo
          (%i11) remrule ("^", ?\^rule1);
          (%o11)                          ^
          (%i12) rules;
          (%o12)        [foorule2, foorule3, +rule1, *rule1]

     Ein ausgearbeitetes Beispiel der nicht-kommutativen Multiplikation.

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0


File: maxima.info,  Node: Funktionsdefinitionen,  Next: Laufzeitumgebung,  Prev: Muster und Regeln,  Up: Top

25 Funktionsdefinitionen
************************

* Menu:

* Einführung in Funktionsdefinitionen::
* Funktionen::
* Makros::
* Funktionen und Variablen für Funktionsdefinitionen::


File: maxima.info,  Node: Einführung in Funktionsdefinitionen,  Next: Funktionen,  Prev: Funktionsdefinitionen,  Up: Funktionsdefinitionen

25.1 Einführung in Funktionsdefinitionen
========================================


File: maxima.info,  Node: Funktionen,  Next: Makros,  Prev: Einführung in Funktionsdefinitionen,  Up: Funktionsdefinitionen

25.2 Funktionen
===============

25.2.1 Gewöhnliche Funktionen
-----------------------------

Eine Maxima-Funktion wird mit dem Operator `:=' definiert.  Im folgenden
wird die Funktion `f' definiert:

     f(x) := sin(x)

Funktionen, die mit der Funktion `lambda' definiert werden, sind anonyme
Funktionen, die keinen Namen haben.  Diese werden auch
`lambda'-Ausdrücke genannt:

     lambda ([i, j], ...)

Anonyme Funktionen können überall dort verwendet werden, wo eine
Funktion als Argument erwartet wird.  Das folgene Beispiel gibt eine
Liste zurück, bei der jedes Element der Liste `L' mit 1 addiert wird:

     map (lambda ([i], i+1), L)

Ist das letzte oder einzige Argument einer Funktion eine Liste mit einem
Element, kann eine variable Anzahl an Argumenten an die Funktion
übergeben werden:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

Die rechte Seite einer Funktionsdefinition ist ein Ausdruck.  Mehrere
Ausdrücke werden durch Kommata getrennt und mit Klammern umgegeben.  Das
Ergebnis der Funktion ist der Wert des letzten Ausdrucks <exprn>:

     f(x) := (expr1, expr2, ...., exprn);

Ein Rücksprung mit der Anweisung `return' aus einer Funktion ist
möglich, wenn die Definition der Funktion in einen Block eingefügt wird.
Ein Block wird mit der `block'-Anweisung definiert.  Das folgende
Beispiel hat entweder den Wert `a' oder den Wert des Ausdrucks <exprn>
als Ergebnis:

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

Das erste paar Klammern `[]' in einem Block enthält die Definition von
lokalen Variablen wie zum Beispiel `[a: 3, b, c: []]'.  Die Variablen
sind außerhalb des Blocks nicht sichtbar.  Die Werte von globalen
Variablen werden von den lokalen Werten überschrieben.  Außerhalb des
Blocks haben die Variablen, wenn vorhanden, wieder ihre alten Werte.
Die Zuweisung der Werte an die lokalen Variablen wird parallel
ausgeführt.

Im folgenden Beispiel wird der Wert der globalen Variablen <a> der
lokalen Variablen <a> zugewiesen.  Änderungen von <a> im Block wirken
sich nicht auf den globalen Wert der Variablen aus.

     block ([a: a], expr1, ... a: a+3, ..., exprn)

Die Anweisung `block ([x], ...)' bewirkt, dass `x' als lokale Variable
ohne einen Wert verwendet werden kann.

Die Argumente einer Funktion werden in gleicher Weise wie lokal
definierte Variable behandelt.  Die folgende Definition

     f(x) := (expr1, ..., exprn);

mit

     f(1);

hat denselben Effekt wie der folgende Block:

     block ([x: 1], expr1, ..., exprn)

Muss die rechte Seite einer Funktionsdefinition ausgewertet werden,
kann es sinnvoll sein, die Funktionen `define' oder `buildq' zu
verwenden.

25.2.2 Array-Funktionen
-----------------------

Eine Array-Funktion speichert bei dem ersten Aufruf den Funktionswert
zu dem Argument.  Wird die Array-Funktion mit demselben Argument
aufgerufen, wird der gespeicherte Wert zurückgeben, ohne diesen neu zu
berechnen.  Dies wird auch Memoisation genannt.

Die Namen der Array-Funktionen werden in die Informationsliste `arrays'
und nicht in die Liste `functions' eingetragen.  `arrayinfo' gibt eine
Liste der Argumente zurück, für die Werte gespeichert sind und
`listarrays' gibt die Werte zurück.  `dispfun' und `fundef' geben die
Definition der Array-Funktion zurück.

`arraymake' erzeugt den Aufruf einer Array-Funktion.  Dies ist analog zu
der Funktion `funmake' für gewöhnliche Funktionen.  `arrayapply' wendet
eine Array-Funktion auf die Argumente an.  Dies entspricht der Funktion
`apply' für gewöhnliche Funktionen.  Die Funktion `map' hat keine
Entsprechung für Array-Funktionen.  Vergleichbare Konstruktionen sind
`map(lambda([<x>], <a>[<x>]), <L>)' oder `makelist(<a>[<x>], <x>,
<L>)', wobei <L> eine Liste ist.

`remarray' entfernt die Definition einer Array-Funktion einschließlich
der gespeicherten Werte.  Dies entspricht `remfunction' für gewöhnliche
Funktionen.

`kill(<a>[<x>])' entfernt den für das Argument <x> gespeicherten Wert
einer Array-Funktion <a>.  Beim nächsten Aufruf von <a> mit dem
Argument <x> wird der Funktionswert neu berechnet.  Es gibt keine
Möglichkeit, alle gespeicherten Werte zu löschen.  Die Kommandos
`kill(<a>)' und `remarray(<a>)' löschen alle Werte einschließlich der
Definition der Funktion.


File: maxima.info,  Node: Makros,  Next: Funktionen und Variablen für Funktionsdefinitionen,  Prev: Funktionen,  Up: Funktionsdefinitionen

25.3 Makros
===========

 -- Funktion: buildq (<L>, <expr>)
     Die Variablen der Liste <L> werden in den Ausdruck <expr>
     substituiert.  Die Substitution wird parallel ausgeführt.  Das
     Ergebnis der Substitution wird vereinfacht, aber nicht ausgewertet.

     Die Elemente der Liste <L> sind Symbole oder Zuweisungen der Form
     `<symbol>: <value>'.  Zuweisungen werden parallel ausgewertet.
     Der Wert einer Variablen auf der rechten Seite einer Zuweisung ist
     der globale Wert in dem Kontext in dem `buildq' aufgerufen wird
     und nicht der lokale Wert einer vorhergenden Zuweisung.  Erhält
     eine Variable keinen Wert, dann behält die Variable den globalen
     Wert.

     Dann werden die in der Liste <L> enthaltenen Variablen parallel in
     den Ausdruck <expr> substituiert.

     Enthält <expr> Ausdrücke der Form `splice(<x>)', muss die Variable
     <x> eine Liste sein.  Die Liste wird in den Ausdruck eingefügt.

     Variablen in <expr>, die nicht in <L> enthalten sind, werden nicht
     durch einen Wert ersetzt, auch wenn es eine globale Variable mit
     demselben Namen gibt.

     Beispiele:

     Der Variablen `a' wird der Wert zugewiesen.  Die Variable `b'
     erhält den globalen Wert.  Die Variable `c' hat keinen Wert.  Das
     Ergebnis ist ein nicht ausgewerteter Ausdruck.  Die Auswertung
     wird mit dem Quote-Quote-Operator  `''' erzwungen.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' ist eine Liste, die einmal als Argument der Funktion `foo'
     vorliegt und zum anderen in die Argumentliste der Funktion `bar'
     eingefügt wird.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     Das Ergebnis wird nach der Substitution vereinfacht, ansonsten
     hätten die beiden folgenden Beispiele dasselbe Ergebnis.

          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     Die Variablen der Liste <L> erhalten ihren Wert parallel,
     ansonsten wäre das erste Ergebnis `foo(b,b)'.  Substitutionen
     werden parallel ausgeführt.  Im Gegensatz dazu werden die
     Substitutionen mit der Funktion `subst' nacheinander ausgeführt.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
                        bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
                       bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Konstruktion einer Liste mit Gleichungen mit Variablen oder
     Ausdrücken auf der linken Seite und deren Werten auf der rechten
     Seite.  Die Funktion `macroexpand' expandiert das Makro
     `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])

     Konstruktion einer Funktion.

          (%i1) curry (f, [a]) :=
                  buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
          (%i2) by3 : curry ("*", 3);
          (%o2)        lambda([[x]], apply(*, append([3], x)))
          (%i3) by3 (a + b);
          (%o3)                       3 (b + a)

 -- Funktion: macroexpand (<expr>)
     Ist <expr> eine Makrodefinition, wird das Makro expandiert, ohne
     dass es ausgewertet wird.  Ansonsten wird <expr> zurückgegeben.

     Ist die Expansion des Makros selbst ein Makro, wird dieses Makro
     wiederholt expandiert.

     `macroexpand' wertet das Argument <expr> nicht aus.  Hat die
     Expansion des Makros Seiteneffekte, dann werden diese ausgeführt.

     Siehe auch `::=',  `Makros'  und `macroexpand1'.

     Beispiele:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Funktion: macroexpand1 (<expr>)
     Gibt die Makro-Expansion von <expr> zurück, ohne das Ergebnis
     auszuwerten.  Ist <expr> keine Makro-Funktion gibt `macroexpand1'
     das Argument <expr> zurück.

     `macroexpand1' wertet das Argument nicht aus.  Hat die Expansion
     des Makros Seiteneffekte, dann werden diese ausgeführt.

     Enthält die Expansion <expr> wiederum Makros, werden diese im
     Unterschied zur Funktion `macroexpand' nicht expandiert.

     Siehe auch `::=',  `Makros'  und `macroexpand'.

     Beispiele:

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Optionsvariable: macroexpansion
     Standardwert: `false'

     `macroexpansion' kontrolliert die Expansion von Makro-Funktionen.

    `false'
          Die Expansion der Makro-Funktion wird nicht für die
          aufrufende Funktion ersetzt.

    `expand'
          Wird die Makro-Funktion das erste Mal ausgewertet, wird die
          Expansion des Makros gespeichert.  Weitere Aufrufe werten das
          Makro nicht erneut aus.  Seiteneffekte, wie Zuweisungen an
          globale Variablen, werden nur bei der ersten Auswertung
          wirksam.  Die Expansion des Makros beeinflusst nicht andere
          Ausdrücke, die das Makro ebenfalls aufrufen.

    `displace'
          Wird die Makro-Funktion das erstemal ausgewertet, wird die
          Expansion des Makros in den aufrufenden Ausdruck eingesetzt.
          Weitere Aufrufe werten das Makro nicht erneut aus.
          Seiteneffekte, wie Zuweisungen an globale Variablen, werden
          nur bei der ersten Auswertung wirksam.  Die Expansion des
          Makros beeinflusst nicht andere Ausdrücke, die das Makro
          ebenfalls aufrufen.

     Beispiele:

     Hat `macroexpansion' den Wert `false', wird eine Makro-Funktion
     jedesmal aufgerufen, wenn der aufrufende Ausdruck ausgewertet
     wird.  Der aufrufende Ausdruck wird nicht modifiziert.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Hat `macroexpansion' den Wert `expand', wird eine Makro-Funktion
     nur einmal aufgerufen.  Der aufrufende Ausdruck wird nicht
     modifiziert.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     Hat `macroexpansion' den Wert `displace', wird eine Makro-Funktion
     nur einmal aufgerufen.  Der aufrufende Ausdruck wird modifiziert.

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

 -- Systemvariable: macros
     Standardwert: `[]'

     `macros' ist eine Informationsliste, die die vom Nutzer mit dem
     Operator `::=' definierten Makro-Funktionen enthält.  Wird die
     Makro-Funktion mit einer der Funktionen `kill', `remove' oder
     `remfunction' gelöscht, wird der Eintrag aus der Informationsliste
     entfernt.  Siehe auch `infolists'.


 -- Funktion: splice (<a>)
     Die Funktion `splice' kann nur im Zusammenhang mit der Funktion
     `buildq' verwendet werden.  Das Argument <a> bezeichnet eine
     Liste, die an Stelle von `splice(a)' in einen Ausdruck eingefügt
     wird.  <a> kann nicht selbst eine Liste sein oder ein Ausdruck
     sein, der zu einer Liste auswertet.

     Beispiele:

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Funktionen und Variablen für Funktionsdefinitionen,  Prev: Makros,  Up: Funktionsdefinitionen

25.4 Funktionen und Variablen für Funktionsdefinitionen
=======================================================

 -- Funktion: apply (<F>, [<x_1>, ..., <x_n>])
     Konstruiert den Ausdruck `<F>(<arg_1>, ..., <arg_n>)' und wertet
     diesen aus.

     `apply' versucht nicht Array-Funktionen von gewöhnlichen
     Funktionen zu unterscheiden.  Ist <F> der Name eine
     Array-Funktion, wertet `apply' den Ausdruck `<F>(...)' aus.
     `arrayapply' entspricht der Funktion `apply', wenn <F> eine
     Array-Funktion ist.

     Beispiele:

     `apply' wertet die Argumente aus.  In diesem Beispiel wird die
     Funktion `min' auf die Liste `L' angewendet.

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     `apply' wertet die Argumente auch dann aus, wenn die Funktion `F'
     die Auswertung ihrer Argumente unterdrückt.

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729

          (%o5)                         [%t5]

     `apply' wertet den Namen der Funktion <F> aus.  Mit dem
     Quote-Operator  `'' wird die Auswertung unterdrückt.  `demoivre'
     ist der Name einer globalen Optionsvariable und einer Funktion.

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)

 -- Funktion: define (<f>(<x_1>, ..., <x_n>), <expr>)
 -- Funktion: define (<f>[<x_1>, ..., <x_n>], <expr>)
 -- Funktion: define (funmake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Funktion: define (arraymake (<f>, [<x_1>, ..., <x_n>]), <expr>)
 -- Funktion: define (ev (<expr_1>), <expr_2>)
     Definiert eine Funktion mit dem Namen <f> und den Argumenten <x1>,
     ..., <x_n> und der Funktionsdefinition <expr>.  `define' wertet
     das zweite Argument immer aus.

     Ist das letzte oder einzige Argument <v_n> eine Liste mit einem
     Element, dann akzeptiert die Funktion eine variable Anzahl an
     Argumenten.  Die Argumente der Funktion werden nacheinander den
     Variablen <x_1>, ..., <x_(n-1)> zugewiesen.  Sind weitere
     Argumente vorhanden, werden diese als Liste der Variablen <x_n>
     zugewiesen.

     Ist das erste Argument der Funktion `define' ein Ausdruck der Form
     `<f>(<x_1>, ..., <x_n>)' oder `<f>[<x_1>, ..., <x_n>]' werden die
     Argumente der Funktion ausgewertet, aber nicht die Funktion <f>
     selbst.  <f> wird auch dann nicht ausgewertet, wenn es bereits
     eine Funktion mit dem Namen <f> gibt.

     Das erste Argument wird dann ausgewertet, wenn es ein Ausdruck mit
     den Funktionen `funmake', `arraymake' oder `ev' ist.

     Alle Funktionsdefinitionen treten in demselben Namensraum auf.
     Die Definition einer Funktion `g' innerhalb einer Funktion `f'
     führt nicht automatisch zu einer lokalen Definition.  Um eine
     lokale Funktion zu erhalten, kann `lokal(g)' innerhalb der
     Funktion `f' ausgeführt werden.

     Ist eines der Argumente <x_k> nach der Auswertung ein quotiertes
     Symbol, wertet die mit `define' definierte Funktion das Argument
     nicht aus.  Alle weiteren Argumente der Funktion werden
     ausgewertet.

     Siehe auch `:='  und `::='.

     Beispiele:

     `define' wertet das zweite Argument aus.

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     Mit `define' können gewöhnliche Maxima-Funktionen und
     Array-Funktionen definiert werden.

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     Ist das letzte oder einzige Argument <x_n> eine Liste mit einem
     Element, akzeptiert die mit `define' definierte Funktion eine
     variable Anzahl an Argumenten.

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     Ist das erste Argument ein Ausdruck mit den Funktionen `funmake',
     `arraymake' oder `ev' wird das Argument ausgewertet.

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)

 -- Funktion: define_variable (<name>, <default_value>, <mode>)
     Definiert eine globale Variable in der Maxima-Umgebung.
     `define_variable' ist nützlich für das Schreiben von Paketen, die
     häufig übersetzt oder kompiliert werden.  `define_variable' führt
     die folgenden Schritte aus:

       1. `mode_declare(<name>, <mode>)' deklariert den Typ der
          Variablen <name> für den Übersetzer.  Siehe `mode_declare'
          für eine Liste der möglichen Typen.

       2. Hat die Variable keinen Wert, wird der Variablen der Wert
          <default_value> zugewiesen.

       3. `declare(<name>, special)' deklariert die Variable als
          Special.

       4. Ordnet der Variablen <name> eine Testfunktion zu, um
          sicherzustellen, dass der Variablen nur Werte zugewiesen
          werden können.

     Einer mit `define_variable' definierten Variablen, die einen
     anderen Typ als `any' erhalten hat, kann die Eigenschaft
     `value_check' zugewiesen werden.  Die `value_check'-Eigenschaft
     ist eine Aussagefunktion mit einer Variablen oder ein
     Lambda-Ausdruck, die aufgerufen werden, wenn der Variablen ein
     Wert zugewiesen werden soll.  Das Argument der
     `value_check'-Funktion ist der Wert, den die Variable erhalten
     soll.

     `define_variable' wertet `default_value' aus.  Die Argumente
     `name' und `mode' werden nicht ausgewertet.  `define_variable'
     gibt den aktuellen Wert der Variable `name' zurück.  Dieser ist
     `default_value', wenn der Variablen bisher kein Wert zugewiesen
     wurde.

     Beispiele:

     `foo' ist eine boolsche Variable mit dem Wert `true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' ist eine Variable mit dem Typ einer ganzen Zahl, die eine
     Primzahl sein muss.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then
                                     error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 is not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' ist eine Variable, der kein Wert zugewiesen werden
     kann.  Der Typ `any_check' ist vergleichbar mit `any'.  Aber
     `any_check' ruft im Gegensatz zu `any' den
     `value_check'-Mechanismus auf.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then
                           error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then
                           error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux

 -- Funktion: dispfun (<f_1>, ..., <f_n>)
 -- Funktion: dispfun (all)
     Zeigt die Definitionen der nutzerdefinierten Funktionen <f_1>, ...,
     <f_n> an.  Die Argumente können gewöhnliche Funktionen, Makros,
     Array-Funktionen oder indizierte Funktionen sein.

     `dispfun(all)' zeigt die Definitionen aller nutzerdefinierten
     Funktionen an, die in den Informationslisten `functions', `arrays'
     oder `macros' enthalten sind.

     `dispfun' erzeugt Zwischenmarken `%t' für jede einzelne
     anzuzeigende Funktion und weist die Funktionsdefinitionen den
     Zwischenmarken zu.  Im Gegensatz dazu, zeigt die Funktion `fundef'
     die Funktionsdefinition ohne Zwischenmarken an.

     `dispfun' wertet die Argumente nicht aus.  `dispfun' gibt eine
     Liste mit den Zwischenmarken zurück, die zu den angezeigten
     Funktionen gehören.

     Beispiele:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10

 -- Funktion: fullmap (<f>, <expr_1>, ...)
     Die Funktion `fullmap' ist vergleichbar mit der Funktion `map'.  Im
     Unterschied zu der Funktion `map' kann `fullmap' auf verschachtelte
     Audrücke angewendet werden.

     Intern wird `fullmap' von Maxima für die Vereinfachung von Matrizen
     aufgerufen.  Daher können bei der Vereinfachung von Matrizen
     Fehlermeldungen im Zusammenhang mit `fullmap' auftreten, ohne dass
     die Funktion direkt aufgerufen wurde.

     Beispiele:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)

 -- Funktion: fullmapl (<f>, <list_1>, ...)
     Die Funktion `fullmapl' ist vergleichbar mit `fullmap'.
     `fullmapl' kann jedoch nur auf Matrizen und Listen angewendet
     werden kann.

     Beispiele:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]

 -- Systemvariable: functions
     Standardwert: `[]'

     `functions' ist eine Informationsliste, die die vom Nutzer mit dem
     Operator <:=> oder der Funktion `define' definierten Funktionen
     enthält.  Siehe `infolists'.

     Array-Funktionen und indizierte Funktionen werden nicht in die
     Informationsliste `functions', sondern in die Informationsliste
     `arrays' eingetragen.  Siehe `arrays'.

     Beispiele:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]

 -- Funktion: fundef (<f>)
     Gibt die Definition der Funktion <f> zurück.

     Das Argument <f> kann eine gewöhnliche Funktion, eine
     Makro-Funktion, eine Array-Funktion oder eine indizierte Funktion
     sein.

     `fundef' wertet das Argument aus.  Siehe auch `dispfun'.


 -- Funktion: funmake (<F>, [<arg_1>, ..., <arg_n>])
     Gibt den Ausdruck `<F>(<arg_1>, ..., <arg_n>)' zurück.  Die
     Rückgabe wird vereinfacht, aber nicht ausgewertet.  Die Funktion
     <F> wird also nicht aufgerufen, auch wenn diese existiert.

     `funmake' versucht nicht, Array-Funktionen von gewöhnlichen
     Funktionen zu unterscheiden.  Ist <F> der Name einer
     Array-Funktion, dann gibt `funmake' einen Ausdruck der Form
     `<F>(...)' zurück.  Für Array-Funktionen kann die Funktion
     `arraymake' verwendet werden.

     `funmake' wertet die Argumente aus.

     Beispiele:

     `funmake' angewendet auf eine gewöhnliche Funktion.

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     `funmake' angewendet auf ein Makro.

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     `funmake' angewendet auf eine indizierte Funktion.

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     `funmake' angewendet auf ein Symbol, welches keine Funktion
     repräsentiert.

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     `funmake' wertet die Argumente, aber nicht die Rückgabe aus.

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284

     Maxima vereinfacht den Rückgabewert der Funktion `funmake'.

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1

 -- Funktion: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Funktion: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Funktion: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ...,
          <expr_n>)
     Definiert einen Lambda-Ausdruck, auch als anonyme Funktion
     bezeichnet, und gibt diesen zurück.  Die Funktion kann Argumente
     <x_1>, ..., <x_m> und optionale Argumente <L> haben.  Die Rückgabe
     der Funktion ist das Ergebnis des Ausdrucks <exprn>.  Ein
     Lambda-Ausdruck kann einer Variablen zugewiesen werden und wertet
     wie eine gewöhnliche Funktion aus.  Ein Lambda-Ausdruck kann an
     solchen Stellen verwendet werden, wo der Name einer Funktion
     erwartet wird.

     Wird der Lambda-Ausdruck ausgewertet, werden lokale Variablen
     <x_1>, ..., <x_m> erzeugt.  `lambda' kann innerhalb von Blöcken
     oder anderen Lambda-Ausdrücken verwendet werden.  Mit jeder
     `block'-Anweisung oder jedem Lambda-Ausdruck werden erneut lokale
     Variablen erzeugt.  Die lokalen Variablen sind jeweils global zu
     jeder eingeschlossenen `block'-Anweisung oder zu jedem
     eingeschlossenen Lambda-Ausdruck.  Ist eine Variable innerhalb von
     `block' oder `lambda' nicht lokal, hat sie den Wert der
     nächsthöheren Anweisung, die ihr einen Wert gibt oder den globalen
     Wert der Maxima-Umgebung.

     Nachdem die lokalen Variablen erzeugt sind, werden die Ausdrücke
     <expr_1>, ..., <expr_n> nacheinander ausgewertet.  Die
     Systemvariable `%%', welche das Ergebnis eines vorhergehendes
     Ausdrucks enthält, kann verwendet werden.  In einem
     Lambda-Ausdruck können die Anweisungen `catch' und `throw'
     verwendet werden.

     Die `return'-Anweisung kann in einem Lambda-Ausdruck nur verwendet
     werden, wenn sie von einer `block'-Anweisung eingeschlossen wird.
     Die `return'-Anweisung definiert jedoch den Rückgabewert des
     Blocks und nicht des Lambda-Ausdrucks.  Auch die `go'-Anweisung
     kann in einem Lambda-Ausdrucks nur in einem Block verwendet werden.

     `lambda' wertet die Argumente nicht aus.

     Beispiele:

     Ein Lambda-Ausdruck kann einer Variablen zugewiesen werden und wie
     eine gewöhnliche Funktion ausgewertet werden.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

     Ein Lamda-Ausdruck kann an Stellen verwendet werden, wo der Name
     einer Funktion erwartet wird.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

     Die Argumente sind lokale Variablen.  Andere Variablen sind
     globale Variablen.  Globale Variablen werden zu dem Zeitpunkt
     ausgewertet, wenn der Lambda-Ausdruck ausgewertet wird.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

     Lambda-Ausdrücke können verschachtelt werden.  Lokale Variablen
     eines äußeren Lambda-Ausdrucks sind global zu den enthaltenen
     Lambda-Ausdrücken, außer diese werden wieder als lokal erklärt.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

     Da `lambda' die Argumente nicht auswertet, definiert der unten
     angegebene Ausdruck `i' keine Funktion "multipliziere mit `a'".
     Solch eine Funktion kann mit Hilfe der Funktion `buildq' definiert
     werden.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

     Ein Lambda-Ausdruck kann eine variable Anzahl an Argumenten haben,
     wenn das letzte Argument eine Liste mit einem Element ist.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Funktion: map (<f>, <expr_1>, ..., <expr_n>)
     Gibt einen Ausdruck zurück, dessen Hauptoperator derselbe ist, wie
     der der Argumente <expr_1>, ..., <expr_n> aber dessen Operanden
     das Ergebnis der Anwendung des Operators <f> auf die Teilausdrücke
     des Ausdrucks sind.  <f> ist entweder der Name einer Funktion mit
     n Argumenten oder ein Lambda-Ausdruck mit n Argumenten.

     Hat `maperror' den Wert `false', wird die Anwendung der Funktion
     <f> gestoppt, (1) wenn die Anwendung auf den kürzesten Ausdruck
     <expr_i> beendet ist und die Ausdrücke nicht alle dieselbe Länge
     haben oder (2) wenn die Ausdrücke <expr_i> einen verschiedenen Typ
     haben.  Hat `maperror' den Wert `true' wird in den obigen Fällen
     eine Fehlermeldung ausgegeben.

     Beispiele:

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Funktion: mapatom (<expr>)
     Gibt den Wert `true' zurück, wenn der Ausdruck <expr> von
     Funktionen die auf Argumente angewendete werden, als ein Atom
     betrachtet wird.  Als Atome werden Zahlen, einschließlich
     rationaler Zahlen und großer Gleitkommazahlen, Symbole und
     indizierte Symbole betrachtet.

 -- Optionsvariable: maperror
     Standardwert: `true'

     Hat `maperror' den Wert `false', wird die Anwendung der Funktion
     <f> gestoppt, (1) wenn die Anwendung auf den kürzesten Ausdruck
     <expr_i> beendet ist und die Ausdrücke nicht alle dieselbe Länge
     haben oder (2) wenn die Ausdrücke <expr_i> einen verschiedenen Typ
     haben.  Hat `maperror' den Wert `true' wird in den obigen Fällen
     eine Fehlermeldung ausgegeben.

 -- Optionsvariable: mapprint
     Standardwert: `true'

     Hat `mapprint' den Wert `true', werden verschiedene Informationen
     von den Funktionen `map', `mapl' und `fullmap' ausgegeben.  Dies
     ist der Fall, wenn die Funktion `map' die Funktion `apply' aufruft
     oder wenn für die Funktion `map' die Argumente eine verschiedene
     Länge haben.

     Hat `mapprint' den Wert `false', werden diese Meldungen
     unterdrückt.

 -- Funktion: maplist (<f>, <expr_1>, ..., <expr_n>)
     Wendet die Funktion <f> auf die Ausdrücke <expr_1>, ..., <expr_n>
     an und gibt das Ergebnis als eine Liste zurück.  <f> ist der Name
     einer Funktion oder ein lambda-Ausdruck.

     Im Unterschied zu `maplist' gibt die Funktion `map' einen Ausdruck
     zurück, der denselben Hauptoperator wie die Ausdrücke <expr_i> hat.

 -- Funktion: outermap (<f>, <a_1>, ..., <a_n>)
     Wendet die Funktion <f> auf jedes Element des äußeren Produktes der
     Argumente <a_1> `x' <a_2> `x' ... `x' <a_n> an.

     <f> ist der Name einer Funktion mit n Argumenten oder ein
     Lambda-Ausdruck mit n Argumenten.  Jedes Argument <a_k> kann eine
     Liste oder verschachtelte Liste, eine Matrix oder irgendein
     anderer Ausdruck sein.

     `outermap' wertet die Argumente aus.

     Siehe auch `map',  `maplist'  und `apply'.

     Beispiele:

     Einfaches Beispiel für `outermap'.  Die Funktion `F' ist
     undefiniert.

          (%i1) outermap(F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap(F, matrix([a, b],[c, d]), matrix([1, 2],[3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     Das Beispiel zeigt die Rückgabe der Funktion `outermap'
     detaillierter.  Das erste, zweite und dritte Argument sind eine
     Matrix, eine Liste und eine Matrix.  Der Rückgabewert ist eine
     Matrix.  Jedes Element der Matrix ist eine Liste und jedes Element
     der Liste ist eine Matrix.

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                             arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     `outermap' erhält die Struktur der Argumente im Ergebnis.  Die
     Funktion `cartesian_product' erhält die Struktur der Argumente
     nicht.

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map(lambda([L], apply(F, L)),
                               cartesian_product({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true

 -- Funktion: remfunction (<f_1>, ..., <f_n>)
 -- Funktion: remfunction (all)
     Hebt die Bindung der Symbole <f_1>, ..., <f_n> an ihre
     Funktionsdefinitionen auf.  Die Argumente können die Namen von
     Funktionen sein, die mit dem Operator `:='  oder der Funktion
     `define'  definiert wurden sowie Makro-Funktionen, die mit dem
     Operator `::='  definiert wurden.

     `remfunction(all)' entfernt alle Bindungen von
     Funktionsdefinitionen.

     `remfunction' gibt eine Liste mit den Symbolen zurück, die von
     ihren Funktionsdefinitionen entbunden wurden.  `false' wird für
     die Symbole zurückgegeben, für die es keine Funktionsdefinition
     gibt.

     `remfunction' wertet die Argumente nicht aus.

     `remfunction' kann nicht auf Array-Funktionen und indizierte
     Funktionen angewendet werden.  Für diese Funktionen kann `remarray'
     verwendet werden.

 -- Funktion: scanmap (<f>, <expr>)
 -- Funktion: scanmap (<f>, <expr>, bottomup)
     Wendet die Funktion <f> rekursiv auf alle Teilausdrücke in <expr>
     an.  Dies kann zum Beispiel verwendet werden, um einen Ausdruck
     vollständig zu faktorisieren.

     Beispiele:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Ein weiteres Beispiel für die Anwendung einer Funktion auf alle
     Teilausdrücke.

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' wendet die Funktion <f>
     Bottom-up auf den Ausdruck <expr> an.

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))


File: maxima.info,  Node: Laufzeitumgebung,  Next: Programmierung,  Prev: Funktionsdefinitionen,  Up: Top

26 Laufzeitumgebung
*******************

* Menu:

* Einführung in die Laufzeitumgebung::
* Interrupts::
* Funktionen und Variablen der Laufzeitumgebung::


File: maxima.info,  Node: Einführung in die Laufzeitumgebung,  Next: Interrupts,  Prev: Laufzeitumgebung,  Up: Laufzeitumgebung

26.1 Einführung in die Laufzeitumgebung
=======================================

Die Datei `maxima-init.mac' wird automatisch geladen, wenn Maxima
startet.  Die Datei `maxima-init.mac' kann genutzt werden, um bevorzugte
Einstellungen vorzunehmen.  Die Datei wird üblicherweise in dem
Verzeichnis `maxima_userdir' abgelegt.  Sie kann aber auch in jedes
andere Verzeichnis abgelegt werden, das von der Funktion `file_search'
gefunden wird.

Dies ist eine Beispiel für eine `maxima-init.mac'-Datei:

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;


File: maxima.info,  Node: Interrupts,  Next: Funktionen und Variablen der Laufzeitumgebung,  Prev: Einführung in die Laufzeitumgebung,  Up: Laufzeitumgebung

26.2 Interrupts
===============

Eine Berechnung kann mit dem Kommando `^c' (`control-c') abgebrochen
werden.  Standardmäßig kehrt Maxima zu der Eingabeaufforderung der
Konsole zurück.

Wird die Lisp-Variable `*debugger-hook*' mit dem folgenden Kommando
`:lisp (setq *debugger-hook* nil)' auf den Wert `nil' gesetzt, dann
startet Maxima den Lisp-Debugger, wenn das Kommando `^c' ausgeführt
wird.  Im Lisp-Debugger kann mit dem Kommando `continue' zu Maxima
zurückgekehrt werden.

In Unix-Systemen kann die Ausführung auch mit Kommando `^z'
(`control-z') abgebrochen werden.  In diesem Fall wird eine Unix-Shell
gestartet.  Das Kommando `fg' kehrt zu Maxima zurück.


File: maxima.info,  Node: Funktionen und Variablen der Laufzeitumgebung,  Prev: Interrupts,  Up: Laufzeitumgebung

26.3 Funktionen und Variablen der Laufzeitumgebung
==================================================

 -- Systemvariable: maxima_tempdir
     Die Systemvariable `maxima_tempdir' enthält das Verzeichnis in dem
     Maxima temporäre Dateien abgelegt.  Insbesondere werden temporäre
     Grafikausgaben in diesem Verzeichnis abgelegt.  Der Standardwert
     von `maxima_tempdir' ist das Home-Verzeichnis des Nutzers, sofern
     Maxima dieses feststellen kann.  Andernfalls initialisiert Maxima
     die Systemvariable `maxima_tempdir' mit einer geeigneten Annahme.

     Der Systemvariablen `maxima_tempdir' kann eine Zeichenkette
     zugewiesen werden, die ein Verzeichnis bezeichnet.

 -- Systemvariable: maxima_userdir
     Die Systemvariable `maxima_userdir' enthält ein Verzeichnis, das
     Maxima durchsucht, um Maxima- und Lisp-Dateien zu finden.  Maxima
     sucht in weiteren Verzeichnissen.  Die vollständige Liste der
     Suchverzeichnisse ist den Variablen `file_search_maxima'  und
     `file_search_lisp'  enthalten.  Der Standardwert der
     Systemvariablen `maxima_userdir' ist ein Unterverzeichnis des
     Home-Verzeichnis des Nutzers, sofern Maxima dieses bestimmen kann.
     Ansonsten initialisiert Maxima die Systemvariable `maxima_userdir'
     mit einer geeigneten Annahme.

     Der Systemvariablen `maxima_userdir' kann eine Zeichenkette
     zugewiesen werden, die ein Verzeichnis bezeichnet.  Wenn der Wert
     von `maxima_userdir' geändert wird, werden die Variablen
     `file_search_maxima' und `file_search_lisp' nicht automatisch
     angepasst.

 -- Funktion: room ()
 -- Funktion: room (true)
 -- Funktion: room (false)
     Gibt eine Beschreibung der Speicherplatznutzung aus.  Die
     Darstellung und der Inhalt der Informationen hängen von dem Maxima
     zugrundeliegenden Lisp ab.  Mit den Argumenten `true' und `false'
     wird der Umfang der auszugebenen Information kontrolliert.  Mit
     dem Argument `true' wird die umfangreichste Darstellung ausgegeben
     und mit dem Argument `false' die kürzeste.

     Beispiel:

     Das folgende Beispiel zeigt die Ausgabe auf einem Linux-System mit
     der Lisp-Implementierung SBCL 1.0.45.

          (%i1) build_info();

          Maxima version: 5.22post
          Maxima build date: 18:52 12/28/2010
          Host type: i686-pc-linux-gnu
          Lisp implementation type: SBCL
          Lisp implementation version: 1.0.45
          (%o1)

          (%i2) room(false);
          Dynamic space usage is:   63,719,856 bytes.
          Read-only space usage is:      3,512 bytes.
          Static space usage is:         2,256 bytes.
          Control stack usage is:        1,440 bytes.
          Binding stack usage is:          184 bytes.
          Control and binding stack usage is for the current thread only.
          Garbage collection is currently enabled.
          (%o2)                         false

 -- Funktion: sstatus (<keyword>, <item>)
     Hat das Argument <keyword> den Wert `feature', wird das Argument
     <item> der internen Lisp-Eigenschaftsliste `*features*'
     hinzugefügt.  Das Kommando `status(feature, item)' hat dann das
     Ergebnis `true'.  Hat das Argument <keyword> den Wert `false',
     wird das Argument <item> von der internen Lisp-Eigenschaftsliste
     `*features*' entfernt.

     Siehe auch `status'.


 -- Funktion: status (`feature')
 -- Funktion: status (`feature', <item>)
     `status(feature)' gibt die vollständige interne
     Lisp-Eigenschaftsliste `*features*' zurück.
     `status(feature,item)' gibt `true' zurück, wenn das Argument
     <item> in der internen Lisp-Eigenschaftsliste `*features*'
     enthalten ist.  Ansonsten ist die Rückgabe `false'.  `status'
     wertet die Argumente nicht aus.  Eine Systemeigenschaft <item>,
     die Sonderzeichen wie `-' oder `*' enthält, muss als Zeichenkette
     angegeben werden.

     Siehe auch `sstatus'.

     Die Systemvariable `features' enthält eine Liste mit
     Eigenschaften, die einer mathematischen Funktionen zugeordnet
     werden können.  Siehe `features'  und `featurep'.

     Beispiel:

     Das folgende Beispiel zeigt die Ausgabe für ein Linux-System mit
     SBCL als Lisp.

          (%i1) status(feature);
          (%o1) [sb-bsd-sockets-addrinfo, asdf2, asdf, cl, mk-defsystem,
          cltl2, ansi-cl, common-lisp, sbcl, sb-doc, sb-test, sb-ldb,
          sb-package-locks, sb-unicode, sb-eval, sb-source-locations,
          ieee-floating-point, x86, unix, elf, linux, sb-thread,
          largefile, gencgc, stack-grows-downward-not-upward,
          c-stack-is-control-stack, compare-and-swap-vops,
          unwind-to-frame-and-call-vop, raw-instance-init-vops,
          stack-allocatable-closures, stack-allocatable-vectors,
          stack-allocatable-lists, stack-allocatable-fixed-objects,
          alien-callbacks, cycle-counter, inline-constants,
          memory-barrier-vops, linkage-table, os-provides-dlopen,
          os-provides-dladdr, os-provides-putwc, os-provides-suseconds-t,
          os-provides-getprotoby-r, os-provides-poll]

          (%i2) status(feature,"ansi-cl");
          (%o2)                         true

 -- Funktion: system (<command>)
     `system(command)' führt das Kommando <command> in einem eigenen
     Prozess aus.  Das Kommando wird an die Standard-Shell übergeben.
     `system' wird nicht von allen Betriebssystemen unterstützt, steht
     aber im Allgemeinen unter Unix oder Unix ähnlichen
     Betriebssystemen zur Verfügung.

 -- Funktion: time (%o1, %o2, %o3, ...)
     Gibt eine Liste mit den Ausführungszeiten zurück, die benötigt
     wurden, um die Ergebnisse `%o1', `%o2', `%o3', ... zu berechnen.
     Die Argumente der Funktion `time' können nur Ausgabemarken sein.
     Für andere Argumente ist das Ergebnis `unknown'.

     Siehe die Optionsvariable `showtime',  um die Ausführungszeiten für
     jede einzelne Berechnung anzuzeigen.

     Beispiel:

     Die Zeit für die Berechnung der Fakultät einer großen ganzen Zahl
     wird mit `time' ausgegeben.  Das Ergebnis muss nicht angezeigt
     werden.  Das Ergebnis hat 456573 Stellen.

          (%i1) factorial(100000)$

          (%i2) time(%o1);
          (%o2)                        [7.585]
          (%i3) bfloat(%o1);
          (%o3)               2.824229407960348b456573

 -- Funktion: timedate ()
     Gibt eine Zeichenkette zurück, die das aktuelle Datum und die
     aktuelle Zeit enthält.  Die Zeichenkette hat das Format
     `yyyy-mm-dd HH:MM:SS (GMT-n)'.

     Beispiel:

          (%i1) timedate();
          (%o1)               2010-12-28 21:56:32+01:00

 -- Funktion: absolute_real_time ()
     Gibt die Sekunden zurück, die seit dem 1. Januar 1990 UTC
     verstrichen sind.  Die Rückgabe ist eine ganze Zahl.

     Siehe auch `elapsed_real_time'  und `elapsed_run_time'.

     Beispiel:

          (%i1) absolute_real_time ();
          (%o1)                      3502559124
          (%i2) truncate(1900+absolute_real_time()/(365.25*24*3600));
          (%o2)                         2010

 -- Funktion: elapsed_real_time ()
     Gibt die Sekunden zurück, die seit dem letzten Start von Maxima
     verstrichen sind.  Die Rückgabe ist eine Gleitkommazahl.

     Siehe auch `absolute_real_time'  und `elapsed_run_time'.

     Beispiel:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087

 -- Funktion: elapsed_run_time ()
     Gibt eine Schätzung der Zeit in Sekunden zurück, die Maxima für
     Berechnungen seit dem letzten Start benötigt hat.  Der
     Rückgabewert ist eine Gleitkommazahl.

     Siehe auch `absolute_real_time'  und `elapsed_real_time'.

     Beispiel:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26


File: maxima.info,  Node: Programmierung,  Next: Übersetzer,  Prev: Laufzeitumgebung,  Up: Top

27 Programmierung
*****************

* Menu:

* Lisp und Maxima::
* Einführung in die Programmierung::
* Funktionen und Variablen der Programmierung::


File: maxima.info,  Node: Lisp und Maxima,  Next: Einführung in die Programmierung,  Prev: Programmierung,  Up: Programmierung

27.1 Lisp und Maxima
====================

Maxima ist in Lisp programmiert.  Es ist einfach Lisp-Funktionen und
Lisp-Variable in Maxima zu verwenden.  Umgekehrt können
Maxima-Funktionen und Maxima-Variablen in Lisp verwendet werden.  Ein
Lisp-Symbol, das mit einem Dollarzeichen `$' beginnt, entspricht einem
Maxima-Symbol ohne einem Dollarzeichen.  Umgekehrt entspricht einem
Maxima-Symbol, das mit einem Fragezeichen `?' beginnt, einem
Lisp-Symbol ohne das Fragezeichen.  Zum Beispiel entspricht dem
Maxima-Symbol `foo' das Lisp-Symbol `$foo' und dem Maxima-Symbol `?foo'
entspricht das Lisp-Symbol `foo'.

Speziellen Zeichen wie einem Trennstrich `-' oder einem Stern `*' in
Lisp-Symbolen muss ein Backslash `\' vorangestellt werden, um diese in
Maxima zu verwenden.  Zum Beispiel entspricht dem Lisp-Symbol
`*foo-bar*' das Maxima-Symbol `?\*foo\-bar\*'.

Lisp-Code kann von einer Maxima-Kommandozeile ausgeführt werden.  Eine
einzelne Zeile Lisp-Code kann mit dem Unterbrechungskommando `:lisp'
ausgeführt werden.  Siehe das Kapitel Debugger-Kommandos  für weitere
Informationen zu Unterbrechungskommandos.

Beispiele:

Addiere die Werte der Maxima-Variablen `x' und `y' mit dem
Lisp-Operator `+'.

     (%i1) x:10$ y:5$
     (%i3) :lisp (+ $x $y)
     15

Addiere die Symbole `a' und `b' mit der Lisp-Funktion `ADD'.  Das
Ergebnis wird der Variablen `$RES' zugewiesen.  Die Variable hat in
Maxima den Namen `res'.

     (%i3) :lisp (setq $res (add '$a '$b))
     ((MPLUS SIMP) $A $B)
     (%i3) res;
     (%o3)                         b + a

Das `:lisp'-Kommando ist nützlich, um zum Beispiel Lisp-Eigenschaften
von Maxima-Symbolen anzuzeigen, globale Lisp-Variablen wie
`*PRINT-CIRCLE*' zu setzen oder wie im letzten Beispiel die interne
Form von Maxima-Ausdrücken anzuzeigen.

     (%i4) :lisp (symbol-plist 'mabs)
     (TEXSYM ((\left| ) \right| ) TEX TEX-MATCHFIX REAL-VALUED T
             MAPS-INTEGERS-TO-INTEGERS T DIMENSION DIM-MABS TRANSLATE
             #<FUNCTION (LAMBDA #) {972D045}> FLOATPROG MABSBIGFLOAT INTEGRAL
             ((X) #<FUNCTION ABS-INTEGRAL>) OPERATORS SIMPABS DISTRIBUTE_OVER
             (MLIST $MATRIX MEQUAL) NOUN $ABS REVERSEALIAS $ABS GRAD
             ((X) ((MTIMES) X ((MEXPT) ((MABS) X) -1))))

     (%i4) :lisp (setq *print-circle* nil)
     NIL

     (%i4) 'integrate(t*sin(t), t);
                               /
                               [
     (%o4)                     I t sin(t) dt
                               ]
                               /
     (%i5) :lisp $%
     ((%INTEGRATE SIMP) ((MTIMES SIMP) $T ((%SIN SIMP) $T)) $T)

Das Kommando `:lisp' kann in einer Kommandozeile und in Dateien
verwendet werden, die mit den Funktionen `batch'  oder `demo'  geladen
werden.  Dagegen kann das Kommando `:lisp' nicht in Dateien verwendet
werden, die mit den Funktionen `load',  `batchload',  `translate_file'
oder `compile_file'  geladen werden.

Mit dem Kommando `to_lisp()'  kann von einer Maxima-Kommandozeile eine
Lisp-Sitzung geöffnet werden.  Mit dem Kommando `(TO-MAXIMA)' wird die
Lisp-Sitzung beendet und nach Maxima zurückgekehrt.

Lisp-Funktionen und Lisp-Variablen, welche in Maxima verwendet werden,
sollten mit einem Dollarzeichen `$' beginnen.

Im Gegensatz zu Lisp unterscheidet Maxima Groß- und Kleinschreibung.  Es
gibt einige Regeln, die eine Übersetzung von Namen zwischen Lisp und
Maxima betreffen:

  1. Ein Lisp-Bezeichner, der nicht von senkrechten Strichen
     eingeschlossen ist, entspricht einem klein geschriebenen
     Maxima-Bezeichner.  Die Schreibweise des Lisp-Bezeichners wird
     dabei ignoriert.  Zum Beispiel entspricht den folgenden
     Lisp-Bezeichnern `$foo', `$FOO' und `$Foo' jeweils der
     Maxima-Bezeichner `foo'.

  2. Ein Lisp-Bezeichner, der vollständig groß oder klein geschrieben
     ist und von senkrechten Strichen eingeschlossen wird, entspricht
     einem Maxima-Bezeichner in der umgekehrten Schreibweise.  Ein
     klein geschriebener Lisp-Bezeichner wird also zu einem
     großgeschriebenen Maxima-Bezeichner und umgekehrt.  Zum Beispiel
     entsprechen den Lisp-Bezeichnern `|$FOO|' und `|$foo|' die
     Maxima-Bezeichner `foo' und `FOO'.

  3. Ein Lisp-Bezeichner in gemischter Schreibweise, der von
     senkrechten Strichen eingeschlossen ist, entspricht einem
     Maxima-Bezeichner in der gleichen Schreibweise.  Zum Beispiel
     entspricht dem Lisp-Bezeichner `|$Foo|' der Maxima-Bezeichner
     `Foo'.

Das Lisp-Makro `#$' erlaubt die Nutzung von Maxima-Ausdrücken in
Lisp-Code.  `#$<expr>$' wird zu einem Lisp-Ausdruck expandiert, der dem
Maxima-Ausdruck <expr> entspricht.

Beispiele:

Die beiden folgenden Beispiele zeigen die Zuweisung an eine Variable
`var'.  Im ersten Beispiel werden Lisp- und Maxima-Code gemischt.  Für
die Zuweisung an die Variable wird die Lisp-Funktion `MSETQ'
aufgerufen.  Das Makro `#$' transformiert den Maxima Ausdruck `sin(x) +
a^2' in die Lisp-Form `((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP)
$X))'.  Dies entspricht dem im zweiten Beispiel gezeigten
Maxima-Kommando.

     (%i1) :lisp (msetq $var #$sin(x)+a^2$)
     ((MPLUS SIMP) ((MEXPT SIMP) $A 2) ((%SIN SIMP) $X))

     (%i1) var: sin(x)+a^2;
                                          2
     (%o1)                      sin(x) + a

In diesem Beispiel wird zunächst ein Maxima-Ausdruck der Variablen
<$VAR> zugewiesen und dann mit der Lisp-Funktion `DISPLA' ausgegeben.

     (%i1) :lisp (setq $var #$'integrate(f(x), x)$)
     ((%INTEGRATE SIMP) (($F SIMP) $X) $X)

     (%i1) :lisp (displa $var)
     /
     [
     I f(x) dx
     ]
     /
     NIL

Maxima-Funktionen sind keine Lisp-Funktionen.  Um eine Maxima-Funktion
in Lisp-Code aufzurufen, kann die Lisp-Funktion `MFUNCALL' aufgerufen
werden.

     (%i1) f(x,y) := x^2 + sin(y)$

     (%i2) :lisp (mfuncall '$f '$a 10)
     ((MPLUS SIMP) ((%SIN SIMP) 10) ((MEXPT SIMP) $A 2))

Die folgenden Lisp-Funktionen können in Maxima nicht verwendet werden:

`complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', und `gcd'.


File: maxima.info,  Node: Einführung in die Programmierung,  Next: Funktionen und Variablen der Programmierung,  Prev: Lisp und Maxima,  Up: Programmierung

27.2 Einführung in die Programmierung
=====================================

In Maxima können Programme geschrieben werden.  Alle Maxima-Funktionen
und Maxima-Variablen können in Programmen verwendet werden.  Maxima hat
einen Übersetzer, um Maxima-Programme in Lisp-Programme zu übersetzen,
und einen Compiler, um die übersetzten Programme zu kompilieren.  Siehe
dazu das Kapitel Übersetzer.

Maxima-Programme bestehen aus Funktionen und Makros, die im Kapitel
Funktionsdefinitionen  beschrieben sind.  Die Funktionen werden aus
Ausdrücken der Form `(expr_1, expr_2, ..., expr_n)' oder `block'
-Anweisungen zusammengesetzt.  Mit der Anweisung `local'  werden
Variablen definiert, deren Werte und Eigenschaften lokal zu einem Block
sind.

Konditionale Verzweigen werden mit der Anweisung `if'  definiert und
haben die Form `if ... then ... else'.

Maxima kennt die sehr allgemeine Anweisung `for',  um Schleifen zu
programmieren.  Schlüsselworte für die Programmierung von Schleifen sind
`while',  `unless',  `do'  sowie `thru', `step', `in'.

Mit der Sprunganweisung `return'  kann ein Block verlassen werden und
mit der Sprunganweisung `go'  wird innerhalb eines Blockes zu eine Marke
verzweigt.  Nicht-lokale Rücksprünge aus Funktionen werden mit den
Anweisungen `catch'  und `throw'  programmiert.

Die Anweisung `errcatch'  fängt Fehler ab, so dass die Ausführung eines
Programms nicht abgebrochen wird.  Mit der Anweisungen `error'  und
`break'  wird ein Programm abgebrochen.  Im ersten Fall kann eine
Fehlermelung ausgegeben werden und das Programm kehrt zur
Maxima-Kommandozeile zurück.  Mit `break' wird der Maxima-Debugger
gestartet.

Maxima kennt die folgenden Anweisungen und Variablen um Programme zu
definieren:


   backtrace   block        break
   catch       do           errcatch
   error       error_size   error_syms
   errormsg    for          go
   if          local        return
   throw       unless       while


File: maxima.info,  Node: Funktionen und Variablen der Programmierung,  Prev: Einführung in die Programmierung,  Up: Programmierung

27.3 Funktionen und Variablen der Programmierung
================================================

 -- Funktion: backtrace ()
 -- Funktion: backtrace (<n>)
     Gibt den Aufruf-Stack der Funktion zurück, die ausgeführt wird.

     Das Kommando `backtrace()' zeigt den gesamten Stack.
     `backtrace(<n>)' zeigt die letzten <n> Funktionen einschließlich
     der Funktion, die ausgeführt wird.

     `backtrace' kann in einer Batch-Datei, die zum Beispiel mit der
     Funktion `batch'  geladen wird, in einer Funktion oder von einer
     Kommandozeile aufgerufen werden.

     Beispiele:

     `backtrace()' gibt den gesamten Stack aus.

          (%i1) h(x) := g(x/7)$
          (%i2) g(x) := f(x-11)$
          (%i3) f(x) := e(x^2)$
          (%i4) e(x) := (backtrace(), 2*x + 13)$
          (%i5) h(10);
          #0: e(x=4489/49)
          #1: f(x=-67/7)
          #2: g(x=10/7)
          #3: h(x=10)
                                        9615
          (%o5)                         ----
                                         49

     `backtrace(<n>)' gibt die letzten <n> Funktionen aus.

          (%i1) h(x) := (backtrace(1), g(x/7))$
          (%i2) g(x) := (backtrace(1), f(x-11))$
          (%i3) f(x) := (backtrace(1), e(x^2))$
          (%i4) e(x) := (backtrace(1), 2*x + 13)$
          (%i5) h(10);
          #0: h(x=10)
          #0: g(x=10/7)
          #0: f(x=-67/7)
          #0: e(x=4489/49)
                                        9615
          (%o5)                         ----
                                         49

 -- Funktion: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Funktion: block (<expr_1>, ..., <expr_n>)
     Mit der Anweisung `block' werden Ausdrücke in einer lokalen
     Umgebung zusammengefasst.  `block' wertet die Argument <expr_1>,
     <expr_2>, ..., <expr_n> nacheinander aus und gibt das Ergebnis des
     letzten ausgewerteten Ausdrucks zurück.  Die Liste `[v_1, ...,
     v_m]' am Anfang der `block'-Anweisung bezeichnet Variablen, die
     innerhalb der `block'-Anweisung lokal sind.  Alle anderen
     Variablen, die in einem Block verwendet werden, beziehen sich auf
     globale Variablen, die auÃerhalb des Block definiert sind.  Dies
     kann ein weiterer Block oder die globale Maxima-Umgebung sein.
     `block' sichert die aktuellen Werte der Variablen <v_1>, ...,
     <v_m>.  Wird `block' verlassen, werden diese Werte
     wiederhergestellt.

     Die Deklaration `local(<v_1>, ..., <v_m>)' innerhalb der
     `block'-Anweisung sichert nicht nur die Werte, sondern auch die
     Eigenschaften der Variablen wie sie zum Beispiel mit den Funktionen
     `declare'  oder `depends'  definiert werden.  Erhalten die mit
     `local' deklarierten Variablen innerhalb der `block'-Anweisung
     Eigenschaften, wirken sich diese nur lokal aus.  Beim Verlassen der
     `block'-Anweisung werden die globalen Eigenschaften
     wiederhergestellt.  Siehe auch `local'.

     Die `block'-Anweisung kann verschachtelt werden.  Jeder Block kann
     eigene lokale Variablen definieren.  Diese sind global zu jedem
     anderen Block der sich innerhalb des Blockes befindet.  Ein
     Variable die nicht als lokal definiert ist, hat den globalen Wert
     eines umgebenden Blocks oder den Wert der globalen Maxima-Umgebung.

     Der Rückgabewert eines Blocks ist der Wert des letzten Ausdrucks
     oder der Wert, der mit den `return'-Anweisung zurückgegeben wird.
     Mit der `go'-Anweisung kann innerhalb eines Blocks zu einer Marke
     gesprungen werden.  Weiterhin kann mit der `throw' -Anweisung ein
     nicht-lokaler Rücksprung zu einer entsprechenden `catch'
     -Anweisung erfolgen.

     Blöcke erscheinen typischerweise auf der rechten Seite einer
     Funktionsdefinitionen.  Sie können aber auch an anderen Stellen
     verwendet werden.

     Beispiel:

     Das Beispiel zeigt eine einfache Implementation des
     Newton-Algorithmus.  Der Block definiert die lokalen Variablen
     `xn', `s' und <numer>.  `numer'  ist eine Optionsvariable, die im
     Block einen lokalen Wert erhält.  Im Block ist das Tag `loop'
     definiert.  Zu diesem Tag wird mit der Anweisung `go(loop)'
     gesprungen.  Der Block und damit die Funktion wird mit der
     Anweisung `return(xn)' verlassen.  Der Wert der Variablen `xn' ist
     das Ergebnis der Funktion `newton'.

          newton(exp,var,x0,eps):=
             block([xn,s,numer],
                numer:true,
                s:diff(exp,var),
                xn:x0,
             loop,
                if abs(subst(xn,var,exp))<eps then return(xn),
                xn:xn-subst(xn,var,exp)/subst(xn,var,s),
                go(loop) )$

 -- Funktion: break (<expr_1>, ..., <expr_n>)
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> aus, zeigt die
     Ergebnisse an und führt dann eine Unterbrechung aus.  Mit dem
     Kommando `exit;' wird Maxima fortgesetzt.  Siehe das Kapitel

     Beispiel:

     Der Variablen `a' wird der Wert 2 zugewiesen.  Dann wird die
     Unterbrechung ausgeführt.  Mit dem Kommando `exit;' wird Maxima
     fortgesetzt.

          (%i1) break(a:2);
          2

          Entering a Maxima break point. Type 'exit;' to resume.
          _a;
          2
          _exit;
          (%o1)                           2

 -- Funktion: catch (<expr_1>, ..., <expr_n>)
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> nacheinander aus.
     Wertet irgendeiner der Ausdrücke zu `throw(arg)' aus, dann ist das
     Ergebnis der Wert von `throw(arg)' und es werden keine weiteren
     Ausdrücke ausgewertet.  Diese nicht-lokale Rückgabe kehrt zu dem
     nächsten `catch' in einer beliebigen Verschachtelungstiefe zurück.
     Wird kein `catch' gefunden gibt Maxima eine Fehlermeldung aus.

     Führt die Auswertung der Argumente nicht zu einem `throw', dann ist
     die Rückgabe das Ergebnis des letzten Ausdrucks `expr_n'.

     Beispiel:

     Die Funktion `g' gibt eine Liste mit den Werten des
     Lambda-Ausdrucks zurück.  Tritt ein negativer Wert auf, bricht die
     Funktion ab, in diesem Beispiel mit `throw(-3)'.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

 -- Spezieller Operator: do
     Die `do'-Anweisung erlaubt die Definition von Iterationen.
     Aufgrund der großen Allgemeinheit der `do'-Anweisung folgt die
     Beschreibung in zwei Teilen.  Zunächst werden die bekannteren
     Formen beschrieben, wie sie auch in anderen Programmiersprachen
     vorhanden sind.  Dann folgen die weiteren Möglichkeiten.

     Es gibt drei Varianten der `do'-Anweisung, die sich nur durch die
     Abbruchbedingung voneinander unterscheiden.  Diese sind:

          for <variable>: <initial_value> step <increment>
                thru <limit> do <body>

          for <variable>: <initial_value> step <increment>
                while <condition> do <body>

          for <variable>: <initial_value> step <increment>
                unless <condition> do <body>

     <initial_value>, <increment>, <limit> und <body> können beliebige
     Ausdrücke sein.  Ist das Inkrement 1, kann `step' entfallen.

     Die Ausführung der `do'-Anweisung beginnt mit der Zuweisung von
     `initial_value' an die Kontrollvariable <variable>.  Dann folgen
     die Schritte: (1) Hat die Kontrollvariable den Wert einer
     `thru'-Anweisung überschritten oder hat die Bedingung einer
     `unless'-Anweisung den Wert `true' oder hat die Bedingung einer
     `while'-Anweisung den Wert `false', dann endet die Ausführung der
     `do'-Anweisung.  (2) Die Ausdrücke in <body> werden ausgewertet.
     (3) Das Inkrement wird zu der Kontrollvariablen hinzuaddiert.  Die
     Schritte (1) bis (3) werden solange ausgeführt, bis eine der
     Bedingungen für die Beendigung der `do'-Anweisung zutrifft.

     Im Allgemeinen ist der `thru'-Test erfüllt, wenn die
     Kontrollvariable größer als <limit> ist, falls <increment> nicht
     negativ ist.  Oder wenn die Kontrollvariable kleiner als `limit'
     ist, für den Fall, dass das Inkrement negativ ist.  <increment>
     und <limit> können Ausdrücke sein, sofern die Bedingung zum
     Abbruch der `do'-Anweisung ausgewertet werden kann.  Soll
     `increment' zu einem negativen Wert auswerten und kann dies jedoch
     bei Eintritt in die Schleife von Maxima nicht festgestellt werden,
     so wird das Inkrement als positiv angenommen.  Dies kann dazu
     führen, dass die Schleife nicht korrekt ausgeführt wird.

     <limit>, <increment> und die Bedingung für den Abbruch der Schleife
     werden für jeden Durchgang durch die Schleife ausgewertet.  Ändern
     diese ihren Wert nicht, kann es daher effizienter sein, die Werte
     diese Ausdrücke vor Eintritt in die Schleife zu berechnen und in
     Variablen abzulegen, die anstatt der Ausdrücke in der Schleife
     verwendet werden.

     Die `do'-Anweisung hat den Rückgabewert `done'.  Um einen anderen
     Wert zurückzugeben, kann die `return'-Anweisung innerhalb von
     `body' genutzt werden.  Befindet sich die `do'-Anweisung innerhalb
     eines Blockes, so wird dieser nicht mit einer `return'-Anweisung
     verlassen, die sich innerhalb der `do'-Anweisung befindet.  Auch
     kann nicht mit der `go'-Anweisung in einen umgebenen Block
     gesprungen werden.

     Die Kontrollvariable ist immer lokal zur `do'-Anweisung.  Nach dem
     Verlassen der `do'-Anweisung kann auf die Kontrollvariable nicht
     mehr zugegriffen werden.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

     Die Bedingung `while i <= 10' ist äquivalent zu den Bedingungen
     `unless i > 10' und `thru 10' ist.

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Berechne die ersten acht Terme einer Taylorreihe in einer
     `do'-Schleife.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     In diesem Beispiel wird die negative Wurzel von 10 mit einem
     Newton-Raphson-Algorithmus berechnet.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Anstatt eines festes Inkrements mit `step' kann die
     Kontrollvariable auch mit `next' für jeden Schleifendurchgang
     berechnet werden.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Anstatt mit der Syntax `for <variable>: <value> ...' kann die
     Kontrollvariable auch mit `for <variable> from <value> ...do...'
     initialisiert werden.  Wird auch `from <value>' fortgelassen, wird
     die Kontrollvariable mit dem Wert 1 initialisiert.

     Manchmal kann es von Interesse sein, in einer Schleife keine
     Kontrollvariable zu nutzen.  In diesem Fall genügt es allein die
     Bedingung für den Abbruch der Schleife anzugeben.  Im folgenden
     wird die Wurzel aus 5 mit dem Heron-Verfahren bestimmt.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Auch die Abbruchbedingung kann fortgelassen werden.  Wird allein
     `do <body>' angegeben, wird die Schleife unendlich oft ausgeführt.
     Die Schleife kann mit der `return'-Anweisung verlassen werden.
     Das folgende Beispiel zeigt eine Implementierung des
     Newton-Algorithmus.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     Eine weitere Syntax ist die folgende:

          for <variable> in <list> <end_tests> do <body>

     Die Elemente der Liste <list> können beliebige Ausdrücke sein, die
     nacheinander der Kontrollvariablen zugewiesen werden.  Die
     Schleife bricht ab, wenn die optionale Abbruchbedingung `end_test'
     zutrifft, wenn die Liste <list> keine weiteren Elemente enthält
     oder wenn die Schleife zum Beispiel mit der Funktion `return'
     verlassen wird.

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816

 -- Funktion: errcatch (<expr_1>, ..., <expr_n>)
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> nacheinander aus und
     gibt das Ergebnis des letzten Ausdrucks als eine Liste `[<expr_n>]'
     zurück, wenn kein Fehler bei der Auswertung auftritt.  Tritt ein
     Fehler bei der Auswertung eines der Ausdrücke auf, ist die
     Rückgabe eine leere Liste `[]'.

     `errcatch' ist nützlich in Batch-Dateien.  Mit `errcatch' kann ein
     möglicher Fehler abgefangen werden, ohne das die Verarbeitung der
     Batch-Datei abbricht.

     Beispiele:

          (%i1) errcatch(x:2,1/x);
                                          1
          (%o1)                          [-]
                                          2
          (%i2) errcatch(x:0,1/x);

          Division by 0
          (%o2)                          []

 -- Funktion: error (<expr_1>, ..., <expr_n>)
 -- Systemvariable: error
     Wertet die Ausdrücke <expr_1>, ..., <expr_n> aus, gibt diese auf
     der Konsole aus und generiert einen Fehler, der zur obersten Ebene
     von Maxima führt oder zu dem nächsten `errcatch'.

     Der Systemvariablen `error' wird eine Liste zugewiesen, die eine
     Beschreibung des Fehlers enthält.  Das erste Element der Liste ist
     eine Zeichenkette und die weiteren Elemente enthalten die
     Argumente die keine Zeichenkette sind.

     `errormsg()' formatiert und gibt die Fehlermeldung in `error' aus.
     Damit wird die letzte Fehlermeldung erneut ausgegeben.

     Beispiel:

          (%i1) f(x):= if x=0 then
                          error("Division durch", x, "ist nicht gestattet.")
                       else 1/x$
          (%i2) f(0);

          Division durch 0 ist nicht gestattet.
          #0: f(x=0)
           -- an error. To debug this try: debugmode(true);
          (%i3) errormsg();

          Division durch 0 ist nicht gestattet.
          (%o3)                         done
          (%i4) error;
          (%o4)      [Division durch ~M ist nicht gestattet., 0]

 -- Optionsvariable: error_size
     Standardwert: 10

     `error_size' kontrolliert die Ausgabe eines Ausdrucks der zu einem
     Fehler geführt hat.  Ist der Ausdruck größer als `error_size' wird
     der Ausdruck bei der Ausgabe einer Fehlermeldung durch ein Symbol
     ersetzt und dem Symbol wird der Ausdruck zugewiesen.  Die Symbole
     werden aus der Liste `error_syms' ausgewählt.

     Ist der Ausdruck kleiner als `error_size' wird dieser mit der
     Fehlermeldung ausgegeben.

     Siehe auch `error'  und `error_syms'.

     Beispiel:

     Die Größe des Ausdrucks `U' ist 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Optionsvariable: error_syms
     Standardwert: `[errexp1, errexp2, errexp3]'

     In Fehlermeldungen werden Ausdrücke, die größer als `error_size'
     sind, durch Symbole ersetzt, denen der Ausdruck zugewiesen wird.
     Die Symbole werden nacheinander der Liste `error_syms' entnommen.

     Sind keine Symbole mehr vorhanden, werden automatisch neue Symbole
     mit `concat('errexp, <n>)' gebildet.

     Siehe auch `error'  und `error_size'.


 -- Funktion: errormsg ()
     Gibt die letzte Fehlermeldung erneut aus.  Die Fehlermeldung ist
     in der Systemvariablen `errormsg' enthalten.  Die Funktion
     `errormsg' formatiert diese und gibt sie aus.

 -- Optionsvariable: errormsg
     Standardwert: `true'

     Hat die Optionsvariable `errormsg' den `false' wird die Ausgabe
     von Fehlermeldungen unterdrückt.

     Der Optionsvariablen `errormsg' kann in einem Block kein lokaler
     Wert zugewiesen werden.  Der globale Wert von `errormsg' ist stets
     präsent.

     Beispiele:

          (%i1) errormsg;
          (%o1)                                true
          (%i2) sin(a,b);
          Wrong number of arguments to sin
           -- an error. To debug this try: debugmode(true);
          (%i3) errormsg:false;
          (%o3)                                false
          (%i4) sin(a,b);

           -- an error. To debug this try: debugmode(true);

     Der Optionsvariablen `errormsg' kann in einem Block kein lokaler
     Wert zugewiesen werden.

          (%i1) f(bool):=block([errormsg:bool],
                               print ("value of errormsg is",errormsg))$
          (%i2) errormsg:true;
          (%o2)                                true
          (%i3) f(false);
          value of errormsg is true
          (%o3)                                true
          (%i4) errormsg:false;
          (%o4)                                false
          (%i5) f(true);
          value of errormsg is false
          (%o5)                                false

 -- Spezieller Operator: for
     Anweisung für Interationen.  Siehe die `do' -Anweisung für eine
     Beschreibung der Iterationsmöglichkeiten von Maxima.

 -- Funktion: go (<tag>)
     Erlaubt einen Sprung innerhalb eines Blocks zu einer Marke mit dem
     Namen `tag'.  Um eine Anweisung mit einer Sprungmarke zu versehen,
     wird der Anweisung die Marke vorangestellt.  Ein Beispiel ist:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     Das Argument der Funktion `go' muss der Name einer Marke sein, die
     in demselben Block erscheint.  Es ist nicht möglich in einen
     anderen Block zu springen.

 -- Spezieller Operator: if
     Ist die bedingte Anweisung.  Verschiedene Formen einer bedingten
     Anweisung sind möglich.

     `if <cond_1> then <expr_1> else <expr_0>' wertet zu <expr_1> aus,
     wenn die Bedingung <cond_1> den Wert `true' hat.  Ansonsten wertet
     der Ausdruck zu <expr_0> aus.

     Die zusammengesetzte bedingte Anweisung `if <cond_1> then <expr_1>
     elseif <cond_2> then <expr_2> elseif ... else <expr_0>' wertet zu
     <expr_k> aus, wenn die Bedingung <cond_k> den Wert `true' hat und
     alle vorhergehenden Bedingungen den Wert `false' haben.  Trifft
     keine der Bedingungen zu, wertet der Ausdruck zu <expr_0> aus.

     Fehlt die Anweisung `else', wird diese zu `else false' angenommen.
     `if <cond_1> then <expr_1>' ist daher äquivalent zu `if <cond_1>
     then <expr_1> else false' und `if <cond_1> then <expr_1> elseif
     ... elseif <cond_n> then <expr_n>' ist äquivalent zu `if <cond_1>
     then <expr_1> elseif ... elseif <cond_n> then <expr_n> else false'.

     Die Anweisungen <expr_0>, ..., <expr_n> können beliebige
     Maxima-Ausdrücke einschließlich weiterer `if'-Anweisungen sein.
     Die Anweisungen werden nicht vereinfacht oder ausgewertet, solange
     die dazugehörende Bedingung nicht das Ergebnis `true' hat.

     Die Bedingungen <cond_1>, ..., <cond_n> sind Ausdrücke, die zu
     `true' oder `false' ausgewertet werden können.  Kann eine Bedingung
     nicht zu `true' oder `false' ausgewertet werden, hängt die Reaktion
     von der Optionsvariablen `prederror' ab.  Hat `prederror' den Wert
     `true', dann meldet Maxima einen Fehler, wenn eine Bedingung nicht
     zu `true' oder `false' ausgewertet werden kann.  Ansonsten werden
     Bedingungen akzeptiert, die nicht zu `true' oder `false'
     ausgewertet werden können und das Ergebnis ist ein bedingter
     Ausdruck.

     Die Bedingungen können die folgenden Operatoren enthalten:

          Operation              Symbol      Typ

          less than              <           relational infix
          less than              <=
            or equal to                      relational infix
          equality (syntactic)   =           relational infix
          negation of =          #           relational infix
          equality (value)       equal       relational function
          negation of equal      notequal    relational function
          greater than           >=
            or equal to                      relational infix
          greater than           >           relational infix
          and                    and         logical infix
          or                     or          logical infix
          not                    not         logical prefix

 -- Funktion: local (<v_1>, ..., <v_n>)
     Speichert alle Eigenschaften der Symbole <v_1>, ..., <v_n>,
     entfernt die Eigenschaften und stellt die abgespeicherten
     Eigenschaften nach dem Austritt aus einem Block oder einem
     zusammengesetzten Ausdruck in dem `local' auftritt wieder her.

     Einige Deklarationen sind als Eigenschaft eines Symbols
     implementiert.  Dazu gehören Deklarationen mit `:=', `array',
     `dependencies', `atvalue', `matchdeclare', `atomgrad', `constant',
     `nonscalar' oder `assume'.  Der Effekt von `local' ist, dass
     solche Deklarationen nur lokal in dem Block wirksam sind.

     `local' kann nur in `block'-Anweisungen oder in einer
     Funktionsdefinition oder in einem Lambda-Ausdruck verwendet
     werden. Weiterhin darf `local' jeweils nur einmal auftreten.

     `local' wertet die Argumente aus.  `local' hat die Rückgabe `done'.

     Beispiel:

     Eine lokale Funktionsdefinition.

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99

 -- Funktion: return (<value>)
     Die `return'-Anweisung wird in einem Block verwendet, um den Block
     mit dem Ergebnis <value> zu verlassen.  Siehe `block'  für mehr
     Informationen.

 -- Funktion: throw (<expr>)
     Wertet den Ausdruck <expr> aus und generiert eine Ausnahme mit dem
     Ergebnis der Auswertung, die von der letzten `catch'-Anweisung
     behandelt wird.

 -- Spezieller Operator: while
 -- Spezieller Operator: unless
     Siehe den Operator `do'.



File: maxima.info,  Node: Übersetzer,  Next: Fehlersuche,  Prev: Programmierung,  Up: Top

28 Übersetzer
*************

* Menu:

* Einführung in den Übersetzer::
* Funktionen und Variablen des Übersetzers::


File: maxima.info,  Node: Einführung in den Übersetzer,  Next: Funktionen und Variablen des Übersetzers,  Prev: Übersetzer,  Up: Übersetzer

28.1 Einführung in den Übersetzer
=================================


File: maxima.info,  Node: Funktionen und Variablen des Übersetzers,  Prev: Einführung in den Übersetzer,  Up: Übersetzer

28.2 Funktionen und Variablen des Übersetzers
=============================================

 -- Funktion: compfile (<filename>, <f_1>, ..., <f_n>)
 -- Funktion: compfile (<filename>, functions)
 -- Funktion: compfile (<filename>, all)
     Übersetzt Maxima-Funktionen nach Lisp und schreibt den übersetzten
     Code in die Datei <filename>.

     `compfile(<filename>, <f_1>, ..., <f_n>)' übersetzt die Funktionen
     <f_1>, ..., <f_n>.  `compfile(<filename>, functions)' und
     `compfile(<filename>, all)' übersetzen alle nutzerdefinierten
     Funktionen.

     Die Lisp-Übersetzungen werden nicht ausgewertet.  Auch wird die
     Ausgabedatei nicht kompiliert.  `translate' generiert und wertert
     Lisp-Übersetzungen aus.  Die Funktion `compile_file' übersetzt
     Maxima nach Lisp und führt dann den Lisp-Compiler aus.

     Siehe auch `translate',  `translate_file'  und `compile_file'.


 -- Funktion: compile (<f_1>, ..., <f_n>)
 -- Funktion: compile (functions)
 -- Funktion: compile (all)
     Übersetzt die Maxima-Funktionen <f_1>, ..., <f_n> nach Lisp,
     wertet die Lisp-Übersetzungen aus und ruft den Lisp-Compiler für
     jede übersetzte Funktion auf.  `compile' gibt eine Liste mit den
     Namen der kompilierten Funktionen zurück.

     `compile(all)' oder `compile(funtions)' kompiliert alle
     nutzerdefinierten Funktionen.

     `compile' wertet die Argumente nicht aus.  Der Quote-Quote-Operator
     `''' erzwingt die Auswertung.


 -- Funktion: compile_file (<filename>)
 -- Funktion: compile_file (<filename>, <compiled_filename>)
 -- Funktion: compile_file (<filename>, <compiled_filename>,
          <lisp_filename>)
     Übersetzt die Maxima-Datei <filename> nach Lisp, ruft den
     Lisp-Compiler auf und lädt falls erfolgreich den kompilierten Code
     in Maxima.

     `compile_file' gibt eine Liste mit den Namen von vier Dateien
     zurück: die ursprüngliche Maxima-Datei, die Lisp-Übersetzung, eine
     Datei mit Notizen zur Übersetzungen und eine Datei mit dem
     kompilierten Code.  Schlägt die Kompilierung fehlt, ist der vierte
     Eintrag `false'.

     Einige Deklarationen und Definitionen sind bereits vorhanden,
     nachdem der Lisp-Code kompiliert ist und ohne das dieser geladen
     wurde.  Dies schließt Funktionsdefinitionen mit dem Operator `:=',
     Makros definiert mit dem Operator `::=' sowie Definitionen der
     folgenden Funktionen `alias', `declare', `define_variable',
     `mode_declare', `infix', `matchfix', `nofix', `postfix', `prefix'
     und `compfile' ein.

     Zuweisungen und Funktionsaufrufe werden nicht ausgwertet bevor der
     komplierte Code geladen wird.  Im besonderen haben Zuweisungen an
     die Übersetzungsschalter wie `tr_numer' und andere, die in der
     Maxima-Datei aufgeführt sind, keinen Effekt auf die Übersetzung.

     `compile_file' kann Fehler oder Warnungen ausgegeben und `false'
     zurückgegeben, obwohl die Kompilierung erfolgreich ist.  Dies ist
     ein Programmfehler

     Die Datei <filename> darf keine `:lisp'-Anweisungen enthalten.

     `compile_file' wertet die Argumente aus.


 -- Funktion: declare_translated (<f_1>, <f_2>, ...)
     Bei der Übersetzung einer Datei von Maxima-Code nach Lisp-Code ist
     es für den Übersetzer wichtig zu wissen, welche Funktionen der
     Datei bereits übersetzte oder kompilierte Funktionen sind und
     welche Funktionen Maxima-Funktionen oder undefiniert sind.  Mit
     der Deklaration `declare_translated' am Anfang der zu
     übersetzenden Datei wird dem Übersetzer mitgeteilt, dass die als
     Argumente aufgeführten Funktionen <f_1>, <f_2>, ... zur Laufzeit
     des Programms eine Lisp-Funktion repräsentieren.  Fehlt dem
     Übersetzer diese Information wird das Kommando `(MFUNCTION-CALL fn
     arg1 arg2 ...)' generiert.


 -- Optionsvariable: mode_checkp
     Standardwert: `true'

     Hat die Optionsvariable `mode_checkp' den Wert `true' und wird mit
     `mode_declare' für eine Variable, die bereits einen Wert hat, ein
     Typ festgelegt, dann prüft Maxima, ob der vorgesehene Typ zum
     vorliegenden Wert passt.

     Beispiel:

     Im folgenden hat die Variable <n> den Wert 2.0.  Wird <n> mit
     `mode_declare' als eine ganze Zahl definiert, gibt Maxima eine
     Warnung aus, wenn `mode_checkp' den Wert `true' hat.

          (%i1) n: 2.0;
          (%o1)                          2.0
          (%i2) mode_checkp:true;
          (%o2)                         true
          (%i3) mode_declare(n,fixnum);
          warning: n was declared with mode fixnum, but it has value: 2.0
          (%o3)                          [n]
          (%i4) mode_checkp:false;
          (%o4)                         false
          (%i5) mode_declare(n,fixnum);
          (%o5)                          [n]


 -- Optionsvariable: mode_check_errorp
     Standardwert: `false'

     Hat `mode_check_errorp' den Wert `true', bricht `mode_declare' mit
     einer Fehlermeldung ab, wenn für eine Variable die bereits einen
     Wert hat, mit `mode_declare' ein verschiedener Typ deklariert
     werden soll.  Damit diese Optionsvariable wirksam ist, muss
     `mode_checkp' den Wert `true' haben.  Siehe `mode_checkp'.

          (%i1) n: 2.0;
          (%o1)                          2.0
          (%i2) mode_checkp:true;
          (%o2)                         true
          (%i3) mode_check_errorp:true;
          (%o3)                         true
          (%i4) mode_declare(n,fixnum);

          Error: n was declared mode fixnum, has value: 2.0
           -- an error. To debug this try: debugmode(true);


 -- Optionsvariable: mode_check_warnp
     Standardwert: `true'

     Hat `mode_check_warnp' den Wert `true', gibt `mode_declare' eine
     Warnung aus, wenn für eine Variable die bereits einen Wert hat,
     mit `mode_declare' ein verschiedener Typ deklariert werden soll.
     Damit diese Optionsvariable wirksam ist, muss `mode_checkp' den
     Wert `true' haben.  Siehe `mode_checkp'  und `mode_check_errorp'.


 -- Funktion: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' deklariert den Typ von Variablen und Funktionen für
     den Übersetzer und den Kompilierer.  Typischerweise wird
     `mode_declare' am Anfang einer Funktion oder einer Datei mit
     Maxima-Code ausgeführt.

     Die Argumente werden paarweise angegeben und bezeichnen jeweils
     den Namen einer Variablen sowie deren Typ.  Folgende Typen können
     die Variablen erhalten: `boolean', `fixnum', `number', `rational'
     oder `float'.  Anstatt dem Namen einer Variablen kann auch eine
     Liste mit den Namen von Variablen angegeben werden.  In diesem
     Fall erhalten alle Variablen der Liste den angegebenen Typ.

     Ein Array sollte bereits bei seiner Deklaration einen Typ für die
     Elemente erhalten.  Haben alle Elemente des Arrays einen Wert
     sollte das Array mit der Option `complete' deklariert werden, zum
     Beispiel `array(a, complete, dim1, dim2, ...)'.  Sind die Elemente
     des Arrays ganze Zahlen oder Gleitkommazahlen sollte der Typ als
     `fixnum' oder `flonum' deklariert werden.

     Mit der Funktion `mode_declare' kann dann der Typ des Arrays für
     den Übersetzer oder Kompilierer festgelegt werden.  Ein Array der
     Größe 10 `x' 10 mit Gleitkommazahlen erhält die Deklaration
     `mode_declare(completearray(a[10, 10], float)'.

     Der Typ von Funktionen wird mit dem Argument `function(f_1, f2,
     ...)' deklariert.  Hier sind `f_1', `f_2', ... die Funktionen.  Mit
     `mode_declare([function (f_1, f_2, ...)], fixnum)' werden die
     Rückgabewerte der Funktionen `f_1', `f_2', ... als ganze Zahlen
     definiert.

     `modedeclare' ist ein Alias-Name der Funktion `mode_declare'.


 -- Funktion: mode_identity (<mode>, <expr>)
     Mit der Funktion `mode_identity' wird der Typ <mode> für das
     Ergebnis des Ausdrucks <expr> festgelegt.  Hat das Ergebnis einen
     anderen Typ wird in Abhängigkeit von den Werten der
     Optionsvariablen `mode_checkp', `mode_check_warnp' und
     `mode_check_errorp' eine Warnung ausgegeben oder das Programm
     abgebrochen.

     Beispiel:

          (%i1) mode_identity(flonum, sin(1.0));
          (%o1)                   .8414709848078965
          (%i2) mode_identity(integer, sin(1.0));
          warning: sin(1.0) was declared with mode fixnum
                                      , but it has value: .8414709848078965
          (%o2)                   .8414709848078965
          (%i3) mode_identity(integer, sin(a));
          warning: sin(a) was declared with mode fixnum, but it has value:
                                                                     sin(a)
          (%o3)                        sin(a)


 -- Optionsvariable: savedef
     Standardwert: `true'

     Hat `savedef' den Wert `true', wird die Maxima-Definition einer
     Funktion nicht gelöscht, wenn die Funktion übersetzt wird.  Damit
     kann die Definition der Funktion weiterhin mit `dispfun' angzeigt
     werden.

     Hat `savedef' den Wert `false' wird die Maxima-Definition der
     Funktion gelöscht, wenn die Funktion übersetzt wird.

     Beispiele:

     `savedef' hat den Wert `true'.  Die Funktion `f' kann auch nach
     der Übersetzung angzeigt werden und ist in der Liste `functions'
     enthalten.

          (%i1) savedef:true;
          (%o1)                         true
          (%i2) f(x):=x^2+sin(x);
                                          2
          (%o2)                  f(x) := x  + sin(x)
          (%i3) translate(f);
          (%o3)                          [f]
          (%i4) dispfun(f);
                                          2
          (%t4)                  f(x) := x  + sin(x)

          (%o4)                         [%t4]
          (%i5) functions;
          (%o5)                        [f(x)]

     Dasselbe für eine Funktion `g' mit dem Wert `false' für `savedef'.

          (%i6) savedef:false;
          (%o6)                         false
          (%i7) g(x):=sqrt(x)+cos(x)$

          (%i8) translate(g);
          (%o8)                          [g]
          (%i9) dispfun(g);

          fundef: no such function: g
           -- an error. To debug this try: debugmode(true);
          (%i10) functions;
          (%o10)                       [f(x)]


 -- Optionsvariable: transcompile
     Standardwert: `true'

     Hat `transcompile' den Wert `true', generieren die Funktionen
     `translate' und `translate_file' Deklarationen, die das Kompilieren
     des Codes verbessern.

     `compfile' setzt den Wert von `transcompile' zu `true'.


 -- Funktion: translate (<f_1>, ..., <f_n>)
 -- Funktion: translate (functions)
 -- Funktion: translate (all)
     Die vom Nutzer definierten Maxima-Funktionen <f_1>, ..., <f_n>
     werden nach Lisp übersetzt.  Typischerweise sind die übersetzten
     Funktionen schneller als die Maxima-Funktionen.

     `translate(all)' oder `translate(functions)' übersetzt alle vom
     Benutzer definierten Funktionen.

     Funktionen, die übersetzt werden sollen, sollten mit
     `mode_declare' den Typ von Variablen und Funktionen deklarieren,
     um effizienteren Code zu erhalten.  Im Folgenden Beispiel sind
     <x_1>, <x_2>, ... die Argumente der Funktion und <v_1>, <v_2>, ...
     sind die lokalen Variablen.

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     Die Namen von übersetzten Funktionen werden von der
     Informationsliste `functions' entfernt, wenn die Optionsvariable
     `savedef' den Wert `false' hat.  Sie werden der Informationsliste
     `props' hinzugefügt.

     Funktionen sollten erst übersetzt werden, wenn sie vollständig von
     Fehlern befreit wurden.

     Ausdrücke werden als vereinfacht angenommen.  Sind sie es nicht,
     wird zwar korrekter, aber nicht optimierter Code erzeugt.  Daher
     sollte der Schalter `simp' nicht den Wert `false' haben, wodurch
     die Vereinfachung von Ausdrücken unterdrückt wäre.

     Hat der Schalter `translate' den Wert `true', werden
     nutzerdefinierte Funktionen automatisch nach Lisp übersetzt.

     Das Laufzeitverhalten von übersetzten Funktionen kann sich von dem
     nicht-übersetzter Funktionen unterscheiden.  Grundsätzlich sollte
     die Funktion `rat' nicht mit mehr als zwei Argumenten und die
     Funktion `ratvars' nicht genutzt werden, wenn irgendeine der
     Variablen eine CRE-Form mit Deklaration mit `mode_declare'
     aufweisen.  Auch wird `prederror:false' nicht übersetzt.

     Hat die Optionsvariable `savedef' den Wert `true', wird die
     Originalversion einer Funktion nicht entfernt.  Siehe `savedef'.
     Mit dem Wert `false' für `transrun' werden, wenn noch vorhanden,
     die Originalversionen der übersetzten Funktion ausgeführt.

     Das Ergebnis der Funktion `translate' ist eine Liste der Namen der
     übersetzten Funktionen.


 -- Funktion: translate_file (<maxima_filename>)
 -- Funktion: translate_file (<maxima_filename>, <lisp_filename>)
     Übersetzt eine Datei mit Maxima-Code in eine Datei mit Lisp-Code.
     `translate_file' gibt eine Liste mit drei Dateien zurück, die den
     Namen der Maxima-Datei, den Namen der Lisp-Datei und den Namen
     einer Datei mit Informationen zur Übersetzung enthält.
     `translate_file' wertet die Argumente aus.

     Die Kommandos `translate_file("foo.mac")' und `load("foo.LISP")'
     haben bis auf wenige Ausnahmen dieselbe Wirkung wie
     `batch("foo.mac")'.  Zum Beispiel funktionieren `''' und `%'
     unterschiedlich.

     `translate_file(<maxima_filename>)' übersetzt die Maxima-Datei
     <maxima_filename> in ein Lisp-Datei mit einem vergleichbaren
     Namen.  Zum Beispiel wird die Maxima-Datei `foo.mac' zu
     `foo.LISP'.  Der Name der Maxima-Datei kann Pfadangaben enthalten.
     In diesem Fall wird die Lisp-Datei in dasselbe Verzeichnis wie
     die Maxima-Datei geschrieben.

     `translate_file(<maxima_filename>, <lisp_filename>)' übersetzt die
     Maxima-Datei <maxima_filename> in eine Lisp-Datei mit dem Namen
     `lisp_filename'.  `translate_file' ignoriert eine angegebene
     Dateiendung des Dateinamenes `lisp_filename'.  Die Dateiendung ist
     immer `.LISP'.  Der Name der Lisp-Datei kann Pfadangaben
     enthalten, um die Lisp-Datei in das gewünschte Verzeichnis zu
     schreiben.

     `translate_file' schreibt eine Ausgabedatei mit Meldungen des
     Übersetzers.  Die Dateiendung der Ausgabedatei ist `.UNILISP'.  Die
     Informationen dieser Datei können für die Fehlersuche genutzt
     werden.  Die Datei wird immer in das Verzeichnis geschrieben, das
     die Maxima-Datei enthält.

     `translate_file' generiert Lisp-Code mit Deklarationen und
     Definitionen, die bereits beim Kompilieren des Codes wirksam
     werden.  Siehe `compile_file'  für mehr Informationen.

     Siehe auch die folgenden Optionsvariablen:

     `tr_array_as_ref',
     `tr_bound_function_applyp',
     `tr_exponent',
     `tr_file_tty_messagesp',
     `tr_float_can_branch_complex',
     `tr_function_call_default',
     `tr_numer',
     `tr_optimize_max_loop',
     `tr_semicompile',
     `tr_state_vars',
     `tr_warnings_get',
     `tr_warn_bad_function_calls',
     `tr_warn_fexpr',
     `tr_warn_meval',
     `tr_warn_mode',
     `tr_warn_undeclared',
     und `tr_warn_undefined_variable'.


 -- Optionsvariable: transrun
     Standardwert: `true'

     Hat `transrun' den Wert `false', werden die nicht-übersetzten
     Versionen ausgeführt, falls diese noch vorhanden sind.  Siehe
     `savedef'.


 -- Optionsvariable: tr_array_as_ref
     Standardwert: `true'

     Hat `translate_fast_arrays' den Wert `false', werden Referenzen auf
     Arrays in Lisp-Code von der Variablen `tr_array_as_ref'
     kontrolliert.  Hat `tr_array_as_ref' den Wert `true', werden
     Array-Namen ausgewertet.

     `tr_array_as_ref' hat keinen Effekt, wenn `translate_fast_arrays'
     den Wert `true' hat.


 -- Optionsvariable: tr_bound_function_applyp
     Standardwert: `true'

     Hat `tr_bound_function_applyp' den Wert `true', gibt Maxima eine
     Warnung aus, wenn versucht wird, eine gebundene Variable als eine
     Funktion verwendet werden soll.  `tr_bound_function_applyp' hat
     keinen Effekt auf den generierten Code.

     Zum Beispiel gibt ein Ausdruck der Form  `g (f, x) := f (x+1)' eine
     Warnung.


 -- Optionsvariable: tr_file_tty_messagesp
     Standardwert: `false'

     Hat `tr_file_tty_messagesp' den Wert `true', werden Meldungen die
     von der Funktion `translate_file' während einer Übersetzung
     generiert werden auch auf der Konsole ausgegeben.  Ansonsten
     werden Meldungen nur in die Datei `.UNILISP' geschrieben.


 -- Optionsvariable: tr_float_can_branch_complex
     Standardwert: `true'

     Erklärt dem Übersetzer, dass die Funktionen `acos', `asin', `asec'
     und `acsc' komplexe Werte zurückgegeben können.


 -- Optionsvariable: tr_function_call_default
     Standardwert: `general'

     `false' bedeutet, gebe auf und rufe `meval' auf, `expr' bedeutet,
     nehme Lisp-Argumente an.  `general', der Standardwert, gibt Code
     der für `MEXPRS'-Funktionen geeignet ist.  Wird Maxima-Code mit
     dem Standardwert `general' übersetzt, ohne dass Warnmeldungen
     ausgegeben werden, kann davon ausgegangen werden, dass der
     übersetzte und komplilierte Code kompatibel mit der ursprünglichen
     Funktion ist.


 -- Optionsvariable: tr_numer
     Standardwert: `false'

     Hat `tr_numer' den Wert `true', wird die `numer'-Eigenschaft von
     Symbolen vom Übersetzer angewendet.


 -- Optionsvariable: tr_optimize_max_loop
     Standardwert: 100

     `tr_optimize_max_loop' enthält die maximale Anzahl an Durchgängen,
     um Makros zu expandieren und den Code zu optimieren.  Damit werden
     unendliche Schleifen des Übersetzers vermieden.


 -- Optionsvariable: tr_semicompile
     Standardwert: `false'

     Hat `tr_semicompile' den Wert `true', geben die Funktionen
     `translate_file' und `compfile' Code aus, in dem Makrofunktionen
     expandiert sind, der aber nicht kompliliert ist.


 -- Systemvariable: tr_state_vars
     Standardwert:
     [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
     tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
     tr_function_call_default, tr_array_as_ref,tr_numer]

     Enthält eine Liste der Schalter, die die Übersetzung kontrollieren.


 -- Funktion: tr_warnings_get ()
     Gebe die Liste der Warnungen aus, welche bei der letzten
     Übersetzung erzeugt wurden.


 -- Optionsvariable: tr_warn_bad_function_calls
     Standardwert: `true'

     Gebe Warnungen aus, wenn Funktionsaufrufe generiert werden, die
     möglicherweise nicht korrekt sind, aufgrund von ungeeigneten
     Deklarationen für die Übersetzung.


 -- Optionsvariable: tr_warn_fexpr
     Standardwert: `compfile'

     Gebe Warnungen aus, wenn `FEXPR'-Ausdrücke im übersetzten Code
     auftreten.


 -- Optionsvariable: tr_warn_meval
     Standardwert: `compfile'

     Gebe Warnungen aus, wenn die Funktion `meval' aufgerufen wird.
     Dies signalisiert Probleme bei der Übersetzung.


 -- Optionsvariable: tr_warn_mode
     Standardwert: `all'

     Gebe Warnungen aus, wenn Variablen Werte zugewiesen werden, die
     nicht zu dem deklarierten Typ passen.


 -- Optionsvariable: tr_warn_undeclared
     Standardwert: `compile'

     Kontrolliert, wann Warnungen über nicht-deklarierte Variablen
     angezeigt werden sollen.


 -- Optionsvariable: tr_warn_undefined_variable
     Standardwert: `all'

     Gebe eine Warnung aus, wenn undefinierte globale Variablen
     auftreten.



File: maxima.info,  Node: Fehlersuche,  Next: Verschiedenes,  Prev: Übersetzer,  Up: Top

29 Fehlersuche
**************

* Menu:

* Quellcode-Debugger::
* Debugger-Kommandos::
* Funktionen und Variablen der Fehlersuche::


File: maxima.info,  Node: Quellcode-Debugger,  Next: Debugger-Kommandos,  Up: Fehlersuche

29.1 Quellcode-Debugger
=======================

Maxima hat einen Quellcode-Debugger.  Es können Unterbrechungspunkte
gesetzt werden, um die Ausführung einer Funktion abzubrechen und um
schrittweise die Funktion zu testen.  Der Stapelspeicher und Variable
können untersucht werden.

Das Kommando `:help' oder `:h' zeigt eine Liste mit den
Debugger-Kommandos.  Innerhalb des Debuggers können alle
Maxima-Funktionen genutzt werden, um Variablen und Ausdrücke
auszugeben, zu definieren oder anderweitig zu manipulieren.

Eine Unterbrechnung wird mit dem Kommando `:br' gesetzt.  Mit dem
Kommando `:n' oder `:next' wird die nächste Programmzeile ausgeführt.
Das Kommando `:bt' oder `:backtrace' zeigt eine Liste der Stack Frames.
Mit dem Kommando `:r' oder `:resume' wird der Debugger verlassen.

Beispiele:

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt typed here gives a backtrace
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investigate value of u
     28

     (dbm:1) u: 33;                     <-- Change u to be 33
     33

     (dbm:1) :r                         <-- Type :r to resume the computation

     (%o2)                                1094

Die im obigen Beispiel geladene Datei `/tmp/foobar.mac' hat den
folgenden Inhalt:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

Nutzung des Debuggers mit Emacs
-------------------------------

Wird Maxima unter GNU Emacs in einer Shell ausgeführt oder wird die
Nutzeroberfläche Xmaxima verwendet, dann wird in einem zweiten
Ausgabefenster die Position einer Unterbrechung im Quellcode angezeigt.
Mit dem Emacs-Kommando `M-n' kann dann schrittweise die Funktion
ausgeführt werden.

Um diese Funktionalität zu nutzen, sollte Emacs in einer `dbl'-Shell
ausgeführt werden.  Dazu benötigt Emacs die Datei `dbl.el' im elisp
Verzeichnis.  Dazu müssen die elisp-Dateien installiert oder das Maxima
elisp Verzeichnis bekannt sein.  Dazu können die folgenden Kommandos der
Datei `.emacs' hinzugefügt werden:

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

Mit dem Emacs-Kommando `M-x dbl' wird eine Shell gestartet, in der
Programme wie Maxima, gcl, gdb u. a. ausgeführt werden können.  In
dieser Shell kann auch der Maxima-Debugger ausgeführt werden.

The user may set a break point at a certain line of the file by typing
`C-x space'.  This figures out which function the cursor is in, and then
it sees which line of that function the cursor is on.   If the cursor
is on,  say, line 2 of `foo', then it will insert in the other window
the  command, "`:br foo 2'", to break `foo' at its second line.  To
have this enabled, the user must have maxima-mode.el turned on in the
window  in which the file `foobar.mac' is visiting.  There are
additional  commands available in that file window, such as evaluating
the function into  the Maxima, by typing `Alt-Control-x'.


File: maxima.info,  Node: Debugger-Kommandos,  Next: Funktionen und Variablen der Fehlersuche,  Prev: Quellcode-Debugger,  Up: Fehlersuche

29.2 Debugger-Kommandos
=======================

Es gibt spezielle Kommandos, die von Maxima nicht als ein Ausdruck
interpretiert werden.  Diese Kommandos beginnen mit einem Doppelpunkt
`:' und können in der Kommandozeile oder nach einer Unterbrechung
ausgeführt werden.  Mit dem Kommando `:lisp' werden zum Beispiel
Lisp-Zeilen ausgewertet:

     (%i1) :lisp (+ 2 3)
     5

Die Anzahl der Argumente hängt vom jeweiligen Kommando ab.  Die
Kommandos können mit den ersten zwei Buchstaben abgekürzt werden.  Zum
Beispiel genügt es `:br' für das Kommando `:break' einzugeben.

Die speziellen Kommandos sind folgende:

`:break F n'
     Setzte einen Unterbrechnungspunkt in der Funktion `F' in der Zeile
     `n' vom Anfang der Funktion.  Wird `F' als eine Zeichenkette
     angegeben, dann wird `F' als der Name einer Datei angenommen.  `n'
     ist in diesem Fall die `n'-te Zeile in der Datei.  Wird `n' nicht
     angegeben, wird der Wert zu Null angenommen.

`:bt'
     Gebe einen Backtrace des Stack Frames aus.

`:continue'
     Setze die Ausführung der Funktion fort.

`:delete'
     Lösche den spezifizierten Unterbrechnungspunkt oder alle, wenn
     keiner spezifiziert wird.

`:disable'
     Schalte den spezifierten oder alle Unterbrechnungspunkte ab.

`:enable'
     Schalte den spezifizierten oder alle Unterbrechnungspunkte ein.

`:frame n'
     Gebe den Stack Frame `n' oder den aktuellen aus, wenn keiner
     spezifiert wird.

`:help'
     Gebe einen Hilfetext zu einem spezifierten Kommando oder zu allen
     Kommandos aus, wenn kein Kommando spezifierten wird.

`:info'
     Gebe Information über einen Eintrag aus.

`:lisp some-form'
     Werte `some-form' als eine Lisp-Form aus.

`:lisp-quiet some-form'
     Werte `some-form' als eine Lisp-Form aus, ohne eine Ausgabe zu
     erzeugen.

`:next'
     Wie `:step', führt aber Funktionsaufrufe als einen Schritt aus.

`:quit'
     Beende den Debugger.

`:resume'
     Setzte die Ausführung des Programms fort.

`:step'
     Setzte die Auswertung des Programms bis zur nächsten Zeile fort.

`:top'
     Beende die Auswertung und kehre zur Maxima-Eingabe zurück.



File: maxima.info,  Node: Funktionen und Variablen der Fehlersuche,  Prev: Debugger-Kommandos,  Up: Fehlersuche

29.3 Funktionen und Variablen der Fehlersuche
=============================================

 -- Optionsvariable: debugmode
     Standardwert: `false'

     Hat die Optionsvariable `debugmode' den Wert `true', wird der
     Maxima-Debugger gestartet, wenn ein Programmfehler auftritt.  Nach
     der Unterbrechung des Programms kann der Debugger genutzt werden.
     Siehe das Kapitel Debugger-Kommandos  für eine Liste der Kommandos
     des Debuggers.

     Der Maxima-Debugger behandelt keine Lisp-Programmfehler.


 -- Optionsvariable: refcheck
     Standardwert: `false'

     Hat `refcheck' den Wert `true', gibt Maxima eine Meldung aus, wenn
     einer Variablen zum ersten Mal ein Wert zugewiesen wird.


 -- Optionsvariable: setcheck
     Standardwert: `false'

     Der Optionsvariablen `setcheck' kann eine Liste mit den Namen von
     Variablen zugewiesen werden.  Dies können auch indizierte
     Variablen sein.  Immer wenn einer der Variablen mit den Operatoren
     `:' oder `::' ein Wert zugewiesen wird, gibt Maxima eine Meldung
     aus, die den Namen der Variablen und den zugewiesenen Wert enthält.

     `setcheck' kann den Wert `all' oder `true' erhalten.  In diesem
     Fall wird für alle Variablen eine Meldung ausgegeben.

     Jede Zuweisung an `setcheck' initialisert eine neue Liste mit
     Variablen.  Vorherige Zuweisungen werden überschrieben.

     Die Auswertung der Namen der Variablen muss mit dem Quote-Operator
     `'' unterdrückt werden, wenn den Variablen bereits Werte
     zugewiesen wurden.  Haben zum Beispiel die Variablen `x', `y' und
     `z' Werte, dann werden die Variablen mit dem folgenden Befehl
     angegeben:

          setcheck: ['x, 'y, 'z]$

     Es wird keine Meldung ausgegeben, wenn eine Variable sich selbst
     zugewiesen wird, zum Beispiel `X: 'X'.


 -- Optionsvariable: setcheckbreak
     Standardwert: `false'

     Hat `setcheckbreak' den Wert `true', startet Maxima den Debugger,
     wenn einer Variablen, die in der Liste `setcheck' enthalten ist,
     ein Wert zugewiesen wird.  Die Unterbrechung wird noch vor der
     Zuweisung des Wertes ausgeführt.  Die Variable `setval' enhält den
     Wert, der zugewiesen werden soll.  Dieser Variablen kann ein
     anderer Wert zugewiesen werden.

     Siehe auch `setcheck'  und `setval'.


 -- Systemvariable: setval
     Enthält den Wert, der einer Variable zugewiesen werden soll, wenn
     die Zuweisung mit der Optionsvariablen `setcheckbreak'
     unterbrochen wurde.  `setval' kann ein anderer Wert zugewiesen
     werden.

     Siehe auch `setcheck'  und `setcheckbreak'.


 -- Funktion: timer (<f_1>, ..., <f_n>)
 -- Funktion: timer (all)
 -- Funktion: timer ()
     Sammelt Statistiken über die Ausführungszeiten von Funktionen.  Die
     Argumente <f_1>, ..., <f_n> sind die Namen von Funktionen zu denen
     Statistiken gesammelt werden.  `time(g)' fügt die Funktion `g' der
     Liste an Funktionen hinzu, zu denen Informationen gesammelt werden.

     `timer(all)' fügt alle nutzerdefinierten Funktionen, die in der
     Informationsliste `functions' enthalten sind, der Liste der
     Funktionen hinzu, über die Informationen gesammelt werden.

     Wird `timer()' ohne Argumente aufgerufen, wird eine Liste der
     Funktionen zurückgeben, über die Informationen gesammelt werden.

     Maxima misst die Zeit, die eine Funktion für die Ausführung
     benötigt.  `timer_info' gibt eine Statistik für alle Funktionen
     zurück, für die die Ausführungszeiten gemessen werden.  Die
     Statistik enthält die durchschnittliche Ausführungszeit der
     Funktionen und die Anzahl der Aufrufe der Funktionen.  Mit der
     Funktion `untimer' wird die Aufzeichnung der Ausführungszeiten
     beendet.

     `timer' wertet die Argumente nicht aus.  Daher werden im Folgenden
     `f(x) := x^2$ g:f$ timer(g)$' für die Funktion `f' keine
     Ausführungszeiten aufgezeichnet.

     Wird für die Funktion `f' mit dem Kommando `trace(f)' der Ablauf
     verfolgt, hat das Kommando `timer(f)' keinen Effekt.  Für eine
     Funktion können nicht gleichzeitig Ausführungszeiten aufgezeichnet
     und der Ablauf verfolgt werden.

     Siehe auch `timer_devalue'.


 -- Funktion: untimer (<f_1>, ..., <f_n>)
 -- Funktion: untimer ()
     `untimer' beendet die Aufzeichnung von Informationen zur
     Ausführungszeit für die Funktionen <f_1>, ..., <f_n>.

     Wird `untimer' ohne Argument aufgerufen, wird die Aufzeichnung für
     alle Funktionen beendet.

     Die aufgezeichneten Informationen zu einer Funktion `f' können mit
     dem Kommando `timer_info(f)' auch dann abgerufen werden, wenn
     zuvor mit dem Kommando `untimer(f)' die Aufzeichnung für die
     Funktion `f' beendet wurde.  Jedoch werden die aufgezeichneten
     Informationen für die Funktion `f' nicht mit dem Kommando
     `timer_info()' angezeigt.  Das Kommando `timer(f)' setzt alle
     aufgezeichneten zurück und startet die Aufzeichnung für die
     Funktion erneut.


 -- Optionsvariable: timer_devalue
     Standardwert: `false'

     Hat `timer_devalue' den Wert `true', subtrahiert Maxima bei der
     Aufzeichnung der Ausführungszeiten die Zeiten, welche eine
     Funktion in anderen Funktionen verbringt.  Ansonsten enthalten die
     aufgezeichneten Zeiten auch die Ausführungszeiten der Funktionen,
     die aufgerufen werden.

     Siehe auch `timer'  und `timer_info'.


 -- Funktion: timer_info (<f_1>, ..., <f_n>)
 -- Funktion: timer_info ()
     Gibt eine Tabelle mit den aufgezeichneten Informationen über die
     Ausführungszeiten der Funktionen <f_1>, ..., <f_n> zurück.  Wird
     kein Argument angegeben, werden Informationen für alle Funktionen
     angezeigt, zu denen Informationen aufgezeichnet sind.

     Die Tabelle enthält die Namen der Funktionen, die Ausführungszeit
     pro Aufruf, die Anzahl der Aufrufe, die gesamte Zeit und die
     `gctime'-Zeit.  Die `gctime'-Zeit bedeutet "Garbage Collection
     Time".

     Die Daten, die von der Funktion `timer_info' angezeigt werden,
     können auch mit der Funktion `get' erhalten werden:

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Siehe auch `timer'.


 -- Funktion: trace (<f_1>, ..., <f_n>)
 -- Funktion: trace (all)
 -- Funktion: trace ()
     Startet die Ablaufverfolgung für die Funktionen <f_1>, ..., <f_n>.
     Mit dem Kommando `trace(g)' kann eine weitere Funktion hinzugefügt
     werden.

     `trace(all)' startet die Ablaufverfolgung für alle
     nutzerdefinierten Funktionen, die in der Informationsliste
     `functions' enthalten sind.

     Das Kommando `trace()' zeigt eine Liste aller Funktionen für die
     eine Ablaufverfolgung gestartet wurde.

     Mit der Funktion `untrace' wird die Ablaufverfolgung beendet.
     Siehe auch `trace_options'.

     `trace' wertet die Argumente nicht aus.

     Die Ablaufverfolgung kann für eine Funktion `f' nicht gestartet
     werden, wenn für die Funktion bereits mit der Funktion `timer'
     Informationen über die Ausführungszeiten gesammelt werden.


 -- Funktion: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Funktion: trace_options (<f>)
     Setzt Optionen für die Ablaufverfolgung einer Funktion <f>.
     Bereits vorliegende Optionen werden ersetzt.

     `trace_options(<f>)' setzt alle Optionen auf die Standardwerte
     zurück.

     Die Optionen sind:

    `noprint'
          Gebe keine Meldung beim Eintritt in eine oder dem Austritt
          aus einer Funktion aus.

    `break'
          Setze eine Unterbrechnung vor dem Eintritt in eine Funktion
          und nach dem Austritt aus einer Funktion.  Siehe `break'.

    ``lisp_print''
          Zeige die Argumente und Rückgabewerte in der Lisp-Syntax an.

    `info'
          Gebe `-> true' beim Eintritt in und Austritt aus einer
          Funktion aus.

    ``errorcatch''
          Catch errors, giving the option to signal an error,  retry
          the function call, or specify a return value.


     Es können bedingte Optionen für die Ablaufverfolgung definiert
     werden.  Dazu wird eine Option zusammen mit einer Aussagefunktion
     angegeben.  Die Argumente der Aussagefunktion für eine bedingte
     Option sind immer `[level, direction, function, item]'.  `level'
     ist die Rekursionstiefe der Funktion, `direction' enthält die
     Werte `enter' oder `exit', `function' ist der Name der Funktion
     und `item' ist eine Liste der Argumente oder der Rückgabewert beim
     Verlassen der Funktion.

     Dies ist ein Beispiel für eine Ablaufverfolgung ohne Bedingungen:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     In diesem Fall wird eine Aussagefunktion für eine bedingte
     Ablaufverfolgung angegeben:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Funktion: untrace (<f_1>, ..., <f_n>)
 -- Funktion: untrace ()
     Beendet die Ablaufverfolgung für die Funktionen <f_1>, ..., <f_n>.
     Das Kommando `untrace()' beendet die Ablaufverfolgung für alle
     Funktionen.

     `untrace' gibt eine Liste der Funktionen zurück, für die die
     Ablaufverfolgung beendet wurde.



File: maxima.info,  Node: Verschiedenes,  Next: abs_integrate,  Prev: Fehlersuche,  Up: Top

30 Verschiedenes
****************

* Menu:

* Einführung in Verschiedenes::
* Share-Pakete::
* Funktionen und Variablen für Verschiedenes::


File: maxima.info,  Node: Einführung in Verschiedenes,  Next: Share-Pakete,  Prev: Verschiedenes,  Up: Verschiedenes

30.1 Einführung in Verschiedenes
================================

Dieses Kapitel enthält verschiedene Funktionen und Optionsvariablen.


File: maxima.info,  Node: Share-Pakete,  Next: Funktionen und Variablen für Verschiedenes,  Prev: Einführung in Verschiedenes,  Up: Verschiedenes

30.2 Share-Pakete
=================

Das Maxima Share-Verzeichnis enthält viele weitere zusätzliche
Funktionen und Erweiterungen, die nicht Teil des Kernels von Maxima und
in Paketen organisiert sind.  Diese Pakete werden mit der Funktion
`load' geladen.  Einige Pakete werden automatisch geladen, wenn der
Nutzer eine Funktion des Paketes aufruft.  Mit der Funktion
`setup_autoload' können Funktionen für das automatische Laden
konfiguriert werden.

Die Lisp-Variable `*maxima-sharedir*' enthält das Verzeichnis der
Pakete.  Das Kommanod `printfile("share.usg")' gibt eine Übersicht über
Pakete aus.  Diese ist jedoch derzeit stark veraltert.


File: maxima.info,  Node: Funktionen und Variablen für Verschiedenes,  Prev: Share-Pakete,  Up: Verschiedenes

30.3 Funktionen und Variablen für Verschiedenes
===============================================

 -- Systemvariable: askexp
     Wenn `asksign' aufgerufen wird, enthält `askexp' den Ausdruck, der
     von `asksign' getestet wird.

     Es war einmal möglich, die Variable `askexp' nach einer
     Unterbrechnung mit Control-A zu inspezieren.

 -- Funktion: remvalue (<name_1>, ..., <name_n>)
 -- Funktion: remvalue (all)
     Entfernt die Werte von nutzerdefinierten Variablen <name_1>, ...,
     <name_n>.  Die Variablen können indiziert sein.  `remvalue(all)'
     entfernt die Werte aller Variablen, die in der Informationsliste
     `values' enthalten sind.

     Siehe auch `values'.


 -- Funktion: rncombine (<expr>)
     Transformiert den Ausdruck <expr> so, dass alle Terme mit
     identischem Nenner oder Nennern, die sich nur um einen numerischen
     Faktor voneinander unterscheiden, über einen Nenner
     zusammengefasst werden. Die Funktion `combine' fasst ebenfalls
     Ausdrücke über einen Nenner zusammen, betrachtet aber Nenner als
     verschieden, die sich um einen Zahlenfaktor voneinander
     unterscheiden.

     Die Funktion wird mit dem Kommando `rncomb' geladen.

 -- Funktion: setup_autoload (<filename>, <function_1>, ...,
          <function_n>)
     Die Funktionen <function_1>, ..., <function_n> erhalten die
     Eigenschaft, dass die Datei <filename> automatisch geladen wird,
     wenn die Funktion zum ersten Mal genutzt werden soll.  <filename>
     wird mit der Funktion `load' geladen und enthält üblicherweise den
     Code für die Definition der zu ladenden Funktion.

     `setup_autoload' funktioniert nicht für Array-Funktionen.
     `setup_autoload' wertet die Argumente nicht aus.

     Beispiele:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


File: maxima.info,  Node: abs_integrate,  Next: affine,  Prev: Verschiedenes,  Up: Top

31 abs_integrate
****************

* Menu:

* Introduction to abs_integrate::
* Functions and Variables for abs_integrate::


File: maxima.info,  Node: Introduction to abs_integrate,  Next: Functions and Variables for abs_integrate,  Prev: abs_integrate,  Up: abs_integrate

31.1 Introduction to abs_integrate
==================================

The package `abs_integrate' extends Maxima's integration code to some
integrands that involve the absolute value, max, min, signum, or unit
step functions.  For integrands of the form p(x) |q(x)|, where p is a
polynomial and q is a polynomial that `factor' is able to factor into a
product of linear or constant terms, the `abs_integrate' package
determines an antiderivative that is continuous on the entire real
line.  Additionally, for an integrand that involves one or more
parameters, the function `conditional_integrate'  tries to determine an
antiderivative that is valid for all parameter values.

Examples:

To use the `abs_integrate' package, you'll first need to load it:

     (%i1) load("abs_integrate.mac")$
     (%i2) integrate(abs(x),x);
                                 x abs(x)
     (%o2)                       --------
                                    2

To convert (%o2) into an expression involving the absolute value
function, apply `signum_to_abs' ; thus

     (%i3) signum_to_abs(%);
                                 x abs(x)
     (%o3)                       --------
                                    2

When the integrand has the form p(x) |x - c1| |x - c2| ... |x - cn|,
where p(x) is a polynomial and c1, c2, ..., cn are constants, the
`abs_integrate' package returns an antiderivative that is valid on the
entire real line; thus without making assumptions on a and b; for
example

     (%i4) factor(convert_to_signum(integrate(abs((x-a)*(x-b)),x,a,b)));
                                 3       2
                          (b - a)  signum (b - a)
     (%o4)                -----------------------
                                     6

Additionally, `abs_integrate' is able to find antiderivatives of some
integrands involving `max',  `min',  `signum',  and `unit_step',
examples:

     (%i5) integrate(max(x,x^2),x);
                3      2                                        3    2
             2 x  - 3 x    1                   1               x    x
     (%o5) ((----------- + --) signum(x - 1) + --) signum(x) + -- + --
                 12        12                  12              6    4
     (%i6) integrate(signum(x) - signum(1-x),x);
     (%o6)                  abs(x) + abs(x - 1)

A plot indicates that indeed (%o5) and (%o6) are continuous at zero and
at one.

For definite integrals with numerical integration limits (including
both minus and plus infinity), the `abs_integrate' package converts the
integrand to signum form and then it tries to subdivide the integration
region so that the integrand simplifies to a non-signum expression on
each subinterval; for example

     (%i1) load(abs_integrate)$
     (%i2) integrate(1 / (1 + abs(x-5)),x,-5,6);
     (%o2)                   log(11) + log(2)

Finally, `abs_integrate' is able to determine antiderivatives of _some_
functions of the form F(x, |x - a|); examples

     (%i3) integrate(1/(1 + abs(x)),x);
           signum(x) (log(x + 1) + log(1 - x))
     (%o3) -----------------------------------
                            2
                                               log(x + 1) - log(1 - x)
                                             + -----------------------
                                                          2
     (%i4) integrate(cos(x + abs(x)),x);
              (signum(x) + 1) sin(2 x) - 2 x signum(x) + 2 x
     (%o4)    ----------------------------------------------
                                    4

Barton Willis (Professor of Mathematics, University of Nebraska at
Kearney) wrote the `abs_integrate' package and its English language
user documentation.  This documentation also describes the `partition'
package for integration.  Richard Fateman wrote `partition'.
Additional documentation for `partition' is located at
`http://www.cs.berkeley.edu/~fateman/papers/partition.pdf'


File: maxima.info,  Node: Functions and Variables for abs_integrate,  Prev: Introduction to abs_integrate,  Up: abs_integrate

31.2 Functions and Variables for abs_integrate
==============================================

 -- Option variable: extra_integration_methods
     Default value: `['signum_int, 'abs_integrate_use_if]'

     The list `extra_integration_methods' is a list of functions for
     integration.  When `integrate'  is unable to find an
     antiderivative, Maxima uses the methods in
     `extra_integration_methods' to attempt to determine an
     antiderivative.

     Each function `f' in `extra_integration_methods' should have the
     form `f(integrand, variable)'.  The function `f' may either return
     `false' to indicate failure, or it may return an expression
     involving an integration noun form.  The integration methods are
     tried from the first to the last member of
     `extra_integration_methods'; when no method returns an expression
     that does not involve an integration noun form, the value of the
     integral is the last value that does not fail (or a pure noun form
     if all methods fail).

     When the function `abs_integrate_use_if' is successful, it returns
     a conditional expression; for example

          (%i1) load(abs_integrate)$
          (%i2) integrate(1/(1 + abs(x+1) + abs(x-1)),x);
                                     log(1 - 2 x)            2
          (%o2) %if(- (x + 1) > 0, - ------------ + log(3) - -,
                                          2                  3
                                             x   log(3)   1  log(2 x + 1)
                          %if(- (x - 1) > 0, - + ------ - -, ------------))
                                             3     2      3       2
          (%i3) integrate(exp(-abs(x-1) - abs(x)),x);
                               2 x - 1
                             %e              - 1
          (%o3) %if(- x > 0, --------- - 2 %e   ,
                                 2
                                                         - 1      1 - 2 x
                                             - 1     3 %e       %e
                        %if(- (x - 1) > 0, %e    x - -------, - ---------))
                                                        2           2

     For definite integration, these conditional expressions can cause
     trouble:

          (%i4) integrate(exp(-abs(x-1) - abs(x)),x, minf,inf);
                                         - 1    2 x
                                       %e    (%e    - 4)
          (%o4) limit     %if(- x > 0, -----------------,
                x -> inf-                      2
                               - 1                1 - 2 x
                             %e    (2 x - 3)    %e
          %if(- (x - 1) > 0, ---------------, - ---------))
                                    2               2
                                       - 1    2 x
                                     %e    (%e    - 4)
           - limit      %if(- x > 0, -----------------,
             x -> minf+                      2
                               - 1                1 - 2 x
                             %e    (2 x - 3)    %e
          %if(- (x - 1) > 0, ---------------, - ---------))
                                    2               2

     For such definite integrals, try disallowing the method
     `abs_integrate_use_if':

          (%i5) integrate(exp(-abs(x-1) - abs(x)),x, minf,inf),
                    extra_integration_methods : ['signum_int];
                                           - 1
          (%o5)                        2 %e

     Related options `extra_definite_integration_methods'.

     To use `load(abs_integrate)'

 -- Option variable: extra_definite_integration_methods
     Default value: `['abs_defint]'

     The list `extra_definite_integration_methods' is a list of extra
     functions for definite integration.  When `integrate'  is unable
     to find a definite integral, Maxima uses the methods in
     `extra_definite_integration_methods' to attempt to determine an
     antiderivative.

     Each function `f' in `extra_definite_integration_methods' should
     have the form `f(integrand, variable, lo, hi)', where `lo' and
     `hi' are the lower and upper limits of integration, respectively.
     The function `f' may either return `false' to indicate failure, or
     it may return an expression involving an integration noun form.
     The integration methods are tried from the first to the last
     member of `extra_definite_integration_methods'; when no method
     returns an expression that does not involve an integration noun
     form, the value of the integral is the last value that does not
     fail (or a pure noun form if all methods fail).

     Related options `extra_integration_methods'.

     To use `load(abs_integrate)'.

 -- Function: intfudu (<e>, <x>)
     This function uses the derivative divides rule for integrands of
     the form f(w(x)) * diff(w(x),x).  When `infudu' is unable to find
     an antiderivative, it returns false.

          (%i1) load(abs_integrate)$
          (%i2) intfudu(cos(x^2) * x,x);
                                            2
                                       sin(x )
          (%o2)                        -------
                                          2
          (%i3) intfudu(x * sqrt(1+x^2),x);
                                       2     3/2
                                     (x  + 1)
          (%o3)                      -----------
                                          3
          (%i4) intfudu(x * sqrt(1 + x^4),x);
          (%o4)                         false

     For the last example, the derivative divides rule fails, so
     `intfudu' returns false.

     A hashed array `intable' contains the antiderivative data.  To
     append a fact to the hash table, say integrate(f) = g, do this:

          (%i5) intable[f] : lambda([u],  [g(u),diff(u,%voi)]);
          (%o5)          lambda([u], [g(u), diff(u, %voi)])
          (%i6) intfudu(f(z),z);
          (%o6)                         g(z)
          (%i7) intfudu(f(w(x)) * diff(w(x),x),x);
          (%o7)                        g(w(x))

     An alternative to calling `intfudu' directly is to use the
     `extra_integration_methods'  mechanism; an example:

          (%i1) load(abs_integrate)$
          (%i2) load(basic)$
          (%i3) load("partition.mac")$

          (%i4) integrate(bessel_j(1,x^2) * x,x);
                                                 2
                                    bessel_j(0, x )
          (%o4)                   - ---------------
                                           2
          (%i5) push('intfudu, extra_integration_methods)$

          (%i6) integrate(bessel_j(1,x^2) * x,x);
                                                 2
                                    bessel_j(0, x )
          (%o6)                   - ---------------
                                           2

     To use `load(partition)'.

     Additional documentation
     `http://www.cs.berkeley.edu/~fateman/papers/partition.pdf'.

     Related functions `intfugudu'.


 -- Function: intfugudu (<e>, <x>)
     This function uses the derivative divides rule for integrands of
     the form f(w(x)) * g(w(x)) * diff(w(x),x).  When `infugudu' is
     unable to find an antiderivative, it returns false.

          (%i1) load(abs_integrate)$
          (%i2) diff(jacobi_sn(x,2/3),x);
                                        2               2
          (%o2)            jacobi_cn(x, -) jacobi_dn(x, -)
                                        3               3
          (%i3) intfugudu(%,x);
                                                2
          (%o3)                    jacobi_sn(x, -)
                                                3
          (%i4) diff(jacobi_dn(x^2,a),x);
                                         2                2
          (%o4)       - 2 a x jacobi_cn(x , a) jacobi_sn(x , a)
          (%i5) intfugudu(%,x);
                                             2
          (%o5)                   jacobi_dn(x , a)

     For a method for automatically calling `infugudu' from `integrate',
     see the documentation for `intfudu'.

     To use `load(partition)'.

     Additional documentation
     `http://www.cs.berkeley.edu/~fateman/papers/partition.pdf'

     Related functions `intfudu'.


 -- Function: signum_to_abs (<e>)
     This function replaces subexpressions of the form q signum(q) by
     abs(q).  Before it does these substitutions, it replaces
     subexpressions of the form signum(p) * signum(q) by signum(p * q);
     examples:

          (%i1) load(abs_integrate)$
          (%i2) map('signum_to_abs, [x * signum(x),
                                     x * y * signum(x)* signum(y)/2]);
                                        abs(x) abs(y)
          (%o2)                [abs(x), -------------]
                                              2

     To use `load(abs_integrate)'.

 -- Macro: simp_assuming (<e>, <f_1>, <f_2>, ..., <f_n>)
     Appended the facts f_1, f_2, ..., f_n to the current context and
     simplify e.  The facts are removed before returning the simplified
     expression e.

          (%i1) load(abs_integrate)$
          (%i2) simp_assuming(x + abs(x), x < 0);
          (%o2)                           0

     The facts in the current context aren't ignored:

          (%i3) assume(x > 0)$
          (%i4) simp_assuming(x + abs(x),x < 0);
          (%o4)                          2 x

     Since `simp_assuming' is a macro, effectively `simp_assuming'
     quotes is arguments; this allows

          (%i5) simp_assuming(asksign(p), p < 0);
          (%o5)                          neg

     To use `load(abs_integrate)'.

 -- Function: conditional_integrate (<e>, <x>)
     For an integrand with one or more parameters, this function tries
     to determine an antiderivative that is valid for all parameter
     values.  When successful, this function returns a conditional
     expression for the antiderivative.

          (%i1) load(abs_integrate)$
          (%i2) conditional_integrate(cos(m*x),x);
                                          sin(m x)
          (%o2)                %if(m # 0, --------, x)
                                             m
          (%i3) conditional_integrate(cos(m*x)*cos(x),x);

          (%o3) %if((m - 1 # 0) %and (m + 1 # 0),
          (m - 1) sin((m + 1) x) + (- m - 1) sin((1 - m) x)
          -------------------------------------------------,
                                 2
                              2 m  - 2
          sin(2 x) + 2 x
          --------------)
                4
          (%i4) sublis([m=6],%);
                               5 sin(7 x) + 7 sin(5 x)
          (%o4)                -----------------------
                                         70
          (%i5) conditional_integrate(exp(a*x^2+b*x),x);
                                            2
                                           b
                                         - ---
                                           4 a      2 a x + b
                             sqrt(%pi) %e      erf(-----------)
                                                   2 sqrt(- a)
          (%o5) %if(a # 0, - ----------------------------------,
                                        2 sqrt(- a)
                                                                   b x
                                                                 %e
                                                      %if(b # 0, -----, x))
                                                                   b

 -- Function: convert_to_signum (<e>)
     This function replaces subexpressions of the form `abs(q),
     unit_step(q), min(q1, q2, ..., qn)' and `max(q1, q2, ..., qn)' by
     equivalent signum terms.

          (%i1) load(abs_integrate)$
          (%i2) map('convert_to_signum, [abs(x), unit_step(x),
                                         max(a,2), min(a,2)]);

                              signum(x) (signum(x) + 1)
          (%o2) [x signum(x), -------------------------,
                                          2
            (a - 2) signum(a - 2) + a + 2  - (a - 2) signum(a - 2) + a + 2
            -----------------------------, -------------------------------]
                          2                               2

     To convert `unit_step'  to signum form, the function
     `convert_to_signum' uses unit_step(x) = (1 + signum(x))/2.

     To use `load(abs_integrate)'.

     Related functions `signum_to_abs'.



File: maxima.info,  Node: affine,  Next: asympa,  Prev: abs_integrate,  Up: Top

32 affine
*********

* Menu:

* Introduction to Affine::
* Functions and Variables for Affine::


File: maxima.info,  Node: Introduction to Affine,  Next: Functions and Variables for Affine,  Prev: affine,  Up: affine

32.1 Introduction to Affine
===========================

`affine' is a package to work with groups of polynomials.


File: maxima.info,  Node: Functions and Variables for Affine,  Prev: Introduction to Affine,  Up: affine

32.2 Functions and Variables for Affine
=======================================

 -- Function: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Solves the simultaneous linear equations <expr_1>, ..., <expr_m>
     for the variables <x_1>, ..., <x_n>.  Each <expr_i> may be an
     equation or a general expression; if given as a general
     expression, it is treated as an equation of the form `<expr_i> =
     0'.

     The return value is a list of equations of the form `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' where <a_1>, ..., <a_n> are all free
     of <x_1>, ..., <x_n>.

     `fast_linsolve' is faster than `linsolve'  for system of equations
     which are sparse.

     `load(affine)' loads this function.

 -- Function: grobner_basis ([<expr_1>, ..., <expr_m>])
     Returns a Groebner basis for the equations <expr_1>, ..., <expr_m>.
     The function `polysimp' can then be used to simplify other
     functions relative to the equations.

     `polysimp(f)' yields 0 if and only if <f> is in the ideal
     generated by <expr_1>, ..., <expr_m>, that is, if and only if <f>
     is a polynomial combination of the elements of <expr_1>, ...,
     <expr_m>.

     `load(affine)' loads this function.

     Beispiel:

          (%i1) load(affine)$

          (%i2) grobner_basis ([3*x^2+1, y*x]);
          eliminated one
           . 0 . 0                                   2
          (%o2)/R/                [- y, - 3 x  - 1]
          (%i3) polysimp(y^2*x+x^3*9+2);
          (%o3)/R/                    - 3 x + 2

 -- Function: set_up_dot_simplifications (<eqns>,
          <check_through_degree>)
 -- Function: set_up_dot_simplifications (<eqns>)
     The <eqns> are polynomial equations in non commutative variables.
     The value of `current_variables' is the list of variables used for
     computing degrees.  The equations must be homogeneous, in order
     for the procedure to terminate.

     If you have checked overlapping simplifications in
     `dot_simplifications' above the degree of <f>, then the following
     is true: `dotsimp(<f>)' yields 0 if and only if <f> is in the ideal
     generated by the equations, i.e., if and only if <f> is a
     polynomial combination of the elements of the equations.

     The degree is that returned by `nc_degree'.   This in turn is
     influenced by the weights of individual variables.

     `load(affine)' loads this function.

 -- Function: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Assigns weights <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectively.  These are the weights used in computing `nc_degree'.

     `load(affine)' loads this function.

 -- Function: nc_degree (<p>)
     Returns the degree of a noncommutative polynomial <p>.  See
     `declare_weights'.

     `load(affine)' loads this function.

 -- Function: dotsimp (<f>)
     Returns 0 if and only if <f> is in the ideal generated by the
     equations, i.e., if and only if <f> is a polynomial combination of
     the elements of the equations.

     `load(affine)' loads this function.

 -- Function: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     If `set_up_dot_simplifications'  has been previously done, finds
     the central polynomials in the variables <x_1>, ..., <x_n> in the
     given degree, <n>.

     For example:

          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     `load(affine)' loads this function.

 -- Function: check_overlaps (<n>, <add_to_simps>)
     Checks the overlaps thru degree <n>, making sure that you have
     sufficient simplification rules in each degree, for `dotsimp'  to
     work correctly.  This process can be speeded up if you know before
     hand what the dimension of the space of monomials is.  If it is of
     finite global dimension, then `hilbert' should be used.  If you
     don't know the monomial dimensions, do not specify a
     `rank_function'.  An optional third argument `reset', `false' says
     don't bother to query about resetting things.

     `load(affine)' loads this function.

 -- Function: mono ([<x_1>, ..., <x_n>], <n>)
     Returns the list of independent monomials relative to the current
     dot simplifications of degree <n> in the variables <x_1>, ...,
     <x_n>.

     `load(affine)' loads this function.

 -- Function: monomial_dimensions (<n>)
     Compute the Hilbert series through degree <n> for the current
     algebra.

     `load(affine)' loads this function.

 -- Function: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>,
          ..., <m_n>])
     Makes a list of the coefficients of the noncommutative polynomials
     <p_1>, ..., <p_n> of the noncommutative monomials <m_1>, ...,
     <m_n>.  The coefficients should be scalars.  Use
     `list_nc_monomials' to build the list of monomials.

     `load(affine)' loads this function.

 -- Function: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Function: list_nc_monomials (<p>)
     Returns a list of the non commutative monomials occurring in a
     polynomial <p> or a list of polynomials <p_1>, ..., <p_n>.

     `load(affine)' loads this function.

 -- Option variable: all_dotsimp_denoms
     Default value: `false'

     When `all_dotsimp_denoms' is a list, the denominators encountered
     by `dotsimp'  are appended to the list.  `all_dotsimp_denoms' may
     be initialized to an empty list `[]' before calling `dotsimp'.

     By default, denominators are not collected by `dotsimp'.


File: maxima.info,  Node: asympa,  Next: augmented_lagrangian,  Prev: affine,  Up: Top

33 asympa
*********

* Menu:

* Introduction to asympa::
* Functions and variables for asympa::


File: maxima.info,  Node: Introduction to asympa,  Next: Functions and variables for asympa,  Prev: asympa,  Up: asympa

33.1 Introduction to asympa
===========================

 -- Function: asympa
     `asympa' is a package for asymptotic analysis. The package contains
     simplification functions for asymptotic analysis, including the
     "big O" and "little o" functions that are widely used in
     complexity analysis and numerical analysis.

     `load ("asympa")' loads this package.



File: maxima.info,  Node: Functions and variables for asympa,  Prev: Introduction to asympa,  Up: asympa

33.2 Functions and variables for asympa
=======================================


File: maxima.info,  Node: augmented_lagrangian,  Next: bernstein,  Prev: asympa,  Up: Top

34 augmented_lagrangian
***********************

* Menu:

* Functions and Variables for augmented_lagrangian::


File: maxima.info,  Node: Functions and Variables for augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

34.1 Functions and Variables for augmented_lagrangian
=====================================================

 -- Function: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- Function: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          optional_args)
 -- Function: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>)
 -- Function: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>,
          <yy>, optional_args)
     Returns an approximate minimum of the expression <FOM> with
     respect to the variables <xx>, holding the constraints <C> equal
     to zero.  <yy> is a list of initial guesses for <xx>.  The method
     employed is the augmented Lagrangian method (see Refs [1] and [2]).

     <grad>, if present, is the gradient of <FOM> with respect to <xx>,
     represented as a list of expressions, one for each variable in
     <xx>.  If not present, the gradient is constructed automatically.

     <FOM> and each element of <grad>, if present, must be ordinary
     expressions, not names of functions or lambda expressions.

     `optional_args' represents additional arguments, specified as
     `<symbol> = <value>'.  The optional arguments recognized are:

    `niter'
          Number of iterations of the augmented Lagrangian algorithm

    `lbfgs_tolerance'
          Tolerance supplied to LBFGS

    `iprint'
          IPRINT parameter (a list of two integers which controls
          verbosity) supplied to LBFGS

    `%lambda'
          Initial value of `%lambda' to be used for calculating the
          augmented Lagrangian

     This implementation minimizes the augmented Lagrangian by applying
     the limited-memory BFGS (LBFGS) algorithm, which is a quasi-Newton
     algorithm.

     `load(augmented_lagrangian)' loads this function.

     See also `lbfgs'.

     References:

     [1]
     `http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html'

     [2] `http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf'

     Examples:

          (%i1) load (lbfgs);
          (%o1)     /maxima/share/lbfgs/lbfgs.mac
          (%i2) load (augmented_lagrangian);
          (%o2)
             /maxima/share/contrib/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%i6) yy: [1, 1];
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method(FOM, xx, C, yy, iprint=[-1,0]);
          (%o7) [[x = 0.66665984108002, y = 0.33334027245545],
                                           %lambda = [- 1.333337940892525]]

     Same example as before, but this time the gradient is supplied as
     an argument.

          (%i1) load (lbfgs)$
          (%i2) load (augmented_lagrangian)$
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) FOM: x^2 + 2*y^2;
                                         2    2
          (%o4)                       2 y  + x
          (%i5) xx: [x, y];
          (%o5)                        [x, y]
          (%i6) grad : [2*x, 4*y];
          (%o6)                      [2 x, 4 y]
          (%i7) C: [x + y - 1];
          (%o7)                      [y + x - 1]
          (%i8) yy: [1, 1];
          (%o8)                        [1, 1]
          (%i9) augmented_lagrangian_method ([FOM, grad], xx, C, yy,
                                             iprint = [-1, 0]);
          (%o9) [[x = 0.666659841080025, y = .3333402724554462],
                                           %lambda = [- 1.333337940892543]]


File: maxima.info,  Node: bernstein,  Next: bode,  Prev: augmented_lagrangian,  Up: Top

35 bernstein
************

* Menu:

* Functions and Variables for Bernstein::


File: maxima.info,  Node: Functions and Variables for Bernstein,  Prev: bernstein,  Up: bernstein

35.1 Functions and Variables for Bernstein
==========================================

 -- Function: bernstein_poly (<k>, <n>, <x>)
     Provided `k' is not a negative integer, the Bernstein polynomials
     are defined by `bernstein_poly(k,n,x) = binomial(n,k) x^k
     (1-x)^(n-k)'; for a negative integer `k', the Bernstein polynomial
     `bernstein_poly(k,n,x)' vanishes. When either `k' or `n' are non
     integers, the option variable `bernstein_explicit' controls the
     expansion of the Bernstein polynomials into its explicit form;
     example:

          (%i1) load(bernstein)$

          (%i2) bernstein_poly(k,n,x);
          (%o2)                bernstein_poly(k, n, x)
          (%i3) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o3)            binomial(n, k) (1 - x)      x

     The Bernstein polynomials have both a gradef property and an
     integrate property:

          (%i4) diff(bernstein_poly(k,n,x),x);
          (%o4) (bernstein_poly(k - 1, n - 1, x)
                                           - bernstein_poly(k, n - 1, x)) n
          (%i5) integrate(bernstein_poly(k,n,x),x);
          (%o5)
                                                                      k + 1
           hypergeometric([k + 1, k - n], [k + 2], x) binomial(n, k) x
           ----------------------------------------------------------------
                                        k + 1

     For numeric inputs, both real and complex, the Bernstein
     polynomials evaluate to a numeric result:

          (%i6) bernstein_poly(5,9, 1/2 + %i);
                                  39375 %i   39375
          (%o6)                   -------- + -----
                                    128       256
          (%i7) bernstein_poly(5,9, 0.5b0 + %i);
          (%o7)           3.076171875b2 %i + 1.5380859375b2

     To use `bernstein_poly', first `load("bernstein")'.

 -- Variable: bernstein_explicit
     Default value: `false'

     When either `k' or `n' are non integers, the option variable
     `bernstein_explicit' controls the expansion of `bernstein(k,n,x)'
     into its explicit form; example:

          (%i1) bernstein_poly(k,n,x);
          (%o1)                bernstein_poly(k, n, x)
          (%i2) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o2)            binomial(n, k) (1 - x)      x

     When both `k' and `n' are explicitly integers, `bernstein(k,n,x)'
     _always_ expands to its explicit form.

 -- Function: multibernstein_poly (<[k1, k2, ..., kp]>, <[n1, n2, ...,
          np]>, <[x1, x2, ...,  xp]>)
     The multibernstein polynomial `multibernstein_poly (<[k1, ...,
     kp]>, <[n1, ..., np]>, <[x1, ..., xp]>)' is the product of
     bernstein polynomials `bernstein_poly(k1, n1, x1) * ... *
     bernstein_poly(kp, np, xp)'.

     To use `multibernstein_poly', first `load("bernstein")'.

 -- Function: bernstein_approx (<f>, <[x1, x1, ..., xn]>, <n>)
     Return the `n'-th order uniform Bernstein polynomial approximation
     for the function `(x1, x2, ..., xn) |--> f'.

     Examples:

          (%i1) bernstein_approx(f(x),[x], 2);
                           2       1                          2
          (%o1)      f(1) x  + 2 f(-) (1 - x) x + f(0) (1 - x)
                                   2
          (%i2) bernstein_approx(f(x,y),[x,y], 2);
                         2  2       1                2
          (%o2) f(1, 1) x  y  + 2 f(-, 1) (1 - x) x y
                                    2
                            2  2          1   2
           + f(0, 1) (1 - x)  y  + 2 f(1, -) x  (1 - y) y
                                          2
                 1  1                               1         2
           + 4 f(-, -) (1 - x) x (1 - y) y + 2 f(0, -) (1 - x)  (1 - y) y
                 2  2                               2
                      2        2       1                      2
           + f(1, 0) x  (1 - y)  + 2 f(-, 0) (1 - x) x (1 - y)
                                       2
                            2        2
           + f(0, 0) (1 - x)  (1 - y)

     To use `bernstein_approx', first `load("bernstein")'.

 -- Function: bernstein_expand (<e>, <[x1, x1, ..., xn]>)
     Express the _polynomial_ `e' exactly as a linear combination of
     multi-variable Bernstein polynomials.

          (%i1) bernstein_expand(x*y+1,[x,y]);
          (%o1)    2 x y + (1 - x) y + x (1 - y) + (1 - x) (1 - y)
          (%i2) expand(%);
          (%o2)                        x y + 1

     Maxima signals an error when the first argument isn't a polynomial.

     To use `bernstein_expand', first `load("bernstein")'.


File: maxima.info,  Node: bode,  Next: cobyla,  Prev: bernstein,  Up: Top

36 bode
*******

* Menu:

* Functions and Variables for bode::


File: maxima.info,  Node: Functions and Variables for bode,  Prev: bode,  Up: bode

36.1 Functions and Variables for bode
=====================================

 -- Function: bode_gain (<H>, <range>, ... <plot_opts> ...)
     Function to draw Bode gain plots. To use this function write first
     `load(bode)'. See also `bode_phase'.

     Examples:

     Examples (1 through 7 from
     `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 from Ron Crummett):

          (%i1) load("bode")$
          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$
          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$
          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$
          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$
          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$
          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$
          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                                    omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$
          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                                    omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$
          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

 -- Function: bode_phase (<H>, <range>, ... <plot_opts> ...)
     Function to draw Bode phase plots. To use this function write first
     `load(bode)'. See also `bode_gain'.

     Examples:

     Examples (1 through 7 from
     `http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html',
     8 from Ron Crummett):

          (%i1) load("bode")$
          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$
          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$
          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$
          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$
          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$
          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$
          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$
          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$
          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));


File: maxima.info,  Node: cobyla,  Next: contrib_ode,  Prev: bode,  Up: Top

37 cobyla
*********

* Menu:

* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::


File: maxima.info,  Node: Introduction to cobyla,  Next: Functions and Variables for cobyla,  Prev: cobyla,  Up: cobyla

37.1 Introduction to cobyla
===========================

`fmin_cobyla' is a Common Lisp translation (via `f2cl') of the Fortran
constrained optimization routine COBYLA by Powell[1][2][3].

COBYLA minimizes an objective function F(X) subject to M inequality
constraints of the form g(X) >= 0 on X, where X is a vector of
variables that has N components.

Equality constraints g(X)=0 can often be implemented by a pair of
inequality constraints g(X)>=0 and -g(X)>= 0.  Maxima's interface to
COBYLA allows equality constraints and internally converts the equality
constraints to a pair of inequality constraints.

The algorithm employs linear approximations to the objective and
constraint functions, the approximations being formed by linear
interpolation at N+1 points in the space of the variables.  The
interpolation points are regarded as vertices of a simplex.  The
parameter RHO controls the size of the simplex and it is reduced
automatically from RHOBEG to RHOEND.  For each RHO the subroutine tries
to achieve a good vector of variables for the current size, and then
RHO is reduced until the value RHOEND is reached.  Therefore RHOBEG and
RHOEND should be set to reasonable initial changes to and the required
accuracy in the variables respectively, but this accuracy should be
viewed as a subject for experimentation because it is not guaranteed.
The routine treats each constraint individually when calculating a
change to the variables, rather than lumping the constraints together
into a single penalty function.  The name of the subroutine is derived
from the phrase Constrained Optimization BY Linear Approximations.

References:

[1] Fortran Code is from `http://plato.asu.edu/sub/nlores.html#general'

[2] M. J. D. Powell, "A direct search optimization method that models
the objective and constraint functions by linear interpolation," in
Advances in Optimization and Numerical Analysis, eds. S. Gomez and
J.-P. Hennart (Kluwer Academic: Dordrecht, 1994), p. 51-67.

[3] M. J. D. Powell, "Direct search algorithms for optimization
calculations," Acta Numerica 7, 287-336 (1998).  Also available as
University of Cambridge, Department of Applied Mathematics and
Theoretical Physics,  Numerical Analysis Group, Report NA1998/04 from
`http://www.damtp.cam.ac.uk/user/na/reports.html'


File: maxima.info,  Node: Functions and Variables for cobyla,  Next: Examples for cobyla,  Prev: Introduction to cobyla,  Up: cobyla

37.2 Functions and Variables for cobyla
=======================================

 -- Function: fmin_cobyla (<F>, <X>, <Y>)
 -- Function: fmin_cobyla (<F>, <X>, <Y>, optional_args)
     Returns an approximate minimum of the expression <F> with respect
     to the variables <X>, subject to an optional set of constraints.
     <Y> is a list of initial guesses for <X>.

     <F> must be an ordinary expressions, not names of functions or
     lambda expressions.

     `optional_args' represents additional arguments, specified as
     `<symbol> = <value>'.  The optional arguments recognized are:

    `constraints'
          List of inequality and equality constraints that must be
          satisfied by <X>.  The inequality constraints must be actual
          inequalities of the form `g(<X>) >= h(<X>)' or `g(<X>) <=
          h(<X>)'.  The equality constraints must be of the form
          `g(<X>) = h(<X>)'.

    `rhobeg'
          Initial value of the internal RHO variable which controls the
          size of simplex.  (Defaults to 1.0)

    `rhoend'
          The desired final value rho parameter.  It is approximately
          the accuracy in the variables.  (Defaults to 1d-6.)

    `iprint'
          Verbose output level.  (Defaults to 0)
             * 0 - No output

             * 1 - Summary at the end of the calculation

             * 2 - Each new value of RHO and SIGMA is printed, including
               the vector of variables, some function information when
               RHO is reduced.

             * 3 - Like 2, but information is printed when F(X) is
               computed.

    `maxfun'
          The maximum number of function evaluations.  (Defaults to
          1000).

     On return, a vector is given:

       1. The value of the variables giving the minimum.  This is a
          list of elements of the form `<var> = <value>' for each of the
          variables listed in <X>.

       2. The minimized function value

       3. The number of function evaluations.

       4. Return code with the following meanings
            1.  0 - No errors.

            2.  1 - Limit on maximum number of function evaluations
               reached.

            3.  2 - Rounding errors inhibiting progress.

     `load(fmin_cobyla)' loads this function.

 -- Function: bf_fmin_cobyla (<F>, <X>, <Y>)
 -- Function: bf_fmin_cobyla (<F>, <X>, <Y>, optional_args)
     This function is identical to `fmin_cobyla', except that bigfloat
     operations are used, and the default value for <rhoend> is
     `10^(fpprec/2)'.

     See `fmin_cobyla' for more information.

     `load(fmin_cobyla)' loads this function.


File: maxima.info,  Node: Examples for cobyla,  Prev: Functions and Variables for cobyla,  Up: cobyla

37.3 Examples for cobyla
========================

Minimize x1*x2 with 1-x1^2-x2^2 >= 0.  The theoretical solution is x1 =
1/sqrt(2), x2 = -1/sqrt(2).

     (%i1) load(fmin_cobyla)$

     (%i2) fmin_cobyla(x1*x2, [x1, x2], [1,1],
                              constraints = [x1^2+x2^2<=1], iprint=1);

        Normal return from subroutine COBYLA

        NFVALS =   66   F =-5.000000E-01    MAXCV = 1.999956E-12
        X = 7.071058E-01  -7.071077E-01
     (%o2) [[x1 = .7071058493484819, x2 = - .7071077130247994],
                                           - .499999999999263

There are additional examples in the share/cobyla/ex directory.


File: maxima.info,  Node: contrib_ode,  Next: Package descriptive,  Prev: cobyla,  Up: Top

38 contrib_ode
**************

* Menu:

* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::


File: maxima.info,  Node: Introduction to contrib_ode,  Next: Functions and Variables for contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

38.1 Introduction to contrib_ode
================================

Maxima's ordinary differential equation (ODE) solver `ode2' solves
elementary linear ODEs of first and second order.  The function
`contrib_ode' extends `ode2' with additional methods for linear and
non-linear first order ODEs and linear homogeneous second order ODEs.
The code is still under development and the calling sequence may change
in future releases.  Once the code has stabilized it may be moved from
the contrib directory and integrated into Maxima.

This package must be loaded with the command `load('contrib_ode)'
before use.

The calling convention for `contrib_ode' is identical to `ode2'.  It
takes three arguments: an ODE (only the left hand side need be given if
the right hand side is 0), the dependent variable, and the independent
variable.  When successful, it returns a list of solutions.

The form of the solution differs from `ode2'.  As non-linear equations
can have multiple solutions, `contrib_ode' returns a list of solutions.
Each solution can have a number of forms:

   * an explicit solution for the dependent variable,

   * an implicit solution for the dependent variable,

   * a parametric solution in terms of variable `%t', or

   * a tranformation into another ODE in variable `%u'.

`%c' is used to represent the constant of integration for first order
equations.  `%k1' and `%k2' are the constants for second order
equations.  If `contrib_ode' cannot obtain a solution for whatever
reason, it returns `false', after perhaps printing out an error message.

It is necessary to return a list of solutions, as even first order
non-linear ODEs can have multiple solutions.  For example:

     (%i1) load('contrib_ode)$
     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);
                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;
     (%o4)                        factor

Nonlinear ODEs can have singular solutions without constants of
integration, as in the second solution of the following example:

     (%i1) load('contrib_ode)$
     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;
                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);
                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;
     (%o4)                       clairault

The following ODE has two parametric solutions in terms of the dummy
variable `%t'.  In this case the parametric solutions can be manipulated
to give explicit solutions.

     (%i1) load('contrib_ode)$
     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);
     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;
     (%o4)                       lagrange

The following example (Kamke 1.112) demonstrates an implicit solution.

     (%i1) load('contrib_ode)$
     (%i2) assume(x>0,y>0);
     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);
                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;
     (%o5)                          lie

The following Riccati equation is transformed into a linear second
order ODE in the variable `%u'.  Maxima is unable to solve the new ODE,
so it is returned unevaluated.

     (%i1) load('contrib_ode)$
     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;
     (%o4)                        riccati

For first order ODEs `contrib_ode' calls `ode2'.  It then tries the
following methods: factorization, Clairault, Lagrange, Riccati, Abel
and Lie symmetry methods.  The Lie method is not attempted on Abel
equations if the Abel method fails, but it is tried if the Riccati
method returns an unsolved second order ODE.

For second order ODEs `contrib_ode' calls `ode2' then `odelin'.

Extensive debugging traces and messages are displayed if the command
`put('contrib_ode,true,'verbose)' is executed.


File: maxima.info,  Node: Functions and Variables for contrib_ode,  Next: Possible improvements to contrib_ode,  Prev: Introduction to contrib_ode,  Up: contrib_ode

38.2 Functions and Variables for contrib_ode
============================================

 -- Function: contrib_ode (<eqn>, <y>, <x>)
     Returns a list of solutions of the ODE <eqn> with independent
     variable <x> and dependent variable <y>.

 -- Function: odelin (<eqn>, <y>, <x>)
     `odelin' solves linear homogeneous ODEs of first and second order
     with independent variable <x> and dependent variable <y>.  It
     returns a fundamental solution set of the ODE.

     For second order ODEs, `odelin' uses a method, due to Bronstein and
     Lafaille, that searches for solutions in terms of given special
     functions.

          (%i1) load('contrib_ode);

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x

 -- Function: ode_check (<eqn>, <soln>)
     Returns the value of ODE <eqn> after substituting a possible
     solution <soln>.  The value is equivalent to zero if <soln> is a
     solution of <eqn>.

          (%i1) load('contrib_ode)$
          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);
          (%o4)                           0

 -- System variable: method
     The variable `method' is set to the successful solution method.

 -- Variable: %c
     `%c' is the integration constant for first order ODEs.

 -- Variable: %k1
     `%k1' is the first integration constant for second order ODEs.

 -- Variable: %k2
     `%k2' is the second integration constant for second order ODEs.

 -- Function: gauss_a (<a>, <b>, <c>, <x>)
     `gauss_a(a,b,c,x)' and `gauss_b(a,b,c,x)' are 2F1 geometric
     functions.  They represent any two independent solutions of the
     hypergeometric differential equation `x(1-x) diff(y,x,2) +
     [c-(a+b+1)x diff(y,x) - aby = 0' (A&S 15.5.1).

     The only use of these functions is in solutions of ODEs returned by
     `odelin' and `contrib_ode'.  The definition and use of these
     functions may change in future releases of Maxima.

     See also `gauss_b', `dgauss_a' and `gauss_b'.

 -- Function: gauss_b (<a>, <b>, <c>, <x>)
     See `gauss_a'.

 -- Function: dgauss_a (<a>, <b>, <c>, <x>)
     The derivative with respect to <x> of `gauss_a(<a>, <b>, <c>,
     <x>)'.

 -- Function: dgauss_b (<a>, <b>, <c>, <x>)
     The derivative with respect to <x> of `gauss_b(<a>, <b>, <c>,
     <x>)'.

 -- Function: kummer_m (<a>, <b>, <x>)
     Kummer's M function, as defined in Abramowitz and Stegun, Handbook
     of Mathematical Functions, Section 13.1.2.

     The only use of this function is in solutions of ODEs returned by
     `odelin' and `contrib_ode'.  The definition and use of this
     function may change in future releases of Maxima.

     See also `kummer_u', `dkummer_m' and `dkummer_u'.

 -- Function: kummer_u (<a>, <b>, <x>)
     Kummer's U function, as defined in Abramowitz and Stegun, Handbook
     of Mathematical Functions, Section 13.1.3.

     See `kummer_m'.

 -- Function: dkummer_m (<a>, <b>, <x>)
     The derivative with respect to <x> of `kummer_m(<a>, <b>, <x>)'.

 -- Function: dkummer_u (<a>, <b>, <x>)
     The derivative with respect to <x> of `kummer_u(<a>, <b>, <x>)'.


File: maxima.info,  Node: Possible improvements to contrib_ode,  Next: Test cases for contrib_ode,  Prev: Functions and Variables for contrib_ode,  Up: contrib_ode

38.3 Possible improvements to contrib_ode
=========================================

These routines are work in progress.  I still need to:

   * Extend the FACTOR method `ode1_factor' to work for multiple roots.

   * Extend the FACTOR method `ode1_factor' to attempt to solve higher
     order factors.  At present it only attemps to solve linear
     factors.

   * Fix the LAGRANGE routine `ode1_lagrange' to prefer real roots over
      complex roots.

   * Add additional methods for Riccati equations.

   * Improve the detection of Abel equations of second kind.  The
     exisiting   pattern matching is weak.

   * Work on the Lie symmetry group routine `ode1_lie'.  There are
     quite a   few problems with it: some parts are unimplemented; some
     test cases   seem to run forever; other test cases crash; yet
     others return very   complex "solutions".  I wonder if it really
     ready for release yet.

   * Add more test cases.


File: maxima.info,  Node: Test cases for contrib_ode,  Next: References for contrib_ode,  Prev: Possible improvements to contrib_ode,  Up: contrib_ode

38.4 Test cases for contrib_ode
===============================

The routines have been tested on a approximately one thousand  test
cases from Murphy, Kamke, Zwillinger and elsewhere.  These are included
in the tests subdirectory.

   * The Clairault routine `ode1_clairault' finds all known solutions,
     including singular solutions, of the Clairault equations in
     Murphy and   Kamke.

   * The other routines often return a single solution when multiple
     solutions exist.

   * Some of the "solutions" from `ode1_lie' are overly complex and
     impossible to check.

   * There are some crashes.


File: maxima.info,  Node: References for contrib_ode,  Prev: Test cases for contrib_ode,  Up: contrib_ode

38.5 References for contrib_ode
===============================

  1. E. Kamke, Differentialgleichungen Losungsmethoden und Losungen,
     Vol 1,     Geest & Portig, Leipzig, 1961

  2. G. M. Murphy, Ordinary Differential Equations and Their Solutions,
        Van Nostrand, New York, 1960

  3. D. Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F. Schwarz, Symmetry Analysis of Abel's Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F. Schwarz, Algorithmic Solution of Abel's Equation,     Computing
     61, 39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order     ODE
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (`http://lie.uwaterloo.ca/papers/ode_vii.pdf')

  7. E. S. Cheb-Terrab, T. Kolokolnikov,  First Order ODEs,
     Symmetries and Linear Transformations, European Journal of
     Applied Mathematics, Vol. 14, No. 2, pp. 231-246 (2003).
     (`http://arxiv.org/abs/math-ph/0007023',
     `http://lie.uwaterloo.ca/papers/ode_iv.pdf')
  8. G. W. Bluman, S. C. Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M. Bronstein, S. Lafaille, Solutions of linear ordinary
     differential equations in terms of special functions, Proceedings
     of ISSAC 2002, Lille, ACM Press, 23-28.


File: maxima.info,  Node: Package descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

39 Package descriptive
**********************

* Menu:

* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for specific multivariate descriptive statistics::
* Functions and Variables for statistical graphs::


File: maxima.info,  Node: Introduction to descriptive,  Next: Functions and Variables for data manipulation,  Prev: Package descriptive,  Up: Package descriptive

39.1 Introduction to descriptive
================================

Package `descriptive' contains a set of functions for making descriptive
statistical computations and graphing.  Together with the source code
there are three data sets in your Maxima tree: `pidigits.data',
`wind.data' and `biomed.data'.

Any statistics manual can be used as a reference to the functions in
package `descriptive'.

For comments, bugs or suggestions, please contact me at <'mario AT edu
DOT xunta DOT es'>.

Here is a simple example on how the descriptive functions in
`descriptive' do they work, depending on the nature of their arguments,
lists or matrices,

     (%i1) load (descriptive)$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* multivariate sample */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

Note that in multivariate samples the mean is calculated for each
column.

In case of several samples with possible different sizes, the Maxima
function `map' can be used to get the desired results for each sample,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

In this case, two samples of sizes 3 and 2 were stored into a list.

Univariate samples must be stored in lists like

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

and multivariate samples in matrices as in

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

In this case, the number of columns equals the random variable
dimension and the number of rows is the sample size.

Data can be introduced by hand, but big samples are usually stored in
plain text files.  For example, file `pidigits.data' contains the first
100 digits of number `%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

In order to load these digits in Maxima,

     (%i1) s1 : read_list (file_search ("pidigits.data"))$
     (%i2) length (s1);
     (%o2)                          100

On the other hand, file `wind.data' contains daily average wind speeds
at 5 meteorological stations in the Republic of Ireland (This is part
of a data set taken at 12 meteorological stations.  The original file
is freely downloadable from the StatLib Data Repository and its
analysis is discused in Haslett, J., Raftery, A. E. (1989) <Space-time
Modelling with Long-memory Dependence: Assessing Ireland's Wind Power
Resource, with Discussion>.  Applied Statistics 38, 1-50).  This loads
the data:

     (%i1) s2 : read_matrix (file_search ("wind.data"))$
     (%i2) length (s2);
     (%o2)                          100
     (%i3) s2 [%]; /* last record */
     (%o3)            [3.58, 6.0, 4.58, 7.62, 11.25]

Some samples contain non numeric data.  As an example, file
`biomed.data' (which is part of another bigger one downloaded from the
StatLib Data Repository) contains four blood measures taken from two
groups of patients, `A' and `B', of different ages,

     (%i1) s3 : read_matrix (file_search ("biomed.data"))$
     (%i2) length (s3);
     (%o2)                          100
     (%i3) s3 [1]; /* first record */
     (%o3)            [A, 30, 167.0, 89.0, 25.6, 364]

The first individual belongs to group `A', is 30 years old and his/her
blood measures were 167.0, 89.0, 25.6 and 364.

One must take care when working with categorical data.  In the next
example, symbol `a' is asigned a value in some previous moment and then
a sample with categorical value `a' is taken,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Functions and Variables for data manipulation,  Next: Functions and Variables for descriptive statistics,  Prev: Introduction to descriptive,  Up: Package descriptive

39.2 Functions and Variables for data manipulation
==================================================

 -- Function: continuous_freq (<list>)
 -- Function: continuous_freq (<list>, <m>)
     The argument of `continuous_freq' must be a list of numbers.
     Divides the range in intervals and counts how many values are
     inside them.  The second argument is optional and either equals
     the number of classes we want, 10 by default, or equals a list
     containing the class limits and the number of classes we want, or
     a list containing only the limits.  Argument <list> must be a list
     of (2 or 3) real numbers.  If sample values are all equal, this
     function returns only one class of amplitude 2.

     Examples:

     Optional argument indicates the number of classes we want.  The
     first list in the output contains the interval limits, and the
     second the corresponding counts: there are 16 digits inside the
     interval `[0, 1.8]', 24 digits in `(1.8, 3.6]', and so on.

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, 5);
          (%o3) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     Optional argument indicates we want 7 classes with limits -2 and
     12:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12,7]);
          (%o3) [[- 2, 0, 2, 4, 6, 8, 10, 12], [8, 20, 22, 17, 20, 13, 0]]

     Optional argument indicates we want the default number of classes
     with limits -2 and 12:

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12]);
                          3  4  11  18     32  39  46  53
          (%o3)  [[- 2, - -, -, --, --, 5, --, --, --, --, 12],
                          5  5  5   5      5   5   5   5
                         [0, 8, 20, 12, 18, 9, 8, 25, 0, 0]]

 -- Function: discrete_freq (<list>)
     Counts absolute frequencies in discrete samples, both numeric and
     categorical.  Its unique argument is a list,

          (%i1) load (descriptive)$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) discrete_freq (s1);
          (%o3) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     The first list gives the sample values and the second their
     absolute frequencies.  Commands `? col' and `? transpose' should
     help you to understand the last input.

 -- Function: subsample (<data_matrix>, <predicate_function>)
 -- Function: subsample (<data_matrix>, <predicate_function>,
          <col_num1>, <col_num2>, ...)
     This is a sort of variant of the Maxima `submatrix' function.  The
     first argument is the data matrix, the second is a predicate
     function and optional additional arguments are the numbers of the
     columns to be taken.  Its behaviour is better understood with
     examples.

     These are multivariate records in which the wind speed in the first
     meteorological station were greater than 18.  See that in the
     lambda expression the <i>-th component is refered to as `v[i]'.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) subsample (s2, lambda([v], v[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o3)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     In the following example, we request only the first, second and
     fifth components of those records with wind speeds greater or
     equal than 16 in station number 1 and less than 25 knots in
     station number 4.  The sample contains only data from stations 1,
     2 and 5.  In this case, the predicate function is defined as an
     ordinary Maxima function.

          (%i1) load (descriptive)$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) g(x):= x[1] >= 16 and x[4] < 25$
          (%i4) subsample (s2, g, 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     Here is an example with the categorical variables of `biomed.data'.
     We want the records corresponding to those patients in group `B'
     who are older than 38 years.

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) h(u):= u[1] = B and u[2] > 38 $
          (%i4) subsample (s3, h);
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Probably, the statistical analysis will involve only the blood
     measures,

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) subsample (s3, lambda([v], v[1] = B and v[2] > 38),
                           3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o3)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     This is the multivariate mean of `s3',

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) mean (s3);
                 65 B + 35 A  317          6 NA + 8144.999999999999
          (%o3) [-----------, ---, 87.178, ------------------------,
                     100      10                     100
                                                              3 NA + 19587
                                                      18.123, ------------]
                                                                  100

     Here, the first component is meaningless, since `A' and `B' are
     categorical, the second component is the mean age of individuals
     in rational form, and the fourth and last values exhibit some
     strange behaviour.  This is because symbol `NA' is used here to
     indicate <non available> data, and the two means are nonsense.  A
     possible solution would be to take out from the matrix those rows
     with `NA' symbols, although this deserves some loss of information.

          (%i1) load (descriptive)$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) g(v):= v[4] # NA and v[6] # NA $
          (%i4) mean (subsample (s3, g, 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13



Local Variables:
coding: iso-8859-1
End:
