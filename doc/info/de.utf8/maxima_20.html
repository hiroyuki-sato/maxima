<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on August, 1 2011 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 20. Tensoren</title>

<meta name="description" content="Maxima Manual: 20. Tensoren">
<meta name="keywords" content="Maxima Manual: 20. Tensoren">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Tensoren"></a>
<a name="SEC128"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_19.html#SEC127" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC122" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 20. Tensoren </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC129">20.1 Introduction to itensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC132">20.2 Functions and Variables for itensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC143">20.3 Introduction to ctensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC144">20.4 Functions and Variables for ctensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC156">20.5 Introduction to atensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC157">20.6 Functions and Variables for atensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introduction-to-itensor"></a>
<a name="SEC129"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC128" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC130" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.1 Introduction to itensor </h2>

<p>Maxima implements symbolic tensor manipulation of two distinct types:
component tensor manipulation (<code>ctensor</code> package) and indicial tensor manipulation (<code>itensor</code> package).
</p>
<p>Nota bene: Please see the note on 'new tensor notation' below.
</p>
<p>Component tensor manipulation means that geometrical tensor
objects are represented as arrays or matrices. Tensor operations such
as contraction or covariant differentiation are carried out by
actually summing over repeated (dummy) indices with <code>do</code> statements.
That is, one explicitly performs operations on the appropriate tensor
components stored in an array or matrix.
</p>
<p>Indicial tensor manipulation is implemented by representing
tensors as functions of their covariant, contravariant and derivative
indices. Tensor operations such as contraction or covariant
differentiation are performed by manipulating the indices themselves
rather than the components to which they correspond.
</p>
<p>These two approaches to the treatment of differential, algebraic and
analytic processes in the context of Riemannian geometry have various
advantages and disadvantages which reveal themselves only through the
particular nature and difficulty of the user's problem.  However, one
should keep in mind the following characteristics of the two
implementations:
</p>
<p>The representation of tensors and tensor operations explicitly in
terms of their components makes <code>ctensor</code> easy to use. Specification of
the metric and the computation of the induced tensors and invariants
is straightforward. Although all of Maxima's powerful simplification
capacity is at hand, a complex metric with intricate functional and
coordinate dependencies can easily lead to expressions whose size is
excessive and whose structure is hidden. In addition, many calculations
involve intermediate expressions which swell causing programs to
terminate before completion. Through experience, a user can avoid
many of these difficulties.
</p>
<p>Because of the special way in which tensors and tensor operations
are represented in terms of symbolic operations on their indices,
expressions which in the component representation would be
unmanageable can sometimes be greatly simplified by using the special
routines for symmetrical objects in <code>itensor</code>. In this way the structure
of a large expression may be more transparent. On the other hand, because
of the the special indicial representation in <code>itensor</code>, in some cases the
user may find difficulty with the specification of the metric, function
definition, and the evaluation of differentiated &quot;indexed&quot; objects.
</p>
<p>The <code>itensor</code> package can carry out differentiation with respect to an indexed
variable, which allows one to use the package when dealing with Lagrangian
and Hamiltonian formalisms. As it is possible to differentiate a field
Lagrangian with respect to an (indexed) field variable, one can use Maxima
to derive the corresponding Euler-Lagrange equations in indicial form. These
equations can be translated into component tensor (<code>ctensor</code>) programs using
the <code>ic_convert</code> function, allowing us to solve the field equations in a
particular coordinate representation, or to recast the equations of motion
in Hamiltonian form. See <code>einhil.dem</code> and <code>bradic.dem</code> for two comprehensive
examples. The first, <code>einhil.dem</code>, uses the Einstein-Hilbert action to derive
the Einstein field tensor in the homogeneous and isotropic case (Friedmann
equations) and the spherically symmetric, static case (Schwarzschild
solution.) The second, <code>bradic.dem</code>, demonstrates how to compute the Friedmann
equations from the action of Brans-Dicke gravity theory, and also derives
the Hamiltonian associated with the theory's scalar field.
</p>

<hr size="6">
<a name="SEC130"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC129" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC131" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.1.1 New tensor notation </h3>

<p>Earlier versions of the <code>itensor</code> package in Maxima used a notation that sometimes
led to incorrect index ordering. Consider the following, for instance:
</p>
<pre class="example">(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                 i l  j k
(%t3)                           g    g    a
                                           i j
(%i4) ishow(contract(%))$
                                      k l
(%t4)                                a
</pre>
<p>This result is incorrect unless <code>a</code> happens to be a symmetric tensor.
The reason why this happens is that although <code>itensor</code> correctly maintains
the order within the set of covariant and contravariant indices, once an
index is raised or lowered, its position relative to the other set of
indices is lost.
</p>
<p>To avoid this problem, a new notation has been developed that remains fully
compatible with the existing notation and can be used interchangeably. In
this notation, contravariant indices are inserted in the appropriate
positions in the covariant index list, but with a minus sign prepended.
Functions like <code>contract</code> and <code>ishow</code> are now aware of this
new index notation and can process tensors appropriately.
</p>
<p>In this new notation, the previous example yields a correct result:
</p>
<pre class="example">(%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                 i l       j k
(%t5)                           g    a    g
                                      i j
(%i6) ishow(contract(%))$
                                      l k
(%t6)                                a
</pre>
<p>Presently, the only code that makes use of this notation is the <code>lc2kdt</code>
function. Through this notation, it achieves consistent results as it
applies the metric tensor to resolve Levi-Civita symbols without resorting
to numeric indices.
</p>
<p>Since this code is brand new, it probably contains bugs. While it has been
tested to make sure that it doesn't break anything using the &quot;old&quot; tensor
notation, there is a considerable chance that &quot;new&quot; tensors will fail to
interoperate with certain functions or features. These bugs will be fixed
as they are encountered... until then, caveat emptor!
</p>
<hr size="6">
<a name="SEC131"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC130" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.1.2 Indicial tensor manipulation </h3>

<p>The indicial tensor manipulation package may be loaded by
<code>load(itensor)</code>. Demos are also available: try <code>demo(tensor)</code>.
</p>
<p>In <code>itensor</code> a tensor is represented as an &quot;indexed object&quot; .  This is a
function of 3 groups of indices which represent the covariant,
contravariant and derivative indices.  The covariant indices are
specified by a list as the first argument to the indexed object, and
the contravariant indices by a list as the second argument. If the
indexed object lacks either of these groups of indices then the empty
list <code>[]</code> is given as the corresponding argument.  Thus, <code>g([a,b],[c])</code>
represents an indexed object called <code>g</code> which has two covariant indices
<code>(a,b)</code>, one contravariant index (<code>c</code>) and no derivative indices.
</p>
<p>The derivative indices, if they are present, are appended as
additional arguments to the symbolic function representing the tensor.
They can be explicitly specified by the user or be created in the
process of differentiation with respect to some coordinate variable.
Since ordinary differentiation is commutative, the derivative indices
are sorted alphanumerically, unless <code>iframe_flag</code> is set to <code>true</code>,
indicating that a frame metric is being used. This canonical ordering makes it
possible for Maxima to recognize that, for example, <code>t([a],[b],i,j)</code> is
the same as <code>t([a],[b],j,i)</code>.  Differentiation of an indexed object with
respect to some coordinate whose index does not appear as an argument
to the indexed object would normally yield zero. This is because
Maxima would not know that the tensor represented by the indexed
object might depend implicitly on the corresponding coordinate.  By
modifying the existing Maxima function <code>diff</code> in <code>itensor</code>, Maxima now
assumes that all indexed objects depend on any variable of
differentiation unless otherwise stated.  This makes it possible for
the summation convention to be extended to derivative indices. It
should be noted that <code>itensor</code> does not possess the capabilities of
raising derivative indices, and so they are always treated as
covariant.
</p>
<p>The following functions are available in the tensor package for
manipulating indexed objects.  At present, with respect to the
simplification routines, it is assumed that indexed objects do not
by default possess symmetry properties. This can be overridden by
setting the variable <code>allsym[false]</code> to <code>true</code>, which will
result in treating all indexed objects completely symmetric in their
lists of covariant indices and symmetric in their lists of
contravariant indices.
</p>
<p>The <code>itensor</code> package generally treats tensors as opaque objects. Tensorial
equations are manipulated based on algebraic rules, specifically symmetry
and contraction rules. In addition, the <code>itensor</code> package understands
covariant differentiation, curvature, and torsion. Calculations can be
performed relative to a metric of moving frame, depending on the setting
of the <code>iframe_flag</code> variable.
</p>
<p>A sample session below demonstrates how to load the <code>itensor</code> package,
specify the name of the metric, and perform some simple calculations.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
(%i4) ishow(g([k,l],[]))$
(%t4)                               e p
                                       k l
(%i5) ishow(diff(v([i],[]),t))$
(%t5)                                  0
(%i6) depends(v,t);
(%o6)                               [v(t)]
(%i7) ishow(diff(v([i],[]),t))$
                                    d
(%t7)                               -- (v )
                                    dt   i
(%i8) ishow(idiff(v([i],[]),j))$
(%t8)                                v
                                      i,j
(%i9) ishow(extdiff(v([i],[]),j))$
(%t9)                             v    - v
                                   j,i    i,j
                                  -----------
                                       2
(%i10) ishow(liediff(v,w([i],[])))$
                               %3          %3
(%t10)                        v   w     + v   w
                                   i,%3    ,i  %3
(%i11) ishow(covdiff(v([i],[]),j))$
                                              %4
(%t11)                        v    - v   ichr2
                               i,j    %4      i j
(%i12) ishow(ev(%,ichr2))$
                %4 %5
(%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
        i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                         + e p       + e   p    ))/2
                                              i %5,j    ,j  i %5
(%i13) iframe_flag:true;
(%o13)                               true
(%i14) ishow(covdiff(v([i],[]),j))$
                                             %6
(%t14)                        v    - v   icc2
                               i,j    %6     i j
(%i15) ishow(ev(%,icc2))$
                                             %6
(%t15)                        v    - v   ifc2
                               i,j    %6     i j
(%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
             %6 %7                    %6 %7
(%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                    %6    j %7 i             %6    i j %7      i,j

                                             %6 %7
                                        - ifg      v   ifb      )/2
                                                    %6    %7 i j
(%i17) ishow(canform(s([i,j],[])-s([j,i])))$
(%t17)                            s    - s
                                   i j    j i
(%i18) decsym(s,2,0,[sym(all)],[]);
(%o18)                               done
(%i19) ishow(canform(s([i,j],[])-s([j,i])))$
(%t19)                                 0
(%i20) ishow(canform(a([i,j],[])+a([j,i])))$
(%t20)                            a    + a
                                   j i    i j
(%i21) decsym(a,2,0,[anti(all)],[]);
(%o21)                               done
(%i22) ishow(canform(a([i,j],[])+a([j,i])))$
(%t22)                                 0
</pre>

<hr size="6">
<a name="Functions-and-Variables-for-itensor"></a>
<a name="SEC132"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC131" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC133" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.2 Functions and Variables for itensor </h2>
<hr size="6">
<a name="SEC133"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC132" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC134" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.1 Managing indexed objects </h3>

<dl>
<dt><u>Function:</u> <b>dispcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1004"></a>
</dt>
<dt><u>Function:</u> <b>dispcon</b><i> (all)</i>
<a name="IDX1005"></a>
</dt>
<dd><p>Displays the contraction properties of its arguments as were given to 
<code>defcon</code>.  <code>dispcon (all)</code> displays all the contraction properties
which were defined.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>entertensor</b><i> (<var>name</var>)</i>
<a name="IDX1006"></a>
</dt>
<dd><p>is a function which, by prompting, allows one to create an indexed
object called <var>name</var> with any number of tensorial and derivative
indices. Either a single index or a list of indices (which may be
null) is acceptable input (see the example under <code>covdiff</code>).
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>changename</b><i> (<var>old</var>, <var>new</var>, <var>expr</var>)</i>
<a name="IDX1007"></a>
</dt>
<dd><p>will change the name of all indexed objects called <var>old</var> to <var>new</var>
in <var>expr</var>. <var>old</var> may be either a symbol or a list of the form
<code>[<var>name</var>, <var>m</var>, <var>n</var>]</code> in which case only those indexed objects called
<var>name</var> with <var>m</var> covariant and <var>n</var> contravariant indices will be
renamed to <var>new</var>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>listoftens</b>
<a name="IDX1008"></a>
</dt>
<dd><p>Lists all tensors in a tensorial expression, complete with their indices. E.g.,
</p>
<pre class="example">
(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ishow</b><i> (<var>expr</var>)</i>
<a name="IDX1009"></a>
</dt>
<dd><p>displays <var>expr</var> with the indexed objects in it shown having their
covariant indices as subscripts and contravariant indices as
superscripts. The derivative indices are displayed as subscripts,
separated from the covariant indices by a comma (see the examples
throughout this document).
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>indices</b><i> (<var>expr</var>)</i>
<a name="IDX1010"></a>
</dt>
<dd><p>Returns a list of two elements.  The first is a list of the free
indices in <var>expr</var> (those that occur only once). The second is the
list of the dummy indices in <var>expr</var> (those that occur exactly twice)
as the following example demonstrates.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre>
<p>A tensor product containing the same index more than twice is syntactically
illegal. <code>indices</code> attempts to deal with these expressions in a
reasonable manner; however, when it is called to operate upon such an
illegal expression, its behavior should be considered undefined.
</p>

</dd></dl>

<dl>
<dt><u>Function:</u> <b>rename</b><i> (<var>expr</var>)</i>
<a name="IDX1011"></a>
</dt>
<dt><u>Function:</u> <b>rename</b><i> (<var>expr</var>, <var>count</var>)</i>
<a name="IDX1012"></a>
</dt>
<dd><p>Returns an expression equivalent to <var>expr</var> but with the dummy indices
in each term chosen from the set <code>[%1, %2,...]</code>, if the optional second
argument is omitted. Otherwise, the dummy indices are indexed
beginning at the value of <var>count</var>.  Each dummy index in a product
will be different. For a sum, <code>rename</code> will operate upon each term in
the sum resetting the counter with each term. In this way <code>rename</code> can
serve as a tensorial simplifier. In addition, the indices will be
sorted alphanumerically (if <code>allsym</code> is <code>true</code>) with respect to
covariant or contravariant indices depending upon the value of <code>flipflag</code>.
If <code>flipflag</code> is <code>false</code> then the indices will be renamed according
to the order of the contravariant indices. If <code>flipflag</code> is <code>true</code>
the renaming will occur according to the order of the covariant
indices. It often happens that the combined effect of the two renamings will
reduce an expression more than either one by itself.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$

       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %5      %4 %6      %7 r
(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

        %1 %2  %3 %4      %6         %5         %7        u
     - g      g      ichr2      ichr2      ichr2     ichr2
                          %1 %3      %2 %6      %4 r      %5 %7
</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>show</b><i> (<var>expr</var>)</i>
<a name="IDX1013"></a>
</dt>
<dd><p>Displays <code>expr</code> with the indexed objects in it shown
having covariant indices as subscripts, contravariant indices as
superscripts.  The derivative indices are displayed as subscripts,
separated from the covariant indices by a comma.
</p>
</dd></dl>


<dl>
<dt><u>Option variable:</u> <b>flipflag</b>
<a name="IDX1014"></a>
</dt>
<dd><p>Default: <code>false</code>. If <code>false</code> then the indices will be
renamed according to the order of the contravariant indices,
otherwise according to the order of the covariant indices.
</p>
<p>If <code>flipflag</code> is <code>false</code> then <code>rename</code> forms a list
of the contravariant indices as they are encountered from left to right
(if <code>true</code> then of the covariant indices). The first dummy
index in the list is renamed to <code>%1</code>, the next to <code>%2</code>, etc.
Then sorting occurs after the <code>rename</code>-ing (see the example
under <code>rename</code>).
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>defcon</b><i> (<var>tensor_1</var>)</i>
<a name="IDX1015"></a>
</dt>
<dt><u>Function:</u> <b>defcon</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</i>
<a name="IDX1016"></a>
</dt>
<dd><p>gives <var>tensor_1</var> the property that the
contraction of a product of <var>tensor_1</var> and <var>tensor_2</var> results in <var>tensor_3</var>
with the appropriate indices.  If only one argument, <var>tensor_1</var>, is
given, then the contraction of the product of <var>tensor_1</var> with any indexed
object having the appropriate indices (say <code>my_tensor</code>) will yield an
indexed object with that name, i.e. <code>my_tensor</code>, and with a new set of
indices reflecting the contractions performed.
    For example, if <code>imetric:g</code>, then <code>defcon(g)</code> will implement the
raising and lowering of indices through contraction with the metric
tensor.
    More than one <code>defcon</code> can be given for the same indexed object; the
latest one given which applies in a particular contraction will be
used.
<code>contractions</code> is a list of those indexed objects which have been given
contraction properties with <code>defcon</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>remcon</b><i> (<var>tensor_1</var>, ..., <var>tensor_n</var>)</i>
<a name="IDX1017"></a>
</dt>
<dt><u>Function:</u> <b>remcon</b><i> (all)</i>
<a name="IDX1018"></a>
</dt>
<dd><p>removes all the contraction properties
from the <var>tensor_1</var>, ..., <var>tensor_n</var>). <code>remcon(all)</code> removes all contraction
properties from all indexed objects.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>contract</b><i> (<var>expr</var>)</i>
<a name="IDX1019"></a>
</dt>
<dd><p>Carries out the tensorial contractions in <var>expr</var> which may be any
combination of sums and products. This function uses the information
given to the <code>defcon</code> function. For best results, <code>expr</code>
should be fully expanded. <code>ratexpand</code> is the fastest way to expand
products and powers of sums if there are no variables in the denominators
of the terms. The <code>gcd</code> switch should be <code>false</code> if GCD
cancellations are unnecessary.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>indexed_tensor</b><i> (<var>tensor</var>)</i>
<a name="IDX1020"></a>
</dt>
<dd><p>Must be executed before assigning components to a <var>tensor</var> for which
a built in value already exists as with <code>ichr1</code>, <code>ichr2</code>,
<code>icurvature</code>. See the example under <code>icurvature</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>components</b><i> (<var>tensor</var>, <var>expr</var>)</i>
<a name="IDX1021"></a>
</dt>
<dd><p>permits one to assign an indicial value to an expression
<var>expr</var> giving the values of the components of <var>tensor</var>. These
are automatically substituted for the tensor whenever it occurs with
all of its indices. The tensor must be of the form <code>t([...],[...])</code>
where either list may be empty. <var>expr</var> can be any indexed expression
involving other objects with the same free indices as <var>tensor</var>. When
used to assign values to the metric tensor wherein the components
contain dummy indices one must be careful to define these indices to
avoid the generation of multiple dummy indices. Removal of this
assignment is given to the function <code>remcomps</code>.
</p>
<p>It is important to keep in mind that <code>components</code> cares only about
the valence of a tensor, not about any particular index ordering. Thus
assigning components to, say, <code>x([i,-j],[])</code>, <code>x([-j,i],[])</code>, or
<code>x([i],[j])</code> all produce the same result, namely components being
assigned to a tensor named <code>x</code> with valence <code>(1,1)</code>.
</p>
<p>Components can be assigned to an indexed expression in four ways, two
of which involve the use of the <code>components</code> command:
</p>
<p>1) As an indexed expression. For instance:
</p>
<pre class="example">
(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre>
<p>2) As a matrix:
</p>
<pre class="example">
(%i5) lg:-ident(4)$lg[1,1]:1$lg;
                            [ 1   0    0    0  ]
                            [                  ]
                            [ 0  - 1   0    0  ]
(%o5)                       [                  ]
                            [ 0   0   - 1   0  ]
                            [                  ]
                            [ 0   0    0   - 1 ]

(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([1,1],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1

</pre>
<p>3) As a function. You can use a Maxima function to specify the
components of a tensor based on its indices. For instance, the following
code assigns <code>kdelta</code> to <code>h</code> if <code>h</code> has the same number
of covariant and contravariant indices and no derivative indices, and
<code>g</code> otherwise:
</p>
<pre class="example">
(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l

</pre>
<p>4) Using Maxima's pattern matching capabilities, specifically the
<code>defrule</code> and <code>applyb1</code> commands:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                    i m
(%t5)                              m    m
                                         i n
(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n


</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>remcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX1022"></a>
</dt>
<dd><p>Unbinds all values from <var>tensor</var> which were assigned with the
<code>components</code> function.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>showcomps</b><i> (<var>tensor</var>)</i>
<a name="IDX1023"></a>
</dt>
<dd><p>Shows component assignments of a tensor, as made using the <code>components</code>
command. This function can be particularly useful when a matrix is assigned
to an indicial tensor using <code>components</code>, as demonstrated by the
following example:
</p>
<pre class="example">
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(itensor);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

</pre>
<p>The <code>showcomps</code> command can also display components of a tensor of
rank higher than 2.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>idummy</b><i> ()</i>
<a name="IDX1024"></a>
</dt>
<dd><p>Increments <code>icounter</code> and returns as its value an index of the form
<code>%n</code> where n is a positive integer.  This guarantees that dummy indices
which are needed in forming expressions will not conflict with indices
already in use (see the example under <code>indices</code>).
</p>
</dd></dl>

<dl>
<dt><u>Option variable:</u> <b>idummyx</b>
<a name="IDX1025"></a>
</dt>
<dd><p>Default value: <code>%</code>
</p>
<p>Is the prefix for dummy indices (see the example under <code>indices</code>).
</p>
</dd></dl>

<dl>
<dt><u>Option variable:</u> <b>icounter</b>
<a name="IDX1026"></a>
</dt>
<dd><p>Default value: <code>1</code>
</p>
<p>Determines the numerical suffix to be used in
generating the next dummy index in the tensor package.  The prefix is
determined by the option <code>idummy</code> (default: <code>%</code>).
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>kdelta</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX1027"></a>
</dt>
<dd><p>is the generalized Kronecker delta function defined in
the <code>itensor</code> package with <var>L1</var> the list of covariant indices and <var>L2</var>
the list of contravariant indices.  <code>kdelta([i],[j])</code> returns the ordinary
Kronecker delta.  The command <code>ev(<var>expr</var>,kdelta)</code> causes the evaluation of
an expression containing <code>kdelta([],[])</code> to the dimension of the
manifold.
</p>
<p>In what amounts to an abuse of this notation, <code>itensor</code> also allows
<code>kdelta</code> to have 2 covariant and no contravariant, or 2 contravariant
and no covariant indices, in effect providing a co(ntra)variant &quot;unit matrix&quot;
capability. This is strictly considered a programming aid and not meant to
imply that <code>kdelta([i,j],[])</code> is a valid tensorial object.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>kdels</b><i> (<var>L1</var>, <var>L2</var>)</i>
<a name="IDX1028"></a>
</dt>
<dd><p>Symmetricized Kronecker delta, used in some calculations. For instance:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>levi_civita</b><i> (<var>L</var>)</i>
<a name="IDX1029"></a>
</dt>
<dd><p>is the permutation (or Levi-Civita) tensor which yields 1 if
the list <var>L</var> consists of an even permutation of integers, -1 if it
consists of an odd permutation, and 0 if some indices in <var>L</var> are
repeated.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>lc2kdt</b><i> (<var>expr</var>)</i>
<a name="IDX1030"></a>
</dt>
<dd><p>Simplifies expressions containing the Levi-Civita symbol, converting these
to Kronecker-delta expressions when possible. The main difference between
this function and simply evaluating the Levi-Civita symbol is that direct
evaluation often results in Kronecker expressions containing numerical
indices. This is often undesirable as it prevents further simplification.
The <code>lc2kdt</code> function avoids this problem, yielding expressions that
are more easily simplified with <code>rename</code> or <code>contract</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l

</pre>
<p>The <code>lc2kdt</code> function sometimes makes use of the metric tensor.
If the metric tensor was not defined previously with <code>imetric</code>,
this results in an error.
</p>
<pre class="example">
(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i    l i  j
(%t11)                           a    - g    a
                                              j

</pre>

</dd></dl>

<dl>
<dt><u>Function:</u> <b>lc_l</b>
<a name="IDX1031"></a>
</dt>
<dd><p>Simplification rule used for expressions containing the unevaluated Levi-Civita
symbol (<code>levi_civita</code>). Along with <code>lc_u</code>, it can be used to simplify
many expressions more efficiently than the evaluation of <code>levi_civita</code>.
For example:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
(%t4)                                  0
(%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
(%t5)                                  0

</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>lc_u</b>
<a name="IDX1032"></a>
</dt>
<dd><p>Simplification rule used for expressions containing the unevaluated Levi-Civita
symbol (<code>levi_civita</code>). Along with <code>lc_u</code>, it can be used to simplify
many expressions more efficiently than the evaluation of <code>levi_civita</code>.
For details, see <code>lc_l</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>canten</b><i> (<var>expr</var>)</i>
<a name="IDX1033"></a>
</dt>
<dd><p>Simplifies <var>expr</var> by renaming (see <code>rename</code>)
and permuting dummy indices. <code>rename</code> is restricted to sums of tensor
products in which no derivatives are present. As such it is limited
and should only be used if <code>canform</code> is not capable of carrying out the
required simplification.
</p>
<p>The <code>canten</code> function returns a mathematically correct result only
if its argument is an expression that is fully symmetric in its indices.
For this reason, <code>canten</code> returns an error if <code>allsym</code> is not
set to <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>concan</b><i> (<var>expr</var>)</i>
<a name="IDX1034"></a>
</dt>
<dd><p>Similar to <code>canten</code> but also performs index contraction.
</p>
</dd></dl>

<hr size="6">
<a name="SEC134"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC133" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC135" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.2 Tensor symmetries </h3>

<dl>
<dt><u>Option variable:</u> <b>allsym</b>
<a name="IDX1035"></a>
</dt>
<dd><p>Default: <code>false</code>. if <code>true</code> then all indexed objects
are assumed symmetric in all of their covariant and contravariant
indices. If <code>false</code> then no symmetries of any kind are assumed
in these indices. Derivative indices are always taken to be symmetric
unless <code>iframe_flag</code> is set to <code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>decsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, ...], [<var>contr_1</var>, <var>contr_2</var>, ...])</i>
<a name="IDX1036"></a>
</dt>
<dd><p>Declares symmetry properties for <var>tensor</var> of <var>m</var> covariant and
<var>n</var> contravariant indices. The <var>cov_i</var> and <var>contr_i</var> are
pseudofunctions expressing symmetry relations among the covariant and
contravariant indices respectively.  These are of the form
<code>symoper(<var>index_1</var>, <var>index_2</var>,...)</code> where <code>symoper</code> is one of
<code>sym</code>, <code>anti</code> or <code>cyc</code> and the <var>index_i</var> are integers
indicating the position of the index in the <var>tensor</var>.  This will
declare <var>tensor</var> to be symmetric, antisymmetric or cyclic respectively
in the <var>index_i</var>. <code>symoper(all)</code> is also an allowable form which
indicates all indices obey the symmetry condition. For example, given an
object <code>b</code> with 5 covariant indices,
<code>decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code> declares <code>b</code>
symmetric in its first and second and antisymmetric in its third and
fourth covariant indices, and cyclic in all of its contravariant indices.
Either list of symmetry declarations may be null.  The function which
performs the simplifications is <code>canform</code> as the example below
illustrates.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract( expand( a([i1, j1, k1], [])
           *kdels([i, j, k], [i1, j1, k1])))$
(%i3) ishow(expr)$
(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre>

</dd></dl>

<dl>
<dt><u>Function:</u> <b>remsym</b><i> (<var>tensor</var>, <var>m</var>, <var>n</var>)</i>
<a name="IDX1037"></a>
</dt>
<dd><p>Removes all symmetry properties from <var>tensor</var> which has <var>m</var>
covariant indices and <var>n</var> contravariant indices.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>canform</b><i> (<var>expr</var>)</i>
<a name="IDX1038"></a>
</dt>
<dt><u>Function:</u> <b>canform</b><i> (<var>expr</var>, <var>rename</var>)</i>
<a name="IDX1039"></a>
</dt>
<dd><p>Simplifies <var>expr</var> by renaming dummy
indices and reordering all indices as dictated by symmetry conditions
imposed on them. If <code>allsym</code> is <code>true</code> then all indices are assumed
symmetric, otherwise symmetry information provided by <code>decsym</code>
declarations will be used. The dummy indices are renamed in the same
manner as in the <code>rename</code> function. When <code>canform</code> is applied to a large
expression the calculation may take a considerable amount of time.
This time can be shortened by calling <code>rename</code> on the expression first.
Also see the example under <code>decsym</code>. Note: <code>canform</code> may not be able to
reduce an expression completely to its simplest form although it will
always return a mathematically correct result.
</p>
<p>The optional second parameter <var>rename</var>, if set to <code>false</code>, suppresses renaming.
</p>
</dd></dl>

<hr size="6">
<a name="SEC135"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC134" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC136" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.3 Indicial tensor calculus </h3>

<dl>
<dt><u>Function:</u> <b>diff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</i>
<a name="IDX1040"></a>
</dt>
<dd><p>is the usual Maxima differentiation function which has been expanded
in its abilities for <code>itensor</code>. It takes the derivative of <var>expr</var> with
respect to <var>v_1</var> <var>n_1</var> times, with respect to <var>v_2</var> <var>n_2</var>
times, etc. For the tensor package, the function has been modified so
that the <var>v_i</var> may be integers from 1 up to the value of the variable
<code>dim</code>.  This will cause the differentiation to be carried out with
respect to the <var>v_i</var>th member of the list <code>vect_coords</code>.  If
<code>vect_coords</code> is bound to an atomic variable, then that variable
subscripted by <var>v_i</var> will be used for the variable of
differentiation.  This permits an array of coordinate names or
subscripted names like <code>x[1]</code>, <code>x[2]</code>, ...  to be used.
</p>
<p>A further extension adds the ability to <code>diff</code> to compute derivatives
with respect to an indexed variable. In particular, the tensor package knows
how to differentiate expressions containing combinations of the metric tensor
and its derivatives with respect to the metric tensor and its first and
second derivatives. This capability is particularly useful when considering
Lagrangian formulations of a gravitational theory, allowing one to derive
the Einstein tensor and field equations from the action principle.
</p>
</dd></dl>

<p><a name="idiff"></a>
</p><dl>
<dt><u>Function:</u> <b>idiff</b><i> (<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] &hellip;])</i>
<a name="IDX1041"></a>
</dt>
<dd><p>Indicial differentiation. Unlike <code>diff</code>, which differentiates
with respect to an independent variable, <code>idiff)</code> can be used
to differentiate with respect to a coordinate. For an indexed object,
this amounts to appending the <var>v_i</var> as derivative indices.
Subsequently, derivative indices will be sorted, unless <code>iframe_flag</code>
is set to <code>true</code>.
</p>
<p><code>idiff</code> can also differentiate the determinant of the metric
tensor. Thus, if <code>imetric</code> has been bound to <code>G</code> then
<code>idiff(determinant(g), k)</code> will return
<code>2 * determinant(g) * ichr2([%i,k], [%i])</code> where the dummy index <code>%i</code>
is chosen appropriately.
</p>
</dd></dl>

<p><a name="liediff"></a>
</p><dl>
<dt><u>Function:</u> <b>liediff</b><i> (<var>v</var>, <var>ten</var>)</i>
<a name="IDX1042"></a>
</dt>
<dd><p>Computes the Lie-derivative of the tensorial expression <var>ten</var> with
respect to the vector field <var>v</var>. <var>ten</var> should be any indexed
tensor expression; <var>v</var> should be the name (without indices) of a vector
field. For example:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>rediff</b><i> (<var>ten</var>)</i>
<a name="IDX1043"></a>
</dt>
<dd><p>Evaluates all occurrences of the <code>idiff</code> command in the tensorial
expression <var>ten</var>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>undiff</b><i> (<var>expr</var>)</i>
<a name="IDX1044"></a>
</dt>
<dd><p>Returns an expression equivalent to <var>expr</var> but with all derivatives
of indexed objects replaced by the noun form of the <code>idiff</code> function. Its
arguments would yield that indexed object if the differentiation were
carried out.  This is useful when it is desired to replace a
differentiated indexed object with some function definition resulting
in <var>expr</var> and then carry out the differentiation by saying
<code>ev(<var>expr</var>, idiff)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>evundiff</b><i> (<var>expr</var>)</i>
<a name="IDX1045"></a>
</dt>
<dd><p>Equivalent to the execution of <code>undiff</code>, followed by <code>ev</code> and
<code>rediff</code>.
</p>
<p>The point of this operation is to easily evalute expressions that cannot
be directly evaluated in derivative form. For instance, the following
causes an error:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>However, if <code>icurvature</code> is entered in noun form, it can be evaluated
using <code>evundiff</code>:
</p>
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
</pre>
<p>Note: In earlier versions of Maxima, derivative forms of the
Christoffel-symbols also could not be evaluated. This has been fixed now,
so <code>evundiff</code> is no longer necessary for expressions like this:
</p>
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>flush</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1046"></a>
</dt>
<dd><p>Set to zero, in
<var>expr</var>, all occurrences of the <var>tensor_i</var> that have no derivative indices.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>flushd</b><i> (<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1047"></a>
</dt>
<dd><p>Set to zero, in
<var>expr</var>, all occurrences of the <var>tensor_i</var> that have derivative indices.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>flushnd</b><i> (<var>expr</var>, <var>tensor</var>, <var>n</var>)</i>
<a name="IDX1048"></a>
</dt>
<dd><p>Set to zero, in <var>expr</var>, all
occurrences of the differentiated object <var>tensor</var> that have <var>n</var> or more
derivative indices as the following example demonstrates.
</p><pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>coord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1049"></a>
</dt>
<dd><p>Gives <var>tensor_i</var> the coordinate differentiation property that the
derivative of contravariant vector whose name is one of the
<var>tensor_i</var> yields a Kronecker delta. For example, if <code>coord(x)</code> has
been done then <code>idiff(x([],[i]),j)</code> gives <code>kdelta([i],[j])</code>.
<code>coord</code> is a list of all indexed objects having this property.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>remcoord</b><i> (<var>tensor_1</var>, <var>tensor_2</var>, ...)</i>
<a name="IDX1050"></a>
</dt>
<dt><u>Function:</u> <b>remcoord</b><i> (all)</i>
<a name="IDX1051"></a>
</dt>
<dd><p>Removes the coordinate differentiation property from the <code>tensor_i</code>
that was established by the function <code>coord</code>.  <code>remcoord(all)</code>
removes this property from all indexed objects.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>makebox</b><i> (<var>expr</var>)</i>
<a name="IDX1052"></a>
</dt>
<dd><p>Display <var>expr</var> in the same manner as <code>show</code>; however,
any tensor d'Alembertian occurring in <var>expr</var> will be indicated using the
symbol <code>[]</code>.  For example, <code>[]p([m],[n])</code> represents
<code>g([],[i,j])*p([m],[n],i,j)</code>.
</p>
</dd></dl>

<p><a name="conmetderiv"></a>
</p><dl>
<dt><u>Function:</u> <b>conmetderiv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX1053"></a>
</dt>
<dd><p>Simplifies expressions containing ordinary derivatives of both covariant and 
contravariant forms of the metric tensor (the current restriction).  For 
example, the function <code>conmetderiv</code> can relate the derivative of the 
contravariant metric tensor with the Christoffel symbols as seen from the 
following:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre>
</dd></dl>

<p><a name="simpmetderiv"></a>
</p><dl>
<dt><u>Function:</u> <b>simpmetderiv</b><i> (<var>expr</var>)</i>
<a name="IDX1054"></a>
</dt>
<dt><u>Function:</u> <b>simpmetderiv</b><i> (<var>expr</var>[, <var>stop</var>])</i>
<a name="IDX1055"></a>
</dt>
<dd><p>Simplifies expressions containing products of the derivatives of the
metric tensor. Specifically, <code>simpmetderiv</code> recognizes two identities:
</p>
<pre class="example">
   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre>
<p>hence
</p>
<pre class="example">
   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre>
<p>and
</p>
<pre class="example">
  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre>
<p>which follows from the symmetries of the Christoffel symbols.
</p>
<p>The <code>simpmetderiv</code> function takes one optional parameter which, when
present, causes the function to stop after the first successful
substitution in a product expression. The <code>simpmetderiv</code> function
also makes use of the global variable <var>flipflag</var> which determines
how to apply a &quot;canonical&quot; ordering to the product indices.
</p>
<p>Put together, these capabilities can be used to achieve powerful
simplifications that are difficult or impossible to accomplish otherwise.
This is demonstrated through the following example that explicitly uses the
partial simplification features of <code>simpmetderiv</code> to obtain a
contractible expression:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre>
<p>See also <code>weyl.dem</code> for an example that uses <code>simpmetderiv</code>
and <code>conmetderiv</code> together to simplify contractions of the Weyl tensor.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>flush1deriv</b><i> (<var>expr</var>, <var>tensor</var>)</i>
<a name="IDX1056"></a>
</dt>
<dd><p>Set to zero, in <code>expr</code>, all occurrences of <code>tensor</code> that have
exactly one derivative index.
</p>
</dd></dl>

<hr size="6">
<a name="SEC136"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC135" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC137" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.4 Tensors in curved spaces </h3>

<dl>
<dt><u>Function:</u> <b>imetric</b><i> (<var>g</var>)</i>
<a name="IDX1057"></a>
</dt>
<dt><u>System variable:</u> <b>imetric</b>
<a name="IDX1058"></a>
</dt>
<dd><p>Specifies the metric by assigning the variable <code>imetric : <var>g</var></code> in
addition, the contraction properties of the metric <var>g</var> are set up by
executing the commands <code>defcon(<var>g</var>), defcon(<var>g</var>, <var>g</var>, kdelta)</code>.
The variable <code>imetric</code> (unbound by default), is bound to the metric, 
assigned by the <code>imetric(<var>g</var>)</code> command.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>idim</b><i> (<var>n</var>)</i>
<a name="IDX1059"></a>
</dt>
<dd><p>Sets the dimensions of the metric. Also initializes the antisymmetry
properties of the Levi-Civita symbols for the given dimension.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ichr1</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>])</i>
<a name="IDX1060"></a>
</dt>
<dd><p>Yields the Christoffel symbol of the first kind via the
definition
</p><pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre>
<p>To evaluate the Christoffel symbols for a particular metric, the
variable <code>imetric</code> must be assigned a name as in the example under <code>chr2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ichr2</b><i> ([<var>i</var>, <var>j</var>], [<var>k</var>])</i>
<a name="IDX1061"></a>
</dt>
<dd><p>Yields the Christoffel symbol of the second kind
defined by the relation
</p><pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>icurvature</b><i> ([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</i>
<a name="IDX1062"></a>
</dt>
<dd><p>Yields the Riemann
curvature tensor in terms of the Christoffel symbols of the second
kind (<code>ichr2</code>).  The following notation is used:
</p><pre class="example">            h             h            h         %1         h
  icurvature     = - ichr2      - ichr2     ichr2    + ichr2
            i j k         i k,j        %1 j      i k        i j,k
                            h          %1
                     + ichr2      ichr2
                            %1 k       i j
</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>covdiff</b><i> (<var>expr</var>, <var>v_1</var>, <var>v_2</var>, ...)</i>
<a name="IDX1063"></a>
</dt>
<dd><p>Yields the covariant derivative of <var>expr</var> with
respect to the variables <var>v_i</var> in terms of the Christoffel symbols of the
second kind (<code>ichr2</code>).  In order to evaluate these, one should use
<code>ev(<var>expr</var>,ichr2)</code>.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;
(%o4)                                  g
(%i5) ishow(ev(%th(2),ichr2))$
         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s
(%i6)
</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>lorentz_gauge</b><i> (<var>expr</var>)</i>
<a name="IDX1064"></a>
</dt>
<dd><p>Imposes the Lorentz condition by substituting 0 for all
indexed objects in <var>expr</var> that have a derivative index identical to a
contravariant index.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>igeodesic_coords</b><i> (<var>expr</var>, <var>name</var>)</i>
<a name="IDX1065"></a>
</dt>
<dd><p>Causes undifferentiated Christoffel symbols and
first derivatives of the metric tensor vanish in <var>expr</var>. The <var>name</var>
in the <code>igeodesic_coords</code> function refers to the metric <var>name</var>
(if it appears in <var>expr</var>) while the connection coefficients must be
called with the names <code>ichr1</code> and/or <code>ichr2</code>. The following example
demonstrates the verification of the cyclic identity satisfied by the Riemann
curvature tensor using the <code>igeodesic_coords</code> function.
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0

</pre>
</dd></dl>

<hr size="6">
<a name="SEC137"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC136" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC138" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.5 Moving frames </h3>

<p>Maxima now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary frame.
</p>
<p>To use frames, you must first set <code>iframe_flag</code> to <code>true</code>. This
causes the Christoffel-symbols, <code>ichr1</code> and <code>ichr2</code>, to be replaced
by the more general frame connection coefficients <code>icc1</code> and <code>icc2</code>
in calculations. Speficially, the behavior of <code>covdiff</code> and
<code>icurvature</code> is changed.
</p>
<p>The frame is defined by two tensors: the inverse frame field (<code>ifri</code>,
the dual basis tetrad),
and the frame metric <code>ifg</code>. The frame metric is the identity matrix for
orthonormal frames, or the Lorentz metric for orthonormal frames in Minkowski
spacetime. The inverse frame field defines the frame base (unit vectors).
Contraction properties are defined for the frame field and the frame metric.
</p>
<p>When <code>iframe_flag</code> is true, many <code>itensor</code> expressions use the frame
metric <code>ifg</code> instead of the metric defined by <code>imetric</code> for
raising and lowerind indices.
</p>
<p>IMPORTANT: Setting the variable <code>iframe_flag</code> to <code>true</code> does NOT
undefine the contraction properties of a metric defined by a call to
<code>defcon</code> or <code>imetric</code>. If a frame field is used, it is best to
define the metric by assigning its name to the variable <code>imetric</code>
and NOT invoke the <code>imetric</code> function.
</p>
<p>Maxima uses these two tensors to define the frame coefficients (<code>ifc1</code>
and <code>ifc2</code>) which form part of the connection coefficients (<code>icc1</code>
and <code>icc2</code>), as the following example demonstrates:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                               %1     i       i
(%t4)                         v   ifc2     + v
                                      %1 j    ,j
(%i5) ishow(ev(%,ifc2))$
                          %1    i %2                i
(%t5)                    v   ifg     ifc1        + v
                                         %1 j %2    ,j
(%i6) ishow(ev(%,ifc1))$
            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t6)      -------------------------------------------------- + v
                                   2                             ,j
(%i7) ishow(ifb([a,b,c]))$
                                                   %3    %4
(%t7)               (ifri        - ifri       ) ifr   ifr
                         a %3,%4       a %4,%3     b     c

</pre>
<p>An alternate method is used to compute the frame bracket (<code>ifb</code>) if
the <code>iframe_bracket_form</code> flag is set to <code>false</code>:
</p>
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                %6    %5        %5      %6
(%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                       a %5     b     c,%6      b,%6    c

</pre>

<dl>
<dt><u>Function:</u> <b>iframes</b><i> ()</i>
<a name="IDX1066"></a>
</dt>
<dd><p>Since in this version of Maxima, contraction identities for <code>ifr</code> and
<code>ifri</code> are always defined, as is the frame bracket (<code>ifb</code>), this
function does nothing.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifb</b>
<a name="IDX1067"></a>
</dt>
<dd><p>The frame bracket. The contribution of the frame metric to the connection
coefficients is expressed using the frame bracket:
</p>
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre>
<p>The frame bracket itself is defined in terms of the frame field and frame
metric. Two alternate methods of computation are used depending on the
value of <code>frame_bracket_form</code>. If true (the default) or if the
<code>itorsion_flag</code> is <code>true</code>:
</p>
<pre class="example">
          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre>
<p>Otherwise:
</p>
<pre class="example">
             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre>
</dd></dl>


<dl>
<dt><u>Variable:</u> <b>icc1</b>
<a name="IDX1068"></a>
</dt>
<dd><p>Connection coefficients of the first kind. In <code>itensor</code>, defined as
</p>
<pre class="example">
icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre>
<p>In this expression, if <code>iframe_flag</code> is true, the Christoffel-symbol
<code>ichr1</code> is replaced with the frame connection coefficient <code>ifc1</code>.
If <code>itorsion_flag</code> is <code>false</code>, <code>ikt1</code>
will be omitted. It is also omitted if a frame base is used, as the
torsion is already calculated as part of the frame bracket.
Lastly, of <code>inonmet_flag</code> is <code>false</code>,
<code>inmc1</code> will not be present.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>icc2</b>
<a name="IDX1069"></a>
</dt>
<dd><p>Connection coefficients of the second kind. In <code>itensor</code>, defined as
</p>
<pre class="example">
    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre>
<p>In this expression, if <code>iframe_flag</code> is true, the Christoffel-symbol
<code>ichr2</code> is replaced with the frame connection coefficient <code>ifc2</code>.
If <code>itorsion_flag</code> is <code>false</code>, <code>ikt2</code>
will be omitted. It is also omitted if a frame base is used, as the
torsion is already calculated as part of the frame bracket.
Lastly, of <code>inonmet_flag</code> is <code>false</code>,
<code>inmc2</code> will not be present.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifc1</b>
<a name="IDX1070"></a>
</dt>
<dd><p>Frame coefficient of the first kind (also known as Ricci-rotation
coefficients.) This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind. Defined
as:
</p>
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifc2</b>
<a name="IDX1071"></a>
</dt>
<dd><p>Frame coefficient of the first kind. This tensor represents the contribution
of the frame metric to the connection coefficient of the first kind. Defined
as a permutation of the frame bracket (<code>ifb</code>) with the appropriate
indices raised and lowered as necessary:
</p>
<pre class="example">
    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifr</b>
<a name="IDX1072"></a>
</dt>
<dd><p>The frame field. Contracts with the inverse frame field (<code>ifri</code>) to
form the frame metric (<code>ifg</code>).
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifri</b>
<a name="IDX1073"></a>
</dt>
<dd><p>The inverse frame field. Specifies the frame base (dual basis vectors). Along
with the frame metric, it forms the basis of all calculations based on
frames.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifg</b>
<a name="IDX1074"></a>
</dt>
<dd><p>The frame metric. Defaults to <code>kdelta</code>, but can be changed using
<code>components</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ifgi</b>
<a name="IDX1075"></a>
</dt>
<dd><p>The inverse frame metric. Contracts with the frame metric (<code>ifg</code>)
to <code>kdelta</code>.
</p>
</dd></dl>

<dl>
<dt><u>Option variable:</u> <b>iframe_bracket_form</b>
<a name="IDX1076"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>Specifies how the frame bracket (<code>ifb</code>) is computed.
</p>
</dd></dl>

<hr size="6">
<a name="SEC138"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC137" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC139" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.6 Torsion and nonmetricity </h3>

<p>Maxima can now take into account torsion and nonmetricity. When the flag
<code>itorsion_flag</code> is set to <code>true</code>, the contribution of torsion
is added to the connection coefficients. Similarly, when the flag
<code>inonmet_flag</code> is true, nonmetricity components are included.
</p>
<dl>
<dt><u>Variable:</u> <b>inm</b>
<a name="IDX1077"></a>
</dt>
<dd><p>The nonmetricity vector. Conformal nonmetricity is defined through the
covariant derivative of the metric tensor. Normally zero, the metric
tensor's covariant derivative will evaluate to the following when
<code>inonmet_flag</code> is set to <code>true</code>:
</p>
<pre class="example">
g     =- g  inm
 ij;k     ij   k

</pre>
</dd></dl>


<dl>
<dt><u>Variable:</u> <b>inmc1</b>
<a name="IDX1078"></a>
</dt>
<dd><p>Covariant permutation of the nonmetricity vector components. Defined as
</p>
<pre class="example">
           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>inmc2</b>
<a name="IDX1079"></a>
</dt>
<dd><p>Contravariant permutation of the nonmetricity vector components. Used
in the connection coefficients if <code>inonmet_flag</code> is <code>true</code>. Defined
as:
</p>
<pre class="example">
                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ikt1</b>
<a name="IDX1080"></a>
</dt>
<dd><p>Covariant permutation of the torsion tensor (also known as contorsion).
Defined as:
</p>
<pre class="example">
                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>ikt2</b>
<a name="IDX1081"></a>
</dt>
<dd><p>Contravariant permutation of the torsion tensor (also known as contorsion).
Defined as:
</p>
<pre class="example">
    c     cd
ikt2   = g   ikt1
    ab           abd

</pre>
<p>(Substitute <code>ifg</code> in place of <code>g</code> if a frame metric is used.)
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>itr</b>
<a name="IDX1082"></a>
</dt>
<dd><p>The torsion tensor. For a metric with torsion, repeated covariant
differentiation on a scalar function will not commute, as demonstrated
by the following example:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre>
</dd></dl>

<hr size="6">
<a name="SEC139"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC138" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC140" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.7 Exterior algebra </h3>

<p>The <code>itensor</code> package can perform operations on totally antisymmetric
covariant tensor fields. A totally antisymmetric tensor field of rank
(0,L) corresponds with a differential L-form. On these objects, a
multiplication operation known as the exterior product, or wedge product,
is defined.
</p>
<p>Unfortunately, not all authors agree on the definition of the wedge
product. Some authors prefer a definition that corresponds with the
notion of antisymmetrization: in these works, the wedge product of
two vector fields, for instance, would be defined as
</p>
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre>
<p>More generally, the product of a p-form and a q-form would be defined as
</p>
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>where <code>D</code> stands for the Kronecker-delta.
</p>
<p>Other authors, however, prefer a &quot;geometric&quot; definition that corresponds
with the notion of the volume element:
</p>
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre>
<p>and, in the general case
</p>
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre>
<p>Since <code>itensor</code> is a tensor algebra package, the first of these two
definitions appears to be the more natural one. Many applications, however,
utilize the second definition. To resolve this dilemma, a flag has been
implemented that controls the behavior of the wedge product: if
<code>igeowedge_flag</code> is <code>false</code> (the default), the first, &quot;tensorial&quot;
definition is used, otherwise the second, &quot;geometric&quot; definition will
be applied.
</p>
<dl>
<dt><u>Operator:</u> <b>~</b>
<a name="IDX1083"></a>
</dt>
<dd><p>The wedge product operator is denoted by the tilde <code>~</code>. This is
a binary operator. Its arguments should be expressions involving scalars,
covariant tensors of rank one, or covariant tensors of rank <code>l</code> that
have been declared antisymmetric in all covariant indices.
</p>
<p>The behavior of the wedge product operator is controlled by the
<code>igeowedge_flag</code> flag, as in the following example:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre>
</dd></dl>

<dl>
<dt><u>Operator:</u> <b>|</b>
<a name="IDX1084"></a>
</dt>
<dd><p>The vertical bar <code>|</code> denotes the &quot;contraction with a vector&quot; binary
operation. When a totally antisymmetric covariant tensor is contracted
with a contravariant vector, the result is the same regardless which index
was used for the contraction. Thus, it is possible to define the
contraction operation in an index-free manner.
</p>
<p>In the <code>itensor</code> package, contraction with a vector is always carried out
with respect to the first index in the literal sorting order. This ensures
better simplification of expressions involving the <code>|</code> operator. For instance:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre>
<p>Note that it is essential that the tensors used with the <code>|</code> operator be
declared totally antisymmetric in their covariant indices. Otherwise,
the results will be incorrect.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>extdiff</b><i> (<var>expr</var>, <var>i</var>)</i>
<a name="IDX1085"></a>
</dt>
<dd><p>Computes the exterior derivative of <var>expr</var> with respect to the index
<var>i</var>. The exterior derivative is formally defined as the wedge
product of the partial derivative operator and a differential form. As
such, this operation is also controlled by the setting of <code>igeowedge_flag</code>.
For instance:
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                    - (a      - a      + a     )
                             k j,i    k i,j    j i,k

</pre>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>hodge</b><i> (<var>expr</var>)</i>
<a name="IDX1086"></a>
</dt>
<dd><p>Compute the Hodge-dual of <var>expr</var>. For instance:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre>
</dd></dl>

<dl>
<dt><u>Option variable:</u> <b>igeowedge_flag</b>
<a name="IDX1087"></a>
</dt>
<dd><p>Default value: <code>false</code>
</p>
<p>Controls the behavior of the wedge product and exterior derivative. When
set to <code>false</code> (the default), the notion of differential forms will
correspond with that of a totally antisymmetric covariant tensor field.
When set to <code>true</code>, differential forms will agree with the notion
of the volume element.
</p>
</dd></dl>

<hr size="6">
<a name="SEC140"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC139" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC141" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.8 Exporting TeX expressions </h3>

<p>The <code>itensor</code> package provides limited support for exporting tensor
expressions to TeX. Since <code>itensor</code> expressions appear as function calls,
the regular Maxima <code>tex</code> command will not produce the expected
output. You can try instead the <code>tentex</code> command, which attempts
to translate tensor expressions into appropriately indexed TeX objects.
</p>
<dl>
<dt><u>Function:</u> <b>tentex</b><i> (<var>expr</var>)</i>
<a name="IDX1088"></a>
</dt>
<dd><p>To use the <code>tentex</code> function, you must first load <code>tentex</code>,
as in the following example:
</p>
<pre class="example">
(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(tentex);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

</pre>
<p>Note the use of the <code>idummyx</code> assignment, to avoid the appearance
of the percent sign in the TeX expression, which may lead to compile errors.
</p>
<p>NB: This version of the <code>tentex</code> function is somewhat experimental.
</p>
</dd></dl>

<hr size="6">
<a name="SEC141"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC140" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC142" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.9 Interfacing with ctensor </h3>

<p>The <code>itensor</code> package has the ability to generate Maxima code that can
then be executed in the context of the <code>ctensor</code> package. The function that performs
this task is <code>ic_convert</code>.
</p>
<dl>
<dt><u>Function:</u> <b>ic_convert</b><i> (<var>eqn</var>)</i>
<a name="IDX1089"></a>
</dt>
<dd><p>Converts the <code>itensor</code> equation <var>eqn</var> to a <code>ctensor</code> assignment statement.
Implied sums over dummy indices are made explicit while indexed
objects are transformed into arrays (the array subscripts are in the
order of covariant followed by contravariant indices of the indexed
objects). The derivative of an indexed object will be replaced by the
noun form of <code>diff</code> taken with respect to <code>ct_coords</code> subscripted
by the derivative index. The Christoffel symbols <code>ichr1</code> and <code>ichr2</code>
will be translated to <code>lcs</code> and <code>mcs</code>, respectively and if
<code>metricconvert</code> is <code>true</code> then all occurrences of the metric
with two covariant (contravariant) indices will be renamed to <code>lg</code>
(<code>ug</code>). In addition, <code>do</code> loops will be introduced summing over
all free indices so that the
transformed assignment statement can be evaluated by just doing
<code>ev</code>. The following examples demonstrate the features of this
function.
</p>
<pre class="example">(%i1) load(itensor);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre>
</dd></dl>

<hr size="6">
<a name="SEC142"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC141" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC143" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.2.10 Reserved words </h3>

<p>The following Maxima words are used by the <code>itensor</code> package internally and
should not be redefined:
</p>
<pre class="example">  Keyword    Comments
  ------------------------------------------
  indices2() Internal version of indices()
  conti      Lists contravariant indices
  covi       Lists covariant indices of a indexed object
  deri       Lists derivative indices of an indexed object
  name       Returns the name of an indexed object
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre>



<hr size="6">
<a name="Introduction-to-ctensor"></a>
<a name="SEC143"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC142" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.3 Introduction to ctensor </h2>

<p><code>ctensor</code> is a component tensor manipulation package.  To use the 
<code>ctensor</code> package, type <code>load(ctensor)</code>.
To begin an interactive session with <code>ctensor</code>, type <code>csetup()</code>.  
You are first asked to specify the dimension of the manifold. If the dimension
is 2, 3 or 4 then the list of coordinates defaults to <code>[x,y]</code>, 
<code>[x,y,z]</code> or <code>[x,y,z,t]</code> respectively.
These names may be changed by assigning a new list of coordinates to
the variable <code>ct_coords</code> (described below) and the user is queried about
this. Care must be taken to avoid the coordinate names conflicting
with other object definitions.
</p>
<p>Next, the user enters the metric either directly or from a file by
specifying its ordinal position.
The metric is stored in the matrix
<code>lg</code>. Finally, the metric inverse is computed and stored in the matrix
<code>ug</code>. One has the option of carrying out all calculations in a power
series.
</p>
<p>A sample protocol is begun below for the static, spherically symmetric
metric (standard coordinates) which will be applied to the problem of
deriving Einstein's vacuum equations (which lead to the Schwarzschild
solution) as an example. Many of the functions in <code>ctensor</code> will be
displayed for the standard metric as examples.
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)      /share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system:
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none
depends([a,d],x);
Do you wish to see the metric?
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done

</pre>
<hr size="6">
<a name="Functions-and-Variables-for-ctensor"></a>
<a name="SEC144"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC143" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC145" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.4 Functions and Variables for ctensor </h2>
<hr size="6">
<a name="SEC145"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC144" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC146" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.1 Initialization and setup </h3>

<p><a name="csetup"></a>
</p><dl>
<dt><u>Function:</u> <b>csetup</b><i> ()</i>
<a name="IDX1090"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package
which initializes the package and allows the user to enter a metric
interactively. See <code>ctensor</code> for more details.
</p>
</dd></dl>

<p><a name="cmetric"></a>
</p><dl>
<dt><u>Function:</u> <b>cmetric</b><i> (<var>dis</var>)</i>
<a name="IDX1091"></a>
</dt>
<dt><u>Function:</u> <b>cmetric</b><i> ()</i>
<a name="IDX1092"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package
that computes the metric inverse and sets up the package for
further calculations.
</p>
<p>If <code>cframe_flag</code> is <code>false</code>, the function computes the inverse metric
<code>ug</code> from the (user-defined) matrix <code>lg</code>. The metric determinant is
also computed and stored in the variable <code>gdet</code>. Furthermore, the
package determines if the metric is diagonal and sets the value
of <code>diagmetric</code> accordingly. If the optional argument <var>dis</var>
is present and not equal to <code>false</code>, the user is prompted to see
the metric inverse.
</p>
<p>If <code>cframe_flag</code> is <code>true</code>, the function expects that the values of
<code>fri</code> (the inverse frame matrix) and <code>lfg</code> (the frame metric) are
defined. From these, the frame matrix <code>fr</code> and the inverse frame
metric <code>ufg</code> are computed.
</p>
</dd></dl>

<p><a name="ct_005fcoordsys"></a>
</p><dl>
<dt><u>Function:</u> <b>ct_coordsys</b><i> (<var>coordinate_system</var>, <var>extra_arg</var>)</i>
<a name="IDX1093"></a>
</dt>
<dt><u>Function:</u> <b>ct_coordsys</b><i> (<var>coordinate_system</var>)</i>
<a name="IDX1094"></a>
</dt>
<dd><p>Sets up a predefined coordinate system and metric. The argument
<var>coordinate_system</var> can be one of the following symbols:
</p>
<pre class="example"> SYMBOL             Dim Coordinates     Description/comments
 ------------------------------------------------------------------
 cartesian2d           2  [x,y]             Cartesian 2D coordinate
                                            system
 polar                 2  [r,phi]           Polar coordinate system
 elliptic              2  [u,v]             Elliptic coord. system
 confocalelliptic      2  [u,v]             Confocal elliptic
                                            coordinates
 bipolar               2  [u,v]             Bipolar coord. system
 parabolic             2  [u,v]             Parabolic coord. system
 cartesian3d           3  [x,y,z]           Cartesian 3D coordinate
                                            system
 polarcylindrical      3  [r,theta,z]       Polar 2D with
                                            cylindrical z
 ellipticcylindrical   3  [u,v,z]           Elliptic 2D with
                                            cylindrical z
 confocalellipsoidal   3  [u,v,w]           Confocal ellipsoidal
 bipolarcylindrical    3  [u,v,z]           Bipolar 2D with
                                            cylindrical z
 paraboliccylindrical  3  [u,v,z]           Parabolic 2D with
                                            cylindrical z
 paraboloidal          3  [u,v,phi]         Paraboloidal coords.
 conical               3  [u,v,w]           Conical coordinates
 toroidal              3  [u,v,phi]         Toroidal coordinates
 spherical             3  [r,theta,phi]     Spherical coord. system
 oblatespheroidal      3  [u,v,phi]         Oblate spheroidal
                                            coordinates
 oblatespheroidalsqrt  3  [u,v,phi]
 prolatespheroidal     3  [u,v,phi]         Prolate spheroidal
                                            coordinates
 prolatespheroidalsqrt 3  [u,v,phi]
 ellipsoidal           3  [r,theta,phi]     Ellipsoidal coordinates
 cartesian4d           4  [x,y,z,t]         Cartesian 4D coordinate
                                            system
 spherical4d           4  [r,theta,eta,phi] Spherical 4D coordinate
                                            system
 exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild metric
 interiorschwarzschild 4  [t,z,u,v]         Interior Schwarzschild
                                            metric
 kerr_newman           4  [t,r,theta,phi]   Charged axially
                                            symmetric metric
</pre>
<p><code>coordinate_system</code> can also be a list of transformation functions,
followed by a list containing the coordinate variables. For instance,
you can specify a spherical metric as follows:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                   r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3
</pre>
<p>Transformation functions can also be used when <code>cframe_flag</code> is 
<code>true</code>:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
(%o4)
 [cos(phi)cos(theta) -cos(phi) r sin(theta) -sin(phi) r cos(theta)]
 [                                                                ]
 [sin(phi)cos(theta) -sin(phi) r sin(theta)  cos(phi) r cos(theta)]
 [                                                                ]
 [    sin(theta)           r cos(theta)                0          ]

(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

</pre>
<p>The optional argument <var>extra_arg</var> can be any one of the following:
</p>
<p><code>cylindrical</code> tells <code>ct_coordsys</code> to attach an additional cylindrical 
coordinate.
</p>
<p><code>minkowski</code> tells <code>ct_coordsys</code> to attach an additional coordinate 
with negative metric signature.
</p>
<p><code>all</code> tells <code>ct_coordsys</code> to call <code>cmetric</code> and 
<code>christof(false)</code> after setting up the metric.
</p>
<p>If the global variable <code>verbose</code> is set to <code>true</code>, <code>ct_coordsys</code> 
displays the values of <code>dim</code>, <code>ct_coords</code>, and either <code>lg</code> or 
<code>lfg</code> and <code>fri</code>, depending on the value of <code>cframe_flag</code>.
</p>
</dd></dl>

<p><a name="init_005fctensor"></a>
</p><dl>
<dt><u>Function:</u> <b>init_ctensor</b><i> ()</i>
<a name="IDX1095"></a>
</dt>
<dd><p>Initializes the <code>ctensor</code> package.
</p>
<p>The <code>init_ctensor</code> function reinitializes the <code>ctensor</code> package. It 
removes all arrays and matrices used by <code>ctensor</code>, resets all flags, resets
<code>dim</code> to 4, and resets the frame metric to the Lorentz-frame.
</p>
</dd></dl>

<hr size="6">
<a name="SEC146"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC145" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC147" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.2 The tensors of curved space </h3>

<p>The main purpose of the <code>ctensor</code> package is to compute the tensors
of curved space(time), most notably the tensors used in general
relativity.
</p>
<p>When a metric base is used, <code>ctensor</code> can compute the following tensors:
</p>
<pre class="example"> lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem
</pre>
<p><code>ctensor</code> can also work using moving frames. When <code>cframe_flag</code> is
set to <code>true</code>, the following tensors can be calculated:
</p>
<pre class="example"> lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem
</pre>
<p><a name="christof"></a>
</p><dl>
<dt><u>Function:</u> <b>christof</b><i> (<var>dis</var>)</i>
<a name="IDX1096"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package.  It computes the 
Christoffel symbols of both kinds.  The argument <var>dis</var> determines which 
results are to be immediately displayed.  The Christoffel symbols of the first 
and second kinds are stored in the arrays <code>lcs[i,j,k]</code> and 
<code>mcs[i,j,k]</code> respectively and defined to be symmetric in the first two 
indices.  If the argument to <code>christof</code> is <code>lcs</code> or <code>mcs</code> then 
the unique non-zero values of <code>lcs[i,j,k]</code> or <code>mcs[i,j,k]</code>, 
respectively, will be displayed. If the argument is <code>all</code> then the unique 
non-zero values of <code>lcs[i,j,k]</code> and <code>mcs[i,j,k]</code> will be displayed.  
If the argument is <code>false</code> then the display of the elements will not occur.
The array elements <code>mcs[i,j,k]</code> are defined in such a manner that the final
index is contravariant.
</p>
</dd></dl>
  
<p><a name="ricci"></a>
</p><dl>
<dt><u>Function:</u> <b>ricci</b><i> (<var>dis</var>)</i>
<a name="IDX1097"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package. <code>ricci</code> 
computes the covariant (symmetric) components <code>ric[i,j]</code> of the Ricci 
tensor.  If the argument <var>dis</var> is <code>true</code>, then the non-zero components 
are displayed.
</p>
</dd></dl>

<p><a name="uricci"></a>
</p><dl>
<dt><u>Function:</u> <b>uricci</b><i> (<var>dis</var>)</i>
<a name="IDX1098"></a>
</dt>
<dd><p>This function first computes the covariant components <code>ric[i,j]</code> of the 
Ricci tensor.  Then the mixed Ricci tensor is computed using the contravariant 
metric tensor.  If the value of the argument <var>dis</var> is <code>true</code>, then 
these mixed components, <code>uric[i,j]</code> (the index <code>i</code> is covariant and 
the index <code>j</code> is contravariant), will be displayed directly.  Otherwise, 
<code>ricci(false)</code> will simply compute the entries of the array 
<code>uric[i,j]</code> without displaying the results.
</p>
</dd></dl>

<p><a name="scurvature"></a>
</p><dl>
<dt><u>Function:</u> <b>scurvature</b><i> ()</i>
<a name="IDX1099"></a>
</dt>
<dd><p>Returns the scalar curvature (obtained by contracting
the Ricci tensor) of the Riemannian manifold with the given metric.
</p>
</dd></dl>

<p><a name="einstein"></a>
</p><dl>
<dt><u>Function:</u> <b>einstein</b><i> (<var>dis</var>)</i>
<a name="IDX1100"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor) package.  <code>einstein</code> 
computes the mixed Einstein tensor after the Christoffel symbols and Ricci 
tensor have been obtained (with the functions <code>christof</code> and <code>ricci</code>).
If the argument <var>dis</var> is <code>true</code>, then the non-zero values of the mixed 
Einstein tensor <code>ein[i,j]</code> will be displayed where <code>j</code> is the 
contravariant index.  The variable <code>rateinstein</code> will cause the rational 
simplification on these components. If <code>ratfac</code> is <code>true</code> then the 
components will also be factored.
</p>
</dd></dl>

<p><a name="leinstein"></a>
</p><dl>
<dt><u>Function:</u> <b>leinstein</b><i> (<var>dis</var>)</i>
<a name="IDX1101"></a>
</dt>
<dd><p>Covariant Einstein-tensor.  <code>leinstein</code> stores the values of the covariant 
Einstein tensor in the array <code>lein</code>.  The covariant Einstein-tensor is 
computed from the mixed Einstein tensor <code>ein</code> by multiplying it with the 
metric tensor.  If the argument <var>dis</var> is <code>true</code>, then the non-zero 
values of the covariant Einstein tensor are displayed.
</p>
</dd></dl>

<p><a name="riemann"></a>
</p><dl>
<dt><u>Function:</u> <b>riemann</b><i> (<var>dis</var>)</i>
<a name="IDX1102"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor)
package.  <code>riemann</code> computes the Riemann curvature tensor
from the given metric and the corresponding Christoffel symbols. The following
index conventions are used:
</p>
<pre class="example">                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
</pre>
<p>This notation is consistent with the notation used by the <code>itensor</code>
package and its <code>icurvature</code> function.
If the optional argument <var>dis</var> is <code>true</code>,
the non-zero components <code>riem[i,j,k,l]</code> will be displayed.
As with the Einstein tensor, various switches set by the user
control the simplification of the components of the Riemann tensor.
If <code>ratriemann</code> is <code>true</code>, then
rational simplification will be done. If <code>ratfac</code>
is <code>true</code> then
each of the components will also be factored.
</p>
<p>If the variable <code>cframe_flag</code> is <code>false</code>, the Riemann tensor is
computed directly from the Christoffel-symbols. If <code>cframe_flag</code> is
<code>true</code>, the covariant Riemann-tensor is computed first from the
frame field coefficients.
</p>
</dd></dl>

<p><a name="lriemann"></a>
</p><dl>
<dt><u>Function:</u> <b>lriemann</b><i> (<var>dis</var>)</i>
<a name="IDX1103"></a>
</dt>
<dd><p>Covariant Riemann-tensor (<code>lriem[]</code>).
</p>
<p>Computes the covariant Riemann-tensor as the array <code>lriem</code>. If the
argument <var>dis</var> is <code>true</code>, unique nonzero values are displayed.
</p>
<p>If the variable <code>cframe_flag</code> is <code>true</code>, the covariant Riemann
tensor is computed directly from the frame field coefficients. Otherwise,
the (3,1) Riemann tensor is computed first.
</p>
<p>For information on index ordering, see <code>riemann</code>.
</p>
</dd></dl>

<p><a name="uriemann"></a>
</p><dl>
<dt><u>Function:</u> <b>uriemann</b><i> (<var>dis</var>)</i>
<a name="IDX1104"></a>
</dt>
<dd><p>Computes the contravariant components of the Riemann
curvature tensor as array elements <code>uriem[i,j,k,l]</code>.  These are displayed
if <var>dis</var> is <code>true</code>.
</p>
</dd></dl>

<p><a name="rinvariant"></a>
</p><dl>
<dt><u>Function:</u> <b>rinvariant</b><i> ()</i>
<a name="IDX1105"></a>
</dt>
<dd><p>Forms the Kretchmann-invariant (<code>kinvariant</code>) obtained by
contracting the tensors
</p>
<pre class="example">lriem[i,j,k,l]*uriem[i,j,k,l].
</pre>
<p>This object is not automatically simplified since it can be very large.
</p>
</dd></dl>

<p><a name="weyl"></a>
</p><dl>
<dt><u>Function:</u> <b>weyl</b><i> (<var>dis</var>)</i>
<a name="IDX1106"></a>
</dt>
<dd><p>Computes the Weyl conformal tensor.  If the argument <var>dis</var> is
<code>true</code>, the non-zero components <code>weyl[i,j,k,l]</code> will be displayed to 
the user.  Otherwise, these components will simply be computed and stored.
If the switch <code>ratweyl</code> is set to <code>true</code>, then the components will be
rationally simplified; if <code>ratfac</code> is <code>true</code> then the results will be
factored as well.
</p>
</dd></dl>

<hr size="6">
<a name="SEC147"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC146" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC148" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.3 Taylor series expansion </h3>

<p>The <code>ctensor</code> package has the ability to truncate results by assuming
that they are Taylor-series approximations. This behavior is controlled by
the <code>ctayswitch</code> variable; when set to true, <code>ctensor</code> makes use
internally of the function <code>ctaylor</code> when simplifying results.
</p>
<p>The <code>ctaylor</code> function is invoked by the following <code>ctensor</code> 
functions:
</p>
<pre class="example">    Function     Comments
    ---------------------------------
    christof()   For mcs only
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
</pre>
<p><a name="ctaylor"></a>
</p><dl>
<dt><u>Function:</u> <b>ctaylor</b><i> ()</i>
<a name="IDX1107"></a>
</dt>
<dd><p>The <code>ctaylor</code> function truncates its argument by converting
it to a Taylor-series using <code>taylor</code>, and then calling
<code>ratdisrep</code>. This has the combined effect of dropping terms
higher order in the expansion variable <code>ctayvar</code>. The order
of terms that should be dropped is defined by <code>ctaypov</code>; the
point around which the series expansion is carried out is specified
in <code>ctaypt</code>.
</p>
<p>As an example, consider a simple metric that is a perturbation of
the Minkowski metric. Without further restrictions, even a diagonal
metric produces expressions for the Einstein tensor that are far too
complex:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],
                [0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
      [ h11 l - 1      0          0                 0            ]
      [                                                          ]
      [     0      h22 l + 1      0                 0            ]
      [                                                          ]
(%o8) [                        2                                 ]
      [     0          0      r  + h33 l            0            ]
      [                                                          ]
      [                                    2    2                ]
      [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 24]
[[2, 3], 0]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 0]
[[3, 3], 46]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 46]
(%o12)                               done
</pre>
<p>However, if we recompute this example as an approximation that is
linear in the variable <code>l</code>, we get much simpler expressions:
</p>
<pre class="example">(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 13]
[[2, 3], 2]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 2]
[[3, 3], 9]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 9]
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                            2               2      4    2
              - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                       r r                r
</pre>
<p>This capability can be useful, for instance, when working in the weak
field limit far from a gravitational source.
</p>
</dd></dl>

<hr size="6">
<a name="SEC148"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC147" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC149" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.4 Frame fields </h3>

<p>When the variable <code>cframe_flag</code> is set to true, the <code>ctensor</code> package
performs its calculations using a moving frame.
</p>
<p><a name="frame_005fbracket"></a>
</p><dl>
<dt><u>Function:</u> <b>frame_bracket</b><i> (<var>fr</var>, <var>fri</var>, <var>diagframe</var>)</i>
<a name="IDX1108"></a>
</dt>
<dd><p>The frame bracket (<code>fb[]</code>).
</p>
<p>Computes the frame bracket according to the following definition:
</p>
<pre class="example">   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
</pre>
</dd></dl>

<hr size="6">
<a name="SEC149"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC148" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC150" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.5 Algebraic classification </h3>

<p>A new feature (as of November, 2004) of <code>ctensor</code> is its ability to
compute the Petrov classification of a 4-dimensional spacetime metric.
For a demonstration of this capability, see the file
<code>share/tensor/petrov.dem</code>.
</p>
<p><a name="nptetrad"></a>
</p><dl>
<dt><u>Function:</u> <b>nptetrad</b><i> ()</i>
<a name="IDX1109"></a>
</dt>
<dd><p>Computes a Newman-Penrose null tetrad (<code>np</code>) and its raised-index
counterpart (<code>npi</code>). See <code>petrov</code> for an example.
</p>
<p>The null tetrad is constructed on the assumption that a four-diemensional
orthonormal frame metric with metric signature (-,+,+,+) is being used.
The components of the null tetrad are related to the inverse frame matrix
as follows:
</p>
<pre class="example">
np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

</pre>
</dd></dl>

<p><a name="ctensor_005fpsi"></a>
</p><dl>
<dt><u>Function:</u> <b>psi</b><i> (<var>dis</var>)</i>
<a name="IDX1110"></a>
</dt>
<dd><p>Computes the five Newman-Penrose coefficients <code>psi[0]</code>...<code>psi[4]</code>.
If <code>psi</code> is set to <code>true</code>, the coefficients are displayed.
See <code>petrov</code> for an example.
</p>
<p>These coefficients are computed from the Weyl-tensor in a coordinate base.
If a frame base is used, the Weyl-tensor is first converted to a coordinate
base, which can be a computationally expensive procedure. For this reason,
in some cases it may be more advantageous to use a coordinate base in the
first place before the Weyl tensor is computed. Note however, that
constructing a Newman-Penrose null tetrad requires a frame base. Therefore,
a meaningful computation sequence may begin with a frame base, which
is then used to compute <code>lg</code> (computed automatically by <code>cmetric</code>
and then <code>ug</code>. At this point, you can switch back to a coordinate base
by setting <code>cframe_flag</code> to false before beginning to compute the
Christoffel symbols. Changing to a frame base at a later stage could yield
inconsistent results, as you may end up with a mixed bag of tensors, some
computed in a frame base, some in a coordinate base, with no means to
distinguish between the two.
</p>
</dd></dl>

<p><a name="petrov"></a>
</p><dl>
<dt><u>Function:</u> <b>petrov</b><i> ()</i>
<a name="IDX1111"></a>
</dt>
<dd><p>Computes the Petrov classification of the metric characterized by 
<code>psi[0]</code> &hellip; <code>psi[4]</code>.
</p>
<p>For example, the following demonstrates how to obtain the Petrov-classification
of the Kerr metric:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np =

[ sqrt(r - 2 m)           sqrt(r)                                 ]
[---------------   ---------------------    0            0        ]
[sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                          ]
[                                                                 ]
[ sqrt(r - 2 m)            sqrt(r)                                ]
[---------------  - ---------------------   0            0        ]
[sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                         ]
[                                                                 ]
[                                          r      %i r sin(theta) ]
[       0                    0          -------   --------------- ]
[                                       sqrt(2)       sqrt(2)     ]
[                                                                 ]
[                                          r       %i r sin(theta)]
[       0                    0          -------  - ---------------]
[                                       sqrt(2)        sqrt(2)    ]

                             sqrt(r)         sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------,---------------, 0, 0],
                      sqrt(2) sqrt(r - 2 m) sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0],
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------],
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D
</pre>
<p>The Petrov classification function is based on the algorithm published in
&quot;Classifying geometries in general relativity: III Classification in practice&quot;
by Pollney, Skea, and d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Except for some simple test cases, the implementation is untested as of
December 19, 2004, and is likely to contain errors.
</p>
</dd></dl>

<hr size="6">
<a name="SEC150"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC149" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC151" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.6 Torsion and nonmetricity </h3>

<p><code>ctensor</code> has the ability to compute and include torsion and nonmetricity
coefficients in the connection coefficients.
</p>
<p>The torsion coefficients are calculated from a user-supplied tensor
<code>tr</code>, which should be a rank (2,1) tensor. From this, the torsion
coefficients <code>kt</code> are computed according to the following formulae:
</p>
<pre class="example">              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm
</pre>
<p>Note that only the mixed-index tensor is calculated and stored in the
array <code>kt</code>.
</p>
<p>The nonmetricity coefficients are calculated from the user-supplied
nonmetricity vector <code>nm</code>. From this, the nonmetricity coefficients
<code>nmc</code> are computed as follows:
</p>
<pre class="example">             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2
</pre>
<p>where D stands for the Kronecker-delta.
</p>
<p>When <code>ctorsion_flag</code> is set to <code>true</code>, the values of <code>kt</code>
are substracted from the mixed-indexed connection coefficients computed by
<code>christof</code> and stored in <code>mcs</code>. Similarly, if <code>cnonmet_flag</code>
is set to <code>true</code>, the values of <code>nmc</code> are substracted from the
mixed-indexed connection coefficients.
</p>
<p>If necessary, <code>christof</code> calls the functions <code>contortion</code> and
<code>nonmetricity</code> in order to compute <code>kt</code> and <code>nm</code>.
</p>
<dl>
<dt><u>Function:</u> <b>contortion</b><i> (<var>tr</var>)</i>
<a name="IDX1112"></a>
</dt>
<dd><p>Computes the (2,1) contortion coefficients from the torsion tensor <var>tr</var>.
</p>
</dd></dl>

<p><a name="nonmetricity"></a>
</p><dl>
<dt><u>Function:</u> <b>nonmetricity</b><i> (<var>nm</var>)</i>
<a name="IDX1113"></a>
</dt>
<dd><p>Computes the (2,1) nonmetricity coefficients from the nonmetricity
vector <var>nm</var>.
</p>
</dd></dl>

<hr size="6">
<a name="SEC151"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC150" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC152" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.7 Miscellaneous features </h3>

<p><a name="ctransform"></a>
</p><dl>
<dt><u>Function:</u> <b>ctransform</b><i> (<var>M</var>)</i>
<a name="IDX1114"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor)
package which will perform a coordinate transformation
upon an arbitrary square symmetric matrix <var>M</var>. The user must input the
functions which define the transformation.  (Formerly called <code>transform</code>.)
</p>
</dd></dl>

<p><a name="findde"></a>
</p><dl>
<dt><u>Function:</u> <b>findde</b><i> (<var>A</var>, <var>n</var>)</i>
<a name="IDX1115"></a>
</dt>
<dd><p>returns a list of the unique differential equations (expressions)
corresponding to the elements of the <var>n</var> dimensional square
array <var>A</var>. Presently, <var>n</var> may be 2 or 3. <code>deindex</code> is a global list
containing the indices of <var>A</var> corresponding to these unique
differential equations. For the Einstein tensor (<code>ein</code>), which
is a two dimensional array, if computed for the metric in the example
below, <code>findde</code> gives the following independent differential equations:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a, 0, 0, 0], [ 0, x^2, 0, 0],
                              [0, 0, x^2*sin(y)^2, 0], [0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x
        x                     x x         x        x    x

                                              2          2
                          + 2 a d d   - 2 a  d , a  x + a  - a]
                                   x       x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]
</pre>
</dd></dl>

<p><a name="cograd"></a>
</p><dl>
<dt><u>Function:</u> <b>cograd</b><i> ()</i>
<a name="IDX1116"></a>
</dt>
<dd><p>Computes the covariant gradient of a scalar function allowing the
user to choose the corresponding vector name as the example under
<code>contragrad</code> illustrates.
</p>
</dd></dl>

<p><a name="contragrad"></a>
</p><dl>
<dt><u>Function:</u> <b>contragrad</b><i> ()</i>
<a name="IDX1117"></a>
</dt>
<dd><p>Computes the contravariant gradient of a scalar function allowing
the user to choose the corresponding vector name as the example
below for the Schwarzschild metric illustrates:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r
</pre>
</dd></dl>

<p><a name="ctensor_005fdscalar"></a>
</p><dl>
<dt><u>Function:</u> <b>dscalar</b><i> ()</i>
<a name="IDX1118"></a>
</dt>
<dd><p>computes the tensor d'Alembertian of the scalar function once
dependencies have been declared upon the function. For example:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
</pre>
</dd></dl>

<p><a name="checkdiv"></a>
</p><dl>
<dt><u>Function:</u> <b>checkdiv</b><i> ()</i>
<a name="IDX1119"></a>
</dt>
<dd><p>computes the covariant divergence of the mixed second rank tensor
(whose first index must be covariant) by printing the
corresponding n components of the vector field (the divergence) where
n = <code>dim</code>. If the argument to the function is <code>g</code> then the
divergence of the Einstein tensor will be formed and must be zero.
In addition, the divergence (vector) is given the array name <code>div</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cgeodesic</b><i> (<var>dis</var>)</i>
<a name="IDX1120"></a>
</dt>
<dd><p>A function in the <code>ctensor</code> (component tensor)
package.  <code>cgeodesic</code> computes the geodesic equations of
motion for a given metric.  They are stored in the array <code>geod[i]</code>.  If
the argument <var>dis</var> is <code>true</code> then these equations are displayed.
</p>
</dd></dl>

<p><a name="bdvac"></a>
</p><dl>
<dt><u>Function:</u> <b>bdvac</b><i> (<var>f</var>)</i>
<a name="IDX1121"></a>
</dt>
<dd><p>generates the covariant components of the vacuum field equations of
the Brans- Dicke gravitational theory. The scalar field is specified
by the argument <var>f</var>, which should be a (quoted) function name
with functional dependencies, e.g., <code>'p(x)</code>.
</p>
<p>The components of the second rank covariant field tensor are
represented by the array <code>bd</code>.
</p>
</dd></dl>

<p><a name="invariant1"></a>
</p><dl>
<dt><u>Function:</u> <b>invariant1</b><i> ()</i>
<a name="IDX1122"></a>
</dt>
<dd><p>generates the mixed Euler- Lagrange tensor (field equations) for the
invariant density of R^2. The field equations are the components of an
array named <code>inv1</code>.
</p>
</dd></dl>

<p><a name="invariant2"></a>
</p><dl>
<dt><u>Function:</u> <b>invariant2</b><i> ()</i>
<a name="IDX1123"></a>
</dt>
<dd><p>*** NOT YET IMPLEMENTED ***
</p>
<p>generates the mixed Euler- Lagrange tensor (field equations) for the
invariant density of <code>ric[i,j]*uriem[i,j]</code>. The field equations are the
components of an array named <code>inv2</code>.
</p>
</dd></dl>

<p><a name="bimetric"></a>
</p><dl>
<dt><u>Function:</u> <b>bimetric</b><i> ()</i>
<a name="IDX1124"></a>
</dt>
<dd><p>*** NOT YET IMPLEMENTED ***
</p>
<p>generates the field equations of Rosen's bimetric theory. The field
equations are the components of an array named <code>rosen</code>.
</p>
</dd></dl>

<hr size="6">
<a name="SEC152"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC151" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC153" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.8 Utility functions </h3>

<p><a name="diagmatrixp"></a>
</p><dl>
<dt><u>Function:</u> <b>diagmatrixp</b><i> (<var>M</var>)</i>
<a name="IDX1125"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>M</var> is a diagonal matrix or (2D) array.
</p>
</dd></dl>

<p><a name="symmetricp"></a>
</p><dl>
<dt><u>Function:</u> <b>symmetricp</b><i> (<var>M</var>)</i>
<a name="IDX1126"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>M</var> is a symmetric matrix or (2D) array.
</p>
</dd></dl>

<p><a name="ntermst"></a>
</p><dl>
<dt><u>Function:</u> <b>ntermst</b><i> (<var>f</var>)</i>
<a name="IDX1127"></a>
</dt>
<dd><p>gives the user a quick picture of the &quot;size&quot; of the doubly subscripted
tensor (array) <var>f</var>.  It prints two element lists where the second
element corresponds to NTERMS of the components specified by the first
elements.  In this way, it is possible to quickly find the non-zero
expressions and attempt simplification.
</p>
</dd></dl>

<p><a name="cdisplay"></a>
</p><dl>
<dt><u>Function:</u> <b>cdisplay</b><i> (<var>ten</var>)</i>
<a name="IDX1128"></a>
</dt>
<dd><p>displays all the elements of the tensor <var>ten</var>, as represented by
a multidimensional array. Tensors of rank 0 and 1, as well as other types
of variables, are displayed as with <code>ldisplay</code>. Tensors of rank 2 are
displayed as 2-dimensional matrices, while tensors of higher rank are displayed
as a list of 2-dimensional matrices. For instance, the Riemann-tensor of
the Schwarzschild metric can be viewed as:
</p>
<pre class="example">(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
          [ 0               0                   0           0     ]
          [                                                       ]
          [                              2                        ]
          [      3 m (r - 2 m)   m    2 m                         ]
          [ 0  - ------------- + -- - ----      0           0     ]
          [            4          3     4                         ]
          [           r          r     r                          ]
          [                                                       ]
riem    = [                                m (r - 2 m)            ]
    1, 1  [ 0               0              -----------      0     ]
          [                                     4                 ]
          [                                    r                  ]
          [                                                       ]
          [                                           m (r - 2 m) ]
          [ 0               0                   0     ----------- ]
          [                                                4      ]
          [                                               r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

             [     2 m                                         ]
             [ ------------  0        0               0        ]
             [  2                                              ]
             [ r  (r - 2 m)                                    ]
             [                                                 ]
             [      0        0        0               0        ]
             [                                                 ]
  riem     = [                         m                       ]
      2, 2   [      0        0  - ------------        0        ]
             [                     2                           ]
             [                    r  (r - 2 m)                 ]
             [                                                 ]
             [                                         m       ]
             [      0        0        0         - ------------ ]
             [                                     2           ]
             [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

           [        2                                             ]
           [   m sin (theta)                                      ]
           [ - -------------         0                0         0 ]
           [         r                                            ]
           [                                                      ]
           [                         2                            ]
           [                    m sin (theta)                     ]
riem     = [        0         - -------------         0         0 ]
    4, 4   [                          r                           ]
           [                                                      ]
           [                                          2           ]
           [                                   2 m sin (theta)    ]
           [        0                0         ---------------  0 ]
           [                                          r           ]
           [                                                      ]
           [        0                0                0         0 ]

(%o5)                                done
</pre>
</dd></dl>

<p><a name="deleten"></a>
</p><dl>
<dt><u>Function:</u> <b>deleten</b><i> (<var>L</var>, <var>n</var>)</i>
<a name="IDX1129"></a>
</dt>
<dd><p>Returns a new list consisting of <var>L</var> with the <var>n</var>'th element
deleted.
</p>
</dd></dl>

<hr size="6">
<a name="SEC153"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC152" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC154" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.9 Variables used by <code>ctensor</code> </h3>

<p><a name="dim"></a>
</p><dl>
<dt><u>Option variable:</u> <b>dim</b>
<a name="IDX1130"></a>
</dt>
<dd><p>Default value: 4
</p>
<p>An option in the <code>ctensor</code> (component tensor)
package.  <code>dim</code> is the dimension of the manifold with the
default 4. The command <code>dim: n</code> will reset the dimension to any other
value <code>n</code>.
</p>
</dd></dl>

<p><a name="diagmetric"></a>
</p><dl>
<dt><u>Option variable:</u> <b>diagmetric</b>
<a name="IDX1131"></a>
</dt>
<dd><p>Default value: <code>false</code>
</p>
<p>An option in the <code>ctensor</code> (component tensor)
package.  If <code>diagmetric</code> is <code>true</code> special routines compute
all geometrical objects (which contain the metric tensor explicitly)
by taking into consideration the diagonality of the metric. Reduced
run times will, of course, result. Note: this option is set
automatically by <code>csetup</code> if a diagonal metric is specified.
</p>
</dd></dl>

<p><a name="ctrgsimp"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctrgsimp</b>
<a name="IDX1132"></a>
</dt>
<dd><p>Causes trigonometric simplifications to be used when tensors are computed. 
Presently, <code>ctrgsimp</code> affects only computations involving a moving frame.
</p>
</dd></dl>

<p><a name="cfram_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>cframe_flag</b>
<a name="IDX1133"></a>
</dt>
<dd><p>Causes computations to be performed relative to a moving frame as opposed to
a holonomic metric. The frame is defined by the inverse frame array <code>fri</code>
and the frame metric <code>lfg</code>. For computations using a Cartesian frame,
<code>lfg</code> should be the unit matrix of the appropriate dimension; for
computations in a Lorentz frame, <code>lfg</code> should have the appropriate
signature.
</p>
</dd></dl>

<p><a name="ctorsion_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctorsion_flag</b>
<a name="IDX1134"></a>
</dt>
<dd><p>Causes the contortion tensor to be included in the computation of the
connection coefficients. The contortion tensor itself is computed by
<code>contortion</code> from the user-supplied tensor <code>tr</code>.
</p>
</dd></dl>

<p><a name="cnonmet_005fflag"></a>
</p><dl>
<dt><u>Option variable:</u> <b>cnonmet_flag</b>
<a name="IDX1135"></a>
</dt>
<dd><p>Causes the nonmetricity coefficients to be included in the computation of
the connection coefficients. The nonmetricity coefficients are computed
from the user-supplied nonmetricity vector <code>nm</code> by the function
<code>nonmetricity</code>.
</p>
</dd></dl>

<p><a name="ctayswitch"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctayswitch</b>
<a name="IDX1136"></a>
</dt>
<dd><p>If set to <code>true</code>, causes some <code>ctensor</code> computations to be carried out
using Taylor-series expansions. Presently, <code>christof</code>, <code>ricci</code>,
<code>uricci</code>, <code>einstein</code>, and <code>weyl</code> take into account this
setting.
</p>
</dd></dl>

<p><a name="ctayvar"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctayvar</b>
<a name="IDX1137"></a>
</dt>
<dd><p>Variable used for Taylor-series expansion if <code>ctayswitch</code> is set to
<code>true</code>.
</p>
</dd></dl>

<p><a name="ctaypov"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctaypov</b>
<a name="IDX1138"></a>
</dt>
<dd><p>Maximum power used in Taylor-series expansion when <code>ctayswitch</code> is
set to <code>true</code>.
</p>
</dd></dl>

<p><a name="ctaypt"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ctaypt</b>
<a name="IDX1139"></a>
</dt>
<dd><p>Point around which Taylor-series expansion is carried out when
<code>ctayswitch</code> is set to <code>true</code>.
</p>
</dd></dl>

<p><a name="gdet"></a>
</p><dl>
<dt><u>System variable:</u> <b>gdet</b>
<a name="IDX1140"></a>
</dt>
<dd><p>The determinant of the metric tensor <code>lg</code>. Computed by <code>cmetric</code> when
<code>cframe_flag</code> is set to <code>false</code>.
</p>
</dd></dl>

<p><a name="ratchristof"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ratchristof</b>
<a name="IDX1141"></a>
</dt>
<dd><p>Causes rational simplification to be applied by <code>christof</code>.
</p>
</dd></dl>

<p><a name="ratstein"></a>
</p><dl>
<dt><u>Option variable:</u> <b>rateinstein</b>
<a name="IDX1142"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>If <code>true</code> rational simplification will be
performed on the non-zero components of Einstein tensors; if
<code>ratfac</code> is <code>true</code> then the components will also be factored.
</p>
</dd></dl>

<p><a name="ratriemann"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ratriemann</b>
<a name="IDX1143"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>One of the switches which controls
simplification of Riemann tensors; if <code>true</code>, then rational
simplification will be done; if <code>ratfac</code> is <code>true</code> then each of the
components will also be factored.
</p>
</dd></dl>

<p><a name="ratweyl"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ratweyl</b>
<a name="IDX1144"></a>
</dt>
<dd><p>Default value: <code>true</code>
</p>
<p>If <code>true</code>, this switch causes the <code>weyl</code> function
to apply rational simplification to the values of the Weyl tensor. If
<code>ratfac</code> is <code>true</code>, then the components will also be factored.
</p>
</dd></dl>

<p><a name="lfg"></a>
</p><dl>
<dt><u>Variable:</u> <b>lfg</b>
<a name="IDX1145"></a>
</dt>
<dd><p>The covariant frame metric. By default, it is initialized to the 4-dimensional 
Lorentz frame with signature (+,+,+,-). Used when <code>cframe_flag</code> is 
<code>true</code>.
</p>
</dd></dl>

<p><a name="ufg"></a>
</p><dl>
<dt><u>Variable:</u> <b>ufg</b>
<a name="IDX1146"></a>
</dt>
<dd><p>The inverse frame metric. Computed from <code>lfg</code> when <code>cmetric</code> is 
called while <code>cframe_flag</code> is set to <code>true</code>.
</p>
</dd></dl>

<p><a name="riem"></a>
</p><dl>
<dt><u>Variable:</u> <b>riem</b>
<a name="IDX1147"></a>
</dt>
<dd><p>The (3,1) Riemann tensor. Computed when the function <code>riemann</code> is invoked. 
For information about index ordering, see the description of <code>riemann</code>.
</p>
<p>If <code>cframe_flag</code> is <code>true</code>, <code>riem</code> is computed from the 
covariant Riemann-tensor <code>lriem</code>.
</p>
</dd></dl>

<p><a name="lriem"></a>
</p><dl>
<dt><u>Variable:</u> <b>lriem</b>
<a name="IDX1148"></a>
</dt>
<dd><p>The covariant Riemann tensor. Computed by <code>lriemann</code>.
</p>
</dd></dl>

<p><a name="uriem"></a>
</p><dl>
<dt><u>Variable:</u> <b>uriem</b>
<a name="IDX1149"></a>
</dt>
<dd><p>The contravariant Riemann tensor. Computed by <code>uriemann</code>.
</p>
</dd></dl>

<p><a name="ric"></a>
</p><dl>
<dt><u>Variable:</u> <b>ric</b>
<a name="IDX1150"></a>
</dt>
<dd><p>The mixed Ricci-tensor. Computed by <code>ricci</code>.
</p>
</dd></dl>

<p><a name="uric"></a>
</p><dl>
<dt><u>Variable:</u> <b>uric</b>
<a name="IDX1151"></a>
</dt>
<dd><p>The contravariant Ricci-tensor. Computed by <code>uricci</code>.
</p>
</dd></dl>

<p><a name="lg"></a>
</p><dl>
<dt><u>Variable:</u> <b>lg</b>
<a name="IDX1152"></a>
</dt>
<dd><p>The metric tensor. This tensor must be specified (as a <code>dim</code> by 
<code>dim</code> matrix) before other computations can be performed.
</p>
</dd></dl>

<p><a name="ug"></a>
</p><dl>
<dt><u>Variable:</u> <b>ug</b>
<a name="IDX1153"></a>
</dt>
<dd><p>The inverse of the metric tensor. Computed by <code>cmetric</code>.
</p>
</dd></dl>

<p><a name="variable_005fweyl"></a>
</p><dl>
<dt><u>Variable:</u> <b>weyl</b>
<a name="IDX1154"></a>
</dt>
<dd><p>The Weyl tensor. Computed by <code>weyl</code>.
</p>
</dd></dl>

<p><a name="fb"></a>
</p><dl>
<dt><u>Variable:</u> <b>fb</b>
<a name="IDX1155"></a>
</dt>
<dd><p>Frame bracket coefficients, as computed by <code>frame_bracket</code>.
</p>
</dd></dl>

<p><a name="kinvariant"></a>
</p><dl>
<dt><u>Variable:</u> <b>kinvariant</b>
<a name="IDX1156"></a>
</dt>
<dd><p>The Kretchmann invariant. Computed by <code>rinvariant</code>.
</p>
</dd></dl>

<p><a name="np"></a>
</p><dl>
<dt><u>Variable:</u> <b>np</b>
<a name="IDX1157"></a>
</dt>
<dd><p>A Newman-Penrose null tetrad. Computed by <code>nptetrad</code>.
</p>
</dd></dl>

<p><a name="npi"></a>
</p><dl>
<dt><u>Variable:</u> <b>npi</b>
<a name="IDX1158"></a>
</dt>
<dd><p>The raised-index Newman-Penrose null tetrad. Computed by <code>nptetrad</code>.
Defined as <code>ug.np</code>. The product <code>np.transpose(npi)</code> is constant:
</p>
<pre class="example">(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
</pre>
</dd></dl>

<p><a name="tr"></a>
</p><dl>
<dt><u>Variable:</u> <b>tr</b>
<a name="IDX1159"></a>
</dt>
<dd><p>User-supplied rank-3 tensor representing torsion. Used by <code>contortion</code>.
</p>
</dd></dl>

<p><a name="kt"></a>
</p><dl>
<dt><u>Variable:</u> <b>kt</b>
<a name="IDX1160"></a>
</dt>
<dd><p>The contortion tensor, computed from <code>tr</code> by <code>contortion</code>.
</p>
</dd></dl>

<p><a name="nm"></a>
</p><dl>
<dt><u>Variable:</u> <b>nm</b>
<a name="IDX1161"></a>
</dt>
<dd><p>User-supplied nonmetricity vector. Used by <code>nonmetricity</code>.
</p>
</dd></dl>

<p><a name="nmc"></a>
</p><dl>
<dt><u>Variable:</u> <b>nmc</b>
<a name="IDX1162"></a>
</dt>
<dd><p>The nonmetricity coefficients, computed from <code>nm</code> by <code>nonmetricity</code>.
</p>
</dd></dl>

<p><a name="tensorkill"></a>
</p><dl>
<dt><u>System variable:</u> <b>tensorkill</b>
<a name="IDX1163"></a>
</dt>
<dd><p>Variable indicating if the tensor package has been initialized. Set and used by
<code>csetup</code>, reset by <code>init_ctensor</code>.
</p>
</dd></dl>

<p><a name="ct_005fcoords"></a>
</p><dl>
<dt><u>Option variable:</u> <b>ct_coords</b>
<a name="IDX1164"></a>
</dt>
<dd><p>Default value: <code>[]</code>
</p>
<p>An option in the <code>ctensor</code> (component tensor)
package.  <code>ct_coords</code> contains a list of coordinates.
While normally defined when the function <code>csetup</code> is called,
one may redefine the coordinates with the assignment
<code>ct_coords: [j1, j2, ..., jn]</code> where the j's are the new coordinate names.
See also <code>csetup</code>.
</p>
</dd></dl>

<hr size="6">
<a name="SEC154"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC153" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC155" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.10 Reserved names </h3>

<p>The following names are used internally by the <code>ctensor</code> package and
should not be redefined:
</p>
<pre class="example">  Name         Description
  ---------------------------------------------------------------------
  _lg()        Evaluates to lfg if frame metric used, lg otherwise
  _ug()        Evaluates to ufg if frame metric used, ug otherwise
  cleanup()    Removes items drom the deindex list
  contract4()  Used by psi()
  filemet()    Used by csetup() when reading the metric from a file
  findde1()    Used by findde()
  findde2()    Used by findde()
  findde3()    Used by findde()
  kdelt()      Kronecker-delta (not generalized)
  newmet()     Used by csetup() for setting up a metric interactively
  setflags()   Used by init_ctensor()
  readvalue()
  resimp()
  sermet()     Used by csetup() for entering a metric as Taylor-series
  txyzsum()
  tmetric()    Frame metric, used by cmetric() when cframe_flag:true
  triemann()   Riemann-tensor in frame base, used when cframe_flag:true
  tricci()     Ricci-tensor in frame base, used when cframe_flag:true
  trrc()       Ricci rotation coefficients, used by christof()
  yesp()
</pre>
<hr size="6">
<a name="SEC155"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC154" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC156" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC144" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 20.4.11 Changes </h3>

<p>In November, 2004, the <code>ctensor</code> package was extensively rewritten.
Many functions and variables have been renamed in order to make the
package compatible with the commercial version of Macsyma.
</p>
<pre class="example">  New Name     Old Name        Description
  ---------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
  lgeod[]      EM              Geodesic equations
  ein[]        G[]             Mixed Einstein-tensor
  ric[]        LR[]            Mixed Ricci-tensor
  ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
  ctaypov      MINP            Maximum power in Taylor-series expansion
  cgeodesic()  MOTION          Compute geodesic equations
  ct_coords    OMEGA           Metric coordinates
  ctayvar      PARAM           Taylor-series expansion variable
  lriem[]      R[]             Covariant Riemann-tensor
  uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
  ratriemann   RATRIEMAN       Rational simplif. of the Riemann-tensor
  uric[]       RICCI[]         Contravariant Ricci-tensor
  uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
  cmetric()    SETMETRIC()     Set up the metric
  ctaypt       TAYPT           Point for Taylor-series expansion
  ctayswitch   TAYSWITCH       Taylor-series setting switch
  csetup()     TSETUP()        Start interactive setup session
  ctransform() TTRANSFORM()    Interactive coordinate transformation
  uriem[]      UR[]            Contravariant Riemann-tensor
  weyl[]       W[]             (3,1) Weyl-tensor
</pre>




<hr size="6">
<a name="Introduction-to-atensor"></a>
<a name="SEC156"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC155" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC157" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.5 Introduction to atensor </h2>

<p><code>atensor</code> is an algebraic tensor manipulation package. To use 
<code>atensor</code>, type <code>load(atensor)</code>, followed by a call to the 
<code>init_atensor</code> function.
</p>
<p>The essence of <code>atensor</code> is a set of simplification rules for the
noncommutative (dot) product operator (&quot;<code>.</code>&quot;). <code>atensor</code> recognizes
several algebra types; the corresponding simplification rules are put
into effect when the <code>init_atensor</code> function is called.
</p>
<p>The capabilities of <code>atensor</code> can be demonstrated by defining the
algebra of quaternions as a Clifford-algebra Cl(0,2) with two basis
vectors. The three quaternionic imaginary units are then the two
basis vectors and their product, i.e.:
</p>
<pre class="example">    i = v     j = v     k = v  . v
         1         2         1    2
</pre>
<p>Although the <code>atensor</code> package has a built-in definition for the
quaternion algebra, it is not used in this example, in which we
endeavour to build the quaternion multiplication table as a matrix:
</p>
<pre class="example">(%i1) load(atensor);
(%o1)       /share/tensor/atensor.mac
(%i2) init_atensor(clifford,0,0,2);
(%o2)                                done
(%i3) atensimp(v[1].v[1]);
(%o3)                                 - 1
(%i4) atensimp((v[1].v[2]).(v[1].v[2]));
(%o4)                                 - 1
(%i5) q:zeromatrix(4,4);
                                [ 0  0  0  0 ]
                                [            ]
                                [ 0  0  0  0 ]
(%o5)                           [            ]
                                [ 0  0  0  0 ]
                                [            ]
                                [ 0  0  0  0 ]
(%i6) q[1,1]:1;
(%o6)                                  1
(%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
(%o7)                                done
(%i8) q[1,4]:q[4,1]:v[1].v[2];
(%o8)                               v  . v
                                     1    2
(%i9) for i from 2 thru 4 do for j from 2 thru 4 do
         q[i,j]:atensimp(q[i,1].q[1,j]);
(%o9)                                done
(%i10) q;
                   [    1        v         v      v  . v  ]
                   [              1         2      1    2 ]
                   [                                      ]
                   [   v         - 1     v  . v    - v    ]
                   [    1                 1    2      2   ]
(%o10)             [                                      ]
                   [   v      - v  . v     - 1      v     ]
                   [    2        1    2              1    ]
                   [                                      ]
                   [ v  . v      v        - v       - 1   ]
                   [  1    2      2          1            ]
</pre>
<p><code>atensor</code> recognizes as base vectors indexed symbols, where the symbol
is that stored in <code>asymbol</code> and the index runs between 1 and <code>adim</code>.
For indexed symbols, and indexed symbols only, the bilinear forms
<code>sf</code>, <code>af</code>, and <code>av</code> are evaluated. The evaluation
substitutes the value of <code>aform[i,j]</code> in place of <code>fun(v[i],v[j])</code>
where <code>v</code> represents the value of <code>asymbol</code> and <code>fun</code> is
either <code>af</code> or <code>sf</code>; or, it substitutes <code>v[aform[i,j]]</code>
in place of <code>av(v[i],v[j])</code>.
</p>
<p>Needless to say, the functions <code>sf</code>, <code>af</code> and <code>av</code>
can be redefined.
</p>
<p>When the <code>atensor</code> package is loaded, the following flags are set:
</p>
<pre class="example">dotscrules:true;
dotdistrib:true;
dotexptsimp:false;
</pre>
<p>If you wish to experiment with a nonassociative algebra, you may also
consider setting <code>dotassoc</code> to <code>false</code>. In this case, however,
<code>atensimp</code> will not always be able to obtain the desired
simplifications.
</p>
<hr size="6">
<a name="Functions-and-Variables-for-atensor"></a>
<a name="SEC157"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC156" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 20.6 Functions and Variables for atensor </h2>

<p><a name="init_005fatensor"></a>
</p><dl>
<dt><u>Function:</u> <b>init_atensor</b><i> (<var>alg_type</var>, <var>opt_dims</var>)</i>
<a name="IDX1165"></a>
</dt>
<dt><u>Function:</u> <b>init_atensor</b><i> (<var>alg_type</var>)</i>
<a name="IDX1166"></a>
</dt>
<dd><p>Initializes the <code>atensor</code> package with the specified algebra type. 
<var>alg_type</var> can be one of the following:
</p>
<p><code>universal</code>: The universal algebra has no commutation rules.
</p>
<p><code>grassmann</code>: The Grassman algebra is defined by the commutation
relation <code>u.v+v.u=0</code>.
</p>
<p><code>clifford</code>: The Clifford algebra is defined by the commutation
relation <code>u.v+v.u=-2*sf(u,v)</code> where <code>sf</code> is a symmetric
scalar-valued function. For this algebra, <var>opt_dims</var> can be up
to three nonnegative integers, representing the number of positive,
degenerate, and negative dimensions of the algebra, respectively. If
any <var>opt_dims</var> values are supplied, <code>atensor</code> will configure the
values of <code>adim</code> and <code>aform</code> appropriately. Otherwise,
<code>adim</code> will default to 0 and <code>aform</code> will not be defined.
</p>
<p><code>symmetric</code>: The symmetric algebra is defined by the commutation
relation <code>u.v-v.u=0</code>.
</p>
<p><code>symplectic</code>: The symplectic algebra is defined by the commutation
relation <code>u.v-v.u=2*af(u,v)</code> where <code>af</code> is an antisymmetric
scalar-valued function. For the symplectic algebra, <var>opt_dims</var> can
be up to two nonnegative integers, representing the nondegenerate and
degenerate dimensions, respectively. If any <var>opt_dims</var> values are
supplied, <code>atensor</code> will configure the values of <code>adim</code> and 
<code>aform</code> appropriately. Otherwise, <code>adim</code> will default to 0 and 
<code>aform</code> will not be defined.
</p>
<p><code>lie_envelop</code>: The algebra of the Lie envelope is defined by the
commutation relation <code>u.v-v.u=2*av(u,v)</code> where <code>av</code> is
an antisymmetric function.
</p>
<p>The <code>init_atensor</code> function also recognizes several predefined
algebra types:
</p>
<p><code>complex</code> implements the algebra of complex numbers as the
Clifford algebra Cl(0,1). The call <code>init_atensor(complex)</code> is
equivalent to <code>init_atensor(clifford,0,0,1)</code>.
</p>
<p><code>quaternion</code> implements the algebra of quaternions. The call
<code>init_atensor (quaternion)</code> is equivalent to
<code>init_atensor (clifford,0,0,2)</code>.
</p>
<p><code>pauli</code> implements the algebra of Pauli-spinors as the Clifford-algebra
Cl(3,0). A call to <code>init_atensor(pauli)</code> is equivalent to
<code>init_atensor(clifford,3)</code>.
</p>
<p><code>dirac</code> implements the algebra of Dirac-spinors as the Clifford-algebra
Cl(3,1). A call to <code>init_atensor(dirac)</code> is equivalent to
<code>init_atensor(clifford,3,0,1)</code>.
</p>
</dd></dl>

<p><a name="atensimp"></a>
</p><dl>
<dt><u>Function:</u> <b>atensimp</b><i> (<var>expr</var>)</i>
<a name="IDX1167"></a>
</dt>
<dd><p>Simplifies an algebraic tensor expression <var>expr</var> according to the rules
configured by a call to <code>init_atensor</code>. Simplification includes
recursive application of commutation relations and resolving calls
to <code>sf</code>, <code>af</code>, and <code>av</code> where applicable. A
safeguard is used to ensure that the function always terminates, even
for complex expressions.
</p>
</dd></dl>

<p><a name="alg_005ftype"></a>
</p><dl>
<dt><u>Function:</u> <b>alg_type</b>
<a name="IDX1168"></a>
</dt>
<dd><p>The algebra type. Valid values are <code>universal</code>, <code>grassmann</code>,
<code>clifford</code>, <code>symmetric</code>, <code>symplectic</code> and <code>lie_envelop</code>.
</p>
</dd></dl>

<p><a name="adim"></a>
</p><dl>
<dt><u>Variable:</u> <b>adim</b>
<a name="IDX1169"></a>
</dt>
<dd><p>Default value: 0
</p>
<p>The dimensionality of the algebra. <code>atensor</code> uses the value of <code>adim</code>
to determine if an indexed object is a valid base vector.  See <code>abasep</code>.
</p>
</dd></dl>

<p><a name="aform"></a>
</p><dl>
<dt><u>Variable:</u> <b>aform</b>
<a name="IDX1170"></a>
</dt>
<dd><p>Default value: <code>ident(3)</code>
</p>
<p>Default values for the bilinear forms <code>sf</code>, <code>af</code>, and
<code>av</code>. The default is the identity matrix <code>ident(3)</code>.
</p>
</dd></dl>

<p><a name="asymbol"></a>
</p><dl>
<dt><u>Variable:</u> <b>asymbol</b>
<a name="IDX1171"></a>
</dt>
<dd><p>Default value: <code>v</code>
</p>
<p>The symbol for base vectors.
</p>
</dd></dl>

<p><a name="sf"></a>
</p><dl>
<dt><u>Function:</u> <b>sf</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1172"></a>
</dt>
<dd><p>A symmetric scalar function that is used in commutation relations.
The default implementation checks if both arguments are base vectors
using <code>abasep</code> and if that is the case, substitutes the
corresponding value from the matrix <code>aform</code>.
</p>
</dd></dl>

<p><a name="af"></a>
</p><dl>
<dt><u>Function:</u> <b>af</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1173"></a>
</dt>
<dd><p>An antisymmetric scalar function that is used in commutation relations.
The default implementation checks if both arguments are base vectors
using <code>abasep</code> and if that is the case, substitutes the
corresponding value from the matrix <code>aform</code>.
</p>
</dd></dl>

<p><a name="av"></a>
</p><dl>
<dt><u>Function:</u> <b>av</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1174"></a>
</dt>
<dd><p>An antisymmetric function that is used in commutation relations.
The default implementation checks if both arguments are base vectors
using <code>abasep</code> and if that is the case, substitutes the
corresponding value from the matrix <code>aform</code>.
</p>
<p>For instance:
</p>
<pre class="example">(%i1) load(atensor);
(%o1)       /share/tensor/atensor.mac
(%i2) adim:3;
(%o2)                                  3
(%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                               [  0    3   - 2 ]
                               [               ]
(%o3)                          [ - 3   0    1  ]
                               [               ]
                               [  2   - 1   0  ]
(%i4) asymbol:x;
(%o4)                                  x
(%i5) av(x[1],x[2]);
(%o5)                                 x
                                       3
</pre>
</dd></dl>

<p><a name="abasep"></a>
</p><dl>
<dt><u>Function:</u> <b>abasep</b><i> (<var>v</var>)</i>
<a name="IDX1175"></a>
</dt>
<dd><p>Checks if its argument is an <code>atensor</code> base vector. That is, if it is
an indexed symbol, with the symbol being the same as the value of
<code>asymbol</code>, and the index having a numeric value between 1
and <code>adim</code>.
</p>
</dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC128" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC158" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC404" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>August, 1 2011</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
