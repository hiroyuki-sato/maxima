<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on April, 4 2011 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 18. Gleichungen</title>

<meta name="description" content="Maxima Manual: 18. Gleichungen">
<meta name="keywords" content="Maxima Manual: 18. Gleichungen">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: 1px solid gray;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    /* background: rgb(247,242,180); */ /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    background-color: #F1F5F9; /* light blue-gray */
    /* font-family: "Lucida Console", monospace */
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}

div.categorybox
{
    border: 1px solid gray;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,220);
}


-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="de" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Gleichungen"></a>
<a name="SEC114"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_17.html#SEC113" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC115" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_17.html#SEC111" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC116" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 18. Gleichungen </h1>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC115">18.1 Funktionen und Variablen f&uuml;r Gleichungen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Funktionen-und-Variablen-f_00fcr-Gleichungen"></a>
<a name="SEC115"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC114" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC116" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC114" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC114" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC116" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 18.1 Funktionen und Variablen f&uuml;r Gleichungen </h2>


<p><a name="g_t_0025rnum"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>%rnum</b>
<a name="IDX866"></a>
</dt>
<dd><p>Standardwert: 0
</p>
<p>Wenn notwendig, erzeugen die Funktionen <code>solve</code> und <code>algsys</code> 
Parameter, die in die L&ouml;sungen eingesetzt werden.  Die Parameter haben den 
Namen <code>%r&lt;<var>num</var>&gt;</code>.  <code>%rnum</code> enth&auml;lt die Nummer <var>num</var>, die an 
den Pr&auml;fix <code>%r</code> angeh&auml;ngt wird.  Maxima erh&ouml;ht <code>%rnum</code> 
automatisch.  Siehe auch die Systemvariable <code><a href="#g_t_0025rnum_005flist">%rnum_list</a></code>
 f&uuml;r eine Liste 
der Parameter einer L&ouml;sung.
</p></dd></dl>

<p><a name="g_t_0025rnum_005flist"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>%rnum_list</b>
<a name="IDX867"></a>
</dt>
<dd><p>Standardwert: <code>[]</code>
</p>


<p><code>%rnum_list</code> ist die Liste der Parameter, die von <code>solve</code> und 
<code>algsys</code> in L&ouml;sungen eingesetzt werden.  Die Parameter werden der Liste 
<code>%rnum_list</code> hinzugef&uuml;gt, in der Reihenfolge in der sie erzeugt werden.
</p>
<pre class="example">(%i1) solve ([x + y = 3], [x,y]);
(%o1)              [[x = 3 - %r1, y = %r1]]
(%i2) %rnum_list;
(%o2)                       [%r1]
(%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
(%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
(%i4) %rnum_list;
(%o4)                     [%r2, %r3]
(%i5) for i : 1 thru length (%rnum_list) do
        sol : subst (t[i], %rnum_list[i], sol)$
(%i6) sol;
(%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                     2      1           2       1
</pre></dd></dl>

<p><a name="algexact"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>algexact</b>
<a name="IDX868"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>



<p><code>algexact</code> kontrolliert die Funktion <code>algsys</code> folgenderma&szlig;en:
</p>
<ul>
<li>
Hat <code>algexact</code> den Wert <code>true</code>, wird von der Funktion <code>algsys</code> 
stets <code>solve</code> aufgerufen.  Findet <code>solve</code> keine L&ouml;sung, wird die 
Funktion <code>realroots</code> aufgerufen.

</li><li>
Hat <code>algexact</code> den Wert <code>false</code>, wird die Funktion <code>solve</code> f&uuml;r
Gleichungen aufgerufen, die von mehr als einer Variablen abh&auml;ngen oder f&uuml;r
quadratische oder kubische Gleichungen.
</li></ul>


<p>Der Wert <code>true</code> f&uuml;r <code>algexact</code> garantiert nicht, dass <code>algsys</code> 
nur exakte L&ouml;sungen findet.  Findet <code>algsys</code> keine exakten 
L&ouml;sungen, versucht die Funktion N&auml;herungsl&ouml;sungen zu finden.
</p></dd></dl>

<p><a name="algepsilon"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>algepsilon</b>
<a name="IDX869"></a>
</dt>
<dd><p>Standardwert: 10^8
</p>

<p>Kontrolliert die Genauigkeit einer numerischen L&ouml;sung der Funktion 
<code><a href="#algsys">algsys</a></code>.
</p>
</dd></dl>

<p><a name="algsys"></a>
</p><dl>
<dt><u>Funktion:</u> <b>algsys</b><i> ([<var>expr_1</var>, &hellip;, <var>expr_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX870"></a>
</dt>
<dt><u>Funktion:</u> <b>algsys</b><i> ([<var>eqn_1</var>, &hellip;, <var>eqn_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX871"></a>
</dt>
<dd>
<p>L&ouml;st ein Gleichungsystem mit den Polynomen <var>expr_1</var>, &hellip;, <var>expr_m</var> 
oder den Gleichungen <var>eqn_1</var>, &hellip;, <var>eqn_m</var> f&uuml;r die Variablen 
<var>x_1</var>, &hellip;, <var>x_n</var>.  Werden Polynome <var>expr_i</var> als Argument 
&uuml;bergeben, werden diese als Gleichungen <var>x_i = 0</var> interpretiert.  Die 
Anzahl der Gleichungen und Variablen kann verschieden sein.
</p>

<p><code>algsys</code> gibt eine Liste mit den L&ouml;sungen zur&uuml;ck.  Jede L&ouml;sung ist
wiederum eine Liste mit den L&ouml;sungen f&uuml;r die einzelnen Variablen <var>x_i</var>.
Kann <code>algsys</code> keine L&ouml;sung finden, wird eine leere Liste <code>[]</code>
zur&uuml;ckgegeben.
</p>

<p>Haben die L&ouml;sungen freie Parameter setzt <code>algsys</code> die Symbole <code>%r1</code>,
<code>%r2</code>, &hellip; in die L&ouml;sungen ein.  Die Parameter werden der Liste 
<code>%rnum_list</code> hinzugef&uuml;gt.  Siehe <code><a href="#g_t_0025rnum_005flist">%rnum_list</a></code>.
</p>

<p>Die Funktion <code>algsys</code> verwendet die folgenden Schritte, um L&ouml;sungen eines
Gleichungsystems zu finden:
</p>
<ol>
<li>
Die Gleichungen werden faktorisiert und in Teilsysteme aufgeteilt.


</li><li>
F&uuml;r jedes Teilsystem <var>S_i</var> werden eine Gleichung <var>E</var> und eine Variable 
<var>x</var> ausgew&auml;hlt, die den niedrigsten von Null verschiedenen Grad hat.  Dann
wird die Resultante der Gleichungen <var>E</var> und <var>E_j</var> f&uuml;r die Variable 
<var>x</var> sowie allen verbleibenden Gleichungen <var>E_j</var> des Teilsystems 
<var>S_i</var> berechnet.  Dieses Verfahren eliminiert die Variable <var>x</var> und
hat ein neues Teilsystem <var>S_i'</var> als Ergebnis.  Der Algorithmus wiederholt 
nun den 1. Schritt.






</li><li>
Besteht das Teilsystem nur noch aus einer Gleichung, hat diese Gleichung
mehrere Variablen und enth&auml;lt diese keine Gleitkommazahlen, dann wird 
<code>solve</code> aufgerufen, um eine exakte L&ouml;sung zu finden.

<p>Es kann sein, dass <code>solve</code> keine L&ouml;sung oder einen sehr gro&szlig;en 
Ausdruck als L&ouml;sung findet. 
</p>
<p>Auch f&uuml;r Gleichungen, die nur eine Variable enthalten und die entweder linear,
quadratisch oder quartisch sind sowie keine Gleitkommazahlen enthalten, wird 
<code>solve</code> aufgerufen, um eine exakte L&ouml;sung zu finden.  Trifft dies nicht 
zu, wird die Funktion <code>realroots</code> aufgerufen, wenn der Schalter 
<code>realonly</code> den Wert <code>true</code> hat.  Ansonsten wird die Funktion 
<code>allroots</code> aufgerufen.  Die Funktion <code>realroots</code> sucht reelle L&ouml;sung 
der Gleichung, w&auml;hrend die Funktion <code>allroots</code> auch komplex L&ouml;sungen 
sucht.
</p>
<p>Die Genauigkeit einer numerischen L&ouml;sung wird von der Optionsvariablen 
<code>algepsilon</code> kontrolliert.
</p>
<p>Hat die Optionsvariable <code>algexact</code> den Wert <code>true</code>, wird immer die
Funktion <code>solve</code> aufgerufen.
</p>




</li><li>
Zuletzt werden die erhaltenen L&ouml;sungen in das betrachtete Teilsystem 
eingesetzt und der L&ouml;sungsalgorithmus mit dem 1. Schritt fortgesetzt.
</li></ol>

<p>Tritt beim L&ouml;sen des Gleichungssystems eine Gleichung auf, die von mehreren
Variablen abh&auml;ngt und Gleitkommazahlen enth&auml;lt, dann wird der Algorithmus 
mit der Meldung &quot;<code>algsys</code> cannot solve - system too complicated.&quot; 
abgebrochen.  Ein N&auml;herung mit Gleitkommazahlen kann in vorgehenden Schritten 
auftreten, wenn keine exakten L&ouml;sungen auffindbar sind.
</p>
<p>Ist das Argument der Funktion <code>allroots</code> kein Polynom, gibt Maxima eine
Fehlermeldung.  Die L&ouml;sungen eines Gleichungssystems k&ouml;nnen sehr gro&szlig;e 
Ausdr&uuml;cke sein.  Obwohl die L&ouml;sung reell ist, kann die imagin&auml;re Einheit 
<code>%i</code> in den L&ouml;sungen enthalten sein.  F&uuml;r die weitere Bearbeitung der 
L&ouml;sungen k&ouml;nnen die Funktionen <code>pickapart</code> oder <code>reval</code> n&uuml;tzlich
sein.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
</pre></dd></dl>

<p><a name="allroots"></a>
</p><dl>
<dt><u>Funktion:</u> <b>allroots</b><i> (<var>expr</var>)</i>
<a name="IDX872"></a>
</dt>
<dt><u>Funktion:</u> <b>allroots</b><i> (<var>eqn</var>)</i>
<a name="IDX873"></a>
</dt>
<dd>
<p>Berechnet numerische N&auml;herungen der reellen und komplexen Wurzeln 
des Polynoms <var>expr</var> oder der Polynomgleichung <var>eqn</var> mit einer Variable.
</p>

<p>Hat der Schalter <code>polyfactor</code> den Wert <code>true</code>, wird das Polynom
&uuml;ber die reellen oder komplexen Zahlen faktorisiert.
</p>

<p>F&uuml;r den Fall mehrfacher Wurzeln kann <code>allroots</code> ungenaue Ergebnisse 
liefern.  Ist das Polynom reell, kann <code>allroots (%i*<var>p</var>)</code>) genauere 
Approximationen liefern als <code>allroots (<var>p</var>)</code>, da <code>allroots</code> in 
diesem Fall einen anderen Algorithmus verwendet. 
</p>

<p>Der Z&auml;hler des Arguments der Funktion <code>allroots</code> muss nach Anwendung der
Funktion <code>rat</code> ein Polynom sein und darf im Nenner h&ouml;chstens eine 
komplexe Zahl enthalten.  Ist das Argument der Funktion <code>allroots</code> kein 
Polynom, gibt Maxima eine Fehlermeldung.  Hat die Optionsvariable 
<code>polyfactor</code> den Wert <code>true</code>, wird ein &auml;quivalenter, faktorisierter 
Ausdruck zur&uuml;ckgegeben, der die N&auml;herungen f&uuml;r die Nullstellen enth&auml;lt.
</p>

<p>F&uuml;r komplexe Polynome wird ein Algorithmus von Jenkins und Traub verwendet 
(Algorithm 419, <i>Comm. ACM</i>, vol. 15, (1972), p. 97).
F&uuml;r reelle Polynome wird ein Algorithmus von Jenkins verwendet
(Algorithm 493, <i>ACM TOMS</i>,vol. 1, (1975), p.178).
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
</pre></dd></dl>

<p><a name="bfallroots"></a>
</p><dl>
<dt><u>Funktion:</u> <b>bfallroots</b><i> (<var>expr</var>)</i>
<a name="IDX874"></a>
</dt>
<dt><u>Funktion:</u> <b>bfallroots</b><i> (<var>eqn</var>)</i>
<a name="IDX875"></a>
</dt>
<dd>
<p>Berechnet numerische N&auml;herungen der reellen und komplexen Wurzeln des Polynoms 
<var>expr</var> oder der Polynomgleichung <var>eqn</var> mit einer Variable.
</p>

<p><code>bfallroots</code> entspricht in jeder Hinsicht der Funktion <code>allroots</code> mit
dem Unterschied, dass <code>bfallroots</code> die N&auml;herungen mit gro&szlig;en
Gleitkommazahlen berechnet.  Siehe <code><a href="#allroots">allroots</a></code>.
</p>
</dd></dl>

<p><a name="backsubst"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>backsubst</b>
<a name="IDX876"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>backsubst</code> den Wert <code>false</code>, werden die L&ouml;sungen der Funktion
<code>linsolve</code> nicht r&uuml;cksubstituiert.  Dies kann hilfreich sein, wenn die
R&uuml;cksubstitution zu sehr gro&szlig;en Ausdr&uuml;cken f&uuml;hrt.
</p>
<pre class="example">(%i1) eq1 : x + y + z = 6$
(%i2) eq2 : x - y + z = 2$
(%i3) eq3 : x + y - z = 0$
(%i4) backsubst : false$
(%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
(%o5)             [x = z - y, y = 2, z = 3]
(%i6) backsubst : true$
(%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
(%o7)               [x = 1, y = 2, z = 3]
</pre></dd></dl>

<p><a name="breakup"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>breakup</b>
<a name="IDX877"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Haben die Optionsvariablen <code>programmode</code> und <code>breakup</code> den Wert 
<code>true</code>, werden Zwischenmarken f&uuml;r gemeinsame Terme in L&ouml;sungen von 
kubischen und quartischen Gleichungen erzeugt.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
</pre></dd></dl>

<p><a name="dimension"></a>
</p><dl>
<dt><u>Funktion:</u> <b>dimension</b><i> (<var>eqn</var>)</i>
<a name="IDX878"></a>
</dt>
<dt><u>Funktion:</u> <b>dimension</b><i> (<var>eqn_1</var>, &hellip;, <var>eqn_n</var>)</i>
<a name="IDX879"></a>
</dt>
<dd>

<p><code>dimen</code> ist ein Paket f&uuml;r die Dimensionsanalysis.  <code>load(dimen)</code> 
l&auml;dt dieses Paket.  <code>demo(dimen)</code> zeigt eine kleine Demonstration.
</p></dd></dl>

<p><a name="dispflag"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>dispflag</b>
<a name="IDX880"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>dispflag</code> den Wert <code>false</code>, werden Ausgaben der Funktion
<code>solve</code> unterdr&uuml;ckt, die erzeugt werden, wenn die Optionsvariable
<code>programmmode</code> den Wert <code>false</code> hat.
</p></dd></dl>

<p><a name="funcsolve"></a>
</p><dl>
<dt><u>Funktion:</u> <b>funcsolve</b><i> (<var>eqn</var>, <var>g</var>(<var>t</var>))</i>
<a name="IDX881"></a>
</dt>
<dd>
<p>Das Argument ist eine Gleichung <var>eqn</var>, die ein Polynom erster Ordnung in den
Funktionen <code><var>g</var>(<var>t</var>)</code> und <code><var>g</var>(<var>t+1</var>)</code> ist. 
<code>funcsolve</code> sucht die rationale Funktion <code><var>g</var>(<var>t</var>)</code>, die
L&ouml;sung der Gleichung <var>eqn</var> ist.
</p>
<pre class="example">(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
      (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Dependent equations eliminated:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
</pre>

<p>Warnung: Die Funktion ist nur sehr rudiment&auml;r implementiert.  Offensichtliche
Verallgemeinerungen fehlen.
</p></dd></dl>

<dl>
<dt><u>Optionsvariable:</u> <b>globalsolve</b>
<a name="IDX882"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>globalsolve</code> den Wert <code>true</code>, werden den unbekannten Variablen
eines linearen Gleichungssystems die Werte der L&ouml;sung der Funktionen
<code>linsolve</code> und <code>solve</code> zugewiesen.
</p>

<p>Hat <code>globalsolve</code> den Wert <code>false</code>, werden den unbekannten Variablen
eines linearen Gleichungssystems keine Werte zugewiesen.  Die L&ouml;sungen werden 
als Gleichungen mit den unbekannten Variablen ausgedr&uuml;ckt.
</p>

<p>F&uuml;r andere als lineare Gleichungssysteme wird der Wert von <code>globalsolve</code>
ignoriert.  <code>algsys</code> ignoriert <code>globalsolve</code> immer.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
</pre></dd></dl>

<p><a name="ieqn"></a>
</p><dl>
<dt><u>Funktion:</u> <b>ieqn</b><i> (<var>ie</var>, <var>unk</var>, <var>tech</var>, <var>n</var>, <var>guess</var>)</i>
<a name="IDX883"></a>
</dt>
<dd>
<p><code>inteqn</code> ist ein Paket zur L&ouml;sung von Integralgleichungen der Form 
<code>p(x) = q( x, p(x), 'integrate(w(x,u,p(x),p(u)),u,a(x),b(x)) )</code> (zweiter 
Art, <code>secondkind</code>) und <code>'integrate(w(x,u,p(u)),u,a(x),b(x)) = f(x)</code> 
(erster Art, <code>firstkind</code>).  <code>load (&quot;inteqn&quot;)</code> l&auml;dt dieses Paket.
</p>

<p><var>ie</var> ist die Integralgleichung; <var>unk</var> ist die unbekannte Funktion 
einschlie&szlig;lich angegebener Abh&auml;ngigkeit; <var>tech</var> ist die Technik, die 
zur L&ouml;sung angewendet werden soll (<var>tech</var> = <code>first</code> bedeutet, dass 
die verf&uuml;gbaren L&ouml;sungstechniken der Reihe nach angewandt werden und das 
Ergebnis der ersten erfolgreichen L&ouml;sung wird zur&uuml;ckgegeben; <var>tech</var> = 
<code>all</code> bedeutet, dass alle Techniken angewandt werden); <var>n</var> ist die 
maximale Anzahl an Termen, die f&uuml;r <code>taylor</code>, <code>neumann</code>, 
<code>firstkindseries</code> oder <code>fredseries</code> verwendet werden (es ist ebenso 
die maximale Tiefe der Rekursion f&uuml;r die Differentiationsmethode); <var>guess</var>
ist der Startwert f&uuml;r <code>neumann</code> oder <code>firstkindseries</code>.
</p>

<p>Standardwerte f&uuml;r den 2ten bis 5ten Parameter sind:
</p>

<p><var>unk</var>: <code><var>p</var>(<var>x</var>)</code>, wobei <var>p</var> die als erste im Integranden
aufgefundene Funktion ist, die f&uuml;r Maxima unbekannt ist, und <var>x</var> ist die 
Variable, die im Falle einer <code>secondkind</code>-Gleichung als Argument des ersten
<var>p</var> au&szlig;erhalb des Integrals vorgefunden wird, oder im Falle einer 
<code>firstkind</code>-Gleichung die einzige andere Variable neben der 
Integrationsvariable.  Wenn der Versuch, <var>x</var> zu finden, fehlschl&auml;gt, wird 
der Nutzer gefragt, eine unabh&auml;ngige Variable anzugeben.
</p>
<p><var>tech</var>: <code>first</code>
</p>
<p><var>n</var>: 1
</p>

<p><var>guess</var>: <code>none</code>, was bewirkt, dass <code>neumann</code> und 
<code>firstkindseries</code> <code><var>f</var>(<var>x</var>)</code> als Startwert verwenden.
</p>
<p>Siehe share/integequations/inteqn.usg f&uuml;r weitere Informationen.
</p></dd></dl>

<p><a name="ieqnprint"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>ieqnprint</b>
<a name="IDX884"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>



<p><code>ieqnprint</code> regelt die Darstellung des Ergebnisses, das durch den Befehl 
<code>ieqn</code> zur&uuml;ckgegeben wird.  Wenn <code>ieqnprint</code> <code>true</code> ist,
ist die von der <code>ieqn</code>-Funktion zur&uuml;ckgegebene Liste von der Form 
</p>
<p>   [<var>solution</var>, <var>technique used</var>, <var>nterms</var>, <var>flag</var>]
</p>
<p>wobei <var>flag</var> nicht vorkommt, wenn die L&ouml;sung exakt ist.
</p>

<p>Andernfalls ist <code>approximate</code> bzw. <code>incomplete</code> das Wort, das sich auf 
eine nicht exakte bzw. nicht geschlossene Form der L&ouml;sung bezieht.  Wird eine
Reihenmethode angewandt, gibt <var>nterms</var> die Anzahl der verwendeten Terme (die
kleiner als das in <code>ieqn</code> angegebene <var>n</var> sein kann, wenn ein Fehler die
Erzeugung weiterer Terme verhindert). 
</p></dd></dl>

<p><a name="lhs"></a>
</p><dl>
<dt><u>Funktion:</u> <b>lhs</b><i> (<var>expr</var>)</i>
<a name="IDX885"></a>
</dt>
<dd>
<p>Gibt die linke Seite, das ist das erste Argument, des Ausdrucks <var>expr</var> 
zur&uuml;ck, wenn der Operator von <var>expr</var> einer der relationalen Operatoren
<code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>, einer der Zuweisungsoperatoren 
<code>:= ::= : ::</code> oder ein nutzerdefinierter bin&auml;rer Infixoperator ist, der 
mit der Funktion deklariert durch <code>infix</code> deklariert wurde.
</p>

<p>Wenn <var>expr</var> ein Atom ist oder sein Operator ein anderer als oben 
aufgelistet, gibt <code>lhs</code> den Ausdruck <var>expr</var> zur&uuml;ck.  Siehe auch 
<code><a href="#rhs">rhs</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa &lt; bb), lhs (aa &lt;= bb), lhs (aa &gt;= bb),
       lhs (aa &gt; bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
       lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
</pre></dd></dl>

<p><a name="linsolve"></a>
</p><dl>
<dt><u>Funktion:</u> <b>linsolve</b><i> ([<var>expr_1</var>, &hellip;, <var>expr_m</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX886"></a>
</dt>
<dd>
<p>L&ouml;st das Gleichungssystem mit den Gleichungen oder Polynomen 
[<var>expr_1</var>, &hellip;, <var>expr_m</var>] und den Variablen [<var>x_1</var>, &hellip;, 
<var>x_n</var>].  Jede Gleichung muss ein Polynom in den angegebenen Variablen sein.
</p>

<p>Hat <code>globalsolve</code> den Wert <code>true</code>, werden die L&ouml;sungen des 
Gleichungssystems den angegebenen Variablen zugewiesen.
</p>

<p>Hat <code>backsubst</code> den Wert <code>false</code>, f&uuml;hrt <code>linsolve</code> keine 
R&uuml;cksubstitutionen aus.  Dies kann hilfreich sein, wenn die R&uuml;cksubstitution
zu sehr gro&szlig;en Ausdr&uuml;cken f&uuml;hrt.
</p>

<p>Hat <code>linsolve_params</code> den Wert <code>true</code>, setzt <code>linsolve</code> f&uuml;r ein
unterbestimmtes Gleichungssystem freie Parameter in die L&ouml;sungen ein, die mit 
<code>%r</code>-Symbolen bezeichnet werden.  Siehe auch <code><a href="#g_t_0025rnum">%rnum</a></code>
 und 
<code><a href="#g_t_0025rnum_005flist">%rnum_list</a></code>.
</p>


<p>Hat <code>programmode</code> den Wert <code>false</code>, gibt <code>linsolve</code> die 
L&ouml;sungen  mit Hilfe von Zwischenmarken <code>%t</code> aus.  Die Zwischenmarken 
werden als Liste zur&uuml;ckgegeben.
</p>
<pre class="example">(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
</pre></dd></dl>


<p><a name="linsolvewarn"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>linsolvewarn</b>
<a name="IDX887"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>linsolvewarn</code> den Wert <code>true</code>, gibt <code>linsolve</code> 
gegebenenfalls die Meldung &quot;Dependent equations eliminated&quot; aus.
</p></dd></dl>

<p><a name="linsolve_005fparams"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>linsolve_params</b>
<a name="IDX888"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>linsolve_params</code> den Wert <code>true</code>, setzt <code>linsolve</code> f&uuml;r ein
unterbestimmtes Gleichungssystem freie Parameter in die L&ouml;sungen ein, die mit 
<code>%r</code>-Symbolen bezeichnet werden.  Siehe auch <code><a href="#g_t_0025rnum">%rnum</a></code>
 und 
<code><a href="#g_t_0025rnum_005flist">%rnum_list</a></code>.
</p>
</dd></dl>

<p><a name="multiplicities"></a>
</p><dl>
<dt><u>Systemvariable:</u> <b>multiplicities</b>
<a name="IDX889"></a>
</dt>
<dd><p>Standardwert: <code>not_set_yet</code>
</p>

<p><code>multiplicities</code> ist die Liste der Vielfachheiten der  
L&ouml;sungen, die von <code>solve</code>, <code>realroots</code> oder <code>allroots</code> 
zur&uuml;ckgegeben werden.
</p></dd></dl>

<p><a name="nroots"></a>
</p><dl>
<dt><u>Funktion:</u> <b>nroots</b><i> (<var>p</var>, <var>low</var>, <var>high</var>)</i>
<a name="IDX890"></a>
</dt>
<dd>
<p>Gibt die Anzahl der reellen Wurzeln des reellen univariaten Polynoms <var>p</var> im 
halboffenen Intervall <code>(<var>low</var>, <var>high</var>]</code> zur&uuml;ck. 
Die Grenzen des Intervalls k&ouml;nnen auch negativ unendlich <code>minf</code> oder 
positiv unendlich <code>inf</code> sein.
</p>

<p><code>nroots</code> verwendet die Methode der Sturm-Sequenzen.
</p>
<pre class="example">(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
</pre></dd></dl>

<p><a name="nthroot"></a>
</p><dl>
<dt><u>Funktion:</u> <b>nthroot</b><i> (<var>p</var>, <var>n</var>)</i>
<a name="IDX891"></a>
</dt>
<dd>
<p>Das Argument <var>p</var> ist ein Polynom mit ganzzahligen Koeffizienten und das
Argument <var>n</var> eine positive ganze Zahl.  <code>nthroot</code> gibt ein Polynom 
<em>q</em> &uuml;ber den ganzen Zahlen zur&uuml;ck, so dass <em>q^n = p</em> gilt. 
Existiert kein derartiges Polynom <var>q</var> gibt Maxima eine Fehlermeldung.  Diese
Funktion ist wesentlich schneller als <code>factor</code> oder <code>sqfr</code>.
</p></dd></dl>

<dl>
<dt><u>Optionsvariable:</u> <b>polyfactor</b>
<a name="IDX892"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat die Optionsvariable <code>polyfactor</code> den Wert <code>true</code>, werden die
L&ouml;sungen der Funktionen <code>allroots</code> und <code>bfallroots</code> &uuml;ber die 
reellen Zahlen, f&uuml;r reelle Polynome, und die komplexen Zahlen, f&uuml;r komplexe 
Polynome, faktorisiert.
</p>
<p>Siehe <code><a href="#allroots">allroots</a></code>
 f&uuml;r ein Beispiel.
</p></dd></dl>

<p><a name="programmode"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>programmode</b>
<a name="IDX893"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>programmode</code> den Wert <code>true</code>, geben die Funktionen <code>solve</code>, 
<code>realroots</code>, <code>allroots</code>, <code>bfallroots</code> und <code>linsolve</code> 
die L&ouml;sungen als Elemente einer Liste zur&uuml;ck.
</p>

<p>Hat <code>programmode</code> den Wert <code>false</code>, werden die L&ouml;sungen der oben 
genannten Funktionen Zwischenmarken <code>%t</code> zugewiesen.  Die R&uuml;ckgabe der 
Funktionen ist in diesem Fall eine Liste der Zwischenmarken.
</p></dd></dl>

<p><a name="realonly"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>realonly</b>
<a name="IDX894"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>realonly</code> den Wert <code>true</code>, gibt <code>algsys</code> nur L&ouml;sungen 
zur&uuml;ck, die nicht die imagin&auml;re Einheit <code>%i</code> enthalten.
</p></dd></dl>

<p><a name="realroots"></a>
</p><dl>
<dt><u>Funktion:</u> <b>realroots</b><i> (<var>expr</var>, <var>bound</var>)</i>
<a name="IDX895"></a>
</dt>
<dt><u>Funktion:</u> <b>realroots</b><i> (<var>eqn</var>, <var>bound</var>)</i>
<a name="IDX896"></a>
</dt>
<dt><u>Funktion:</u> <b>realroots</b><i> (<var>expr</var>)</i>
<a name="IDX897"></a>
</dt>
<dt><u>Funktion:</u> <b>realroots</b><i> (<var>eqn</var>)</i>
<a name="IDX898"></a>
</dt>
<dd><p>Computes rational approximations of the real roots of the polynomial <var>expr</var>
or polynomial equation <var>eqn</var> of one variable, to within a tolerance of 
<var>bound</var>.  Coefficients of <var>expr</var> or <var>eqn</var> must be literal numbers;
symbol constants such as <code>%pi</code> are rejected.
</p>
<p><code>realroots</code> assigns the multiplicities of the roots it finds to the global 
variable <code>multiplicities</code>.
</p>
<p><code>realroots</code> constructs a Sturm sequence to bracket each root, and then 
applies bisection to refine the approximations.  All coefficients are converted 
to rational equivalents before searching for roots, and computations are carried
out by exact rational arithmetic.  Even if some coefficients are floating-point 
numbers, the results are rational (unless coerced to floats by the <code>float</code> 
or <code>numer</code> flags).
</p>
<p>When <var>bound</var> is less than 1, all integer roots are found exactly.  When 
<var>bound</var> is unspecified, it is assumed equal to the global variable 
<code>rootsepsilon</code>.
</p>
<p>When the global variable <code>programmode</code> is <code>true</code>, <code>realroots</code> 
returns a list of the form <code>[x = <var>x_1</var>, x = <var>x_2</var>, ...]</code>.  When 
<code>programmode</code> is <code>false</code>, <code>realroots</code> creates intermediate 
expression labels <code>%t1</code>, <code>%t2</code>, ..., assigns the results to them, and 
returns the list of labels.
</p>
<p>Examples:
</p>
<pre class="example">(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
</pre>
<pre class="example">(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
</pre></dd></dl>

<p><a name="rhs"></a>
</p><dl>
<dt><u>Funktion:</u> <b>rhs</b><i> (<var>expr</var>)</i>
<a name="IDX899"></a>
</dt>
<dd>
<p>Gibt die rechte Seite, das ist das zweite Argument, des Ausdrucks <var>expr</var> 
zur&uuml;ck, wenn der Operator von <var>expr</var> einer der relationalen Operatoren
<code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>, einer der Zuweisungsoperatoren 
<code>:= ::= : ::</code> oder ein nutzerdefinierter bin&auml;rer Infixoperator ist, der
mit der Funktion <code>infix</code> deklariert wurde.
</p>

<p>Wenn <var>expr</var> ein Atom ist oder sein Operator ein anderer als oben 
aufgelistet, hat <code>rhs</code> das Ergebnis 0.  Siehe auch <code><a href="#lhs">lhs</a></code>.
</p>

<p>Beispiele:
</p>
<pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa &lt; bb), rhs (aa &lt;= bb), rhs (aa &gt;= bb),
       rhs (aa &gt; bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
       rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
</pre></dd></dl>

<p><a name="rootsepsilon"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>rootsepsilon</b>
<a name="IDX900"></a>
</dt>
<dd><p>Standardwert: 1.0e-7
</p>

<p><code>rootsepsilon</code> ist die Toleranz, die den Vertrauensbereich f&uuml;r die von 
der Funktion <code>realroots</code> gefundenen Wurzeln festsetzt.
</p></dd></dl>

<p><a name="solve"></a>
</p><dl>
<dt><u>Funktion:</u> <b>solve</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX901"></a>
</dt>
<dt><u>Funktion:</u> <b>solve</b><i> (<var>expr</var>)</i>
<a name="IDX902"></a>
</dt>
<dt><u>Funktion:</u> <b>solve</b><i> ([<var>eqn_1</var>, &hellip;, <var>eqn_n</var>], [<var>x_1</var>, &hellip;, <var>x_n</var>])</i>
<a name="IDX903"></a>
</dt>
<dd>
<p>L&ouml;st eine algebraische Gleichung <var>expr</var> nach der Variable <var>x</var> auf.
Wenn <var>expr</var> keine Gleichung ist, wird die Gleichung <code><var>expr</var> = 0</code> 
angenommen.  <var>x</var> kann eine Funktion wie zum Beispiel <code>f(x)</code>) sein oder
ein allgemeiner Ausdruck.  Ausgenommen sind Summen und Produkte.  Hat die 
Gleichung nur eine Variable, braucht diese nicht angegeben zu werden.  
<var>expr</var> kann ein rationaler Ausdruck sein und trigonometrische Funktionen, 
Exponentialfunktionen und andere Funktionen enthalten.  Zur L&ouml;sung wird die
folgende Methode verwendet:
</p>

<p>Sei <var>E</var> ein Ausdruck und <var>X</var> die Variable.  Ist <var>E</var> linear in 
<var>X</var>, dann kann die Gleichung sofort nach der Variablen <code>X</code> aufgel&ouml;st 
werden.  Hat <var>E</var> die Form <code>A*X^N + B</code>, dann ist das Ergebnis 
<code>(-B/A)^1/N)</code> mal die <code>N</code>-te Einheitswurzel. 
</p>

<p>Ist <var>E</var> nicht linear in <var>X</var>, wird der gr&ouml;&szlig;te gemeinsame Teiler 
<var>N</var> der Exponenten der Variable <var>X</var> bestimmt.  Die Exponenten der 
Variablen werden durch <var>N</var> dividiert und die Multiplizit&auml;t der L&ouml;sungen 
mit <var>N</var> multipliziert.  <code>solve</code> wird erneut f&uuml;r den Ausdruck 
aufgerufen.  Kann <var>E</var> faktorisiert werden, wird <code>solve</code> f&uuml;r jeden 
Faktor aufgerufen.  Zuletzt pr&uuml;ft <code>solve</code>, ob einer der Algorithmen f&uuml;r
quadratische, kubische oder quartische Gleichungen angewendet werden kann. 
</p>

<p>Ist <var>E</var> ein Polynom in einer Funktion <code>F(X)</code> mit <var>X</var> als der
Variablen, wird zun&auml;chst die L&ouml;sung des Polynoms f&uuml;r <code>F(X)</code> gesucht.
Ist <var>C</var> eine solche L&ouml;sung, kann die Gleichung <code>F(X)=C</code> gel&ouml;st 
werden, wenn die Umkehrfunktion zu <code>F(X)</code> bekannt ist.
</p>

<p>Haben die Optionsvariablen <code>programmode</code> und <code>breakup</code> den Wert 
<code>true</code>, werden Zwischenmarken f&uuml;r gemeinsame Terme in L&ouml;sungen von 
kubischen und quartischen Gleichungen erzeugt.
</p>

<p><code>multiplicities</code> ist eine Liste mit den Vielfachheiten der einzelnen 
L&ouml;sungen.
</p>

<p><code>solve ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</code>
l&ouml;st ein Gleichungssystem mit den Polynomen <var>eqn_1</var>, &hellip;, <var>eqn_n</var> 
f&uuml;r die Variablen <var>x_1</var>, &hellip;, <var>x_n</var>.  Die Polynome k&ouml;nnen linear 
oder nichtlinear sein.  Um das System zu l&ouml;sen, werden die Funktionen 
<code>linsolve</code> oder <code>algsys</code> aufgerufen.  Das Ergebnis ist eine Liste mit 
den L&ouml;sungen.  Ist die Anzahl der Gleichungen gleich der Anzahl der Variablen 
des Systems, kann die Liste mit den Variablen entfallen. 
</p>

<p>Wenn <code>programmode</code> <code>false</code> ist, zeigt <code>solve</code> die L&ouml;sungen mit 
Hilfe von Zwischenmarken (<code>%t</code>) an und gibt die Liste der Marken zur&uuml;ck. 
</p>
<p>Hat <code>programmode</code> den Wert <code>false</code>, werden die L&ouml;sungen 
Zwischenmarken <code>%t</code> zugewiesen.  Die R&uuml;ckgabe ist in diesem Fall eine 
Liste der Zwischenmarken.
</p>

<p>Hat <code>globalsolve</code> den Wert <code>true</code>, werden den unbekannten Variablen
eines linearen Gleichungssystems die Werte der L&ouml;sung der Funktionen
<code>linsolve</code> und <code>solve</code> zugewiesen.
</p>
<p>Beispiele:
</p>
<pre class="example">(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
</pre>

<p>Die Symbole <code>%r</code> bezeichnen freie Konstanten einer L&ouml;sung.
</p>
<pre class="example">(%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

solve: dependent equations eliminated: (2)
(%o1)                      [[x = 1 - %r1, y = %r1]]
</pre>
<p>Siehe <code><a href="#algsys">algsys</a></code>
 and <code><a href="#g_t_0025rnum_005flist">%rnum_list</a></code>
 f&uuml;r mehr Informationen.
</p></dd></dl>

<p><a name="solvedecomposes"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>solvedecomposes</b>
<a name="IDX904"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>solvedecomposes</code> den Wert <code>true</code>, ruft <code>solve</code> die Funktion
<code>polydecomp</code> auf, um Polynome zu l&ouml;sen.
</p></dd></dl>

<p><a name="solveexplicit"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>solveexplicit</b>
<a name="IDX905"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>solveexplicit</code> den Wert <code>true</code>, gibt <code>solve</code> keine 
impliziten L&ouml;sungen der Form <code>F(x) = 0</code> zur&uuml;ck.
</p></dd></dl>

<p><a name="solvefactors"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>solvefactors</b>
<a name="IDX906"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>solvefactors</code> den Wert <code>false</code>, versucht <code>solve</code> nicht, den 
Ausdruck zu faktorisieren.
</p></dd></dl>

<p><a name="solvenullwarn"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>solvenullwarn</b>
<a name="IDX907"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>solvenullwarn</code> den Wert <code>true</code>, gibt <code>solve</code> eine 
Warnmeldung aus, wenn keine Gleichungen oder keine Variablen als Argument
&uuml;bergeben wurden.
</p></dd></dl>

<p><a name="solveradcan"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>solveradcan</b>
<a name="IDX908"></a>
</dt>
<dd><p>Standardwert: <code>false</code>
</p>

<p>Hat <code>solveradcan</code> den Wert <code>true</code>, ruft <code>solve</code> die Funktion 
<code>radcan</code> auf, um Ausdr&uuml;cke zu vereinfachen.
</p></dd></dl>

<p><a name="solvetrigwarn"></a>
</p><dl>
<dt><u>Optionsvariable:</u> <b>solvetrigwarn</b>
<a name="IDX909"></a>
</dt>
<dd><p>Standardwert: <code>true</code>
</p>

<p>Hat <code>solvetrigwarn</code> den Wert <code>true</code>, gibt <code>solve</code> eine Warnung
aus, wenn inverse trigonometrische Funktionen genutzt werden, um L&ouml;sungen zu
finden.  In diesem Fall k&ouml;nnen L&ouml;sungen verloren gehen.
</p></dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC114" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC116" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_75.html#SEC385" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>April, 4 2011</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
