This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introdução ao Maxima,  Prev: (dir),  Up: (dir)

Manual do Maxima
****************

Maxima é um sistema de álgebra computacional, implementado em Lisp.

   Maxima é derivado do sistema Macsyma, desenvolvido no MIT nos anos
de 1968 a 1982 como parte do Projeto MAC.  MIT remanejou uma cópia do
código fonte do Macsyma para o Departamento de Energia em 1982; aquela
versão é agora conhecida como Macsyma DOE.  Uma cópia do Macsyma DOE
foi mantida pelo Professor William F. Schelter da Universidade do Texas
de 1982 até sua morte em 2001.  Em 1998, Schelter obteve permissão do
Departamento de Energia para liberar o código fonte do Macsyma DOE sob
a Licença Pública GNU, e em 2000 ele iniciou o projeto Maxima no
SourceForge para manter e desenvolver o Macsyma DOE, agora chamado
Maxima.

   Notas de tradução:

   O código fonte deste documento encontra-se no formato texinfo.  	Para
contribuir com a equipe do Maxima na tarefa de manter a
tradução para o português sempre atualizada envie um 	e-mail para
<maxima at math dot utexas dot edu>.

   A parte do manual intitulada "Simetrias" encontra-se atualmente em
francês e aguardando uma versão em inglês para ser traduzida.

   Em caso de dúvida sobre algum trecho deste manual consulte o
original inglês.

   Caso sua dúvida persista ou tenha alguma sugestão/aperfeiçoamen-
to/crítica mande por e-mail para Jorge Barros de Abreu 	<ficmatin01 at
solar dot com dot br>

* Menu:

Infraestrutura do Maxima

* Introdução ao Maxima::  Exemplo de sessões do Maxima.
* Detecção e Relato de Erros::  Encontrando e relatando erros no Maxima.
* Ajuda::                       Solicitando ajuda de dentro de uma
                                sessão do Maxima.
* Linha de Comando::            Sintaxe de linha de comando do Maxima.
* Operadores::                  Operadores usados em expressões do Maxima.
* Expressões::                  Expressões no Maxima.
* Simplificação::               Simplificando expressões.
* Montando Gráficos::           Saídas gráficas em 2D e 3D.
* Entrada e Saída::             Entrada e saída de arquivos.
* Ponto Flutuante::             Rotinas numéricas de baixo nível.
* Contextos::                   Conjunto de fatos assumidos.

Suporte a áreas específicas da matemática

* Polinômios::                  Formas padrão para polinômios, e
                                funções operando sobre polinômios.
* Constantes::                  Constantes numéricas.
* Logarítmos::                  Manipulação de expressões envolvendo
                                logarítmos.
* Trigonometria::               Manipulando expressões com trigonometria e
                                Funções trigonométricas inversas.
* Funções Especiais::           Funções especiais
* Polinômios Ortogonais::       Polinômios Ortogonais e Funções Especiais

* Funções Elípticas::           Funções Elípticas e Integrais
* Limites::                     Limites de expressões.
* Diferenciação::               Cálculo diferencial.
* Integração::                  Cálculo integral.
* Equações::                    Definindo e resolvendo equações.
* Equações Diferenciais::       Definindo e resolvendo equações diferenciais.
* Numérico::                    Integração numérica, transformações
                                de Fourier, etc.
* Estatística::                 Funções estatísticas.
* Arrays e Tabelas::            Criando e trabalhando com arrays.
* Matrizes e Álgebra Linear::   Operações com Matrizes.
* Funções Afins::
* itensor::                     Manipulação de índice de Tensores.
* ctensor::                     Manipulação de componentes de Tensores.
* Pacote atensor::              Manipulação de Tensores Algébricos.
* Séries::                      Taylor e séries de potência.
* Teoria dos Números::          Teoria dos números.
* Symmetries::                  Reflexões, rotações, translações, etc
* Grupos::                      Álgebra Abstrata.

Facilidades avançadas e programação

* Tempo de Execução::           Customização do ambiente Maxima.
* Opções Diversas::             Opções com efeito global sobre o Maxima.
* Regras e Modelos::            Coincidência de expressões definidas pelo
                                usuário e regras de simplificação.
* Listas::                      Manipulação de listas.
* Conjuntos::                   Manipulação de conjuntos.
* Definição de Função::         Definindo funções.
* Fluxo de Programa::           Definindo programas do Maxima.
* Depurando::                   Depurando programas do Maxima.

Índice

* Índice de Função e Variável:: Índice.

 --- Listagem de Nodos Detalhada ---

Introdução

* Introdução ao Maxima::

Ajuda

* Introdução a Ajuda::
* Lisp e Maxima::
* Descartando::
* Documentação::
* Definições para Ajuda::

Linha de Comando

* Introdução a Linha de Comando::
* Definições para Linha de Comando::

Operadores

* "N" Argumentos::
* Sem Argumentos::
* Operador::
* Operador Pósfixado::
* Operador Préfixado::
* Definições para Operadores::

Expressões

* Introdução a Expressões::
* Atribuição::
* Complexo::
* Desigualdade::
* Sintaxe::
* Definições para Expressões::

Simplificação

* Definições para Simplificação::

Montando Gráficos

* Definições para Montagem de Gráficos::

Entrada e Saída

* Introdução a Entrada e Saída::
* Arquivos::
* Definições para Entrada e Saída::

Ponto Flutuante

* Definições para ponto Flutuante::

Contextos

* Definições para Contextos::

Polinômios

* Introdução a Polinômios::
* Definições para Polinômios::

Constantes

* Definições para Constantes::

Logarítmos

* Definições para Logarítmos::

Trigonometria

* Introdução ao Pacote Trigonométrico::
* Definições para Trigonometria::

Funções Especiais

* Introdução a Funções Especiais::
* specint::
* Definições para Funções Especiais::

Polinômios Ortogonais

* Introdução a Polinômios Ortogonais::
* Definições para Polinômios Ortogonais::

Funções Elípticas

* Introdução a Funções Elípticas e Integrais::
* Definições para Funções Elípticas::
* Definições para Integrais Elípticas::

Limites

* Definições para Limites::

Diferenciação

* Definições para Diferenciação::

Integração

* Introdução a Integração::
* Definições para Integração::

Equações

* Definições para Equações::

Equações Diferenciais

* Definições para Equações Diferenciais::

Numérico

* Introdução a Numérico::
* Pacotes de Fourier::
* Definições para Numérico::
* Definições para Séries de Fourier::

Estatistica

* Definições para Estatística::

Arrays e Tabelas

* Definições para Arrays e Tabelas::

Matrizes e Álgebra Linear

* Introdução a Matrizes e Álgebra Linear::
* Ponto::
* Vetores::
* auto::
* Definições para Matrizes e Álgebra Linear::

Funções Afins

* Definições para Funções Afins::

itensor

* Introdução a itensor::
* Definições para itensor::

ctensor

* Introdução a ctensor::
* Definições para ctensor::

Pacote atensor

* Introdução ao Pacote atensor::
* Definições para o Pacote atensor::

Séries

* Introdução a Séries::
* Definições para Séries::

Teoria dos Números

* Definições para Teoria dos Números::

Symmetries

* Definitions for Symmetries::

Grupos

* Definições para Grupos::

Tempo de Execução

* Introdução a Tempo de Execução::
* Interrupções::
* Definições para Tempo de Execução::

Opções Diversas

* Introdução a Opções Diversas::
* Compartilhado::
* Definições para Opções Diversas::

Regras e Modelos

* Introdução a Regras e Modelos::
* Definições para Regras e Modelos::

Listas

* Introdução a Listas::
* Definições para Listas::

Conjuntos

* Introdução a Conjuntos::
* Definições para Conjuntos::

Definição de Função

* Introdução a Definição de Função::
* Função::
* Macros::
* Definições para Definição de Função::

Fluxo de Programa

* Introdução a Fluxo de Programa::
* Definições para Fluxo de Programa::

Depurando

* Definições para Depuração::


File: maxima.info,  Node: Introdução ao Maxima,  Next: Detecção e Relato de Erros,  Prev: Top,  Up: Top

1 Introdução ao Maxima
**********************

Inicie o Maxima com o comando "maxima".  Maxima mostrará a informação
de versão e uma linha de comando.  Termine cada comando Maxima com um
ponto e vírgula.  Termine uma sessão com o comando "quit();".  Aqui
está um exemplo de sessão:

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maxima pode procurar as páginas info.  Use o comando `describe' para
mostrar todos os comandos e variáveis contendo uma dada seqüência de
caracteres, e opcionalmente sua documentação.  O ponto de interrogação
`?' é uma abreviatura para `describe':

     (%i1) ? integ

      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 6 5

     Info from file /usr/local/info/maxima.info:
      - Function: integerp (<expr>)
          Returns `true' if <expr> is an integer, otherwise `false'.


      - Function: askinteger (expr, integer)
      - Function: askinteger (expr)
      - Function: askinteger (expr, even)
      - Function: askinteger (expr, odd)
          `askinteger (expr, integer)' attempts to determine from the
          `assume' database whether `expr' is an integer.  `askinteger' will
          ask the user if it cannot tell otherwise, and attempt to install
          the information in the database if possible.  `askinteger (expr)'
          is equivalent to `askinteger (expr, integer)'.

          `askinteger (expr, even)' and `askinteger (expr, odd)' likewise
          attempt to determine if `expr' is an even integer or odd integer,
          respectively.

     (%o1)                         false

   Para usar um resultado em cálculos posteriores, você pode atribuir
esse valor a uma variável ou referir-se a esse mesmo valor através de
seu rótulo gerado automaticamente.  Adicionalmente, `%' refere-se ao
mais recente resultado calculado:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maxima tem conhecimento sobre números complexos e constantes
numéricas:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maxima pode fazer cálculos diferenciais e integrais:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maxima pode resolver sistemas lineares e equações cúbicas:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maxima pode resolver sistemas de equações não lineares.  Note que se
você não quer um resultado impresso, você pode encerrar seu comando com
`$' em lugar de encerrar com `;'.

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maxima pode gerar gráficos de uma ou mais funções:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2
     (%i4) kill(labels);
     (%o0)                         done
     (%i1) plot2d (sin(x)/x, [x, -20, 20]);
     (%o1)
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5]);
     (%o2)
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2), [x, -12, 12], [y, -12, 12]);
     (%o3)


File: maxima.info,  Node: Detecção e Relato de Erros,  Next: Ajuda,  Prev: Introdução ao Maxima,  Up: Top

2 Detecção e Relato de Erros
****************************

* Menu:

* Introdução à Detecção e Relato de Erros::
* Definições para Detecção e Relato de Erros::


File: maxima.info,  Node: Introdução à Detecção e Relato de Erros,  Next: Definições para Detecção e Relato de Erros,  Up: Detecção e Relato de Erros

2.1 Introdução à Detecção e Relato de Erros
===========================================

Como todos os grandes programas, Maxima contém erros conhecidos e erros
desconhecidos.  Esse capítulo descreve as facilidades internas para
executar o conjunto de testes do Maxima bem como informar novos erros.


File: maxima.info,  Node: Definições para Detecção e Relato de Erros,  Prev: Introdução à Detecção e Relato de Erros,  Up: Detecção e Relato de Erros

2.2 Definições para Detecção e Relato de Erros
==============================================

 -- Função: run_testsuite ()
 -- Função: run_testsuite (<boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>)
 -- Função: run_testsuite (<boolean>, <boolean>, <list>)
     Executa o conjunto de testes do Maxima.  Testes que produzem a
     resposta desejada são considerados "passes," e testes que não
     produzem a resposta desejada, são marcados como erros conhecidos.

     `run_testsuite ()' mostra somente testes que não são aprovados.

     `run_testsuite (true)' mostra somente testes que são marcados como
     bugs conhecidos, bem como as falhas.

     `run_testsuite (true, true)' mostra todos os testes.

     Se o terceiro argumento opcional for dado, um subconjunto de
     testes é executado.  O subconjunto de testes para executar é dado
     como uma lista de nomes dos testes.  O conjunto completo de testes
     é especificado por `testsuite_files'.

     `run_testsuite' altera a variável de ambiente Maxima.  Tipicamente
     um script de teste executa `kill' para estabelecer uma variável de
     ambiente (uma a saber sem funções definidas pelo usuário e
     variáveis) e então define funções e variáveis apropriadamente para
     o teste.

     `run_testsuite' retorna `done'.

 -- Variável de opção: testsuite_files
     `testsuite_files' é o conjunto de testes a ser executado por
     `run_testsuite'.  Isso é uma lista de nomes de arquivos contendo
     os testes a executar.  Se alguns dos testes em um arquivo falha de
     forma conhecida, então em lugar de listar o nome do arquivo, uma
     lista contendo o nome do arquivo e o número dos testes que
     falharam é usada.

     por exemplo, a linha adinate é uma parte do conjunto de testes
     padrão:

           ["rtest13s", ["rtest14", 57, 63]]

     Essa linha especifica a suite de testes que consiste dos arquivos
     "rtest13s" e "rtest14", mas "rtest14" contém dois testes que
     falham de forma conhecida: 57 e 63.

 -- Função: bug_report ()
     Imprime os números de versão do Maxima e do Lisp, e chama o link
     para a página web de informação de erros do projeto Maxima.  A
     informação da versão é a mesma reportada por `build_info'.

     Quando um erro é informado, é muito útil copiar a versão do Maxima
     e do Lisp dentro da informação do erro.

     `bug_report' retorna uma seqüência de caracteres vazia `""'.

 -- Função: build_info ()
     Imprime um sumário de parâmetros da compilação do Maxima.

     `build_info' retorna uma seqüência de caracteres vazia `""'.


File: maxima.info,  Node: Ajuda,  Next: Linha de Comando,  Prev: Detecção e Relato de Erros,  Up: Top

3 Ajuda
*******

* Menu:

* Introdução a Ajuda::
* Lisp e Maxima::
* Descartando::
* Documentação::
* Definições para Ajuda::


File: maxima.info,  Node: Introdução a Ajuda,  Next: Lisp e Maxima,  Prev: Ajuda,  Up: Ajuda

3.1 Introdução a Ajuda
======================

A função primária de ajuda on-line é `describe', que é tipicamente
invocada através do ponto de interrogação `?' na linha de comando
interativa.  `? foo' (com um espaço entre `?' e `foo') é equivalente a
`describe ("foo")', onde `foo' é o nome ou parte do nome de uma
função ou tópico; `describe' então acha todos os ítens documentados que
possuem a seqüência de caracteres `foo' em seus títulos.  Se existe
mais que um tal item, Maxima solicita ao usuário selecionar um item ou
ítens para mostrar.

     (%i1) ? integ
      0: (maxima.info)Introduction to Elliptic Functions and Integrals.
      1: Definitions for Elliptic Integrals.
      2: Integration.
      3: Introduction to Integration.
      4: Definitions for Integration.
      5: askinteger :Definitions for Simplification.
      6: integerp :Definitions for Miscellaneous Options.
      7: integrate :Definitions for Integration.
      8: integrate_use_rootsof :Definitions for Integration.
      9: integration_constant_counter :Definitions for Integration.
     Enter space-separated numbers, `all' or `none': 7 8

     Info from file /use/local/maxima/doc/info/maxima.info:
      - Function: integrate (expr, var)
      - Function: integrate (expr, var, a, b)
          Attempts to symbolically compute the integral of `expr' with
          respect to `var'.  `integrate (expr, var)' is an indefinite
          integral, while `integrate (expr, var, a, b)' is a definite
          integral, [...]

   Nesse exemplo, ítens 7 e 8 foram selecionados.  Todos ou nenhum dos
ítens poderia ter sido selecionados através da inserção de `all' ou
`none', que podem ser abreviados para `a' ou `n', respectivamente.


File: maxima.info,  Node: Lisp e Maxima,  Next: Descartando,  Prev: Introdução a Ajuda,  Up: Ajuda

3.2 Lisp e Maxima
=================

Maxima é escrito na liguagem de programação Lisp, e é fácil acessar
funções Lisp e variáveis a partir do Maxima e vice-versa.  Símbolos
Lisp e Maxima são distingüidos através de uma convenção de nome.  Um
símbolo Lisp que começa com um sinal de dólar `$' corresponde a um
símbolo Maxima sem o sinal de dólar.  Um símbolo Maxima que começa com
um ponto de interrogação `?' corresponde a um símbolo Lisp sem o ponto
de interrogação.  Por exemplo, o símbolo Maxima `foo' corresponde ao
símbolo Lisp `$foo', enquanto o símbolo Maxima `?foo' corresponde ao
símbolo Lisp `foo', Note que `?foo' é escrito sem um espaço entre `?' e
`foo'; de outra forma pode ser uma chamada errônea para `describe
("foo")'.

   Hífen `-', asterisco `*', ou outro caractere especial em símbolos
Lisp deve ser precedido por uma barra invertida `\' onde ele aparecer
no código Maxima.  Por exemplo, o identificador Lisp `*foo-bar*' é
escrito `?\*foo\-bar\*' no Maxima.

   Código Lisp pode ser executado dentro de uma sessão Maxima.  Uma
linha simples de Lisp (contendo uma ou mais formas) pode ser executada
através do comando especial `:lisp'. Por exemplo,

     (%i1) :lisp (foo $x $y)

chama a função Lisp `foo' com variáveis Maxima `x' e `y' como
argumentos.  A constução `:lisp' pode aparecer na linha de comando
interativa ou em um arquivo processado por `batch' ou `demo', mas não
em um arquivo processado por `load', `batchload', `translate_file', ou
`compile_file'.

   A função `to_lisp()' abre uma sessão interativa Lisp.  Digitando
`(to-maxima)' fecha a sessão Lisp e retorna para o Maxima.

   Funções Lisp e variáveis que são para serem visíveis no Maxima como
funções e variáveis com nomes comuns (sem pontuação especial) devem ter
nomes Lisp começando com o sinal de dólar `$'.

   Maxima é sensível à caixa, distingue entre letras em caixa alta
(maiúsculas) e letras em caixa baixa (minúsculas) em identificadores,
enquanto Lisp não é sensível à caixa.  Existem algumas regras
governando a tradução de nomes entre o Lisp e o Maxima.

  1. Um identificador Lisp não contido entre barras verticais
     corresponde a um identificador Maxima em caixa baixa.  Se o
     identificador Lisp estiver em caixa alta, caixa baixa, ou caixa
     mista, é ignorado.  E.g., Lisp `$foo', `$FOO', e `$Foo' todos
     correspondem a Maxima `foo'.

  2. Um identificador Lisp que está todo em caixa alta ou todo em caixa
     baixa e contido em barras verticais corresponde a um identificador
     Maxima com caixa invertida.  Isto é, caixa alta é alterada para
     caixa baixa e caixa baixa para caixa alta.  E.g., Lisp `|$FOO|' e
     `|$foo|' corresponde a Maxima `foo' e `FOO', respectivamente.

  3. Um identificador Lisp que é misto de caixa alta e caixa baixa e
     contido entre barras verticais corresponde a um identificador
     Maxima com o mesma caixa.  E.g., Lisp `|$Foo|' corresponde a
     Maxima `Foo'.

   A macro Lisp `#$' permite o uso de expressões Maxima em código Lisp.
`#$<expr>$' expande para uma expressão Lisp equivalente à expressão
Maxima <expr>.

     (msetq $foo #$[x, y]$)

Isso tem o mesmo efeito que digitar

     (%i1) foo: [x, y];

A função Lisp `displa' imprime uma expressão em formato Maxima.

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Funções definidas em Maxima não são funções comuns em Lisp.  A
função Lisp `mfuncall' chama uma função Maxima.  Por exemplo:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   Algumas funções Lisp possuem o mesmo nome que no pacote Maxima, a
saber as seguintes.

   `complement', `continue', `//', `float', `functionp', `array', `exp',
`listen', `signum', `atan', `asin', `acos', `asinh', `acosh', `atanh',
`tanh', `cosh', `sinh', `tan', `break', e `gcd'.


File: maxima.info,  Node: Descartando,  Next: Documentação,  Prev: Lisp e Maxima,  Up: Ajuda

3.3 Descartando
===============

Computação simbólica tende a criar um bom volume de arquivos
temporários, e o efetivo manuseio disso pode ser crucial para sucesso
completo de alguns programas.

   Sob GCL, nos sistemas UNIX onde a chamada de sistema mprotect (
controle de acessso autorizado a uma região de memória) está disponível
(incluindo SUN OS 4.0 e algumas variantes de BSD) uma organização de
arquivos temporários estratificada está disponível.   Isso limita a
organização para páginas que tenham sido recentemente escritas.    Veja
a documentação da GCL sob ALLOCATE e GBC.   No ambiente Lisp fazendo
(setq si::*notify-gbc* t) irá ajudar você a determinar quais áreas
podem precisar de mais espaço.


File: maxima.info,  Node: Documentação,  Next: Definições para Ajuda,  Prev: Descartando,  Up: Ajuda

3.4 Documentação
================

O manual on-line de usuário do Maxima pode ser visto em diferentes
formas.  A partir da linha de comando interativa do Maxima, o manual de
usuário é visto em texto plano através do comando `?' (i.e., a
função `describe' ).  O manual de usuário é visto como hipertexto
`info' através do programa visualizador `info' e como uma web page
através de qualquer navegador web comum.

   `example' mostra exemplos de muitas funções do Maxima.  Por exemplo,

     (%i1) example (integrate);

   retorna

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),

                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   e saída adicional.


File: maxima.info,  Node: Definições para Ajuda,  Prev: Documentação,  Up: Ajuda

3.5 Definições para Ajuda
=========================

 -- Função: demo (<nomedearquivo>)
     Avalia expressões Maxima em <nomedearquivo> e mostra os resultados.
     `demo' faz uma pausa após avaliar cada expressão e continua após a
     conclusão com um enter das entradas de usuário.  (Se executando em
     Xmaxima, `demo' pode precisar ver um ponto e vírgula `;' seguido
     por um enter.)

     `demo' procura na lista de diretórios `file_search_demo' para
     achar `nomedearquivo'.  Se o arquivo tiver o sufixo `dem', o
     sufixo pode ser omitido.  Veja também `file_search'.

     `demo' avalia seus argumento.  `demo' retorna o nome do arquivo de
     demonstração.

     Exemplo:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load(disol)

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _
          (%i5) demo ("rncomb");

          batching /home/wfs/maxima/share/simplification/rncomb.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i6)                     load(rncomb)

          _
                                       z         x
          (%i7)               exp1 : ----- + ---------
                                     y + x   2 (y + x)
                                    z         x
          (%o7)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i8)                     combine(exp1)
                                    z         x
          (%o8)                   ----- + ---------
                                  y + x   2 (y + x)

          _
          (%i9)                     rncombine(%)
                                       2 z + x
          (%o9)                       ---------
                                      2 (y + x)

          _
                                       d   c   b   a
          (%i10)                exp2 : - + - + - + -
                                       3   3   2   2
                                    d   c   b   a
          (%o10)                    - + - + - + -
                                    3   3   2   2

          _
          (%i11)                    combine(exp2)
                                2 d + 2 c + 3 (b + a)
          (%o11)                ---------------------
                                          6

          _
          (%i12)                   rncombine(exp2)
                                2 d + 2 c + 3 b + 3 a
          (%o12)                ---------------------
                                          6

          _
          (%i13)


 -- Função: describe (<string>)
     Encontra todos os ítens documentados que possuem <string> em seus
     títulos.  Se existe mais de um de tal item, Maxima solicita ao
     usuário selecionar um item ou ítens para mostrar.  Na linha de
     comando interativa, `? foo' (com um espaço entre `?' e `foo') é
     equivalente a `describe ("foo")'.

     `describe ("")' retorna uma lista de todos os tópicos documentados
     no manual on-line.

     `describe' não avalia seu argumento. `describe' sempre retorna
     `false'.

     Exemplo:

          (%i1) ? integ
           0: (maxima.info)Introduction to Elliptic Functions and Integrals.
           1: Definitions for Elliptic Integrals.
           2: Integration.
           3: Introduction to Integration.
           4: Definitions for Integration.
           5: askinteger :Definitions for Simplification.
           6: integerp :Definitions for Miscellaneous Options.
           7: integrate :Definitions for Integration.
           8: integrate_use_rootsof :Definitions for Integration.
           9: integration_constant_counter :Definitions for Integration.
          Enter space-separated numbers, `all' or `none': 7 8

          Info from file /use/local/maxima/doc/info/maxima.info:
           - Function: integrate (expr, var)
           - Function: integrate (expr, var, a, b)
               Attempts to symbolically compute the integral of `expr' with
               respect to `var'.  `integrate (expr, var)' is an indefinite
               integral, while `integrate (expr, var, a, b)' is a definite
               integral, [...]

     Nesse , ítens 7 e 8 foram selecionados.  Todos ou nenhum dos ítens
     poderia ter sido selecionado através da inserção de `all' ou
     `none', que podem ser abreviado para `a' ou para `n',
     respectivamente.

     *note Introdução a Ajuda::


 -- Função: example (<tópico>)
 -- Função: example ()
     `example (<topic>)' mostra alguns exemplos de <tópico>, que é um
     símbolo (não uma seqüência de caracteres).  A maioria dos tópicos
     são nomes de função.  `example ()' retorna a lista de todos os
     tópicos reconhecidos.

     O nome do arquivo contendo os exemplos é dado pela variável global
     `manual_demo', cujo valor padrão é `"manual.demo"'.

     `example' não avalia seu argumento.  `example' retorna `done' a
     menos que ocorra um erro ou não exista o argumento fornecido pelo
     usuário, nesse caso `example' retorna uma lista de todos os
     tópicos reconhecidos.

     Exemplos:

          (%i1) example (append);
          (%i2) append([x+y,0,-3.2],[2.5E+20,x])
          (%o2)             [y + x, 0, - 3.2, 2.5E+20, x]
          (%o2)                         done
          (%i3) example (coeff);
          (%i4) coeff(b+tan(x)+2*a*tan(x) = 3+5*tan(x),tan(x))
          (%o4)                      2 a + 1 = 5
          (%i5) coeff(1+x*%e^x+y,x,0)
          (%o5)                         y + 1
          (%o5)                         done



File: maxima.info,  Node: Linha de Comando,  Next: Operadores,  Prev: Ajuda,  Up: Top

4 Linha de Comando
******************

* Menu:

* Introdução a Linha de Comando::
* Definições para Linha de Comando::


File: maxima.info,  Node: Introdução a Linha de Comando,  Next: Definições para Linha de Comando,  Prev: Linha de Comando,  Up: Linha de Comando

4.1 Introdução a Linha de Comando
=================================

 -- operador: "'"
     O operador apóstrofo `'' evita avaliação.

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função, embora os argumentos da função sejam ainda
     avaliados (se a avaliação não for de outra forma evitada).  O
     resultado é a forma substantiva da chamada de função.

     Aplicada a uma espressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.
     E.g., `'(f(x))' significa não avalie a expressão `f(x)'.  `'f(x)'
     (com apóstrofo aplicado a `f' em lugar de `f(x)') retorna a forma
     substantiva de `f' aplicada a `[x]'.

     O apóstrofo nao evita simplificação.

     Quando o sinalizador global `noundisp' for `true', substantivos
     são mostrados com um apóstrofo.  Esse comutador é sempre `true'
     quando mostrando definições de funções.

     Veja também operador apóstrofo-apóstrofo `''' e `nouns'.

     Exemplos:

     Aplicado a um símbolo, o apóstrofo evita avaliação do símbolo.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     Aplicado a uma chamada de função, o apóstrofo evita avaliação da
     chamada de função.  O resultado é a forma substantiva da chamada
     de função.

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     Aplicado a uma expressão com parêntesis, o apóstrofo evita
     avaliação de todos os símbolos e chamadas de função na expressão.

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     O apóstrofo não evita simplificação.

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1


 -- Operador: "''"
     O operador `''' (apóstrofo-apóstrofo) faz com que ocorra uma
     avaliação extra.  E.g., `''%i4' irá reavaliar a linha de entrada
     `%i4'.  `''(f(x))' significa avalie a expressão `f(x)' novamente.
     `''f(x)' (com as aspas simples aplicadas a `f' em lugar de `f(x)')
     significa retorne a forma verbal de `f' aplicada a `[x]'.



File: maxima.info,  Node: Definições para Linha de Comando,  Prev: Introdução a Linha de Comando,  Up: Linha de Comando

4.2 Definições para Linha de Comando
====================================

 -- Função: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     provê um nome alternativo para uma função (de usuário ou de
     sistema), variável, array, etc.  Qualquer número de argumentos
     pode ser usado.


 -- Variável de opção: debugmode
     Valor padrão: `false'

     Quando um erro do Maxima ocorre, Maxima iniciará o depurador se
     `debugmode' for `true'.  O usuário pode informar comandos para
     examinar o histórico de chamadas, marcar pontos de parada,
     percorrer uma linha por vez o código do Maxima, e assim por
     diante.  Veja `debugging' para uma lista de opções do depurador.

     Habilitando `debugmode' por meio da alteração de seu valor para
     `true', não serão capturados erros do Lisp.


 -- Função: ev (<expr>, <arg_1>, ..., <arg_n>)
     Avalia a expressão <expr> no ambiente especificado pelos
     argumentos <arg_1>, ..., <arg_n>.  Os argumentos são comutadores
     (sinalizadores Booleanos), atribuições, equações, e funções.  `ev'
     retorna o resultado (outra expressão) da avaliação.

     A avaliação é realizada em passos, como segue.

       1. Primeiro o ambiente é preparado examinando os argumentos que
          podem ser quaisquer ou todos os seguintes.

             * `simp' faz com que <expr> seja simplificado
               independentemente da posição do comutador `simp' que
               inibe simplificação se `false'.

             * `noeval' suprime a fase de avaliação de `ev' (veja passo
               (4) adiante).  Isso é útil juntamente com outros
               comutadores e faz com que <expr> seja simplificado
               novamente sem ser reavaliado.

             * `nouns' causa a avaliação de formas substantivas
               (tipicamente funções não avaliadas tais como
               `'integrate' ou `'diff') em <expr>.

             * `expand' causa expansão.

             * `expand (<m>, <n>)' causa expansão, alterando os valores
               de `maxposex' e `maxnegex' para <m> e <n>
               respectivamente.

             * `detout' faz com que qualquer matriz inversa calculada
               em <expr> tenha seu determinante mantido fora da inversa
               ao invés de dividindo a cada elemento.

             * `diff' faz com que todas as diferenciações indicadas em
               <expr> sejam executadas.

             * `derivlist (<x>, <y>, <z>, ...)' causa somente
               diferenciações referentes às variáveis indicadas.

             * `float' faz com que números racionais não inteiros sejam
               convertidos para ponto flutuante.

             * `numer' faz com que algumas funções matemáticas
               (incluindo a exponenciação) com argumentos sejam
               valiadas em ponto flutuante.  Isso faz com que variávels
               em <expr> que tenham sido dados numervals (valores
               numéricos) sejam substituídas por seus valores.  Isso
               também modifica o comutador `float' para ativado.

             * `pred' faz com que predicados (expressões que podem ser
               avaliados em `true' ou `false') sejam avaliadas.

             * `eval' faz com que uma avaliação posterior de <expr>
               ocorra.  (Veja passo (5) adiante.)

             * `A' onde `A' é um átomo declarado seja um sinalizador de
               avaliação (veja `evflag') faz com que `A' seja associado
               a `true' durante a avaliação de <expr>.

             * `V: expresão' (ou alternativamente `V=expressão') faz
               com que `V' seja associado ao valor de `expressão'
               durante a avaliação de <expr>.  Note que se `V' é uma
               opção do Maxima, então `expression' é usada para seu
               valor durante a avaliação de <expr>.  Se mais que um
               argumento para `ev' é desse tipo então a associação
               termina em paralelo.  Se `V' é uma expressão não atômica
               então a substituição, ao invés de uma associação, é
               executada.

             * `F' onde `F', um nome de função, tenha sido declarado
               para ser uma função de avaliação (veja `evfun') faz com
               que `F' seja aplicado a <expr>.

             * Qualquer outro nome de função (e.g., `sum') causa a
               avaliação de ocorrências desses nomes em <expr> mesmo
               que eles tenham sido verbos.

             * De forma adicional uma função ocorrendo em <expr>
               (digamos `F(x)') pode ser definida localmente para o
               propósito dessa avaliação de <expr> dando `F(x) :=
               expressão' como um argumento para `ev'.

             * Se um átomo não mensionado acima ou uma variável
               subscrita ou expressão subscrita for dada como um
               argumento, isso é avaliado e se o resultado for uma
               equação ou uma atribuição então a associação indicada ou
               substituição é executada.  Se o resultado for uma lista
               então os membros da lista serão tratados  como se eles
               fossem argumentos adicionais dados para `ev'.  Isso
               permite que uma lista de equações seja dada (e.g. `[X=1,
               Y=A**2]') ou que seja dado uma lista de nomes de
               equações (e.g., `[%t1, %t2]' onde `%t1' e `%t2' são
               equações) tais como aquelas listas retornadas por
               `solve'.

          Os argumentos de `ev' podem ser dados em qualquer ordem com
          exceção de substituições de equações que são manuseadas em
          seqüência, da esquerda para a direita, e funções de avaliação
          que são compostas, e.g., `ev (<expr>, ratsimp, realpart)' são
          manuseadas como `realpart (ratsimp (<expr>))'.

          Os comutadores `simp', `numer', `float', e `pred' podem
          também ser alterados localmente em um bloco, ou globalmente
          no Maxima dessa forma eles irã permanecer em efeito até serem
          resetados ao término da execução do bloco.

          Se <expr> for uma expressão racional canônica (CRE), então a
          expressão retornada por `ev' é também uma CRE, contanto que
          os comutadores `numer' e `float' não sejam ambos `true'.

       2. Durante o passo (1), é feito uma lista  de variáveis não
          subscritas aparecendo do lado esquerdo das equações nos
          argumentos ou nos valores de alguns argumentos se o valor for
          uma equação.  As variáveis (variáveis subscritas que não
          possuem funções array associadas bem como variáveis não
          subscritas) na expressão <expr> são substituídas por seus
          valores globais, exceto para esse aparecendo nessa lista.
          Usualmente, <expr> é apenas um rótulo ou `%' (como em `%i2'
          no exemplo adiante), então esse passo simplesmente repete a
          expressão nomeada pelo rótulo, de modo que `ev' possa
          trabalhar sobre isso.

       3. Se quaisquer substituições tiveem sido indicadas pelos
          argumentos, elas serão realizadas agora.

       4. A expressão resultante é então reavaliada (a menos que um dos
          argumentos seja `noeval') e simplificada conforme os
          argumentos.  Note que qualquer chamada de função em <expr>
          será completada depois das variáveis nela serem avalidas e
          que `ev(F(x))' dessa forma possa comportar-se como `F(ev(x))'.

       5. Se um dos argumentos for `eval', passos (3) e (4) serão
          repetidos.

     Exemplos

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, sin, expand, diff, x=2, y=1);
                                    2
          (%o2)           cos(w) + w  + 2 w + cos(1) + 1.909297426825682

     Uma sintaxe alternativa de alto nível tem sido provida por `ev',
     por meio da qual se pode apenas digitar seus argumentos, sem o
     `ev()'.  Isto é, se pode escrever simplesmente

          <expr>, <arg_1>, ..., <arg_n>

     Isso não é permitido como parte de outra expressão, e.g., em
     funções, blocos, etc.

     Observe o processo de associação paralela no seguinte exemplo.

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true


 -- Propriedade: evflag
     Alguns sinalizadores Booleanos possuem a propriedae `evflag'.
     `ev' trata tais sinalizadores especialmente.  Um sinalizador com a
     propriedade `evflag' não será associado a `true' durante a
     execução de `ev' se isso for mensionado na chamada para `ev'.  Por
     exemplo, `demoivre' e `ratfac' são associados a `true' durante a
     chamada `ev (%, demoivre, ratfac)'.

     Os sinalizadores que possuem a propriedade `evflag' são:
     `algebraic', `cauchysum', `demoivre', `dotscrules', `%emode',
     `%enumer', `exponentialize', `exptisolate', `factorflag', `float',
     `halfangles', `infeval', `isolate_wrt_times', `keepfloat',
     `letrat', `listarith', `logabs', `logarc', `logexpand',
     `lognegint', `lognumer', `m1pbranch', `numer_pbranch',
     `programmode', `radexpand', `ratalgdenom', `ratfac', `ratmx',
     `ratsimpexpons', `simp', `simpsum', `sumexpand', and `trigexpand'.

     A construção `:lisp (putprop '|$foo| t 'evflag)' fornece a
     propriedade `evflag' para a variável `foo', então `foo' ássociada
     a `true' durante a chamada `ev (%, foo)'.  Equivalentemente, `ev
     (%, foo:true)' tem o mesmo efeito.


 -- Propriedade: evfun
     Agumas funções possuem a proriedade `evfun'.  `ev' trata cada
     função especialmente.  Uma função com a propriedade `evfun' será
     aplicada durante a execução de `ev' se isso for mecionado na
     chamada a `ev'.  Por exemplo, `ratsimp' e `radcan' será aplicada
     durante a chamada `ev (%, ratsimp, radcan)'.

     As funções que possuem a propriedade `evfun' são: `bfloat',
     `factor', `fullratsimp', `logcontract', `polarform', `radcan',
     `ratexpand', `ratsimp', `rectform', `rootscontract', `trigexpand',
     e `trigreduce'.

     A construção `:lisp (putprop '|$foo| t 'evfun)' fornece a
     propriedade `evfun' para a função `foo', de modo que `foo' é
     aplicada durante a chamada `ev (%, foo)'.  Equivalentemente, `foo
     (ev (%))' tem o mesmo efeito.


 -- Variável de opção: infeval
     Habilita o modo "avaliação infinita".  `ev' repetidamente avalia
     uma expressão até que ela permaneça invariante.  Para prevenir uma
     variável, digamos `X', seja demoradamente avaliada nesso modo,
     simplesmente inclua `X='X' como um argumento para `ev'.
     Certamente expressões tais como `ev (X, X=X+1, infeval)' irão
     gerar um ciclo infinito.


 -- Função: kill (<símbolo_1>, ..., <símbolo_n>)
 -- Função: kill (labels)
 -- Função: kill (inlabels, outlabels, linelabels)
 -- Função: kill (<n>)
 -- Função: kill ([<m>, <n>])
 -- Função: kill (values, functions, arrays, ...)
 -- Função: kill (all)
 -- Função: kill (allbut (<símbolo_1>, ..., <símbolo_n>))
     Remove todas as associações (valor, funções, array, ou regra) dos
     argumentos <símbolo_1>, ..., <símbolo_n>.  Um argumento pode ser
     um elemento simples de um array ou uma função subscrita.

     Muitos argumentos especiais são reconhecidos.  Diferentes famílias
     de argumentos podem ser combinadas, e.g., `kill (inlabels,
     functions, allbut (foo, bar))'

     todos os rótulos de entrada, de saída, e de expressões
     intermediárias criados até então.  `kill (inlabels)' libera
     somente rótudos de entrada que começam com o valor corrente de
     `inchar'.  De forma semelhante, `kill (outlabels)' libera somente
     rótulos de saída que começam com o valor corrente de `outchar', e
     `kill (linelabels)' libera somente rótulos de expressões
     intermediárias que começam com o valor corrente de `linechar'.

     `kill (<n>)', onde <n> é um inteiro, libera os <n> mais recentes
     rótulos de entrada e saída.

     `kill ([<m>, <n>])' libera rótulos de entrada e saída de <m> até
     <n>.

     `kill (<infolist>)', onde <infolist> é um item em `infolists'
     (tais como `values', `functions', ou `arrays') libera todos os
     ítens em <infolist>.  Veja também `infolists'.

     `kill (all)' liberar todos os ítens em todas as infolists.  `kill
     (all)' não retorna variáveis globais para seus valores padrões;
     Veja `reset' sobre esse ponto.

     `kill (allbut (<símbolo_1>, ..., <símbolo_n>))' libera todos os
     ítens em todas as infolists exceto para <símbolo_1>, ...,
     <símbolo_n>.  `kill (allbut (<infolist>))' libera todos os ítens
     exceto para si próprio em <infolist>, onde <infolist> é `values',
     `functions', `arrays', etc.

     A memória usada por uma propriedade de associação não será
     liberada até que todos os símbolos sejam liberados disso.  Em
     particular, para liberar a memória usada pelo valor de um símbolo,
     deve-se liberar o rótulo de saída que mosta o valor associado, bem
     como liberando o próprio símbolo.

     `kill' não avalia seus argumentos.  O operador
     apóstrofo-apóstrofo, `''', faz com que ocorra avaliação.

     `kill (<símbolo>)' libera todas as propriedades de <símbolo>.  Em
     oposição, `remvalue', `remfunction', `remarray', e `remrule'
     liberam uma propriedade específica.

     `kill' sempre retorna `done', igualmente se um argumento não tem
     associações.


 -- Função: labels (<símbolo>)
 -- Variável de sistema: labels
     Retorna a lista de rótulos de entradas, de saída, de expressões
     intermediárias que começam com <símbolo>.  Tipicamente <símbolo> é
     o valor de `inchar', `outchar', ou `linechar'.  O caracter rótulo
     pode ser dado com ou sem o sinal de porcentagem, então, por
     exemplo, `i' e `%i' retornam o mesmo resultado.

     Se nenhum rótulo começa com <símbolo>, `labels' retorna uma lista
     vazia.

     A função `labels' não avalia seu argumento.  O operador
     apóstrofo-apóstrofo `''' faz com que ocorra avaliação.  Por
     exemplo, `labels (''inchar)' retorna os rótulos de entrada que
     começam com o caractere corrente do rótulo de entrada.

     A variável `labels' é uma lista de rótulos de entrada, saída, e de
     expressões intermediárias, incluindo todos os rótulos anteriores
     se `inchar', `outchar', ou `linechar' que tiverem sido redefinidos.

     Por padrão, Maxima mostra o resultado de cada expressão de entrada
     do usuário, dando ao resultado um rótulo de saída.  A exibição da
     saída é suprimida pelo encerramento da entrada com `$' (sinal de
     dolar) em lugar de `;' (ponto e vírgula).  Um rótulo de saída é
     construido e associado ao resultado, mas não é mostrado, e o
     rótulo pode ser referenciado da mesma forma que rótulos de saída
     mostrados.  Veja também `%', `%%', e `%th'.

     Rótulos de expressões intermediárias podem ser gerados por algumas
     funções.  O sinalizador `programmode' controla se `solve' e
     algumas outras funções geram rótulos de expressões intermediárias
     em lugar de retornar uma lista de expressões.  Algumas outras
     funções, tais como `ldisplay', sempre geram rótulos de expressões
     intermediárias.

     Veja também `inchar', `outchar', `linechar', e `infolists'.


 -- Variável de sistema: linenum
     Retorna o número da linha do par corrente de expressões de entrada
     e saída.


 -- Variável de sistema: myoptions
     Valor padrão: `[]'

     `myoptions' é a lista de todas as opções alguma vez alteradas pelo
     usuário, tenha ou não ele retornado a alteração para o seu valor
     padrão.


 -- Variável de opção: nolabels
     Valor padrão: `false'

     Quando `nolabels' for `true', rótulos de entrada e saída (`%i' e
     `%o', respectivamente) são mostrados, mas os rótulos não são
     associados aos resultados, e os rótulos não são anexados ao final
     da lista `labels'.  Uma vez que rótulos não são associados aos
     resultados, a reciclagem pode recuperar a memória tomada pelos
     resultados.

     De outra forma rótulos de entrada e saída são associados aos
     resultados, e os rótulos são anexados ao final da lista `labels'.

     Veja também `batch', `batchload', e `labels'.


 -- Variável de opção: optionset
     Valor padrão: `false'

     Quando `optionset' for `true', Maxima mostrará uma mensagem sempre
     que uma opção do Maxima for alterada.  Isso é útil se o usuário
     está incerto sobre a ortografia de alguma opção e quer ter certeza
     que a variável por ele atribuído um valor foi realmente uma
     variável de opção.


 -- Função: playback ()
 -- Função: playback (<n>)
 -- Função: playback ([<m>, <n>])
 -- Função: playback ([<m>])
 -- Função: playback (input)
 -- Função: playback (slow)
 -- Função: playback (time)
 -- Função: playback (grind)
     Mostra expressões de entrada, de saída, e expressões
     intermediárias, sem refazer os cálculos.  `playback' somente
     mostra as expressões associadas a rótulos; qualquer outra saída
     (tais como textos impressos por `print' ou `describe', ou
     messagens de erro) não é mostrada.  Veja também `labels'.

     `playback' não avalia seus argumentos.  O operador
     apóstrofo-apóstrofo, `''', sobrepõe-se às aspas.  `playback'
     sempre retorna `done'.

     `playback ()' (sem argumentos) mostra todas as entradas, saídas e
     expressões intermediárias geradas até então.  Uma expressão de
     saída é mostrada mesmo se for suprimida pelo terminador `$' quando
     ela tiver sido originalmente calculada.

     `playback (<n>)' mostra as mais recentes <n> expressões.  Cada
     entrada, saída e expressão intermediária conta como um.

     `playback ([<m>, <n>])' mostra entradas, saídas e expressões
     intermediárias com os números de <m> até <n>, inclusive.

     `playback ([<m>])' é equivalente a `playback ([<m>, <m>])'; isso
     usualmente imprime um par de expressões de entrada e saída.

     `playback (input)' mostra todas as expressões de entrada geradas
     até então.

     `playback (slow)' insere pausas entre expressões e espera que o
     usuário pressione `enter'.  Esse comportamento é similar a `demo'.
     `playback (slow)' é útil juntamente com `save' ou `stringout'
     quando criamos um arquivo secundário de armazenagem com a
     finalidade de capturar expressões úteis.

     `playback (time)' mostra o tempo de computação de cada expressão.

     `playback (grind)' mostra expressões de entrada no mesmo formato
     da função `grind'.  Expressões de saída não são afetadas pela
     opção `grind'.  Veja `grind'.

     Argumentos podem ser combinados, e.g., `playback ([5, 10], grind,
     time, slow)'.


 -- Função: printprops (<a>, <i>)
 -- Função: printprops ([<a_1>, ..., <a_n>], <i>)
 -- Função: printprops (all, <i>)
     Mostra a propriedade como o indicador <i> associada com o átomo
     <a>.  <a> pode também ser uma lista de átomos ou o átomo `all'
     nesse caso todos os átomos com a propriedade dada serão usados.
     Por exemplo, `printprops ([f, g], atvalue)'.  `printprops' é para
     propriedades que não podem  ser mostradas de outra forma, i.e. para
     `atvalue', `atomgrad', `gradef', e `matchdeclare'.


 -- Variável de opção: prompt
     Valor padrão: `_'

     `prompt' é o símbolo de linha de comando da função `demo', modo
     `playback (slow)', e da interrupção de ciclos do Maxima (como
     invocado por `break').


 -- Função: quit ()
     Encerra a sessão do Maxima.  Note que a função pode ser invocada
     como `quit();' ou `quit()$', não por sí mesma `quit'.

     Para parar um cálculo muito longo, digite `control-C'.  A ação
     padrão é retornar à linha de comando do Maxima.  Se
     `*debugger-hook*' é `nil', `control-C' abre o depurador Lisp.
     Veja também `debugging'.


 -- Função: remfunction (<f_1>, ..., <f_n>)
 -- Função: remfunction (all)
     Desassocia as definições de função dos síbolos <f_1>, ..., <f_n>.
     Os argumentos podem ser os nomes de funções comuns (criadas por
     meio de `:=' ou `define') ou funções macro (criadas por meio de
     `::=').

     `remfunction (all)' desassocia todas as definições de funcção.

     `remfunction' coloca um ap'ostrofo em seus argumentos (não os
     avalia).

     `remfunction' retorna uma lista de símbolos para a qual a
     definição de função foi desassociada.  `false' é retornado em
     lugar de qualquer símbolo para o qual não exista definição de
     função.


 -- Função: reset ()
     Retorna muitas variáveis globais e opções, e algumas outras
     variáveis, para seus valores padrões.

     `reset' processa as variáveis na lista Lisp
     `*variable-initial-values*'.  A macro Lisp `defmvar' coloca
     variáveis nessa lista (entre outras ações).  Muitas, mas não
     todas, variáveis globais e opções são definidas por `defmvar',  e
     algumas variáveis definidas por `defmvar' não são variáveis
     globais ou variáveis de opção.


 -- Variável de opção: showtime
     Valor padrão: `false'

     Quando `showtime' for `true', o tempo de computação e o tempo
     decorrido são impressos na tela com cada expressão de saída.

     O tempo de cálculo é sempre gravado, então `time' e `playback'
     podem mostrar o tempo de cálculo mesmo quando `showtime' for
     `false'.

     Veja também `timer'.


 -- Função: sstatus (<recurso>, <pacote>)
     Altera o status de <recurso> em <pacote>.  Após `sstatus
     (<recurso>, <pacote>)' ser executado, `status (<recurso>,
     <pacote>)' retorna `true'.  Isso pode ser útil para quem escreve
     pacotes, para manter um registro de quais recursos os pacotes usam.


 -- Função: to_lisp ()
     Insere o sistema Lisp dentro do Maxima.  `(to-maxima)' retorna
     para o Maxima.


 -- Variável de sistema: values
     Valor inicial: `[]'

     `values' é uma lista de todas as varáveis de usuário associadas
     (não opções Maxima ou comutadores).  A lista compreende símbolos
     associados por `:' , `::', ou `:='.



File: maxima.info,  Node: Operadores,  Next: Expressões,  Prev: Linha de Comando,  Up: Top

5 Operadores
************

* Menu:

* "N" Argumentos::
* Sem Argumentos::
* Operador::
* Operador Pósfixado::
* Operador Préfixado::
* Definições para Operadores::


File: maxima.info,  Node: "N" Argumentos,  Next: Sem Argumentos,  Prev: Operadores,  Up: Operadores

5.1 "N" Argumentos
==================

Um operador `nary' é usado para denotar uma função com qualquer número
de argumentos, cada um dos quais é separado por uma ocorrência do
operador, e.g. A+B ou A+B+C.  A função `nary("x")'  é uma função de
extensão sintática para declarar x como sendo um operador `nary'.
Funções podem ser declaradas para serem `nary'.  Se `declare(j,nary);'
é concluída, diz ao simplicador para simplificar, e.g.
`j(j(a,b),j(c,d))' para `j(a, b, c, d)'.

   Veja também `syntax'.


File: maxima.info,  Node: Sem Argumentos,  Next: Operador,  Prev: "N" Argumentos,  Up: Operadores

5.2 Sem Argumentos
==================

Operadores `nofix' são usados para denotar funções sem argumentos.  A
mera presença de tal operador em um comando fará com que a função
correspondente seja avaliada.  Por exemplo, quando se digita "exit;"
para sair de uma parada do Maxima, "exit" tem comportamento similar a um
operador `nofix'.  A função `nofix("x")' é uma função de extensão
sintática que declara x como sendo um operador `nofix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador,  Next: Operador Pósfixado,  Prev: Sem Argumentos,  Up: Operadores

5.3 Operador
============

Veja `operators'.


File: maxima.info,  Node: Operador Pósfixado,  Next: Operador Préfixado,  Prev: Operador,  Up: Operadores

5.4 Operador Pósfixado
======================

Operadores `postfix' como a variedade `prefix' denotam funções de um
argumento simples, mas nesse caso  o argumento sucede imediatamente uma
ocorrência do operador na seqüência de caracteres de entrada, e.g. 3! .
Uma função `postfix("x")' é uma função de extensão sintática que
declara x como sendo um operador `postfix'.

   Veja também `syntax'.


File: maxima.info,  Node: Operador Préfixado,  Next: Definições para Operadores,  Prev: Operador Pósfixado,  Up: Operadores

5.5 Operador Préfixado
======================

Um operador `prefix' é um que significa uma função de um argumento, o
qual imediatamente segue uma ocorrência do operador.  `prefix("x")' é
uma função de extensão sintática que declara x como sendo um operador
`prefix'.

   Veja também `syntax'.


File: maxima.info,  Node: Definições para Operadores,  Prev: Operador Préfixado,  Up: Operadores

5.6 Definições para Operadores
==============================

 -- Operador: "!"
     O operador fatorial.  Para qualquer número complexo `x' (incluíndo
     números inteiros, racionais, e reais) exceto para inteiros
     negativos, `x!' é definido como `gamma(x+1)'.

     Para um inteiro `x', `x!' simplifica para o produto de inteiros de
     1 a `x' inclusive.  `0!' simplifica para 1.  Para um número em
     ponto flutuante `x', `x!' simplifica para o valor de `gamma (x+1)'.
     Para `x' igual a `n/2' onde `n' é um inteiro ímpar, `x!'
     simplifica para um fator racional vezes `sqrt (%pi)' (uma vez que
     `gamma (1/2)' é igual a `sqrt (%pi)').  Se `x' for qualquer outra
     coisa, `x!' não é simplificado.

     As variáveis `factlim', `minfactorial', e `factcomb' controlam a
     simplificação de expressões contendo fatoriais.

     As funções `gamma', `bffac', e `cbffac' são variedades da função
     `gamma'.  `makegamma' substitui `gamma' para funções relacionadas
     a fatoriais.

     Veja também `binomial'.

        * O fatorial de um inteiro, inteiro dividido por dois, ou
          argumento em ponto flutuante é simplificado a menos que o
          operando seja maior que `factlim'.

               (%i1) factlim: 10$
               (%i2) [0!, (7/2)!, 4.77!, 8!, 20!];
                         105 sqrt(%pi)
               (%o2) [1, -------------, 81.44668037931193, 40320, 20!]
                              16

        * O fatorial de um número complexo, constante conhecida, ou
          expressão geral não é simplificado.  Ainda assim pode ser
          possível simplificar o fatorial após avaliar o operando.

               (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
               (%o1)    [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
               (%i2) ev (%, numer, %enumer);
               (%o2) [(%i + 1)!, 7.188082728976031, 4.260820476357003,

                                                         1.227580202486819]

        * O fatorial de um símbolo não associado não é simplificado.

               (%i1) kill (foo)$
               (%i2) foo!;
               (%o2)                       foo!

        * Fatoriais são simplificados, não avaliados.  Dessa forma `x!'
          pode ser substituído mesmo em uma expressão com apóstrofo.

               (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                         105 sqrt(%pi)
               (%o1) [1, -------------, 81.44668037931193, 40320, 20!]
                              16


 -- Operador: "!!"
     O operador de duplo fatorial.

     Para um número inteiro, número em ponto flutuante, ou número
     racional `n', `n!!' avalia para o produto `n (n-2) (n-4) (n-6) ...
     (n - 2 (k-1))' onde `k' é igual a `entier (n/2)', que é, o maior
     inteiro menor que ou igual a `n/2'.  Note que essa definição não
     coincide com outras definições publicadas para argumentos que não
     são inteiros.

     Para um inteiro par (ou ímpar) `n', `n!!' avalia para o produto de
     todos os inteiros consecutivos pares (ou ímpares) de 2 (ou 1) até
     `n' inclusive.

     Para um argumento `n' que não é um número inteiro, um número em
     ponto flutuante, ou um número racional, `n!!' retorna uma forma
     substantiva `genfact (n, n/2, 2)'.


 -- Operador: "#"
     Representa a negação da igualdade sintática `='.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de `not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma `not <a> = <b>' não é
     equivalente à forma `<a> # <b>' em alguns casos.

     Exemplos:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) é (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) é (a # b);
          (%o5)                         true
          (%i6) é (not a = b);
          (%o6)                         true


 -- Operador: "."
     O operador ponto, para multiplicação (não comutativa) de matrizes.
     Quando "." é usado com essa finalidade, espaços devem ser
     colocados em ambos os lados desse operador, e.g. A . B.  Isso
     distingüe o operador ponto plenamente de um ponto decimal em um
     número em ponto flutuante.

     Veja também `dot', `dot0nscsimp', `dot0simp', `dot1simp',
     `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
     `dotident', e `dotscrules'.


 -- Operador: ":"
     O operador de atribuição.  E.g. A:3 escolhe a variável A para 3.


 -- Operador: "::"
     Operador de atribuição.  :: atribui o valor da expressão em seu
     lado direito para o valor da quantidade na sua esquerda, que pode
     avaliar para uma variável atômica ou variável subscrita.


 -- Operador: "::="
     Operador de definição de função de macro.  `::=' define uma função
     (chamada uma "macro" por razões históricas) que coloca um
     apóstrofo em seus argumentos (evitando avaliação), e a expressão
     que é retornada (chamada a "expansão de macro") é avaliada no
     contexto a partir do qual a macro foi chamada.  Uma função de
     macro é de outra forma o mesmo que uma função comum.

     `macroexpand' retorna uma expansão de macro (sem avaliar a
     expansão).  `macroexpand (foo (x))' seguida por `''%' é
     equivalente a `foo (x)' quando `foo' for uma função de macro.

     `::=' coloca o nome da nova função de macro dentro da lista global
     `macros'.  `kill', `remove', e `remfunction' desassocia definições
     de função de macro e remove nomes de `macros'.

     `fundef' e `dispfun' retornam respectivamente uma definição de
     função de macro e uma atribuição dessa definição a um rótulo,
     respectivamente.

     Funções de macro comumente possuem expressões `buildq' e `splice'
     para construir uma expressão, que é então avaliada.

     Exemplos

     Uma função de macro coloca um apóstrofo em seus argumentos
     evitando então a avaliação, então mensagem (1) mostra `y - z', não
     o valor de `y - z'.  A expansão de macro (a expressão com
     apóstrofo `'(print ("(2) x is equal to", x))' é avaliada no
     contexto a partir do qual a macro for chamada, mostrando a
     mensagem (2).

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printq1 (x) ::= block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printq1(x) ::= block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printq1 (y - z);
          (1) x é igual a y - z
          (2) x é igual a %pi
          (%o5)                          %pi

     Uma função comum avalia seus argumentos, então message (1) mostra
     o valor de `y - z'.  O valor de retorno não é avaliado, então
     mensagem (2) não é mostrada até a avaliação explícita `''%'.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) printe1 (x) := block (print ("(1) x é igual a", x), '(print ("(2) x é igual a", x)));
          (%o4) printe1(x) := block(print("(1) x é igual a", x),
                                          '(print("(2) x é igual a", x)))
          (%i5) printe1 (y - z);
          (1) x é igual a 1234 - 1729 w
          (%o5)              print((2) x é igual a, x)
          (%i6) ''%;
          (2) x é igual a %pi
          (%o6)                          %pi

     `macroexpand' retorna uma expansão de macro.  `macroexpand (foo
     (x))' seguido por `''%' é equivalente a `foo (x)' quando `foo' for
     uma função de macro.

          (%i1) x: %pi;
          (%o1)                          %pi
          (%i2) y: 1234;
          (%o2)                         1234
          (%i3) z: 1729 * w;
          (%o3)                        1729 w
          (%i4) g (x) ::= buildq ([x], print ("x é igual a", x));
          (%o4)    g(x) ::= buildq([x], print("x é igual a", x))
          (%i5) macroexpand (g (y - z));
          (%o5)              print(x é igual a, y - z)
          (%i6) ''%;
          x é igual a 1234 - 1729 w
          (%o6)                     1234 - 1729 w
          (%i7) g (y - z);
          x é igual a 1234 - 1729 w
          (%o7)                     1234 - 1729 w


 -- Operador: ":="
     O operador de definição de função.  E.g. `f(x):=sin(x)' define uma
     função `f'.


 -- Operador: "="
     denota uma equação para o Maxima.  Para o verificador de modelos no
     Maxima isso denota uma relação total que prende duas expressões se
     e somente se as expressões são sintaticamente idênticas.

     A negação de `=' é representada por `#'.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de `not <expr>' fazer com que
     ocorra a avaliação de <expr>), a forma `not <a> = <b>' não é
     equivalente à forma `<a> # <b>' em alguns casos.


 -- Operador: and
     O operador lógico de conjunção.  `and' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um
     valor Booleano.

     `and' força avaliação (como `is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecerem.  `and' avalia
     somente quantos de seus operandos forem necessários para
     determinar o resultado.  Se qualquer operando for `false', o
     resultado é `false' e os operandos restantes não são avaliados.

     O sinalizador global `prederror' governa o comportamento de `and'
     quando um operando avaliado não pode ser determinado como sendo
     `true' ou `false'.  `and' imprime uma mensagem de erro quando
     `prederror' for `true'.  De outra forma, `and' retorna `unknown'
     (desconhecido).

     `and' não é comutativo: `a and b' pode não ser igual a `b and a'
     devido ao tratamento de operandos indeterminados.


 -- Operador: or
     O operador lógico de disjunção.  `or' é um operador n-ário infixo;
     seus operandos são expressões Booleanas, e seu resultado é um
     valor Booleano.

     `or' força avaliação (como `is') de um ou mais operandos, e pode
     forçar a avaliação de todos os operandos.

     Operandos são avaliados na ordem em que aparecem.  `or' avalia
     somente quantos de seus operandos forem necessários para
     determinar o resultado.  Se qualquer operando for `true', o
     resultado é `true' e os operandos restantes não são avaliados.

     O sinalizador global `prederror' governa o comportamento de `or'
     quando um operando avaliado não puder ser determinado como sendo
     `true' ou `false'.  `or' imprime uma mensagem de erro quando
     `prederror' for `true'.  De outra forma, `or' retorna `unknown'.

     `or' não é comutativo: `a or b' pode não ser igual a `b or a'
     devido ao tratamento de operando indeterminados.


 -- Operador: not
     O operador lógico de negação.  `not' é operador prefixado; Seu
     operando é uma expressão Booleana, e seu resultado é um valor
     Booleano.

     `not' força a avaliação (como `is') de seu operando.

     O sinalizador global `prederror' governa o comportamento de `not'
     quando seu operando não pode ser determinado em termos de `true'
     ou `false'.  `not' imprime uma mensagem de erro quando `prederror'
     for `true'.  De outra forma, `not' retorna `unknown'.


 -- Função: abs (<expr>)
     Retorna o valor absoluto de <expr>.  Se <expr> for um número
     complexo, retorna o módulo complexo de <expr>.


 -- Palavra chave: additive
     Se `declare(f,additive)' tiver sido executado, então:

     (1) Se `f' for uma função de uma única variável, sempre que o
     simplificador encontrar `f' aplicada a uma adição, `f' será
     distribuído sobre aquela adição.  I.e. `f(y+x)' irá simplificar
     para `f(y)+f(x)'.

     (2) Se `f' for uma função de 2 ou mais argumentos, a adição é
     definida como adição no primeiro argumento para `f', como no caso
     de `sum' ou `integrate', i.e. `f(h(x)+g(x),x)' irá simplificar
     para `f(h(x),x)+f(g(x),x)'.  Essa simplificação não ocorre quando
     `f' é aplicada para expressões da forma
     `sum(x[i],i,lower-limit,upper-limit)'.


 -- Palavra chave: allbut
     trabalha com os comandos `part' (i.e. `part', `inpart',
     `substpart', `substinpart', `dpart', e `lpart').  Por exemplo,

          (%i1) expr: e+d+c+b+a$
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     enquanto

          (%i3) part (expr, allbut (2, 5));
          (%o3)                       e + c + b

     Também trabalha com o comando `kill',

          kill (allbut (name_1, ..., name_k))

     executará um `kill (all)' deixando fora do `kill' os nomes
     especificados.  Nota: `name_i' significa um nome tal como nome de
     função `u', `f', `foo', ou `g', não um `infolist' tal como
     `functions'.


 -- Declaração: antisymmetric
     Se `declare(h,antisymmetric)' é concluída, diz ao simplicador que
     `h' é uma função antisimétrica.  E.g. `h(x,z,y)' simplificará para
     `- h(x, y, z)'.  Isto é, dará (-1)^n vezes o resultado dado por
     `symmetric' ou `commutative', quando n for o número de
     interescolhas de dois argumentos necessários para converter isso
     naquela forma.


 -- Função: cabs (<expr>)
     Retorna o valor absoluto complexo (o módulo complexo) de <expr>.


 -- Função: ceiling (<x>)
     Quando <x> for um número real, retorna o último inteiro que é
     maior que ou igual a <x>.

     Se <x> for uma expressão constante (`10 * %pi', por exemplo),
     `ceiling' avalia <x> usando grandes números em ponto flutuante, e
     aplica `ceiling' para o grande número em ponto flutuante
     resultante. Porque `ceiling' usa avaliação de ponto flutuante, é
     possível, embora improvável, que `ceiling' possa retornar uma
     valor errôneo para entradas constantes. Para prevenir erros, a
     avaliação de ponto flutuante é concluída usando três valores para
     `fpprec'.

     Para entradas não constantes, `ceiling' tenta retornar um valor
     simplificado.  Aqui está um exemplo de simplificações que `ceiling'
     conhece:

          (%i1) ceiling(ceiling(x));
          (%o1) ceiling(x)
          (%i2) ceiling(floor(x));
          (%o2) floor(x)
          (%i3) declare(n,integer)$
          (%i4) [ceiling(n), ceiling(abs(n)), ceiling(max(n,6))];
          (%o4) [n, abs(n), max(n,6)]
          (%i5) assume(x > 0, x < 1)$
          (%i6) ceiling(x);
          (%o6) 1
          (%i7) tex(ceiling(a));
             $$\left \lceil a \right \rceil$$

     A função `ceiling' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, `ceiling' retorna uma forma substantiva.

     Se o intervalo de uma função é um subconjunto dos inteiros, o
     intervalo pode ser declarado `integervalued'. Ambas as funções
     `ceiling' e `floor' podem usar essa informação; por exemplo:

          (%i1) declare(f,integervalued)$
          (%i2) floor(f(x));
          (%o2) f(x)
          (%i3) ceiling(f(x) -1);
          (%o3) f(x)-1


 -- Função: charfun (<p>)
     Retorna 0 quando o predicado <p> avaliar para `false'; retorna 1
     quando o predicado avaliar para `true'.  Quando o predicado
     avaliar para alguma coisa que não `true' ou `false' (`unknown'),
     retorna uma forma substantiva.

     Exemplos:

          (%i1) charfun(x<1);
          (%o1) charfun(x<1)
          (%i2) subst(x=-1,%);
          (%o2) 1
          (%i3) e : charfun('"and"(-1 < x, x < 1))$
          (%i4) [subst(x=-1,e), subst(x=0,e), subst(x=1,e)];
          (%o4) [0,1,0]


 -- Declaração: commutative
     Se `declare(h,commutative)' é concluída, diz ao simplicador que
     `h' é uma função comutativa.  E.g. `h(x,z,y)' irá simplificar para
     `h(x, y, z)'.  Isto é o mesmo que `symmetric'.


 -- Função: compare (<x>, <y>)
     Retorna um operador de comparação <op> (`<', `<=', `>', `>=', `=',
     ou `#') tal que `is (<x> <op> <y>)' avalia para `true'; quando ou
     <x> ou <y> dependendo de `%i' e `<x> # <y>', retorna
     `notcomparable'; Quando não existir tal operador ou Maxima não
     estiver apto a determinar o operador, retorna `unknown'.

     Exemplos:

          (%i1) compare(1,2);
          (%o1) <
          (%i2) compare(1,x);
          (%o2) unknown
          (%i3) compare(%i,%i);
          (%o3) =
          (%i4) compare(%i,%i+1);
          (%o4) notcomparable
          (%i5) compare(1/x,0);
          (%o5) #
          (%i6) compare(x,abs(x));
          (%o6) <=

     A função `compare' não tenta de terminar se o domínio real de seus
     argumentos é não vazio; dessa forma

          (%i1) compare(acos(x^2+1), acos(x^2+1) + 1);
          (%o1) <

     O domínio real de `acos (x^2 + 1)' é vazio.


 -- Função: entier (<x>)
     Retorna o último inteiro menor que ou igual a <x> onde <x> é
     numérico.  `fix' (como em `fixnum') é um sinônimo disso, então
     `fix(<x>)' é precisamente o mesmo.


 -- Função: equal (<expr_1>, <expr_2>)
     Usado com um `is', retorna `true' (ou `false') se e somente se
     <expr_1> e <expr_2> forem iguais (ou não iguais) para todos os
     possíveis valores de suas variáveis (como determinado por
     `ratsimp').  Dessa forma `is (equal ((x + 1)^2, x^2 + 2*x + 1))'
     retorna `true' ao passo que se `x' for não associado `is ((x +
     1)^2 = x^2 + 2*x + 1)' retorna `false'.  Note também que
     `is(rat(0)=0)' retorna `false' mas `is (equal (rat(0), 0))'
     retorna `true'.

     Se uma determinação não pode ser feita, então `is (equal (a, b))'
     retorna uma expressão simplificada mas equivalente, ao passo que
     `is (a=b)' sempre retorna ou `true' ou `false'.

     Todas as variáveis que ocorrem em <expr_1> e <expr_2> são
     presumidas serem valores reais.

     A negação de `equal' é `notequal'.  Note que devido às regras de
     avaliação de expressões predicadas (em particular pelo fato de
     `not <expr>' causar a avaliação de <expr>), `notequal' não seja
     equivalente a `not equal' em alguns casos.

     `ev (<expr>, pred)' é equivalente a `is (<expr>)'.

          (%i1) é (x^2 >= 2*x - 1);
          (%o1)                         true
          (%i2) assume (a > 1);
          (%o2)                        [a > 1]
          (%i3) é (log (log (a+1) + 1) > 0 and a^2 + 1 > 2*a);
          (%o3)                         true


 -- Função: floor (<x>)
     Quando <x> for um número real, retorna o maior inteiro que é menor
     que ou igual a <x>.

     Se <x> for uma expressão constante (`10 * %pi', for exemplo),
     `floor' avalia <x> usando grandes números em ponto flutuante, e
     aplica `floor' ao grande número em ponto flutuante resultante.
     Porque `floor' usa avaliação em ponto flutuante, é possível,
     embora improvável, que `floor' não possa retornar um valor errôneo
     para entradas constantes.  Para prevenir erros, a avaliação de
     ponto flutuante é concluída usando três valores para `fpprec'.

     Para entradas não constantes, `floor' tenta retornar um valor
     simplificado.  Aqui está exemplos de simplificações que `floor'
     conhece:

          (%i1) floor(ceiling(x));
          (%o1) ceiling(x)
          (%i2) floor(floor(x));
          (%o2) floor(x)
          (%i3) declare(n,integer)$
          (%i3) [floor(n), floor(abs(n)), floor(min(n,6))];
          (%o4) [n,abs(n),min(n,6)]
          (%i4) assume(x > 0, x < 1)$
          (%i5) floor(x);
          (%o5) 0
          (%i6) tex(floor(a);
              $$\left \lfloor a \right \rfloor$$

     A função `floor' não mapeia automaticamente sobre listas ou
     matrizes.  Finalmente, para todas as entradas que forem
     manifestamente complexas, `floor' retorna uma forma substantiva.

     Se o intervalo de uma função for um subconjunto dos inteiros, o
     intervalo pode ser declarado `integervalued'. Ambas as funções
     `ceiling' e `floor' podem usar essa informação; por exemplo:

          (%i1) declare(f,integervalued)$
          (%i2) floor(f(x));
          (%o2) f(x)
          (%i3) ceiling(f(x) -1);
          (%o3) f(x)-1


 -- Função: notequal (<expr_1>, <expr_2>)
     Representa a negação de `equal (<expr_1>, <expr_2>)'.

     Note que pelo fato de as regras de avaliação de expressões
     predicadas (em particular pelo fato de `not <expr>' causar a
     avaliação de <expr>), `notequal' não é equivalente a `not equal'
     em alguns casos.

     Exemplos:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          `macsyma' was unable to evaluate the predicate:
          equal(a, b)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) maybe (not equal (a, b));
          (%o6)                        unknown
          (%i7) assume (a > b);
          (%o7)                        [a > b]
          (%i8) equal (a, b);
          (%o8)                      equal(a, b)
          (%i9) maybe (equal (a, b));
          (%o9)                         false
          (%i10) notequal (a, b);
          (%o10)                   notequal(a, b)
          (%i11) not equal (a, b);
          (%o11)                        true
          (%i12) maybe (notequal (a, b));
          (%o12)                        true
          (%i13) maybe (not equal (a, b));
          (%o13)                        true


 -- Operador: eval
     Como um argumento em uma chamada a `ev (<expr>)', `eval' causa uma
     avaliação extra de <expr>.  Veja `ev'.


 -- Função: evenp (<expr>)
     Retorna `true' se <expr> for um inteiro sempre.  `false' é
     retornado em todos os outros casos.


 -- Função: fix (<x>)
     Um sinônimo para `entier (<x>)'.


 -- Função: fullmap (<f>, <expr_1>, ...)
     Similar a `map', mas `fullmap' mantém mapeadas para baixo todas as
     subexpressões até que os operadores principais não mais sejam os
     mesmos.

     `fullmap' é usada pelo simplificador do Maxima para certas
     manipulações de matrizes; dessa forma, Maxima algumas vezes gera
     uma mensagem de erro concernente a `fullmap' mesmo apesar de
     `fullmap' não ter sido explicitamente chamada pelo usuário.

          (%i1) a + b*c$
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)


 -- Função: fullmapl (<f>, <list_1>, ...)
     Similar a `fullmap', mas `fullmapl' somente mapeia sobre listas e
     matrizes.

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]


 -- Função: is (<expr>)
     Tenta determinar se a <expr> predicada (expressões que avaliam
     para `true' ou `false') é dedutível de fatos localizados na base
     de dados de `assume'.

     Se a dedutibilidade do predicado for `true' ou `false', `is'
     retorna `true' ou `false', respectivamente.  De outra forma, o
     valor e retorno é controlado pelo sinalizador global `prederror'.
     Quando `prederror' for `false', `is' retorna `unknown' para um
     predicado que não pode ser provado ou refutado, e reporta um erro
     de outra forma.

     Veja também `assume', `facts', and `maybe'.

     Exemplos:

     `is' causa avaliação de predicados.

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) é (%pi > %e);
          (%o2)                         true

     `is' tenta derivar predicados da base de dados do assume `assume'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) é (a < b);
          (%o3)                         false
          (%i4) é (a > c);
          (%o4)                         true
          (%i5) é (equal (a, c));
          (%o5)                         false

     Se `is' não puder nem prover nem refutar uma forma predicada a
     partir da base de dados de `assume', o sinalizador global
     `prederror' governa o comportamento de `is'.

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) é (a > 0);
          `macsyma' was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) é (a > 0);
          (%o5)                        unknown


 -- Função: maybe (<expr>)
     Tenta determinar se a <expr> predicada é dedutível dos fatos na
     base de dados de `assume'.

     Se a dedutibilidade do predicado for `true' ou `false', `maybe'
     retorna `true' ou `false', respectivamente.  De outra forma,
     `maybe' retorna `unknown'.

     `maybe' é funcinalmente equivalente a `is' com `prederror: false',
     mas o resultado é computado sem atualmente atribuir um valor a
     `prederror'.

     Veja também `assume', `facts', and `is'.

     Exemplos:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true


 -- Função: isqrt (<x>)
     Retorna o "inteiro raíz quadrada" do valor absoluto de <x>, que é
     um inteiro.


 -- Função: lmax (<L>)
     Quando <L> for uma lista ou um conjunto, retorna `apply ('max,
     args (<L>))'.  Quando <L> não for uma lista ou um conjunto,
     sinaliza um erro.


 -- Função: lmin (<L>)
     Quando <L> for uma lista ou um conjunto, retorna `apply ('min,
     args (<L>))'. Quando <L> não for uma lista ou um conjunto,
     sinaliza um erro.


 -- Função: max (<x_1>, ..., <x_n>)
     Retorna um valor simplificado para o máximo entre as expressões
     <x_1> a <x_n>.  Quando `get (trylevel, maxmin)', for dois ou mais,
     `max' usa a simplificação `max (e, -e) --> |e|'.  Quando `get
     (trylevel, maxmin)' for 3 ou mais, <max> tenta eliminar expressões
     que estiverem entre dois outros argumentos; por exemplo, `max (x,
     2*x, 3*x) --> max (x, 3*x)'. Para escolher o valor de `trylevel'
     para 2, use `put (trylevel, 2, maxmin)'.


 -- Função: min (<x_1>, ..., <x_n>)
     Retorna um valor simplificado para o mínimo entre as expressões
     `x_1' through `x_n'.  Quando `get (trylevel, maxmin)', for 2 ou
     mais, `min' usa a simplificação `min (e, -e) --> -|e|'.  Quando
     `get (trylevel, maxmin)' for 3 ou mais, `min' tenta eliminar
     expressões que estiverem entre dois outros argumentos; por exemplo,
     `min (x, 2*x, 3*x) --> min (x, 3*x)'. Para escolher o valor de
     `trylevel' para 2, use `put (trylevel, 2, maxmin)'.


 -- Função: polymod (<p>)
 -- Função: polymod (<p>, <m>)
     Converte o polinômio <p> para uma representação modular com
     relação ao módulo corrente que é o valor da variável `modulus'.

     `polymod (<p>, <m>)' especifica um módulo <m> para ser usado em
     lugar do valor corrente de `modulus'.

     Veja `modulus'.


 -- Função: mod (<x>, <y>)
     Se <x> e <y> forem números reais e <y> for não nulo, retorna `<x>
     - <y> * floor(<x> / <y>)'.  Adicionalmente para todo real <x>, nós
     temos `mod (<x>, 0) = <x>'. Para uma discursão da definição `mod
     (<x>, 0) = <x>', veja a Seção 3.4, de "Concrete Mathematics," por
     Graham, Knuth, e Patashnik. A função `mod (<x>, 1)' é uma função
     dente de serra com peródo 1 e com `mod (1, 1) = 0' e `mod (0, 1) =
     0'.

     Para encontrar o argumento principal (um número no intervalo
     `(-%pi, %pi]') de um número complexo, use a função `<x> |-> %pi -
     mod (%pi - <x>, 2*%pi)', onde <x> é um argumento.

     Quando <x> e <y> forem expressões constantes (`10 * %pi', por
     exemplo), `mod' usa o mesmo esquema de avaliação em ponto
     flutuante que `floor' e `ceiling' usam.  Novamente, é possível,
     embora improvável, que `mod' possa retornar um valor errôneo
     nesses casos.

     Para argumentos não numéricos <x> ou <y>, `mod 'conhece muitas
     regras de simplificação:

          (%i1) mod(x,0);
          (%o1) x
          (%i2) mod(a*x,a*y);
          (%o2) a*mod(x,y)
          (%i3) mod(0,x);
          (%o3) 0


 -- Função: oddp (<expr>)
     é `true' se <expr> for um inteiro ímpar.  `false' é retornado em
     todos os outros casos.


 -- Operador: pred
     Como um argumento em uma chamada a `ev (<expr>)', `pred' faz com
     que predicados (expressões que avaliam para `true' ou `false')
     sejam avaliados.  Veja `ev'.


 -- Função: make_random_state (<n>)
 -- Função: make_random_state (<s>)
 -- Função: make_random_state (true)
 -- Função: make_random_state (false)
     Um objeto de estado randômico representa o estado do gerador de
     números randômicos (aleatórios).  O estado compreende 627 palavras
     de 32 bits.

     `make_random_state (<n>)' retorna um novo objeto de estado
     randômico criado de um valor inteiro semente igual a <n> modulo
     2^32.  <n> pode ser negativo.

     `make_random_state (<s>)' retorna uma copia do estado randômico
     <s>.

     `make_random_state (true)' retorna um novo objeto de estado
     randômico, usando a hora corrente  do relógio do computador como
     semente.

     `make_random_state (false)' retorna uma cópia do estado corrente
     do gerador de números randômicos.


 -- Função: set_random_state (<s>)
     Copia <s> para o estado do gerador de números randômicos.

     `set_random_state' sempre retorna `done'.


 -- Função: random (<x>)
     Retorna um número pseudorandômico. Se <x> é um inteiro, `random
     (<x>)' retorna um inteiro de 0 a `<x> - 1' inclusive. Se <x> for
     um número em ponto flutuante, `random (<x>)' retorna um número não
     negativo em ponto flutuante menor que <x>.  `random' reclama com
     um erro se <x> não for nem um inteiro nem um número em ponto
     flutuante, ou se <x> não for positivo.

     As funções `make_random_state' e `set_random_state' mantém o
     estado do gerador de números randômicos.

     O gerador de números randômicos do Maxima é uma implementação do
     algorítmo de Mersenne twister MT 19937.

     Exemplos:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


 -- Função: rationalize (<expr>)
     Converte todos os números em ponto flutuante de precisão dupla e
     grandes números em ponto flutuante na expressão do Maxima <expr>
     para seus exatos equivalentes racionais. Se você não estiver
     faminilarizado com a representação binária de números em ponto
     flutuante, você pode se surpreender que `rationalize (0.1)' não
     seja igual a 1/10.  Esse comportamento não é especial para o
     Maxima - o número 1/10 tem uma representação binária repetitiva e
     não terminada.

          (%i1) rationalize(0.5);
          (%o1) 1/2
          (%i2) rationalize(0.1);
          (%o2) 3602879701896397/36028797018963968
          (%i3) fpprec : 5$
          (%i4) rationalize(0.1b0);
          (%o4) 209715/2097152
          (%i5) fpprec : 20$
          (%i6) rationalize(0.1b0);
          (%o6) 236118324143482260685/2361183241434822606848
          (%i7) rationalize(sin(0.1 * x + 5.6));
          (%o7) sin((3602879701896397*x)/36028797018963968+3152519739159347/562949953421312)

     Exemplo de utilização:

          unitfrac(r) := block([uf : [], q],
             if not(ratnump(r)) then error("The input to 'unitfrac' must be a rational number"),
             while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
             reverse(uf));

          (%i2) unitfrac(9/10);
          (%o2) [1/2,1/3,1/15]
          (%i3) apply("+",%);
          (%o3) 9/10
          (%i4) unitfrac(-9/10);
          (%o4) [-1,1/10]
          (%i5) apply("+",%);
          (%o5) -9/10
          (%i6) unitfrac(36/37);
          (%o6) [1/2,1/3,1/8,1/69,1/6808]
          (%i7) apply("+",%);
          (%o7) 36/37


 -- Função: sign (<expr>)
     Tenta determinar o sinal de <expr> a partir dos fatos na base de
     dados corrente.  Retorna uma das seguintes respostar: `pos'
     (positivo), `neg' (negativo), `zero', `pz' (positivo ou zero),
     `nz' (negativo ou zero), `pn' (positivo ou negativo), ou `pnz'
     (positivo, negativo, ou zero, i.e. nada se sabe sobre o sinal da
     epressão).


 -- Função: signum (<x>)
     Para um <x> numérico retorna 0 se <x> for 0, de outra forma
     retorna -1 ou +1 à medida que <x> seja menor ou maior que 0,
     respectivamente.

     Se <x> não for numérico então uma forma simplificada mas
     equivalente é retornada.  Por exemplo, `signum(-x)' fornece
     `-signum(x)'.


 -- Função: sort (<list>, <p>)
 -- Função: sort (<list>)
     Ordena a <list> conforme o predicado `p' de dois argumentos, tais
     como `"<"' ou `orderlessp'.

     `sort (<list>)' ordena a <list> conforme a ordem interna do Maxima.

     <list> pode conter ítens numéricos ou não numéricos, ou ambos.


 -- Função: sqrt (<x>)
     A raíz quadrada de <x>. É representada internamente por
     `<x>^(1/2)'.  Veja também `rootscontract'.

     `radexpand' se `true' fará com que n-ésimas raízes de fatores de
     um produto que forem potências de n sejam colocados fora do
     radical, e.g.  `sqrt(16*x^2)' retonará `4*x' somente se
     `radexpand' for `true'.


 -- Variável de opção: sqrtdispflag
     Valor padrão: `true'

     Quando `sqrtdispflag' for `false', faz com que `sqrt' seja
     mostrado como expoente 1/2.


 -- Função: sublis (<list>, <expr>)
     Faz multiplas substituições paralelas dentro de uma expressão.

     A variável `sublis_apply_lambda' controla a simplificação após
     `sublis'.

     Exemplo:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)


 -- Função: sublist (<list>, <p>)
     Retorna a lista de elementos da <list> da qual o predicado `p'
     retornar `true'.

     Exemplo:

          (%i1) L: [1, 2, 3, 4, 5, 6]$
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]


 -- Variável de opção: sublis_apply_lambda
     Valor padrão: `true' - controla se os substitutos de `lambda' são
     aplicados na simplificação após as `sublis' serem usadas ou se
     você tem que fazer um `ev' para pegar coisas para aplicar.  `true'
     significa faça a aplicação.


 -- Função: subst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <b> deve ser um átomo ou uma
     subexpressão completa de <c>.  Por exemplo, `x+y+z' é uma
     subexpressão completa de `2*(x+y+z)/w' enquanto `x+y' não é.
     Quando <b> não tem essas características, pode-se algumas vezes
     usar `substpart' ou `ratsubst' (veja abaixo).  Alternativamente,
     se <b> for da forma de `e/f' então se poderá usar `subst (a*f, e,
     c)' enquanto se <b> for da forma `e^(1/f)' então se poderá usar
     `subst (a^f, e, c)'.  O comando `subst' também discerne o `x^y' de
     `x^-y' de modo que `subst (a, sqrt(x), 1/sqrt(x))' retorna `1/a'.
     <a> e <b> podem também ser operadores de uma expressão contida
     entre aspas duplas `"' ou eles podem ser nomes de função.  Se se
     desejar substituir por uma variável independente em formas
     derivadas então a função `at' (veja abaixo) poderá ser usada.

     `subst' é um álias para `substitute'.

     `subst (<eq_1>, <expr>)' ou `subst ([<eq_1>, ..., <eq_k>], <expr>)'
     são outras formas permitidas.  As <eq_i> são equações indicando
     substituições a serem feitas.  Para cada equação, o lado direito
     será substituído pelo lado esquerdo na expressão <expr>.

     `exptsubst' se `true' permite que substituições como `y' por
     `%e^x' em `%e^(a*x)' ocorram.

     Quando `opsubst' for `false', `subst' tentará substituir dentro do
     operador de uma expressão.  E.g. `(opsubst: false, subst (x^2, r,
     r+r[0]))' trabalhará.

     Exemplos:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     Para exemplos adicionais, faça `example (subst)'.


 -- Função: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Similar a `substpart', mas `substinpart' trabalha sobre a
     representação interna de <expr>.

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       D
          (%o1)                    x . --- (f(x))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x+1), 0);
          (%o3)                       f1(x + 1)

     Se o último argumento para a função `part' for uma lista de
     índices então muitas subexpressões são escolhidas, cada uma
     correspondendo a um índice da lista.  Dessa forma

          (%i1) part (x+y+z, [1, 3]);
          (%o1)                         z + x

     `piece' recebe o valor da última expressão selecionada quando
     usando as funções `part'.  É escolhida durante a execução da
     função e dessa forma pode ser referenciada para a própria função
     como mostrado abaixo.  Se `partswitch' é escolhido para `true'
     então `end' é retornado quando uma parte selecionada de uma
     expressão não existir, de outra forma uma mensagem de erro é
     fornecida.

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     Também, escolhendo a opção `inflag' para `true' e chamando `part'
     ou `substpart' é o mesmo que chamando `inpart' ou `substinpart'.


 -- Função: substpart (<x>, <expr>, <n_1>, ..., <n_k>)
     Substitue <x> para a subexpressão selecionada pelo resto dos
     argumentos como em `part'.  Isso retorna o novo valor de <expr>.
     <x> pode ser algum operador a ser substituído por um operador de
     <expr>.  Em alguns casos <x> precisa ser contido em aspas duplas
     `"' (e.g.  `substpart ("+", a*b, 0)' retorna `b + a').

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f (b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     Também, escolhendo a opção `inflag' para `true' e chamando `part'
     ou `substpart' é o mesmo que chamando `inpart' ou `substinpart'.


 -- Função: subvarp (<expr>)
     Retorna `true' se <expr> for uma variável subscrita, por exemplo
     `a[i]'.


 -- Função: symbolp (<expr>)
     Retorna `true' se <expr> for um símbolo, de outra forma retorna
     `false'.  com efeito, `symbolp(x)' é equivalente ao predicado
     `atom(x) and not numberp(x)'.

     Veja também `Identifiers'


 -- Função: unorder ()
     Disabilita a ação de alias criada pelo último uso dos comandos de
     ordenação `ordergreat' e `orderless'. `ordergreat' e `orderless'
     não podem ser usados mais que uma vez cada sem chamar `unorder'.
     Veja também `ordergreat' e `orderless'.

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x + a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat (a);
          (%o3)                         done
          (%i4) b*x + a^2;
                                       2
          (%o4)                       a  + b x
          (%i5) %th(1) - %th(3);
                                        2    2
          (%o5)                        a  - a
          (%i6) unorder();
          (%o6)                          [a]


 -- Função: vectorpotential (<givencurl>)
     Retorna o potencial do vetor de um dado vetor de torção, no
     sistema de coordenadas corrente.  `potentialzeroloc' tem um papel
     similar ao de `potential', mas a ordem dos lados esquerdos das
     equações deve ser uma permutação cíclica das variáveis de
     coordenadas.


 -- Função: xthru (<expr>)
     Combina todos os termos de <expr> (o qual pode ser uma adição)
     sobre um denominador comum sem produtos e somas exponenciadas como
     `ratsimp' faz.  `xthru' cancela fatores comuns no numerador e
     denominador de expressões racionais mas somente se os fatores são
     explícitos.

     Algumas vezes é melhor usar `xthru' antes de `ratsimp' em uma
     expressão com o objetivo de fazer com que fatores explicitos do
     máximo divisor comum entre o numerador e o denominador seja
     cancelado simplificando dessa forma a expressão a ser aplicado o
     `ratsimp'.

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


 -- Função: zeroequiv (<expr>, <v>)
     Testa se a expressão <expr> na variável <v> é equivalente a zero,
     retornando `true', `false', ou `dontknow' (não sei).

     `zeroequiv' Tem essas restrições:
       1. Não use funções que o Maxima não sabe como diferenciar e
          avaliar.

       2. Se a expressão tem postes sobre o eixo real, podem existir
          erros no resultado (mas isso é improvável ocorrer).

       3. Se a expressão contem funções que não são soluções para
          equações diferenciais de primeira ordem (e.g.  funções de
          Bessel) pode ocorrer resultados incorretos.

       4. O algorítmo usa avaliação em pontos aleatóriamente escolhidos
          para subexpressões selecionadas cuidadosamente.  Isso é
          sempre negócio um tanto quanto perigoso, embora o algorítmo
          tente minimizar o potencial de erro.

     Por exemplo  `zeroequiv (sin(2*x) - 2*sin(x)*cos(x), x)' retorna
     `true' e `zeroequiv (%e^x + x, x)' retorna `false'.  Por outro
     lado `zeroequiv (log(a*b) - log(a) - log(b), a)' retorna
     `dontknow' devido à presença de um parâmetro extra `b'.



File: maxima.info,  Node: Expressões,  Next: Simplificação,  Prev: Operadores,  Up: Top

6 Expressões
************

* Menu:

* Introdução a Expressões::
* Atribuição::
* Complexo::
* Substantivos e Verbos::
* Identificadores::
* Desigualdade::
* Sintaxe::
* Definições para Expressões::


File: maxima.info,  Node: Introdução a Expressões,  Next: Atribuição,  Prev: Expressões,  Up: Expressões

6.1 Introdução a Expressões
===========================

Existe um conjunto de palavras reservadas que não pode ser usado como
nome de variável.   Seu uso pode causar um possível erro crítico de
sintaxe.

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Muitas coisas em Maxima são expressões.   Uma seqüência de expressões
pode ser feita dentro de uma expressão maior através da separação
dessas através de vírgulas e colocando parêntesis em torno dela.   Isso
é similar ao C expressão com vírgula.

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   Mesmo ciclos em Maxima são expressões, embora o valor de retorno
desses ciclos não seja muito útil (eles retornam sempre `done').

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   contanto que o que você realmente queira é provavelmente incluir um
terceiro termo na expressão com vírgula que atualmente fornece de volta
o valor.

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Atribuição,  Next: Complexo,  Prev: Introdução a Expressões,  Up: Expressões

6.2 Atribuição
==============

Existem dois operadores de atribuição no Maxima, "`:'" e "`::'".  E.g.,
`a: 3' escolhe a variável `a' para 3. `::' atribui o valor da expressão
sobre seu lado direito para o valor da quantidade sobre seu lado
esquerdo, que deve avaliar para uma variável atômica ou para uma
variável subscrita.


File: maxima.info,  Node: Complexo,  Next: Substantivos e Verbos,  Prev: Atribuição,  Up: Expressões

6.3 Complexo
============

Uma expressão complexa é especificada no Maxima através da adição da
parte real da expressão a `%i' vezes a parte imaginária.  Dessa forma as
raízes da equação `x^2 - 4*x + 13 = 0' são `2 + 3*%i' e `2 - 3*%i'.
Note que produtos de simplificação de expressões complexas podem ter
efeito através da expansão do produto.  Simplificação de quocientes,
raízes, e outras funções de expressões complexas podem usualmente serem
realizadas através do uso das funções `realpart', `imagpart',
`rectform', `polarform', `abs', `carg'.


File: maxima.info,  Node: Substantivos e Verbos,  Next: Identificadores,  Prev: Complexo,  Up: Expressões

6.4 Substantivos e Verbos
=========================

Maxima distingue entre operadores que são "substantivos" e operadores
que são "verbos".  Um verbo é um operador que pode ser executado.  Um
substantivo é um operador que aparece como um símbolo em uma expressão,
sem ser executado.  Por padrão, nomes de função são verbos.  Um verbo
pode ser mudado em um substantivo através da adição de um apóstrofo no
início do nome da função ou aplicando a função `nounify'.  Um
substantivo pode ser mudado em um verbo através da aplicação da função
`verbify'.  O sinalizador de avaliação `nouns' faz com que `ev' avalie
substantivos em uma expressão.

   A forma verbal é distinguida através de um sinal de dólar `$' no
início do símbolo Lisp correspondente.  De forma oposta, a forma
substantiva é distinguida através de um sinal de `%' no início do
símbolo Lisp correspondente.  Alguns substantivos possuem propriedades
especiais de exibição, tais como `'integrate' e `'derivative'
(retornado por `diff'), mas muitos não.  Por padrão, as formas
substantiva e verbal de uma função são idênticas quando mostradas.  O
sinalizador global `noundisp' faz com que Maxima mostre substantivos
com um apóstrofo no início `''.

   Veja também `noun', `nouns', `nounify', e `verbify'.

   Exemplos:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identificadores,  Next: Desigualdade,  Prev: Substantivos e Verbos,  Up: Expressões

6.5 Identificadores
===================

Identificadores do Maxima podem compreender caracteres alfabéticos,
mais os numerais de 0 a 9, mais qualquer caractere especial precedido
por um caractere contra-barra `\'.

   Um numeral pode ser o primeiro caractere de um identificador se esse
numeral for precedido por uma contra barra.  Numerais que forem o
segundo ou o último caractere não precisam ser precedidos por uma
contra barra.

   Um caractere especial pode ser declarado alfabético através da
função `declare'.  Se isso ocorrer, esse caractere não precisa ser
precedido por uma contra barra em um identificador.  Os caracteres
alfabéticos vão inicialmente de `A' a `Z', de `a' a `z', `%', e `_'.

   Maxima é sensível à caixa . Os identificadores `algumacoisa',
`ALGUMACOISA', e `Algumacoisa' são distintos.  Veja *Note Lisp e
Maxima:: para mais sobre esse ponto.

   Um identificador Maxima é um símbolo Lisp que começa com um sianl de
dólar `$'.  Qualquer outro símbolo Lisp é precedido por um ponto de
interrogação `?' quando aparecer no Maxima.  Veja *Note Lisp e Maxima::
para maiores detalhes sobre esse ponto.

   Exemplos:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Desigualdade,  Next: Sintaxe,  Prev: Identificadores,  Up: Expressões

6.6 Desigualdade
================

Maxima tem os operadores de desigualdade `<', `<=', `>=', `>', `#', e
`notequal'.  Veja `if' para uma descrição de expressões condicionais.


File: maxima.info,  Node: Sintaxe,  Next: Definições para Expressões,  Prev: Desigualdade,  Up: Expressões

6.7 Sintaxe
===========

É possível definir novos operadores com precedência especificada,
remover a definição de operadores existentes, ou redefinir a
precedência de operadores existentes.  Um operador pode ser unário
prefixado ou unário pósfixado, binario infixado, n-ário infixado,
matchfix, ou nofix.  "Matchfix" significa um par de símbolos que
abraçam seu argumento ou seus argumentos, e "nofix" significa um
operador que não precisa de argumentos.  Como exemplos dos diferentes
tipos de operadores, existe o seguinte.

unário prefixado
     negação `- a'

unário posfixado
     fatorial `a!'

binário infixado
     exponenciação `a^b'

n-ário infixado
     adição `a + b'

matchfix
     construção de lista `[a, b]'

   (Não existe operadores internos nofix; para um exemplo de tal
operador, veja `nofix'.)

   O mecanismo para definir um novo operador é direto.  Somente é
necessário declarar uma função como um operador; a função operador pode
ou não estar definida previamente.

   Um exemplo de operadores definidos pelo usuário é o seguinte.  Note
que a chamada explícita de função `"dd" (a)' é equivalente a `dd a', da
mesma forma `"<-" (a, b)' é equivalente a `a <- b'.  Note também que as
funções `"dd"' e `"<-"' são indefinidas nesse exemplo.

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   As funções máxima que definem novos operadores estão sumarizadas
nessa tabela, equilibrando expoente associado esquerdo (padrão) e o
expoente associado direito ("eae" e "ead", respectivamente).
(Associação de expoentes determina a precedência do operador. todavia,
uma vez que os expoentes esquerdo e diretiro podem ser diferentes,
associação de expoentes é até certo ponto mais complicado que
precedência.)  Alguma das funções de definição de operações tomam
argumentos adicionais; veja as descrições de função para maiores
detalhes.

`prefixado'
     ead=180

`posfixado'
     eae=180

`infixado'
     eae=180, ead=180

`nário'
     eae=180, ead=180

`matchfix'
     (associação de expoentes não é aplicável)

`nofix'
     (associação de expoentes não é aplicável)

   Para comparação, aqui está alguns operadores internos e seus
expoentes associados esquerdo e direito.

     Operador   eae     ead

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   `remove' e `kill' removem propriedades de operador de um átomo.
`remove ("<a>", op)' remove somente as propriedades de operador de <a>.
`kill ("<a>")' remove todas as propriedades de <a>, incluindo as
propriedades de operador.  Note que o nome do operador dever estar
abraçado por aspas duplas.

     (%i1) infix ("@");
     (%o1)                           @
     (%i2) "@" (a, b) := a^b;
                                          b
     (%o2)                      a @ b := a
     (%i3) 5 @ 3;
     (%o3)                          125
     (%i4) remove ("@", op);
     (%o4)                         done
     (%i5) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i5) "@" (5, 3);
     (%o5)                          125
     (%i6) infix ("@");
     (%o6)                           @
     (%i7) 5 @ 3;
     (%o7)                          125
     (%i8) kill ("@");
     (%o8)                         done
     (%i9) 5 @ 3;
     Incorrect syntax: @ is not an infix operator
     5 @
      ^
     (%i9) "@" (5, 3);
     (%o9)                        @(5, 3)


File: maxima.info,  Node: Definições para Expressões,  Prev: Sintaxe,  Up: Expressões

6.8 Definições para Expressões
==============================

 -- Função: at (<expr>, [<eqn_1>, ..., <eqn_n>])
 -- Função: at (<expr>, <eqn>)
     Avalia a expressão <expr> com as variáveis assumindo os valores
     como especificado para elas na lista de equações `[<eqn_1>, ...,
     <eqn_n>]' ou a equação simples <eqn>.

     Se uma subexpressão depender de qualquer das variáveis para a qual
     um valor foi especificado mas não existe `atvalue' especificado e
     isso não pode ser de outra forma avaliado, então uma forma
     substantiva de `at' é retornada que mostra em uma forma
     bidimensional.

     `at' realiza múltiplas substituições em série, não em paralelo.

     Veja também `atvalue'.  Para outras funções que realizam
     substituições, veja também `subst' e `ev'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Função: box (<expr>)
 -- Função: box (<expr>, <a>)
     Retorna <expr> dentro de uma caixa.  O valor de retorno é uma
     expressão com `box' como o operador e <expr> como o argumento.
     Uma caixa é desenhada sobre a tela quando `display2d' for `true'.

     `box (<expr>, <a>)' Empacota <expr> em uma caixa rotulada pelo
     símbolo <a>.  O rótulo é truncado se for maior que a largura da
     caixa.

     Uma expressão dentro de uma caixa não avalia para seu conteúdo,
     então expressões dentro de caixas são efetivamente excluídas de
     cálculos.

     `boxchar' é o caractere usado para desenhar a caixa em `box' e nas
     funções `dpart' e `lpart'.

     Exemplos:

          (%i1) box (a^2 + b^2);
                       """""""""
                       " 2   2 "
          (%o1)        "b  + a "
                       """""""""
          (%i2) box (a^2 + b^2, term_1);
                       term_1"""
                       " 2   2 "
          (%o2)        "b  + a "
                       """""""""
          (%i3) 1729 - box (1729);
                            """"""
          (%o3)      1729 - "1729"
                            """"""
          (%i4) boxchar: "-";
          (%o4)            -
          (%i5) box (sin(x) + cos(y));
                          -----------------
          (%o5)           -COS(y) + SIN(x)-
                          -----------------
          (%i6)


 -- Variável de opção: boxchar
     Valor padrão: `"'

     `boxchar' é o caractere usado para desenhar a caixa por `box' e
     nas funções `dpart' e `lpart'.

     Todas as caixas em uma expressão são desenhadas com o valor atual
     de `boxchar'; o caractere de desenho não é armazenado com a
     expressão de caixa. Isso quer dizer que se você desenhar uma caixa
     e em seguida mudar o caractere de desenho a caixa anteriormente
     desenhada será redesenhada com o caractere mudado caso isso seja
     solicitado.


 -- Função: carg (<z>)
     Retorna o argumento complexo de <z>.  O argumento complexo é um
     ângulo `theta' no intervalo de `(-%pi, %pi]' tal que `r exp (theta
     %i) = <z>' onde `r' é o módulo de <z>.

     `carg' é uma função computacional, não uma função de simplificação.

     `carg' ignora a declaração `declare (<x>, complex)', e trata <x>
     como uma variável real.  Isso é um erro.  Veja também `abs'
     (módulo de número complexo), `polarform', `rectform', `realpart',
     e `imagpart'.

     Exemplos:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2


 -- Opereador especial: constant
     `declare (<a>, constant)' declara <a> para ser uma constante.
     Veja `declare'.


 -- Função: constantp (<expr>)
     Retorna `true' se <expr> for uma expressão constante, de outra
     forma retorna `false'.

     Uma expressão é considerada uma expressão constante se seus
     argumentos forem números (incluindo números racionais, como
     mostrado com `/R/'), constantes simbólicas como `%pi', `%e', e
     `%i', variáveis associadas a uma constante ou constante declarada
     através de `declare', ou funções cujos argumentos forem constante.

     `constantp' avalia seus argumentos.

     Exemplos:

          (%i1) constantp (7 * sin(2));
          (%o1) 				     TRUE
          (%i2) constantp (rat (17/29));
          (%o2) 				     TRUE
          (%i3) constantp (%pi * sin(%e));
          (%o3) 				     TRUE
          (%i4) constantp (exp (x));
          (%o4) 				     FALSE
          (%i5) declare (x, constant);
          (%o5) 				     DONE
          (%i6) constantp (exp (x));
          (%o6) 				     TRUE
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7) 				     FALSE
          (%i8)


 -- Função: declare (<a_1>, <f_1>, <a_2>, <f_2>, ...)
     Atribui ao átomo <a_i> o sinalizador <f_i>.  Os <a_i>'s e <f_i>'s
     podem também serem listas de átomos e sinalizadores
     respectivamente nesse caso cada um dos átomos tomam todas as
     propriedades.

     `declare' não avalia seus argumentos.  `declare' sempre retorna
     `done'.

     Os possíveis sinalizadores e seus significados são:

     `constant' torna <a_i> uma constate como é `%pi'.

     `mainvar' torna <a_i> uma `mainvar' (variável principal).  A
     escala de ordenação para átomos: numeros < constantes (e.g. `%e',
     `%pi') < escalares < outras variáveis < variáveis principais.

     `scalar' torna <a_i> um escalar.

     `nonscalar' faz <a_i> comportar-se como como comporta-se uma lista
     ou matriz com relação ao operador ponto.

     `noun' torna a função <a_i> um substantivo de forma que não possa
     ser avaliada automaticamente.

     `evfun' torna <a_i> conhecido para a função `ev' de forma que `ev'
     possa vir a ser aplicada se seu nome for mencionado.  Veja `evfun'.

     `evflag' torna <a_i> conhecido para a função `ev' de forma que
     `ev' possa vir a ser associado a `true' durante a execução de `ev'
     se isso for mencionado.  Veja `evflag'.

     `bindtest' faz com que <a_i> sinalize um erro se isso mesmo for
     usado em um cálculo não associado.

     Maxima atualmente reconhe os seguintes recursos de objetos:

          even, odd, integer, rational, irrational, real, imaginary,
          e complex

     Que pode ser traduzido para o português como:

          par, ímpar, inteiro, racional, irracional, real, imaginário,
          e complexo

     Os recursos úteis de funções incluem:

          increasing,
          decreasing, oddfun (odd function), evenfun (even function),
          commutative (or symmetric), antisymmetric, lassociative and
          rassociative

     Que pode ser traduzido para o português como:
          incremento,
          decremento, oddfun (função ímpar), evenfun (função par),
          comutativa (ou simetrica), antisimetrica, lassociative (associativa à esquerda) and
          rassociative (associativa à direita).

     Os <a_i> e <f_i> podem também serem listas de objetos ou recursos.

     `featurep (<objeto>, <recurso>)' determina se <objeto> foi
     declarado para ter <recurso>.

     Veja também `features'.


 -- Função: disolate (<expr>, <x_1>, ..., <x_n>)
     é similar a `isolate (<expr>, <x>)' exceto que isso habilita ao
     usuário isolar mais que uma variável simultâneamente.  Isso pode
     ser útil, por exemplo, se se for tentado mudar variáveis em uma
     integração múltipla, e em mudança de variável envolvendo duas ou
     mais das variáveis de integração.  Essa função é chamada
     automaticamente de `simplification/disol.mac'.  Uma demostração
     está disponível através de `demo("disol")$'.


 -- Função: dispform (<expr>)
     Retorna a representação externa de <expr> com relação a seu
     principal operador.  Isso pode ser útil em conjunçào com `part' que
     também lida com a representação externa.  Suponha que <expr> seja
     -A .  Então a representação interna de <expr> é  "*"(-1,A),
     enquanto que a representaçào externa é "-"(A). `dispform (<expr>,
     all)' converte a expressão inteira (não apenas o nível mais alto)
     para o formato externo.  Por exemplo, se `expr: sin (sqrt (x))',
     então `freeof (sqrt, expr)' e `freeof (sqrt, dispform (expr))'
     fornece `true', enquanto `freeof (sqrt, dispform (expr, all))'
     fornece `false'.


 -- Função: distrib (<expr>)
     Distribue adições sobre produtos.  `distrib' difere de `expand' no
     fato de que `distrib' trabalha em somente no nível mais alto de
     uma expressão, i.e., `distrib' não é recursiva e `distrib' é mais
     rápida que `expand'.  `distrib' difere de `multthru' no que
     `distrib' expande todas as adições naquele nível.

     Exemplos:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c


 -- Função: dpart (<expr>, <n_1>, ..., <n_k>)
     Seleciona a mesma subexpressão que `part', mas em lugar de apenas
     retornar aquela subexpressão como seu valor, isso retorna a
     expressão completa com a subexpressão selecionada mostrada dentro
     de uma caixa.  A caixa é atualmente parte da expressão.

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """


 -- Função: exp (<x>)
     Representa função exponencial.  Instâncias de `exp (<x>)' em uma
     entrada são simplificadas para `%e^<x>'; `exp' não aparece em
     expressões simplificadas.

     `demoivre' se `true' faz com que `%e^(a + b %i)' simplificar para
     `%e^(a (cos(b) + %i sin(b)))' se `b' for livre de `%i'. veja
     `demoivre'.

     `%emode', quando `true', faz com que `%e^(%pi %i x)' seja
     simplificado. Veja `%emode'.

     `%enumer', quando `true' faz com que `%e' seja substituído por
     2.718...  quando `numer' for `true'. Veja `%enumer'.


 -- Variável de opção: %emode
     Valor padrão: `true'

     Quando `%emode' for `true', `%e^(%pi %i x)' é simplificado como
     segue.

     `%e^(%pi %i x)' simplifica para `cos (%pi x) + %i sin (%pi x)' se
     `x' for um inteiro ou um multiplo de 1/2, 1/3, 1/4, ou 1/6, e
     então é adicionalmente simplificado.

     Para outro `x' numérico, `%e^(%pi %i x)' simplifica para `%e^(%pi
     %i y)' onde `y' é `x - 2 k' para algum inteiro `k' tal que `abs(y)
     < 1'.

     Quando `%emode' for `false', nenhuma simplificação adicional de
     `%e^(%pi %i x)' é realizada.


 -- Variável de opção: %enumer
     Valor padrão: `false'

     Quando `%enumer' for `true', `%e' é substituido por seu valor
     numérico 2.718...  mesmo que `numer' seja `true'.

     Quando `%enumer' for `false', essa substituição é realizada
     somente se o expoente em `%e^x' avaliar para um número.

     Veja também `ev' e `numer'.


 -- Variável de opção: exptisolate
     Valor padrão: `false'

     `exptisolate', quando `true', faz com que `isolate (expr, var)'
     examine expoentes de átomos (tais como `%e') que contenham `var'.


 -- Variável de opção: exptsubst
     Valor padrão: `false'

     `exptsubst', quando `true', permite substituições tais como `y'
     para `%e^x' em `%e^(a x)'.


 -- Função: freeof (<x_1>, ..., <x_n>, <expr>)
     `freeof (<x_1>, <expr>)' Retorna `true' se nenhuma subexpressão de
     <expr> for igual a <x_1> ou se <x_1> ocorrer somente uma variável
     que não tenha associação fora da expressão <expr>, e retorna
     `false' de outra forma.

     `freeof (<x_1>, ..., <x_n>, <expr>)' é equivalente a `freeof
     (<x_1>, <expr>) and ... and freeof (<x_n>, <expr>)'.

     Os argumentos <x_1>, ..., <x_n> podem ser nomes de funções e
     variáveis, nomes subscritos, operadores (empacotados em aspas
     duplas), ou expressões gerais.  `freeof' avalia seus argumentos.

     `freeof' opera somente sobre <expr> como isso representa (após
     simplificação e avaliação) e não tenta determinar se alguma
     expressão equivalente pode fornecer um resultado diferente.  Em
     particular, simplificação pode retornar uma expressão equivalente
     mas diferente que compreende alguns diferentes elementos da forma
     original de <expr>.

     Uma variável é uma variável dummy em uma expressão se não tiver
     associação fora da expressão.  Variáveis dummy recoreconhecidas
     através de `freeof' são o índice de um somatório ou produtório, o
     limite da variável em `limit', a variável de integração na forma
     de integral definida de `integrate', a variável original em
     `laplace', variáveis formais em expressoes `at', e argumentos em
     expressões `lambda'.  Variáveis locais em `block' não são
     reconhecidas por `freeof' como variáveis dummy; isso é um bug.

     A forma indefinida de `integrate' not é livre de suas variáveis de
     integração.

        * Argumentos são nomes de funções, variáveis, nomes subscritos,
          operadores, e expressões.  `freeof (a, b, expr)' é
          equivalente a `freeof (a, expr) and freeof (b, expr)'.

               (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                                d + c  3
               (%o1)                   cos(a ) b      z
                                            1
               (%i2) freeof (z, expr);
               (%o2)                         false
               (%i3) freeof (cos, expr);
               (%o3)                         false
               (%i4) freeof (a[1], expr);
               (%o4)                         false
               (%i5) freeof (cos (a[1]), expr);
               (%o5)                         false
               (%i6) freeof (b^(c+d), expr);
               (%o6)                         false
               (%i7) freeof ("^", expr);
               (%o7)                         false
               (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
               (%o8)                         true

        * `freeof' avalia seus argumentos.

               (%i1) expr: (a+b)^5$
               (%i2) c: a$
               (%i3) freeof (c, expr);
               (%o3)                         false

        * `freeof' não considera expressões equivalentes.
          Simplificação pode retornar uma expressão equivalente mas
          diferente.

               (%i1) expr: (a+b)^5$
               (%i2) expand (expr);
                         5        4       2  3       3  2      4      5
               (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
               (%i3) freeof (a+b, %);
               (%o3)                         true
               (%i4) freeof (a+b, expr);
               (%o4)                         false
               (%i5) exp (x);
                                                x
               (%o5)                          %e
               (%i6) freeof (exp, exp (x));
               (%o6)                         true

        * Um somatório ou uma integral definida está livre de uma
          variável dummy.  Uma integral indefinida não é livre de suas
          variáveis de integração.

               (%i1) freeof (i, 'sum (f(i), i, 0, n));
               (%o1)                         true
               (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
               (%o2)                         true
               (%i3) freeof (x, 'integrate (x^2, x));
               (%o3)                         false


 -- Função: genfact (<x>, <y>, <z>)
     Retorna o fatorial generalizado, definido como `x (x-z) (x - 2 z)
     ... (x - (y - 1) z)'.  Dessa forma, para integral <x>, `genfact
     (x, x, 1) = x!' e `genfact (x, x/2, 2) = x!!'.


 -- Função: imagpart (<expr>)
     Retorna a parte imaginária da expressão <expr>.

     `imagpart' é uma função computacional, não uma função de
     simplificação.

     Veja também `abs', `carg', `polarform', `rectform', e `realpart'.


 -- Função: infix (<op>)
 -- Função: infix (<op>, <lbp>, <rbp>)
 -- Função: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)
     Declara <op> para ser um operador infixo.  Um operador infixo é
     uma função de dois argumentos, com o nome da função escrito entre
     os argumentos.  Por exemplo, o operador de subtração `-' é um
     operador infixo.

     `infix (<op>)' declara <op> para ser um operador infixo com
     expoentes associados padrão (esquerdo e direito ambos iguais a 180)
     e podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a `any').

     `infix (<op>, <lbp>, <rbp>)' declara <op> para ser um operador
     infixo com expoentes associados esquerdo e diretio equilibrados e
     podendo ser qualquer entre prefixado, infixado, posfixado, nário,
     matchfix e nofix (esquerdo e direito ambos iguais a `any').

     `infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)' declara <op>
     para ser um operdor infixo com expoentes associados padrão e
     podendo ser um entre prefixado, infixado, posfixado, nário,
     matchfix e nofix.

     A precedência de <op> com relação a outros operadores derivam dos
     expoentes associados diretiro e esquerdo dos operadores em questão.
     Se os expoentes associados esquerdo e direito de <op> forem ambos
     maiores que o expoente associado esquerdo e o direito de algum
     outro operador, então <op> tem prededência sobre o outro operador.
     Se os expoentes associados não forem ambos maior ou menor, alguma
     relação mais complicada ocorre.

     A associatividade de <op> depende de seus expoentes associados.
     Maior expoente associado esquerdo (<eae>) implica uma instância de
     <op> é avaliadas antes de outros operadores para sua esquerda em
     uma expressão, enquanto maior expoente associado direito (<ead>)
     implica uma instância de <op> é avaliada antes de outros
     operadores para sua direita em uma expressão.  Dessa forma maior
     <eae> torna <op> associativo à direita, enquanto maior <ead> torna
     <op> associativa à esquerda.  Se <eae> for igual a <ead>, <op> é
     associativa à esquerda.

     Veja também `Syntax'.

     Exemplos:

        * Se os expoentes associados esquerdo e direito de <op> forem
          ambos maiores que os expoentes associados à direita e à
          esquerda de algum outro operador, então <op> tem precedência
          sobre o outro operador.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) :lisp (get '$+ 'lbp)
          100
          (%i2) :lisp (get '$+ 'rbp)
          100
          (%i2) infix ("@", 101, 101)$
          (%i3) 1 + a@b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("@", 99, 99)$
          (%i5) 1 + a@b + 2;
          (%o5)                       (a+1,b+2)

        * grande <eae> torna <op> associativa à direita, enquanto
          grande <ead> torna <op> associativa à esquerda.

          (%i1) "@"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i2) infix ("@", 100, 99)$
          (%i3) foo @ bar @ baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("@", 100, 101)$
          (%i5) foo @ bar @ baz;
          (%o5)                    ((foo,bar),baz)


 -- Variável de opção: inflag
     Velor padrão: `false'

     Quando `inflag' for `true', funções para extração de partes
     inspecionam a forma interna de `expr'.

     Note que o simplificador re-organiza expressões.  Dessa forma
     `first (x + y)' retorna `x' se `inflag' for `true' e `y' se
     `inflag' for `false'.  (`first (y + x)' fornece os mesmos
     resultados.)

     Também, escolhendo `inflag' para `true' e chamando `part' ou
     `substpart' é o mesmo que chamar `inpart' ou `substinpart'.

     As funções afetadas pela posição do sinalizador `inflag' são:
     `part', `substpart', `first', `rest', `last', `length', a
     estrutura `for' ... `in', `map', `fullmap', `maplist', `reveal' e
     `pickapart'.


 -- Função: inpart (<expr>, <n_1>, ..., <n_k>)
     É similar a `part' mas trabalha sobre a representação interna da
     expressão em lugar da forma de exibição e dessa forma pode ser
     mais rápida uma vez que nenhuma formatação é realizada.  Cuidado
     deve ser tomado com relação à ordem de subexpressões em adições e
     produtos (uma vez que a ordem das variáveis na forma interna é
     muitas vezes diferente daquela na forma mostrada) e no manuseio
     com menos unário, subtração, e divisão (uma vez que esses
     operadores são removidos da expressão). `part (x+y, 0)' ou `inpart
     (x+y, 0)' retorna `+', embora com o objetivo de referirse ao
     operador isso deva ser abraçado por aspas duplas.  Por exemplo
     `... if inpart (%o9,0) = "+" then ...'.

     Exemplos:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)


 -- Função: isolate (<expr>, <x>)
     Retorna <expr> com subexpressões que são adições e que não possuem
     <x> substituido por rótulos de expressão intermediária (esses
     sendo símbolos atômicos como `%t1', `%t2', ...).  Isso é muitas
     vezes útil para evitar expansões desnecessárias de subexpressões
     que não possuam a variável de interesse.  Uma vez que os rótulos
     intermediários são associados às subexpressões eles podem todos
     ser substituídos de volta por avaliação da expressão em que
     ocorrerem.

     `exptisolate' (valor padrão: `false') se `true' fará com que
     `isolate' examine expoentes de átomos (como `%e') que contenham
     <x>.

     `isolate_wrt_times' se `true', então `isolate' irá também isolar
     produtos wrt. Veja `isolate_wrt_times'.

     Faça `example (isolate)' para exemplos.


 -- Variável de opção: isolate_wrt_times
     Valor padrão: `false'

     Quando `isolate_wrt_times' for `true', `isolate' irá também isolar
     produtos wrt.  E.g. compare ambas as escolhas do comutador em

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4


 -- Variável de opção: listconstvars
     Valor padrão: `false'

     Quando `listconstvars' for `true', isso fará com que `listofvars'
     inclua `%e', `%pi', `%i', e quaisquer variáveis declaradas
     contantes na lista seja retornado se aparecer na expressão que
     chamar `listofvars'.  O comportamento padrão é omitir isso.


 -- Variável de opção: listdummyvars
     Valor padrão: `true'

     Quando `listdummyvars' for `false', "variáveis dummy" na expressão
     não serão incluídasna lista retornada por `listofvars'.  (O
     significado de "variável dummy" é o mesmo que em `freeof'.
     "Variáveis dummy" são coisas matemáticas como o índice de um
     somatório ou produtório, a variável limite, e a variável da
     integral definida.)  Exemplo:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]


 -- Função: listofvars (<expr>)
     Retorna uma lista de variáveis em <expr>.

     `listconstvars' se `true' faz com que `listofvars' inclua `%e',
     `%pi', `%i', e quaisquer variáveis declaradas constantes na lista
     é retornada se aparecer em <expr>.  O comportamento padrão é
     omitir isso.

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1


 -- Função: lfreeof (<lista>, <expr>)
     Para cada um dos membros <m> de lista, chama `freeof (<m>,
     <expr>)'.  Retorna `false' se qualquer chamada a `freeof' for
     feita e `true' de outra forma.

 -- Função: lopow (<expr>, <x>)
     Retorna o menor expoente de <x> que explicitamente aparecer em
     <expr>.  Dessa forma

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)


 -- Função: lpart (<rótulo>, <expr>, <n_1>, ..., <n_k>)
     é similar a `dpart' mas usa uma caixa rotulada. Uma moldura
     rotulada é similar à que é produzida por `dpart' mas a produzida
     por `lpart' tem o nome na linha do topo.


 -- Função: multthru (<expr>)
 -- Função: multthru (<expr_1>, <expr_2>)
     Multiplica um fator (que pode ser uma adição) de <expr> pelos
     outros fatores de <expr>.  Isto é, <expr> é `<f_1> <f_2> ... <f_n>'
     onde ao menos um fator, digamos <f_i>, é uma soma de termos.  Cada
     termo naquela soma é multiplicado por outros fatores no produto.
     (A saber todos os fatores exceto <f_i>).  `multthru' não expande
     somas exponenciais.  Essa função é o caminho mais rápido para
     distribuir produtos (comutativos ou não) sobre adições.  Uma vez
     que quocientes são representados como produtos `multthru' podem
     ser usados para dividir adições por produtos também.

     `multthru (<expr_1>, <expr_2>)' multiplica cada termo em <expr_2>
     (que pode ser uma adição ou uma equção) por <expr_1>.  Se <expr_1>
     não for por si mesmo uma adição então essa forma é equivalente a
     `multthru (<expr_1>*<expr_2>)'.

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b


 -- Função: nounify (<f>)
     Retorna a forma substantiva do nome da função <f>.  Isso é
     necessário se se quer referir ao nome de uma função verbo como se
     esse nome fosse um substantivo.  Note que algumas funções verbos
     irão retornar sua forma substantiva senão puderem ser avaliadas
     para certos argumentos.  A forma substantiva é também a forma
     retornada se uma chamada de função é precedida por um apóstrofo.


 -- Função: nterms (<expr>)
     Retorna o número de termos que <expr> pode ter se for
     completamente expandida e nenhum cancelamento ou combinação de
     termos acontecer.  Note expressões como `sin (<expr>)', `sqrt
     (<expr>)', `exp (<expr>)', etc.  contam como apenas um termo
     independentemente de quantos termos <expr> tenha (se <expr> for uma
     adição).


 -- Função: op (<expr>)
     Retorna o operador principal da expressão <expr>.  `op (<expr>)' é
     equivalente a `part (<expr>, 0)'.

     `op' retorna uma seqüência de caracteres se o operador principal
     for uma operador interno ou definido pelo usuário como prefixado,
     binário ou n-ário infixo, posfixado, matchfix ou nofix.  De outra
     forma `op' retorna um símbolo.

     `op' observa o valor do sinalizador global `inflag'.

     `op' avalia seus argumentos.

     Veja também `args'.

     Exemplos:

          (%i1) ?stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"


 -- Função: operatorp (<expr>, <op>)
 -- Função: operatorp (<expr>, [<op_1>, ..., <op_n>])
     `operatorp (<expr>, <op>)' retorna `true' se <op> for igual ao
     operador de <expr>.

     `operatorp (<expr>, [<op_1>, ..., <op_n>])' retorna `true' se
     algum elementos de <op_1>, ..., <op_n> for igual ao operador de
     <expr>.


 -- Função: optimize (<expr>)
     Retorna uma expressão que produz o mesmo valor e efeito que <expr>
     mas faz de forma mais eficientemente por evitar a recomputação de
     subexpressões comuns.  `optimize' também tem o mesmo efeito de
     "colapsar" seus argumentos de forma que todas as subexpressões
     comuns são compartilhadas.  Faça `example (optimize)' para
     exemplos.


 -- Variável de opção: optimprefix
     Valor padrão: `%'

     `optimprefix' é o prefixo usado para símbolos gerados pelo comando
     `optimize'.


 -- Função: ordergreat (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     > <v_2> > ...  > <v_n>, e <v_n> > qualquer outra variável não
     mencionada como um argumento.

     Veja também `orderless'.


 -- Função: ordergreatp (<expr_1>, <expr_2>)
     Retorna `true' se <expr_2> precede <expr_1> na ordenação escolhida
     com a função `ordergreat'.


 -- Função: orderless (<v_1>, ..., <v_n>)
     Escolhe aliases para as variáveis <v_1>, ..., <v_n> tais que <v_1>
     < <v_2> < ...  < <v_n>, and <v_n> < qualquer outra variável não
     mencionada como um argumento.

     Dessa forma a escala de ordenação completa é: constantes numéricas
     < constantes declaradas < escalares declarados < primeiro
     argumento para `orderless' < ...  < último argumento para
     `orderless' < variáveis que começam com A < ...  < variáveis que
     começam com Z < último argumento para `ordergreat' <  ... <
     primeiro argumento para `ordergreat' < `mainvar's - variáveis
     principais declaradas.

     Veja também `ordergreat' e `mainvar'.


 -- Função: orderlessp (<expr_1>, <expr_2>)
     Retorna `true' se <expr_1> precede <expr_2> na ordenação escolhida
     pelo comando `orderless'.


 -- Função: part (<expr>, <n_1>, ..., <n_k>)
     Retorna partes da forma exibida de `expr'. Essa função obtém a
     parte de `expr' como especificado pelos índices <n_1>, ..., <n_k>.
     A primeira parte <n_1> de `expr' é obtida, então a parte <n_2>
     daquela  é obtida, etc.  O resultado é parte <n_k> de ... parte
     <n_2> da parte <n_1> da `expr'.

     `part' pode ser usada para obter um elemento de uma lista, uma
     linha de uma matriz, etc.

     Se o último argumento para uma função `part' for uma lista de
     índices então muitas subexpressões serão pinçadas, cada uma
     correspondendo a um índice da lista.  Dessa forma `part (x + y +
     z, [1, 3])' é `z+x'.

     `piece' mantém a última expressão selecionada quando usando as
     funções `part'.  Isso é escolhido durante a execução da função e
     dessa forma pode referir-se à função em si mesma como mostrado
     abaixo.

     Se `partswitch' for escolhido para `true' então `end' é retornado
     quando uma parte selecionada de uma expressão não existir, de
     outra forma uma mensagem de erro é forncecida.

     Exemplo: `part (z+2*y, 2, 1)' retorna 2.

     `example (part)' mostra exemplos adicionais.


 -- Função: partition (<expr>, <x>)
     Retorna uma lista de duas expressões.  Elas são (1) os fatores de
     <expr> (se essa expressão for um produto), os termos de <expr> (se
     isso for uma adição), ou a lista (se isso for uma lsita) que não
     contiver `var' e, (2) os fatores, termos, ou lista que faz.

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]


 -- Variável de opção: partswitch
     Valor padrão: `false'

     Quando `partswitch' for `true', `end' é retornado quando uma parte
     selecionada de uma expressão não existir, de outra forma uma
     mensagem de erro é fornecida.


 -- Função: pickapart (<expr>, <n>)
     Atribui rótulos de expressão intermediária a subexpressões de
     <expr> de comprimento <n>, um inteiro.  A subexpressões maiores ou
     menores não são atribuidos rótulos.  `pickapart' retorna uma
     expressão em termos de expressões intermediárias equivalentes à
     expressão original <expr>.

     Veja também `part', `dpart', `lpart', `inpart', e `reveal'.

     Exemplos:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);

                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2

          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)

                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2


 -- Variável de sistema: piece
     Mantém a ultima expressão selecionada quando usando funções `part'.
     Isso é escolhido durante a execução da função e dessa forma pode
     referir-se à função em si mesma.


 -- Função: polarform (<expr>)
     Retorna uma expressão `r %e^(%i theta)' equivalente a <expr>, tal
     que `r' e `theta' sejam puramente reais.


 -- Função: powers (<expr>, <x>)
     Fornece os expoentes de <x> que ocorrem em expressão <expr>.

     `load (powers)' chama essa função.


 -- Função: product (<expr>, <i>, <i_0>, <i_1>)
     Representa um produto dos velores de `expr' com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva `'product' é
     mostrada como um pi maiísculo.

     `product' avalia <expr> e os limites inferior e superior <i_0> e
     <i_1>, `product' coloca um apóstrofo (não avalia) o índice <i>.

     If the upper and lower limits differ by an integer, <expr> is
     evaluated for each value of the index <i>, and the result is an
     explicit product.

     Otherwise, the range of the index is indefinite.  Some rules are
     applied to simplify the product.  When the global variable
     `simpproduct' is `true', additional rules are applied.  In some
     cases, simplification yields a result which is not a product;
     otherwise, the result is a noun form `'product'.

     See also `nouns' and `evflag'.

     Exemplos:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b


 -- Função: realpart (<expr>)
     Retorna a parte real de <expr>. `realpart' e `imagpart' irão
     trabalhar sobre expressões envolvendo funções trigonométricas e
     hiperbólicas, bem como raízes quadradas, logarítmos, e
     exponenciação.


 -- Função: rectform (<expr>)
     Retorna uma expressão `a + b %i' equivalente a <expr>, tal que <a>
     e <b> sejam puramente reais.


 -- Função: rembox (<expr>, unlabelled)
 -- Função: rembox (<expr>, <rótulo>)
 -- Função: rembox (<expr>)
     Remove caixas de <expr>.

     `rembox (<expr>, unlabelled)' remove todas as caixas sem rótulos
     de <expr>.

     `rembox (<expr>, <rótulo>)' remove somente caixas contendo
     <rótulo>.

     `rembox (<expr>)' remove todas as caixas, rotuladas e nã rotuladas.

     Caixas são desenhadas pelas funções `box', `dpart', e `lpart'.

     Exemplos:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h


 -- Função: sum (<expr>, <i>, <i_0>, <i_1>)
     Representa um somatório dos valores de <expr> com o índice <i>
     variando de <i_0> a <i_1>.  A forma substantiva `'sum' é mostrada
     com uma letra sigma maiúscula.  `sum' avalia seu somando <expr> e
     limites inferior e superior <i_0> e <i_1>, `sum' coloca apóstrofo
     (não avalia) o índice <i>.

     Se os limites superiores e inferiores diferirem de um número
     inteiro, o somatoriando <expr> é avaliado para cada valor do
     índice do somatório <i>, e o resultado é uma adição explícita.

     De outra forma, o intervalo dos índices é indefinido.  Algumas
     regras são aplicadas para simplificar o somatório.  Quando a
     variável global `simpsum' for `true', regras adicionais são
     aplicadas.  Em alguns casos, simplificações retornam um resultado
     que não é um somatório; de outra forma, o resultado é uma forma
     substantiva `'sum'.

     Quando o `evflag' (sinalizador de avaliação) `cauchysum' for
     `true', um produto de somatórios é mostrado como um produto de
     Cauchy, no qual o índice do somatório mais interno é uma função de
     índice de um nível acima, em lugar de variar independentemente.

     A variável global `genindex' é o prefixo alfabético usado para
     gerar o próximo índice do somatório, quando um índice
     automaticamente gerado for necessário.

     `gensumnum' é o sufixo numérico usando para gerar o próximo índice
     do somatório, quando um índice gerado automaticamente for
     necessário.  Quando `gensumnum' for `false', um índice gerado
     automaticamente é somente `genindex' sem sufixo numérico.

     Veja também `sumcontract', `intosum', `bashindices', `niceindices',
     `nouns', `evflag', e `zeilberger'.

     Exemplos:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10));
          Incorrect syntax: Too many )'s
          else b^k, k, 1, 10))
                            ^
          (%i12) linenum:11;
          (%o11)                         11
          (%i12) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o12)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i13) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o13)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a


 -- Função: lsum (<expr>, <x>, <L>)
     Representas a adição de <expr> a cada elemento <x> em <L>.

     Uma forma substantiva `'lsum' é retornada se o argumento <L> não
     avaliar para uma lista.

     Exemplos:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1)


 -- Função: verbify (<f>)
     Retorna a forma verbal da função chamada <f>.

     Veja também `verb', `noun', e `nounify'.

     Exemplos:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO



File: maxima.info,  Node: Simplificação,  Next: Montando Gráficos,  Prev: Expressões,  Up: Top

7 Simplificação
***************

* Menu:

* Definições para Simplificação::


File: maxima.info,  Node: Definições para Simplificação,  Prev: Simplificação,  Up: Simplificação

7.1 Definições para Simplificação
=================================

* Menu:

 -- Variável de sistema: askexp
     Quando `asksign' é chamada, `askexp' é a expressão que `asksign'
     está testando.

     Antigamente, isso era possível para um usuário inspecionar `askexp'
     entrando em uma parada do Maxima com control-A.

 -- Função: askinteger (<expr>, integer)
 -- Função: askinteger (<expr>)
 -- Função: askinteger (<expr>, even)
 -- Função: askinteger (<expr>, odd)
     `askinteger (<expr>, integer)' tenta determinar a partir da base
     de dados do `assume' se <expr> é um inteiro.  `askinteger'
     pergunta ao usuário pela linha de comando se isso não pode ser
     dito de outra forma, e tenta instalar a informação na base de
     dados do `assume' se for possível.  `askinteger (<expr>)' é
     equivalente a `askinteger (<expr>, integer)'.

     `askinteger (<expr>, even)' e `askinteger (<expr>, odd)' da mesma
     forma tentam determinar se <expr> é um inteiro par ou inteiro
     ímpar, respectivamente.


 -- Função: asksign (<expr>)
     Primeiro tenta determinar se a expressão especificada é positiva,
     negativa, ou zero.  Se isso não for possível, `asksign' pergunta ao
     usuário com as questões necessárias para completar a sua dedução.
     As respostas do usuário são guardadas na base de dados pelo tempo
     que durar a computação corrente. O valor de retorno de `asksign' é
     um entre `pos', `neg', ou `zero'.


 -- Função: demoivre (<expr>)
 -- Variável de opção: demoivre
     A função `demoivre (expr)' converte uma expressão sem escolher a
     variável global `demoivre'.

     Quando a variável `demoivre' for `true', exponenciais complexas
     são convertidas em expressões equivalentes em termos de funções
     circulares: `exp (a + b*%i)' simplifica para `%e^a * (cos(b) +
     %i*sin(b))' se `b' for livre de `%i'.  `a' e `b' não são
     expandidos.

     O valor padrão de `demoivre' é `false'.

     `exponentialize' converte funções circulares e hiperbólicas para a
     forma exponencial.  `demoivre' e `exponentialize' não podem ambas
     serem `true' ao mesmo tempo.


 -- Variável de opção: domain
     Valor padrão: `real'

     Quando `domain' é escolhida para `complex', `sqrt (x^2)'
     permanecerá `sqrt (x^2)' em lugar de retornar `abs(x)'.


 -- Função: expand (<expr>)
 -- Função: expand (<expr>, <p>, <n>)
     Expande a expressão <expr>.  Produtos de somas e somas
     exponenciadas são multiplicadas para fora, numeradores de
     expressões racionais que são adições são quebradas em suas
     respectivas parcelas, e multiplicação (comutativa e não
     comutativa) é distribuída sobre a adição em todos os níveis de
     <expr>.

     Para polinômios se pode ter usulmente `ratexpand' que usa um
     algorítmo mais eficiente.

     `maxnegex' e `maxposex' controlam o máximo expoente negativo e o
     máximo expoente positivo, respectivamente, que irão expandir.

     `expand (<expr>, <p>, <n>)' expande <expr>, usando <p> para
     `maxposex' e <n> para `maxnegex'.  Isso é útil com o objetivo de
     expandir partes mas não tudo de uma expressão.

     `expon' - o expoente da maior potência negativa que é
     automaticamente expandida (independente de chamadas a `expand').
     Por Exemplo se `expon' for 4 então `(x+1)^(-5)' não serã
     automaticamente expandido.

     `expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma `(x+1)^3', quando digitado, será
     automaticamente expandido somente se `expop' for maior que ou
     igual a 3.  Se for desejado ter `(x+1)^n' expandido onde `n' é
     maior que `expop' então executando `expand ((x+1)^n)' trabalhará
     somente se `maxposex' não for menor que `n'.

     O sinalizador `expand' usado com `ev' causa expansão.

     O arquivo `simplification/facexp.mac' contém muitas funções
     relacionadas (em particular `facsum', `factorfacsum' e
     `collectterms', que são chamadas automaticamente) e variáveis
     (`nextlayerfactor' e `facsum_combine') que fornecem ao usuário com
     a habilidade para estruturar expressões por expansão controlada.
     Descrições breves de função estão disponível em
     `simplification/facexp.usg'.  Um arquivo demonstrativo está
     disponível fazendo `demo("facexp")'.


 -- Função: expandwrt (<expr>, <x_1>, ..., <x_n>)
     Expande expressão `expr' com relação às variáveis <x_1>, ...,
     <x_n>.  Todos os produtos envolvendo as variáveis aparecem
     explicitamente.  A forma retornada será livre de produtos de somas
     de expressões que não estão livres das variáveis.   <x_1>, ...,
     <x_n> podem ser variáveis, operadores, ou expressões.

     Por padrão, denominadores não são expandidos, mas isso pode ser
     controlado através do comutador `expandwrt_denom'.

     Essa função, `expandwrt', não é automaticamente chamada a partir de
     `simplification/stopex.mac'.


 -- Variável de opção: expandwrt_denom
     Valor padrão: `false'

     `expandwrt_denom' controla o tratamento de expressões racionais
     por `expandwrt'.  Se `true', então ambos o numerador e o
     denominador da expressão serão expandidos conforme os argumentos
     de `expandwrt', mas se `expandwrt_denom' for `false', então somente
     o numerador será expandido por aquele caminho.


 -- Função: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)
     é similar a `expandwrt', mas trata expressões que são produtos um
     tanto quanto diferentemente.  `expandwrt_factored' expande somente
     sobre esses fatores de `expr' que contiverem as variáveis <x_1>,
     ..., <x_n>.

     Essa função é automaticamente chamada a aprtir de
     `simplification/stopex.mac'.


 -- Variável de opção: expon
     Valor padrão: 0

     `expon' é o expoente da maior potência negativa que é
     automaticamente expandido (independente de chamadas a `expand').
     Por exemplo, se `expon' for 4 então `(x+1)^(-5)' não será
     automaticamente expandido.


 -- Função: exponentialize (<expr>)
 -- Variável de opção: exponentialize
     A função `exponentialize (expr)' converte funções circulares e
     hiperbólicas em <expr> para exponenciais, sem escolher a variável
     global `exponentialize'.

     Quando a variável `exponentialize' for `true', todas as funções
     circulares e hiperbólicas  são convertidas para a forma
     exponencial.  O valor padrão é `false'.

     `demoivre' converte exponenciais complexas em funções circulares.
     `exponentialize' e `demoivre' não podem ambas serem `true' ao
     mesmo tempo.


 -- Variável de opção: expop
     Valor padrão: 0

     `expop' - o maior expoente positivo que é automaticamente
     expandido.  Dessa forma `(x+1)^3', quando digitado, será
     automaticamente expandido somente se `expop' for maior que ou
     igual a 3.  Se for desejado ter `(x+1)^n' expandido onde `n' é
     maior que `expop' então executando `expand ((x+1)^n)' trabalhará
     somente se `maxposex' não for menor que `n'.


 -- Variável de opção: factlim
     Valor padrão: -1

     `factlim' especifica o maior fatorial que é automaticamente
     expandido.  Se for -1 então todos os inteiros são expandidos.


 -- Função: intosum (<expr>)
     Move fatores multiplicativos fora de um somatório para dentro.  Se
     o índice for usado na expressão de fora, então a função tentará
     achar um índice razoável, o mesmo que é feito para `sumcontract'.
     Isso é essencialmente a idéia reversa da propriedade `outative' de
     somatórios, mas note que isso não remove essa propriedade, somente
     pula sua verificação.

     Em alguns casos, um `scanmap (multthru, <expr>)' pode ser
     necessário antes de `intosum'.


 -- Declaração: lassociative
     `declare (g, lassociative)' diz ao simplificador do Maxima que `g'
     é associativa à esquerda.  E.g., `g (g (a, b), g (c, d))' irá
     simplificar para `g (g (g (a, b), c), d)'.


 -- Declaração: linear
     Uma das propriedades operativas do Maxima.  Para funções de uma
     única variável `f' então declarada, a "expansão" `f(x + y)'
     retorna `f(x) + f(y)', `f(a*x)' retorna `a*f(x)' ocorrem onde `a'
     é uma "constante".  Para funções de dois ou mais argumentos,
     "linearidade" é definida para ser como no caso de `sum' ou
     `integrate', i.e., `f (a*x + b, x)' retorna `a*f(x,x) + b*f(1,x)'
     para `a' e `b' livres de `x'.

     `linear' é equivalente a `additive' e `outative'.  Veja também
     `opproperties'.


 -- Declaração: mainvar
     Você pode declarar variáveis para serem `mainvar' (variável
     principal).  A escala de ordenação para átomos é essencialmente:
     números < constantes (e.g., `%e', `%pi') < escalares < outras
     variáveis < mainvars.  E.g., compare `expand ((X+Y)^4)' com
     `(declare (x, mainvar), expand ((x+y)^4))'.  (Nota: Cuidado deve
     ser tomado se você eleger o uso desse recurso acima.  E.g., se
     você subtrair uma expressão na qual `x' for uma `mainvar' de uma
     na qual `x' não seja uma `mainvar', resimplificação e.g. com `ev
     (expr, simp)' pode ser necessária se for para ocorrer um
     cancelamento.  Também, se você grava uma expressão na qual `x' é
     uma `mainvar', você provavelmente pode também gravar `x'.)


 -- Variável de opção: maxapplydepth
     Valor padrão: 10000

     `maxapplydepth' é a máxima definição para a qual `apply1' e
     `apply2' irão pesquisar.


 -- Variável de opção: maxapplyheight
     Valor padrão: 10000

     `maxapplyheight' é a elevação máxima a qual `applyb1' irá alcançar
     antes de abandonar.


 -- Variável de opção: maxnegex
     Valor padrão: 1000

     `maxnegex' é o maior expoente negativo que será expandido pelo
     comando `expand' (veja também `maxposex').


 -- Variável de opção: maxposex
     Valor padrão: 1000

     `maxposex' é o maior expoente que irá ser expandido com o comando
     `expand' (veja também `maxnegex').


 -- Declaração: multiplicative
     `declare (f, multiplicative)' diz ao simplificador do Maxima que
     `f' é multiplicativa.

       1. Se `f' for uma função de uma única variável, sempre que o
          simplificador encontrar `f' aplicada a um produto, `f'
          distribue sobre aquele procuto.  E.g., `f(x*y)' simplifica
          para `f(x)*f(y)'.

       2. Se `f' é uma função de 2 ou mais argumentos,
          multiplicatividade é definida como multiplicatividade no
          primeiro argumento para `f', e.g., `f (g(x) * h(x), x)'
          simplifica para `f (g(x) ,x) * f (h(x), x)'.

     Essa simplificação não ocorre quando `f' é aplicada a expressões da
     forma `product (x[i], i, m, n)'.


 -- Variável de opção: negdistrib
     Valor padrão: `true'

     Quando `negdistrib' for `true', -1 distribue sobre uma expressão.
     E.g., `-(x + y)' transforma-se em `- y - x'.  Setting it to `false'
     Permitirá `- (x + y)' seja mostrado como foi escrito.  Isso
     algumas vezes é útil mas seja muito cuidadoso: como o sinalizador
     `simp', isso  um sinalizador que você não que escolher para
     `false' como algo natural ou necessário com excessão de usar
     localmente no seu Maxima.


 -- Variável de opção: negsumdispflag
     Valor padrão: `true'

     Quando `negsumdispflag' for `true', `x - y' é mostrado como `x - y'
     em lugar de como `- y + x'.  Escolhendo isso para `false' faz com
     que a verificação especial em visualização para a diferença das
     duas expressões não seja concluída.  Uma aplicação é que dessa
     forma `a + %i*b' e `a - %i*b' podem ambos serem mostrados pelo
     mesmo caminho.


 -- Símbolo especial: noeval
     `noeval' suprime a fase de avaliação de `ev'.  Isso é útil em
     conjunção com outros comutadores e em fazer com que expressões
     sejam resimplificadas sem serem reavaliadas.


 -- Declaração: noun
     `noun' é uma das opções do comando `declare'.  Isso faz um função
     então declarada como "noun" (substantivo), significando que ela
     não deve ser avaliada automaticamente.


 -- Variável de opção: noundisp
     Valor padrão: `false'

     Quando `noundisp' for `true', substantivos (nouns) são mostrados
     com um apóstrofo.  Esse comutador é sempre `true' quando mostrando
     definições de função.


 -- Símbolo especial: nouns
     `nouns' é um `evflag' (sinalizador de avaliação). Quando usado
     como uma opção para o comando `ev', `nouns' converte todas as
     formas substantivas ("noun") que ocorrem na expressão que está
     sendo avaliada para verbos ("verbs"), i.e., avalia essas
     expressões.  Veja também `noun', `nounify', `verb', e `verbify'.


 -- Símbolo especial: numer
     `numer' faz com que algumas funções matemáticas (incluindo
     exponenciação) com argumentos numéricos sejam avaliados em ponto
     flutuante. Isso faz com que variáveis em `expr' que tenham sido
     dados valores numéricos a elas (`numerval') sejam substituídas
     pelos seus valores.  Isso também escolhe o sinalizador `float'
     para `on'.


 -- Função: numerval (<x_1>, <expr_1>, ..., <var_n>, <expr_n>)
     Declara as variáveis `x_1', ..., <x_n> para terem valores
     numéricos iguais a `expr_1', ..., `expr_n'.  O valor numérico é
     avaliado e substituido para a variável em quaisquer expressões na
     qual a variável ocorra se o sinalizador `numer' for `true'. Veja
     também `ev'.

     As expressões `expr_1', ..., `expr_n' podem ser quaisquer
     expressões, não necessariamente numéricas.

 -- Variável de sistema: opproperties
     `opproperties' é a lista de propriedades de operadores especiais
     reconhecidas pelo simplificador do Maxima: `linear', `additive',
     `multiplicative', `outative', `evenfun', `oddfun', `commutative',
     `symmetric', `antisymmetric', `nary', `lassociative',
     `rassociative'.


 -- Variável de opção: opsubst
     Valor padrão: `true'

     Quando `opsubst' for `false', `subst' não tenta substituir dentro
     de um operador de uma expressão.  E.g., `(opsubst: false, subst
     (x^2, r, r+r[0]))' irá trabalhar.


 -- Declaração: outative
     `declare (f, outative)' diz ao simplificador do Maxima que fatores
     constantes no argumento de `f' podem ser puxados para fora.

       1. Se `f' for uma função de uma única variável, sempre que o
          simplificador encontrar `f' aplicada a um produto, aquele
          produto será particionado em fatores que são constantes e
          fatores que não são e os fatores constantes serão puxados
          para fora.  E.g., `f(a*x)' simplificará para `a*f(x)' onde
          `a' é uma constante.  Fatores de constantes não atômicas não
          serão puxados para fora.

       2. Se `f' for uma função de 2 ou mais argumentos, a colocação
          para fora é definida como no caso de `sum' ou `integrate',
          i.e., `f (a*g(x), x)' irá simplificar para `a * f(g(x), x)'
          sendo `a' livre de `x'.

     `sum', `integrate', e `limit' são todas `outative'.


 -- Declaração: posfun
     `declare (f, posfun)' declara `f' para ser uma função positiva.
     `is (f(x) > 0)' retorna `true'.


 -- Função: radcan (<expr>)
     Simplifica <expr>, que pode conter logarítmos, exponenciais, e
     radicais, convertendo essa expressão em uma forma que é canônica
     sobre uma larga classe de expressões e uma dada ordenação de
     variáveis; isto é, todas formas funcionalmente equivalentes são
     mapeadas em uma única forma.  Para uma classe um tanto quanto
     larga de expressões, `radcan' produz uma forma regular.  Duas
     expressões equivalentes nessa classe não possuem necessáriamente a
     mesma aparência, mas suas diferenças podem ser simplificadas por
     `radcan' para zero.

     Para algumas expressões `radcan' é que consome inteiramente o
     tempo.  Esse é o custo de explorar certos relacionamentos entre os
     componentes da expressão para simplificações baseadas sobre
     fatoração e expansões de fração-parcial de expoentes.

     Quando `%e_to_numlog' for `true', `%e^(r*log(expr))' simplifica
     para `expr^r' se `r' for um número racional.

     Quando `radexpand' for `false', certas transformações são inibidas.
     `radcan (sqrt (1-x))' permanece `sqrt (1-x)' e não é simplificada
     para `%i sqrt (x-1)'.  `radcan (sqrt (x^2 - 2*x + 11))' permanece
     `sqrt (x^2 - 2*x + 1)' e não é simplificada para `x - 1'.

     `example (radcan)' mostra alguns exemplos.


 -- Variável de opção: radexpand
     Valor padrão: `true'

     `radexpand' controla algumas simplificações de radicais.

     Quando `radexpand' for `all', faz com que nésimas raízes de
     fatores de um produto que são potências de n sejam puxados para
     fora do radical.  E.g. Se `radexpand' for `all', `sqrt (16*x^2)'
     simplifica para `4*x'.

     Mais particularmente, considere `sqrt (x^2)'.
        * Se `radexpand' for `all' or `assume (x > 0)' tiver sido
          executado, `sqrt(x^2)' simplifica para `x'.

        * Se `radexpand' for `true' e `domain' for `real' (isso é o
          padrão), `sqrt(x^2)' simplifica para `abs(x)'.

        * Se `radexpand' for `false', ou `radexpand' for `true' e
          `domain' for `complex', `sqrt(x^2)' não é simplificado.

     Note que `domain' somente interessa quando `radexpand' for `true'.


 -- Variável de opção: radsubstflag
     Valor padrão: `false'

     `radsubstflag', se `true', permite a `ratsubst' fazer
     substituições tais como `u' por `sqrt (x)' em `x'.


 -- Declaração: rassociative
     `declare (g, rassociative)' diz ao simplificador do Maxima que `g'
     é associativa à direita.  E.g., `g(g(a, b), g(c, d))' simplifica
     para `g(a, g(b, g(c, d)))'.


 -- Função: scsimp (<expr>, <rule_1>, ..., <rule_n>)
     Simplificação Seqüêncial Comparativa (método devido a Stoute).
     `scsimp' tenta simplificar <expr> conforme as regras <rule_1>,
     ..., <rule_n>.  Se uma expressão pequena for obtida, o processo
     repete-se.  De outra forma após todas as simplificações serem
     tentadas, isso retorna a resposta original.

     `example (scsimp)' mostra alguns exemplos.


 -- Variável de opção: simpsum
     Valor padrão: `false'

     Quando `simpsum' for `true', o resultado de uma `sum' é
     simplificado.  Essa simplificação pode algumas vezes estar apta a
     produzir uma forma fechada.  Se `simpsum' for `false' ou se a
     forma com apóstrofo `'sum' for usada, o valor é uma forma
     substantiva aditiva que é uma representação da notação sigma usada
     em matemática.


 -- Função: sumcontract (<expr>)
     Combina todas as parcelas de uma adição que tem maiores e menores
     associações que diferem por constantes. O resultado é uma
     expressão contendo um somatório para cada escolha de cada tais
     somatórios adicionados a todos os termos extras apropriados que
     tiveram de ser extraídos para a forma dessa adição.  `sumcontract'
     combina todas as somas compatíveis e usa-se os indices de uma as
     somas se puder, e então tenta formar um índice razoável se não for
     usar qualquer dos fornecidos.

     Isso pode ser necessário fazer um `intosum (<expr>)' antes de
     `sumcontract'.


 -- Variável de opção: sumexpand
     Valor padrão: `false'

     Quando `sumexpand' for `true', produtos de somas e somas
     exponeciadas simplificam para somas aninhadas.

     Veja também `cauchysum'.

     Exemplos:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


 -- Variável de opção: sumsplitfact
     Valor padrão: `true'

     When `sumsplitfact' for `false', `minfactorial' é aplicado após um
     `factcomb'.


 -- Declaração: symmetric
     `declare (h, symmetric)' diz ao simplificador do Maxima que `h' é
     uma função simétrica.  E.g., `h (x, z, y)' simplifica para `h (x,
     y, z)'.

     `commutative' é sinônimo de `symmetric'.


 -- Função: unknown (<expr>)
     Retorna `true' se e somente se <expr> contém um operador ou função
     não reconhecida pelo simplificador do Maxima.



File: maxima.info,  Node: Montando Gráficos,  Next: Entrada e Saída,  Prev: Simplificação,  Up: Top

8 Montando Gráficos
*******************

* Menu:

* Definições para Montagem de Gráficos::


File: maxima.info,  Node: Definições para Montagem de Gráficos,  Prev: Montando Gráficos,  Up: Montando Gráficos

8.1 Definições para Montagem de Gráficos
========================================

 -- Variável: in_netmath
     Valor padrão: `false'

     Quando `in_netmath' é `true', `plot3d' imprime uma saída OpenMath
     para o console se `plot_format' é `openmath'; caso contrário
     `in_netmath' (mesmo se `true') não tem efeito.

     `in_netmath' não tem efeito sobre `plot2d'.


 -- Função: openplot_curves (<list>, <rest_options>)
     Pega uma lista de curvas tais como
          [[x1, y1, x2, y2, ...], [u1, v1, u2, v2, ...], ..]
     ou
          [[[x1, y1], [x2, y2], ...], ...]
     e monta seus gráficos.  Isso é similar a xgraph_curves, mas não
     usa as rotinas open plot.  Argumentos adicionais de símbolos podem
     ser dados tais como `"{xrange -3 4}"'.  O exemplo adiante monta o
     gráfico de duas curvas, usando pontos grandes, rotulando-se o
     primeiro `jim' e o segundo rotulando-se `jane'.
          openplot_curves ([["{plotpoints 1} {pointsize 6} {label jim}
                {xaxislabel {joe is nice}}"], [1, 2, 3, 4, 5, 6, 7, 8],
                ["{label jane} {color pink }"], [3, 1, 4, 2, 5, 7]]);

     Algumas outras palavras chave especiais são `xfun', `color',
     `plotpoints', `linecolors', `pointsize', `nolines', `bargraph',
     `labelposition', `xaxislabel', e `yaxislabel'.


 -- Função: plot2d (<expr>, <range>, ..., <options>, ...)
 -- Função: plot2d (<parametric_expr>)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>)
 -- Função: plot2d ([<expr_1>, ..., <expr_n>], <x_range>)
 -- Função: plot2d (<expr>, <x_range>, <y_range>)
 -- Função: plot2d (<expr>, <x_range>)
 -- Função: plot2d (<expr>, <x_range>)
 -- Função: plot2d ([<name_1>, ..., <name_n>], <x_range>, <y_range>)
 -- Função: plot2d ([<name_1>, ..., <name_n>], <x_range>)
 -- Função: plot2d (<name>, <x_range>, <y_range>)
 -- Função: plot2d (<name>, <x_range>)
     Mostra a montagem de uma ou mais expressões como uma função de uma
     variável.

     Em todos os casos, <expr> é uma expressão a ser montado o gráfico
     no eixo vertical como uma função de uma variável.  <x_range>, a
     amplitude do eixo horizontal, é uma lista da forma `[<variável>,
     <min>, <max>]', onde <variável> é uma variável que aparece em
     <expr>.  <y_range>, e a amplitude do eixo vertical, é uma lista da
     forma `[y, <min>, <max>]'.

     `plot2d (<expr>, <x_range>)' monta o gráfico <expr> como uma
     função da variável nomeada em <x_range>, sobre a amplitude
     especificada em <x_range>.  Se a amplitude vertical não for
     alternativamente especificada por `set_plot_option', essa é
     escolhida automaticamente.  Todas as opções são assumidas terem
     valores padrão a menos que sejam alternativamente especificadas
     por `set_plot_option'.

     `plot2d (<expr>, <x_range>, <y_range>)' monta o gráfico de <expr>
     como uma função de uma variável nomeada em <x_range>, sobre a
     amplitude especificada em <x_range>.  O alcance vertical é
     escolhido para <y_range>.  Todas as opções são assumidas terem
     valores padrão a menos que sejam alternativamente especificadas
     por `set_plot_option'.

     `plot2d ([<expr_1>, ..., <expr_n>], <x_range>)' monta o gráfico
     <expr_1>, ..., <expr_n> como uma função da variável nomeada em
     <x_range>, sobre a amplitude especificada em <x_range>.  Se a
     amplitude vertical não for alternativamente especificada por
     `set_plot_option', essa é escolhida automaticamente.  Todas as
     opções são assumidas terem valores padrão a menos que sejam
     alternativamente especificadas por `set_plot_option'.

     `plot2d ([<expr_1>, ..., <expr_n>], <x_range>, <y_range>)' monta o
     gráfico <expr_1>, ..., <expr_n> como uma função de uma variável
     nomedada em <x_range>, sobre a amplitude especificada em <x_range>.
     O alcance vertical é escolhido para <y_range>.  Todas as opções
     são assumidas terem valores padrão a menos que sejam
     alternativamente especificadas por `set_plot_option'.

     Quando a função a ser montado o gráfico é uma função definida no
     Maxima através de `:=' ou `define', ou no Lisp através de DEFUN ou
     DEFMFUN, a função pode ser especificada pelo nome.  Funções
     definidas em Lisp através de DEFMSPEC, e funções de simplificação,
     não podem ser especificadas pelo nome; que inclui muitas funções
     internas.

     Exemplos:

     Montando um gráfico de uma expressão, e escolhendo alguns
     parâmetros comumente usados.

          (%i1) plot2d (sin(x), [x, -5, 5])$
          (%i2) plot2d (sec(x), [x, -2, 2], [y, -20, 20], [nticks, 200])$

     Montando gráfico de funções pelo nome.

          (%i1) F(x) := x^2 $

          (%i2) :lisp (defun |$g| (x) (m* x x x))

          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $

          (%i3) plot2d (F, [u, -1, 1])$

          (%i4) plot2d ([F, G, H], [u, -1, 1])$

     Em qualquer lugar onde pode existir uma expressão comum, pode
     existir uma expressão paramétrica: <parametric_expr> é uma lista
     da forma `[parametric, <x_expr>, <y_expr>, <t_range>, <options>]'.
     Aqui <x_expr> e <y_expr> são expressões de 1 variável <var> que é
     o primeiro elemento da amplitude <trange>.  A montagem do gráfico
     mostra o caminho descrito pelo par `[<x_expr>, <y_expr>]' como
     <var> varia em <trange>.

     No exemplo seguinte, montaremos o gráfico de um círculo, então
     faremos a montagem do gráfico com somente poucos pontos usados,
     desse modo vamos pegar uma estrela, e inicialmente montaremos o
     gráfico juntamente com uma função comum de X.

     Exemplos:

        * Montar o gráfico de um círculo de forma paramétrica.
               (%i1) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                       [nticks, 80]])$

        * Monta o gráfico de uma estrela: liga oito pontos sobre a
          circunferência de um círculo.
               (%i2) plot2d ([parametric, cos(t), sin(t), [t, -%pi*2, %pi*2],
                       [nticks, 8]])$

        * Monta o gráfico de um polinômio cúbico da forma comum e de um
          círculo da forma paramétrica.
               (%i3) plot2d ([x^3 + 2, [parametric, cos(t), sin(t), [t, -5, 5],
                       [nticks, 80]]], [x, -3, 3])$

     Expressões discretas podem também serem usadas ou em lugar de
     expressões comuns ou em lugar de expressões paramétricas:
     <discrete_expr> é uma lista da forma `[discrete, <x_list>,
     <y_list>]' ou da forma `[discrete, <xy_list>]', onde <xy_list> é
     uma lista de pares `[<x>,<y>]'.

     Exemplos:

        * Cria algumas listas.
               (%i1) xx:makelist(x,x,0,10)$
               (%i2) yy:makelist(exp(-x*1.0),x,0,10)$
               (%i3) xy:makelist([x,x*x],x,0,5)$

        * Monta um gráfico com segmentos de reta.
               (%i4) plot2d([discrete,xx,yy])$

        * Monta um gráfico com segmentos de reta, usando uma lista de
          pares.
               (%i5) plot2d([discrete,xy])$

        * Monta um gráfico com pontos.
               (%i6) plot2d([discrete,xx,yy],[gnuplot_curve_styles,["with points"]])$

        * Monta o gráfico da curva `cos(<x>)' usando linhas e
          (<xx>,<yy>) usando pontos.
               plot2d([cos(x),[discrete,xx,yy]],[x,0,10],[gnuplot_curve_styles,["with lines","with points pointsize 3"]])$

     Veja também `plot_options', que descreve opções de montagem de
     gráfico e tem mais exemplos.


 -- Função: xgraph_curves (<list>)
     transforma em gráfico a lista de `grupos de pontos' dados em lista
     usando xgraph.

     Uma lista de grupos de pontos pode ser da forma

          [x0, y0, x1, y1, x2, y2, ...]
     ou
          [[x0, y0], [x1, y1], ...]
     Um grupo de pontos pode também conter símbolos que fornecem
     rótulos ou outra informação.

          xgraph_curves ([pt_set1, pt_set2, pt_set3]);

     transforma em gráfico os três grupos de pontos com três curvas.

          pt_set: append (["NoLines: True", "LargePixels: true"], [x0, y0, x1, y1, ...]);

     fizemos com que os grupos de pontos [e os próprios subseqüêntes],
     não possuam linhas entre os pontos, e para usar pixels largos.
     Veja a página de manual sobre o xgraph para especificar mais
     opções.

          pt_set: append ([concat ("\"", "x^2+y")], [x0, y0, x1, y1, ...]);

     fizemos aí aparecer um "rótulo" de "x^2+y" para esse grupo de
     pontos em particular.  As aspas, `"', no início é que dizem ao
     xgraph isso é um rótulo.

          pt_set: append ([concat ("TitleText: Dados da Amostra")], [x0, ...])$

     fizemos o título principal do gráfico ser "Dados da Amostra" ao
     invés de "Maxima Plot".

     Para fazer um gráfico em barras com largura de 0.2 unidades, e
     para montar o gráfico com duas possibilidades diferentes dos tais
     gráficos em barras:
          xgraph_curves ([append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
              create_list ([i - .2, i^2], i, 1, 3)),
              append (["BarGraph: true", "NoLines: true", "BarWidth: .2"],
              create_list ([i + .2, .7*i^2], i, 1, 3))]);
     Um arquivo temporário `xgraph-out' é usado.


 -- Variável de sistema: plot_options
     Elementos dessa lista estabelecem as opções padrão para a montagem
     do gráfico.  Se uma opção está presente em uma chamada a `plot2d'
     ou `plot3d', esse valor tem precedência sobre a opção padrão.  De
     outra forma, o valor em `plot_options' é usado.  Opções padrão são
     atribuídas por `set_plot_option'.

     Cada elemento de `plot_options' é uma lista de dois ou mais ítens.
     O primeiro item é o nome de uma opção, e os restantes compreendem
     o valor ou valores atribuídos à opção.  Em alguns casos, o valor
     atribuído é uma lista, que pode compreender muitos ítens.

     As opções de montagem de gráfico que são reconhecidas por `plot2d'
     e `plot3d' são as seguintes:

        * Opção: `plot_format' determina qual pacote de montagem de
          gráfico é usado por `plot2d' e `plot3d'.

             * Valor padrão: `gnuplot' Gnuplot é o padrão, e mais
               avançado, pacote de montagem de gráfico.  Esse requer
               uma instalação externa do gnuplot.

             * Valor: `mgnuplot' Mgnuplot é um invólucro em torno do
               gnuplot baseado no Tk.  Isso está incluído na
               distribuíção do Maxima.  Mgnuplot oferece uma GUI
               rudimentar para o gnuplot, mas tem menos recursos em
               geral que a interface texto.  Mgnuplot requer uma
               instalação externa do gnuplot e Tcl/Tk.

             * Valor: `openmath' Openmath é um programa-GUI para
               montagem de gráfico baseado no Tcl/Tk.  Isso está
               incluído na distribuíção do Maxima.

             * Valor: `ps' Gera arquivos Postscript simples diretamente
               do Maxima.  Saídas Postscript mais sofisticadas podem
               ser geradas pelo gnuplot, deixando a opção `plot_format'
               não especificada (para aceitar o padrão), e posicionando
               a opção `gnuplot_term' para `ps'.

        * Opção: `run_viewer' controla se o visualizador apropriado
          para o formato da montagem do gráfico pode ou não poderá ser
          executado.

             * Valor padrão: `true' Executa o programa visualizador.

             * Valor: `false' Não executa o programa visualizador.

        * `gnuplot_term' Prepara a saída tipo terminal para gnuplot.
             * Valor padrão: `default' A saída do Gnuplot é mostrada em
               uma janela gráfica separada.

             * Valor: `dumb' A saída do Gnuplot é mostrada no console
               do Maxima como uma aproximação "arte ASCII" para
               gráficos.

             * Valor: `ps' Gnuplot gera comandos na linguagem
               PostScript de descrição de páginas.  Se a opção
               `gnuplot_out_file' está escolhida para <filename>,
               gnuplot escreve os comandos PostScript para <filename>.
               De outra forma, os comandos são mostrados no console
               Maxima.

        * Opção: `gnuplot_out_file' Escreve a saída gnuplot para um
          arquivo.

             * Valor padrão: `false' Nenhum arquivo de saída
               especificado.

             * Valor: <filename> Exemplo: `[gnuplot_out_file,
               "myplot.ps"]' Esse exemplo envia uma saída PostScript
               para o arquivo `myplot.ps' quando usada em conjunto com
               o terminal PostScript do gnuplot.

        * Opção: `x' A amplitude horizontal padrão.
               [x, - 3, 3]
          Especifica a amplitude horizontal para [-3, 3].

        * Opção: `y' A amplitude vertical padrão.
               [y, - 3, 3]
          Especifica a amplitude vertical para [-3, 3].

        * Opção: `t' A amplitude padrão para o parâmetro em montagem de
          gráficos paramétricos.
               [t, 0, 10]
          Especifica a amplitude da variável paramétrica para [0, 10].

        * Opção: `nticks' Número de pontos iniciais usado pela rotina
          adaptativa de montagem do gráfico.
               [nticks, 20]
          O padrão para `nticks' é 10.

        * Opção: `adapt_depth' O número maximo de quebras usada pela
          rotina adaptativa de montagem do gráfico.
               [adapt_depth, 5]
          O padrão para `adapt_depth' é 10.

        * Opção: `grid' Escolhe o número de pontos da grade para usar
          nas direções x e y para montagem de gráficos tridimensionais.
               [grid, 50, 50]
          Escolhe a grade para 50 por 50 pontos.  A grade padrão é 30
          por 30.

        * Opção: `transform_xy' Permite que transformações sejam
          aplicadas à montagem de gráficos tridimensionais.
               [transform_xy, false]
          O padrão `transform_xy' é `false'.  Se isso não é `false',
          pode ser a saída de
               make_transform ([x, y, z], f1(x, y, z), f2(x, y, z), f3(x, y, z))$
          A transformação `polar_xy' é previamente definida no Maxima.
          Isso fornece a mesma transformação que
               make_transform ([r, th, z], r*cos(th), r*sin(th), z)$

        * Opção: `colour_z' é específica para o formato `ps' de
          montagem de gráfico.
               [colour_z, true]
          O valor padrão para `colour_z' é `false'.

        * Opção: `view_direction' Específico para o formato `ps' de
          montagem de gráfico.
               [view_direction, 1, 1, 1]
          O padrão `view_direction' é [1, 1, 1].

     Existem muitas opções de montagem de gráficos específicas para
     gnuplot.  Todas essas opções (exceto `gnuplot_pm3d') são comandos
     gnuplot em estado natural, especificados como seqüências de
     caracteres.  Consulte a documentação do gnuplot para maiores
     detalhes.

        * Opção: `gnuplot_pm3d' Controla o uso do modo PM3D, que possui
          recursos avançados em 3D.  PM3D está somente disponível no
          gnuplot em versões após a 3.7.  O valor padrão para
          `gnuplot_pm3d' é `false'.

          Exemplo:

               [gnuplot_pm3d, true]

        * Opção: `gnuplot_preamble' Insere comandos antes que o gráfico
          seja desenhado.  Quaisquer comandos válidos para o gnuplot
          podem ser usados.  Multiplos comandos podem ser separados com
          um ponto e vírgula.  O exemplo mostrado produz uma escala
          numérica na montagem do gráfico.  O valor padrão para
          `gnuplot_preamble' é uma seqüência de caracteres vazia `""'.

          Exemplo:

               [gnuplot_preamble, "set log y"]

        * Opção: `gnuplot_curve_titles' Controla os títulos dados na
          chave da montagem do gráfico.  O valor padrão é `[default]',
          que automaticamente escolhe o título de cada curva para a
          função cujo gráfico está sendo construído. Se não contiver
          `[default]', `gnuplot_curve_titles' pode conter uma lista de
          seqüências de caracteres, cada uma das quais é `"title
          '<title_string>'"'.  (Para disabilitar a chave de impressão
          de gráfico, adicione `"set nokey"' a `gnuplot_preamble'.)

          Exemplo:

               [gnuplot_curve_titles, ["title 'Minha primeira função'", "title 'Minha segunda função'"]]

        * Opção: `gnuplot_curve_styles' Uma lista de seqüências de
          caracteres controlando a aparência das curvas, i.e., cor,
          largura, brilho, etc., para serem enviadas para o comando de
          montagem do gráfico do gnuplot.  O valor padrão é `["with
          lines 3", "with lines 1", "with lines 2", "with lines 5",
          "with lines 4", "with lines 6", "with lines 7"]', que circula
          através de diferentes cores.  Veja a documentação do gnuplot
          de `plot' para maiores informações.

          Exemplo:

               [gnuplot_curve_styles, ["with lines 7", "with lines 2"]]

        * Opção: `gnuplot_default_term_command' O comando gnuplot para
          escolher o tipo de terminal para o terminal padrão.  O valor
          padrão é a seqüência de caracteres vazia `""', i.e., usa os
          padrões do gnuplot.

          Exemplo:

               [gnuplot_default_term_command, "set term x11"]

        * Opção: `gnuplot_dumb_term_command' O comando gnuplot para
          escolher o tipo de terminal para o terminal dumb.  O valor
          padrão é `"set term dumb 79 22"', que faz a saída texto com
          79 caracteres por 22 caracteres.

          Exemplo:

               [gnuplot_dumb_term_command, "set term dumb 132 50"]

        * Opção: `gnuplot_ps_term_command' O comando gnuplot para
          escolher o tipo de terminal para o terminal PostScript.  O
          valor padrão é `"set size 1.5, 1.5;set term postscript eps
          enhanced color solid 24"', que escolhe o tamanho para 1.5
          vezes o padrão do gnuplot, e o tamanho da fonte para 24, além
          de outras coisas.  Veja a documentação do gnuplot de `set
          term postscript' para mais informação.

          Exemplo:

               [gnuplot_ps_term_command, "set term postscript eps enhanced color solid 18"]


     Exemplos:

        * Grava um gráfico de `sin(x)' para o arquivo `sin.eps'.

          plot2d (sin(x), [x, 0, 2*%pi], [gnuplot_term, ps], [gnuplot_out_file, "sin.eps"])$

        * Usa a opção do y para arrancar singularidades e a opção
          gnuplot_preamble para colocar a chave na parte inferior do
          gráfico em lugar de no topo.

          plot2d ([gamma(x), 1/gamma(x)], [x, -4.5, 5], [y, -10, 10], [gnuplot_preamble, "set key bottom"])$

        * Usa um muito complicado `gnuplot_preamble' para produzir
          elegantes rótulos para o eixo x.  (Note que a seqüência de
          caracteres `gnuplot_preamble' deve ser fornecida inteiramente
          sem qualquer quebra de linha.)

          my_preamble: "set xzeroaxis; set xtics ('-2pi' -6.283, '-3pi/2' -4.712, '-pi' -3.1415, '-pi/2' -1.5708, '0' 0,'pi/2' 1.5708, 'pi' 3.1415,'3pi/2' 4.712, '2pi' 6.283)"$
          plot2d ([cos(x), sin(x), tan(x), cot(x)], [x, -2*%pi, 2*%pi],
              [y, -2, 2], [gnuplot_preamble, my_preamble]);

        * Usa uma muito complicada `gnuplot_preamble' para produzir
          elegantes rótulos para o eixo x, e produzir saídas PostScript
          que pegam vantagens do formato de texto avançado disponível
          no gnuplot.  (Note que a seqüência de caracteres
          `gnuplot_preamble' deve ser fornecida inteiramente sem
          qualquer quebra de linha.)

          my_preamble: "set xzeroaxis; set xtics ('-2{/Symbol p}' -6.283, '-3{/Symbol p}/2' -4.712, '-{/Symbol p}' -3.1415, '-{/Symbol p}/2' -1.5708, '0' 0,'{/Symbol p}/2' 1.5708, '{/Symbol p}' 3.1415,'3{/Symbol p}/2' 4.712, '2{/Symbol p}' 6.283)"$
          plot2d ([cos(x), sin(x), tan(x)], [x, -2*%pi, 2*%pi], [y, -2, 2],
              [gnuplot_preamble, my_preamble], [gnuplot_term, ps], [gnuplot_out_file, "trig.eps"]);

        * Uma montagem de gráfico tridimensional usando o terminal
          gnuplot pm3d.

          plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4], [grid, 50, 50], [gnuplot_pm3d, true])$

        * Uma montagem de gráfico tridimensional sem a malha e com
          contornos projetados no plano inferior.

          my_preamble: "set pm3d at s;unset surface;set contour;set cntrparam levels 20;unset key"$
          plot3d (atan (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4], [grid, 50, 50],
              [gnuplot_pm3d, true], [gnuplot_preamble, my_preamble])$

        * Uma montagem de gráfico onde o eixo z é representado apenas
          por cores.  (Note que a seqüência de caracteres
          `gnuplot_preamble' deve ser fornecida inteiramente sem
          qualquer quebra de linha.)

          plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
              [gnuplot_preamble, "set view map; unset surface"], [gnuplot_pm3d, true], [grid, 150, 150])$


 -- Função: plot3d (<expr>, <x_range>, <y_range>, ..., <options>, ...)
 -- Função: plot3d (<name>, <x_range>, <y_range>, ..., <options>, ...)
 -- Função: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_rge>, <y_rge>)
 -- Função: plot3d ([<name_1>, <name_2>, <name_3>], <x_range>,
          <y_range>, ..., <options>, ...)
     Mostra um gráfico de uma ou três expressões como funções de duas
     variáveis.

          plot3d (2^(-u^2 + v^2), [u, -5, 5], [v, -7, 7]);

     monta o gráfico `z = 2^(-u^2+v^2)' com `u' e `v' variando em
     [-5,5] e [-7,7] respectivamente, e com <u> sobre o eixo x, e `v'
     sobre o eixo y.

     Um terceiro exemplo de modelo de argumento é

          plot3d ([cos(x)*(3 + y*cos(x/2)), sin(x)*(3 + y*cos(x/2)), y*sin(x/2)],
             [x, -%pi, %pi], [y, -1, 1], ['grid, 50, 15]);

     que monta o gráfico da banda de Moebius, parametrizada por três
     expressões fornecidas como o primeiro argumento para `plot3d'.  Um
     adicional e opcional argumento `['grid, 50, 15]' fornece o número
     de retâgulos da grade na direção x e na direção y.

     Quando a função a ser montado o gráfico for uma função definida no
     Maxima por meio de `:=' ou `define', ou em Lisp por meio de DEFUN
     ou DEFMFUN, a função pode ser especificada através do nome.
     Funções definidas em Lisp por meio de DEFMSPEC, e funções de
     simplificação, não podem ser especificadas através do nome; que
     inclui muitas funções internas.

     Esse exemplo mostra uma montagem de gráfico da parte real de
     `z^1/3'.

           plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
               ['grid, 12, 80], ['plot_format, ps],
               ['transform_xy, polar_to_xy], ['view_direction, 1, 1, 1.4],
               ['colour_z, true]);

     Aqui a opção `view_direction' indica a direção da qual nós pegamos
     a projeção.  Nós atualmente fazemos isso de infinitamente distante,
     mas paralelo à linha de `view_direction' para a orígem.  Isso é
     correntemente usado somente em plot_format `ps', uma vez que
     outros visualizadores permitem rotação interativa do objeto.

     Outro exemplo é uma superfície de Klein:

          expr_1: 5*cos(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0) - 10.0;
          expr_2: -5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0);
          expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y));

          plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi], [y, -%pi, %pi], ['grid, 40, 40]);

     ou um toro

          expr_1: cos(y)*(10.0+6*cos(x));
          expr_2: sin(y)*(10.0+6*cos(x));
          expr_3: -6*sin(x);

          plot3d ([expr_1, expr_2, expr_3], [x, 0, 2*%pi], [y, 0, 2*%pi], ['grid, 40, 40]);

     Podemos também enviar saídas para o gnuplot:

          plot3d (2^(x^2 - y^2), [x, -1, 1], [y, -2, 2], [plot_format, gnuplot]);

     Algumas vezes você precisa definir uma função para mortar o
     gráfico de uma expressão.  Todos os argumentos para plot3d são
     avaliados antes de serem passados para plot3d, e então tentando
     fazer um expressão que faz apenas o que você que pode ser difícil,
     e é apenas mais fácil fazer uma função.

          M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4], [1, 2, 3, 3])$
          f(x, y) := float (M [?round(x), ?round(y)])$
          plot3d (f, [x, 1, 4], [y, 1, 4], ['grid, 4, 4])$

     Veja `plot_options' para mais exemplos.


 -- Função: make_transform (<vars>, <fx>, <fy>, <fz>)
     Retornam uma função adequada para a função transformação em
     plot3d.  Use com a opção de montagem de gráfico `transform_xy'.
          make_transform ([r, th, z], r*cos(th), r*sin(th), z)$
     é uma transformação para coordenadas polares.

 -- Função: plot2d_ps (<expr>, <range>)
     Escreve para pstream uma seqüência de comandos PostScript que
     montam o graáfico de <expr> sobre <range>.

     <expr> é uma expressão.  <range> é uma lista da forma `[<x>,
     <min>, <max>]' na qual <x> é uma variável que aparece em <expr>.

     Veja também `closeps'.


 -- Função: closeps ()
     Essa poderá usualmente ser chamada no final de um seqüência
     comandos de montagem de gráfico.   Isso fecha o fluxo corrente de
     saída <pstream>, e altera esse para nil.   Isso também pode ser
     chamado ao iniciar uma montagem de gráfico, para garantir que
     pstream será fechado se estiver aberto.    Todos os comandos que
     escrevem para pstream, abrem isso se necessário.   `closeps' é
     separada de outros comandos de montagem de gráfico, posteriormente
     podemos querer montar um gráfico com 2 amplitudes ou sobrepor
     muitas montagens de gráficos, e então devemos manter esse fluxo
     aberto.

 -- Função: set_plot_option (<opção>)
     Atribui uma das varáveis globais para impressão.  <option> é
     especificada como uma lista de dois ou mais elementos, na qual o
     primeiro elemeto é uma das palavras chave dentro da lista
     `plot_options'.

     `set_plot_option' avalia seu argumento.  `set_plot_option' retorna
     `plot_options' (após modificar um desses elementos).

     Veja também `plot_options', `plot2d', e `plot3d'.

     Exemplos:

     Modifica a malha (`grid') e valores de `x'.  Quando uma palavra
     chave em `plot_options' tem um valor atribuído, colocar um
     apóstrofo evita avaliação.

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[x, - 1.755559702014E+305, 1.755559702014E+305],
          [y, - 1.755559702014E+305, 1.755559702014E+305], [t, - 3, 3],
          [grid, 30, 40], [view_direction, 1, 1, 1], [colour_z, false],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]
          (%i2) x: 42;
          (%o2)                          42
          (%i3) set_plot_option (['x, -100, 100]);
          (%o3) [[x, - 100.0, 100.0], [y, - 1.755559702014E+305,
          1.755559702014E+305], [t, - 3, 3], [grid, 30, 40],
          [view_direction, 1, 1, 1], [colour_z, false],
          [transform_xy, false], [run_viewer, true],
          [plot_format, gnuplot], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 10], [adapt_depth, 10],
          [gnuplot_pm3d, false], [gnuplot_preamble, ],
          [gnuplot_curve_titles, [default]],
          [gnuplot_curve_styles, [with lines 3, with lines 1,
          with lines 2, with lines 5, with lines 4, with lines 6,
          with lines 7]], [gnuplot_default_term_command, ],
          [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript #
          eps enhanced color solid 24]]


 -- Função: psdraw_curve (<ptlist>)
     Desenha uma curva conectando os pontos em <ptlist>.   O último
     pode ser da forma `[x0, y0, x1, y1, ...]' ou da forma `[[x0, y0],
     [x1, y1], ...]'

     A função `join' é útil fazendo uma lista dos x's e uma lista dos
     y's e colocando-os juntos.

     <psdraw_curve> simplesmente invoca a mais primitiva função
     <pscurve>.   Aqui está a definiçã:

          (defun $psdraw_curve (lis)
            (p "newpath")
            ($pscurve lis)
            (p "stroke"))


 -- Função: pscom (<cmd>)
     <cmd> é inserida no arquivo PostScript.  Exemplo:
          pscom ("4.5 72 mul 5.5 72 mul translate 14 14 scale");



File: maxima.info,  Node: Entrada e Saída,  Next: Ponto Flutuante,  Prev: Montando Gráficos,  Up: Top

9 Entrada e Saída
*****************

* Menu:

* Introdução a Entrada e Saída::
* Arquivos::
* Definições para Entrada e Saída::


File: maxima.info,  Node: Introdução a Entrada e Saída,  Next: Arquivos,  Prev: Entrada e Saída,  Up: Entrada e Saída

9.1 Introdução a Entrada e Saída
================================


File: maxima.info,  Node: Arquivos,  Next: Definições para Entrada e Saída,  Prev: Introdução a Entrada e Saída,  Up: Entrada e Saída

9.2 Arquivos
============

Um arquivo é simplesmente uma área sobre um dispositivo particular de
armazenagem que contém dados ou texto.  Arquivos em disco são
figurativamente agrupados dentro de "diretórios".  Um diretório é
apenas uma lista de arquivos.  Comandos que lidam com arquivos são:
`save', `load', `loadfile', `stringout', `batch', `demo', `writefile',
`closefile', and `appendfile'.


File: maxima.info,  Node: Definições para Entrada e Saída,  Prev: Arquivos,  Up: Entrada e Saída

9.3 Definições para Entrada e Saída de Dados
============================================

 -- Variável de sistema: __
     `__' é a expressão de entrada atualmente sendo avaliada.  Isto é,
     enquanto um expressão de entrada <expr> está sendo avaliada, `__'
     é <expr>.

     `__' é atribuída à expressão de entrada antes de a entrada ser
     simplificada ou avaliada.  Todavia, o valor de `__' é simplificado
     (mas não avaliado) quando for mostrado.

     `__' é reconhecido por `batch', mas não por `load'.

     Veja também `_' e `%'.

     Exemplos:

          (%i1) print ("Eu fui chamada como", __);
          Eu fui chamada como print(Eu fui chamada como, __)
          (%o1)              print(Eu fui chamada como, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Expressão atual de entrada =", __), 0);
          (%o3) g(x) := (print("Expressão atual de entrada =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                         cc + bb + aa
          Expressão atual de entrada = --------------
                                        g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- Variável de sistema: _
     `_' é a mais recente expressão de  entrada (e.g., `%i1', `%i2',
     `%i3', ...).

     A `_' é atribuída à expressão de entrada antes dela ser
     simplificada ou avaliada.  Todavia, o valor de `_' é simplificado
     (mas não avaliado) quando for mostrado.

     `_' é reconhecido por `batch', mas não por `load'.

     Veja também `__' e `%'.

     Exemplos:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- Variável de sistema: %
     `%' é a expressão de saída (e.g., `%o1', `%o2', `%o3', ...)  mais
     recentemente calculada pelo Maxima, pode ou não ser mostrada.  `%'
     é reconhecido por `batch', mas não por `load'.

     Veja também `_', `%%', e `%th'


 -- Variável de sistema: %%
     Em declaração composta, a saber `block', `lambda', ou `(<s_1>,
     ..., <s_n>)', `%%' é os valor da declaração anterior.  Por exemplo,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x), ev (prev, x=2) - ev (prev, x=1));

     retornam o mesmo resultado, a saber `21/2'.

     Uma declaração composta pode compreender outras declarações
     compostas.  Pode uma declaração ser simples ou composta, `%%' é o
     valor da declaração anterior.  Por exemplo,

          block (block (a^n, %%*42), %%/6)

     retorna `7*a^n'.

     Dentro da declaração composta, o valor de `%%' pode ser
     inspecionado em uma parada de linha de comando, que é aberta pela
     execução da função `break'.  Por exemplo, na parada de linha de
     comando aberta por

          block (a: 42, break ())$

     digitando `%%;' retorna `42'.

     Na primeira declaração em uma declaração composta, ou fora de uma
     declaração composta, `%%' é indefinido.

     `%%'  reconhecido por ambos `batch' e `load'.

     Veja também `%'.


 -- Variável de opção: %edispflag
     Valor padrão: `false'

     Quando `%edispflag' é `true', Maxima mostra `%e' para um expoente
     negativo como um quociente.  Por exemplo, `%e^-x' é mostrado como
     `1/%e^x'.


 -- Função: %th (<i>)
     O valor da <i>'ésima expressão prévia de saída.  Isto é, se a
     próxima expressão a ser calculada for a <n>'ésima saída, `%th
     (<m>)' será a (<n> - <m>)'ésima saída.

     `%th' é útil em arquivos `batch' ou para referir-se a um grupo de
     expressões de saída.  Por exemplo,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     escolhe `s' para a soma das últimas dez expressões de saída.

     `%th' é reconhecido por `batch', mas não por `load'.

     Veja também `%'.


 -- Símbolo especial: "?"
     Como prefixo para uma função ou nome de variável, `?' significa que
     o nome é um nome Lisp, não um nome Maxima.  Por exemplo, `?round'
     significa a função Lisp `ROUND'.  Veja *Note Lisp e Maxima:: para
     mais sobre esse ponto.

     A notação `? word' (um ponto de interrogação seguido de uma
     palavra e separado desta por um espaço em branco) é equivalente a
     `describe ("word")'.


 -- Variável de opção: absboxchar
     Valor padrão: `!'

     `absboxchar' é o caracter usado para para desenhar o sinal de valor
     absoluto em torno de expressões que são maiores que uma linha de
     altura.


 -- Variável de opção: file_output_append
     Valor padrão: `false'

     `file_output_append' governa se funções de saída de arquivo anexam
     ao final ou truncam seu arquivo de saída.  Quando
     `file_output_append' for `true', tais funções anexam ao final de
     seu arquivo de saída.  De outra forma, o arquivo de saída é
     truncado.

     `save', `stringout', e `with_stdout' respeitam
     `file_output_append'.  Outras funções que escrevem arquivos de
     saída não respeitam `file_output_append'.  Em partivular, montagem
     de gráficos e traduções de funções sempre truncam seu arquivo de
     saída, e `tex' e `appendfile' sempre anexam ao final.


 -- Função: appendfile (<filename>)
     Adiciona ao final de <filename> uma transcrição do console.
     `appendfile' é o mesmo que `writefile', exceto que o arquivo
     transcrito, se já existe, terá sempre alguma coisa adicionada ao
     seu final.

     `closefile' fecha o arquivo transcrito que foi aberto
     anteriormente por `appendfile' ou por `writefile'.


 -- Função: batch (<filename>)
     Lê expressões Maxima do arquivo <filename> e as avalia.  `batch'
     procura pelo arquivo <filename> na lista `file_search_maxima'.
     Veja `file_search'.

     <filename> compreende uma seqüência de expressões Maxima, cada uma
     terminada com `;' ou `$'.  A varável especial `%' e a função `%th'
     referem-se a resultados prévios dentro do arquivo.  O arquivo pode
     incluir construções `:lisp'.  Espaços, tabulações, e o caracter de
     nova linha no arquivo serão ignorados.  um arquivo de entrada
     conveniente pode ser criado por um editor de texto ou pela função
     `stringout'.

     `batch' lê cada expressão de entrada de <filename>, mostra a
     entrada para o console, calcula a correspondente expressão de
     saída, e mostra a expressão de saída.  Rótulos de entrada são
     atribuídos para expressões de entrada e rótulos de saída são
     atribuídos para expressões de saída.  `batch' avalia toda
     expressão de entrada no arquivo a menos que exista um erro.  Se
     uma entrada de usuário for requisitada (by `asksign' ou
     `askinteger', por exemplo) `batch' interrompe para coletar a
     entrada requisitada e então continua.

     Isso possibilita interromper `batch' pela digitação de `control-C'
     no console.  O efeito de `control-C' depende da subjacente
     implementação do Lisp.

     `batch' tem muitos usos, tais como fornecer um reservatório para
     trabalhar linhas de comando, para fornecer demonstrações livres de
     erros, ou para ajudar a organizar alguma coisa na solução de
     problemas complexos.

     `batch' avalia seu argumento.  `batch' não possui valor de retorno.

     Veja também `load', `batchload', e `demo'.


 -- Função: batchload (<filename>)
     Lê expressões Maxima de <filename> e as avalia, sem mostrar a
     entrada ou expressões de saída e sem atribuir rótulos para
     expressões de saída.  Saídas impressas (tais como produzidas por
     `print' ou `describe') são mostradas, todavia.

     A variável especial `%' e a função `%th' referem-se a resultados
     anteriores do interpretador interativo, não a resultados dentro do
     arquivo.  O arquivo não pode incluir construções `:lisp'.

     `batchload' retorna o caminho de <filename>, como uma seqüência de
     caracteres.  `batchload' avalia seu argumento.

     Veja também `batch' e `load'.


 -- Função: closefile ()
     Fecha o arquivo transcrito aberto por `writefile' ou `appendfile'.


 -- Função: collapse (<expr>)
     Reduz <expr> fazendo com que todas as suas subexpressões comuns
     (i.e., iguais)  serem compartilhadas (i.e., usam a mesma células),
     dessa forma exonomizando espaço.  (`collapse' é uma subrotina
     usada pelo comando `optimize'.)  Dessa forma, chamar `collapse'
     pode ser útil após um `save' arquivo.  Você pode diminuir muitas
     expressões juntas pelo uso de `collapse ([<expr_1>, ...,
     <expr_n>])'.  Similarmente, você pode diminuir os elementos de um
     array `A' fazendo `collapse (listarray ('A))'.


 -- Função: concat (<arg_1>, <arg_2>, ...)
     Concatena seus argumentos.  Os argumentos devem obrigatóriamente
     serem avaliados para atomos.  O valor de retorno é um símbolo se o
     primeiro argumento for um símbolo e uma seqüência de caracteres no
     formato do Maxima em caso contrário.

     `concat' avalia seus argumentos.  O apóstrofo `'' evita avaliação.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     Um símbolo construído por `concat' pode ser atribuído a um valor e
     aparecer em expressões.  O operador de atribuição `::' (duplo dois
     pontos) avalia seu lado esquerdo.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Note que embora `concat (1, 2)' seja visto como um números, isso é
     uma seqüência de caracteres no formato do Maxima.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Função: sconcat (<arg_1>, <arg_2>, ...)
     Concatena seus argumentos em uma seqüência de caracteres.  Ao
     contrário de `concat', os argumentos arrumados não precisam ser
     atômicos.

     O resultado é uma seqüência de caracteres no format do Lisp.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Função: disp (<expr_1>, <expr_2>, ...)
     é como `display' mas somente os valores dos argumentos são
     mostrados em lugar de equações.  Isso é útil para argumentos
     complicados que não possuem nomes ou onde somente o valor do
     argumento é de interesse e não o nome.


 -- Função: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Função: dispcon (all)
     Mostram as propriedades de contração de seus argumentos como foram
     dados para `defcon'.  `dispcon (all)' mostra todas as propriedades
     de contração que foram definidas.


 -- Função: display (<expr_1>, <expr_2>, ...)
     Mostra equações cujo lado esquerdo é <expr_i> não avaliado, e cujo
     lado direito é o valor da expressão centrada na linha.  Essa
     função é útil em blocos e em `for' declarações com o objetivo de
     ter resultados intermediários mostrados.  The Os argumentos para
     `display' são usualmente átomos, variáveis subscritas, ou chamadas
     de função.  Veja também `disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done


 -- Variável de opção: display2d
     Valor padrão: `true'

     Quando `display2d' é `false', O console visualizador é
     unidimensional ao invés de bidimensional.


 -- Variável de opção: display_format_internal
     Valor padrão: `false'

     Quando `display_format_internal' é `true', expressões são
     mostradas sem ser por caminhos que escondam a representação
     matemática interna.  O visualizador então corresponde ao que
     `inpart' retorna em lugar de `part'.

     Exemplos:

          User     part       inpart
          a-b;      A - B     A + (- 1) B

                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   sqrt(X)    X

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Função: dispterms (<expr>)
     Mostra <expr> em partes uma abaixo da outra.  Isto é, primeiro o
     operador de <expr> é mostrado, então cada parcela em uma adição,
     ou fatores em um produto, ou parte de uma expressão mais geral é
     mostrado separadamente.  Isso é útil se <expr> é muito larga para
     ser mostrada de outra forma.  Por exemplo se `P1', `P2', ...  são
     expressões muito largas então o programa visualizador pode sair
     fora do espaço de armazenamento na tentativa de mostrar `P1 + P2 +
     ...'  tudo de uma vez.  Todavia, `dispterms (P1 + P2 + ...)'
     mostra `P1', então abaixo disso `P2', etc.  Quando não usando
     `dispterms', se uma expressão exponencial é muito alta para ser
     mostrada como `A^B' isso aparece como `expt (A, B)' (ou como
     `ncexpt (A, B)' no caso de `A^^B').


 -- Variável de opção: error_size
     Valor padrão: 10

     `error_size' modifica mensagens de erro conforme o tamanho das
     expressões que aparecem nelas.  Se o tamanho de uma expressão
     (como determinado pela função Lisp `ERROR-SIZE') é maior que
     `error_size', a expressão é substituída na mensagem por um símbolo,
     e o o símbolo é atribuído à expressão.  Os símbolos são obtidos da
     lista `error_syms'.

     De outra forma, a expressão é menor que `error_size', e a
     expressão é mostrada na mensagem.

     Veja também `error' e `error_syms'.

     Exemplo:

     O tamanho de `U', como determinado por `ERROR-SIZE', é 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Expressão exemplo é", U);

          Expressão exemplo é errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Expressão exemplo é", U);

                                     E
                                    D
                                   C   + B + A
          Expressão exemplo é --------------
                                  cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Variável de opção: error_syms
     Valor padrão: `[errexp1, errexp2, errexp3]'

     Em mensagens de erro, expressões mais largas que `error_size' são
     substituídas por símbolos, e os símbolos são escolhidos para as
     expressões.  Os símbolos são obtidos da lista `error_syms'.  A
     primeira expressão muito larga é substituída por `error_syms[1]',
     a segunda por `error_syms[2]', e assim por diante.

     Se houverem mais expressões muito largas que há elementos em
     `error_syms', símbolos são construídos automaticamente, com o
     <n>-ésimo símbolo equivalente a `concat ('errexp, <n>)'.

     Veja também `error' e `error_size'.


 -- Função: expt (<a>, <b>)
     Se uma expressão exponencial é muito alta para ser mostrada cmo
     `<a>^<b>' isso aparece como `expt (<a>, <b>)' (ou como `ncexpt
     (<a>, <b>)' no caso de `<a>^^<b>').

     `expt' e `ncexpt' não são reconhecidas em entradas.


 -- Variável de opção: exptdispflag
     Valor padrão: `true'

     Quando `exptdispflag' é `true', Maxima mostra expressões com
     expoente negativo usando quocientes, e.g., `X^(-1)' como `1/X'.


 -- Função: filename_merge (<path>, <filename>)
     Constroem um caminho modificado de <path> e <filename>.  Se o
     componente final de <path> é da forma `###.<algumacoisa>', o
     componente é substituído com `<filename>.<algumacoisa>'.  De outra
     forma, o componente final é simplesmente substituído por
     <filename>.


 -- Função: file_search (<filename>)
 -- Função: file_search (<filename>, <pathlist>)
     `file_search' procura pelo arquivo <filename> e retorna o caminho
     para o arquivo (como uma seqüência de caracteres) se ele for
     achado; de outra forma `file_search' retorna `false'.
     `file_search (<filename>)' procura nos diretórios padrões de busca,
     que são especificados pelas variáveis `file_search_maxima',
     `file_search_lisp', e `file_search_demo'.

     `file_search' primeiro verifica se o nome atual passado existe,
     antes de tentar coincidir esse nome atual com o modelo "coringa"
     de busca do arquivo.  Veja `file_search_maxima' concernente a
     modelos de busca de arquivos.

     O argumento <filename> pode ser um caminho e nome de arquivo, ou
     apenas um nome de arquivo, ou, se um diretório de busca de arquivo
     inclui um modelo de busca de arquivo, apenas a base do nome de
     arquivo (sem uma extensão).  Por exemplo,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     todos acham o mesmo arquivo, assumindo que o arquivo exista e
     `/home/wfs/special/###.mac' está em `file_search_maxima'.

     `file_search (<filename>, <pathlist>)' procura somente nesses
     diretórios especificados por <pathlist>, que é uma lista de
     seqüências de caracteres.  O argumento <pathlist> substitui os
     diretórios de busca padrão, então se a lista do caminho é dada,
     `file_search' procura somente nesses especificados, e não qualquer
     dos diretórios padrão de busca.  Mesmo se existe somente um
     diretório em <pathlist>, esse deve ainda ser dado como uma lista
     de um único elemento.

     O usuário pode modificar o diretório de busca padrão.  Veja
     `file_search_maxima'.

     `file_search' é invocado por `load' com `file_search_maxima' e
     `file_search_lisp' como diretórios de busca.


 -- Variável de opção: file_search_maxima
 -- Variável de opção: file_search_lisp
 -- Variável de opção: file_search_demo
     Essas variáveis especificam listas de diretórios a serem procurados
     por `load', `demo', e algumas outras funções do Maxima.  O valor
     padrão dessas variáveis nomeia vários diretórios na instalaçã
     padrão do Maxima.

     O usuáro pode modificar essas variáveis, quer substituindo os
     valores padrão ou colocando no final diretórios adicionais.  Por
     exemplo,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     substitui o valor padrão de `file_search_maxima', enquanto

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     adiciona no final da lista dois diretórios adicionais.  Isso pode
     ser conveniente para colocar assim uma expressão no arquivo
     `maxima-init.mac' de forma que o caminho de busca de arquivo é
     atribuído automaticamente quando o Maxima inicia.

     Multiplas extensões de arquivo e e multiplos caminhos podem ser
     especificados por construções "coringa" especiais.  A seqüência de
     caracteres `###' expande a busca para além do nome básico,
     enquanto uma lista separada por vírgulas e entre chaves
     `{foo,bar,baz}' expande em multiplas seqüências de caracteres.
     Por exemplo, supondo que o nome básico a ser procurado seja
     `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     expande em `/home/wfs/neumann.lisp', `/home/gcj/neumann.lisp',
     `/home/wfs/neumann.mac', e `/home/gcj/neumann.mac'.


 -- Função: file_type (<filename>)
     Retorna uma suposta informação sobre o conteúdo de <filename>,
     baseada na extensão do arquivo.  <filename> não precisa referir-se
     a um arquivo atual; nenhuma tentativa é feita para abrir o arquivo
     e inspecionar seu conteúdo.

     O valor de retorno é um símbolo, qualquer um entre `object',
     `lisp', ou `maxima'.  Se a extensão começa com `m' ou `d',
     `file_type' retorna `maxima'.  Se a extensão começa om `l',
     `file_type' retorna `lisp'.  Se nenhum dos acima, `file_type'
     retorna `object'.


 -- Função: grind (<expr>)
 -- Variável de opção: grind
     A função `grind' imprime <expr> para o console em uma forma
     adequada de entrada para Maxima.  `grind' sempre retorna `done'.

     Quando <expr> for um nome de uma função ou o nome de uma macro,
     `grind' mostra na tela a definição da função ou da macro em lugar
     de apenas o nome.

     Veja também `string', que retorna uma seqüência de caracteres em
     lugar de imprimir sua saída.  `grind' tenta imprimir a expressão
     de uma maneira que a faz levemente mais fácil para ler que a saída
     de `string'.

     Quando a variável `grind' é `true', a saída de `string' e
     `stringout' tem o mesmo formato que `grind'; de outra forma
     nenhuma tentativa é feita para formatar especialmente a saída
     dessas funções.  O valor padrão da variável `grind' é `false'.

     `grind' pode também ser especificado como um argumento de
     `playback'.  Quando `grind' está presente, `playback' imprime
     expressões de entrada no mesmo formato que a função `grind'.  De
     outra forma, nenhuma tentativa é feita para formatar especialmente
     as expressões de entrada.  `grind' avalia seus argumentos.

     Exemplos:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
          p : makelist (0, i, 1, length (A))], for i thru n do for j : i thru n do
          (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1), if i = j then
          p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]), for i thru n do L[i, i] : 1 / p[i],
          for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)


 -- Variável de opção: ibase
     Valor padrão: 10

     Inteiros fornecidos dentro do Maxima são interpretados com
     respeito à base `ibase'.

     A `ibase' pode ser atribuído qualquer inteiro entre 2 e 35
     (decimal), inclusive.  Quando `ibase' é maior que 10, os numerais
     compreendem aos numerais decimais de 0 até 9 mais as letras
     maiúsculas do alfabeto A, B, C, ..., como necessário.  Os numerais
     para a base 35, a maior base aceitável, compreendem de 0 até 9 e
     de A até Y.

     Veja também `obase'.


 -- Variável de opção: inchar
     Valor padrão: `%i'

     `inchar' é o prefixo dos rótulos de expressões fornecidas pelo
     usuário.  Maxima automaticamente constrói um rótulo para cada
     expressão de entrada por concatenação de `inchar' e `linenum'.  A
     `inchar' pode ser atribuído qualquer seqüência de caracteres ou
     símbolo, não necessariamente um caracter simples.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     Veja também `labels'.


 -- Função: ldisp (<expr_1>, ..., <expr_n>)
     Mostra expressões <expr_1>, ..., <expr_n> para o console como
     saída impressa na tela.  `ldisp' atribue um rótulo de expressão
     intermediária a cada argumento e retorna a lista de rótulos.

     Veja também `disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Função: ldisplay (<expr_1>, ..., <expr_n>)
     Mostra expressões <expr_1>, ..., <expr_n> para o console como
     saída impressa na tela.  Cada expressão é impressa como uma
     equação da forma `lhs = rhs' na qual `lhs' é um dos argumentos de
     `ldisplay' e `rhs' é seu valor.  Tipicamente cada argumento é uma
     variável.  `ldisp' atribui um rótulo de expressão intermediáia a
     cada equação e retorna a lista de rótulos.

     Veja também `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Variável de opção: linechar
     Valor padrão: `%t'

     `linechar' é o refixo de rótulos de expressões intermediárias
     gerados pelo Maxima.  Maxima constrói um rótulo para cada
     expressão intermediária (se for mostrada) pela concatenação de
     `linechar' e `linenum'.  A `linechar' pode ser atribuído qualquer
     seqüência de caracteres ou símbolo, não necessáriamente um
     caractere simples.

     Expressões intermediárias podem ou não serem mostradas.  See
     `programmode' e `labels'.


 -- Variável de opção: linel
     Valor padrão: 79

     `linel' é a largura assumida (em caracteres) do console para o
     propósito de mostrar expressões.  A `linel' pode ser atribuído
     qualquer valor pelo usuário, embora valores muio pequenos ou muito
     grandes possam ser impraticáveis.  Textos impressos por funções
     internas do Maxima, tais como mensagens de erro e a saída de
     `describe', não são afetadas por `linel'.


 -- Variável de opção: lispdisp
     Valor padrão: `false'

     Quando `lispdisp' for `true', símbolos Lisp são mostrados com um
     ponto de interrogação `?' na frente.  De outra forma, símbolos
     Lisp serão mostrados sem o ponto de interrogaçõ na frente.

     Exemplos:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Função: load (<filename>)
     Avalia expressões em <filename>, dessa forma conduzindo variáveis,
     funções, e outros objetos dentro do Maxima.  A associação de
     qualquer objeto existente é substituída pela associação recuperada
     de <filename>.  Para achar o arquivo, `load' chama `file_search'
     com `file_search_maxima' e `file_search_lisp' como diretórios de
     busca.  Se `load' obtém sucesso, isso retorna o nome do arquivo.
     De outra forma `load' imprime uma mensagem e erro.

     `load' trabalha igualmente bem para códigos Lisp e códigos Maxima.
     Arquivos criados por `save', `translate_file', e `compile_file',
     que criam códigos Lisp, e `stringout', que criam códigos Maxima,
     podem ser processadas por `load'.  `load' chama `loadfile' para
     carregar arquivos Lisp e `batchload' para carregar arquivos Maxima.

     Veja também `loadfile', `batch', `batchload', e `demo'.
     `loadfile' processa arquivos Lisp; `batch', `batchload', e `demo'
     processam arquivos Maxima.

     Veja `file_search' para mais detalhes sobre o mecanismo de busca
     de arquivos.

     `load' avalia seu argumento.


 -- Função: loadfile (<filename>)
     Avalia expressões Lisp em <filename>.  `loadfile' não invoca
     `file_search', então `filename' deve obrigatóriamente incluir a
     extensão do arquivo e tanto quanto o caminho como necessário para
     achar o arquivo.

     `loadfile' pode processar arquivos criados por `save',
     `translate_file', e `compile_file'.  O usuário pode achar isso
     mais conveniente para usar `load' em lugar de `loadfile'.

     `loadfile' avalia seu argumento, então `filename' deve
     obrigatóriamente ser uma seqüência de caracteres literal, não uma
     variável do tipo seqüência de caracteres.  O operador aspas
     simples não aceita avaliação.


 -- Variável de opção: loadprint
     Valor padrão: `true'

     `loadprint' diz se deve imprimir uma mensagem quando um arquivo é
     chamado.

        * Quando `loadprint' é `true', sempre imprime uma mensagem.

        * Quando `loadprint' é `'loadfile', imprime uma mensagem
          somente se um arquivo é chamado pela função `loadfile'.

        * Quando `loadprint' é `'autoload', imprime uma mensagem
          somente se um arquivo é automaticamente carregado.  Veja
          `setup_autoload'.

        * Quando `loadprint' é `false', nunca imprime uma mensagem.


 -- Variável de opção: obase
     Valor padrão: 10

     `obase' é a base para inteiros mostrados pelo Maxima.

     A `obase' poode ser atribuído qualquer inteiro entre 2 e 35
     (decimal), inclusive.  Quando `obase' é maior que 10, os numerais
     compreendem os numerais decimais de 0 até 9 e letras maiúsulas do
     alfabeto A, B, C, ..., quando necessário.  Os numerais para a base
     35, a maior base aceitável, compreendem de 0 até 9, e de A até Y.

     Veja também `ibase'.


 -- Variável de opção: outchar
     Valor padrão: `%o'

     `outchar' é o prefixo dos rótulos de expressões calculadas pelo
     Maxima.  Maxima automaticamente constrói um rótulo para cada
     expressão calculada pela concatenação de `outchar' e `linenum'.  A
     `outchar' pode ser atribuído qualquer seqüência de caracteres ou
     símbolo, não necessáriamente um caractere simples.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     Veja também `labels'.


 -- Variável de opção: packagefile
     Valor padrão: `false'

     Projetistas de pacotes que usam `save' ou `translate' para criar
     pacotes (arquivos) para outros usarem podem querer escolher
     `packagefile: true' para prevenir qu informações sejam
     acrescentadas à lista de informações do Maxima (e.g. `values',
     `funções') exceto onde necessário quando o arquivo é carregado.
     Nesse caminho, o conteúdo do pacote não pegará no caminho do
     usuário quando ele adicionar seus próprios dados.  Note que isso
     não resolve o problema de possíveis conflitos de nome.  Também
     note que o sinalizador simplesmente afeta o que é saída para o
     arquivo pacote.  Escolhendo o sinalizador para `true' é também
     útil para criar arquivos de init do Maxima.


 -- Variável de opção: pfeformat
     Valor padrão: `false'

     Quando `pfeformat' é `true', uma razão de inteiros é mostrada com
     o caractere sólido (barra normal), e um denominador inteiro `n' é
     mostrado como um termo multiplicativo em primeiro lugar `1/n'.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Função: print (<expr_1>, ..., <expr_n>)
     Avalia e mostra <expr_1>, ..., <expr_n> uma após a outra, da
     esquerda para a direita, iniciando no lado esquerdo do console.

     O valor retornado por `print' é o valor de seu último argumento.
     `print' não gera rótulos de expressão intermediária.

     Veja também `display', `disp', `ldisplay', e `ldisp'.  Essas
     funções mostram uma expressão por linha, enquanto `print' tenta
     mostrar duas ou mais expressões por linha.

     Para mostrar o conteúdo de um arquivo, veja `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is", radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Função: tcl_output (<list>, <i0>, <skip>)
 -- Função: tcl_output (<list>, <i0>)
 -- Função: tcl_output ([<list_1>, ..., <list_n>], <i>)
     Imprime os elementos de uma lista entre chaves `{ }', conveniente
     como parte de um programa na linguagem Tcl/Tk.

     `tcl_output (<list>, <i0>, <skip>)' imprime <list>, começando com
     o elemento <i0> e imprimindo elementos `<i0> + <skip>', `<i0> + 2
     <skip>', etc.

     `tcl_output (<list>, <i0>)' é equivalente a `tcl_output (<list>,
     <i0>, 2)'.

     `tcl_output ([<list_1>, ..., <list_n>], <i>)' imprime os
     <i>'ésimos elementos de <list_1>, ..., <list_n>.

     Exemplos:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }


 -- Função: read (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n>, então lê uma expressão do console
     e retorna a expressão avaliada.  A expressão é terminada com um
     ponto e vírgula `;' ou o sinal de dólar `$'.

     Veja também `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Função: readonly (<expr_1>, ..., <expr_n>)
     Imprime <expr_1>, ..., <expr_n>, então lê uma expressão do console
     e retorna a expressão (sem avaliação).  A expressão é terminada
     com um `;' (ponto e vírgula) ou `$' (sinal de dólar).

          (%i1) aa: 7$
          (%i2) foo: readonly ("Forneça uma expressão:");
          Enter an expressão:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Forneça uma expressão:");
          Enter an expressão:
          2^aa;
          (%o3)                            128

     Veja também `read'.


 -- Função: reveal (<expr>, <depth>)
     Substitue partes de <expr> no inteiro especificado <depth> com
     sumário descritivo.

        * Somas e diferenças são substituídas por `sum(<n>)' onde <n> é
          o número de operandos do produto.

        * Produtos são substituídos por `product(<n>)' onde <n> é o
          número de operandos da multiplicação.

        * Exponenciais são substituídos por `expt'.

        * Quocientes são substituídos por `quotient'.

        * Negação unária é substituída por `negterm'.

     Quando <depth> é maior que ou igual à máxima intensidade de <expr>,
     `reveal (<expr>, <depth>)' retornam <expr> sem modificações.

     `reveal' avalia seus argumentos.  `reveal' retorna expressão
     sumarizada.

     Exemplo:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       quotient
          (%i3) reveal (e, 2);
                                       sum(3)
          (%o3)                        ------
                                       sum(3)
          (%i4) reveal (e, 3);
                               expt + negterm + expt
          (%o4)               ------------------------
                              product(2) + expt + expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - product(3) + a
          (%o5)         ------------------------------------
                                   product(2)     product(2)
                        2 expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Variável de opção: rmxchar
     Valor padrão: `]'

     `rmxchar' é the caractere desenhado lado direito de uma matriz.

     Veja também `lmxchar'.


 -- Função: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Função: save (<filename>, values, functions, labels, ...)
 -- Função: save (<filename>, [<m>, <n>])
 -- Função: save (<filename>, <name_1>=<expr_1>, ...)
 -- Função: save (<filename>, all)
     Armazena os valores correntes de <name_1>, <name_2>, <name_3>,
     ..., em <filename>.  Os argumentos são os nomes das variáveis,
     funções, ou outros objetos.  Se um nome não possui valore ou
     função associada a ele, esse nome sem nenhum valor ou função
     associado será ignorado.  `save' retorna <filename>.

     `save' armazena dados na forma de expressões Lisp.  Os dados
     armazenados por `save' podem ser recuperados por `load
     (<filename>)'.

     O sinalizador global `file_output_append' governa se `save' anexa
     ao final ou trunca o arquivo de saída.  Quando
     `file_output_append' for `true', `save' anexa ao final doarquivo
     de saída.  De outra forma, `save' trunca o arquivo de saída.
     Nesse caso, `save' cria o arquivo se ele não existir ainda.

     A forma especial `save (<filename>, values, functions, labels,
     ...)'  armazena os ítens nomeados por `values', `funções',
     `labels', etc.  Os nomes podem ser quaisquer especificados pela
     variável `infolists'.  `values' compreende todas as variáveis
     definidas pelo usuário.

     A forma especial `save (<filename>, [<m>, <n>])' armazena os
     valores de rótulos de entrada e saída de <m> até <n>.  Note que
     <m> e <n> devem obrigatóriamente ser inteiros literais ou símbolos
     envolvidos por aspas duplas.  Rótulos de entrada e saída podem
     também ser armazenados um a um, e.g., `save ("foo.1", %i42, %o42)'.
     `save (<filename>, labels)' armazena todos os rótulos de entrada e
     saída.  Quando rótulos armazenados são recuperados, eles
     substituem rótulos existentes.

     A forma especial `save (<filename>, <name_1>=<expr_1>,
     <name_2>=<expr_2>, ...)' armazena os valores de <expr_1>,
     <expr_2>, ..., com nomes <name_1>, <name_2>, ....  Isso é útil
     para aplicar essa forma para rótulos de entrada e saída, e.g.,
     `save ("foo.1", aa=%o88)'.  O lado direito dessa igualdade nessa
     forma pode ser qualquer expressão, que é avaliada.  Essa forma não
     introduz os novos nomes no ambiente corrente do Maxima, mas
     somente armazena-os em <filename>.

     Essa forma especial e a forma geral de `save' podem ser misturados.
     Por exemplo, `save (<filename>, aa, bb, cc=42, funções, [11, 17])'.

     A forma especial `save (<filename>, all)' armazena o estado
     corrente do Maxima.  Isso inclui todas as variáveis definidas pelo
     usuário, funções, arrays, etc., bem como alguns ítens definidos
     automaticamente.  Os ítes salvos incluem variáveis de sistema,
     tais como `file_search_maxima' ou `showtime', se a elas tiverem
     sido atribuídos novos valores pelo usuário; veja `myoptions'.

     `save' avalia seus argumentos.  <filename> deve obrigatóriamente
     ser uma seqüência de caracteres, não uma variável tipo seqüência
     de caracteres.  O primeiro e o último rótulos a salvar, se
     especificado, devem obrigatóriamente serem inteiros.  O operador
     aspas duplas avalia uma variável tipo seqüência de caracteres para
     seu valor seqüência de caracteres, e.g., `s: "foo.1"$ save (''s,
     all)$', e variáveis inteiras para seus valores inteiros, e.g., `m:
     5$ n: 12$ save ("foo.1", [''m, ''n])$'.


 -- Variável de opção: savedef
     Valor padrão: `true'

     Quando `savedef' é `true', a vesão Maxima de uma função de usuário
     é preservada quando a função é traduzida.  Isso permite que a
     definição seja mostrada por `dispfun' e autoriza a função a ser
     editada.

     Quando `savedef' é `false', os nomes de funções traduzidas são
     removidos da lista de `funções'.


 -- Função: show (<expr>)
     Mostra `expr' com os objetos indexados tendo índices covariantes
     como subscritos, índices contravariantes como sobrescritos.  Os
     índices derivativos são mostrados como subscritos, separados dos
     índices covariantes por uma vírgula.


 -- Função: showratvars (<expr>)
     Retorna uma lista de variáveis expressão racional canônica (CRE)
     na expressão `expr'.

     Veja também `ratvars'.


 -- Variável de opção: stardisp
     Valor padrão: `false'

     Quando `stardisp' é `true', multiplicação é mostrada com um
     asterisco `*' entre os operandos.


 -- Função: string (<expr>)
     Converte `expr' para a notação linear do Maxima apenas como se
     tivesse sido digitada.

     O valor de retorno de `string' é uma seqüência de caracteres, e
     dessa forma não pode ser usada em um cálculo.


 -- Variável Lisp: stringdisp
     Valor padrão: `false'

     Quando `?stringdisp' for `true', seqüências de caracteres serão
     mostradas contidas em aspas duplas.  De outra forma, aspas não são
     mostradas.

     `?stringdisp' é sempre `true' quando mostrando uma definição de
     função.

     `?stringdisp' é uma variável Lisp, então deve ser escrita com um
     ponto de interrogação `?' na frente.

     Exemplos:

          (%i1) ?stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () := print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) ?stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


 -- Função: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Função: stringout (<filename>, [<m>, <n>])
 -- Função: stringout (<filename>, input)
 -- Função: stringout (<filename>, functions)
 -- Função: stringout (<filename>, values)
     `stringout' escreve expressões para um arquivo na mesma forma de
     expressões que foram digitadas para entrada.  O arquivo pode então
     ser usado como entrada para comandos `batch' ou `demo', e isso
     pode ser editado para qualquer propósito.  `stringout' pode ser
     executado enquanto `writefile' está em progresso.

     O sinalizador global `file_output_append' governa se `stringout'
     anexa ao final ou trunca o arquivo de saída.  Quando
     `file_output_append' for `true', `stringout' anexa ao final do
     arquivo de sad'a.  De outra forma, `stringout' trunca o arquivo de
     saída.  Nesse caso, `stringout' cria o arquivo de saída se ele não
     existir ainda.

     A forma geral de `stringout' escreve os valores de um ou mais
     expressões para o arquivo de saída.  Note que se uma expressão é
     uma variável, somente o valor da variável é escrito e não o nome
     da variável.  Como um útil caso especial, as expressões podem ser
     rótulos de entrada (`%i1', `%i2', `%i3', ...) ou rótulos de saída
     (`%o1', `%o2', `%o3', ...).

     Se `grind' é `true', `stringout' formata a saída usando o formato
     `grind'.  De outra forma o formato `string' é usado.  Veja `grind'
     e `string'.

     A forma especial `stringout (<filename>, [<m>, <n>])' escreve os
     valores dos rótulos de entrada de m até n, inclusive.

     A forma especial `stringout (<filename>, input)' escreve todos os
     rótulos de entrada para o arquivo.

     A forma especial `stringout (<filename>, functions)' escreve todas
     as funções definidas pelo usuário (nomeadas pela lista global
     `functions') para o arquivo.

     A forma especial `stringout (<filename>, values)' escreve todas as
     variáveis atribuídas pelo usuário (nomeadas pela lista global
     `values') para o arquivo.  Cada variável é impressa como uma
     declaração de atribuição, com o nome da variável seguida de dois
     pontos, e seu valor.  Note que a forma geral de `stringout' não
     imprime variáveis como declarações de atribuição.


 -- Função: tex (<expr>)
 -- Função: tex (<rótulo>)
 -- Função: tex (<expr>, <momearquivo>)
 -- Função: tex (<label>, <nomearquivo>)
     Imprime uma representação de uma expressão adequada para o sistema
     TeX  de preparação de documento.  O resultado é um fragmento de um
     documento, que pode ser copiado dentro de um documento maior.
     Esse fragmento não pode ser processado de forma direta e isolada.

     `tex (<expr>)' imprime uma representação TeX da <expr> no console.

     `tex (<rótulo>)' imprime uma representação TeX de uma expressão
     chamada <rótulo> e atribui a essa um rótulo de equação (a ser
     mostrado à esquerda da expressão).  O rótulo de equação TeX é o
     mesmo que o rótulo da equação no Maxima.

     `tex (<expr>, <nomearquivo>)' anexa ao final uma representação TeX
     de <expr> no arquivo <nomearquivo>.  `tex' não avalia o argumento
     <nomearquivo>; apóstrofo-apóstrofo `''' força a avaliação so
     argumento.

     `tex (<rótulo>, <nomearquivo>)' anexa ao final uma representação
     TeX da expressão chamada de <rótulo>, com um rótulo de equação, ao
     arquivo <nomearquivo>.

     `tex' não avalia o argumento <nomearquivo>; apóstrofo-apóstrofo
     `''' força a avaliação so argumento.  `tex' avalia seus argumentos
     após testar esse argumento para ver se é um rótulo.  duplo
     apóstrofo `''' força a avaliação do argumento, desse modo
     frustrando o teste e prevenindo o rótulo.

     Veja também `texput'.

     Exemplos:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)


 -- Função: texput (<a>, <s>)
 -- Função: texput (<a>, <s>, <operator_type>)
 -- Função: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Função: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Escolhe a saída TeX para o átomo <a>, que pode ser um símbolo ou o
     nome de um operador.

     `texput (<a>, <s>)' faz com que a função `tex' interpole a
     seqüência de caracteres <s> dentro da saída TeX em lugar de <a>.

     `texput (<a>, <s>, <operator_type>)', onde <operator_type> é
     `prefix', `infix', ou `postfix' faz com que a função `tex'
     interpole <s> dentro da saída TeX em lugar de <a>, e coloca o
     texto interpolado na posição apropriada.

     `texput (<a>, [<s_1>, <s_2>], matchfix)' faz com que a função
     `tex' interpole <s_1> e <s_2> dentro da saída TeX sobre qualquer
     lado dos argumentos de <a>.  Os argumentos (se mais de um) são
     separados por vírgulas.

     `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' faz com que a
     função `tex' interpole <s_1> e <s_2> dentro da saída TeX sobre
     qualquer lado dos argumentos de <a>, com <s_3> separando os
     argumentos.

     Exemplos:

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false
          (%i3) texput (lcm, "\\mathrm{lcm}");
          (%o3)                     \mathrm{lcm}
          (%i4) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o4)                         false
          (%i5) prefix ("grad");
          (%o5)                         grad
          (%i6) texput ("grad", " \\nabla ", prefix);
          (%o6)                          180
          (%i7) tex (grad f);
          $$ \nabla f$$
          (%o7)                         false
          (%i8) infix ("~");
          (%o8)                           ~
          (%i9) texput ("~", " \\times ", infix);
          (%o9)                          180
          (%i10) tex (a ~ b);
          $$a \times b$$
          (%o10)                        false
          (%i11) postfix ("@");
          (%o11)                          @
          (%i12) texput ("@", "!!", postfix);
          (%o12)                         160
          (%i13) tex (x @);
          $$x!!$$
          (%o13)                        false
          (%i14) matchfix ("<<", ">>");
          (%o14)                         <<
          (%i15) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o15)              \langle ( \rangle , false)
          (%i16) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o16)                        false
          (%i17) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o17)                        false
          (%i18) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], matchfix);
          (%o18)            \langle ( \rangle ,  \, | \,)
          (%i19) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o19)                        false
          (%i20) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o20)                        false


 -- Função: system (<comando>)
     Executa <comando> como um processo separado.  O comando é passado
     ao shell padraõ para execução.  `system' não é suportado por todos
     os sistemas operacionais, mas geralmente existe em ambientes Unix
     e Unix-like.

     Supondo que `_hist.out' é uma lista de freqüência que você deseja
     imprimir como um gráfico em barras usando `xgraph'.

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     Com o objetivo de fazer com que a impressão do gráfico seja
     concluída em segundo plano (retornando o controle para o Maxima) e
     remover o arquivo temporário após isso ter sido concluído faça:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")


 -- Variável de opção: ttyoff
     Valor padrão: `false'

     Quando `ttyoff' é `true', expressões de saída não são mostradas.
     Expressões de saída são ainda calculadas e atribuídas rótulos.
     Veja `labels'.

     Textos impresso por funções internas do Maxima, tais como
     mensagens de erro e a saída de `describe', não são afetadas por
     `ttyoff'.


 -- Função: with_stdout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
     Abre <filename> e então avalia <expr_1>, <expr_2>, <expr_3>, ....
     Os valores dos argumentos não são armazenados em <filename>, mas
     qualquer saída impressa gerada pela avaliação dos argumentos (de
     `print', `display', `disp', ou `grind', por exemplo) vai para
     <filename> em lugar do console.

     O sinalizador global `file_output_append' governa se `with_stdout'
     anexa ao final ou trunca o arquivo de saída.  Quando
     `file_output_append' for `true', `with_stdout' anexa ao final do
     arquivo de saída.  De outra forma, `with_stdout' trunca o arquivo
     de saída.  Nesse caso, `with_stdout' cria o arquivo se ele não
     existir ainda.

     `with_stdout' retorna o valor do seu argumento final.

     Veja também `writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Função: writefile (<filename>)
     Começa escrevendo uma transcrição da sessão Maxima para <filename>.
     Toda interação entre o usuário e Maxima é então gravada nesse
     arquivo, da mesma forma que aparece no console.

     Como a transcrição é impressa no formato de saída do console, isso
     não pode ser reaproveitado pelo Maxima.  Para fazer um arquivo
     contendo expressões que podem ser reaproveitadas, veja `save' e
     `stringout'.  `save' armazena expressões no formato Lisp, enquanto
     `stringout' armazena expressões no formato Maxima.

     O efeito de executar `writefile' quando <filename> ainda existe
     depende da implementação Lisp subjacente; o arquivo transcrito
     pode ser substituído, ou o arquivo pode receber um anexo.
     `appendfile' sempre anexa para o arquivo transcrito.

     Isso pode ser conveniente para executar `playback' após
     `writefile' para salvar a visualização de interações prévias.
     Como `playback' mostra somente as variáveis de entrada e saída
     (`%i1', `%o1', etc.), qualquer saída gerada por uma declaração de
     impressão em uma função (como oposição a um valor de retorno) não
     é mostrada por `playback'.

     `closefile' fecha o arquivo transcrito aberto por `writefile' ou
     `appendfile'.



File: maxima.info,  Node: Ponto Flutuante,  Next: Contextos,  Prev: Entrada e Saída,  Up: Top

10 Ponto Flutuante
******************

* Menu:

* Definições para ponto Flutuante::


File: maxima.info,  Node: Definições para ponto Flutuante,  Prev: Ponto Flutuante,  Up: Ponto Flutuante

10.1 Definições para ponto Flutuante
====================================

 -- Função: bffac (<expr>, <n>)
     Versão para grandes números em ponto flutuante da função
     `factorial' (usa o artifício gamma).  O segundo argumento informa
     quantos dígitos reter e retornar, isso é uma boa idéia para
     requisitar precisão adicional.

     `load ("bffac")' chama essa função.


 -- Variável de Opção: algepsilon
     Valor padrão: 10^8

     `algepsilon' é usada por `algsys'.


 -- Função: bfloat (<expr>)
     Converte todos os números e funções de números em <expr> para
     grandes números em ponto flutuante (bigfloat).  O número de
     algarismos significativos no grande número em ponto flutuante
     resultante é especificado através da variável global `fpprec'.

     Quando `float2bf' for `false' uma mensagem de alerta é mostrada
     quando uma número em ponto flutuante (float) é convertido em um
     grande número em ponto flutuante (bigfloat - uma vez que isso pode
     resultar em perda de precisão).


 -- Função: bfloatp (<expr>)
     Retorna `true' se a avaliação da <expr> resultar em um grande
     número em ponto flutuante, de outra forma retorna `false'.


 -- Função: bfpsi (<n>, <z>, <fpprec>)
 -- Função: bfpsi0 (<z>, <fpprec>)
     `bfpsi' é a função `polygamma' de argumentos reais <z> e ordem de
     inteiro <n>.  `bfpsi0' é a função `digamma'.  `bfpsi0 (<z>,
     <fpprec>)' é equivalente a `bfpsi (0, <z>, <fpprec>)'.

     Essas funções retornam valores em grandes números em ponto
     flutuante.  <fpprec> é a precisão do valor de retorno dos grandes
     números em ponto flutuante.

     `load ("bffac")' chama essas funções.


 -- Variável de Opção: bftorat
     Valor padrão: `false'

     `bftorat' controla a conversão de `bfloats' para números racionais.
     Quando `bftorat' for `false', `ratepsilon' será usada para
     controlar a conversão (isso resulta em números racionais
     relativametne pequenos).  Quando `bftorat' for `true', o número
     racional gerado irá representar precisamente o `bfloat'.


 -- Variável de Opção: bftrunc
     Valor padrão: `true'

     `bftrunc' faz com que tilhas de zeros em grandes números em ponto
     flutuante diferentes de zero sejam ocultadas.  Desse modo, se
     `bftrunc' for `false', `bfloat (1)' será mostrado como
     `1.000000000000000B0'. De outra forma, será mostrado como `1.0B0'.


 -- Função: cbffac (<z>, <fpprec>)
     Fatorial complexo de grandes números em ponto flutuante.

     `load ("bffac")' chama essa função.


 -- Função: float (<expr>)
     Converte inteiros, números racionais e grandes números em ponto
     flutuante em <expr> para números em ponto flutuante.  Da mesma
     forma um `evflag', `float' faz com que números racionais
     não-inteiros e grandes números em ponto flutuante sejam
     convertidos para ponto flutuante.


 -- Variável de Opção: float2bf
     Valor padrão: `false'

     Quando `float2bf' for `false', uma mensagem de alerta é mostrada
     quando um número em ponto flutuante é convertido em um grande
     número em ponto flutuante (uma vez que isso pode resultar em perda
     de precisão).


 -- Função: floatnump (<expr>)
     Retorna `true' se <expr> for um número em ponto flutuante, de
     outra forma retorna `false'.


 -- Variável de Opção: fpprec
     Valor padrão: 16

     `fpprec' é o número de algarismos significativos para aritmética
     sobre grandes números em ponto flutuante `fpprec' não afeta
     cálculos sobre números em ponto flutuante comuns.

     Veja também `bfloat' e `fpprintprec'.


 -- Variável de Opção: fpprintprec
     Valor padrão: 0

     `fpprintprec' é o número de dígitos para impressão quando
     imprimindo um grande número em ponto flutuante, tornando possível
     calcular com grande número de dígitos de precisão, mas ter na
     resposta impressa com um pequeno número de dígitos.

     Quando `fpprintprec' for 0, ou maior que ou igual a `fpprec',
     então o valor de `fpprec' controla o número de dígitos usado para
     imprimir.

     Quando `fpprintprec' tem um valor entre 2 e `fpprec - 1', então
     `fpprintprec' controla o número de dígitos usado.  (O menor número
     de dígitos usado é 2, um do lado esquerdo do ponto e um do lado
     direito.

     O valor 1 para `fpprintprec' é ilegal.


 -- Função Lisp: ?round (<x>)
 -- Função Lisp: ?round (<x>, <divisor>)
     Arredonda o ponto flutuante <x> para o inteiro mais próximo.   O
     argumento obrigatoriamente deve ser um ponto flutuante comum, não
     um grandes números em ponto flutuante.   A `?' começando o nome
     indica que isso é uma função Lisp.

          (%i1) ?round (-2.8);
          (%o1)                            - 3


 -- Função Lisp: ?truncate (<x>)
 -- Função Lisp: ?truncate (<x>, <divisor>)
     Trunca o ponto flutuante <x> na direção do 0, para transormar-se
     em um inteiro.   O argumento deve ser um número em ponto flutuante
     comum, não um grandes números em ponto flutuante.  A `?'
     começando o nome indica que isso é uma função Lisp.

          (%i1) ?truncate (-2.8);
          (%o1)                            - 2
          (%i2) ?truncate (2.4);
          (%o2)                             2
          (%i3) ?truncate (2.8);
          (%o3)                             2



File: maxima.info,  Node: Contextos,  Next: Polinômios,  Prev: Ponto Flutuante,  Up: Top

11 Contextos
************

* Menu:

* Definições para Contextos::



Local Variables:
coding: iso-8859-1
End:
