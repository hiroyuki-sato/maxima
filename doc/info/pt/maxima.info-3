This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para Equações,  Prev: Equações,  Up: Equações

21.1 Definições para Equações
=============================

 -- Variável: %rnum_list
     Valor padrão: `[]'

     `%rnum_list' é a lista de variáveis introduzidas em soluções por
     `algsys'.  `%r' variáveis São adicionadas a `%rnum_list' na ordem
     em que forem criadas.  Isso é conveniente para fazer substituições
     dentro da solução mais tarde.  É recomendado usar essa lista em
     lugar de fazer `concat ('%r, j)'.


 -- Variável: algexact
     Valor padrão: `false'

     `algexact' afeta o comportamento de `algsys' como segue:

     Se `algexact' é `true', `algsys' sempre chama `solve' e então usa
     `realroots' sobre falhas de `solve'.

     Se `algexact' é `false', `solve' é chamada somente se o eliminante
     não for de uma variável, ou se for uma quadrática ou uma
     biquadrada.

     Dessa forma `algexact: true' não garante soluções exatas, apenas
     que `algsys' tentará primeiro pegar soluções exatas, e somente
     retorna aproximações quando tudo mais falha.


 -- Função: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Função: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resolve polinômios simultâneos <expr_1>, ..., <expr_m> ou equações
     polinômiais <eqn_1>, ..., <eqn_m> para as variáveis <x_1>, ...,
     <x_n>.  Uma expressão <expr> é equivalente a uma equação `<expr> =
     0'.  Pode existir mais equações que variáveis ou vice-versa.

     `algsys' retorna uma lista de soluções, com cada solução dada com
     uma lista de valores de estado das equações das variáveis <x_1>,
     ..., <x_n> que satisfazem o sistema de equações.  Se `algsys' não
     pode achar uma solução, uma lista vazia `[]' é retornada.

     Os símbolos `%r1', `%r2', ..., são introduzidos tantos quantos
     forem necessários para representar parâmetros arbitrários na
     solução; essas variáveis são também anexadas à lista `%rnum_list'.

     O método usado é o seguinte:

     (1) Primeiro as equações são fatoradas e quebradas em subsistemas.

     (2) Para cada subsistema <S_i>, uma equação <E> e uma variável <x>
     são selecionados.  A variável é escolhida para ter o menor grau
     não zero.  Então a resultante de <E> e <E_j> em relação a <x> é
     calculada para cada um das equações restantes <E_j> nos
     subsistemas <S_i>.  Isso retorna um novo subsistema <S_i'> em umas
     poucas variáveis, como <x> tenha sido eliminada.  O processo agora
     retorna ao passo (1).

     (3) Eventualmente, um subsistema consistindo de uma equação
     simples é obtido.  Se a equação é de várias variáveis e
     aproximações na forma de números em ponto flutuante nã tenham sido
     introduzidas, então `solve' é chamada para achar uma solução exata.

     Em alguns casos, `solve' não está habilitada a achar uma solução,
     ou se isso é feito a solução pode ser uma expressão expressão
     muito larga.

     Se a equação é de uma única variável e é ou linear, ou quadrática,
     ou biquadrada, então novamente `solve' é chamada se aproximações
     não tiverem sido introduzidas.  Se aproximações tiverem sido
     introduzidas ou a equação não é de uma única variável e nem tão
     pouco linear, quadratica, ou biquadrada, então o comutador
     `realonly' é `true', A função `realroots' é chamada para achar o
     valor real das soluções.  Se `realonly' é `false', então
     `allroots' é chamada a qual procura por soluções reais e complexas.

     Se `algsys' produz uma solução que tem poucos digitos
     significativos que o requerido, o usuário pode escolher o valor de
     `algepsilon' para um valor maior.

     Se `algexact' é escolhido para `true', `solve' será sempre chamada.

     (4) Finalmente, as soluções obtidas no passo (3) são substituídas
     dentro dos níveis prévios e o processo de solução retorna para (1).

     Quando `algsys' encontrar uma equação de várias variáveis que
     contém aproximações em ponto flutuante (usualmente devido a suas
     falhas em achar soluções exatas por um estágio mais fácil), então
     não tentará aplicar métodos exatos para tais equações e em lugar
     disso imprime a mensagem: "`algsys' cannot solve - system too
     complicated."

     Interações com `radcan' podem produzir expressões largas ou
     complicadas.  Naquele caso, pode ser possível isolar partes do
     resultado com `pickapart' ou `reveal'.

     Ocasionalmente, `radcan' pode introduzir uma unidade imaginária
     `%i' dentro de uma solução que é atualmente avaliada como real.

     Exemplos:

     ++
          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Função: allroots (<expr>)
 -- Função: allroots (<eqn>)
     Calcula aproximações numéricas de raízes reais e complexas do
     polinômio <expr> ou equação polinômial <eqn> de uma variável.

     O sinalizador `polyfactor' quando `true' faz com que `allroots'
     fatore o polinômio sobre os números reais se o polinômio for real,
     ou sobre os números complexos, se o polinômio for complexo.

     `allroots' pode retornar resultados imprecisos no caso de
     multiplas raízes.  Se o polinômio for real, `allroots (%i*<p>)')
     pode retornar aproximações mais precisas que `allroots (<p>)',
     como `allroots' invoca um algorítmo diferente naquele caso.

     `allroots' rejeita não-polinômios.  Isso requer que o numerador
     após a classificação (`rat''ing) poderá ser um polinômio, e isso
     requer que o denominador seja quando muito um número complexo.
     Com um resultado disso `allroots' irá sempre retornar uma
     expressão equivalente (mas fatorada), se `polyfactor' for `true'.

     Para polinômios complexos um algorítmo por Jenkins and Traub é
     usado (Algorithm 419, Comm.  ACM, vol.  15, (1972), p.  97).  Para
     polinômios reais o algorítmo usado é devido a Jenkins (Algorithm
     493, ACM TOMS, vol.  1, (1975), p.178).

     Exemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Variável: backsubst
     Valor padrão: `true'

     Quando `backsubst' é `false', evita substituições em expressões
     anteriores após as equações terem sido triangularizadas.  Isso pode
     ser de grande ajuda em problemas muito grandes onde substituição
     em expressões anteriores pode vir a causar a geração de expressões
     extremamente largas.


 -- Variável: breakup
     Valor padrão: `true'

     Quando `breakup' é `true', `solve' expressa soluções de equações
     cúbicas e quárticas em termos de subexpressões comuns, que são
     atribuídas a rótulos de expressões intermediárias (`%t1', `%t2',
     etc.).  De outra forma, subexpressões comuns não são identificadas.

     `breakup: true' tem efeito somente quando `programmode' é `false'.

     Exemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Função: dimension (<eqn>)
 -- Função: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' é um pacote de análise dimensional.  `load ("dimen")'
     chama esse pacote.  `demo ("dimen")' mostra uma cura demostração.


 -- Variável: dispflag
     Valor padrão: `true'

     Se escolhida para `false' dentro de um `block' inibirá a
     visualização da saída gerada pelas funções solve chamadas de
     dentro de `block'.  Terminando `block' com um sinal de dolar, $,
     escolhe `dispflag' para `false'.


 -- Função: funcsolve (<eqn>, <g>(<t>))
     Retorna `[<g>(<t>) = ...]'  ou `[]', dependendo de existir ou não
     uma função racional `<g>(<t>)' satisfazendo <eqn>, que deve ser de
     primeira ordem, polinômio linear em (para esse caso) `<g>(<t>)'
     and `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Equações dependentes eliminadas:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Atenção: essa é uma implementação muito rudimentar - muitas
     verificações de segurança e obviamente generalizações estão
     ausêntes.


 -- Variável: globalsolve
     Valor padrão: `false'

     When `globalsolve' for `true', variáveis para as quais as equações
     são resolvidas são atribuidas aos valores da solução encontrados
     por `linsolve', e por `solve' quando resolvendo duas ou mais
     equações lineares.  Quando `globalsolve' for `false', soluções
     encontradas por `linsolve' e por `solve' quando resolvendo duas ou
     mais equações lineares são espressas como equações, e as variáveis
     para as quais a equação foi resolvida não são atribuidas.

     Quando resolvendo qualquer coisa outra que não duas equações
     lineares ou mais, `solve' ignora `globalsolve'.  Outras funções
     que resolvem equações (e.g., `algsys') sempre ignoram
     `globalsolve'.

     Exemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Função: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' é um pacote para resolver equações integrais.  `load
     ("inteqn")' carrega esse pacote.

     <ie> é a equação integral; <unk> é a função desconhecida; <tech> é
     a técnica a ser tentada nesses dados acima (<tech> = `first'
     significa: tente a primeira técnica que achar uma solução; <tech>
     = `all' significa: tente todas a técnicas aplicáveis); <n> é o
     número máximo de termos a serem usados de `taylor', `neumann',
     `firstkindseries', ou `fredseries' (isso é também o número máximo
     de ciclos de recurssão para o método de diferenciação); <guess> é
     o inicial suposto para `neumann' ou `firstkindseries'.

     Valores padrão do segundo até o quinto parâmetro são:

     <unk>: `<p>(<x>)', onde <p> é a primeira função encontrada em um
     integrando que é desconhecida para Maxima e <x> é a variável que
     ocorre como um argumento para a primeira ocorrência de <p> achada
     fora de uma integral no caso de equações `secondkind' , ou é
     somente outra variável ao lado da variável de integração em
     equações `firstkind'.  Se uma tentativa de procurar por <x> falha,
     o usuário será perguntado para suprir a variável independente.

     tech: `first'

     n: 1

     guess: `none' o que fará com que `neumann' e `firstkindseries' use
     `<f>(<x>)' como uma suposição inicial.


 -- Variável de opção: ieqnprint
     Valor padrão: `true'

     `ieqnprint' governa o comportamento do resultado retornado pelo
     comando `ieqn'.  Quando `ieqnprint' é `false', as listas
     retornadas pela função `ieqn' são da forma

     [<solução>, <tecnica usada>, <nterms>, <sinalizador>]

     onde <sinalizador> é retirado se a solução for exata.

     De outra forma, isso é a palavra `approximate' ou `incomplete'
     correspondendo à forma inexata ou forma aberta de solução,
     respectivamente.  Se um método de série foi usado, <nterms>
     fornece o número de termos usados (que poderá ser menor que os n
     dados para `ieqn' se ocorrer um erro evita a geração de termos
     adicionais).


 -- Função: lhs (<expr>)
     Retorna o lado esquerdo (isto é, o primeiro argumento) da
     expressão <expr>, quando o operador de <expr> for um dos
     operadores relacionais `< <= = # equal notequal >= >', um dos
     operadores de atribuição `:= ::= : ::', ou um operadro infixo
     definido pelo usuário, como declarado por meio de `infix'.

     Quando <expr> for um átomo ou seu operador for alguma coisa que
     não esses listados acima, `lhs' retorna <expr>.

     Veja também `rhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Função: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resolve a lista de equações lineares simultâneas para a lista de
     variáveis.  As expressões devem ser cada uma polinômios nas
     variáveis e podem ser equações.

     Quando `globalsolve' é `true' então variáveis que foram resolvidas
     serão escolhidas para a solução do conjunto de equações
     simultâneas.

     Quando `backsubst' é `false', `linsolve' não realiza substituição
     em equações anteriores após as equações terem sido
     triangularizadas.  Isso pode ser necessário em problemas muito
     grandes onde substituição em equações anteriores poderá causar a
     geração de expressões extremamente largas.

     Quando `linsolve_params' é `true', `linsolve' também gera símbolos
     `%r' usados para representar parâmetros arbitrários descritos no
     manual sob `algsys'.  De outra forma, `linsolve' resolve um
     menor-determinado sistema de equações com algumas variáveis
     expressas em termos de outras.

          (%i1) e1: x + z = y$
          (%i2) e2: 2*a*x - y = 2*a^2$
          (%i3) e3: y - 2*z = 2$
          (%i4) linsolve ([e1, e2, e3], [x, y, z]);
          (%o4)            [x = a + 1, y = 2 a, z = a - 1]


 -- Variável: linsolvewarn
     Valor padrão: `true'

     Quando `linsolvewarn' é `true', `linsolve' imprime uma mensagem
     "Dependent equações eliminated".


 -- Variável: linsolve_params
     Valor padrão: `true'

     Quando `linsolve_params' é `true', `linsolve' também gera os
     símbolos `%r' usados para representar parâmetros arbitrários
     descritos no manual sob `algsys'.  De outra forma, `linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos e outras.


 -- Variável: multiplicities
     Valor padrão: `not_set_yet'

     `multiplicities' é escolhida para uma lista de multiplicidades das
     soluções individuais retornadas por `solve' ou `realroots'.


 -- Função: nroots (<p>, <low>, <high>)
     Retorna o número de raízes reais do polinômio real de uma única
     variável <p> no intervalo semi-aberto `(<low>, <high>]'.  Uma
     extremidade do intervalo podem ser `minf' ou `inf'.  infinito e
     mais infinito.

     `nroots' usa o método das sequüências de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Função: nthroot (<p>, <n>)
     Onde p é um polinômio com coeficientes inteiros e n é um inteiro
     positivo retorna q, um polinômio sobre os inteiros, tal que q^n=p
     ou imprime uma mensagem de erro indicando que p não é uma potência
     n-ésima perfeita.  Essa rotina é mais rápida que `factor' ou mesmo
     `sqfr'.


 -- Variável: programmode
     Valor padrão: `true'

     Quando `programmode' é `true', `solve', `realroots', `allroots', e
     `linsolve' retornam soluções como elementos em uma lista.  (Exceto
     quando `backsubst' é escolhido para `false', nesse caso
     `programmode: false' é assumido.)

     Quando `programmode' é `false', `solve', etc.  cria rótulos de
     expressões intermediárias `%t1', `t2', etc., e atribui as soluções
     para eles.


 -- Variável: realonly
     Valor padrão: `false'

     Quando `realonly' é `true', `algsys' retorna somente aquelas
     soluções que estão livres de `%i'.


 -- Função: realroots (<poly>, <bound>)
     Acha todas as raízes reais de um polinômio também real de uma
     única variável poly dentro de uma tolerância de limite que, se
     menor que 1, faz com que todas as raízes da integral sejam achadas
     exatamente.  O parâmetro limite pode ser arbitrariamente pequeno
     com o objetivo de encontrar qualquer precisão desejada.  O
     primeiro argumento pode também ser uma equação.  `realroots'
     escolhe `multiplicities', útil em caso de multiplas raízes.
     `realroots (<p>)' é equivalente a `realroots (<p>, rootsepsilon)'.
     `rootsepsilon' é um número real usado para estabelecer um
     intervalo de confidência para as ra@'izes.  Faça `example
     (realroots)' para um exemplo.


 -- Função: rhs (<expr>)
     Retorna o lado direito (isto é, o segundo argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais `< <= = # equal notequal >= >', um dos operadores de
     atribuição `:= ::= : ::', ou um operador binário infixo definido
     pelo usuário, como declarado por meio de `infix'.

     Quando <expr> for um étomo ou seu operadro for alguma coisa que
     não esses listados acima, `rhs' retorna 0.

     Veja também `lhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Variável de opção: rootsconmode
     Valor padrão: `true'

     `rootsconmode' governa o comportamento do comando `rootscontract'.
     Veja `rootscontract' para detalhes.


 -- Função: rootscontract (<expr>)
     Converte produtos de raízes em raízes de produtos.  Por exemplo,
     `rootscontract (sqrt(x)*y^(3/2))' retorna `sqrt(x*y^3)'.

     Quando `radexpand' é `true' e `domain' é `real', `rootscontract'
     converte `abs' em `sqrt', e.g., `rootscontract (abs(x)*sqrt(y))'
     retorna `sqrt(x^2*y)'.

     Existe uma opção `rootsconmode' afetando `rootscontract' como
     segue:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Quando `rootsconmode' é `false', `rootscontract' contrai somente
     como relação a expoentes de número racional cujos denominadores
     são os mesmos.  A chave para os exemplos `rootsconmode: true' é
     simplesmente que 2 divides 4 mas não divide 3.  `rootsconmode:
     all' envolve pegar o menor multiplo comum dos denominadores dos
     expoentes.

     `rootscontract' usa `ratsimp' em uma maneira similar a
     `logcontract'.

     Exemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Variável de opção: rootsepsilon
     Valor padrão: 1.0e-7

     `rootsepsilon' é a tolerância que estabelece o intervalo de
     conficência para as raízes achadas pela função `realroots'.


 -- Função: solve (<expr>, <x>)
 -- Função: solve (<expr>)
 -- Função: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resolve a equação algébrica <expr> para a variável <x> e retorna
     uma lista de equações solução em <x>.  Se <expr> não é uma
     equação, a equação `<expr> = 0' é assumida em seu lugar.  <x> pode
     ser uma função (e.g. `f(x)'), ou outra expressão não atômica
     exceto uma adição ou um produto.  <x> pode ser omitido se <expr>
     contém somente uma variável.  <expr> pode ser uma expressão
     racional, e pode conter funções trigonométricas, exponenciais, etc.

     O seguinte método é usado:

     Tome <E> sendo a expressão e <X> sendo a variável.  Se <E> é
     linear em <X> então isso é trivialmente resolvido para <X>.  De
     outra forma se <E> é da forma `A*X^N + B' então o resultado é
     `(-B/A)^1/N)' vezes as `N''ésimas raízes da unidade.

     Se <E> não é linear em <X> então o máximo divisor comum (mdc) dos
     expoentes de <X> em <E> (digamos <N>) é dividido dentro dos
     expoentes e a multiplicidade das raízes é multiplicada por <N>.
     Então `solve' é chamada novamente sobre o resultado.  Se <E> for
     dada em fatores então `solve' é chamada sobre cada um dos fatores.
     Finalmente `solve' usará as fórmulas quadráticas, cúbicas, ou
     quárticas onde necessário.

     No caso onde <E> for um polinômio em alguma função de variável a
     ser resolvida, digamos `F(X)', então isso é primeiro resolvida
     para `F(X)' (chama o resultado <C>), então a equação `F(X)=C' pode
     ser resolvida para <X> fornecendo o inverso da função <F> que é
     conhecida.

     `breakup' se `false' fará com que `solve' expresse as soluções de
     equações cúbicas ou quárticas como expressões simples ao invés de
     como feito em cima de várias subexpressões comuns que é o padrão.

     `multiplicities' - será escolhido para uma lista de
     multiplicidades de soluções individuais retornadas por `solve',
     `realroots', ou `allroots'.  Tente `apropos (solve)' para os
     comutadores que afetam `solve'.  `describe' pode então ser usada
     sobre o nome do comutador individual se seu proprósito não é claro.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' resolve um
     sistema de equações polinomiais (lineares ou não-lineares)
     simultâneas por chamada a `linsolve' ou `algsys' e retorna uma
     lista de listas solução nas variáveis.  No caso de `linsolve' essa
     lista conterá uma lista simples de soluções.  Isso pega duas
     listas como argumentos.  A primeira lista representa as equações a
     serem resolvidas; a segunda lista é a lista de desconhecidos a ser
     determinada.  Se o número total de variáveis nas equações é igual
     ao número de equações, a segunda lista-argumento pode ser omitida.
     Para sistemas lineares se as dadas equações não são compatíveis,
     a mensagem `inconsistent' será mostrada (veja o comutador
     `solve_inconsistent_error' ); se não existe solução única, então
     `singular' será mostrado.

     Exemplos:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some soluções will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Variável de opção: solvedecomposes
     Valor padrão: `true'

     Quando `solvedecomposes' é `true', `solve' chama `polydecomp' se
     perguntado para resolver polinômios.


 -- Variável de opção: solveexplicit
     Valor padrão: `false'

     Quando `solveexplicit' é `true', inibe `solve' de retornar
     soluções implícitas, isto é, soluções da forma `F(x) = 0' onde `F'
     é alguma função.


 -- Variável de opção: solvefactors
     Valor padrão: `true'

     Quando `solvefactors' é `false', `solve' não tenta fatorar a
     expressão.  O `false' escolhido pode ser desejado em alguns casos
     onde a fatoração não é necessária.


 -- Variável de opção: solvenullwarn
     Valor padrão: `true'

     Quando `solvenullwarn' é `true', `solve' imprime uma mensagem de
     alerta se chamada com ou uma lista equação ou uma variável lista
     nula.  Por exemplo, `solve ([], [])' imprimirá duas mensagens de
     alerta e retorna `[]'.


 -- Variável de opção: solveradcan
     Valor padrão: `false'

     Quando `solveradcan' é `true', `solve' chama `radcan' que faz
     `solve' lento mas permitirá certamente que problemas contendo
     exponeniais e logarítmos sejam resolvidos.


 -- Variável de opção: solvetrigwarn
     Valor padrão: `true'

     Quando `solvetrigwarn' é `true', `solve' pode imprimir uma
     mensagem dizendo que está usando funções trigonométricas inversas
     para resolver a equação, e desse modo perdendo soluções.


 -- Variável de opção: solve_inconsistent_error
     Valor padrão: `true'

     Quando `solve_inconsistent_error' é `true', `solve' e `linsolve'
     resultam em erro se as equações a serem resolvidas são
     inconsistentes.

     Se `false', `solve' e `linsolve' retornam uma lista vazia `[]' se
     as equações forem inconsistentes.

     Exemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equações:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Equações Diferenciais,  Next: Numérico,  Prev: Equações,  Up: Top

22 Equações Diferenciais
************************

* Menu:

* Definições para Equações Diferenciais::


File: maxima.info,  Node: Definições para Equações Diferenciais,  Prev: Equações Diferenciais,  Up: Equações Diferenciais

22.1 Definições para Equações Diferenciais
==========================================

 -- Função: bc2 (<solução>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resolve problema do valor limite para equações diferenciais de
     segunda ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval1> é uma equação para a
     variável independente na forma `<x> = <x0>', e <yval1> é uma
     equação para a variável dependente na forma `<y> = <y0>'.  A
     <xval2> e a <yval2> são equações para essas variáveis em outro
     ponto.  Veja `ode2' para exemplo de utilização.


 -- Função: desolve (<eqn>, <x>)
 -- Função: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     A função `dsolve' resolve sistemas de equações diferenciais
     ordinárias lineares usando transformada de Laplace.  Aqui as
     <eqn>'s são equações diferenciais nas variáveis dependentes <x_1>,
     ..., <x_n>.  A relação funcional deve ser explicitamente indicada
     em ambas as equações e as variáveis.  Por Exemplo

          'diff(f,x,2)=sin(x)+'diff(g,x);
          'diff(f,x)+x^2-f=2*'diff(g,x,2);

     não é o formato apropriado.  O caminho correto é:

          'diff(f(x),x,2)=sin(x)+'diff(g(x),x);
          'diff(f(x),x)+x^2-f=2*'diff(g(x),x,2);

     A chamada é então `desolve([%o3,%o4],[f(x),g(x)]);' .

     Se as condições iniciais em 0 são conhecidas, elas podem ser
     fornecidas antes chamando `desolve' através de `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Se `desolve' não pode obter uma solução, retorna `false'.


 -- Função: ic1 (<solução>, <xval>, <yval>)
     Resolve o problema do valor inicial para equação diferencial de
     primeira ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval> é uma equação para a
     variável independente na forma `<x> = <x0>', e <yval> é uma
     equação para a variável dependente na forma `<y> = <y0>'. Veja
     `ode2' para exemplo de utilização.


 -- Função: ic2 (<solução>, <xval>, <yval>, <dval>)
     Resolve o problema do valor inicial para equação diferencial de
     segunda ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval> é uma equação para a
     variável independente na forma `<x> = <x0>', <yval> é uma
     equação para a variável dependente na forma `<y> = <y0>', e <dval>
     é uma equação para a derivada da variável dependente com
     relação à variável independente avaliada no ponto <xval>.  Veja
     `ode2' para exemplo de utilização.


 -- Função: ode2 (<eqn>, <dvar>, <ivar>)
     A função `ode2' resolve equações diferenciais ordinária ou de
     primeira ou de segunda ordem.  Recebe três argumentos: uma EDO
     <eqn>, a variável dependente <dvar>, e a variável
     independente<ivar>.  Quando obtém sucesso, retorna ou uma
     solução (explícita ou implícita) para a variável dependente.  `%c'
     é usado para representar a constante no caso de equações de
     primeira ordem, e `%k1' e `%k2' as constantes para equações de
     segunda ordem.  Se `ode2' não pode obter a solução por alguma
     razão, retorna `false', após talvez mostra uma mensagem de erro.
     O método implementado para equações diferenciais de primeira ordem
     na seqüência na qual eles são testados são: linear, separável,
     exato - talvez requerendo um fator de integração, homogêneos,
     equação de Bernoulli, e um método homogêneo geral.  Para segunda
     ordem: coeficiente constante, exato, linear homogêneo com
     coeficientes não-constantes os quais podem ser transformados para
     coeficientes constates, o Euler ou equação equidimensional, o
     método de variação de parâmetros, e equações as quais são livres
     ou da variável independente ou da dependente de modo que elas
     possam ser reduzidas duas equações lineares de primeria ordem para
     serem resolvidas seqüêncialmente.  No curso de resolver EDOs,
     muitas variáveis são escolhidas puramente para propósitos
     informativos: `método' denota o método de solução usado e.g.
     `linear', `intfactor' denota qualquer fator de integração usado,
     `odeindex' denota o índice para o método de Bernoulli ou para o
     método homogêneo generalizado, e `yp' denota a solução particular
     para a técnica de variação de parâmetros.

     Com o objetivo de resolver os problemas dos valores iniciais
     (PVIs) e problemas dos valores limite (PVLs), a rotina `ic1' está
     disponível para equações de primeira ordem, e `ic2' e `bc2' para
     segunda ordem PVIs e PVLs, respectively.

     Example:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Numérico,  Next: Estatística,  Prev: Equações Diferenciais,  Up: Top

23 Numérico
***********

* Menu:

* Introdução a Numérico::
* Pacotes de Fourier::
* Definições para Numérico::
* Definições para Séries de Fourier::


File: maxima.info,  Node: Introdução a Numérico,  Next: Pacotes de Fourier,  Prev: Numérico,  Up: Numérico

23.1 Introdução a Numérico
==========================


File: maxima.info,  Node: Pacotes de Fourier,  Next: Definições para Numérico,  Prev: Introdução a Numérico,  Up: Numérico

23.2 Pacotes de Fourier
=======================

O pacote `fft' compreende funções para computação numérica (não
simbólica) das transformações rápidas de Fourier.  `load ("fft")' chama
esse pacote.  Veja `fft'.

   O pacote `fourie' compreende funções para computação simbólica de
séries de Fourier.  `load ("fourie")' chama esse pacote.  Existem
funções no pacote `fourie' para calcular coeficientes da integral de
Fourier e algumas funções para manipulação de expressões.  Veja
`Definições para Séries'.


File: maxima.info,  Node: Definições para Numérico,  Next: Definições para Séries de Fourier,  Prev: Pacotes de Fourier,  Up: Numérico

23.3 Definições para Numérico
=============================

 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Traduz valores complexos da forma `r %e^(%i t)' para a forma `a +
     b %i'.  `load ("fft")' chama essa função dentro do Maxima. Veja
     também `fft'.

     O módulo e a fase, `r' e `t', São tomados de <magnitude_array> e
     <phase_array>, respectivamente. Os valores originais de arrays de
     entrada são substituídos pelas partes real e emaginária, `a' e
     `b', no retorno. As saídas são calculadas como

          a: r cos (t)
          b: r sin (t)

     Os arrays de entrada devem ter o mesmo tamanho  e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `polartorect' é a função inversa de `recttopolar'.


 -- Função: recttopolar (<real_array>, <imaginary_array>)
     Traduz valores complexos da forma `a + b %i' para a forma `r
     %e^(%i t)'.  `load ("fft")' chama essa função dentro do Maxima.
     Veja também `fft'.

     As partes real e imaginária, `a' e `b', são tomadas de
     <real_array> e <imaginary_array>, respectivamente. Os valores
     originais dos arrays de entrada são substituídos pelo módulo e
     pelo ângulo, `r' e `t', no retorno. As saídas são calculadas como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     O ângulo calculado encontra-se no intervalo de `-%pi' a `%pi'.

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `recttopolar' é a função inversa de `polartorect'.


 -- Função: ift (<real_array>, <imaginary_array>)
     Transformação rápida inversa discreta de Fourier . `load ("fft")'
     chama essa função dentro do Maxima.

     `ift' realiza a transformação rápida complexa de Fourier sobre
     arrays em ponto flutuante unidimensionais. A transformação inversa
     é definida como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Veja `fft' para maiores detalhes.


 -- Função: fft (<real_array>, <imaginary_array>)
 -- Função: ift (<real_array>, <imaginary_array>)
 -- Função: recttopolar (<real_array>, <imaginary_array>)
 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Transformação rápidada de Fourier e funções relacionadas. `load
     ("fft")' chama essas funções dentro do Maxima.

     `fft' e `ift' realiza transformação rápida complexa de Fourier e a
     transformação inversa, respectivamente, sobre arrays em ponto
     flutuante unidimensionais. O tamanho de <imaginary_array> deve ser
     igual ao tamanho de <real_array>.

     `fft' e `ift' operam in-loco. Isto é, sobre o retorno de `fft' ou
     de `ift', O conteúdo original dos arrays de entrada é substituído
     pela saída.  A função `fillarray' pode fazer uma cópia de um
     array, isso pode ser necessário.

     A transformação discreta de Fourier e sua transformação inversa
     são definidas como segue. Tome `x' sendo os dados originais, com

          x[i]: real_array[i] + %i imaginary_array[i]

     Tome `y' sendo os dados transformados. A transformação normal e
     sua transformação inversa são

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arrays adequadas podem ser alocadas pela função `array'. Por
     exemplo:

          array (my_array, float, n-1)$

     declara um array unidimensional com n elementos, indexado de 0 a
     n-1 inclusive. O número de elementos n deve ser igual a 2^m para
     algum m.

     `fft' pode ser aplicada a dados reais (todos os arrays imaginários
     são iguais a zero) para obter coeficientes seno e cosseno.  Após
     chamar `fft', os coeficientes seno e cosseno, digamos `a' e `b',
     podem ser calculados como

          a[0]: real_array[0]
          b[0]: 0

     e

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j variando de 1 a n/2-1, e

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     `recttopolar' traduz valores complexos da forma `a + b %i' para a
     forma `r %e^(%i t)'. Veja `recttopolar'.

     `polartorect' traduz valores complexos da forma `r %e^(%i t)' para
     a forma `a + b %i'. Veja `polartorect'.

     `demo ("fft")' exibe uma demonstração do pacote `fft'.


 -- Variável de opção: fortindent
     Valor padrão: 0

     `fortindent' controla a margem esquerda de indentação de
     expressões mostradas pelo comando `fortran'.  0 fornece indentação
     normal (i.e., 6 espaços), e valores positivos farão com que
     expressões sejam mostrados mais além para a direita.


 -- Função: fortran (<expr>)
     Mostra <expr> como uma declaração Fortran.  A linha de saída é
     indentada com espaços.  Se a linha for muito longa, `fortran'
     imprime linhas de continuação.  `fortran' mostra o operador de
     exponenciação `^' como `**', e mostra um número complexo `a + b
     %i' na forma `(a,b)'.

     <expr> pode ser uma equação. Nesse caso, `fortran' mostra uma
     declaração de atribuição, atribuindo o primeiro membro (esquerda)
     da equação ao segundo membro (direita).  Em particular, se o
     primeiro membro <expr> é um nome de uma matriz, então `fortran'
     mostra uma declaração de atribuição para cada elemento da matriz.

     Se <expr> não for alguma coisa reconhecida por `fortran', a
     expressão é mostrada no formato `grind' sem reclamação.  `fortran'
     não conhece listas, arrays ou funções.

     `fortindent' controla o margem esquerda das linhas mostradas.  0 é
     a margem normal (i.e., indentada 6 espaços). Incrementando
     `fortindent' faz com que expressões sejam mostradas adiante para a
     direita.

     quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

     `fortran' avalia seus argumentos; colocando um apóstrofo em um
     argumento evita avaliação.  `fortran' sempre retorna `done'.

     Exemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Variável de opção: fortspaces
     Valor padrão: `false'

     Quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.


 -- Função: horner (<expr>, <x>)
 -- Função: horner (<expr>)
     Retorna uma representação rearranjada de <expr> como na regra de
     Horner, usando <x> como variável principal se isso for
     especificado.  `x' pode ser omitido e nesse caso a variável
     principal da forma de expressão racional canônica de <expr> é
     usada.

     `horner' algumas vezes melhora a estabilidade se `expr' for ser
     numericamente avaliada.  Isso também é útil se Maxima é usado para
     gerar programas para rodar em Fortran. Veja também `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Função: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Função: find_root (<f>, <a>, <b>)
     Encontra a raíz da função <f> com a variável <x> percorrendo o
     intervalo `[<a>, <b>]'.  A função deve ter um sinal diferente em
     cada ponto final.  Se essa condição não for alcançada, a action of
     the function is governed by `find_root_error'.  If
     `find_root_error' is `true' then an error occurs, otherwise the
     value of `find_root_error' is returned (thus for plotting
     `find_root_error' might be set to 0.0).  De outra forma (dado que
     Maxima pode avaliar o primeiro argumento no intervalo
     especificado, e que o intervalo é contínuo) `find_root' é
     garantido vir para cima com a raíz (ou um deles se existir mais
     que uma raíz).  A precisão de `find_root' é governada por
     `intpolabs' e `intpolrel' os quais devem ser números em ponto
     flutuante não negativos.  `find_root' encerrará quando o primeiro
     argumento avaliar para alguma coisa menor que ou igual a
     `intpolabs' ou se sucessivas aproximações da raíz diferirem por
     não mais que `intpolrel * <um dos aproximandos>'.  O valor padrão
     de `intpolabs' e `intpolrel' são 0.0 de forma que `find_root' pega
     como boa uma resposta como for possível com a precisão aritmética
     simples que tivermos.  O primeiro argumento pode ser uma equação.
     A ordem dos dois últimos argumentos é irrelevante.  Dessa forma

          find_root (sin(x) = x/2, x, %pi, 0.1);

     é equivalente a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     O método usado é uma busca binária no intervalo especificado pelos
     últimos dois argumentos.  Quando o resultado da busca for
     encontrado a função é fechada o suficiente para ser linear, isso
     inicia usando interpolação linear.

     Examples:
          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Variável de opção: find_root_abs
     Valor padrão: 0.0

     `find_root_abs' é a precisão do comando `find_root'. A precisão é
     governada por `find_root_abs' e `find_root_rel' que devem ser
     números não negativos em ponto flutuante.  `find_root' terminará
     quando o primeiro argumento avaliar para alguma coisa menor que ou
     igual a `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem por não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_abs' e `find_root_rel' são 0.0 de
     forma que `find_root' tome como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.


 -- Variável de opção: find_root_error
     Valor padrão: `true'

     `find_root_error' governa o comportamento de `find_root'.  Quando
     `find_root' for chamada, ela determina se a função a ser resolvida
     satisfaz ou não a condição que os valores da função nos pontos
     finais do intervalo de interpolação são opostos em sinal.  Se eles
     forem de sinais opostos, a interpolação prossegue.  Se eles forem
     de mesmo sinal, e `find_root_error' for `true', então um erro é
     sinalizado.  Se eles forem de mesmo sinal e `find_root_error' não
     for `true', o valor de `find_root_error' é retornado.  Dessa forma
     para montagem de gráfico, `find_root_error' pode ser escolhida
     para 0.0.


 -- Variável de opção: find_root_rel
     Valor padrão: 0.0

     `find_root_rel' é a precisão do comando `find_root' e é governada
     por `find_root_abs' e `find_root_rel' que devem ser números não
     negativos em ponto flutuante.  `find_root' terminará quando o
     primeiro argumento avaliar para alguma coisa menor que ou igual a
     `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem de não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_labs' e `find_root_rel' é 0.0 de
     forma que `find_root' toma como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.



File: maxima.info,  Node: Definições para Séries de Fourier,  Prev: Definições para Numérico,  Up: Numérico

23.4 Definições para Séries de Fourier
======================================

 -- Função: equalp (<x>, <y>)
     Retorna `true' se `equal (<x>, <y>)' de outra forma `false' (não
     fornece uma mensagem de erro como `equal (x, y)' poderia fazer
     nesse caso).


 -- Função: remfun (<f>, <expr>)
 -- Função: remfun (<f>, <expr>, <x>)
     `remfun (<f>, <expr>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr>.

     `remfun (<f>, <expr>, <x>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr> somente se <arg> contiver a variável
     <x>.


 -- Função: funp (<f>, <expr>)
 -- Função: funp (<f>, <expr>, <x>)
     `funp (<f>, <expr>)' retorna `true' se <expr> contém a função <f>.

     `funp (<f>, <expr>, <x>)' retorna `true' se <expr> contém a
     função <f> e a variável <x> em algum lugar no argumento de uma das
     instâncias de <f>.


 -- Função: absint (<f>, <x>, <halfplane>)
 -- Função: absint (<f>, <x>)
 -- Função: absint (<f>, <x>, <a>, <b>)
     `absint (<f>, <x>, <halfplane>)' retorna a integral indefinida de
     <f> com relação a <x> no dado semi-plano (`pos', `neg', ou `both').
     <f> pode conter expressões da forma `abs (x)', `abs (sin (x))',
     `abs (a) * exp (-abs (b) * abs (x))'.

     `absint (<f>, <x>)' é equivalente a `absint (<f>, <x>, pos)'.

     `absint (<f>, <x>, <a>, <b>)' retorna a integral definida de <f>
     com relação a <x> de <a> até <b>.  <f> pode incluir valores
     absolutos.


 -- Função: fourier (<f>, <x>, <p>)
     Retorna uma lista de coeficientes de Fourier de `<f>(<x>)'
     definidos sobre o intervalo `[-%pi, %pi]'.


 -- Função: foursimp (<l>)
     Simplifica `sin (n %pi)' para 0 se `sinnpiflag' for `true' e `cos
     (n %pi)' para `(-1)^n' se `cosnpiflag' for `true'.


 -- Variável de opção: sinnpiflag
     Valor padrão: `true'

     Veja `foursimp'.


 -- Variável de opção: cosnpiflag
     Valor padrão: `true'

     Veja `foursimp'.


 -- Função: fourexpand (<l>, <x>, <p>, <limit>)
     Constrói e retorna a série de Fourier partindo da lista de
     coeficientes de Fourier <l> até (up through) <limit> termos
     (<limit> pode ser `inf'). <x> e <p> possuem o mesmo significado
     que em `fourier'.


 -- Função: fourcos (<f>, <x>, <p>)
     Retorna os coeficientes do cosseno de Fourier para `<f>(<x>)'
     definida sobre `[0, %pi]'.


 -- Função: foursin (<f>, <x>, <p>)
     Retorna os coeficientes do seno de Fourier para `<f>(<x>)'
     definida sobre `[0, %pi]'.


 -- Função: totalfourier (<f>, <x>, <p>)
     Retorna `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.


 -- Função: fourint (<f>, <x>)
     Constrói e retorna uma lista de coeficientes de integral de
     Fourier de `<f>(<x>)' definida sobre `[minf, inf]'.


 -- Função: fourintcos (<f>, <x>)
     Retorna os coeficientes da integral do cosseno de Fourier para
     `<f>(<x>)' on `[0, inf]'.


 -- Função: fourintsin (<f>, <x>)
     Retorna os coeficientes da integral do seno de Fourier para
     `<f>(<x>)' on `[0, inf]'.



File: maxima.info,  Node: Estatística,  Next: Arrays,  Prev: Numérico,  Up: Top

24 Estatística
**************

* Menu:

* Definições para Estatística::


File: maxima.info,  Node: Definições para Estatística,  Prev: Estatística,  Up: Estatística

24.1 Definições para Estatística
================================

 -- Função: gauss (<mean>, <sd>)
     Retorna um número em ponto flutuante randômico de uma
     distribuição normal com usando <mean> e desvio padrão <sd>.



File: maxima.info,  Node: Arrays,  Next: Matrizes e Álgebra Linear,  Prev: Estatística,  Up: Top

25 Arrays
*********

* Menu:

* Definições para Arrays::


File: maxima.info,  Node: Definições para Arrays,  Prev: Arrays,  Up: Arrays

25.1 Definições para Arrays
===========================

 -- Função: array (<name>, <dim_1>, ..., <dim_n>)
 -- Função: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Função: array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)
     Cria um array n-dimensional.  n pode ser menor ou igual a 5.  Os
     subscritos para a i'ésima dimensão são inteiros no intervalo de 0
     a <dim_i>.

     `array (<name>, <dim_1>, ..., <dim_n>)' cria um array genérico.

     `array (<name>, <type>, <dim_1>, ..., <dim_n>)' cria um array, com
     elementos de um tipo especificado.  <type> pode ser `fixnum' para
     inteiros de tamanho limitado ou `flonum' para números em ponto
     flutuante.

     `array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)' cria m
     arrays, todos da mesma dimensão.

     Se o usuário atribui a uma variável subscrita antes de declarar o
     array correspondente, um array não declarado é criado.  Arrays não
     declarados, também conhecidos como array desordenado (porque o
     codigo desordenado termina nos subscritos), são mais gerais que
     arrays declarados.  O usuário não declara seu tamanho máximo, e
     ele cresce dinamicamente e desordenadamente à medida que são
     atribuídos valores a mais elementos.  Os subscritos de um array
     não declarado não precisam sempre ser números.  Todavia, exceto
     para um array um tanto quanto esparso, é provavelmente mais
     eficiente declarar isso quando possível que deixar não declarado.
     A função `array' pode ser usada para transformar um array não
     declarado em um array declarado.


 -- Função: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Avalia `<A> [<i_1>, ..., <i_n>]', quando <A> for um array e <i_1>,
     ..., <i_n> são inteiros.

     Ela é remanescente de `apply', exceto o primeiro argumento que é
     um array ao invés de uma função.


 -- Função: arrayinfo (<A>)
     Retorna informações sobre o array <A>.  O argumento <A> pode ser
     um array declarado, uma array não declarado ( que sofreu um hash),
     uma função de array, ou uma função que possui subscrito.

     Para arrays declarados, `arrayinfo' retorna uma lista
     compreendendo o átomo `declared', o n;umero de dimensões, e o
     tamanho de cada dimensão.  Os elementos do array, ambos associados
     e não associados, são retornados por `listarray'.

     Para arrays não declarados (arrays que sofreram um hash),
     `arrayinfo' retorna uma lista compreendendo o átomo `hashed', o
     número de subscritos, e os subscritos de de todo elemento que
     tiver um valor.  Os valores são retornados por meio de `listarray'.

     Para funções de array, `arrayinfo' retretorna uma lista
     compreendendo o átomo `hashed', o número de subscritos, e
     quaisquer valores de subscritos para os quais exista valores
     funcionais armazenados.  Os valores funcionais armazenados são
     retornados através de `listarray'.

     Para funções que possuem subscritos, `arrayinfo' retorna uma lista
     compreendendo o átomo `hashed', o número de subscritos, e qualquer
     valores subscritos para os quais existe uma expressões lambda.  As
     expressões lambda são retornadas por `listarray'.

     Examples:

     `arrayinfo' e `listarray' aplicado a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     `arrayinfo' e `listarray' aplicado a um array não declarado (no
     qual foi aplicado um hash).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     `arrayinfo' e `listarray' aplicado a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     `arrayinfo' e `listarray' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- Função: arraymake (<name>, [<i_1>, ..., <i_n>])
     Retorna a expressão `<name> [<i_1>, ..., <i_n>]'.

     Isso é um código remanescente de `funmake', exceto o valor
     retornado é um array de referência não avaliado ao invés de uma
     chamada de função não avaliada.


 -- Variável de sistema: arrays
     Valor padrão: `[]'

     `arrays' é uma lista dos arrays que tiverem sido alocados.  Essa
     lista compreende arrays declarados através de `array', arrays
     desordenados (hashed) construídos através de definição implícita
     (atribuindo alguma coisa a um elemento de array), e funções de
     array definidas por meio de `:=' e `define'.  Arrays definidos por
     meio de `make_array' não estão incluídos.

     Veja também `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray', e `rearray'.

     Exemplos:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]


 -- Função: bashindices (<expr>)
     Transforma a expressão <expr> dando a cada somatório e a cada
     produto um único índice.  Isso dá a `changevar' grande precisão
     quando se está trabalhando com somatórios e produtos.  A forma do
     único índice é `j<number>'.  A quantidade <number> é determindad
     por referência a `gensumnum', que pode ser alterada pelo usuário.
     Por exemplo, `gensumnum:0$' reseta isso.


 -- Função: fillarray (<A>, <B>)
     Preenche o array <A> com <B>, que é uma lista ou um array.

     Se <A> for um array de ponto flutuante (inteiro) então <B> poderá
     ser ou uma lista de números (inteiros) em ponto flutuante ou outro
     array em ponto flutuante (inteiro).

     Se as dimensões do array forem diferentes <A> é preenchida na
     ordem da maior linha.  Se não existem elementos livres em <B> o
     último elemento é usado para preencher todo o resto de <A>.  Se
     existirem muitos os restantes serão descartados.

     `fillarray' retorna esse primeiro argumento.


 -- Função: listarray (<A>)
     Retorna uma lista dos elementos do array <A>.  O argumento <A>
     pode ser um array declarado, um array não declarado (desordenado -
     hashed), uma função de array, ou uma função com subscritos.

     Elementos são listados em ordem de linha maior.  Isto é, elementos
     são ordenados conforme o primeiro índice, en seguida conforme o
     segundo índice, e assim sucessivamente.  A sequüência de ordenação
     por meio dos valores dos índices é a mesma ordem estabelecida por
     meio de `orderless'.

     Para arrays não declarados , funções de arrays, e funções com
     subscritos, os elementos correspondem aos valores de índice
     retornados através de `arrayinfo'.

     Elemetos não associados de arrays genéricos declarados (isto é,
     não `fixnum' e não `flonum') são retornados como `#####'.
     Elementos não associados de arrays declarados `fixnum' ou `flonum'
     são retornados como 0 ou 0.0, respectivamente.  Elementos não
     associados de arrays não declarados, funções de array, e funções
     subscritas não são retornados.

     Exemplos:

     `listarray' e `arrayinfo' aplicados a um array declarado.

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     `listarray' e `arrayinfo' aplicadas a arrays não declarados
     (hashed - desordenados).

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     `listarray' e `arrayinfo' aplicada a uma função de array.

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     `listarray' e `arrayinfo' aplicadas a funções com subscritos.

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]


 -- Função: make_array (<type>, <dim_1>, ..., <dim_n>)
     Cria e retorna um array de Lisp.  <type> pode ser `any', `flonum',
     `fixnum', `hashed' ou `functional'.  Existem n indices, e o
     i'enésimo indice está no intervalo de 0 a <dim_i> - 1.

     A vantagem de `make_array' sobre `array' é que o valor de retorno
     não tem um nome, e uma vez que um ponteiro a ele vai, ele irá
     também.  Por exemplo, se `y: make_array (...)' então `y' aponta
     para um objeto que ocupa espaço, mas depois de `y: false', `y' não
     mais aponta para aquele objeto, então o objeto pode ser descartado.


 -- Função: rearray (<A>, <dim_1>, ..., <dim_n>)
     Altera as dimenções de um array.  O novo array será preenchido com
     os elementos do antigo em ordem da maior linha.  Se o array antigo
     era muito pequeno, os elementos restantes serão preenchidos com
     `false', `0.0' ou `0', dependendo do tipo do array.  O tipo do
     array não pode ser alterado.


 -- Função: remarray (<A_1>, ..., <A_n>)
 -- Função: remarray (all)
     Remove arrays e funções associadas a arrays e libera o espaço
     ocupado.  Os argumentos podem ser arrays declarados, arrays não
     declarados (dsordenados - hashed), funções de array functions, e
     funções com subscritos.

     `remarray (all)' remove todos os ítens na lista global `arrays'.

     Isso pode ser necessário para usar essa função se isso é desejado
     para redefinir os valores em um array desordenado.

     `remarray' retorna a lista dos arrays removidos.


 -- Função: subvar (<x>, <i>)
     Avalia a expressão subscrita `<x>[<i>]'.

     `subvar' avalia seus argumentos.

     `arraymake (<x>, [<i>]' constrói a expressão `<x>[<i>]', mas não a
     avalia.

     Exemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3) foo
           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5) +(%i6) arraymake (x, [i]);
          (%o6) foo
           3
          (%i7) ''%;
          (%o7) +


 -- Variável de pção: use_fast_arrays
     - Se `true' somente dois tipos de arrays são reconhecidos.

     1) O array art-q (t no Lisp Comum) que pode ter muitas dimensões
     indexadas por inteiros, e pode aceitar qualquer objeto do Lisp ou
     do Maxima como uma entrada.  Para construir assim um array, insira
     `a:make_array(any,3,4);' então `a' terá como valor, um array com
     doze posições, e o índice é baseado em zero.

     2) O array Hash_table que é o tipo padrão de array criado se um
     faz `b[x+1]:y^2' (e `b' não é ainda um array, uma lista, ou uma
     matriz - se isso ou um desses ocorrer um erro pode ser causado
     desde `x+1' não poderá ser um subscrito válido para um array
     art-q, uma lista ou uma matriz).  Esses índices (também conhecidos
     como chaves) podem ser quaisquer objetos.  Isso somente pega uma
     chave por vez a cada vez (`b[x+1,u]:y' ignorará o `u').  A
     referência termina em `b[x+1] ==> y^2'.  Certamente a chave poe
     ser uma lista , e.g.  `b[[x+1,u]]:y' poderá ser válido.  Isso é
     incompatível com os arrays antigos do Maxima, mas poupa recursos.

     Uma vantagem de armazenar os arrays como valores de símbolos é que
     as convenções usuais sobre variáveis locais de uma função
     aplicam-se a arrays também.  O tipo Hash_table também usa menos
     recursos e é mais eficiente que o velho tipo hashar do Maxima.
     Para obter comportamento consistente em códigos traduzidos e
     compilados posicione `translate_fast_arrays' para ser `true'.



File: maxima.info,  Node: Matrizes e Álgebra Linear,  Next: Funções Afins,  Prev: Arrays,  Up: Top

26 Matrizes e Álgebra Linear
****************************

/Matrices.texi/1.24/Sat Jun 24 06:45:55 2006/-ko/

* Menu:

* Introdução a Matrizes e Álgebra Linear::
* Definições para Matrizes e Álgebra Linear::


File: maxima.info,  Node: Introdução a Matrizes e Álgebra Linear,  Next: Definições para Matrizes e Álgebra Linear,  Prev: Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

26.1 Introdução a Matrizes e Álgebra Linear
===========================================

* Menu:

* Ponto::
* Vetores::
* auto::


File: maxima.info,  Node: Ponto,  Next: Vetores,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Introdução a Matrizes e Álgebra Linear

26.1.1 Ponto
------------

O operador `.' representa multiplicação não comutativa e produto
escalar.  Quando os operandos são matrizes 1-coluna ou 1-linha `a' e
`b', a expresão `a.b' é equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Se `a' e `b' não são complexos, isso é o produto escalar,
também chamado produto interno ou produto do ponto, de `a' e `b'.  O
produto escalar é definido como `conjugate(a).b' quando `a' e `b' são
complexos; `innerproduct' no pacote `eigen' fornece o produto escalar
complexo.

   Quando os operandos são matrizes mais gerais, o produto é a matriz
produto `a' e `b'.  O número de linhas de `b' deve ser igual ao número
de colunas de `a', e o resultado tem número de linhas igual ao número
de linhas de `a' e número de colunas igual ao número de colunas de `b'.

   Para distingüir `.' como um operador aritmético do ponto decimal em
um número em ponto flutuante, pode ser necessário deixar espaços em
cada lado.  Por exemplo, `5.e3' é `5000.0' mas `5 . e3' é `5' vezes
`e3'.

   Existem muitos sinalizadores que governam a simplificação de
expresões envolvendo `.', a saber `dot', `dot0nscsimp', `dot0simp',
`dot1simp', `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
`dotident', e `dotscrules'.


File: maxima.info,  Node: Vetores,  Next: auto,  Prev: Ponto,  Up: Introdução a Matrizes e Álgebra Linear

26.1.2 Vetores
--------------

`vect' é um pacote de funções para análise vetorial.  `load ("vect")'
chama esse pacote, e `demo ("vect")' permite visualizar uma
demonstração.

   O pacote de análise vetorial pode combinar e simplificar expresões
simbólicas incluindo produtos dos pontos e productos dos x, juntamente
com o gradiente, divergencia, torção, e operadores Laplacianos.  A
distribuição desses operadores sobre adições ou produtos é governada
por muitos sinalizadores, como são várias outras expansões, incluindo
expansão dentro de componentes em qualquer sistema de coordenadas
ortogonais.  Existem também funções para derivar o escalar ou vetor
potencial de um campo.

   O pacote `vect' contém essas funções: `vectorsimp', `scalefactors',
`express', `potential', e `vectorpotential'.

   Atenção: o pacote `vect' declara o operador ponto `.' como sendo um
operador comutativo.


File: maxima.info,  Node: auto,  Prev: Vetores,  Up: Introdução a Matrizes e Álgebra Linear

26.1.3 auto
-----------

O pacote `eigen' contém muitas funções devotadas para a computação
simbólica de autovalores e autovetores.  Maxima chama o pacote
automaticamente se uma das funções `eigenvalues' ou `eigenvectors' é
invocada.  O pacote pode ser chamado explicitamente com `load
("eigen")'.

   `demo ("eigen")' mostra uma demonstração das compatibilidades desse
pacote.  `batch ("eigen")' executa a mesma demonstração, mas sem
lembretes de usuário entre sucessivas computações.

   As funções no pacote `eigen' são `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors', e `similaritytransform'.


File: maxima.info,  Node: Definições para Matrizes e Álgebra Linear,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

26.2 Definições para Matrizes e Álgebra Linear
==============================================

 -- Função: addcol (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) coluna(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: addrow (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) linha(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: adjoint (<M>)
     Retorna a matriz adjunta da matriz <M>.  A matriz adjunta é a
     transposta da matriz dos cofatores de <M>.


 -- Função: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes aumentada para as variáveis
     <x_1>, ..., <x_n> do sistema de equações lineares <eqn_1>, ...,
     <eqn_m>.  Essa é a matriz dos coeficientes com uma coluna anexada
     para os termos independentes em cada equação (i.e., esses termos
     não dependem de <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Função: charpoly (<M>, <x>)
     Retorna um polinômio característico para a matriz <M> em relação à
     variável <x>.  Que é, `determinant (<M> - diagmatrix (length
     (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Função: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes para as variáveis <x_1>, ...,
     <x_n> do sistema de equações lineares <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Função: col (<M>, <i>)
     Reorna a <i>'ésima coluna da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Função: columnvector (<L>)
 -- Função: covect (<L>)
     Retorna uma matriz de uma coluna e `length (<L>)' linhas, contendo
     os elementos da lista <L>.

     `covect' é um sinônimo para `columnvector'.

     `load ("eigen")' chama essa função.

     Isso é útil se você quer usar partes das saídas das funções nesse
     pacote em cálculos matriciais.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovetores
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Função: conjugate (<x>)
     Retorna o conjugado complexo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Função: copymatrix (<M>)
     Retorna uma cópia da matriz <M>.  Esse é o único para fazer uma
     copia separada copiando <M> elemento a elemento.

     Note que uma atribuição de uma matriz para outra, como em `m2: m1',
     não copia `m1'.  Uma atribuição `m2 [i,j]: x' ou `setelmx (x, i,
     j, m2' também modifica `m1 [i,j]'.  criando uma cópia com
     `copymatrix' e então usando atribução cria uma separada e
     modificada cópia.


 -- Função: determinant (<M>)
     Calcula o determinante de <M> por um método similar à eliminação
     de Gauss.

     A forma do resultado depende da escolha do comutador `ratmx'.

     Existe uma rotina especial para calcular determinantes esparsos
     que é chamada quando os comutadores `ratmx' e `sparse' são ambos
     `true'.


 -- Variável: detout
     Valor padrão: `false'

     Quando `detout' é `true', o determinante de uma matriz cuja
     inversa é calculada é fatorado fora da inversa.

     Para esse comutador ter efeito `doallmxops' e `doscmxops' deveram
     ambos serem `false' (veja suas transcrições).  Alternativamente
     esses comutadores podem ser dados para `ev' o que faz com que os
     outros dois sejam escolhidos corretamente.

     Exemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Função: diagmatrix (<n>, <x>)
     Retorna uma matriz diagonal de tamanho <n> por <n> com os
     elementos da diagonal todos iguais a <x>.  `diagmatrix (<n>, 1)'
     retorna uma matriz identidade (o mesmo que `ident (<n>)').

     <n> deve avaliar para um inteiro, de outra forma `diagmatrix'
     reclama com uma mensagem de erro.

     <x> pode ser qualquer tipo de expresão, incluindo outra matriz.
     Se <x> é uma matriz, isso não é copiado; todos os elementos da
     diagonal referem-se à mesma instância, <x>.


 -- Variável: doallmxops
     Valor padrão: `true'

     Quando `doallmxops' é `true', todas as operações relacionadas a
     matrizes são realizadas.  Quando isso é `false' então a escolha de
     comutadores individuais `dot' governam quais operações são
     executadas.


 -- Variável: domxexpt
     Valor padrão: `true'

     Quando `domxexpt' é `true', uma matriz exponencial, `exp (<M>)'
     onde <M> é a matriz, é interpretada como uma matriz com elementos
     `[i,j' iguais a `exp (m[i,j])'.  de outra forma `exp (<M>)' avalia
     para `exp (<ev(M)>'.

     `domxexpt' afeta todas as expresões da forma `<base>^<expoente>'
     onde <base> é uma expresão assumida escalar ou constante, e
     <expoente> é uma lista ou matriz.

     Exemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Variável de opção: domxmxops
     Valor padrão: `true'

     Quando `domxmxops' é `true', todas as operações matriz-matriz ou
     matriz-lista são realizadas (mas não operações escalar-matriz); se
     esse comutador é `false' tais operações não são.


 -- Variável de opção: domxnctimes
     Valor padrão: `false'

     Quando `domxnctimes' é `true', produtos não comutativos de
     matrizes são realizados.


 -- Variável de opção: dontfactor
     Valor padrão: `[]'

     `dontfactor' pode ser escolhido para uma lista de variáveis em
     relação a qual fatoração não é para ocorrer.  (A lista é
     inicialmente vazia.)  Fatoração também não pegará lugares com
     relação a quaisquer variáveis que são menos importantes, conforme
     a hierarquía de variável assumida para a forma expresão racional
     canônica (CRE), que essas na lista `dontfactor'.


 -- Variável de opção: doscmxops
     Valor padrão: `false'

     Quando `doscmxops' é `true', operações escalar-matriz são
     realizadas.


 -- Variável de opção: doscmxplus
     Valor padrão: `false'

     Quando `doscmxplus' é `true', operações escalar-matriz retornam
     uma matriz resultado.  Esse comutador não é subsomado sob
     `doallmxops'.


 -- Variável de opção: dot0nscsimp
     Valor padrão: `true'

     Quando `dot0nscsimp' é `true', um produto não comutativo de zero e
     um termo não escalar é simplificado para um produto comutativo.


 -- Variável de opção: dot0simp
     Valor padrão: `true'

     Quando `dot0simp' é `true', um produto não comutativo de zero e um
     termo escalar é simplificado para um produto não comutativo.


 -- Variável de opção: dot1simp
     Valor padrão: `true'

     Quando `dot1simp' é `true', um produto não comutativo de um e
     outro termo é simplificado para um produto comutativo.


 -- Variável de opção: dotassoc
     Valor padrão: `true'

     Quando `dotassoc' é `true', uma expresão `(A.B).C' simplifica para
     `A.(B.C)'.


 -- Variável de opção: dotconstrules
     Valor padrão: `true'

     Quando `dotconstrules' é `true', um produto não comutativo de uma
     constante e outro termo é simplificado para um produto comutativo.
     Ativando esse sinalizador efetivamente ativamos `dot0simp',
     `dot0nscsimp', e `dot1simp' também.


 -- Variável de opção: dotdistrib
     Valor padrão: `false'

     Quando `dotdistrib' é `true', uma expresão `A.(B + C)' simplifica
     para `A.B + A.C'.


 -- Variável de opção: dotexptsimp
     Valor padrão: `true'

     Quando `dotexptsimp' é `true', uma expresão `A.A' simplifica para
     `A^^2'.


 -- Variável de opção: dotident
     Valor padrão: 1

     `dotident' é o valor retornado por `X^^0'.


 -- Variável de opção: dotscrules
     Valor padrão: `false'

     Quando `dotscrules' é `true', uma expresão `A.SC' ou `SC.A'
     simplifica para `SC*A' e `A.(SC*B)' simplifica para `SC*(A.B)'.


 -- Função: echelon (<M>)
     Retorna a forma escalonada da matriz <M>, como produzido através
     da eliminação de Gauss.  A forma escalonada é calculada de <M> por
     operações elementares de linha tais que o primeiro elemento não
     zero em cada linha na matriz resultante seja o número um e os
     elementos da coluna abaixo do primeiro número um em cada linha
     sejam todos zero.

     `triangularize' também realiza eliminação de Gaussian, mas não
     normaliza o elemento líder não nulo em cada linha.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Função: eigenvalues (<M>)
 -- Função: eivals (<M>)
     Retorna uma lista de duas listas contendo os autovalores da matriz
     <M>.  A primeira sublista do valor de retorno é a lista de
     autovalores da matriz, e a segunda sublista é a lista de
     multiplicidade dos autovalores na ordem correspondente.

     `eivals' é um sinônimo de `eigenvalues'.

     `eigenvalues' chama a função `solve' para achar as raízes do
     polinômio característico da matriz.  Algumas vezes `solve' pode
     não estar habilitado a achar as raízes do polinômio; nesse caso
     algumas outras funções nesse pacote (except `innerproduct',
     `unitvector', `columnvector' e `gramschmidt') não irão trabalhar.

     Em alguns casos os autovalores achados por `solve' podem ser
     expresões complicadas.  (Isso pode acontecer quando `solve'
     retorna uma expresão real não trivial para um autovalor que é
     sabidamente real.)  Isso pode ser possível para simplificar os
     autovalores usando algumas outras funções.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.


 -- Função: eigenvectors (<M>)
 -- Função: eivects (<M>)
     pegam uma matriz <M> como seu argumento e retorna uma lista de
     listas cuja primeira sublista é a saída de `eigenvalues' e as
     outras sublistas são os autovetores da matriz correspondente para
     esses autovalores respectivamente.  Os autovetores e os
     autovetores unitários da matriz são os autovetores direitos e os
     autovetores unitários direitos.

     `eivects' é um sinônimo para `eigenvectors'.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.

     Os sinalizadores que afetam essa função são:

     `nondiagonalizable' é escolhido para `true' ou `false' dependendo
     de se a matriz é não diagonalizável ou diagonalizável após o
     retorno de `eigenvectors'.

     `hermitianmatrix' quando `true', faz com que os autovetores
     degenerados da matriz Hermitiana sejam ortogonalizados usando o
     algorítmo de Gram-Schmidt.

     `knowneigvals' quando `true' faz com que o pacote `eigen' assumir
     que os autovalores da matriz são conhecidos para o usuário e
     armazenados sob o nome global `listeigvals'.  `listeigvals' poderá
     ser escolhido para uma lista similar à saída de `eigenvalues'.

     A função `algsys' é usada aqui para resolver em relação aos
     autovetores.  Algumas vezes se os autovalores estão ausêntes,
     `algsys' pode não estar habilitado a achar uma solução.  Em alguns
     casos, isso pode ser possível para simplificar os autovalores por
     primeiro achando e então usando o comando `eigenvalues' e então
     usando outras funções para reduzir os autovalores a alguma coisa
     mais simples.  Continuando a simplificação, `eigenvectors' pode
     ser chamada novamente com o sinalizador `knowneigvals' escolhido
     para `true'.


 -- Função: ematrix (<m>, <n>, <x>, <i>, <j>)
     Retorna uma matriz <m> por <n>, todos os elementos da qual são
     zero exceto para o elemento `[<i>, <j>]' que é <x>.


 -- Função: entermatrix (<m>, <n>)
     Retorna uma matriz <m> por <n>, lendo os elementos interativamente.

     Se <n> é igual a <m>, Maxima pergunta pelo tipo de matriz
     (diagonal, simétrica, antisimétrica, ou genérica) e por cada
     elemento.  Cada resposta é terminada por um ponto e vírgula `;' ou
     sinal de dólar `$'.

     Se <n> não é igual a <m>, Maxima pergunta por cada elemento.

     Os elementos podem ser quaisquer expressões, que são avaliadas.
     `entermatrix' avalia seus argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matriz entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>)
     Retorna uma matriz gerada de <a>, pegando o elemento
     `<a>[<i_1>,<j_1>]' como o elemento do canto superior esquerdo e
     `<a>[<i_2>,<j_2>]' como o elemento do canto inferior direto da
     matriz.  Aqui <a> é um array declarado (criado através de `array'
     mas não por meio de `make_array') ou um array não declarado, ou
     uma função array, ou uma expressão lambda de dois argumentos.
     (Uma funçãO array é criado como outras funções com `:=' ou
     `define', mas os argumentos são colocados entre colchêtes em lugar
     de parêntesis.)

     Se <j_1> é omitido, isso é assumido ser igual a <i_1>.  Se ambos
     <j_1> e <i_1> são omitidos, ambos são assumidos iguais a 1.

     Se um elemento selecionado `i,j' de um array for indefinido, a
     matriz conterá um elemento simbólico `<a>[i,j]'.

     Exemplos:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]


 -- Função: gramschmidt (<x>)
 -- Função: gschmit (<x>)
     Realiza o algorítmo de ortonalização de Gram-Schmidt sobre <x>,
     seja ela uma matriz ou uma lista de listas.  <x> não é modificado
     por `gramschmidt'.

     Se <x> é uma matriz, o algorítmo é aplicado para as linhas de <x>.
     Se <x> é uma lista de listas, o algorítmo é aplicado às sublistas,
     que devem ter igual números de elementos.  Nos dois casos, o valor
     de retorno é uma lista de listas, as sublistas das listas são
     ortogonais e alcançam o mesmo spaço que <x>.  Se a dimensão do
     alcance de <x> é menor que o número de linhas ou sublistas,
     algumas sublistas do valor de retorno são zero.

     `factor' é chamada a cada estágio do algorítmo para simplificar
     resultados intermediários.  Como uma conseqüência, o valor de
     retorno pode conter inteiros fatorados.

     `gschmit' (nota ortográfica) é um sinônimo para `gramschmidt'.

     `load ("eigen")' chama essa função.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovetores
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]


 -- Função: hach (<a>, <b>, <m>, <n>, <l>)
     `hach' é um implementação algorítmo de programação linear de
     Hacijan.

     `load ("kach")' chama essa função.  `demo ("kach")' executa uma
     demonstração dessa função.


 -- Função: ident (<n>)
     Retorna uma matriz identidade <n> por <n>.


 -- Função: innerproduct (<x>, <y>)
 -- Função: inprod (<x>, <y>)
     Retorna o produto interno (também chamado produto escalar ou
     produto do ponto) de <x> e <y>, que são listas de igual
     comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual
     comprimento.  O valor de retorno é `conjugate (x) . y', onde `.' é
     o operador de multiplicação não comutativa.

     `load ("eigen")' chama essa função.

     `inprod' é um sinônimo para `innerproduct'.


 -- Função: invert (<M>)
     Retorna a inversa da matriz <M>.  A inversa é calculada pelo
     método adjunto.

     Isso permite a um usuário calcular a inversa de uma matriz com
     entradas bfloat ou polinômios com coeficientes em ponto flutuante
     sem converter para a forma CRE.

     Cofatores são calculados pela função  `determinant', então se
     `ratmx' é `false' a inversa é calculada sem mudar a representação
     dos elementos.

     A implementação corrente é ineficiente para matrizes de alta ordem.

     Quando `detout' é `true', o determinante é fatorado fora da
     inversa.

     Os elementos da inversa não são automaticamente expandidos.  Se
     <M> tem elementos polinomiais, melhor aparência de saída pode ser
     gerada por `expand (invert (m)), detout'.  Se isso é desejável
     para ela divisão até pelo determinante pode ser excelente por
     `xthru (%)' ou alternativamente na unha por

          expe (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     Veja `^^' (expoente não comutativo) para outro método de inverter
     uma matriz.


 -- Variável de opção: lmxchar
     Valor padrão: `['

     `lmxchar' é o caractere mostrado como o delimitador esquerdo de
     uma matriz.  Veja também `rmxchar'.

     Exemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Função: matrix (<row_1>, ..., <row_n>)
     Retorna uma matriz retangular que tem as linhas <row_1>, ...,
     <row_n>.  Cada linha é uma lista de expressões.  Todas as linhas
     devem ter o mesmo comprimento.

     As operações `+' (adição), `-' (subtração), `*' (multiplicação), e
     `/' (divisão), são realizadas elemento por elemento quando os
     operandos são duas matrizes, um escalar e uma matriz, ou uma
     matriz e um escalar.  A operação `^' (exponenciação,
     equivalentemente `**') é realizada elemento por elemento se os
     operandos são um escalar e uma matriz ou uma matriz e um escalar,
     mas não se os operandos forem duas matrizes.  Todos as operações
     são normalmente realizadas de forma completa, incluindo `.'
     (multiplicação não comutativa).

     Multiplicação de matrizes é representada pelo operador de
     multiplicação não comutativa `.'.  O correspondente operador de
     exponenciação não comutativa é `^^'.  Para uma matriz `<A>',
     `<A>.<A> = <A>^^2' e `<A>^^-1' é a inversa de <A>, se existir.

     Existem comutadores para controlar a simplificação de expresões
     envolvendo operações escalar e matriz-lista.  São eles
     `doallmxops', `domxexpt' `domxmxops', `doscmxops', e `doscmxplus'.

     Existem opções adicionais que são relacionadas a matrizes.  São
     elas: `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix', e `sparse'.

     Existe um número de funções que pegam matrizes como argumentos ou
     devolvem matrizes como valor de retorno.  Veja `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon', e `rank'.

     Exemplos:

        * Construção de matrizes de listas.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Adição, elemento por elemento.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Subtração, elemento por elemento.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplicação, elemento por elemento.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * Divisão, elemento por elemento.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matriz para um expoente escalar, elemento por elemento.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Base escalar para um expoente matriz, elemento por elemento.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Base matriz para um expoente matriz.  Essa não é realizada
          elemento por elemento.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Multiplicação não comutativa de matrizes.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Exponenciação não comutativa de matrizes.  Uma base escalar
          <b> para uma potência matriz <M> é realizada elemento por
          elemento e então `b^^m' é o mesmo que `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * A matriz elevada a um expoente -1 com exponenciação não
          comutativa é a matriz inversa, se existir.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Função: matrixmap (<f>, <M>)
     Retorna uma matriz com elemento `i,j' igual a `<f>(<M>[i,j])'.

     Veja também `map', `fullmap', `fullmapl', e `apply'.


 -- Função: matrixp (<expr>)
     Retorna `true' se <expr> é uma matriz, de outra forma retorna
     `false'.


 -- Variável de opção: matrix_element_add
     Valor padrão: `+'

     `matrix_element_add' é a operação invocada em lugar da adição em
     uma multiplicação de matrizes.  A `matrix_element_add' pode ser
     atribuído qualquer operador n-ário (que é, uma função que manuseia
     qualquer número de argumentos).  Os valores atribuídos podem ser o
     nome de um operador entre aspas duplas, o nome da função, ou uma
     expressão lambda.

     Veja também `matrix_element_mult' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Variável de opção: matrix_element_mult
     Valor padrão: `*'

     `matrix_element_mult' é a operação invocada em lugar da
     multiplicação em uma multiplicação de matrizes.  A
     `matrix_element_mult' pode ser atribuído qualquer operador binário.
     O valor atribuído pode ser o nome de um operador entre aspas
     duplas, o nome de uma função, ou uma expressão lambda.

     O operador do ponto `.' é uma escolha útil em alguns contextos.

     Veja também `matrix_element_add' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Variável de opção: matrix_element_transpose
     Valor padrão: `false'

     `matrix_element_transpose' é a operação aplicada a cada elemento
     de uma matriz quando for uma transposta.  A `matrix_element_mult'
     pode ser atribuído qualquer operador unário.  O valor atribuído
     pode ser  nome de um operador entre aspas duplas, o nome de uma
     função, ou uma expressão lambda.

     Quando `matrix_element_transpose' for igual a `transpose', a
     função  `transpose' é aplicada a todo elemento.  Quando
     `matrix_element_transpose' for igual a `nonscalars', a função
     `transpose' é aplicada a todo elemento não escalar.  Se algum
     elemento é um átomo, a opção `nonscalars' aplica `transpose'
     somente se o átomo for declarado não escalar, enquanto a opção
     `transpose' sempre aplica `transpose'.

     O valor padrão, `false', significa nenhuma operação é aplicada.

     Veja também `matrix_element_add' e `matrix_element_mult'.

     Exemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Função: mattrace (<M>)
     Retorna o traço (que é, a soma dos elementos sobre a diagonal
     principal) da matriz quadrada <M>.

     `mattrace' é chamada por `ncharpoly', uma alternativa para
     `charpoly' do Maxima.

     `load ("nchrpl")' chama essa função.


 -- Função: minor (<M>, <i>, <j>)
     Retorna o <i>, <j> menor do elemento localizado na linha <i>
     coluna <j> da matriz <M>.  Que é <M> com linha <i> e coluna <j>
     ambas removidas.


 -- Função: ncexpt (<a>, <b>)
     Se uma expressão exponencial não comutativa é muito alta para ser
     mostrada como `<a>^^<b>' aparecerá como `ncexpt (<a>,<b>)'.

     `ncexpt' não é o nome de uma função ou operador; o nome somente
     aparece em saídas, e não é reconhecido em entradas.


 -- Função: ncharpoly (<M>, <x>)
     Retorna o polinômio característico da matriz <M> com relação a
     <x>.  Essa é uma alternativa para `charpoly' do Maxima.

     `ncharpoly' trabalha pelo cálculo dos traços das potências na dada
     matriz, que são sabidos serem iguais a somas de potências das
     raízes do polinômio característico.  Para essas quantidade a função
     simétrica das raízes pode ser calculada, que nada mais são que os
     coeficientes do polinômio característico.  `charpoly' trabalha
     formatando o determinante de `<x> * ident [n] - a'.  Dessa forma
     `ncharpoly' é vencedor, por exemplo, no caso de largas e densas
     matrizes preencidas com inteiros, desde que isso evite
     inteiramente a aritmética polinomial.

     `load ("nchrpl")' loads this file.


 -- Função: newdet (<M>, <n>)
     Calcula o determinante de uma matriz ou array <M> pelo algorítmo
     da árvore menor de Johnson-Gentleman.  O argumento <n> é a ordem;
     isso é optional se <M> for uma matriz.


 -- Declaração: nonscalar
     Faz átomos ser comportarem da mesma forma que uma lista ou matriz
     em relação ao operador do ponto.


 -- Função: nonscalarp (<expr>)
     Retorna `true' se <expr> é um não escalar, i.e., isso contém
     átomos declarados como não escalares, listas, ou matrizes.


 -- Função: permanent (<M>, <n>)
     Calcula o permanente da matriz <M>.  Um permanente é como um
     determinante mas sem mudança de sinal.


 -- Função: rank (<M>)
     Calcula o posto da matriz <M>.  Que é, a ordem do mais largo
     determinante não singular de <M>.

     <rank> pode retornar uma resposta ruim se não puder determinar que
     um elemento da matriz que é equivalente a zero é realmente isso.


 -- Variável de opção: ratmx
     Valor padrão: `false'

     Quando `ratmx' é `false', adição, subtração, e multiplicação para
     determinantes e matrizes são executados na representação dos
     elementos da matriz e fazem com que o resultado da inversão de
     matrizes seja esquerdo na representação geral.

     Quando `ratmx' é `true', as 4 operações mencionadas acima são
     executadas na forma CRE e o resultado da matriz inversa é dado na
     forma CRE.  Note isso pode fazer com que os elementos sejam
     expandidos (dependendo da escolha de `ratfac') o que pode não ser
     desejado sempre.


 -- Função: row (<M>, <i>)
     retorna a <i>'ésima linha da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Variável de opção: scalarmatrixp
     Valor padrão: `true'

     Quando `scalarmatrixp' é `true', então sempre que uma matriz 1 x 1
     é produzida como um resultado de cálculos o produto do ponto de
     matrizes é simplificado para um escalar, a saber o elemento
     solitário da matriz.

     Quando `scalarmatrixp' é `all', então todas as matrizes 1 x 1
     serão simplificadas para escalares.

     Quando `scalarmatrixp' é `false', matrizes 1 x 1 não são
     simplificadas para escalares.


 -- Função: scalefactors (<coordinatetransform>)
     Aqui coordinatetransform avalia para a forma [[expresão1,
     expresão2, ...], indeterminação1, indeterminação2, ...], onde
     indeterminação1, indeterminação2, etc.  são as variáveis de
     coordenadas curvilíneas e onde a escolha de componentes
     cartesianas retangulares é dada em termos das coordenadas
     curvilíneas por [expresão1, expresão2, ...].  `coordinates' é
     escolhida para o vetor [indeterminação1, indeterminação2,...], e
     `dimension' é escolhida para o comprimento desse vetor.  SF[1],
     SF[2], ..., SF[DIMENSION] são escohidos para fatores de escala de
     coordenada, e `sfprod' é escohido para o produto desse fatores de
     escala.  Inicialmente, `coordinates' é [X, Y, Z], `dimension' é 3,
     e SF[1]=SF[2]=SF[3]=SFPROD=1, correspondendo a coordenadas
     Cartesianas retangulares 3-dimensional.  Para expandir uma
     expresão dentro de componentes físicos no sistema de coordenadas
     corrente , existe uma função com uso da forma


 -- Função: setelmx (<x>, <i>, <j>, <M>)
     Atribue <x> para o (<i>, <j>)'ésimo elemento da matriz <M>, e
     retorna a matriz alterada.

     `<M> [<i>, <j>]: <x>' tem o mesmo efeito, mas retorna <x> em lugar
     de <M>.


 -- Função: similaritytransform (<M>)
 -- Função: simtran (<M>)
     `similaritytransform' calcula uma transformação homotética da
     matriz `M'.  Isso retorna uma lista que é a saída do comando
     `uniteigenvectors'.  Em adição se o sinalizador `nondiagonalizable'
     é `false' duas matrizes globais `leftmatrix' e `rightmatrix' são
     calculadas.  Essas matrizes possuem a propriedade de `leftmatrix .
     <M> . rightmatrix' é uma matriz diagonal com os autovalores de <M>
     sobre a diagonal.  Se `nondiagonalizable' é `true' as matrizes
     esquerda e direita não são computadas.

     Se o sinalizador `hermitianmatrix' é `true' então `leftmatrix' é o
     conjugado complexo da transposta de `rightmatrix'.  De outra forma
     `leftmatrix' é a inversa de `rightmatrix'.

     `rightmatrix' é a matriz cujas colunas são os autovetores
     unitários de <M>.  Os outros sinalizadores (veja `eigenvalues' e
     `eigenvectors') possuem o mesmo efeito desde que
     `similaritytransform' chama as outras funções no pacote com o
     objetivo de estar habilitado para a forma `rightmatrix'.

     `load ("eigen")' chama essa função.

     `simtran' é um sinônimo para `similaritytransform'.


 -- Variável de opção: sparse
     Valor padrão: `false'

     Quando `sparse' é `true', e se `ratmx' é `true', então
     `determinant' usará rotinas especiais para calcular determinantes
     esparsos.


 -- Função: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Função: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Função: submatrix (<M>, <j_1>, ..., <j_n>)
     Retorna uma nova matriz formada pela matrix <M> com linhas <i_1>,
     ..., <i_m> excluídas, e colunas <j_1>, ..., <j_n> excluídas.


 -- Função: transpose (<M>)
     Retorna a transposta de <M>.

     Se <M> é uma matriz, o valor de retorno é outra matriz <N> tal que
     `N[i,j] = M[j,i]'.

     De outra forma <M> é uma lista, e o valor de retorno é uma matriz
     <N> de `length (m)' linhas e 1 coluna, tal que `N[i,1] = M[i]'.


 -- Função: triangularize (<M>)
     Retorna a maior forma triangular da matriz `M', como produzido
     através da eliminação de Gauss.  O valor de retorno é o mesmo que
     `echelon', exceto que o o coeficiente lider não nulo em cada linha
     não é normalizado para 1.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Função: uniteigenvectors (<M>)
 -- Função: ueivects (<M>)
     Calcula autovetores unitários da matriz <M>.  O valor de retorno é
     uma lista de listas, a primeiro sublista é a saída do comando
     `eigenvalues', e as outras sublistas são os autovetores unitários
     da matriz correspondente a esses autovalores respectivamente.

     Os sinalizadores mencionados na descrição do comando
     `eigenvectors' possuem o mesmo efeito aqui também.

     Quando `knowneigvects' é `true', o pacote `eigen' assume que os
     autovetores da matriz são conhecidos para o usuário são
     armazenados sob o nome global `listeigvects'.  `listeigvects' pode
     ser ecolhido para uma lista similar à saída do comando
     `eigenvectors'.

     Se `knowneigvects' é escolhido para `true' e a lista de
     autovetores é dada a escolha do sinalizador `nondiagonalizable'
     pode não estar correta.  Se esse é o caso por favor ecolha isso
     para o valor correto.  O autor assume que o usuário sabe o que
     está fazendo e que não tentará diagonalizar uma matriz cujos
     autovetores não alcançam o mesmo espaço vetorial de dimensão
     apropriada.

     `load ("eigen")' chama essa função.

     `ueivects' é um sinônimo para `uniteigenvectors'.


 -- Função: unitvector (<x>)
 -- Função: uvect (<x>)
     Retorna <x>/norm(<x>); isso é um vetor unitário na mesma direção
     que <x>.

     `load ("eigen")' chama essa função.

     `uvect' é um sinônimo para `unitvector'.


 -- Função: vectorsimp (<expr>)
     Aplica simplificações e expansões conforme os seguintes
     sinalizadores globais:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus', e `expandlaplacianprod'.

     Todos esses sinalizadores possuem valor padrão `false'.  O sufixo
     `plus' refere-se a utilização aditivamente ou distribuitivamente.
     O sufixo `prod' refere-se a expansão para um operando que é
     qualquer tipo de produto.

    `expandcrosscross'
          Simplifica p ~ (q ~ r) para (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifica curl curl p para grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifica laplacian p para div grad p.

    `expandcross'
          Habilita `expandcrossplus' e `expandcrosscross'.

    `expandplus'
          Habilita `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', e `expandlaplacianplus'.

    `expandprod'
          Habilita `expandgradprod', `expanddivprod', e
          `expandlaplacianprod'.

     Esses sinalizadores foram todos declarados `evflag'.


 -- Variável de opção: vect_cross
     Valor padrão: `false'

     Quando `vect_cross' é `true', isso permite DIFF(X~Y,T) trabalhar
     onde ~ é definido em SHARE;VECT (onde VECT_CROSS é escolhido para
     `true', de qualqeur modo.)


 -- Função: zeromatrix (<m>, <n>)
     Retorna um matriz <m> por <n>, com todos os elementos sendo zero.


 -- Símbolo especial: [
 -- Símbolo especial: ]
     `[' e `]' marcam o omeço e o fim, respectivamente, de uma lista.

     `[' e `]' também envolvem os subscritos de uma lista, array, array
     desordenado, ou função array.

     Exemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Funções Afins,  Next: itensor,  Prev: Matrizes e Álgebra Linear,  Up: Top

27 Funções Afins
****************

* Menu:

* Definições para Funções Afins::


File: maxima.info,  Node: Definições para Funções Afins,  Prev: Funções Afins,  Up: Funções Afins

27.1 Definições para Funções Afins
==================================

 -- Função: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resolve equações lineares simultâneas <expr_1>, ..., <expr_m> para
     as variáveis <x_1>, ..., <x_n>.  Cada <expr_i> pode ser uma
     equação ou uma expressão geral; se dada como uma expressão geral,
     ela  tratada como uma equação na forma `<expr_i> = 0'.

     O valor de retorno é uma lista de equações da forma `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' onde <a_1>, ..., <a_n> são todas
     livres de <x_1>, ..., <x_n>.

     `fast_linsolve' é mais rápido que `linsolve' para sistemas de
     equações que são esparsas.


 -- Função: grobner_basis ([<expr_1>, ..., <expr_m>])
     Retorna uma base de Groebner para as equações <expr_1>, ...,
     <expr_m>.  A funçã `polysimp' pode então ser usada para
     simplificar outras funções relativas às equações.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' produz 0 se e somente se <f> está no ideal gerado por
     <expr_1>, ..., <expr_m>, isto é, se e somente se <f> for uma
     combinação polinomial dos elementos de <expr_1>, ..., <expr_m>.


 -- Função: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Função: set_up_dot_simplifications (<eqns>)
     As <eqns> são equações polinomiais em variáveis não comutativas.
     O valor de `current_variables'  é uma lista de variáveis usadas
     para calcular graus.  As equações podem ser homogêneas, em ordem
     para o procedimento terminar.

     Se você checou simplificações de envoltório em
     `dot_simplifications' acima do grau de <f>, então o seguinte é
     verdadeiro: `dotsimp (<f>)' retorna 0 se e somente se <f> está no
     ideal gerado pelas equações, i.e., se e somente se <f> for uma
     combinação polinomial dos elementos das equações.

     acima do grau de f, então o seguinte é verdadeiro: `dotsimp (f)'
     retorna 0 se e somente se <f> está no ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.

     O grau é aquele retornado por `nc_degree'.   Isso por sua vez é
     nfluenciado pelos pesos das variáveis individuais.


 -- Função: declare_weight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Atribui pesos <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectivamente.  Esses são pesos usados em cálculos `nc_degree'.


 -- Função: nc_degree (<p>)
     Retorna o grau de um polinômio não comutativo <p>.  Veja
     `declare_weights'.


 -- Função: dotsimp (<f>)
     Retorna 0 se e somente se <f> for um ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.


 -- Função: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Se `set_up_dot_simplifications' tiver sido feito previamente, ache
     o polinômio central nas variáveis <x_1>, ..., <x_n> no grau dado,
     <n>.

     Por exemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];


 -- Função: check_overlaps (<n>, <add_to_simps>)
     Verifica as sobreposies através do grau <n>, tendo certeza que
     você tem regras de simplificaçõ suficiente em cada grau, para
     `dotsimp' trabalhar corretamente.  Esse processo pode ter sua
     velocidade aumentada se você souber antes de começar souber de
     qual dimensão do espaço de monômios é.  Se ele for de dimensão
     global finita, então `hilbert' pode ser usada.  Se você não
     conhece as dimensões monomiais, não especifique um `rank_function'.
     Um opcional terceiro argumento `reset', `false' diz para não se
     incomodar em perguntar sobre resetar coisas.


 -- Função: mono ([<x_1>, ..., <x_n>], <n>)
     Retorna a lista de monômios independentes relativamente à
     simplificação atual do grau <n> nas variáveis <x_1>, ..., <x_n>.


 -- Função: monomial_dimensions (<n>)
     Calcula a série de Hilbert através do grau <n> para a algebra
     corrente.


 -- Função: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>, ...,
          <m_n>])
     Faz uma lista dos coeficientes dos polinômios não comutativos
     <p_1>, ..., <p_n> dos monomios não comutatvos <m_1>, ..., <m_n>.
     Os coeficientes podem ser escalares.   Use `list_nc_monomials'
     para construir a lista dos monômios.


 -- Função: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Função: list_nc_monomials (<p>)
     Retorna uma lista de monômios não comutativos que ocorrem em um
     polinômio <p> ou em uma lista de polinômios <p_1>, ..., <p_n>.


 -- Variável de opção: all_dotsimp_denoms
     Valor padrão: `false'

     Quando `all_dotsimp_denoms' é uma lista, os denominadores
     encontrados por `dotsimp' são adicionados ao final da lista.
     `all_dotsimp_denoms' pode ser iniciado como uma lista vazia `[]'
     antes chamando `dotsimp'.

     Por padrão, denominadores não são coletados por `dotsimp'.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Funções Afins,  Up: Top

28 itensor
**********

* Menu:

* Introdução a itensor::
* Definições para itensor::


File: maxima.info,  Node: Introdução a itensor,  Next: Definições para itensor,  Prev: itensor,  Up: itensor

28.1 Introdução a itensor
=========================

Maxima implementa a manipulação de tensores simbólicos d dois tipos
distintos: manipulação de componentes de tensores (pacote `ctensor') e
manipulação de tensores indiciais (pacote `itensor').

   Note bem: Por favor veja a nota sobre 'nova notação de tensor'
abaixo.

   Manipulação de componentes de tensores significa que objetos do tipo
tensor geométrico são representados como arrays ou matrizes. Operações
com tensores tais com contração ou diferenciação covariante são
realizadas sobre índices (que ocorrem exatamente duas vezes) repetidos
com declarações `do'.  Isto é, se executa explicitamente operações
sobre as componentes apropriadas do tensor armazenadas em um array ou
uma matriz.

   Manipulação tensorial de índice é implementada através da
representação de tensores como funções e suas covariantes,
contravariantes e índices de derivação. Operações com tensores como
contração ou diferenciação covariante são executadas através de
manipulação dos índices em si mesmos em lugar das componentes para as
quais eles correspondem.

   Esses dois métodos aproximam-se do tratamento de processos
diferenciais, algébricos e analíticos no contexto da geometria de
Riemannian possuem várias vantagens e desvantagens as quais se revelam
por si mesmas somente apesar da natureza particular e dificuldade dos
problemas de usuário.  Todavia, se pode ter em mente as seguintes
características das duas implementações:

   As representações de tensores e de operações com tensores
explicitamente em termos de seus componntes tornam o pacote `ctensor'
fácil de usar. Especificação da métrica e o cálculo de tensores
induzidos e invariantes é direto. Embora todas a capacidade de
simplificação poderosa do Maxima está em manusear, uma métrica complexa
com intrincada dependência funcional e de coordenadas pode facilmente
conduzir a expressões cujo tamanho é excessivo e cuja estrutura está
escondida. Adicionalmente, muitos cálculos envolvem expressões
intermediárias cujo crescimento fazem com que os programas terminem
antes de serem completados. Através da experiência, um usuário pode
evitar muitas dessas dificuldade.

   O motivo de caminhos especiais através dos quais tensores e
operações de tensores são representados em termos de operações
simbólicas sobre seus índices, expressões cujas representação de
componentes podem ser não gerenciaveis da forma comum podem algumas
vezes serem grandemente simplificadas através do uso das rotinas
especiais para objetos simétricos em `itensor'. Nesse caminho a
estrutura de uma expressão grande pode ser mais transparente. Por outro
lado, o motivo da representação indicial especial em `itensor', faz com
que em alguns casos o usuário possa encontrar dificuldade com a
especificação da métrica, definição de função, e a avaliação de objetos
"indexados" diferenciados.

28.1.1 Nova notação d tensores
------------------------------

Até agora, o pacote `itensor' no Maxima tinha usado uma notação que
algumas vezes conduzia a ordenação incorreta de índices. Considere o
seguinte, por exemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   O resultado está incorreto a menos que ocorra ser `a' um tensor
simétrico.  A razão para isso é que embora `itensor' mantenha
corretamente a ordem dentro do conjunto de índices covariantes e
contravariantes, assim que um índice é incrementado ou decrementado,
sua posição relativa para o outro conjunto de índices é perdida.

   Para evitar esse problema, uma nova notação tem sido desenvolvida
que mantém total compatibilidade com a notação existente e pode ser
usada intercambiavelmente. Nessa notação, índices contravariantes são
inseridos na posição apropriada na lista de índices covariantes, mas
com um sinal de menos colocado antes.  Funções como `contract' e
`ishow' estão agora consciente dessa nova notação de índice e podem
processar tensores apropriadamente.

   Nessa nova notação, o exemplo anterior retorna um resultado correto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   Presentemente, o único código que faz uso dessa notação é a função
`lc2kdt'. Através dessa notação, a função `lc2kdt' encontra com êxito
resultados consistentes como a aplicação do tensor métrico para
resolver os símbolos de Levi-Civita sem reordenar para índices
numéricos.

   Uma vez que esse código é um tipo novo, provavelmente contém erros.
Enquanto esse tipo novo não tiver sido testado para garantir que ele
não interrompe nada usando a "antiga" notação de tensor, existe uma
considerável chance que "novos" tensores irão falhar em interoperar com
certas funções ou recursos. Essas falhas serão corrigidas à medida que
forem encontradas... até então, seja cuidadoso!

28.1.2 Manipulação de tensores indiciais
----------------------------------------

o pacote de manipulação de tensores indiciais pode ser chamado através
de `load(itensor)'. Demonstações estão também disponíveis: tente
`demo(tensor)'.  Em `itensor' um tensor é representado como um "objeto
indexado" .  Um "objeto indexado" é uma função de 3 grupos de índices
os quais representam o covariante, o contravariante e o índice de
derivação.  Os índices covariantes são especificados através de uma
lista com o primeiro argumento para o objeto indexado, e os índices
contravariantes através de uma lista como segundo argumento. Se o
objeto indexado carece de algum desses grupos de índices então a lista
vazia `[]' é fornecida como o argumento correspondente.  Dessa forma,
`g([a,b],[c])' representa um objeto indexado chamado `g' o qual tem
dois índices covariantes `(a,b)', um índice contravariante (`c') e não
possui índices de derivação.

   Os índices de derivação, se estiverem presente, são anexados ao
final como argumentos adicionais para a função numérica representando o
tensor.  Eles podem ser explicitamente especificado pelo usuário ou
serem criados no processo de diferenciação com relação a alguma
variável coordenada.  Uma vez que diferenciação ordinária é comutativa,
os índices de derivação são ordenados alfanumericamente, a menos que
`iframe_flag' seja escolhida para `true', indicando que uma moldura
métrica está sendo usada. Essa ordenação canônica torna possível para
Maxima reconhecer que, por exemplo, `t([a],[b],i,j)' é o mesmo que
`t([a],[b],j,i)'.  Diferenciação de um objeto indexado com relação a
alguma coordenada cujos índices não aparecem como um argumento para o
objeto indexado podem normalmente retornar zero. Isso é porque Maxima
pode não saber que o tensor representado através do objeto indexado
possívelmente depende implicitamente da respectiva coordenada.  Pela
modificação da função existente no Maxima, `diff',  em `itensor',
Maxima sabe assumir que todos os objetos indexados dependem de qualquer
variável de diferenciação a menos que seja declarado de outra forma.
Isso torna possível para a convençào de somatório ser extendida para
índices derivativos. Pode ser verificado que `itensor' não possui a
compatibilidade de incrementar índices derivativos, e então eles são
sempre tratados como covariantes.

   As seguintes funções estão disponíveis no pacote tensor para
manipulação de objetos.  Atualmente, com relação às rotinas de
simplificação, é assumido que objetos indexados não possuem por padrão
propriedades simétricas. Isso pode ser modificado através da escolha da
variável `allsym[false]' para `true', o que irá resultar no tratamento
de todos os objetos indexados completamente simétricos em suas listas
de índices covariantes e simétricos em suas listas de índices
contravariantes.

   O pacote `itensor' geralmente trata tensores como objetos opacos.
Equações tensoriais são manipuladas baseadas em regras algébricas,
especificamente simetria e regras de contração. Adicionalmente, o
pacote `itensor' não entende diferenciação covariante, curvatura, e
torsão. Cálculos podem ser executados relativamente a um métrica de
molduras de movimento, dependendo da escolha para a variável
`iframe_flag'.

   Uma sessão demonstrativa abaixo mostra como chamar o pacote
`itensor', especificando o nome da métrica, e executando alguns
cálculos simples.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Definições para itensor,  Prev: Introdução a itensor,  Up: itensor

28.2 Definições para itensor
============================

28.2.1 Gerenciando objetos indexados
------------------------------------

 -- Função: entertensor (<nome>)
     É uma função que, através da linha de comando, permite criar um
     objeto indexado chamado <nome> com qualquer número de índices de
     tensores e derivativos. Ou um índice simples ou uma lista de
     índices (às quais podem ser nulas) são entradas aceitáveis (veja o
     exemplo sob `covdiff').


 -- Função: changename (<antigo>, <novo>, <expr>)
     Irá mudar o nome de todos os objetos indexados chamados <antigo>
     para <novo> em <expr>. <antigo> pode ser ou um símbolo ou uma
     lista da forma `[<nome>, <m>, <n>]' nesse caso somente esses
     objetos indexados chamados <nome> com índice covariante <m> e
     índice contravariante <n> serão renomeados para <novo>.


 -- Função: listoftens
     Lista todos os tensores em uma expressão tensorial, incluindo seus
     índices. E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Função: ishow (<expr>)
     Mostra <expr> com os objetos indexados tendo seus índices
     covariantes como subscritos e índices contravariantes como
     sobrescritos.  Os índices derivativos são mostrados como
     subscritos, separados dos índices covariantes por uma vírgula
     (veja os exemplos através desse documento).


 -- Função: indices (<expr>)
     Retorna uma lista de dois elementos.  O primeiro é uma lista de
     índices livres em <expr> (aqueles que ocorrem somente uma vez). O
     segundo é uma lista de indices que ocorrem exatamente duas vezes
     em <expr> (dummy) como demonstra o seguinte exemplo.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     Um produto de tensores contendo o mesmo índice mais que duas vezes
     é sintaticamente ilegal. `indices' tenta lidar com essas
     expressões de uma forma razoável; todavia, quando `indices' é
     chamada para operar sobre tal uma expressão ilegal, seu
     comportamento pode ser considerado indefinido.


 -- Função: rename (<expr>)
 -- Função: rename (<expr>, <contador>)
     Retorna uma expressão equivalente para <expr> mas com índices que
     ocorrem exatamente duas vezes em cada termo alterado do conjunto
     `[%1, %2,...]', se o segundo argumento opcional for omitido. De
     outra forma, os índices que ocorrem exatamente duas vezes são
     indexados começando no valor de <contador>.  Cada índice que
     ocorre exatamente duas vezes em um produto será diferente. Para
     uma adição, `rename' irá operar sobre cada termo na a adição
     zerando o contador com cada termo. Nesse caminho `rename' pode
     servir como um simplificador tensorial. Adicionalmente, os índices
     serão ordenados alfanumericamente (se `allsym' for `true') com
     relação a índices covariantes ou contravariantes dependendo do
     valor de `flipflag'.  Se `flipflag' for `false' então os índices
     serão renomeados conforme a ordem dos índices contravariantes. Se
     `flipflag' for `true' a renomeação ocorrerá conforme a ordem dos
     índices covariantes. Isso muitas vezes ajuda que o efeito
     combinado dos dois restantes sejam reduzidos a uma expressão de
     valor um ou mais que um por si mesma.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7


 -- Variável de Opção: flipflag
     Valor padrão: `false'. Se `false' então os índices irão ser
     renomeados conforme a ordem dos índices contravariantes, de outra
     forma serão ordenados conforme a ordem dos índices covariantes.

     Se `flipflag' for `false' então `rename' forma uma lista de
     índices contravariantes na ordem em que forem encontrados da
     esquerda para a direita (se `true' então de índices
     contravariantes). O primeiro índice que ocorre exatamente duas
     vezes na lista é renomeado para `%1', o seguinte para `%2', etc.
     Então a ordenação ocorre após a ocorrência do `rename' (veja o
     exemplo sob `rename').


 -- Função: defcon (<tensor_1>)
 -- Função: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Dado <tensor_1> a propriedade que a contração de um produto do
     <tensor_1> e do <tensor_2> resulta em <tensor_3> com os índices
     apropriados.  Se somente um argumento, <tensor_1>, for dado, então
     a contração do produto de <tensor_1> com qualquer objeto indexado
     tendo os índices apropriados (digamos `my_tensor') irá retornar
     como resultado um objeto indexado com aquele nome, i.e.
     `my_tensor', e com uma nova escolha de índices refletindo as
     contrações executadas.  Por exemplo, se `imetric:g', então
     `defcon(g)' irá implementar o incremento e decremento de índices
     através da contração com o tensor métrico.  Mais de uma `defcon'
     pode ser dada para o mesmo objeto indexado; o último  fornecido
     que for aplicado a uma contração particular irá ser usado.
     `contractions' é uma lista de objetos indexados que tenham
     fornecido propriedades de contrações com `defcon'.


 -- Função: remcon (<tensor_1>, ..., <tensor_n>)
 -- Função: remcon (all)
     Remove todas as propriedades de contração de <tensor_1>, ...,
     <tensor_n>). `remcon(all)' remove todas as propriedades de
     contração de todos os objetos indexados.


 -- Função: contract (<expr>)
     Realiza contrações tensoriais em <expr> a qual pode ser qualquer
     combinação de adições e produtos. Essa função usa a informação
     dada para a função `defcon'. Para melhores resultados, `expr' pode
     ser completamente expandida. `ratexpand' é o meio mais rápido para
     expandir produtos e expoentes de adições se não existirem
     variáveis nos denominadores dos termos. O comutador `gcd' pode ser
     `false' se cancelamentos de máximo divisor comum forem
     desnecessários.


 -- Função: indexed_tensor (<tensor>)
     Deve ser executada antes de atribuir componentes para um <tensor>
     para o qual um valor interno já existe como com `ichr1', `ichr2',
     `icurvature'. Veja o exemplo sob `icurvature'.


 -- Função: components (<tensor>, <expr>)
     Permite que se atribua um valor indicial a uma expressão <expr>
     dando os valores das componentes do <tensor>. Esses são
     automaticamente substituídos para o tensor mesmo que isso ocorra
     com todos os seus índices. O tensor deve ser da forma
     `t([...],[...])' onde qualquer lista pode ser vazia. <expr> pode
     ser qualquer expressão indexada envolvendo outros objetos com os
     mesmos índices livres que <tensor>. Quando usada para atribuir
     valores a um tensor métrico no qual as componentes possuem índices
     que ocorrem exatamente duas vezes se deve ser cuidadoso para
     definir esses índices de forma a evitar a geração de índices que
     ocorrem exatamente duas vezes e que são multiplos. a remoção dessas
     atribuições é dada para a função `remcomps'.

     É importante ter em mente que `components' cuida somente da
     valência de um tensor, e que ignora completamente qualquer
     ordenação particular de índices. Dessa forma atribuindo
     componentes a, digamos, `x([i,-j],[])', `x([-j,i],[])', ou
     `x([i],[j])' todas essas atribuições produzem o mesmo resultado, a
     saber componentes sendo atribuidas a um tensor chamado `x' com
     valência `(1,1)'.

     Componentes podem ser atribuidas a uma expressão indexada por
     quatro caminhos, dois dos quais envolvem o uso do comando
     `components':

     1) Como uma expressão indexada. Por exemplo:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Como uma matriz:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Como uma função. Você pode usar uma função Maxima para
     especificar as componentes de um tensor baseado nesses índices.
     Por exemplo, os seguintes códigos atribuem `kdelta' a `h' se `h'
     tiver o mesmo número de índices covariantes e índices
     contravariantes e nenhum índice derivativo, e atribui `kdelta' a
     `g' caso as condições anteriores não sejam atendidas:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Usando a compatibilidade dos modelos de coincidência do Maxima,
     especificamente os comandos `defrule' e `applyb1':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Função: remcomps (<tensor>)
     Desassocia todos os valores de <tensor> que foram atribuídos com a
     função `components'.


 -- Função: showcomps (<tensor>)
     Mostra atribuições de componentes de um tensor, feitas usando o
     comando `components'. Essa função pode ser particularmente útil
     quando uma matriz é atribuída a um tensor indicial usando
     `components', como demonstrado através do seguinte exemplo:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     O comando `showcomps' pode também mostrar componentes de um tensor
     de categoria maior que 2.


 -- Função: idummy ()
     Incrementos `icounter' e retorno como seu valor um índice da forma
     `%n' onde n é um inteiro positivo.  Isso garante que índices que
     ocorrem exatamente duas vezes e que são necessários na formação de
     expressões não irão conflitar com índices que já estiverem sendo
     usados (veja o exemplo sob `indices').


 -- Variável de opção: idummyx
     Valor padrão: `%'

     É o prefixo para índices que ocorrem exatamente duas vezes (veja o
     exemplo sob índices `indices').


 -- Variável de Opção: icounter
     Valor padrão: `1'

     Determina o sufixo numérico a ser usado na geração do próximo
     índice que ocorre exatamente duas vezes no pacote tensor.  O
     prefixo é determinado através da opção `idummy' (padrão: `%').

 -- Função: kdelta (<L1>, <L2>)
     é a função delta generalizada de Kronecker definida no pacote
     `itensor' com <L1> a lista de índices covariantes e <L2> a lista
     de índices contravariantes.  `kdelta([i],[j])' retorna o delta de
     Kronecker comum.  O comando `ev(<expr>,kdelta)' faz com que a
     avaliação de uma expressão contendo `kdelta([],[])' se dê para a
     dimensão de multiplicação.

     No que conduzir a um abuso dessa notação, `itensor' também permite
     `kdelta' ter 2 covariantes e nenhum contravariante, ou 2
     contravariantes e nenhum índice covariante, com efeito fornecendo
     uma compatibilidade para "matriz unitária" covariante ou
     contravariante. Isso é estritamente considerado um recurso de
     programação e não significa implicar que `kdelta([i,j],[])' seja
     um objeto tensorial válido.


 -- Função: kdels (<L1>, <L2>)
     Delta de Kronecker simetrizado, usado em alguns cálculos. Por
     exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Função: levi_civita (<L>)
     é o tensor de permutação (ou de Levi-Civita) que retorna 1 se a
     lista <L> consistir de uma permutação par de inteiros, -1 se isso
     consistir de uma permutação ímpar, e 0 se alguns índices em <L>
     forem repetidos.


 -- Função: lc2kdt (<expr>)
     Simplifica expressões contendo os símbolos de Levi-Civita,
     convertendo esses para expressões delta de Kronecker quando
     possível. A principal diferença entre essa função e simplesmente
     avaliar os simbolos de Levi-Civita é que a avaliação direta muitas
     vezes resulta em expressões Kronecker contendo índices numéricos.
     Isso é muitas vezes indesejável como na prevenção de simplificação
     adicional.  A função `lc2kdt' evita esse problema, retornando
     expressões que são mais facilmente simplificadas com `rename' ou
     `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     A função `lc2kdt' algumas vezes faz uso de tensores métricos.  Se
     o tensor métrico não tiver sido definido previamente com `imetric',
     isso resulta em um erro.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g


 -- Função: lc_l
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0


 -- Função: lc_u
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Para detalhes,
     veja `lc_l'.


 -- Função: canten (<expr>)
     Simplifica <expr> por renomeação (veja `rename') e permutando
     índices que ocorrem exatamente duas vezes. `rename' é restrito a
     adições de produto de tensores nos quais nenhum índice derivativo
     estiver presente. Como tal isso é limitado e pode somente ser
     usado se `canform' não for capaz de realizar a simplificação
     requerida.

     A função `canten' retorna um resultado matematicamente correto
     somente se seu argumento for uma expressão que é completamente
     simétrica em seus índices.  Por essa razão, `canten' retorna um
     erro se `allsym' não for posicionada em `true'.


 -- Função: concan (<expr>)
     Similar a `canten' mas também executa contração de índices.


28.2.2 Simetrias de tensores
----------------------------

 -- Variável de Opção: allsym
     Valor padrão: `false'. Se `true' então todos os objetos indexados
     são assumidos simétricos em todos os seus índices covariantes e
     contravariantes. Se `false' então nenhum simétrico de qualquer
     tipo é assumidos nesses índices. Índices derivativos são sempre
     tomados para serem simétricos a menos que `iframe_flag' seja
     escolhida para `true'.


 -- Função: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declara propriedades de simetria para <tensor> de covariante <m> e
     <n> índices contravariantes. As <cov_i> e <contr_i> são
     pseudofunções expressando relações de simetrias em meio a índices
     covariante e índices contravariantes respectivamente.  Esses são
     da forma `symoper(<index_1>, <index_2>,...)' onde `symoper' é um
     entre `sym', `anti' ou `cyc' e os <index_i> são inteiros indicando
     a posição do índice no <tensor>.  Isso irá declarar <tensor> para
     ser simétrico, antisimétrico ou cíclico respectivamente nos
     <index_i>. `symoper(all)' é também forma permitida que indica
     todos os índices obedecem à condição de simetria. Por exemplo,
     dado um objeto `b' com 5 índices covariantes,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declara `b'
     simétrico no seu primeiro e no seu segundo índices e antisimétrico
     no seu terceiro e quarto índices covariantes, e cíclico em todos
     de seus índices contravariantes.  Qualquer lista de declarações de
     simetria pode ser nula.  A função que executa as simplificações é
     `canform' como o exemplo abaixo ilustra.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Função: remsym (<tensor>, <m>, <n>)
     Remove todas as propriedades de simetria de <tensor> que tem <m>
     índices covariantes e <n> índices contravariantes.

 -- Função: canform (<expr>)
     Simplifica <expr> através de mudança de nome de índices que
     ocorrem exatamente duas vezes e reordenação de todos os índices
     como ditados pelas condições de simetria impostas sobre eles. Se
     `allsym' for `true' então todos os índices são assumidos
     simétricos, de outra forma a informação de simetria fornecida
     pelas declarações `decsym' irão ser usadas. Os índices que ocorrem
     exatamente duas vezes são renomeados da mesma maneira que na
     função `rename'. Quando `canform' é aplicada a uma expressão larga
     o cálculo pode tomar um considerável montante de tempo.  Esse
     tempo pode ser diminuído através do uso de `rename' sobre a
     expressão em primeiro lugar.  Também veja o exemplo sob `decsym'.
     Nota: `canform' pode não estar apta a reduzir um expressão
     completamente para sua forma mais simples embora retorne sempre um
     resultado matemáticamente correto.

28.2.3 Cálculo de tensores indiciais
------------------------------------

 -- Função: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     É a função usual de diferenciação do Maxima que tem sido expandida
     nessas habilidades para `itensor'. `diff' toma a derivada de <expr>
     <n_1> vezes com relação a <v_1>, <n_2> vezes com relação a <v_2>
     , etc. Para o pacote `tensor', a função tem sido modificada de
     forma que os <v_i> possam ser inteiros de 1 até o valor da variável
     `dim'.  Isso causará a conclusão da diferenciação com relação ao
     <v_i>ésimo membro da lista `vect_coords'.  Se `vect_coords' for
     associado a uma variável atômica, então aquela variável subscrita
     através de <v_i> irá ser usada para a variável de diferenciação.
     Isso permite que um array de nomes de coordenadas ou nomes
     subscritos como `x[1]', `x[2]', ...  sejam usados.

 -- Função: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Diferenciação indicial. A menos que `diff', que diferencia com
     relação a uma variável independente, `idiff' possa ser usada para
     diferenciar com relação a uma coordenada. Para um objeto indexado,
     isso equivale a anexar ao final os <v_i> como índices derivativos.
     Subseqüêntemente, índices derivativos irão ser ordenados, a menos
     que `iframe_flag' seja escolhida para `true'.

     `idiff' pode também ser o determinante de um tensor métrico. Dessa
     forma, se `imetric' tiver sido associada a `G' então
     `idiff(determinant(g),k)' irá retornar
     `2*determinant(g)*ichr2([%i,k],[%i])' onde o índice que ocorre
     exatamente duas vezes `%i' é escolhido apropriadamente.


 -- Função: liediff (<v>, <ten>)
     Calcula a derivada de Lie da expressão tensorial <ten> com relação
     ao campo vetorial <v>. <ten> pode ser qualquer expressão tensorial
     indexada; <v> pode ser o nome (sem índices) de um campo vetorial.
     Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Função: rediff (<ten>)
     Avalia todas as ocorrências do comando `idiff' na expressão
     tensorial <ten>.


 -- Função: undiff (<expr>)
     Retorna uma expressão equivalente a <expr> mas com todas as
     derivadas de objetos indexados substituídas pela forma substantiva
     da função `idiff'. Seu argumento pode retornar aquele objeto
     indexado se a diferenciação for concluída.  Isso é útil quando for
     desejado substituir um objeto indexado que sofreu diferenciação
     com alguma definição de função resultando em <expr> e então
     concluir a diferenciação através de digamos `ev(<expr>, idiff)'.


 -- Função: evundiff (<expr>)
     Equivalente à execução de `undiff', seguida por `ev' e `rediff'.

     O ponto dessa operação é facilmente avaliar expressões que não
     possam ser diretamente avaliadas na forma derivada. Por exemplo, o
     seguinte causa um erro:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Todavia, se `icurvature' é informado em sua forma substantiva,
     pode ser avaliado usando `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j

     Nota: Em versões anteriores do Maxima, formas derivadas dos
     símbolos de Christoffel também não podiam ser avaliadas. Isso foi
     corrigido atualmente, de forma que `evundiff' não mais é
     necessária para expressões como essa:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2


 -- Função: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que não tiverem índices derivativos.


 -- Função: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que tiverem índices derivativos.


 -- Função: flushnd (<expr>, <tensor>, <n>)
     Escolhe para zero, em <expr>, todas as ocorrências do objeto
     diferenciado <tensor> que tem <n> ou mais índices derivativos como
     demonstra o seguinte exemplo.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Função: coord (<tensor_1>, <tensor_2>, ...)
     Dados os <tensor_i> a propriedade de diferenciação da coordenada
     que a derivada do vetor contravariante cujo nome é um dos
     <tensor_i> retorna um delta de Kronecker. Por exemplo, se
     `coord(x)' tiver sido concluída então `idiff(x([],[i]),j)' fornece
     `kdelta([i],[j])'.  `coord' que é uma lista de todos os objetos
     indexados tendo essa propriedade.


 -- Função: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Função: remcoord (all)
     Remove a propriedade de coordenada de diferenciação dos `tensor_i'
     que foram estabelecidos através da função `coord'.  `remcoord(all)'
     remove essa propriedade de todos os objetos indexados.


 -- Função: makebox (<expr>)
     Mostra <expr> da mesma maneira que `show'; todavia, qualquer
     tensor d'Alembertiano ocorrendo em <expr> irá ser indicado usando o
     símbolo `[]'.  Por exemplo, `[]p([m],[n])' representa
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Função: conmetderiv (<expr>, <tensor>)
     Simplifica expressões contendo derivadas comuns de ambas as formas
     covariantes e contravariantes do tensor métrico (a restrição
     corrente).  Por exemplo, `conmetderiv' pode relatar a derivada do
     tensor contravariante métrico com símbolos de Christoffel como
     visto adiante:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Função: simpmetderiv (<expr>)
 -- Função: simpmetderiv (<expr>[, <stop>])
     Simplifica expressões contendo produtos de derivadas de tensores
     métricos. Especificamente, `simpmetderiv' reconhece duas
     identidades:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     conseqüêntemente


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     e


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     que seguem de simetrias de símbolos de Christoffel.

     A função `simpmetderiv' toma um parâmetro opcional que, quando
     presente, faz com que a função pare após a primeira substituição
     feita com sucesso em uma expressão produto. A função `simpmetderiv'
     também faz uso da variável global <flipflag> que determina como
     aplicar uma ordenação "canonica" para os índices de produto.

     Colocados juntos, essas compatibilidades podem ser usadas
     poderosamente para encontrar simplificações que são difíceis ou
     impossíveis de realizar de outra forma.  Isso é demonstrado
     através do seguinte exemplo que explicitamente usa o recurso de
     simplificação parcial de `simpmetderiv' para obter uma expressão
     contractível:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Veja também `weyl.dem' para um exemplo que usa `simpmetderiv' e
     `conmetderiv' juntos para simplificar contrações do tensor de Weyl.


 -- Função: flush1deriv (<expr>, <tensor>)
     Escolhe para zero, em `expr', todas as ocorrências de `tensor' que
     possuem exatamente um índice derivativo.


28.2.4 Tensores em espaços curvos
---------------------------------

 -- Função: imetric (<g>)
 -- Variável de sistema: imetric
     Especifica a métrica através de atribuição à variável `imetric:<g>'
     adicionalmente, as propriedades de contração da métrica <g> são
     escolhidas através da execução dos comandos
     `defcon(<g>),defcon(<g>,<g>,kdelta)'.  A variável `imetric'
     (desassociada por padrão), é associada à métrica, atribuida pelo
     comando `imetric(<g>)'.


 -- Função: idim (<n>)
     Escolhe as dimensões da métrica. Também inicializa as propriedades
     de antisimetria dos símbolos de Levi-Civita para as dimensões
     dadas.


 -- Função: ichr1 ([<i>, <j>, <k>])
     Retorna o símbolo de Christoffel de primeiro tipo via definição
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     Para avaliar os símbolos de Christoffel para uma métrica
     particular, à variável `imetric' deve ser atribuída um nome como
     no exemplo sob `chr2'.


 -- Função: ichr2 ([<i>, <j>], [<k>])
     Retorna o símbolo de Christoffel de segundo tipo definido pela
     relação
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Função: icurvature ([<i>, <j>, <k>], [<h>])
     Retorna o tensor da curvatura de Riemann em termos de símbolos de
     Christoffel de segundo tipo (`ichr2').  A seguinte notação é usada:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Função: covdiff (<expr>, <v_1>, <v_2>, ...)
     Retorna a derivada da covariante de <expr> com relação às
     variáveis <v_i> em termos de símbolos de Christoffel de segundo
     tipo (`ichr2').  Com o objetivo de avaliar esses, se pode usar
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the índices covariantes: [i,j];
          Enter a list of the índices contravariantes: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4)                                  g
          (%i5) ishow(ev(%th(2),ichr2))$
                   %1 %4  k
                  g      a     (g       - g       + g      )
                          i %1   s %4,j    j s,%4    j %4,s
          (%t5) - ------------------------------------------
                                      2
              %1 %3  k
             g      a     (g       - g       + g      )
                     %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                                 2
              k %2  %1
             g     a    (g        - g        + g       )
                    i j   s %2,%1    %1 s,%2    %1 %2,s     k
           + ------------------------------------------- + a
                                  2                         i j,s
          (%i6)


 -- Função: lorentz_gauge (<expr>)
     Impõe a condição de Lorentz através da substituição de 0 para
     todos os objetos indexados em <expr> que possui um índice de
     derivada idêntico ao índice contravariante.


 -- Função: igeodesic_coords (<expr>, <nome>)
     Faz com que símbolos de Christoffel não diferenciados e a primeira
     derivada do tensor métrico tendam para zero em <expr>. O <nome> na
     função `igeodesic_coords' refere-se à métrica <nome> (se isso
     aparecer em <expr>) enquando os coeficientes de conecção devem ser
     chamados com os nomes `ichr1' e/ou `ichr2'. O seguinte exemplo
     demonstra a verificação da identidade cíclica satisfeita através
     do tensor da curvatura de Riemann usando a função
     `igeodesic_coords'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0


28.2.5 Molduras móveis
----------------------

Maxima atualmente tem a habilidade de executar cálculos usando molduras
móveis.  Essas podem ser molduras ortonormais (tetrads, vielbeins) ou
uma moldura arbitrária.

   Para usar molduras, você primeiro escolhe `iframe_flag' para `true'.
Isso faz com que os símbolos de Christoffel, `ichr1' e `ichr2', sejam
substituídos pelas molduras mais gerais de coeficientes de conecção
`icc1' e `icc2' em cálculos. Especialmente, o comportamento de
`covdiff' e `icurvature' são alterados.

   A moldura é definida através de dois tensores: o campo de moldura
inversa (`ifri'), a base tetrad dual), e a métrica da moldura `ifg'. A
métrica da moldura é a matriz identidade para molduras ortonormais, ou
a métrica de Lorentz para molduras ortonormais no espaço-tempo de
Minkowski. O campo de moldura inversa define a base da moldura (vetores
unitários).  Propriedades de contração são definidas para o campo de
moldura e para a métrica da moldura.

   Quando `iframe_flag' for `true', muitas expressões `itensor' usam a
métrica da moldura `ifg' em lugar da métrica definida através de
`imetric' para o decremento e para o incremento de índices.

   IMPORTANTE: Escolhendo a variável `iframe_flag' para `true' NÃO
remove a definição das propriedades de contração de uma métrica
definida através de uma chamada a `defcon' ou `imetric'. Se um campo de
moldura for usado, ele é melhor para definir a métrica através de
atribuição desse nome para a variável `imetric' e NÃO invoque a função
`imetric'.

   Maxima usa esses dois tensores para definir os coeficientes de
moldura (`ifc1' e `ifc2') cuja forma parte dos coeficientes de conecção
(`icc1' e `icc2'), como demonstra o seguinte exemplo:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

   Um método alternativo é usado para calcular o suporte da moldura
(`ifb') se o sinalizador `iframe_bracket_form' é escolhido para `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Função: iframes ()
     Uma vez que nessa versão do Maxima, identidades de contração para
     `ifr' e `ifri' são sempre definidas, como é o suporte da moldura
     (`ifb'), essa função não faz nada.


 -- Variável: ifb
     O suporte da moldura. A contribuição da métrica da moldura para os
     coeficientes de conecção é expressa usando o suporte da moldura:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     O suporte da moldura por si mesmo é definido em termos de campo de
     moldura e métrica da moldura. Dois métodos alternativos de cálculo
     são usados dependendo do valor de `frame_bracket_form'. Se `true'
     (o padrão) ou se o sinalizador `itorsion_flag' for `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variável: icc1
     Coeficientes de conecção de primeiro tipo. Em `itensor', definido
     como


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr1' é substituído com o coeficiente de conecção da
     moldura `ifc1'.  Se `itorsion_flag' for `false', `ikt1' será
     omitido. `ikt1' é também omitido se uma base de moldura for usada,
     como a torsão está já calculada como parte do suporte da moldura.
     Ultimamente, como `inonmet_flag' é `false', `inmc1' não estará
     presente.


 -- Variável: icc2
     Coeficientes de conecção de segundo tipo. Em `itensor', definido
     como


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr2' é substituído com o coeficiente de conecção
     `ifc2'.  Se `itorsion_flag' for `false', `ikt2' será omitido.
     `ikt2' também será omitido se uma base de moldura for usada, uma
     vez que a torsão já está calculada como parte do suporte da
     moldura.  Ultimamente, como `inonmet_flag' é `false', `inmc2' não
     estará presente.


 -- Variável: ifc1
     Coeficiente de moldura de primeiro tipo (também conhecido como
     coeficientes de rotação de Ricci).  Esse tensor representa a
     contribuição da métrica da moldura para o coeficiente de conecção
     de primeiro tipo. Definido como:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variável: ifc2
     Coeficiente de moldura de primeiro tipo. Esse tensor representa a
     contribuição da métrica da moldura para o coeficiente de conecção
     de primeiro tipo. Definido como uma permutação de suporte de
     moldura (`ifb') com os índices apropriados incrementados e
     decrementados como necessário:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variável: ifr
     O campo da moldura. Contrai (`ifri') para e com a forma do campo
     inverso da moldura para formar a métrica da moldura (`ifg').


 -- Variável: ifri
     O campo inverso da moldura. Especifica a base da moldura (vetores
     base duais). Juntamente com a métrica da moldura, forma a base de
     todos os cálculos baseados em molduras.


 -- Variável: ifg
     A métrica da moldura. O valor padrão é `kdelta', mas pode ser
     mudada usando `components'.


 -- Variável: ifgi
     O inverso da métrica da moldura. Contrai com a métrica da moldura
     (`ifg') para `kdelta'.


 -- Variável de Opção: iframe_bracket_form
     Valor padrão: `true'

     Especifica como o suporte da moldura (`ifb') é calculado.


28.2.6 Torsão e não metricidade
-------------------------------

Maxima pode trabalhar com torsão e não metricidade. Quando o sinalizador
`itorsion_flag' for escolhido para `true', a contribuição de torsão é
adicionada aos coeficientes de conecção. Similarmente, quando o
sinalizador `inonmet_flag' for `true', componentes de não metricidades
são incluídos.

 -- Variável: inm
     O vetor de não metricidade. Conforme a não metricidade está
     definida através da derivada covariante do tensor métrico.
     Normalmente zero, o tensor da métrica derivada covariante irá
     avaliar para o seguinte quando `inonmet_flag' for escolhido para
     `true':


          g     =- g  inm
           ij;k     ij  k


 -- Variável: inmc1
     Permutação covariante de componentes do vetor de não metricidade.
     Definida como


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: inmc2
     Permutação covariante de componentes do vetor de não metricidade.
     Usada nos coeficicientes de conecção se `inonmet_flag' for `true'.
     Definida como:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: ikt1
     Permutação covariante do tensor de torsão (também conhecido como
     contorsão).  Definido como:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: ikt2
     Permutação contravariante do tensor de torsão (também conhecida
     como contorsão).  Definida como:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: itr
     O tensor de torsão. Para uma métrica com torsão, diferenciação
     covariante repetida sobre uma funçào escalar não irá comutar,como
     demonstrado através do seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


28.2.7 Álgebra exterior
-----------------------

O pacote `itensor' pode executar operações sobre campos tensores
covariantes totalmente antisimétricos. Um campo tensor totalmente
antisimétrico de classe (0,L) corresponde a uma forma diferencial L.
Sobre esses objetos, uma operação de multiplicação funciona como um
produto exterior, ou produto cunha, é definido.

   Desafortunadamente, nem todos os autores concordam sobre a definição
de produto cunha. Alguns autores preferem uma definição que corresponde
à noção de antisimetrização: nessas palavras, o produto cunha de dois
campos vetoriais, por exemplo, pode ser definido como

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   Mais geralmente, o produto de uma forma p e uma forma q pode ser
definido como

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   onde `D' simboliza o delta de Kronecker.

   Outros autores, todavia, preferem uma definição "geométrica" que
corresponde à notação de elemento volume:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   e, no caso geral

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Uma vez que `itensor' é um pacote de algebra de tensores, a primeira
dessas duas definições aparenta ser a mais natural por si mesma. Muitas
aplicações, todavia, usam a segunda definição. Para resolver esse
dilema, um sinalizador tem sido implementado que controla o
comportamento do produto cunha: se `igeowedge_flag' for `false' (o
padrão), a primeira, definição "tensorial" é usada, de outra forma a
segunda, definição "geométrica" irá ser aplicada.

 -- Operator: ~
     O operador do produto cunha é definido como sendo o acento til
     `~'. O til é um operador binário. Seus argumentos podem ser
     expressões envolvendo escalares, tensores covariantes de categoria
     1, ou tensores covariantes de categoria `l' que tiverem sido
     declarados antisimétricos em todos os índices covariantes.

     O comportamento do operador do produto cunha é controlado através
     do sinalizador `igeowedge_flag', como no seguinte exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operator: |
     A barra vertical `|' denota a operação binária "contração com um
     vetor". Quando um tensor covariante totalmente antisimétrico é
     contraído com um vetor contravariante, o resultado é o mesmo
     independente de qual índice foi usado para a contração. Dessa
     forma, é possível definir a operação de contração de uma forma
     livre de índices.

     No pacote `itensor', contração com um vetor é sempre realizada com
     relação ao primeiro índice na ordem literal de ordenação. Isso
     garante uma melhor simplificação de expressões envolvendo o
     operador `|'. Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note que isso é essencial que os tensores usado como o operador
     `|' seja declarado totalmente antisimétrico em seus índices
     covariantes. De outra forma, os resultados serão incorretos.


 -- Função: extdiff (<expr>, <i>)
     Calcula a derivada exterior de <expr> com relação ao índice <i>. A
     derivada exterior é formalmente definida como o produto cunha do
     operador de derivada parcial e uma forma diferencial. Como tal,
     essa operação é também controlada através da escolha de
     `igeowedge_flag'.  Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k


 -- Função: hodge (<expr>)
     Calcula o Hodge dual de <expr>. Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Variável de Opção: igeowedge_flag
     Valor padrão: `false'

     Controla o comportamento de produto cunha e derivada exterior.
     Quando for esconhida para `false' (o padrão), a noção de formas
     diferenciais irá corresponder àquela de um campo tensor covariante
     totalmente antisimétrico.  Quando escolhida para `true', formas
     diferenciais irão concordar com a noção do elemento volume.


28.2.8 Exportando expressões TeX
--------------------------------

O pacote `itensor' fornece suporte limitado à exportação de expressões
de tensores para o TeX.  Uma vez que expressões `itensor' aparecem como
chamada a funções, o comando regular `tex' do Maxima não produzirá a
saída esperada. Você pode tentar em seu lugar o comando `tentex', o
qual tenta traduzir expressões de tensores dentro de objetos TeX
indexados apropriadamente.

 -- Função: tentex (<expr>)
     Para usar a função `tentex', você deve primeiro chamar `tentex',
     como no seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note o uso da declaração `idummyx', para evitar o aparecimento do
     sinal de porcentagem na expressão TeX, o qual pode induzir a erros
     de compilação.

     Note Bem: Essa vesão da função `tentex' é um tanto quanto
     experimental.


28.2.9 Interagindo com o pacote `ctensor'
-----------------------------------------

O pacote `itensor' possui a habilidade de gerar código Maxima que pode
então ser executado no contexto do pacote `ctensor'. A função que
executa essa tarefa é `ic_convert'.

 -- Função: ic_convert (<eqn>)
     Converte a equação <eqn> na sintaxe `itensor' para uma declaração
     de atribuição `ctensor'.  Adições implícitas sobre índices que
     ocorrem exatamente duas vezes são tornadas explícitas enquanto
     objetos indexados são transformados em arrays (os arrays
     subscritos estão na ordem de covariância seguidos de índices
     contravariantes dos objetos indexados). A derivada de um objeto
     indexado irá ser substituída pela forma substantiva de `diff'
     tomada com relação a `ct_coords' subscrita pelo índice de
     derivação. Os símbolos de Christoffel `ichr1' e `ichr2' irão ser
     traduzidos para `lcs' e `mcs', respectivamente e se
     `metricconvert' for `true' então todas as ocorrências da métrica
     com dois índices covariantes (ou contravariantes) irão ser
     renomeadas para `lg' (ou `ug'). Adicionalmente, ciclos `do' irão
     ser introduzidos adicionando sobre todos os índices livres de
     forma que a declaração de atribuição transformada pode ser
     avaliada através de apenas fazendo `ev'. Os seguintes exemplos
     demonstam os recursos dessa função.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


28.2.10 Palavras reservadas
---------------------------

As palavras seguintes do Maxima são usadas internamente pelo pacote
`itensor' e não podem ser redefinidas:

       Keyword    Comments
       ------------------------------------------
       indices2() versão interna de `indices()'
       conti      Lista de índices contravariantes
       covi       Lista de índices covariantes de um objeto indexado
       deri       Lista de índices de derivada de um objeto indexado
       name       Retorna o nome de um objeto indexado
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: Pacote atensor,  Prev: itensor,  Up: Top

29 ctensor
**********

* Menu:

* Introdução a ctensor::
* Definições para ctensor::


File: maxima.info,  Node: Introdução a ctensor,  Next: Definições para ctensor,  Prev: ctensor,  Up: ctensor

29.1 Introdução a ctensor
=========================

`ctensor' é um pacote de manipulação de componentes.  Para usar o pacote
`ctensor', digite `load(ctensor)'.  Para começar uma sessão iterativa
com `ctensor', digite `csetup()'.  Você é primeiramente solicitado a
especificar a dimensão a ser manipulada. Se a dimensão for 2, 3 ou 4
então a lista de coordenadas padrão é `[x,y]', `[x,y,z]' ou `[x,y,z,t]'
respectivamente.  Esses nomes podem ser mudados através da atribuição
de uma nova lista de coordenadas para a variável `ct_coords' (descrita
abaixo) e o usuário é perguntado sobre isso.Cuidado deve ser tomado
para evitar o conflito de nomes de coordenadas com outras definições de
objetos.

   No próximo passo, o usuário informa a métrica ou diretamente ou de
um arquivo especificando sua posição ordinal. Como um exemplo de um
arquivo de métrica comum, veja `share/tensor/metrics.mac'. A métrica
está armazenada na matriz LG. Finalmente, o inverso da métrica é
calculado e armazenado na matriz UG. Se tem a opção de realizar todos
os cálculos em séries de potência.

   Um protocolo amostra é iniciado abaixo para a métrica estática,
esfericamente simétrica (coordenadas padrão) que será aplicadas ao
problema de derivação das equações de vácuo de Einstein (que levam à
solução de Schwarzschild) como um exemplo. Muitas das funções em
`ctensor' irão ser mostradas para a métrica padrão como exemplos.

     (%i1) load(ctensor);
     (%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Definições para ctensor,  Prev: Introdução a ctensor,  Up: ctensor

29.2 Definições para ctensor
============================

29.2.1 Inicialização e configuração
-----------------------------------

 -- Função: csetup ()
     É uma função no pacote `ctensor' (component tensor) que inicializa
     o pacote e permite ao usuário inserir uma métrica interativamente.
     Veja `ctensor' para mais detalhes.

 -- Função: cmetric (<dis>)
 -- Função: cmetric ()
     É uma função no pacote `ctensor' que calcula o inverso da métrica
     e prepara o pacote para cálculos adiante.

     Se `cframe_flag' for `false', a função calcula a métrica inversa
     `ug' a partir da matriz `lg' (definida pelo usuário). O
     determinante da métrica é também calculado e armazenado na
     variável `gdet'. Mais adiante, o pacote determina se a métrica é
     diagonal e escolhe o valor de `diagmetric' conforme a
     determinação. Se o argumento opcional <dis> estiver presente e não
     for `false', a saída é mostrada ao usuário pela linha de comando
     para que ele possa ver o inverso da métrica.

     Se `cframe_flag' for `true', a função espera que o valor de `fri'
     (a matriz moldura inversa) e `lfg' (a métrica da moldura) sejam
     definidas. A partir dessas, a matriz da moldura `fr' e a métrica
     da moldura inversa `ufg' são calculadas.


 -- Função: ct_coordsys (<sistema_de_coordenadas>, <extra_arg>)
 -- Função: ct_coordsys (<sistema_de_coordenadas>)
     Escolhe um sistema de coordenadas predefinido e uma métrica. O
     argumento <sistema_de_coordenadas> pode ser um dos seguintes
     símbolos:


            SYMBOL               Dim Coordenadas       Descrição/comentários
            --------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
            polar                 2  [r,phi]           Sist. de coord. Polare
            elliptic              2  [u,v]
            confocalelliptic      2  [u,v]
            bipolar               2  [u,v]
            parabolic             2  [u,v]
            cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
            polarcylindrical      3  [r,theta,z]
            ellipticcylindrical   3  [u,v,z]           Elíptica 2D com Z cilíndrico
            confocalellipsoidal   3  [u,v,w]
            bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cilíndrico
            paraboliccylindrical  3  [u,v,z]           Parabólico 2D com Z cilíndrico
            paraboloidal          3  [u,v,phi]
            conical               3  [u,v,w]
            toroidal              3  [u,v,phi]
            spherical             3  [r,theta,phi]     Sist. de coord. Esféricas
            oblatespheroidal      3  [u,v,phi]
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]
            cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
            spherical4d           4  [r,theta,eta,phi]
            exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
            interiorschwarzschild 4  [t,z,u,v]        Métrica de Schwarzschild Interior
            kerr_newman           4  [t,r,theta,phi]   Métrica simétrica axialmente alterada

     `sistema_de_coordenadas' pode também ser uma lista de funções de
     transformação, seguida por uma lista contendo as varáveis
     coordenadas. Por exemplo, você pode especificar uma métrica
     esférica como segue:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Funções de transformação podem também serem usadas quando
     `cframe_flag' for `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     O argumento opcional <extra_arg> pode ser qualquer um dos
     seguintes:

     `cylindrical' diz a `ct_coordsys' para anexar uma coordenada
     adicional cilíndrica.

     `minkowski' diz a `ct_coordsys' para anexar uma coordenada com
     assinatura métrica negativa.

     `all' diz a `ct_coordsys' para chamar `cmetric' e
     `christof(false)' após escolher a métrica.

     Se a variável global `verbose' for escolhida para `true',
     `ct_coordsys' mostra os valores de `dim', `ct_coords', e ou `lg'
     ou `lfg' e `fri', dependendo do valor de `cframe_flag'.


 -- Função: init_ctensor ()
     Inicializa o pacote `ctensor'.

     A função `init_ctensor' reinicializa o pacote `ctensor'. Essa
     função remove todos os arrays e matrizes usados por `ctensor',
     coloca todos os sinalizadores de volta a seus valores padrão,
     retorna `dim' para 4, e retorna a métrica da moldura para a
     métrica da moldura de Lorentz.


29.2.2 Os tensores do espaço curvo
----------------------------------

O principal propósito do pacote `ctensor' é calcular os tensores do
espaç(tempo) curvo, mais notavelmente os tensores usados na relatividade
geral.

   Quando uma base métrica é usada, `ctensor' pode calcular os
seguintes tensores:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   `ctensor' pode também usar molduras móveis. Quando `cframe_flag' for
escolhida para `true', os seguintes tensores podem ser calculados:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Função: christof (<dis>)
     Uma função no pacote `ctensor'.  Essa função calcula os símbolos
     de Christoffel de ambos os tipos.  O argumento <dis> determina
     quais resultados são para serem imediatamente mostrados.  Os
     símbolos de Christoffel de primeiro e de segundo tipo são
     armazenados nos arrays `lcs[i,j,k]' e `mcs[i,j,k]' respectivamente
     e definidos para serem simétricos nos primeiros dois índices. Se o
     argumento para `christof' for `lcs' ou for `mcs' então o único
     valor não nulo de `lcs[i,j,k]' ou de `mcs[i,j,k]',
     respectivamente, será mostrado. Se o argumento for `all' então o
     único valor não nulo de `lcs[i,j,k]' e o único valor não nulo de
     `mcs[i,j,k]' serão mostrados.  Se o argumento for `false' então a
     exibição dos elementos não acontecerá. Os elementos do array
     `mcs[i,j,k]' são definidos de uma tal maneira que o índice final é
     contravariante.

 -- Função: ricci (<dis>)
     Uma função no pacote `ctensor'.  `ricci' calcula as componentes
     contravariantes (simétricas) `ric[i,j]' do tensor de Ricci.  Se o
     argumento <dis> for `true', então as componentes não nulas são
     mostradas.

 -- Função: uricci (<dis>)
     Essa função primeiro calcula as componentes contravariantes
     `ric[i,j]' do tensor de Ricci.  Então o tensor misto de Ricci é
     calculado usando o tensor métrico contravariante.  Se o valor do
     argumento <dis> for `true', então essas componentes mistas,
     `uric[i,j]' (o índice "i" é covariante e o índice "j" é
     contravariante), serão mostradas diretamente.  De outra forma,
     `ricci(false)' irá simplesmente calcular as entradas do array
     `uric[i,j]' sem mostrar os resultados.


 -- Função: scurvature ()
     Retorna a curvatura escalar (obtida através da contração do tensor
     de Ricci) do Riemaniano multiplicado com a métrica dada.


 -- Função: einstein (<dis>)
     Uma função no pacote `ctensor'.  `einstein' calcula o tensor misto
     de Einstein após os símbolos de Christoffel e o tensor de Ricci
     terem sido obtidos (com as funções `christof' e `ricci').  Se o
     argumento <dis> for `true', então os valores não nulos do tensor
     misto de Einstein `ein[i,j]' serão mostrados quando `j' for o
     índice contravariante.  A variável `rateinstein' fará com que a
     simplificação racional ocorra sobre esses componentes. Se `ratfac'
     for `true' então as componentes irão também ser fatoradas.


 -- Função: leinstein (<dis>)
     Tensor covariante de Einstein. `leinstein' armazena o valor do
     tensor covariante de Einstein no array `lein'. O tensor covariante
     de Einstein é calculado a partir tensor misto de Einstein `ein'
     através da multiplicação desse pelo tensor métrico. Se o argumento
     <dis> for `true', então os valores não nulos do tensor covariante
     de Einstein são mostrados.


 -- Função: riemann (<dis>)
     Uma função no pacote `ctensor'.  `riemann' calcula o tensor de
     curvatura de Riemann a partir da métrica dada e correspondendo aos
     símbolos de Christoffel. As seguintes convenções de índice são
     usadas:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     Essa notação é consistente com a notação usada por no pacote
     `itensor' e sua função `icurvature'.  Se o argumento opcional
     <dis> for `true', as componentes não nulas `riem[i,j,k,l]' serão
     mostradas.  Como com o tensor de Einstein, vários comutadores
     escolhidos pelo usuário controlam a simplificação de componentes
     do tensor de Riemann.  Se `ratriemann' for `true', então
     simplificação racional será feita. Se `ratfac' for `true' então
     cada uma das componentes irá também ser fatorada.

     Se a variável `cframe_flag' for `false', o tensor de Riemann é
     calculado diretamente dos símbolos de Christoffel. Se
     `cframe_flag' for `true', o tensor covariante de Riemann é
     calculado primeiro dos coeficientes de campo da moldura.


 -- Função: lriemann (<dis>)
     Tensor covariante de Riemann (`lriem[]').

     Calcula o tensor covariante de Riemann como o array `lriem'. Se o
     argumento <dis> for `true', únicos valores não nulos são mostrados.

     Se a variável `cframe_flag' for `true', o tensor covariante de
     Riemann é calculado diretamente dos coeficientes de campo da
     moldura. De outra forma, o tensor (3,1) de Riemann é calculado
     primeiro.

     Para informação sobre a ordenação de índice, veja `riemann'.


 -- Função: uriemann (<dis>)
     Calcula as componentes contravariantes do tensor de curvatura  de
     Riemann como elementos do array `uriem[i,j,k,l]'.  Esses são
     mostrados se <dis> for `true'.


 -- Função: rinvariant ()
     Compõe o invariante de Kretchmann (`kinvariant') obtido através da
     contração dos tensores

          lriem[i,j,k,l]*uriem[i,j,k,l].

     Esse objeto não é automaticamente simplificado devido ao fato de
     poder ser muito largo.


 -- Função: weyl (<dis>)
     Calcula o tensor conformal de Weyl.  Se o argumento <dis> for
     `true', as componentes não nulas `weyl[i,j,k,l]' irão ser
     mostradas para o usuário.  De outra forma, essas componentes irão
     simplesmente serem calculadas e armazenadas.  Se o comutador
     `ratweyl' é escolhido para `true', então as componentes irão ser
     racionalmente simplificadas; se `ratfac' for `true' então os
     resultados irão ser fatorados também.


29.2.3 Expansão das séries de Taylor
------------------------------------

O pacote `ctensor' possui a habilidade para truncar resultados assumindo
que eles são aproximações das séries de Taylor. Esse comportamenteo é
controlado através da variável `ctayswitch'; quando escolhida para
`true', `ctensor' faz uso internamente da função `ctaylor' quando
simplifica resultados.

   A função `ctaylor' é invocada pelas seguintes funções de `ctensor':


         Function     Comments
         ---------------------------------
         christof()   só para mcs
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Função: ctaylor ()
     A função `ctaylor' trunca seus argumentos através da conversão
     destes para uma série de Taylor usando `taylor', e então chamando
     `ratdisrep'. Isso tem efeito combinado de abandonar termos de
     ordem mais alta na variável de expansão `ctayvar'. A ordem dos
     termos que podem ser abandonados é definida através de `ctaypov'; o
     ponto em torno do qual a expansão da série é realizada está
     especificado em `ctaypt'.

     Como um exemplo, considere uma métrica simples que é uma
     perturbação da métrica de Minkowski. Sem restrições adicionais,
     mesmo uma métrica diagonal produz expressões para o tensor de
     Einstein que são de longe muito complexas:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     Todavia, se nós recalcularmos esse exemplo como uma aproximação
     que é linear na variável `l', pegamos expressões muito simples:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r

     Essa compatibilidade pode ser útil, por exemplo, quando
     trabalhamos no limite do campo fraco longe de uma fonte
     gravitacional.


29.2.4 Campos de moldura
------------------------

Quando a variável `cframe_flag' for escolhida para `true', o pacote
`ctensor' executa seus cálculos usando uma moldura móvel.

 -- Função: frame_bracket (<fr>, <fri>, <diagframe>)
     O delimitador da moldura (`fb[]').

     Calcula o delimitador da moldura conforme a seguinte definição:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


29.2.5 Classificação Algébrica
------------------------------

Um novo recurso (a partir de November de 2004) de `ctensor' é sua
habilidade para calcular a classificação de Petrov de uma métrica
espaço tempo tetradimensional.  Para uma demonstração dessa
compatibilidade, veja o arquivo `share/tensor/petrov.dem'.

 -- Função: nptetrad ()
     Calcula um tetrad nulo de Newman-Penrose (`np') e seus índices
     ascendentes em contrapartida (`npi'). Veja `petrov' para um
     exemplo.

     O tetrad nulo é construído assumindo que uma moldura métrica
     ortonormal tetradimensional com assinatura métrica (-,+,+,+) está
     sendo usada.  As componentes do tetrad nulo são relacionadas para
     a matriz moldura inversa como segue:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Função: psi (<dis>)
     Calcula os cinco coeficientes de Newman-Penrose
     `psi[0]'...`psi[4]'.  Se `psi' for escolhida para `true', os
     coeficientes são mostrados.  Veja `petrov' para um exemplo.

     Esses coeficientes são calculados a partir do tensor de Weyl em
     uma base de coordenada.  Se uma base de moldura for usada,o tensor
     de Weyl é primeiro convertido para a base de coordenada, que pode
     ser um procedimento computacional expansível. Por essa razão, em
     alguns casos pode ser mais vantajoso usar uma base de coordenada em
     primeiro lugar antes que o tensor de Weyl seja calculado. Note
     todavia, que para a construção de um tetrad nulo de Newman-Penrose
     é necessário uma base de moldura. Portanto, uma seqüência de
     cálculo expressiva pode começar com uma base de moldura, que é
     então usada para calcular `lg' (calculada automaticamente através
     de `cmetric') e em seguida calcula `ug'. Nesse ponto, você pode
     comutar de volta para uma base de coordenada escolhendo
     `cframe_flag' para `false' antes de começar a calcular os símbolos
     de Christoffel. Mudando para uma base de moldura em um estágio
     posterior pode retornar resultados inconsistentes, já que você
     pode terminar com um grande mistura de tensores, alguns calculados
     em uma base de moldura, alguns em uma base de coordenada, sem
     nenhum modo para distingüir entre os dois tipos.


 -- Função: petrov ()
     Calcula a classificação de petrov da métrica caracterizada através
     de `psi[0]'...`psi[4]'.

     Por exemplo, o seguinte demonstra como obter a classificação de
     Petrov da métrica de Kerr:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     A função de classificação Petrov é baseada no algorítmo publicado
     em "Classifying geometries in general relativity: III
     Classification in practice" por Pollney, Skea, e d'Inverno, Class.
     Quant. Grav. 17 2885-2902 (2000).  Exceto para alguns casos de
     teste simples, a implementação não está testada até 19 de Dezembro
     de 2004, e é provável que contenha erros.


29.2.6 Torsão e não metricidade
-------------------------------

`ctensor' possui a habilidade de calcular e incluir coeficientes de
torsão e não metricidade nos coeficientes de conecção.

   Os coeficientes de torsão são calculados a partir de um tensor
fornecido pelo usuário `tr', que pode ser um tensor de categoria (2,1).
A partir disso, os coeficientes de torsão `kt' são calculados de
acordo com a seguinte fórmula:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Note que somente o tensor de índice misto é calculao e armazenado no
array `kt'.

   Os coeficientes de não metricidade são calculados a partir  do vetor
de não metricidade fornecido pelo usuário `nm'. A partir disso, os
coeficientes de não metricidade `nmc' são calculados como segue:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   onde D simboliza o delta de Kronecker.

   Quando `ctorsion_flag' for escolhida para `true', os valores de `kt'
são subtraídos dos coeficientes de conecção indexados mistos calculados
através de `christof' e armazenados em `mcs'. Similarmente, se
`cnonmet_flag' for escolhida para `true', os valores de `nmc' são
subtraídos dos coeficientes de conecção indexados mistos.

   Se necessário, `christof' chama as funções `contortion' e
`nonmetricity' com o objetivo de calcular `kt' e `nm'.

 -- Função: contortion (<tr>)
     Calcula os coeficientes de contorsão de categoria (2,1) a partir
     do tensor de torsão <tr>.


 -- Função: nonmetricity (<nm>)
     Calcula o coeficiente de não metricidade de categoria (2,1) a
     partir do vetor de não metricidade <nm>.


29.2.7 Recursos diversos
------------------------

 -- Função: ctransform (<M>)
     Uma função no pacote `ctensor' que irá executar uma transformação
     de coordenadas sobre uma matriz simétrica quadrada arbitrária <M>.
     O usuário deve informar as funçãoes que definem a transformação.
     (Formalmente chamada `transform'.)


 -- Função: findde (<A>, <n>)
     Retorna uma lista de equações diferenciais únicas (expressões)
     correspondendo aos elementos do array quadrado <n> dimensional
     <A>. Atualmente, <n> pode ser 2 ou 3. `deindex' é uma lista global
     contendo os índices de <A> correspondendo a essas únicas equações
     diferenciais. Para o tensor de Einstein (`ein'), que é um array
     dimensional, se calculado para a métrica no exemplo abaixo,
     `findde' fornece as seguintes equações diferenciais independentes:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Função: cograd ()
     Calcula o gradiente covariante de uma função escalar permitindo ao
     usuário escolher o nome do vetor correspondente como o exemplo sob
     `contragrad' ilustra.

 -- Função: contragrad ()
     Calcula o gradiente contravariante de uma função escalar permitindo
     ao usuário escolher o nome do vetor correspondente como o exemplo
     abaixo como ilustra a métrica de Schwarzschild:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Função: dscalar ()
     Calcula o tensor d'Alembertiano da função escalar assim que as
     dependências tiverem sido declaradas sobre a função. Po exemplo:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Função: checkdiv ()
     Calcula a divergência covariante do tensor de segunda categoria
     misto (cujo primeiro índice deve ser covariante) imprimindo as
     correspondentes n componentes do campo do vetor (a divergência)
     onde n = `dim'. Se o argumento para a função for `g' então a
     divergência do tensor de Einstein irá ser formada e pode ser zero.
     Adicionalmente, a divergência (vetor) é dada no array chamado
     `div'.

 -- Função: cgeodesic (<dis>)
     Uma função no pacote `ctensor'.  `cgeodesic' calcula as equações
     geodésicas de movimento para uma dada métrica.  Elas são
     armazenadas no array `geod[i]'.  Se o argumento <dis> for `true'
     então essas equações são mostradas.


 -- Função: bdvac (<f>)
     Gera as componentes covariantes das equações de campo de vácuo da
     teoria de gravitação de Brans-Dicke. O campo escalar é especificado
     através do argumento <f>, que pode ser um nome de função (com
     apóstrofo) com dependências funcionais, e.g., `'p(x)'.

     As componentes de segunda categoria do tensor campo covariante são
     as componentes de segunda categoria representadas pelo array `bd'.


 -- Função: invariant1 ()
     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de R^2. As equações de campo são componentes
     de um array chamado `inv1'.


 -- Função: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de `ric[i,j]*uriem[i,j]'. As equações de
     campo são as componentes de um array chamado `inv2'.


 -- Função: bimetric ()
     *** NOT YET IMPLEMENTED ***

     Gera as euauações de campo da teoria bimétrica de Rosen. As
     equações de campo são as componentes de um array chamado `rosen'.


29.2.8 Funções utilitárias
--------------------------

 -- Função: diagmatrixp (<M>)
     Retorna `true' se <M> for uma matriz diagonal ou um array (2D).


 -- Função: symmetricp (<M>)
     Retorna `true' se <M> for uma matriz simétrica ou um array (2D).


 -- Função: ntermst (<f>)
     Fornece ao usuário um rápido quadro do "tamanho" do tensor
     duplamente subscrito (array) <f>.  Imprime uma lista de dois
     elementos onde o segundo elemento corresponde a N-TERMOS de
     componentes especificadas através dos primeiros elementos.  Nesse
     caminho, é possível rapidamente encontrar as expressões não nulas
     e tentar simplificação.


 -- Função: cdisplay (<ten>)
     Mostra todos os elementos do tensor <ten>, como representados por
     um array multidimensional. Tensores de categoria 0 e 1, assim como
     outros tipos de variáveis, são mostrados com `ldisplay'. Tensores
     de categoria 2 são mostrados como matrizes bidimensionais,
     enquanto tensores de alta categoria são mostrados como uma lista
     de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
     métrica de Schwarzschild pode ser visto como:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Função: deleten (<L>, <n>)
     Retorna uma nova lista consistindo de <L> com o <n>'ésimo elemento
     apagado.

29.2.9 Variáveis usadas por `ctensor'
-------------------------------------

 -- Variável de opção: dim
     Valor padrão: 4

     Uma opção no pacote `ctensor'.  `dim' é a dimensão de
     multiplicação com o padrão 4. O comando `dim: n' irá escolher a
     dimensão para qualquer outro valor `n'.


 -- Variável de opção: diagmetric
     Valor padrão: `false'

     Uma opção no pacote `ctensor'.  Se `diagmetric' for `true' rotinas
     especiais calculam todos os objetos geométricos (que possuem o
     tensor métrico explicitamente) levando em consideração a
     diagonalidade da métrica. Tempo de execuçào reduzido irá, com
     certeza, resultar dessa escolha. Nota: essa opção é escolhida
     automaticamente por `csetup' se uma métrica diagonal for
     especificada.


 -- Variável de opção: ctrgsimp
     Faz com que simplificações trigonométricas sejam usadas quando
     tensores forem calculados. Atualmente, `ctrgsimp' afeta somente
     cálculos envolvendo uma moldura móvel.


 -- Variável de opção: cframe_flag
     Faz com que cálculos sejam executados relativamente a uma moldura
     móvel em oposição a uma métrica holonômica. A moldura é definida
     através do array da moldura inversa `fri' e da métrica da moldura
     `lfg'. Para cálculos usando uma moldura Cartesiana, `lfg' pode ser
     a matriz unitária de dimensão apropriada; para cálculos em uma
     moldura de Lorentz, `lfg' pode ter a assinatura apropriada.


 -- Variável de opção: ctorsion_flag
     Faz com que o tensor de contorsão seja incluído no cálculo dos
     coeficientes de conecção. O tensor de contorsão por si mesmo é
     calculado através de `contortion' a partir do tensor `tr'
     fornecido pelo usuário.


 -- Variável de opção: cnonmet_flag
     Faz com que os coeficientes de não metricidade sejam incluídos no
     cálculo dos coeficientes de conecção. Os coeficientes de não
     metricidade são calculados a partir do vetor de não metricidade
     `nm' fornecido pelo usuário através da função `nonmetricity'.


 -- Variável de opção: ctayswitch
     Se escolhida para `true', faz com que alguns cálculos de `ctensor'
     sejam realizados usando expansões das séries de Taylor.
     atualmente, `christof', `ricci', `uricci', `einstein', e `weyl'
     levam em conta essa escolha.


 -- Variável de opção: ctayvar
     Variável usada pela expansão de séries de Taylor se `ctayswitch' é
     escolhida para `true'.


 -- Variável de opção: ctaypov
     Maximo expoente usado em expansões de séries de Taylor quando
     `ctayswitch' for escolhida para `true'.


 -- Variável de opção: ctaypt
     Ponto em torno do qual expansões de séries de Taylor sao
     realizadas quando `ctayswitch' for escolhida para `true'.


 -- Variável de sistema: gdet
     O determinante do tensor métrico `lg'. Calculado através de
     `cmetric' quando `cframe_flag' for escolhido para `false'.


 -- Variável de opção: ratchristof
     Faz com que simplificações racionais sejam aplicadas através de
     `christof'.


 -- Variável de opção: rateinstein
     Valor padrão: `true'

     Se `true' simplificação racional irá ser executada sobre as
     componentes não nulas de tensores de Einstein; se `ratfac' for
     `true' então as componentes irão também ser fatoradas.


 -- Variável de opção: ratriemann
     Valor padrão: `true'

     Um dos comutadores que controlam simplificações dos tensores de
     Riemann; se `true', então simplificações racionais irão ser
     concluídas; se `ratfac' for `true' então cada uma das componentes
     irá também ser fatorada.


 -- Variável de opção: ratweyl
     Valor padrão: `true'

     Se `true', esse comutador faz com que a função de `weyl' aplique
     simplificações racionais aos valores do tensor de Weyl. Se
     `ratfac' for `true', então as componentes irão também ser
     fatoradas.

 -- Variável: lfg
     A moldura métrica covariante. Por padrão, é inicializada para a
     moldura tetradimensional de Lorentz com assinatura (+,+,+,-).
     Usada quando `cframe_flag' for `true'.

 -- Variável: ufg
     A métrica da moldura inversa. Calculada de `lfg' quando `cmetric'
     for chamada enquanto `cframe_flag' for escolhida para `true'.

 -- Variável: riem
     O tensor de categoria (3,1) de Riemann. Calculado quando a função
     `riemann' é invocada. Para informação sobre ordenação de índices,
     veja a descrição de `riemann'.

     Se `cframe_flag' for `true', `riem' é calculado a partir do tensor
     covariante de Riemann `lriem'.


 -- Variável: lriem
     O tensor covariante de Riemann. Calculado através de `lriemann'.


 -- Variável: uriem
     O tensor contravariante de Riemann. Calculado através de
     `uriemann'.


 -- Variável: ric
     O tensor misto de Ricci. Calculado através de `ricci'.


 -- Variável: uric
     O tensor contravariante de Ricci. Calculado através de `uricci'.


 -- Variável: lg
     O tensor métrico. Esse tensor deve ser especificado (como uma
     `dim' através da matriz `dim') antes que outro cálculo possa ser
     executado.


 -- Variável: ug
     O inverso do tensor métrico. Calculado através de `cmetric'.


 -- Variável: weyl
     O tensor de Weyl. Calculado através de `weyl'.


 -- Variável: fb
     Coeficientes delimitadores da moldura, como calculado através de
     `frame_bracket'.


 -- Variável: kinvariant
     O invariante de Kretchmann. Calculado através de `rinvariant'.


 -- Variável: np
     Um tetrad nulo de Newman-Penrose. Calculado através de `nptetrad'.


 -- Variável: npi
     O índice ascendente do tetrad nulo de Newman-Penrose. Calculado
     através de `nptetrad'.  Definido como `ug.np'. O produto
     `np.transpose(npi)' é constante:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variável: tr
     Tensor de categoria 3 fornecido pelo usuário representando torsão.
     Usado por `contortion'.

 -- Variável: kt
     O tensor de contorsão, calculado a partir de `tr' através de
     `contortion'.

 -- Variável: nm
     Vetor de não metrcidade fornecido pelo usuário. Usado por
     `nonmetricity'.

 -- Variável: nmc
     Os coeficientes de não metricidade, calculados a partir de `nm'
     por `nonmetricity'.


 -- Variável de sistema: tensorkill
     Variável indicando se o pacote tensor foi inicializado. Escolhida
     e usada por `csetup', retornada ao seu valor original através de
     `init_ctensor'.


 -- Variável de opção: ct_coords
     Valor padrão: `[]'

     Uma opção no pacote `ctensor'.  `ct_coords' contém uma lista de
     coordenadas.  Enquanto normalmente definida quando a função
     `csetup' for chamada, se pode redefinir as coordenadas com a
     atribuição `ct_coords: [j1, j2, ..., jn]' onde os j's são os novos
     nomes de coordenadas.  Veja também `csetup'.


29.2.10 Nomes reservados
------------------------

Os seguintes nomes são usados internamente pelo pacote `ctensor' e não
devem ser redefinidos:

       Name         Description
       ---------------------------------------
       _lg()        Avalia para `lfg' se a moldura métrica for usada,
                         para `lg' de outra forma
       _ug()        Avalia para `ufg' se a moldura métrica for usada,
                         para `ug' de outra forma
       cleanup()    Remove ítens da lista `deindex'
       contract4()  Usado por psi()
       filemet()    Usado por csetup() quando lendo a métrica de um arquivo
       findde1()    Usado por findde()
       findde2()    Usado por findde()
       findde3()    Usado por findde()
       kdelt()      Delta de Kronecker (não generalizado)
       newmet()     Usado por csetup() para escolher uma métrica
                         interativamente
       setflags()   Usado por init_ctensor()
       readvalue()
       resimp()
       sermet()     Usado por csetup() para informar uma métricacom série
                         de Taylor
       txyzsum()
       tmetric()    Moldura métrica, usado por cmetric() quando
                         cframe_flag:true
       triemann()   Tensor de Riemann em base de moldura, usado quando
                         cframe_flag:true
       tricci()     Tensor de Ricci em base de moldura, usada quando
                         cframe_flag:true
       trrc()       Coeficientes de rotação de Ricci, usado por
                         christof()
       yesp()

29.2.11 Changes
---------------

Em Novembro de 2004, o pacote `ctensor' foi extensivamente reescrito.
Muitas funções e variáveis foram renomeadas com o objetivo de tornar o
pacote com a versão comercial do Macsyma.

       Novo Nome    Nome Antigo     Descrição
       --------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Expansão da série de Taylor de uma
       -----------------------------expressão
       lgeod[]      EM              Equações geodésicas
       ein[]        G[]             Tensor misto de Einstein
       ric[]        LR[]            Tensor misto de Ricci
       ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
       ctaypov      MINP            Maximo expoente em expansões de séries de
       -----------------------------Taylor
       cgeodesic()  MOTION          Calcula as equações geodésicas
       ct_coords    OMEGA           Coordenadas métricas
       ctayvar      PARAM           Variável de expansão de séries de
       -----------------------------Taylor
       lriem[]      R[]             Tensor covariante de Riemann
       uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
       -----------------------------Riemann
       ratriemann   RATRIEMAN       Simplificação racional do tensor de
       -----------------------------Riemann
       uric[]       RICCI[]         Tensor de Ricci contravariante
       uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
       cmetric()    SETMETRIC()     Escolhe a métrica
       ctaypt       TAYPT           Ponto para expansões de séries de Taylor
       ctayswitch   TAYSWITCH       Escolhe o comutador de séries de Taylor
       csetup()     TSETUP()        Inicia sessão interativa de configuração
       ctransform() TTRANSFORM()    Transformação de coordenadas interativa
       uriem[]      UR[]            Tensor contravariante de Riemann
       weyl[]       W[]             Tensor (3,1) de Weyl


File: maxima.info,  Node: Pacote atensor,  Next: Séries,  Prev: ctensor,  Up: Top

30 Pacote atensor
*****************

* Menu:

* Introdução ao Pacote atensor::
* Definições para o Pacote atensor::


File: maxima.info,  Node: Introdução ao Pacote atensor,  Next: Definições para o Pacote atensor,  Prev: Pacote atensor,  Up: Pacote atensor

30.1 Introdução ao Pacote atensor
=================================

`atensor' é um pacote de manipulção de tensores algébricos.  Para usar
`atensor', digite `load(atensor)', seguido por uma chamada à função
`init_atensor'.

   A essência de `atensor' é um conjunto de regras de simplificação
para o operador de produto (ponto) não comutativo ("`.'").  `atensor'
reconhece muitos tipos de álgebra; as regras de simplificação
correspondentes são ativadas quando a função `init_atensor' é chamada.

   A compatibilidade de `atensor' pode ser demonstrada pela definição da
álgebra de quatérnios como uma álgera-Clifford Cl(0,2) com dois vetores
fundamentais.  As três unidades quaterniônicas imaginárias fundamentais
são então os dois vetores base  e seu produto, i.e.:

         i = v     j = v     k = v  .  v
              1         2         1    2

   Embora o pacote `atensor' tenha uma definição interna para a álgebra
dos quatérnios, isso não foi usado nesse exemplo, no qual nós nos
esforçamos para construir a tabela de multiplicação dos quatérnios como
uma matriz:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  .  v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  .  v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  .  v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  .  v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  .  v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   `atensor' reconhece como bases vetoriais símbolos indexados, onde o
símbolo é aquele armazenado em `asymbol' e o iíndice está entre 1 e
`adim'.  Para símbolos indexado, e somente para símbolos indexados, as
formas bilineares `sf', `af', e `av' são avaliadas.  A avaliação
substitui os valores  de `aform[i,j]' em lugar de `fun(v[i],v[j])' onde
`v' representa o valor de `asymbol' e `fun' é ainda `af' ou `sf'; ou,
isso substitui `v[aform[i,j]]' em lugar de `av(v[i],v[j])'.

   Desnecessário dizer, as funções `sf', `af' e `av' podem ser
redefinidas.

   Quando o pacote `atensor' é chamado, os seguintes sinalizadores são
configurados:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   Se você deseja experimentar com uma álgebra não associativa, você
pode também considerar a configuração de `dotassoc' para `false'.
Nesse caso, todavia, `atensimp' não stará sempre habilitado a obter as
simplificações desejadas.


File: maxima.info,  Node: Definições para o Pacote atensor,  Prev: Introdução ao Pacote atensor,  Up: Pacote atensor

30.2 Definições para o Pacote atensor
=====================================

 -- Função: init_atensor (<alg_type>, <opt_dims>)
 -- Função: init_atensor (<alg_type>)
     Inicializa o pacote `atensor' com o tipo especificado de álgebra.
     <alg_type> pode ser um dos seguintes:

     `universal': A álgebra universal tendo regras não comutativas.

     `grassmann': A álgebra de Grassman é definida pela relação de
     comutação `u.v+v.u=0'.

     `clifford': A álgebra de Clifford é definida pela relação de
     comutação `u.v+v.u=-2*sf(u,v)' onde `sf' é a função valor-escalar
     simétrico.  Para essa álgebra, <opt_dims> pode ser acima de três
     inteiros não negativos, representando o número de dimensões
     positivas, dimensões degeneradas, e dimensões negativas da
     álgebra, respectivamente.  Se quaisquer valores <opt_dims> são
     fornecidos, `atensor' irá configurar os valores de `adim' e
     `aform' apropriadamente.  Caso contrário, `adim' irá por padrão
     para 0 e `aform' não será definida.

     `symmetric': A álgebra simétrica é definida pela relação de
     comutação `u.v-v.u=0'.

     `symplectic': A álgebra simplética é definida pela relação de
     comutação `u.v-v.u=2*af(u,v)' onde `af' é uma função valor-escalar
     antisimétrica.  Para a álgebra simplética, <opt_dims> pode mais de
     dois inteiros não negativos, representando a dimensão não
     degenerada e e a dimensão degenerada, respectivamente.  Se
     quaisquer valores <opt_dims> são fornecidos, `atensor' irá
     configurar os valores de `adim' e `aform' apropriadamente.  Caso
     contrário, `adim' irá por padrão para 0 e `aform' não será
     definida.

     `lie_envelop': O invólucro da álgebra de Lie é definido pela
     relação de comutação `u.v-v.u=2*av(u,v)' onde `av' é uma função
     antisimétrica.

     A função `init_atensor' também reconhece muitos tipos
     pré-definidos de álgebra:

     `complex' implementa a álgebra de números complexos como a álgebra
     de Clifford Cl(0,1).  A chamada `init_atensor(complex)' é
     equivalente a `init_atensor(clifford,0,0,1)'.

     `quaternion' implementa a álgebra de quatérnios.  A chamada
     `init_atensor(quaternion)' é equivalente a
     `init_atensor(clifford,0,0,2)'.

     `pauli' implementa a álgebra de Pauli-spinors como a
     Clifford-álgebra Cl(3,0).  Uma chamada a `init_atensor(pauli)' é
     equivalente a `init_atensor(clifford,3)'.

     `dirac' implementa a álgebra de Dirac-spinors como a
     Clifford-álgebra Cl(3,1).  Uma chamada a `init_atensor(dirac)' é
     equivalente a `init_atensor(clifford,3,0,1)'.


 -- Função: atensimp (<expr>)
     Simplifica a expressão algébrica de tensores <expr> conforme as
     regras configuradas por uma chamada a `init_atensor'.
     Simplificações incluem aplicação recursiva de relações comutativas
     e resoluções de chamadas a `sf', `af', e `av' onde for aplicável.
     Uma salvaguarda é usada para garantir que a função sempre termine,
     mesmo para expressões complexas.


 -- Função: alg_type
     O tipo de álgebra.  Valores válidos sáo `universal', `grassmann',
     `clifford', `symmetric', `symplectic' and `lie_envelop'.


 -- Variável: adim
     A dimensionalidade da álgebra.  `atensor' usa o valor de `adim'
     para determinar se um objeto indexado é uma base vetorial válida.
     Veja `abasep'.


 -- Variável: aform
     Valor padrão para as formas bilineares `sf', `af', e `av'.  O
     padrão é a matriz identidade `ident(3)'.


 -- Variável: asymbol
     O símbolo para bases vetoriais.


 -- Função: sf (<u>, <v>)
     É uma função escalar simétrica que é usada em relações comutativas.
     A implementação padrão verifica se ambos os argumentos são bases
     vetoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.


 -- Função: af (<u>, <v>)
     É uma função escalar antisimétrica que é usada em relações
     comutativas.  A implementação padrão verifica se ambos os
     argumentos são bases vetoriais usando `abasep' e se esse for o
     caso, substitui o valor correspondente da matriz `aform'.


 -- Função: av (<u>, <v>)
     É uma função antisimétrica que é usada em relações comutativas.  A
     implementação padrão verifica se ambos os argumentos são bases
     vetoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.

     Por exemplo:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Função: abasep (<v>)
     Verifica se esse argumento é uma base vetorial `atensor' .

     E será, se ele for um símbolo indexado, com o símbolo sendo o
     mesmo que o valor de `asymbol', e o índice tiver o mesmo valor
     numérico entre 1 e `adim'.



File: maxima.info,  Node: Séries,  Next: Teoria dos Números,  Prev: Pacote atensor,  Up: Top

31 Séries
*********

* Menu:

* Introdução a Séries::
* Definições para Séries::


File: maxima.info,  Node: Introdução a Séries,  Next: Definições para Séries,  Prev: Séries,  Up: Séries

31.1 Introdução a Séries
========================

Maxima contém funções `taylor' e `powerseries' (séries de potência)
para encontrar as séries de funções diferenciáveis.   Maxima também tem
ferramentas  tais como `nusum' capazes de encontrar a forma fechada de
algumas séries.   Operações tais como adição e multiplicação travalham
da forma usual sobre séries.  Essa seção apresenta as variáveis globais
que controlam a expansão.



Local Variables:
coding: iso-8859-1
End:
