<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Operators</TITLE>
<link href="maxima_5.html" rel=Next>
<link href="maxima_3.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_3.html">previous</A>, <A HREF="maxima_5.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC11" HREF="maxima_toc.html#TOC11">Operators</A></H1>



<H2><A NAME="SEC12" HREF="maxima_toc.html#TOC12">NARY</A></H2>
<P>
 - An NARY operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the
operator, e.g. A+B or A+B+C.  The NARY("x") function is a syntax
extension function to declare x to be an NARY operator.  Do
DESCRIBE(SYNTAX); for more details.  Functions may be DECLAREd to be
NARY.  If DECLARE(J,NARY); is done, this tells the simplifier to
simplify, e.g. J(J(A,B),J(C,D)) to J(A, B, C, D).

</P>


<H2><A NAME="SEC13" HREF="maxima_toc.html#TOC13">NOFIX</A></H2>
<P>
 - NOFIX operators are used to denote functions of no arguments.
The mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a MACSYMA break, "exit" is behaving similar to a
NOFIX operator.  The function NOFIX("x") is a syntax extension
function which declares x to be a NOFIX operator.  Do
DESCRIBE(SYNTAX); for more details.

</P>


<H2><A NAME="SEC14" HREF="maxima_toc.html#TOC14">OPERATOR</A></H2>
<P>
 - See OPERATORS

</P>


<H2><A NAME="SEC15" HREF="maxima_toc.html#TOC15">POSTFIX</A></H2>
<P>
 - POSTFIX operators like the PREFIX variety denote functions
of a single argument, but in this case the argument immediately
precedes an occurrence of the operator in the input string, e.g. 3! .
The POSTFIX("x") function is a syntax extension function to declare x
to be a POSTFIX operator.  Do DESCRIBE(SYNTAX); for details.

</P>


<H2><A NAME="SEC16" HREF="maxima_toc.html#TOC16">PREFIX</A></H2>
<P>
 - A PREFIX operator is one which signifies a function of one
argument, which argument immediately follows an occurrence of the
operator.  PREFIX("x") is a syntax extension function to declare x to
be a PREFIX operator.  Do DESCRIBE(SYNTAX); for more details.

</P>


<H2><A NAME="SEC17" HREF="maxima_toc.html#TOC17">Definitions for Operators</A></H2>
<P>
<DL>
<DT><U>operator:</U> <B>"!"</B>
<DD><A NAME="IDX37"></A>
The factorial operator, which is the product of all the integers
from 1 up to its argument.  Thus 5! = 1*2*3*4*5 = 120.  The value of
/the option FACTLIM (default: [-1]) gives the highest factorial which is
automatically expanded.  If it is -1 then all integers are expanded.
See also the FACTORIAL, MINFACTORIAL, and FACTCOMB commands.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>"!!"</B>
<DD><A NAME="IDX38"></A>
Stands for double factorial which is defined as the product of
all the consecutive odd (or even) integers from 1 (or 2) to the odd
(or even) argument.  Thus 8!! is 2*4*6*8 = 384.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>"#"</B>
<DD><A NAME="IDX39"></A>
The logical operator "Not equals".

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>"."</B>
<DD><A NAME="IDX40"></A>
The dot operator, for matrix (non-commutative) multiplication.
When "." is used in this way, spaces should be left on both sides of
it, e.g. A . B.  This distinguishes it plainly from a decimal point in
a floating point number.  Do APROPOS(DOT); for a list of the switches
which affect the dot operator.  DESCRIBE(switch-name); will explain
them.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>":"</B>
<DD><A NAME="IDX41"></A>
The assignment operator.  E.g. A:3 sets the variable A to 3.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>"::"</B>
<DD><A NAME="IDX42"></A>
Assignment operator.  :: assigns the value of the expression
on its right to the value of the quantity on its left, which must
evaluate to an atomic variable or subscripted variable.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>"::="</B>
<DD><A NAME="IDX43"></A>
The "::=" is used instead of ":=" to indicate that what
follows is a macro definition, rather than an ordinary functional
definition.  See DESCRIBE(MACROS).

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>":="</B>
<DD><A NAME="IDX44"></A>
The function definition operator.  E.g. F(X):=SIN(X) defines
a function F.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>"="</B>
<DD><A NAME="IDX45"></A>
denotes an equation to MACSYMA.  To the pattern matcher in
MACSYMA it denotes a total relation that holds between two expressions
if and only if the expressions are syntactically identical.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ABS</B> <I>(exp)</I>
<DD><A NAME="IDX46"></A>
returns the absolute value exp.  If exp is complex, returns the complex
modulus of exp.

</P>
</DL>
<P>
<DL>
<DT><U>special symbol:</U> <B>ADDITIVE</B>
<DD><A NAME="IDX47"></A>
 - If DECLARE(F,ADDITIVE) has been executed, then:
(1) If F is univariate, whenever the simplifier encounters F applied
to a sum, F will be distributed over that sum.  I.e. F(Y+X); will
simplify to F(Y)+F(X).
(2) If F is a function of 2 or more arguments, additivity is defined as 
additivity in the first argument to F, as in the case of 'SUM or 
'INTEGRATE, i.e. F(H(X)+G(X),X); will simplify to F(H(X),X)+F(G(X),X).
This simplification does not occur when F is applied to expressions of
the form SUM(X[I],I,lower-limit,upper-limit).

</P>
</DL>
<P>
<DL>
<DT><U>keyword:</U> <B>ALLBUT</B>
<DD><A NAME="IDX48"></A>
 works with the PART commands (i.e. PART, INPART, SUBSTPART,
SUBSTINPART, DPART, and LPART).  For example,

</P>

<PRE>
if EXPR is E+D+C+B+A,
then PART(EXPR,[2,5]);
==&#62; D+A
</PRE>

<P>
while

<PRE>
PART(EXPR,ALLBUT(2,5))==&#62;E+C+B
</PRE>

<P>
It also works with the KILL command,

<PRE>
KILL(ALLBUT(name1,...,namek))
</PRE>

<P>
will do a KILL(ALL) except it will not
KILL the names specified.  Note: namei means a name such as function
name such as U, F, FOO, or G, not an infolist such as FUNCTIONS.

</P>

</DL>
<P>
<DL>
<DT><U>declaration:</U> <B>ANTISYMMETRIC</B>
<DD><A NAME="IDX49"></A>
 - If DECLARE(H,ANTISYMMETRIC); is done, this tells the
simplifier that H is antisymmetric.  E.g. H(X,Z,Y) will simplify to -
H(X, Y, Z).  That is, it will give (-1)^n times the result given by
SYMMETRIC or COMMUTATIVE, where n is the number of interchanges of two
arguments necessary to convert it to that form.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CABS</B> <I>(exp)</I>
<DD><A NAME="IDX50"></A>
returns the complex absolute value (the complex modulus) of
exp.

</P>
</DL>
<P>
<DL>
<DT><U>declaration:</U> <B>COMMUTATIVE</B>
<DD><A NAME="IDX51"></A>
 - If DECLARE(H,COMMUTATIVE); is done, this tells the
simplifier that H is a commutative function.  E.g. H(X,Z,Y) will
simplify to H(X, Y, Z).  This is the same as SYMMETRIC.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ENTIER</B> <I>(X)</I>
<DD><A NAME="IDX52"></A>
largest integer &#60;= X where X is numeric.  FIX (as in
FIXnum) is a synonym for this, so FIX(X); is precisely the same.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EQUAL</B> <I>(expr1,expr2)</I>
<DD><A NAME="IDX53"></A>
used with an "IS", returns TRUE (or FALSE) if
and only if expr1 and expr2 are equal (or not equal) for all possible
values of their variables (as determined by RATSIMP).  Thus
IS(EQUAL((X+1)**2,X**2+2*X+1)) returns TRUE whereas if X is unbound
IS((X+1)**2=X**2+2*X+1) returns FALSE.  Note also that IS(RAT(0)=0)
gives FALSE but IS(EQUAL(RAT(0),0)) gives TRUE.  If a determination
can't be made with EQUAL then a simplified but equivalent form is
returned whereas = always causes either TRUE or FALSE to be returned.
All variables occurring in exp are presumed to be real valued.
EV(exp,PRED) is equivalent to IS(exp).

<PRE>
(C1) IS(X**2 &#62;= 2*X-1);
(D1)                               TRUE
(C2) ASSUME(A&#62;1);
(D2)                               DONE
(C3) IS(LOG(LOG(A+1)+1)&#62;0 AND A^2+1&#62;2*A);
(D3)                               TRUE

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EVAL</B>
<DD><A NAME="IDX54"></A>
 causes an extra post-evaluation of exp to occur.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EVENP</B> <I>(exp)</I>
<DD><A NAME="IDX55"></A>
is TRUE if exp is an even integer.  FALSE is returned in
all other cases.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FIX</B> <I>(x)</I>
<DD><A NAME="IDX56"></A>
a synonym for ENTIER(X) - largest integer &#60;= X where X is
numeric.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FULLMAP</B> <I>(fn, exp1, ...)</I>
<DD><A NAME="IDX57"></A>
is similar to MAP but it will keep mapping
down all subexpressions until the main operators are no longer the
same.  The user should be aware that FULLMAP is used by the MACSYMA
simplifier for certain matrix manipulations; thus, the user might see
an error message concerning FULLMAP even though FULLMAP was not
explicitly called by the user.

<PRE>
(C1) A+B*C$
(C2) FULLMAP(G,%);
(D2)              G(B) G(C) + G(A)
(C3)  MAP(G,D1);
(D3)                G(B C) + G(A)

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FULLMAPL</B> <I>(fn, list1, ...)</I>
<DD><A NAME="IDX58"></A>
is similar to FULLMAP but it only maps onto
lists and matrices

<PRE>
(C1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);
(D1)                      [[A + 3, 4], [4, 3.5]]

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>IS</B> <I>(exp)</I>
<DD><A NAME="IDX59"></A>
attempts to determine whether exp (which must evaluate to a
predicate) is provable from the facts in the current data base.  IS
returns TRUE if the predicate is true for all values of its variables
consistent with the data base and returns FALSE if it is false for all
such values.  Otherwise, its action depends on the setting of the
switch PREDERROR (default: TRUE). IS errs out if the value of
PREDERROR is TRUE and returns UNKNOWN if PREDERROR is FALSE.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ISQRT</B> <I>(X)</I>
<DD><A NAME="IDX60"></A>
takes one integer argument and returns the "integer SQRT"
of its absolute value.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MAX</B> <I>(X1, X2, ...)</I>
<DD><A NAME="IDX61"></A>
yields the maximum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MIN</B> <I>(X1, X2, ...)</I>
<DD><A NAME="IDX62"></A>
yields the minimum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MOD</B> <I>(poly)</I>
<DD><A NAME="IDX63"></A>
converts the polynomial poly to a modular representation
with respect to the current modulus which is the value of the variable
MODULUS.  
MOD(poly,m) specifies a MODULUS m to be used for converting poly, if
it is desired to override the current global value of MODULUS.
See DESCRIBE(MODULUS); .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ODDP</B> <I>(exp)</I>
<DD><A NAME="IDX64"></A>
is TRUE if exp is an odd integer.  FALSE is returned in all
other cases.

</P>
</DL>
<P>
<DL>
<DT><U>operator:</U> <B>PRED</B>
<DD><A NAME="IDX65"></A>
 (EVFLAG) causes predicates (expressions which evaluate to TRUE
or FALSE) to be evaluated.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>RANDOM</B> <I>(X)</I>
<DD><A NAME="IDX66"></A>
returns a random integer between 0 and X-1.  If no
argument is given then a random integer between -2^(29) and 2^(29) -1
is returned.  If X is FALSE then the random sequence is restarted from
the beginning.
Note that the range of the returned result when no argument is given
differs in NIL MACSYMA from that of PDP-10 and Multics MACSYMA, which
is -2^(35) to 2^(35) -1.  This range is the range of the FIXNUM
datatype of the underlying LISP.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SIGN</B> <I>(exp)</I>
<DD><A NAME="IDX67"></A>
attempts to determine the sign of its specified expression
on the basis of the facts in the current data base.  It returns one of
the following answers: POS (positive), NEG (negative), ZERO, PZ
(positive or zero), NZ (negative or zero), PN (positive or negative),
or PNZ (positive, negative, or zero, i.e. nothing known).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SIGNUM</B> <I>(X)</I>
<DD><A NAME="IDX68"></A>
if X&#60;0 then -1 else if X&#62;0 then 1 else 0.  If X is not
numeric then a simplified but equivalent form is returned. For
example, SIGNUM(-X) gives -SIGNUM(X).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SORT</B> <I>(list,optional-predicate)</I>
<DD><A NAME="IDX69"></A>
sorts the list using a suitable
optional-predicate of two arguments (such as "&#60;" or ORDERLESSP).  If
the optional-predicate is not given, then MACSYMA's built-in ordering
predicate is used.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SQRT</B> <I>(X)</I>
<DD><A NAME="IDX70"></A>
the square root of X. It is represented internally by
X^(1/2).  Also see ROOTSCONTRACT.
RADEXPAND[TRUE] - if TRUE will cause nth roots of factors of a product
which are powers of n to be pulled outside of the radical, e.g.
SQRT(16*X^2) will become 4*X only if RADEXPAND is TRUE.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>SQRTDISPFLAG</B>
<DD><A NAME="IDX71"></A>
 default: [TRUE] - if FALSE causes SQRT to display with
exponent 1/2.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBLIS</B> <I>(list,expr)</I>
<DD><A NAME="IDX72"></A>
allows multiple substitutions into an expression in
parallel.  Sample syntax:

<PRE>
        SUBLIS([A=B,B=A],SIN(A)+COS(B));
         =&#62; SIN(B) + COS(A)
</PRE>

<P>
The variable SUBLIS_APPLY_LAMBDA[TRUE] controls simplification after
SUBLIS.  For full documentation, see the file SHARE2;SUBLIS INFO.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBLIST</B> <I>(L,F)</I>
<DD><A NAME="IDX73"></A>
returns the list of elements of the list L for which the
function F returns TRUE.  E.g., SUBLIST([1,2,3,4],EVENP); returns
[2,4].

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>SUBLIS_APPLY_LAMBDA</B>
<DD><A NAME="IDX74"></A>
 default:[TRUE] - controls whether LAMBDA's
substituted are applied in simplification after SUBLIS is used or
whether you have to do an EV to get things to apply. TRUE means do the
application.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBST</B> <I>(a, b, c)</I>
<DD><A NAME="IDX75"></A>
substitutes a for b in c.  b must be an atom, or a
complete subexpression of c.  For example, X+Y+Z is a complete
subexpression of 2*(X+Y+Z)/W while X+Y is not. When b does not have
these characteristics, one may sometimes use SUBSTPART or RATSUBST
(see below).  Alternatively, if b is of the form e/f then one could
use SUBST(a*f,e,c) while if b is of the form e**(1/f) then one could
use SUBST(a**f,e,c).  The SUBST command also discerns the X^Y in X^-Y
so that SUBST(A,SQRT(X),1/SQRT(X)) yields 1/A.  a and b may also be
operators of an expression enclosed in "s or they may be function
names.  If one wishes to substitute for the independent variable in
derivative forms then the AT function (see below) should be used.
Note:  SUBST is an alias for SUBSTITUTE.
SUBST(eq1,exp) or SUBST([eq1,...,eqk],exp) are other permissible
forms.  The eqi are equations indicating substitutions to be made.
For each equation, the right side will be substituted for the left in
the expression exp.
EXPTSUBST[FALSE] if TRUE permits substitutions like Y for %E**X in
%E**(A*X) to take place.
OPSUBST[TRUE] if FALSE, SUBST will not attempt to substitute into the
operator of an expression.  E.g. (OPSUBST:FALSE, SUBST(X^2,R,R+R[0]));
will work.

<PRE>
(C1) SUBST(A,X+Y,X+(X+Y)**2+Y);
                                 2
(D1)                    Y + X + A
(C2) SUBST(-%I,%I,A+B*%I);
(D2)                             A - %I B

</PRE>

<P>
(Note that C2 is one way of obtaining the complex conjugate of an analytic
expression.)  For further examples, do EXAMPLE(SUBST);

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBSTINPART</B> <I>(x, exp, n1, ...)</I>
<DD><A NAME="IDX76"></A>
is like SUBSTPART but works on the
internal representation of exp.

<PRE>
(C1) X.'DIFF(F(X),X,2);
                                   2
                                  d
(D1)                         X . (--- F(X))
                                    2
                                  dX
(C2) SUBSTINPART(D**2,%,2);
                                      2
(D2)                             X . D
(C3) SUBSTINPART(F1,F[1](X+1),0);
(D3)                            F1(X + 1)
              Additional Information
If the last argument to a part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus

<PRE>
(C1) PART(X+Y+Z,[1,3]);
(D1) Z+X
</PRE>

PIECE holds the value of the last expression selected when using the
part functions.  It is set during the execution of the function and
thus may be referred to in the function itself as shown below.
If PARTSWITCH[FALSE] is set to TRUE then END is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.
(C1)  27*Y**3+54*X*Y**2+36*X**2*Y+Y+8*X**3+X+1;
            3         2       2            3
(D1)    27 Y  + 54 X Y  + 36 X  Y + Y + 8 X  + X + 1
(C2)  PART(D1,2,[1,3]);
                  2
(D2)          54 Y
(C3)  SQRT(PIECE/54);
(D3)            Y
(C4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);
                          3
(D4)           (3 Y + 2 X) + Y + X + 1
(C5) 1/X+Y/X-1/Z;
                                 1   Y   1
(D5)                           - - + - + -
                                 Z   X   X
(C6) SUBSTPART(XTHRU(PIECE),%,[2,3]);
                                Y + 1   1
(D6)                            ----- - -
                                  X     Z

</PRE>

<P>
Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART is 
the same as calling INPART/SUBSTINPART.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBSTPART</B> <I>(x, exp, n1, ..., nk)</I>
<DD><A NAME="IDX77"></A>
substitutes x for the subexpression
picked out by the rest of the arguments as in PART.  It returns the
new value of exp.  x may be some operator to be substituted for an
operator of exp.  In some cases it needs to be enclosed in "s (e.g.
SUBSTPART("+",A*B,0); -&#62; B + A ).

<PRE>
(C1) 1/(X**2+2);
                                    1
(D1)                              ------
                                   2
                                  X  + 2
(C2) SUBSTPART(3/2,%,2,1,2);
                                    1
(D2)                             --------
                                  3/2
                                 X    + 2
(C3) A*X+F(B,Y);
(D3)                          A X + F(B, Y)
(C4) SUBSTPART("+",%,1,0);
(D4)                         X + F(B, Y) + A

</PRE>

<P>
Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART is 
the same as calling INPART/SUBSTINPART.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBVARP</B> <I>(exp)</I>
<DD><A NAME="IDX78"></A>
is TRUE if exp is a subscripted variable, for example
A[I].

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SYMBOLP</B> <I>(exp)</I>
<DD><A NAME="IDX79"></A>
returns TRUE if "exp" is a "symbol" or "name", else
FALSE.  I.e., in effect, SYMBOLP(X):=ATOM(X) AND NOT NUMBERP(X)$ .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>UNORDER</B> <I>()</I>
<DD><A NAME="IDX80"></A>
stops the aliasing created by the last use of the ordering
commands ORDERGREAT and ORDERLESS.  ORDERGREAT and ORDERLESS may not
be used more than one time each without calling UNORDER.  Do
DESCRIBE(ORDERGREAT); and DESCRIBE(ORDERLESS);, and also do
EXAMPLE(UNORDER); for specifics.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>VECTORPOTENTIAL</B> <I>(givencurl)</I>
<DD><A NAME="IDX81"></A>
Returns the vector potential of a given
curl vector, in the current coordinate system.
POTENTIALZEROLOC has a similar role as for POTENTIAL, but the order of
the left-hand sides of the equations must be a cyclic permutation of
the coordinate variables.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>XTHRU</B> <I>(exp)</I>
<DD><A NAME="IDX82"></A>
combines all terms of exp (which should be a sum) over a
common denominator without expanding products and exponentiated sums
as RATSIMP does.  XTHRU cancels common factors in the numerator and
denominator of rational expressions but only if the factors are
explicit.  Sometimes it is better to use XTHRU before RATSIMPing an
expression in order to cause explicit factors of the gcd of the
numerator and denominator to be canceled thus simplifying the
expression to be RATSIMPed.

<PRE>
(C1) ((X+2)**20-2*Y)/(X+Y)**20+(X+Y)**-19-X/(X+Y)**20;
                                                20
                     1           X       (X + 2)   - 2 Y
(D1)             --------- - --------- + ---------------
                        19          20             20
                 (Y + X)     (Y + X)        (Y + X)
(C2) XTHRU(%);
                                     20
                              (X + 2)   - Y
(D2)                          -------------
                                       20
                                (Y + X)

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ZEROEQUIV</B> <I>(exp,var)</I>
<DD><A NAME="IDX83"></A>
tests whether the expression exp in the variable
var is equivalent to zero.  It returns either TRUE, FALSE, or
DONTKNOW.  For example ZEROEQUIV(SIN(2*X) - 2*SIN(X)*COS(X),X) returns
TRUE and ZEROEQUIV(%E^X+X,X) returns FALSE.  On the other hand
ZEROEQUIV(LOG(A*B) - LOG(A) - LOG(B),A) will return DONTKNOW because
of the presence of an extra parameter.  The restrictions are:
(1) Do not use functions that MACSYMA does not know how to
differentiate and evaluate.
(2) If the expression has poles on the real line, there may be errors
in the result (but this is unlikely to occur).
(3) If the expression contains functions which are not solutions to
first order differential equations (e.g.  Bessel functions) there may
be incorrect results.
(4) The algorithm uses evaluation at randomly chosen points for
carefully selected subexpressions.  This is always a somewhat
hazardous business, although the algorithm tries to minimize the
potential for error.

</P>
</DL>

<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_3.html">previous</A>, <A HREF="maxima_5.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
