This is maxima.info, produced by makeinfo version 4.1 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Matrices and Linear Algebra,  Prev: Introduction to Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

Definitions for Matrices and Linear Algebra
===========================================

 - Function: ADDCOL (M,list1,list2,...,listn)
     appends the column(s) given by the one or more lists (or matrices)
     onto the matrix M.


 - Function: ADDROW (M,list1,list2,...,listn)
     appends the row(s) given by the one or more lists (or matrices)
     onto the matrix M.


 - Function: ADJOINT (matrix)
     computes the adjoint of a matrix.


 - Function: AUGCOEFMATRIX ([eq1, ...], [var1, ...])
     the augmented coefficient matrix for the variables var1,... of the
     system of linear equations eq1,....  This is the coefficient
     matrix with a column adjoined for the constant terms in each
     equation (i.e. those not dependent upon var1,...).  Do
     EXAMPLE(AUGCOEFMATRIX); for an example.


 - Function: CHARPOLY (M, var)
     computes the characteristic polynomial for Matrix M with respect
     to var.  That is, DETERMINANT(M - DIAGMATRIX(LENGTH(M),var)).  For
     examples of this command, do EXAMPLE(CHARPOLY); .


 - Function: COEFMATRIX ([eq1, ...], [var1, ...])
     the coefficient matrix for the variables var1,... of the system of
     linear equations eq1,...


 - Function: COL (M,i)
     gives a matrix of the ith column of the matrix M.


 - Function: COLUMNVECTOR (X)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     COLUMNVECTOR takes a LIST as its argument and returns a column
     vector the components of which are the elements of the list.  The
     first element is the first component,...etc...(This is useful if
     you want to use parts of the outputs of the functions in this
     package in matrix calculations.)


 - Function: CONJUGATE (X)
     a function in the EIGEN package on the SHARE directory.  It
     returns the complex conjugate of its argument.  This package may
     be loaded by LOAD(EIGEN); .  For a complete description of this
     package, do PRINTFILE("eigen.usg"); .


 - Function: COPYMATRIX (M)
     creates a copy of the matrix M.  This is the only way to make a
     copy aside from recreating M elementwise.  Copying a matrix may be
     useful when SETELMX is used.


 - Function: DETERMINANT (M)
     computes the determinant of M by a method similar to Gaussian
     elimination.  The form of the result depends upon the setting of
     the switch RATMX.  There is a special routine for dealing with
     sparse determininants which can be used by setting the switches
     RATMX:TRUE and SPARSE:TRUE.


 - Variable: DETOUT
     default: [FALSE] if TRUE will cause the determinant of a matrix
     whose inverse is computed to be kept outside of the inverse.  For
     this switch to have an effect DOALLMXOPS and DOSCMXOPS should be
     FALSE (see their descriptions).  Alternatively this switch can be
     given to EV which causes the other two to be set correctly.


 - Function: DIAGMATRIX (n, x)
     returns a diagonal matrix of size n by n with the diagonal
     elements all x.  An identity matrix is created by DIAGMATRIX(n,1),
     or one may use IDENT(n).


 - Variable: DOALLMXOPS
     default: [TRUE] if TRUE all operations relating to matrices are
     carried out.  If it is FALSE then the setting of the individual
     DOT switches govern which operations are performed.


 - Variable: DOMXEXPT
     default: [TRUE] if TRUE,
          %E^MATRIX([1,2],[3,4]) ==>
          MATRIX([%E,%E^2],[%E^3,%E^4])
     In general, this transformation affects expressions of the form
     <base>^<power> where <base> is an expression assumed scalar or
     constant, and <power> is a list or matrix.  This transformation is
     turned off if this switch is set to FALSE.


 - Variable: DOMXMXOPS
     default: [TRUE] if TRUE then all matrix-matrix or matrix-list
     operations are carried out (but not scalar-matrix operations); if
     this switch is FALSE they are not.


 - Variable: DOMXNCTIMES
     default: [FALSE] Causes non-commutative products of matrices to be
     carried out.


 - Variable: DONTFACTOR
     default: [] may be set to a list of variables with respect to
     which factoring is not to occur.  (It is initially empty).
     Factoring also will not take place with respect to any variables
     which are less important (using the variable ordering assumed for
     CRE form) than those on the DONTFACTOR list.


 - Variable: DOSCMXOPS
     default: [FALSE] if TRUE then scalar-matrix operations are
     performed.


 - Variable: DOSCMXPLUS
     default: [FALSE] if TRUE will cause SCALAR + MATRIX to give a
     matrix answer.  This switch is not subsumed under DOALLMXOPS.


 - Variable: DOT0NSCSIMP
     default: [TRUE] Causes a non-commutative product of zero and a
     nonscalar term to be simplified to a commutative product.


 - Variable: DOT0SIMP
     default: [TRUE] Causes a non-commutative product of zero and a
     scalar term to be simplified to a commutative product.


 - Variable: DOT1SIMP
     default: [TRUE] Causes a non-commutative product of one and
     another term to be simplified to a commutative product.


 - Variable: DOTASSOC
     default: [TRUE] when TRUE causes (A.B).C to simplify to A.(B.C)


 - Variable: DOTCONSTRULES
     default: [TRUE] Causes a non-commutative product of a constant and
     another term to be simplified to a commutative product.  Turning
     on this flag effectively turns on DOT0SIMP, DOT0NSCSIMP, and
     DOT1SIMP as well.


 - Variable: DOTDISTRIB
     default: [FALSE] if TRUE will cause A.(B+C) to simplify to A.B+A.C


 - Variable: DOTEXPTSIMP
     default: [TRUE] when TRUE causes A.A to simplify to A^^2


 - Variable: DOTIDENT
     default: [1]  The value to be returned by X^^0.


 - Variable: DOTSCRULES
     default: [FALSE] when TRUE will cause A.SC or SC.A to simplify to
     SC*A and A.(SC*B) to simplify to SC*(A.B)


 - Function: ECHELON (M)
     produces the echelon form of the matrix M.  That is, M with
     elementary row operations performed on it such that the first
     non-zero element in each row in the resulting matrix is a one and
     the column elements under the first one in each row are all zero.
                                  [2  1 - A  -5 B ]
          (D2)                    [               ]
                                  [A    B      C  ]
          
          (C3) ECHELON(D2);
                           [      A - 1        5 B      ]
                           [1   - -----      - ---      ]
                           [        2           2       ]
          (D3)             [                            ]
                           [                2 C + 5 A B ]
                           [0     1         ------------]
                           [                       2    ]
                           [                2 B + A  - A]

 - Function: EIGENVALUES (mat)
     There is a package on the SHARE; directory which contains
     functions for computing EIGENVALUES and EIGENVECTORS and related
     matrix computations.  For information on it do
     PRINTFILE(EIGEN,USAGE,SHARE); .  EIGENVALUES(mat) takes a MATRIX
     as its argument and returns a list of lists the first sublist of
     which is the list of eigenvalues of the matrix and the other
     sublist of which is the list of the multiplicities of the
     eigenvalues in the corresponding order.  [ The MACSYMA function
     SOLVE is used here to find the roots of the characteristic
     polynomial of the matrix.  Sometimes SOLVE may not be able to find
     the roots of the polynomial;in that case nothing in this package
     except CONJUGATE, INNERPRODUCT, UNITVECTOR, COLUMNVECTOR and
     GRAMSCHMIDT will work unless you know the eigenvalues.  In some
     cases SOLVE may generate very messy eigenvalues.  You may want to
     simplify the answers yourself before you go on.  There are
     provisions for this and they will be explained below.  ( This
     usually happens when SOLVE returns a not-so-obviously real
     expression for an eigenvalue which is supposed to be real...)]
     The EIGENVALUES command is available directly from MACSYMA.  To
     use the other functions you must have loaded in the EIGEN package,
     either by a previous call to EIGENVALUES, or by doing
     LOADFILE("eigen"); .


 - Function: EIGENVECTORS (MAT)
     takes a MATRIX as its argument and returns a list of lists the
     first sublist of which is the output of the EIGENVALUES command
     and the other sublists of which are the eigenvectors of the matrix
     corresponding to those eigenvalues respectively.  This function
     will work directly from MACSYMA, but if you wish to take advantage
     of the flags for controlling it (see below), you must first load
     in the EIGEN package from the SHARE; directory.  You may do that by
     LOADFILE("eigen");.  The flags that affect this function are:
     NONDIAGONALIZABLE[FALSE] will be set to TRUE or FALSE depending on
     whether the matrix is nondiagonalizable or diagonalizable after an
     EIGENVECTORS command is executed.  HERMITIANMATRIX[FALSE] If set
     to TRUE will cause the degenerate eigenvectors of the hermitian
     matrix to be orthogonalized using the Gram-Schmidt algorithm.
     KNOWNEIGVALS[FALSE] If set to TRUE the EIGEN package will assume
     the eigenvalues of the matrix are known to the user and stored
     under the global name LISTEIGVALS.  LISTEIGVALS should be set to a
     list similar to the output of the EIGENVALUES command.  ( The
     MACSYMA function ALGSYS is used here to solve for the
     eigenvectors. Sometimes if the eigenvalues are messy, ALGSYS may
     not be able to produce a solution.  In that case you are advised
     to try to simplify the eigenvalues by first finding them using
     EIGENVALUES command and then using whatever marvelous tricks you
     might have to reduce them to something simpler.  You can then use
     the KNOWNEIGVALS flag to proceed further. )


 - Function: EMATRIX (m, n, x, i, j)
     will create an m by n matrix all of whose elements are zero except
     for the i,j element which is x.


 - Function: ENTERMATRIX (m, n)
     allows one to enter a matrix element by element with MACSYMA
     requesting values for each of the m*n entries.
          (C1) ENTERMATRIX(3,3);
          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
           4. General
          
          Answer 1, 2, 3 or 4
          1;
          Row 1 Column 1:  A;
          Row 2 Column 2:  B;
          Row 3 Column 3:  C;
          Matrix entered.
                                           [ A  0  0 ]
                                           [         ]
          (D1)                             [ 0  B  0 ]
                                           [         ]
                                           [ 0  0  C ]

 - Function: GENMATRIX (array, i2, j2, i1, j1)
     generates a matrix from the array using array(i1,j1) for the first
     (upper-left) element and array(i2,j2) for the last (lower-right)
     element of the matrix.  If j1=i1 then j1 may be omitted. If
     j1=i1=1 then i1 and j1 may both be omitted. If a selected element
     of the array doesn't exist a symbolic one will be used.
          (C1) H[I,J]:=1/(I+J-1)$
          (C2) GENMATRIX(H,3,3);
                                     [   1  1]
                                     [1  -  -]
                                     [   2  3]
                                     [       ]
                                     [1  1  1]
          (D2)                       [-  -  -]
                                     [2  3  4]
                                     [       ]
                                     [1  1  1]
                                     [-  -  -]
                                     [3  4  5]

 - Function: GRAMSCHMIDT (X)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     GRAMSCHMIDT takes a LIST of lists the sublists of which are of
     equal length and not necessarily orthogonal (with respect to the
     innerproduct defined above) as its argument and returns a similar
     list each sublist of which is orthogonal to all others.  (Returned
     results may contain integers that are factored.  This is due to
     the fact that the MACSYMA function FACTOR is used to simplify each
     substage of the Gram-Schmidt algorithm.  This prevents the
     expressions from getting very messy and helps to reduce the sizes
     of the numbers that are produced along the way.)


 - Function: HACH (a,b,m,n,l)
     An implementation of Hacijan's linear programming algorithm is
     available by doing BATCH("kach.mc"$.  Details of use are available
     by doing BATCH("kach.dem");


 - Function: IDENT (n)
     produces an n by n identity matrix.


 - Function: INNERPRODUCT (X,Y)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     INNERPRODUCT takes two LISTS of equal length as its arguments and
     returns their inner (scalar) product defined by (Complex Conjugate
     of X).Y (The "dot" operation is the same as the usual one defined
     for vectors).


 - Function: INVERT (matrix)
     finds the inverse of a matrix using the adjoint method.  This
     allows a user to compute the inverse of a matrix with bfloat
     entries or polynomials with floating pt. coefficients without
     converting to cre-form.  The DETERMINANT command is used to compute
     cofactors, so if RATMX is FALSE (the default) the inverse is
     computed without changing the representation of the elements.  The
     current implementation is inefficient for matrices of high order.
     The DETOUT flag if true keeps the determinant factored out of the
     inverse.  Note: the results are not automatically expanded.  If
     the matrix originally had polynomial entries, better appearing
     output can be generated by EXPAND(INVERT(mat)),DETOUT.  If it is
     desirable to then divide through by the determinant this can be
     accomplished by XTHRU(%) or alternatively from scratch by
     EXPAND(ADJOINT(mat))/EXPAND(DETERMINANT(mat)).
     INVERT(mat):=ADJOINT(mat)/DETERMINANT(mat).  See also
     DESCRIBE("^^"); for another method of inverting a matrix.


 - Variable: LMXCHAR
     default: [[] - The character used to display the (left) delimiter
     of a matrix (see also RMXCHAR).


 - Function: MATRIX (row1, ..., rown)
     defines a rectangular matrix with the indicated rows.  Each row
     has the form of a list of expressions, e.g.  [A, X**2, Y, 0] is a
     list of 4 elements.  There are a number of MACSYMA commands which
     deal with matrices, for example:  DETERMINANT, CHARPOLY,
     GENMATRIX, ADDCOL, ADDROW, COPYMATRIX, TRANSPOSE, ECHELON, and
     RANK.  There is also a package on the SHARE directory for
     computing EIGENVALUES.  Try DESCRIBE on these for more information.
     Matrix multiplication is effected by using the dot operator, ".",
     which is also convenient if the user wishes to represent other
     non-commutative algebraic operations.  The exponential of the "."
     operation is "^^" .  Thus, for a matrix A, A.A = A^^2 and, if it
     exists, A^^-1 is the inverse of A.  The operations +,-,*,** are
     all element-by-element operations; all operations are normally
     carried out in full, including the . (dot) operation.  Many
     switches exist for controlling simplification rules involving dot
     and matrix-list operations.  Options Relating to Matrices:
     LMXCHAR, RMXCHAR, RATMX, LISTARITH, DETOUT, DOALLMXOPS, DOMXEXPT
     DOMXMXOPS, DOSCMXOPS, DOSCMXPLUS, SCALARMATRIX, and SPARSE.  Do
     DESCRIBE(option) for details on them.


 - Function: MATRIXMAP (fn, M)
     will map the function fn onto each element of the matrix M.


 - Function: MATRIXP (exp)
     is TRUE if exp is a matrix else FALSE.


 - Variable: MATRIX_ELEMENT_ADD
     default: [+] - May be set to "?"; may also be the name of a
     function, or a LAMBDA expression.  In this way, a rich variety of
     algebraic structures may be simulated.  For more details, do
     DEMO("matrix.dem1"); and DEMO("matrix.dem2");.


 - Variable: MATRIX_ELEMENT_MULT
     default: [*] - May be set to "."; may also be the name of a
     function, or a LAMBDA expression.  In this way, a rich variety of
     algebraic structures may be simulated.  For more details, do
     DEMO("matrix.dem1"); and DEMO("matrix.dem2");


 - Variable: MATRIX_ELEMENT_TRANSPOSE
     default: [FALSE] - Other useful settings are TRANSPOSE and
     NONSCALARS; may also be the name of a function, or a LAMBDA
     expression.  In this way, a rich variety of algebraic structures
     may be simulated.  For more details, do DEMO("matrix.dem1"); and
     DEMO("matrix.dem2");.


 - Function: MATTRACE (M)
     computes the trace [sum of the elements on the main diagonal] of
     the square matrix M.  It is used by NCHARPOLY, an alternative to
     MACSYMA's CHARPOLY.  It is used by doing LOADFILE("nchrpl");


 - Function: MINOR (M, i, j)
     computes the i,j minor of the matrix M.  That is, M with row i and
     column j removed.


 - Function: NCEXPT (A,B)
     if an (non-commutative) exponential expression is too wide to be
     displayed as A^^B it will appear as NCEXPT(A,B).


 - Function: NCHARPOLY (M,var)
     finds the characteristic polynomial of the matrix M with respect
     to var.  This is an alternative to MACSYMA's CHARPOLY.  NCHARPOLY
     works by computing traces of powers of the given matrix, which are
     known to be equal to sums of powers of the roots of the
     characteristic polynomial.  From these quantities the symmetric
     functions of the roots can be calculated, which are nothing more
     than the coefficients of the characteristic polynomial.  CHARPOLY
     works by forming the determinant of VAR * IDENT [N] - A.  Thus
     NCHARPOLY wins, for example, in the case of large dense matrices
     filled with integers, since it avoids polynomial arithmetic
     altogether.  It may be used by doing LOADFILE("nchrpl");


 - Function: NEWDET (M,n)
     also computes the determinant of M but uses the Johnson-Gentleman
     tree minor algorithm.  M may be the name of a matrix or array.
     The argument n is the order; it is optional if M is a matrix.


 - declaration: NONSCALAR
     - makes ai behave as does a list or matrix with respect to the dot
     operator.


 - Function: NONSCALARP (exp)
     is TRUE if exp is a non-scalar, i.e.  it contains atoms declared
     as non-scalars, lists, or matrices.


 - Function: PERMANENT (M,n)
     computes the permanent of the matrix M.  A permanent is like a
     determinant but with no sign changes.


 - Function: RANK (M)
     computes the rank of the matrix M.  That is, the order of the
     largest non-singular subdeterminant of M.  Caveat: RANK may return
     the wrong answer if it cannot determine that a matrix element that
     is equivalent to zero is indeed so.


 - Variable: RATMX
     default: [FALSE] - if FALSE will cause determinant and matrix
     addition, subtraction, and multiplication to be performed in the
     representation of the matrix elements and will cause the result of
     matrix inversion to be left in general representation.  If it is
     TRUE, the 4 operations mentioned above will be performed in CRE
     form and the result of matrix inverse will be in CRE form.  Note
     that this may cause the elements to be expanded (depending on the
     setting of RATFAC) which might not always be desired.


 - Function: ROW (M, i)
     gives a matrix of the ith row of matrix M.


 - Variable: SCALARMATRIXP
     default: [TRUE] - if TRUE, then whenever a 1 x 1 matrix is
     produced as a result of computing the dot product of matrices it
     will be converted to a scalar, namely the only element of the
     matrix.  If set to ALL, then this conversion occurs whenever a 1 x
     1 matrix is simplified.  If set to FALSE, no conversion will be
     done.


 - Function: SETELMX (x, i, j, M)
     changes the i,j element of M to x.  The altered matrix is returned
     as the value.  The notation M[i,j]:x may also be used, altering M
     in a similar manner, but returning x as the value.


 - Function: SIMILARITYTRANSFORM (MAT)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     SIMILARITYTRANSFORM takes a MATRIX as its argument and returns a
     list which is the output of the UNITEIGENVECTORS command.  In
     addition if the flag NONDIAGONALIZABLE is FALSE two global
     matrices LEFTMATRIX and RIGHTMATRIX will be generated.  These
     matrices have the property that LEFTMATRIX.MAT.RIGHTMATRIX is a
     diagonal matrix with the eigenvalues of MAT on the diagonal.  If
     NONDIAGONALIZABLE is TRUE these two matrices will not be
     generated.  If the flag HERMITIANMATRIX is TRUE then LEFTMATRIX is
     the complex conjugate of the transpose of RIGHTMATRIX.  Otherwise
     LEFTMATRIX is the inverse of RIGHTMATRIX.  RIGHTMATRIX is the
     matrix the columns of which are the unit eigenvectors of MAT.  The
     other flags (see DESCRIBE(EIGENVALUES); and
     DESCRIBE(EIGENVECTORS);) have the same effects since
     SIMILARITYTRANSFORM calls the other functions in the package in
     order to be able to form RIGHTMATRIX.


 - Variable: SPARSE
     default: [FALSE] - if TRUE and if RATMX:TRUE then DETERMINANT will
     use special routines for computing sparse determinants.


 - Function: SUBMATRIX (m1, ..., M, n1, ...)
     creates a new matrix composed of the matrix M with rows mi
     deleted, and columns ni deleted.


 - Function: TRANSPOSE (M)
     produces the transpose of the matrix M.


 - Function: TRIANGULARIZE (M)
     produces the upper triangular form of the matrix M which needn't
     be square.


 - Function: UNITEIGENVECTORS (MAT)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     UNITEIGENVECTORS takes a MATRIX as its argument and returns a list
     of lists the first sublist of which is the output of the
     EIGENVALUES command and the other sublists of which are the unit
     eigenvectors of the matrix corresponding to those eigenvalues
     respectively.  The flags mentioned in the description of the
     EIGENVECTORS command have the same effects in this one as well.  In
     addition there is a flag which may be useful :
     KNOWNEIGVECTS[FALSE] - If set to TRUE the EIGEN package will assume
     that the eigenvectors of the matrix are known to the user and are
     stored under the global name LISTEIGVECTS.  LISTEIGVECTS should be
     set to a list similar to the output of the EIGENVECTORS command.
     (If KNOWNEIGVECTS is set to TRUE and the list of eigenvectors is
     given the setting of the flag NONDIAGONALIZABLE may not be
     correct.  If that is the case please set it to the correct value.
     The author assumes that the user knows what he is doing and will
     not try to diagonalize a matrix the eigenvectors of which do not
     span the vector space of the appropriate dimension...)


 - Function: UNITVECTOR (X)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     UNITVECTOR takes a LIST as its argument and returns a unit list.
     (i.e. a list with unit magnitude).


 - Function: VECTORSIMP (vectorexpression)
     This function employs additional simplifications, together with
     various optional expansions according to the settings of the
     following global flags:

          EXPANDALL, EXPANDDOT, EXPANDDOTPLUS, EXPANDCROSS, EXPANDCROSSPLUS,
          EXPANDCROSSCROSS, EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD,
          EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD, EXPANDCURL, EXPANDCURLPLUS,
          EXPANDCURLCURL, EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS,
          EXPANDLAPLACIANPROD.

     All these flags have default value FALSE. The PLUS suffix refers to
     employing additivity or distributivity.  The PROD suffix refers to
     the expansion for an operand that is any kind of product.
     EXPANDCROSSCROSS refers to replacing p~(q~r) with (p.r)*q-(p.q)*r,
     and EXPANDCURLCURL refers to replacing CURL CURL p with GRAD DIV p
     + DIV GRAD p.  EXPANDCROSS:TRUE has the same effect as
     EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other flags,
     EXPANDPLUS and EXPANDPROD, have the same effect as setting all
     similarly suffixed flags true.  When TRUE, another flag named
     EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
     composition DIV GRAD.  All of these flags are initially FALSE.  For
     convenience, all of these flags have been declared EVFLAG.  For
     orthogonal curvilinear coordinates, the global variables
     COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are
     set by the function invocation


 - Variable: VECT_CROSS
     default:[FALSE] - If TRUE allows DIFF(X~Y,T) to work where ~ is
     defined in SHARE;VECT (where VECT_CROSS is set to TRUE, anyway.)


 - Function: ZEROMATRIX (m,n)
     takes integers m,n as arguments and returns an m by n matrix of
     0's.


 - special symbol: "["
     - [ and ] are the characters which MACSYMA uses to delimit a list.


File: maxima.info,  Node: Affine,  Next: Tensor,  Prev: Matrices and Linear Algebra,  Up: Top

Affine
******

* Menu:

* Definitions for Affine::


File: maxima.info,  Node: Definitions for Affine,  Prev: Affine,  Up: Affine

Definitions for Affine
======================

 - Function: FAST_LINSOLVE (eqns,variables)
     Solves the linear system of equations EQNS for the variables
     VARIABLES  and returns a result suitable to SUBLIS.  The function
     is faster than linsolve for system of equations which are sparse.


 - Function: GROBNER_BASIS (eqns)
     Takes as argument a macsyma list of equations and returns a
     grobner basis for them.  The function POLYSIMP may now be used to
     simplify other functions relative to the equations.

     GROBNER_BASIS([3*X^2+1,Y*X])$

     POLYSIMP(Y^2*X+X^3*9+2)==> -3*x+2

     Polysimp(f)==> 0 if and only if f is in the ideal generated by the
     EQNS  ie.  if and only if f is a polynomial combination of the
     elements of EQNS.


 - Function: SET_UP_DOT_SIMPLIFICATIONS (eqns,[check-thru-degree])
     The eqns are polynomial equations in non commutative variables.
     The value of CURRENT_VARIABLES is the list of variables used for
     computing degrees.  The equations must be homogeneous, in order
     for the procedure to terminate.

     If you have checked overlapping simplifications in
     DOT_SIMPLIFICATIONS above the degree of f, then the following is
     true: DOTSIMP(f)==> 0 if and only if f is in the ideal generated
     by the EQNS  ie.  if and only if f is a polynomial combination of
     the elements of EQNS.

     The degree is that returned by NC_DEGREE.   This in turn is
     influenced by the weights of individual variables.


 - Function: DECLARE_WEIGHT (var1,wt1,var2,wt2,...)
     Assigns VAR1 weight WT1, VAR2 weight wt2..  These are the weights
     used in computing NC_DEGREE.


 - Function: NC_DEGREE (poly)
     Degree of a non commutative polynomial.  See DECLARE_WEIGHTS.


 - Function: DOTSIMP (f)
     ==> 0 if and only if f is in the ideal generated by the EQNS  ie.
     if and only if f is a polynomial combination of the elements of
     EQNS.


 - Function: FAST_CENTRAL_ELEMENTS (variables,degree)
     if SET_UP_DOT_SIMPLIFICATIONS has been previously done, finds the
     central polynomials in the variables in the given degree, For
     example:
          set_up_dot_simplifications([y.x+x.y],3);
          fast_central_elements([x,y],2);
          [y.y,x.x];

 - Function: CHECK_OVERLAPS (degree,add-to-simps)
     checks the overlaps thru degree, making sure that you have
     sufficient simplification rules in each degree, for dotsimp to
     work correctly.  This process can be speeded up if you know before
     hand what the dimension of the space of monomials is.  If it is of
     finite global dimension, then HILBERT should be used.  If you
     don't know the monomial dimensions, do not specify a
     RANK_FUNCTIION.  An optional third argument RESET, false says
     don't bother to query about resetting things.


 - Function: MONO (vari,n)
     VARI is a list of variables.   Returns the list of independent
     monomials relative to the current dot_simplifications, in degree N


 - Function: MONOMIAL_DIMENSIONS (n)
     Compute the hilbert series through degreen n for the current
     algebra.


 - Function: EXTRACT_LINEAR_EQUATIONS (List_nc_polys,monoms)
     Makes a list of the coefficients of the polynomials in
     list_nc_polys of the monoms.  MONOMS is a list of noncommutative
     monomials.   The coefficients should be scalars.   Use
     LIST_NC_MONOMIALS to build the list of monoms.


 - Function: LIST_NC_MONOMIALS (polys_or_list)
     returns a list of the non commutative monomials occurring in a
     polynomial or a collection of polynomials.


 - Function: PCOEFF (poly monom [variables-to-exclude-from-cof
          (list-variables monom)])
     This function is called from lisp level, and uses internal poly
     format.

          CL-MAXIMA>>(setq me (st-rat #$x^2*u+y+1$))
          (#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))
          
          CL-MAXIMA>>(pcoeff me (st-rat #$x^2$))
          (#:U 1 1)

     Rule: if a variable appears in monom it must be to the exact power,
     and if it is in variables to exclude it may not appear unless it
     was in monom to the exact power.  (pcoeff pol 1 ..) will exclude
     variables like substituting them to be zero.


 - Function: NEW-DISREP (poly)
     From lisp this returns the general maxima format for an arg which
     is in st-rat form:

          (displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))
          
                 2
          Y + U X  + 1

 - Function: CREATE_LIST (form,var1,list1,var2,list2,...)
     Create a list by evaluating FORM with VAR1 bound to each element
     of LIST1, and for each such binding bind VAR2 to each element of
     LIST2,...  The number of elements in the result will be
     length(list1)*length(list2)*...  Each VARn must actually be a
     symbol-it will not be evaluated.  The LISTn args will be evaluated
     once at the beginning of the iteration.


          (C82) create_list1(x^i,i,[1,3,7]);
          (D82) [X,X^3,X^7]

     With a double iteration:
          (C79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (D79) [[A,E],[A,F],[A,H],[B,E],[B,F],[B,H]]

     Instead of LISTn two args maybe supplied each of which should
     evaluate to a number.   These will be the inclusive lower and
     upper bounds for the iteration.

          (C81) create_list([i,j],i,[1,2,3],j,1,i);
          (D81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note that the limits or list for the j variable can depend on the
     current value of i.


 - Variable: ALL_DOTSIMP_DENOMS
     if its value is FALSE the denominators encountered in getting
     dotsimps will not be collected.   To collect the denoms
          ALL_DOTSIMP_DENOMS:[];

     and they will be nconc'd onto the end of the list.



File: maxima.info,  Node: Tensor,  Next: Ctensor,  Prev: Affine,  Up: Top

Tensor
******

* Menu:

* Introduction to Tensor::
* Definitions for Tensor::


File: maxima.info,  Node: Introduction to Tensor,  Next: Definitions for Tensor,  Prev: Tensor,  Up: Tensor

Introduction to Tensor
======================

   - Indicial Tensor Manipulation package.  It may be loaded by
LOADFILE("itensr"); A manual for the Tensor packages is available in
share/tensor.descr.  A demo is available by DEMO("itenso.dem1"); (and
additional demos are in ("itenso.dem2"), ("itenso.dem3") and following).

   - There are two tensor packages in MACSYMA, CTENSR and ITENSR.
CTENSR is Component Tensor Manipulation, and may be accessed with
LOAD(CTENSR); .  ITENSR is Indicial Tensor Manipulation, and is loaded
by doing LOAD(ITENSR); A manual for CTENSR AND ITENSR is available from
the LCS Publications Office.  Request MIT/LCS/TM-167.  In addition,
demos exist on the TENSOR; directory under the filenames CTENSO DEMO1,
DEMO2, etc. and ITENSO DEMO1, DEMO2, etc.  Do DEMO("ctenso.dem1"); or
DEMO("itenso.dem2"); Send bugs or comments to RP or TENSOR.


File: maxima.info,  Node: Definitions for Tensor,  Prev: Introduction to Tensor,  Up: Tensor

Definitions for Tensor
======================

 - Function: CANFORM (exp)
     [Tensor Package] Simplifies exp by renaming dummy indices and
     reordering all indices as dictated by symmetry conditions imposed
     on them. If ALLSYM is TRUE then all indices are assumed symmetric,
     otherwise symmetry information provided by DECSYM declarations
     will be used. The dummy indices are renamed in the same manner as
     in the RENAME function. When CANFORM is applied to a large
     expression the calculation may take a considerable amount of time.
     This time can be shortened by calling RENAME on the expression
     first.  Also see the example under DECSYM. Note: CANFORM may not
     be able to reduce an expression completely to its simplest form
     although it will always return a mathematically correct result.


 - Function: CANTEN (exp)
     [Tensor Package] Simplifies exp by renaming (see RENAME) and
     permuting dummy indices. CANTEN is restricted to sums of tensor
     products in which no derivatives are present. As such it is limited
     and should only be used if CANFORM is not capable of carrying out
     the required simplification.


 - Function: CARG (exp)
     returns the argument (phase angle) of exp.  Due to the conventions
     and restrictions, principal value cannot be guaranteed unless exp
     is numeric.


 - Variable: COUNTER
     default: [1] determines the numerical suffix to be used in
     generating the next dummy index in the tensor package.  The prefix
     is determined by the option DUMMYX[#].


 - Function: DEFCON (tensor1,<tensor2,tensor3>)
     gives tensor1 the property that the contraction of a product of
     tensor1 and tensor2 results in tensor3 with the appropriate
     indices.  If only one argument, tensor1, is given, then the
     contraction of the product of tensor1 with any indexed object
     having the appropriate indices (say tensor) will yield an indexed
     object with that name, i.e.tensor, and with a new set of indices
     reflecting the contractions performed.      For example, if
     METRIC: G, then DEFCON(G) will implement the raising and lowering
     of indices through contraction with the metric tensor.      More
     than one DEFCON can be given for the same indexed object; the
     latest one given which applies in a particular contraction will be
     used.  CONTRACTIONS is a list of those indexed objects which have
     been given contraction properties with DEFCON.


 - Function: FLUSH (exp,tensor1,tensor2,...)
     Tensor Package - will set to zero, in exp, all occurrences of the
     tensori that have no derivative indices.


 - Function: FLUSHD (exp,tensor1,tensor2,...)
     Tensor Package - will set to zero, in exp, all occurrences of the
     tensori that have derivative indices.


 - Function: FLUSHND (exp,tensor,n)
     Tensor Package - will set to zero, in exp, all occurrences of the
     differentiated object tensor that have n or more derivative
     indices as the following example demonstrates.
          (C1) SHOW(A([I],[J,R],K,R)+A([I],[J,R,S],K,R,S));
                                         J R S      J R
          (D1)                          A        + A
                                         I,K R S    I,K R
          (C2) SHOW(FLUSHND(D1,A,3));
                                               J R
          (D2)                                A
                                               I,K R

 - Function: KDELTA (L1,L2)
     is the generalized Kronecker delta function defined in the Tensor
     package with L1 the list of covariant indices and L2 the list of
     contravariant indices.  KDELTA([i],[j]) returns the ordinary
     Kronecker delta.  The command EV(EXP,KDELTA) causes the evaluation
     of an expression containing KDELTA([],[]) to the dimension of the
     manifold.


 - Function: LC (L)
     is the permutation (or Levi-Civita) tensor which yields 1 if the
     list L consists of an even permutation of integers, -1 if it
     consists of an odd permutation, and 0 if some indices in L are
     repeated.


 - Function: LORENTZ (exp)
     imposes the Lorentz condition by substituting 0 for all indexed
     objects in exp that have a derivative index identical to a
     contravariant index.


 - Function: MAKEBOX (exp)
     will display exp in the same manner as SHOW; however, any tensor
     d'Alembertian occurring in exp will be indicated using the symbol
     [].  For example, []P([M],[N]) represents
     G([],[I,J])*P([M],[N],I,J).


 - Function: METRIC (G)
     specifies the metric by assigning the variable METRIC:G; in
     addition, the contraction properties of the metric G are set up by
     executing the commands DEFCON(G), DEFCON(G,G,KDELTA).  The
     variable METRIC, default: [], is bound to the metric, assigned by
     the METRIC(g) command.


 - Function: NTERMSG ()
     gives the user a quick picture of the "size" of the Einstein
     tensor.  It returns a list of pairs whose second elements give the
     number of terms in the components specified by the first elements.


 - Function: NTERMSRCI ()
     returns a list of pairs, whose second elements give the number of
     terms in the RICCI component specified by the first elements.  In
     this way, it is possible to quickly find the non-zero expressions
     and attempt simplification.


 - Function: NZETA (Z)
     returns the complex value of the Plasma Dispersion Function for
     complex Z.
          NZETAR(Z) ==> REALPART(NZETA(Z))
     NZETAI(Z) returns IMAGPART(NZETA(Z)).  This function is related to
     the complex error function by
          NZETA(Z) = %I*SQRT(%PI)*EXP(-Z^2)*(1-ERF(-%I*Z)).


 - Function: RAISERIEMANN (dis)
     returns the contravariant components of the Riemann curvature
     tensor as array elements UR[I,J,K,L].  These are displayed if dis
     is TRUE.


 - Variable: RATEINSTEIN
     default: [] - if TRUE rational simplification will be performed on
     the non-zero components of Einstein tensors; if FACRAT:TRUE then
     the components will also be factored.


 - Variable: RATRIEMAN
     - This switch has been renamed RATRIEMANN.


 - Variable: RATRIEMANN
     default: [] - one of the switches which controls simplification of
     Riemann tensors; if TRUE, then rational simplification will be
     done; if FACRAT:TRUE then each of the components will also be
     factored.


 - Function: REMCON (tensor1,tensor2,...)
     removes all the contraction properties from the tensori.
     REMCON(ALL) removes all contraction properties from all indexed
     objects.


 - Function: RICCICOM (dis)
     Tensor package) This function first computes the covariant
     components LR[i,j] of the Ricci tensor (LR is a mnemonic for
     "lower Ricci").  Then the mixed Ricci tensor is computed using the
     contravariant metric tensor.  If the value of the argument to
     RICCICOM is TRUE, then these mixed components, RICCI[i,j] (the
     index i is covariant and the index j is contravariant), will be
     displayed directly.  Otherwise, RICCICOM(FALSE) will simply
     compute the entries of the array RICCI[i,j] without displaying the
     results.


 - Function: RINVARIANT ()
     Tensor package) forms the invariant obtained by contracting the
     tensors
          R[i,j,k,l]*UR[i,j,k,l].

     This object is not

     automatically simplified since it can be very large.


 - Function: SCURVATURE ()
     returns the scalar curvature (obtained by contracting the Ricci
     tensor) of the Riemannian manifold with the given metric.


 - Function: SETUP ()
     this has been renamed to TSETUP();  Sets up a metric for Tensor
     calculations.


 - Function: WEYL (dis)
     computes the Weyl conformal tensor.  If the argument dis is TRUE,
     the non-zero components W[I,J,K,L] will be displayed to the user.
     Otherwise, these components will simply be computed and stored.
     If the switch RATWEYL is set to TRUE, then the components will be
     rationally simplified; if FACRAT is TRUE then the results will be
     factored as well.



File: maxima.info,  Node: Ctensor,  Next: Series,  Prev: Tensor,  Up: Top

Ctensor
*******

* Menu:

* Introduction to Ctensor::
* Definitions for Ctensor::


File: maxima.info,  Node: Introduction to Ctensor,  Next: Definitions for Ctensor,  Prev: Ctensor,  Up: Ctensor

Introduction to Ctensor
=======================

   - Component Tensor Manipulation Package.  To use the CTENSR package,
type TSETUP(); which automatically loads it from within MACSYMA (if it
is not already loaded) and then prompts the user to input his
coordinate system.  The user is first asked to specify the dimension of
the manifold. If the dimension is 2, 3 or 4 then the list of
coordinates defaults to [X,Y], [X,Y,Z] or [X,Y,Z,T] respectively.
These names may be changed by assigning a new list of coordinates to
the variable OMEGA (described below) and the user is queried about this.
** Care must be taken to avoid the coordinate names conflicting with
other object definitions **.  Next, the user enters the metric either
directly or from a file by specifying its ordinal position. As an
example of a file of common metrics, see TENSOR;METRIC FILE. The metric
is stored in the matrix LG. Finally, the metric inverse is computed and
stored in the matrix UG. One has the option of carrying out all
calculations in a power series.  A sample protocol is begun below for
the static, spherically symmetric metric (standard coordinates) which
will be applied to the problem of deriving Einstein's vacuum equations
(which lead to the Schwarzschild solution) as an example. Many of the
functions in CTENSR will be displayed for the standard metric as
examples.
     (C2) TSETUP();
     
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     N;
     Do you want to
     1. Enter a new metric?
     2. Enter a metric from a file?
     3. Approximate a metric with a Taylor series?
     Enter 1, 2 or 3
     1;
     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:  A;
     Row 2 Column 2:  X^2;
     Row 3 Column 3:  X^2*SIN(Y)^2;
     Row 4 Column 4:  -D;
     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     DEPENDS([A,D],X);
     Do you wish to see the metric?
     Y;
                               [ A  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  X       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   X  SIN (Y)   0  ]
                               [                        ]
                               [ 0  0       0       - D ]
     Do you wish to see the metric inverse?
     N;


File: maxima.info,  Node: Definitions for Ctensor,  Prev: Introduction to Ctensor,  Up: Ctensor

Definitions for Ctensor
=======================

 - Function: CHR1 ([i,j,k])
     yields the Christoffel symbol of the first kind via the definition
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k

     To evaluate the Christoffel symbols for a particular metric, the
     variable METRIC must be assigned a name as in the example under
     CHR2.


 - Function: CHR2 ([i,j],[k])
     yields the Christoffel symbol of the second kind defined by the
     relation
                                 ks
              CHR2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 - Function: CHRISTOF (arg)
     A function in the CTENSR (Component Tensor Manipulation) package.
     It computes the Christoffel symbols of both kinds.  The arg
     determines which results are to be immediately displayed.  The
     Christoffel symbols of the first and second kinds are stored in
     the arrays LCS[i,j,k] and MCS[i,j,k] respectively and defined to
     be symmetric in the first two indices. If the argument to CHRISTOF
     is LCS or MCS then the unique non-zero values of LCS[i,j,k] or
     MCS[i,j,k], respectively, will be displayed. If the argument is ALL
     then the unique non-zero values of LCS[i,j,k] and MCS[i,j,k] will
     be displayed.  If the argument is FALSE then the display of the
     elements will not occur. The array elements MCS[i,j,k] are defined
     in such a manner that the final index is contravariant.


 - Function: COVDIFF (exp,v1,v2,...)
     yields the covariant derivative of exp with respect to the
     variables vi in terms of the Christoffel symbols of the second
     kind (CHR2).  In order to evaluate these, one should use
     EV(exp,CHR2).


 - Function: CURVATURE ([i,j,k],[h])
     Indicial Tensor Package) yields the Riemann curvature tensor in
     terms of the Christoffel symbols of the second kind (CHR2).  The
     following notation is used:
                         h            h           h        %1        h
                CURVATURE     = - CHR2      - CHR2     CHR2    + CHR2
                         i j k        i k,j       %1 j     i k       i j,k
                                        h         %1
                                  + CHR2      CHR2
                                        %1 k      i j

 - Variable: DIAGMETRIC
     default:[] - An option in the CTENSR (Component Tensor
     Manipulation) package.  If DIAGMETRIC is TRUE special routines
     compute all geometrical objects (which contain the metric tensor
     explicitly) by taking into consideration the diagonality of the
     metric. Reduced run times will, of course, result. Note: this
     option is set automatically by TSETUP if a diagonal metric is
     specified.


 - Variable: DIM
     default:[4] - An option in the CTENSR (Component Tensor
     Manipulation) package.  DIM is the dimension of the manifold with
     the default 4. The command DIM:N; will reset the dimension to any
     other integral value.


 - Function: EINSTEIN (dis)
     A function in the CTENSR (Component Tensor Manipulation) package.
     EINSTEIN computes the mixed Einstein tensor after the Christoffel
     symbols and Ricci tensor have been obtained (with the functions
     CHRISTOF and RICCICOM).  If the argument dis is TRUE, then the
     non-zero values of the mixed Einstein tensor G[i,j] will be
     displayed where j is the contravariant index.  RATEINSTEIN[TRUE]
     if TRUE will cause the rational simplification on these
     components. If RATFAC[FALSE] is TRUE then the components will also
     be factored.


 - Function: LRICCICOM (dis)
     A function in the CTENSR (Component Tensor Manipulation) package.
     LRICCICOM computes the covariant (symmetric) components LR[i,j] of
     the Ricci tensor.  If the argument dis is TRUE, then the non-zero
     components are displayed.


 - Function: MOTION (dis)
     A function in the CTENSR (Component Tensor Manipulation) package.
     MOTION computes the geodesic equations of motion for a given
     metric.  They are stored in the array EM[i].  If the argument dis
     is TRUE then these equations are displayed.


 - Variable: OMEGA
     default:[] - An option in the CTENSR (Component Tensor
     Manipulation) package.  OMEGA assigns a list of coordinates to the
     variable. While normally defined when the function TSETUP is
     called, one may redefine the coordinates with the assignment
     OMEGA:[j1,j2,...jn] where the j's are the new coordinate names. A
     call to OMEGA will return the coordinate name list.  Also see
     DESCRIBE(TSETUP); .


 - Function: RIEMANN (dis)
     A function in the CTENSR (Component Tensor Manipulation) Package.
     RIEMANN computes the Riemann curvature tensor from the given
     metric and the corresponding Christoffel symbols.  If dis is TRUE,
     the non-zero components R[i,j,k,l] will be displayed. All the
     indicated indices are covariant.  As with the Einstein tensor,
     various switches set by the user control the simplification of the
     components of the Riemann tensor.  If RATRIEMAN[TRUE] is TRUE then
     rational simplification will be done. If RATFAC[FALSE] is TRUE then
     each of the components will also be factored.


 - Function: TRANSFORM
     - The TRANSFORM command in the CTENSR package has been renamed to
     TTRANSFORM.


 - Function: TSETUP ()
     A function in the CTENSR (Component Tensor Manipulation) package
     which automatically loads the CTENSR package from within MACSYMA
     (if it is not already loaded) and then prompts the user to make
     use of it.  Do DESCRIBE(CTENSR); for more details.


 - Function: TTRANSFORM (matrix)
     A function in the CTENSR (Component Tensor Manipulation) package
     which will perform a coordinate transformation upon an arbitrary
     square symmetric matrix. The user must input the functions which
     define the transformation.  (Formerly called TRANSFORM.)



File: maxima.info,  Node: Series,  Next: Number Theory,  Prev: Ctensor,  Up: Top

Series
******

* Menu:

* Introduction to Series::
* Definitions for Series::

