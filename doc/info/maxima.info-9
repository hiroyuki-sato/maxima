This is maxima.info, produced by makeinfo version 4.5 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Equations,  Prev: Equations,  Up: Equations

Definitions for Equations
=========================

 - Variable: %RNUM_LIST
     default: [] - When %R variables are introduced in solutions by the
     ALGSYS command, they are added to %RNUM_LIST in the order they are
     created.  This is convenient for doing substitutions into the
     solution later on.  It's recommended to use this list rather than
     doing CONCAT('%R,J).

 - Variable: ALGEXACT
     default: [FALSE] affects the behavior of ALGSYS as follows: If
     ALGEXACT is TRUE, ALGSYS always calls SOLVE and then uses REALROOTS
     on SOLVE's failures.  If ALGEXACT is FALSE, SOLVE is called only if
     the eliminant was not univariate, or if it was a quadratic or
     biquadratic.  Thus ALGEXACT:TRUE doesn't guarantee only exact
     solutions, just that ALGSYS will first try as hard as it can to
     give exact solutions, and only yield approximations when all else
     fails.

 - Function: ALGSYS ([exp1, exp2, ...], [var1, var2, ...])
     solves the list of simultaneous polynomials or polynomial
     equations (which can be non-linear) for the list of variables.
     The symbols %R1, %R2, etc.  will be used to represent arbitrary
     parameters when needed for the solution (the variable %RNUM_LIST
     holds these).  In the process described below, ALGSYS is entered
     recursively if necessary.      The method is as follows: (1) First
     the equations are FACTORed and split into subsystems.  (2) For
     each subsystem Si, an equation E and a variable var are selected
     (the var is chosen to have lowest nonzero degree).  Then the
     resultant of E and Ej with respect to var is computed for each of
     the remaining equations Ej in the subsystem Si.  This yields a new
     subsystem S'i in one fewer variables (var has been eliminated).
     The process now returns to (1).  (3) Eventually, a subsystem
     consisting of a single equation is obtained.  If the equation is
     multivariate and no approximations in the form of floating point
     numbers have been introduced, then SOLVE is called to find an
     exact solution.  (The user should realize that SOLVE may not be
     able to produce a solution or if it does the solution may be a
     very large expression.)      If the equation is univariate and is
     either linear, quadratic, or bi-quadratic, then again SOLVE is
     called if no approximations have been introduced.  If
     approximations have been introduced or the equation is not
     univariate and neither linear, quadratic, or bi-quadratic, then if
     the switch REALONLY[FALSE] is TRUE, the function REALROOTS is
     called to find the real-valued solutions.  If REALONLY:FALSE then
     ALLROOTS is called which looks for real and complex-valued
     solutions.  If ALGSYS produces a solution which has fewer
     significant digits than required, the user can change the value of
     ALGEPSILON[10^8] to a higher value.  If ALGEXACT[FALSE] is set to
     TRUE, SOLVE will always be called.  (4) Finally, the solutions
     obtained in step (3) are re-inserted into previous levels and the
     solution process returns to (1).  The user should be aware of
     several caveats:     When ALGSYS encounters a multivariate
     equation which contains floating point approximations (usually due
     to its failing to find exact solutions at an earlier stage), then
     it does not attempt to apply exact methods to such equations and
     instead prints the message:         "ALGSYS cannot solve - system
     too complicated."      Interactions with RADCAN can produce large
     or complicated expressions.  In that case, the user may use
     PICKAPART or REVEAL to analyze the solution.  Occasionally, RADCAN
     may introduce an apparent %I into a solution which is actually
     real-valued.  Do EXAMPLE(ALGSYS); for examples.


 - Function: ALLROOTS (poly)
     finds all the real and complex roots of the real polynomial poly
     which must be univariate and may be an equation, e.g.  poly=0.
     For complex polynomials an algorithm by Jenkins and Traub is used
     (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  For real
     polynomials the algorithm used is due to Jenkins (Algorithm 493,
     TOMS, vol. 1, (1975), p.178).  The flag POLYFACTOR[FALSE] when
     true causes ALLROOTS to factor the polynomial over the real
     numbers if the polynomial is real, or over the complex numbers, if
     the polynomial is complex.  ALLROOTS may give inaccurate results
     in case of multiple roots.  (If poly is real and you get
     inaccurate answers, you may want to try ALLROOTS(%I*poly);) Do
     EXAMPLE(ALLROOTS); for an example.  ALLROOTS rejects
     non-polynomials.  It requires that the numerator after RATting
     should be a polynomial, and it requires that the denominator be at
     most a complex number.  As a result of this ALLROOTS will always
     return an equivalent (but factored) expression, if POLYFACTOR is
     TRUE.


 - Variable: BACKSUBST
     default: [TRUE] if set to FALSE will prevent back substitution
     after the equations have been triangularized.  This may be
     necessary in very big problems where back substitution would cause
     the generation of extremely large expressions.  (On MC this could
     cause storage capacity to be exceeded.)


 - Variable: BREAKUP
     default: [TRUE] if FALSE will cause SOLVE to express the solutions
     of cubic or quartic equations as single expressions rather than as
     made up of several common subexpressions which is the default.
     BREAKUP:TRUE only works when PROGRAMMODE is FALSE.


 - Function: DIMENSION (equation or list of equations)
     The file "share1/dimen.mc" contains functions for automatic
     dimensional analysis.  LOAD(DIMEN); will load it up for you.
     There is a demonstration available in share1/dimen.dem.  Do
     DEMO("dimen"); to run it.


 - Variable: DISPFLAG
     default: [TRUE] if set to FALSE within a BLOCK will inhibit the
     display of output generated by the solve functions called from
     within  the BLOCK.  Termination of the BLOCK with a dollar sign,
     $, sets DISPFLAG to FALSE.


 - Function: FUNCSOLVE (eqn,g(t))
     gives [g(t) = ...]  or [], depending on whether or not there
     exists a rational fcn g(t) satisfying eqn, which must be a first
     order, linear polynomial in (for this case) g(t) and g(t+1).
          (%i1) FUNCSOLVE((N+1)*FOO(N)-(N+3)*FOO(N+1)/(N+1) =
              (N-1)/(N+2),FOO(N));
                                             N
          (%o1)               FOO(N) = ---------------
                                      (N + 1) (N + 2)
     Warning: this is a very rudimentary implementation-many safety
     checks and obvious generalizations are missing.


 - Variable: GLOBALSOLVE
     default: [FALSE] if set to TRUE then variables which are SOLVEd
     for will be set to the solution of the set of simultaneous
     equations.


 - Function: IEQN (ie,unk,tech,n,guess)
     Integral Equation solving routine.  Do LOAD(INTEQN); to access it.
     CAVEAT: To free some storage, a KILL(LABELS) is included in this
     file.  Therefore, before loading the integral equation package,
     the user should give names to any expressions he wants to keep.
     ie is the integral equation; unk is the unknown function; tech is
     the technique to be tried from those given above (tech = FIRST
     means: try the first technique which finds a solution; tech = ALL
     means: try all applicable techniques); n is the maximum number of
     terms to take for TAYLOR, NEUMANN, FIRSTKINDSERIES, or FREDSERIES
     (it is also the maximum depth of recursion for the differentiation
     method); guess is the initial guess for NEUMANN or FIRSTKINDSERIES.
     Default values for the 2nd thru 5th parameters are: unk: P(X),
     where P is the first function encountered in an integrand which is
     unknown to MACSYMA and X is the variable which occurs as an
     argument to the first occurrence of P found outside of an integral
     in the case of SECONDKIND equations, or is the only other variable
     besides the variable of integration in FIRSTKIND equations.  If the
     attempt to search for X fails, the user will be asked to supply the
     independent variable; tech: FIRST; n: 1; guess: NONE, which will
     cause NEUMANN and FIRSTKINDSERIES to use F(X) as an initial guess.


 - Variable: IEQNPRINT
     default: [TRUE] - governs the behavior of the result returned by
     the IEQN command (which see).  If IEQNPRINT is set to FALSE, the
     lists returned by the IEQN function are of the form    [SOLUTION,
     TECHNIQUE USED, NTERMS, FLAG] where FLAG is absent if the solution
     is exact.  Otherwise, it is the word APPROXIMATE or INCOMPLETE
     corresponding to an inexact or non-closed form solution,
     respectively. If a series method was used, NTERMS gives the number
     of terms taken (which could be less than the n given to IEQN if an
     error prevented generation of further terms).


 - Function: LHS (eqn)
     the left side of the equation eqn.


 - Function: LINSOLVE ([exp1, exp2, ...], [var1, var2, ...])
     solves the list of simultaneous linear equations for the list of
     variables.  The expi must each be polynomials in the variables and
     may be equations.  If GLOBALSOLVE[FALSE] is set to TRUE then
     variables which are SOLVEd for will be set to the solution of the
     set of simultaneous equations.  BACKSUBST[TRUE] if set to FALSE
     will prevent back substitution after the equations have been
     triangularized.  This may be necessary in very big problems where
     back substitution would cause the generation of extremely large
     expressions.  (On MC this could cause the storage capacity to be
     exceeded.)  LINSOLVE_PARAMS[TRUE] If TRUE, LINSOLVE also generates
     the %Ri symbols used to represent arbitrary parameters described
     in the manual under ALGSYS.  If FALSE, LINSOLVE behaves as before,
     i.e. when it meets up with an under-determined system of
     equations, it solves for some of the variables in terms of others.
          (%i1) X+Z=Y$
          (%i2) 2*A*X-Y=2*A**2$
          (%i3) Y-2*Z=2$
          (%i4) LINSOLVE([%o1,%o2,%o3],[X,Y,Z]),GLOBALSOLVE:TRUE;
          SOLUTION
          (%t4)                            X : A + 1
          (%t5)                             Y : 2 A
          (%t6)                            Z : A - 1
          (%o6)                          [%t4, %t5, %t6]

 - Variable: LINSOLVEWARN
     default: [TRUE] - if FALSE will cause the message "Dependent
     equations eliminated" to be suppressed.


 - Variable: LINSOLVE_PARAMS
     default: [TRUE] - If TRUE, LINSOLVE also generates the %Ri symbols
     used to represent arbitrary parameters described in the manual
     under ALGSYS.  If FALSE, LINSOLVE behaves as before, i.e.  when it
     meets up with an under-determined system of equations, it solves
     for some of the variables in terms of others.


 - Variable: MULTIPLICITIES
     default: [NOT_SET_YET] - will be set to a list of the
     multiplicities of the individual solutions returned by SOLVE or
     REALROOTS.


 - Function: NROOTS (poly, low, high)
     finds the number of real roots of the real univariate polynomial
     poly in the half-open interval (low,high].  The endpoints of the
     interval may also be MINF,INF respectively for minus infinity and
     plus infinity.  The method of Sturm sequences is used.
          (%i1) POLY1:X**10-2*X**4+1/2$
          (%i2) NROOTS(POLY1,-6,9.1);
          RAT REPLACED 0.5 BY 1/2 = 0.5
          (%o2)                               4

 - Function: NTHROOT (p,n)
     where p is a polynomial with integer coefficients and n is a
     positive integer returns q, a polynomial over the integers, such
     that q^n=p or prints an error message indicating that p is not a
     perfect nth power. This routine is much faster than FACTOR or even
     SQFR.


 - Variable: PROGRAMMODE
     default: [TRUE] - when FALSE will cause SOLVE, REALROOTS,
     ALLROOTS, and LINSOLVE to print E-labels (intermediate line
     labels) to label answers.  When TRUE, SOLVE, etc. return answers
     as elements in a list.  (Except when BACKSUBST is set to FALSE, in
     which case PROGRAMMODE:FALSE is also used.)


 - Variable: REALONLY
     default: [FALSE] - if TRUE causes ALGSYS to return only those
     solutions which are free of %I.


 - Function: REALROOTS (poly, bound)
     finds all of the real roots of the real univariate polynomial poly
     within a tolerance of bound which, if less than 1, causes all
     integral roots to be found exactly.  The parameter bound may be
     arbitrarily small in order to achieve any desired accuracy.  The
     first argument may also be an equation.  REALROOTS sets
     MULTIPLICITIES, useful in case of multiple roots.  REALROOTS(poly)
     is equivalent to REALROOTS(poly,ROOTSEPSILON).
     ROOTSEPSILON[1.0E-7] is a real number used to establish the
     confidence interval for the roots.  Do EXAMPLE(REALROOTS); for an
     example.


 - Function: RHS (eqn)
     the right side of the equation eqn.


 - Variable: ROOTSCONMODE
     default: [TRUE] - Determines the behavior of the ROOTSCONTRACT
     command.  Do DESCRIBE(ROOTSCONTRACT); for details.


 - Function: ROOTSCONTRACT (exp)
     converts products of roots into roots of products.  For example,
          ROOTSCONTRACT(SQRT(X)*Y^(3/2)) ==> SQRT(X*Y^3)
     When RADEXPAND is TRUE and DOMAIN is REAL (their defaults),
     ROOTSCONTRACT converts ABS into SQRT, e.g.

          ROOTSCONTRACT(ABS(X)*SQRT(Y)) ==> SQRT(X^2*Y)

     There is an option ROOTSCONMODE (default value TRUE), affecting
     ROOTSCONTRACT as follows:



          Problem            Value of        Result of applying
                            ROOTSCONMODE        ROOTSCONTRACT
          
          X^(1/2)*Y^(3/2)      FALSE          (X*Y^3)^(1/2)
          X^(1/2)*Y^(1/4)      FALSE          X^(1/2)*Y^(1/4)
          X^(1/2)*Y^(1/4)      TRUE           (X*Y^(1/2))^(1/2)
          X^(1/2)*Y^(1/3)      TRUE           X^(1/2)*Y^(1/3)
          X^(1/2)*Y^(1/4)      ALL            (X^2*Y)^(1/4)
          X^(1/2)*Y^(1/3)      ALL            (X^3*Y^2)^(1/6)

     The above examples and more may be tried out by typing

          EXAMPLE(ROOTSCONTRACT);

     When ROOTSCONMODE is FALSE, ROOTSCONTRACT contracts only wrt
     rational number exponents whose denominators are the same.  The
     key to the ROOTSCONMODE:TRUE$ examples is simply that 2 divides
     into 4 but not into 3.  ROOTSCONMODE:ALL$ involves taking the lcm
     (least common multiple) of the denominators of the exponents.
     ROOTSCONTRACT uses RATSIMP in a manner similar to LOGCONTRACT (see
     the manual).


 - Variable: ROOTSEPSILON
     default: [1.0E-7] - a real number used to establish the confidence
     interval for the roots found by the REALROOTS function.


 - Function: SOLVE (exp, var)
     solves the algebraic equation exp for the variable var and returns
     a list of solution equations in var.  If exp is not an equation,
     it is assumed to be an expression to be set equal to zero.  Var
     may be a function (e.g. F(X)), or other non-atomic expression
     except a sum or product. It may be omitted if exp contains only one
     variable.  Exp may be a rational expression, and may contain
     trigonometric functions, exponentials, etc.  The following method
     is used: Let E be the expression and X be the variable.  If E is
     linear in X then it is trivially solved for X.  Otherwise if E is
     of the form A*X**N+B then the result is (-B/A)**(1/N) times the
     Nth roots of unity.  If E is not linear in X then the gcd of the
     exponents of X in E (say N) is divided into the exponents and the
     multiplicity of the roots is multiplied by N.  Then SOLVE is
     called again on the result.  If E factors then SOLVE is called on
     each of the factors.  Finally SOLVE will use the quadratic, cubic,
     or quartic formulas where necessary.  In the case where E is a
     polynomial in some function of the variable to be solved for, say
     F(X), then it is first solved for F(X) (call the result C), then
     the equation F(X)=C can be solved for X provided the inverse of
     the function F is known.  BREAKUP[TRUE] if FALSE will cause SOLVE
     to express the solutions of cubic or quartic equations as single
     expressions rather than as made up of several common
     subexpressions which is the default.  MULTIPLICITIES[NOT_SET_YET]
     - will be set to a list of the multiplicities of the individual
     solutions returned by SOLVE, REALROOTS, or ALLROOTS.  Try
     APROPOS(SOLVE) for the switches which affect SOLVE.  DESCRIBE may
     then by used on the individual switch names if their purpose is not
     clear.  SOLVE([eq1, ..., eqn], [v1, ..., vn]) solves a system of
     simultaneous (linear or non-linear) polynomial equations by
     calling LINSOLVE or ALGSYS and returns a list of the solution
     lists in the variables.  In the case of LINSOLVE this list would
     contain a single list of solutions.  It takes two lists as
     arguments.  The first list (eqi, i=1,...,n) represents the
     equations to be solved; the second list is a list of the unknowns
     to be determined.  If the total number of variables in the
     equations is equal to the number of equations, the second
     argument-list may be omitted.  For linear systems if the given
     equations are not compatible, the message INCONSISTENT will be
     displayed (see the SOLVE_INCONSISTENT_ERROR switch); if no unique
     solution exists, then SINGULAR will be displayed.  For examples, do
     EXAMPLE(SOLVE);


 - Variable: SOLVEDECOMPOSES
     default: [TRUE] - if TRUE, will induce SOLVE to use POLYDECOMP
     (see POLYDECOMP) in attempting to solve polynomials.


 - Variable: SOLVEEXPLICIT
     default: [FALSE] - if TRUE, inhibits SOLVE from returning implicit
     solutions i.e. of the form F(x)=0.


 - Variable: SOLVEFACTORS
     default: [TRUE] - if FALSE then SOLVE will not try to factor the
     expression.  The FALSE setting may be desired in some cases where
     factoring is not necessary.


 - Variable: SOLVENULLWARN
     default: [TRUE] - if TRUE the user will be warned if he calls
     SOLVE with either a null equation list or a null variable list.
     For example, SOLVE([],[]); would print two warning messages and
     return [].


 - Variable: SOLVERADCAN
     default: [FALSE] - if TRUE then SOLVE will use RADCAN which will
     make SOLVE slower but will allow certain problems containing
     exponentials and logs to be solved.


 - Variable: SOLVETRIGWARN
     default: [TRUE] - if set to FALSE will inhibit printing by SOLVE
     of the warning message saying that it is using inverse
     trigonometric functions to solve the equation, and thereby losing
     solutions.


 - Variable: SOLVE_INCONSISTENT_ERROR
     default: [TRUE] - If TRUE, SOLVE and LINSOLVE give an error if
     they meet up with a set of inconsistent linear equations, e.g.
     SOLVE([A+B=1,A+B=2]).  If FALSE, they return [] in this case.
     (This is the new mode, previously gotten only by calling ALGSYS.)


 - Function: ZRPOLY
     - This is no longer available in Maxima. See ALLROOTS for a
     function    to compute the roots of a polynomial.


 - Function: ZSOLVE
     This is not available with Maxima anymore.  Documentation is left
     for  historical purposes.

     - For those who can make use of approximate numerical solutions to
     problems, there is a package which calls a routine which has been
     translated from the IMSL fortran library to solve N simultaneous
     non-linear equations in N unknowns.  It uses black-box techniques
     that probably aren't desirable if an exact solution can be
     obtained from one of the smarter solvers (LINSOLVE, ALGSYS, etc).
     But for things that the other solvers don't attempt to handle,
     this can probably give some very useful results.  For
     documentation, do PRINTFILE("zsolve.usg");.  For a demo do
     batch("zsolve.mc")$



File: maxima.info,  Node: Differential Equations,  Next: Numerical,  Prev: Equations,  Up: Top

Differential Equations
**********************

* Menu:

* Definitions for Differential Equations::


File: maxima.info,  Node: Definitions for Differential Equations,  Prev: Differential Equations,  Up: Differential Equations

Definitions for Differential Equations
======================================

 - Function: DESOLVE ([eq1,...,eqn],[var1,...,varn])
     where the eq's are differential equations in the dependent
     variables var1,...,varn.  The functional relationships must be
     explicitly indicated in both the equations and the variables. For
     example
          (%i1) 'DIFF(F,X,2)=SIN(X)+'DIFF(G,X);
          (%i2) 'DIFF(F,X)+X^2-F=2*'DIFF(G,X,2);
          is NOT the proper format.  The correct way is:
          (%i3) 'DIFF(F(X),X,2)=SIN(X)+'DIFF(G(X),X);
          (%i4) 'DIFF(F(X),X)+X^2-F(X)=2*'DIFF(G(X),X,2);
          The call is then DESOLVE([%o3,%o4],[F(X),G(X)]);
          If initial conditions at 0 are known, they should be supplied before
          calling DESOLVE by using ATVALUE.
          (%i11) 'DIFF(F(X),X)='DIFF(G(X),X)+SIN(X);
                                  d         d
          (%o11)                   -- F(X) = -- G(X) + SIN(X)
                                  dX        dX
          (%i12) 'DIFF(G(X),X,2)='DIFF(F(X),X)-COS(X);
                                   2
                                  d          d
          (%o12)                   --- G(X) = -- F(X) - COS(X)
                                    2        dX
                                  dX
          (%i13) ATVALUE('DIFF(G(X),X),X=0,A);
          (%o13)                                A
          (%i14) ATVALUE(F(X),X=0,1);
          (%o14)                                1
          (%i15) DESOLVE([%o11,%o12],[F(X),G(X)]);
                          X                            X
          (%o16) [F(X)=A %E  - A+1, G(X) = COS(X) + A %E  - A + G(0) - 1]
          /* VERIFICATION */
          (%i17) [%o11,%o12],%o16,DIFF;
                            X       X      X                X
          (%o17)        [A %E  = A %E , A %E  - COS(X) = A %E  - COS(X)]

     If DESOLVE cannot obtain a solution, it returns "FALSE".


 - Function: IC1 (exp,var,var)
     In order to solve initial value problems (IVPs) and boundary value
     problems (BVPs), the routine IC1 is available in the ODE2 package
     for first order equations, and IC2 and BC2 for second order IVPs
     and BVPs, respectively.  Do LOAD(ODE2) to access these.  They are
     used as in the following examples:
          (%i3) IC1(%o2,X=%PI,Y=0);
                                   COS(X) + 1
          (%o3)               Y = - ----------
                                        3
                                       X
          (%i4) 'DIFF(Y,X,2) + Y*'DIFF(Y,X)^3 = 0;
                                 2
                                d Y      dY 3
          (%o4)                  --- + Y (--)  = 0
                                  2      dX
                                dX
          (%i5) ODE2(%,Y,X);
                           3
                          Y  - 6 %K1 Y - 6 X
          (%o7)            ------------------ = %K2
                                  3
          (%i8) RATSIMP(IC2(%o7,X=0,Y=0,'DIFF(Y,X)=2));
                               3
                            2 Y  - 3 Y + 6 X
          (%o9)            - ---------------- = 0
                                   3
          (%i10) BC2(%o7,X=0,Y=1,X=1,Y=3);
                           3
                          Y  - 10 Y - 6 X
          (%o11)           --------------- = - 3
                                 3


 - Function: ODE (equation,y,x)
     This no longer exists in Maxima.  The documentation is left here
     for historical purposes.

     a pot-pourri of Ordinary Differential solvers combined in such a
     way as to attempt more and more difficult methods as each fails.
     For example, the first attempt is with ODE2, so therefore, a user
     using ODE can assume he has all the capabilities of ODE2 at the
     very beginning and if he has been using ODE2 in programs they will
     still run if he substitutes ODE (the returned values, and calling
     sequence are identical).  In addition, ODE has a number of user
     features which can assist an experienced ODE solver if the basic
     system cannot handle the equation.  The equation is of the same
     form as required for ODE2 (which see) and the y and x are
     dependent and independent variables, as with ODE2.  For more
     details, do PRINTFILE(ODE,USAGE,SHARE); .


 - Function: ODE2 (exp,dvar,ivar)
     takes three arguments: an ODE of first or second order (only the
     left hand side need be given if the right hand side is 0), the
     dependent variable, and the independent variable.  When
     successful, it returns either an explicit or implicit solution for
     the dependent variable.  %C is used to represent the constant in
     the case of first order equations, and %K1 and %K2 the constants
     for second order equations.  If ODE2 cannot obtain a solution for
     whatever reason, it returns FALSE, after perhaps printing out an
     error message.  The methods implemented for first order equations
     in the order in which they are tested are: linear, separable,
     exact - perhaps requiring an integrating factor, homogeneous,
     Bernoulli's equation, and a generalized homogeneous method.  For
     second order: constant coefficient, exact, linear homogeneous with
     non-constant coefficients which can be transformed to constant
     coefficient, the Euler or equidimensional equation, the method of
     variation of parameters, and equations which are free of either the
     independent or of the dependent variable so that they can be
     reduced to two first order linear equations to be solved
     sequentially.  In the course of solving ODEs, several variables
     are set purely for informational purposes: METHOD denotes the
     method of solution used e.g. LINEAR, INTFACTOR denotes any
     integrating factor used, ODEINDEX denotes the index for
     Bernoulli's method or for the generalized homogeneous method, and
     YP denotes the particular solution for the variation of parameters
     technique.



File: maxima.info,  Node: Numerical,  Next: Statistics,  Prev: Differential Equations,  Up: Top

Numerical
*********

* Menu:

* Introduction to Numerical::
* DCADRE::
* FOURIER::
* NDIFFQ::
* Definitions for Numerical::


File: maxima.info,  Node: Introduction to Numerical,  Next: DCADRE,  Prev: Numerical,  Up: Numerical

Introduction to Numerical
=========================


File: maxima.info,  Node: DCADRE,  Next: FOURIER,  Prev: Introduction to Numerical,  Up: Numerical

DCADRE
======

   The following is obsolete and does not exist in Maxima 5.9.  We leave
the documentation here for historical purposes.

   To make an interface to fortran libraries in the current MAXIMA look
at the examples in "maxima/src/fortdef.lsp"  - The IMSL version of
Romberg integration is now available in Macsyma.  For documentation, Do
PRINTFILE(DCADRE,USAGE,IMSL1); .  For a demo, do batch("dcadre.mc");
This is a numerical integration package using cautious, adaptive
Romberg extrapolation.  The DCADRE package is written to call the IMSL
fortran library routine DCADRE. This is documentation for that program.
Send bugs/comments to KMP To load this package, do
       LOADFILE("imsl")$
   For a demo of this package, do
       batch("dcadre.mc");
   The worker function takes the following syntax:
IMSL_ROMBERG(fn,low,hi) where fn is a function of 1 argument; low and
hi should be the lower and upper bounds of integration. fn must return
floating point values.  IMSL_ROMBERG(exp,var,low,hi)   where exp should
be integrated over the range var=low to hi. The result   of evaluating
exp must always be a floating point number.
FAST_IMSL_ROMBERG(fn,low,hi)   This function does no error checking but
may achieve a speed gain over   the IMSL_ROMBERG function. It expects
that fn is a Lisp function (or   translated Macsyma function) which
accepts a floating point argument   and that it always returns a
floating point value.

   Returns either  [SUCCESS, answer, error] where answer is the result
of the integration and   error is the estimated bound on the absolute
error of the output, DCADRE,   as described in PURPOSE below.  or
[WARNING, n, answer, error] where n is a warning code, answer is the
answer,   and error is the estimated bound on the absolute error of the
output, DCADRE,   as described in PURPOSE below. The following warnings
may occur:      65 = One or more singularities were successfully
handled.       66 = In some subinterval(s), the estimate of the
integral was accepted           merely because the estimated error was
small, even though no regular           behavior was recognized.  or
[ERROR, errorcode] where error code is the IMSL-generated    error
code. The following error codes may occur:      131 = Failure due to
insufficient internal working storage.       132 = Failure. This may be
due to too much noise in function            (relative to the given
error requirements) or due to an            ill-behaved integrand.
133 = RERR is greater than 0.1 or less than 0.0 or is too small
   for the precision of the machine.

   The following flags have an influence upon the operation of
IMSL_ROMBERG -

   ROMBERG_AERR [Default 1.0E-5] - Desired absolute error in answer.

   ROMBERG_RERR [Default 0.0] - Desired relative error in the answer.

   Note: If IMSL signals an error, a message will be printed on the
user's         console stating the nature of the error. (This error
message         may be supressed by setting IMSLVERBOSE to FALSE.)

   Note: Because this uses a translated Fortran routine, it may not be
      recursively invoked. It does not call itself, but the user should
       be aware that he may not type ^A in the middle of an
IMSL_ROMBERG         computation, begin another calculation using the
same package,         and expect to win - IMSL_ROMBERG will complain if
it was already         doing one project when you invoke it. This
should cause minimal         problems.

   Purpose (modified version of the IMSL documentation)
---------------------------------------------------

   DCADRE attempts to solve the following problem: Given a real-valued
function F of one argument, two real numbers A and B, find a number

   DCADRE such that:

     |   / B               |        [                              | / B      | ]
     |   [                 |        [                              | [        | ]
     |   I F(x)dx - DCADRE | <= max [ ROMBERG_AERR, ROMBERG_RERR * | I F(x)dx | ]
     |   ]                 |        [                              | ]        | ]
     |   / A               |        [                              | / A      | ]
   Algorithm (modified version of the IMSL documentation)

   This routine uses a scheme whereby DCADRE is computed as the sum of
estimates for the integral of F(x) over suitably chosen subintervals of
the given interval of integration. Starting with the interval of
integration itself as the first such subinterval, cautious Romberg
extrapolation is used to find an acceptable estimate on a given
subinterval. If this attempt fails, the subinterval is divided into two
subintervals of equal length, each of which is considered separately.
Programming Notes (modified version of the IMSL documentation)

   * 1. DCADRE (the translated-Fortran base for IMSL_ROMBERG) can, in
     many cases,    handle jump discontinuities and certain algebraic
     discontinuities. See    reference for full details.

   * 2. The relative error parameter ROMBERG_RERR must be in the
     interval [0.0,0.1].     For example, ROMBERG_RERR=0.1 indicates
     that the estimate of the intergral    is to be correct to one
     digit, where as ROMBERG_RERR=1.0E-4 calls for four    digits of
     accuracy. If DCADRE determines that the relative accuracy
     requirement cannot be satisfied, IER is set to 133 (ROMBERG_RERR
     should be    large enough that, when added to 100.0, the result is
     a number greater than    100.0 (this will not be true of very tiny
     floating point numbers due to    the nature of machine
     arithmetic)).

   * 3. The absolute error parameter, ROMBERG_AERR, should be
     nonnegative. In    order to give a reasonable value for
     ROMBERG_AERR, the user must know    the approximate magnitude of
     the integral being computed. In many cases,    it is satisfactory
     to use AERR=0.0. In this case, only the relative error
     requirement is satisfied in the compuatation.

   * 4. We quote from the reference, "A very cautious man would accept
     DCADRE    only if IER [the warning or error code] is 0 or 65. The
     merely reasonable    man would keep the faith even if IER is 66.
     The adventurous man is quite    often right in accepting DCADRE
     even if the IER is 131 or 132." Even when    IER is not 0, DCADRE
     returns the best estimate that has been computed.

   For references on this technique, see de Boor, Calr, "CADRE: An
Algorithm for Numerical Quadrature,"   Mathematical Software (John R.
Rice, Ed.), New York, Academic Press,   1971, Chapter 7.


File: maxima.info,  Node: FOURIER,  Next: NDIFFQ,  Prev: DCADRE,  Up: Numerical

FOURIER
=======

   - There is a Fast Fourier Transform package, do DESCRIBE(FFT) for
details.  There is also a Fourier Series package.  It may be loaded
with LOAD(FOURIE).  It will also calculate Fourier integral
coefficients and has various other functions to do such things as
replace all occurrences of F(ARG) by ARG in expression (like changing
ABS(a*x+b) to a*x+b).  Do PRINTFILE(FOURIE,USAGE,DSK,SHARE1); for a
list of the functions included.


File: maxima.info,  Node: NDIFFQ,  Next: Definitions for Numerical,  Prev: FOURIER,  Up: Numerical

NDIFFQ
======

   a package residing on the SHARE directory for numerical solutions of
differential equations.  LOAD("NDIFFQ"); will load it in for use.  An
example of its use would be:

     Define_Variable(N,0.3,FLOAT);
     Define_Variable(H,0.175,FLOAT);
     F(X,E):=(Mode_Declare([X,E],FLOAT),N*EXP(X)/(E+X^(2*H)*EXP(H*X)));
     Compile(F);
     Array([X,E],FLOAT,35);
     Init_Float_Array(X,1.0E-3,6.85); /* Fills X with the interval */
     E[0]:5.0;                        /* Initial condition */
     Runge_Kutta(F,X,E);              /* Solve it */
     Graph2(X,E);                     /* Graph the solution */
   p.s. Runge_Kutta(F,X,E,E_Prime) would be the call for a second-order
equation.


File: maxima.info,  Node: Definitions for Numerical,  Prev: NDIFFQ,  Up: Numerical

Definitions for Numerical
=========================

 - Function: FFT (real-array, imag-array)
     Fast Fourier Transform.  This package may be loaded by doing
     LOAD(FFT); There is also an IFT command, for Inverse Fourier
     Transform.  These functions perform a (complex) fast fourier
     transform on either 1 or 2 dimensional FLOATING-POINT arrays,
     obtained by:
          ARRAY(<ary>,FLOAT,<dim1>); or
          ARRAY(<ary>,FLOAT,<dim1>,<dim2>);
     For 1D arrays
          <dim1> = 2^n-1
     and for 2D arrays
          <dim1>=<dim2>=2^n-1
     (i.e. the array is square).  (Recall that MACSYMA arrays are
     indexed from a 0 origin so that there will be 2^n and (2^n)^2
     arrays elements in the above two cases.)  This package also
     contains two other functions, POLARTORECT and RECTTOPOLAR.  Do
     DESCRIBE(cmd) for details. For details on the implementation, do
     PRINTFILE(FFT,USAGE,SHARE); .


 - Variable: FORTINDENT
     default: [0] - controls the left margin indentation of expressions
     printed out by the FORTRAN command.  0 gives normal printout (i.e.
     6 spaces), and positive values will causes the expressions to be
     printed farther to the right.


 - Function: FORTMX (name,matrix)
     converts a MACSYMA matrix into a sequence of FORTRAN assignment
     statements of the form name(i,j)=<corresponding matrix element>.
     This command is now obsolete.  FORTMX(name,matrix); may now be
     done as FORTRAN(name=matrix);.  (If "name" is bound,
     FORTRAN('name=matrix); may be necessary.)  Please convert code that
     uses the FORTMX command as it may be flushed some day.


 - Function: FORTRAN (exp)
     converts exp into a FORTRAN linear expression in legal FORTRAN
     with 6 spaces inserted at the beginning of each line, continuation
     lines, and ** rather than ^ for exponentiation.  When the option
     FORTSPACES[FALSE] is TRUE, the FORTRAN command fills out to 80
     columns using spaces.  If FORTRAN is called on a bound symbolic
     atom, e.g. FORTRAN(X); where X:A*B$ has been done, then X={value
     of X}, e.g.  X=A*B will be generated.  In particular, if e.g.
     M:MATRIX(...); has been done, then FORTRAN(M); will generate the
     appropriate assignment statements of the form
     name(i,j)=<corresponding matrix element>.  FORTINDENT[0] controls
     the left margin of expressions printed out, 0 is the normal margin
     (i.e. indented 6 spaces), increasing it will cause the expression
     to be printed further to the right.


 - Variable: FORTSPACES
     default: [FALSE] - if TRUE, the FORTRAN command fills out to 80
     columns using spaces.


 - Function: HORNER (exp, var)
     will convert exp into a rearranged representation as in Horner's
     rule, using var as the main variable if it is specified.  Var may
     also be omitted in which case the main variable of the CRE form of
     exp is used.  HORNER sometimes improves stability if expr is to be
     numerically evaluated.  It is also useful if MACSYMA is used to
     generate programs to be run in FORTRAN (see DESCRIBE(STRINGOUT);)
          (%i1) 1.0E-20*X^2-5.5*X+5.2E20;
                                          2
          (%o1)                   1.0E-20 X  - 5.5 X + 5.2E+20
          (%i2) HORNER(%,X),KEEPFLOAT:TRUE;
          (%o2)                  X (1.0E-20 X - 5.5) + 5.2E+20
          (%i3) %o1,X=1.0E20;
          ARITHMETIC OVERFLOW
          (%i4) %o2,X=1.0E20;
          (%o4)                          6.9999999E+19

 - Function: IFT (real-array, imag-array)
     Inverse Fourier Transform.  Do LOAD(FFT); to load in this package.
     These functions (FFT and IFT) perform a (complex) fast fourier
     transform on either 1 or 2 dimensional FLOATING-POINT arrays,
     obtained by: ARRAY(<ary>,FLOAT,<dim1>); or
     ARRAY(<ary>,FLOAT,<dim1>,<dim2>); For 1D arrays <dim1> must equal
     2^n-1, and for 2D arrays <dim1>=<dim2>=2^n-1 (i.e. the array is
     square).  (Recall that MACSYMA arrays are indexed from a 0 origin
     so that there will be 2^n and (2^n)^2 arrays elements in the above
     two cases.)  For details on the implementation, do
     PRINTFILE(FFT,USAGE,SHARE); .


 - Function: INTERPOLATE (func,x,a,b)
     finds the zero of func as x varies.  The last two args give the
     range to look in.  The function must have a different sign at each
     endpoint.  If this condition is not met, the action of the of the
     function is governed by INTPOLERROR[TRUE]).  If INTPOLERROR is
     TRUE then an error occurs, otherwise the value of INTPOLERROR is
     returned (thus for plotting INTPOLERROR might be set to 0.0).
     Otherwise (given that MACSYMA can evaluate the first argument in
     the specified range, and that it is continuous) INTERPOLATE is
     guaranteed to come up with the zero (or one of them if there is
     more than one zero).  The accuracy of INTERPOLATE is governed by
     INTPOLABS[0.0] and INTPOLREL[0.0] which must be non-negative
     floating point numbers.  INTERPOLATE will stop when the first arg
     evaluates to something less than or equal to INTPOLABS or if
     successive approximants to the root differ by no more than
     INTPOLREL * <one of the approximants>.  The default values of
     INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets as good an
     answer as is possible with the single precision arithmetic we
     have.  The first arg may be an equation.  The order of the last
     two args is irrelevant.  Thus

          INTERPOLATE(SIN(X)=X/2,X,%PI,.1);
             is equivalent to
          INTERPOLATE(SIN(X)=X/2,X,.1,%PI);
     The method used is a binary search in the range specified by the
     last two args.  When it thinks the function is close enough to
     being linear, it starts using linear interpolation.  An
     alternative syntax has been added to interpolate, this replaces the
     first two arguments by a function name.  The function MUST be
     TRANSLATEd or compiled function of one argument.  No checking of
     the result is done, so make sure the function returns a floating
     point number.

          F(X):=(MODE_DECLARE(X,FLOAT),SIN(X)-X/2.0);
          INTERPOLATE(SIN(X)-X/2,X,0.1,%PI)       time= 60 msec
          INTERPOLATE(F(X),X,0.1,%PI);            time= 68 msec
          TRANSLATE(F);
          INTERPOLATE(F(X),X,0.1,%PI);            time= 26 msec
          INTERPOLATE(F,0.1,%PI);                 time=  5 msec

     There is also a Newton method interpolation routine, do
     DESCRIBE(NEWTON); .


 - Variable: INTPOLABS
     default: [0.0] - The accuracy of the INTERPOLATE command is
     governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
     non-negative floating point numbers.  INTERPOLATE will stop when
     the first arg evaluates to something less than or equal to
     INTPOLABS or if successive approximants to the root differ by no
     more than INTPOLREL * <one of the approximants>.  The default
     values of INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets as
     good an answer as is possible with the single precision arithmetic
     we have.


 - Variable: INTPOLERROR
     default: [TRUE] - Governs the behavior of INTERPOLATE.  When
     INTERPOLATE is called, it determines whether or not the function
     to be interpolated satisfies the condition that the values of the
     function at the endpoints of the interpolation interval are
     opposite in sign.  If they are of opposite sign, the interpolation
     proceeds.  If they are of like sign, and INTPOLERROR is TRUE, then
     an error is signaled.  If they are of like sign and INTPOLERROR is
     not TRUE, the value of INTPOLERROR is returned.  Thus for
     plotting, INTPOLERROR might be set to 0.0.


 - Variable: INTPOLREL
     default: [0.0] - The accuracy of the INTERPOLATE command is
     governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
     non-negative floating point numbers.  INTERPOLATE will stop when
     the first arg evaluates to something less than or equal to
     INTPOLABS or if successive approximants to the root differ by no
     more than INTPOLREL * <one of the approximants>.  The default
     values of INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets as
     good an answer as is possible with the single precision arithmetic
     we have.


 - Function: NEWTON (exp,var,X0,eps)
     The file NEWTON 1 on the SHARE directory contains a function which
     will do interpolation using Newton's method.  It may be accessed
     by LOAD(NEWTON); .  The Newton method can do things that
     INTERPOLATE will refuse to handle, since INTERPOLATE requires that
     everything evaluate to a flonum. Thus
     NEWTON(x^2-a^2,x,a/2,a^2/100); will say that it can't tell if
     flonum*a^2<a^2/100. Doing ASSUME(a>0); and then doing NEWTON again
     works. You get x=a+<small flonum>*a which is symbolic all the way.
     INTERPOLATE(x^2-a^2,x,a/2,2*a); complains that .5*a is not
     flonum...  An adaptive integrator which uses the Newton-Cotes 8
     panel quadrature rule is available in SHARE1;QQ FASL.  Do
     DESCRIBE(QQ) for details.


 - Function: POLARTORECT (magnitude-array, phase-array)
     converts from magnitude and phase form into real and imaginary
     form putting the real part in the magnitude array and the
     imaginary part into the phase array

          <real>=<magnitude>*COS(<phase>) ==>
            <imaginary>=<magnitude>*SIN(<phase>

     This function is part of the FFT package.  Do LOAD(FFT); to use
     it.  Like FFT and IFT this function accepts 1 or 2 dimensional
     arrays.  However, the array dimensions need not be a power of 2,
     nor need the 2D arrays be square.


 - Function: RECTTOPOLAR (real-array, imag-array)
     undoes POLARTORECT.  The phase is given in the range from -%PI to
     %PI.  This function is part of the FFT package.  Do LOAD(FFT); to
     use it.  Like FFT and IFT this function accepts 1 or 2 dimensional
     arrays.  However, the array dimensions need not be a power of 2,
     nor need the 2D arrays be square.



File: maxima.info,  Node: Statistics,  Next: Arrays and Tables,  Prev: Numerical,  Up: Top

Statistics
**********

* Menu:

* Definitions for Statistics::


File: maxima.info,  Node: Definitions for Statistics,  Prev: Statistics,  Up: Statistics

Definitions for Statistics
==========================

 - Function: GAUSS (mean,sd)
     returns a random floating point number from a normal distribution
     with mean MEAN and standard deviation SD.  This is part of the
     BESSEL function package, do LOAD(BESSEL); to use it.



File: maxima.info,  Node: Arrays and Tables,  Next: Matrices and Linear Algebra,  Prev: Statistics,  Up: Top

Arrays and Tables
*****************

* Menu:

* Definitions for Arrays and Tables::

