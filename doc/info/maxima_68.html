<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on September, 20 2006 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima Manual: 68. stringproc</title>

<meta name="description" content="Maxima Manual: 68. stringproc">
<meta name="keywords" content="Maxima Manual: 68. stringproc">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body
{
    color: black;
    background: white; 
    margin-left: 8%;
    margin-right: 13%;
}

h1
{
    margin-left: +8%;
    font-size: 150%;
    font-family: sans-serif
}

h2
{
    font-size: 125%;
    font-family: sans-serif
}

h3
{
    font-size: 100%;
    font-family: sans-serif
}

h2,h3,h4,h5,h6 { margin-left: +4%; }

div.textbox
{
    border: solid;
    border-width: thin;
    /* width: 100%; */
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em
}

div.titlebox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
    background: rgb(200,255,255);
    font-family: sans-serif
}

div.synopsisbox
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 2em;
    padding-right: 2em;
     background: rgb(255,220,255);
    /*background: rgb(200,255,255); */
    /* font-family: fixed */
}

pre.example
{
    border: none;
    padding-top: 1em;
    padding-bottom: 1em;
    padding-left: 1em;
    padding-right: 1em;
    background: rgb(247,242,180); /* kind of sandy */
    /* background: rgb(200,255,255); */ /* sky blue */
    font-family: "Lucida Console", monospace
}

div.spacerbox
{
    border: none;
    padding-top: 2em;
    padding-bottom: 2em
}

div.image
{
    margin: 0;
    padding: 1em;
    text-align: center;
}
-->
</style>

<link rel="icon" href="http://maxima.sourceforge.net/favicon.ico"/>
</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="stringproc"></a>
<a name="SEC247"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_67.html#SEC246" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC248" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_67.html#SEC245" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC264" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 68. stringproc </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC248">68.1 Introduction to string processing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC249">68.2 Definitions for input and output</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC250">68.3 Definitions for characters</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC251">68.4 Definitions for strings</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introduction-to-string-processing"></a>
<a name="SEC248"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC247" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC249" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC247" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC247" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC264" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 68.1 Introduction to string processing </h2>

<p><code>stringproc.lisp</code> enlarges Maximas capabilities of working with strings.
</p>
<p>Please note that for Maxima Version 5.9.1 you need a different file. 
For questions and bugs mail to van.nek at arcor.de .
</p>
<p>Load <code>stringproc.lisp</code> by typing <code>load(&quot;stringproc&quot;);</code>.
</p>
<p>In Maxima a string is easily constructed by typing &quot;text&quot;.
Note that Maxima-strings are no Lisp-strings and vice versa.
Tests can be done with <code>stringp</code> respectively <code>lstringp</code>.
If for some reasons you have a value,
that is a Lisp-string, maybe when using Maxima-function sconcat, you can convert via <code>sunlisp</code>. 
</p>

<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) m: &quot;text&quot;;
(%o2)                         text
(%i3) [stringp(m),lstringp(m)];
(%o3)                     [true, false]
(%i4) l: sconcat(&quot;text&quot;);
(%o4)                         text
(%i5) [stringp(l),lstringp(l)];
(%o5)                     [false, true]
(%i6) stringp( sunlisp(l) );
(%o6)                         true
</pre></td></tr></table>
<p>All functions in <code>stringproc.lisp</code>, that return strings, return Maxima-strings.
</p>
<p>Characters are introduced as Maxima-strings of length 1.
Of course, these are no Lisp-characters.
Tests can be done with <code>charp</code> (respectively <code>lcharp</code> and conversion from Lisp to Maxima with <code>cunlisp</code>).
</p>

<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) c: &quot;e&quot;;
(%o2)                           e
(%i3) [charp(c),lcharp(c)];
(%o3)                     [true, false]
(%i4) supcase(c);
(%o4)                           E
(%i5) charp(%);
(%o5)                         true
</pre></td></tr></table>
<p>Again, all functions in <code>stringproc.lisp</code>, that return characters, return Maxima-characters.
Due to the fact, that the introduced characters are strings of length 1,
you can use a lot of string functions also for characters.
As seen, <code>supcase</code> is one example.
</p>
<p>It is important to know,
that the first character in a Maxima-string is at position 1.
This is designed due to the fact that the first element in a Maxima-list is at position 1 too.
See definitions of charat and charlist for examples.
</p>
<p>In applications string-functions are often used when working with files.
You will find some useful stream- and print-functions in <code>stringproc.lisp</code>.
The following example shows some of the here introduced functions at work.
</p>
<p>Example: 
</p>
<p>Let file contain Maxima console I/O,
saved with 'Save Console to File' or with copy and paste.
<code>extracti</code> then extracts the values of all input labels to a batchable file,
which path is the return value.
The batch process can directly be started with <code>batch(%)</code>.
Note that <code>extracti</code> fails if at least one label is damaged, maybe due to erasing the <code>).</code>
Or if there are input lines from a batch process.
In this case terminators are missing.
It fails too, if there are some characters behind the terminators, maybe due to comment.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">extracti(file):= block(
   [ s1: openr(file), ifile: sconc(file,&quot;.in&quot;), line, nl: false ],
   s2: openw(ifile), 

   while ( stringp(line: readline(s1)) ) do (
      if ssearch( sconc(&quot;(&quot;,inchar),line ) = 1 then (
         line: strim(&quot; &quot;,substring( line,ssearch(&quot;)&quot;,line)+1 )),
         printf( s2,&quot;~a~%&quot;,line ),
         checklast(line) )
      else if nl then (
         line: strimr(&quot; &quot;,line),
         printf( s2,&quot;~a~%&quot;,line ),
         checklast(line) )),
         
   close(s1), close(s2),
   ifile)$
      
checklast(line):= block(
   [ last: charat( line,slength(line) ) ],
   if cequal(last,&quot;;&quot;) or cequal(last,&quot;$&quot;) then 
      nl:false else nl:true )$
</pre></td></tr></table>
<p>File 'C:\home\maxima\test.out':
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) f(x):= sin(x)$
(%i2) diff(f(x),x);
(%o2)                               cos(x)
(%i3) df(x):= ''%;
(%o3)                           df(x) := cos(x)
(%i4) df(0);
(%o4)                                  1
</pre></td></tr></table>
<p>Maxima:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i11) extracti(&quot;C:\\home\\maxima\\test.out&quot;);
(%o11)             C:\home\maxima\test.out.in
(%i12) batch(%);

batching #pC:/home/maxima/test.out.in
(%i13)                          f(x) := sin(x)
(%i14)                           diff(f(x), x)
(%o14)                              cos(x)
(%i15)                          df(x) := cos(x)
(%o15)                          df(x) := cos(x)
(%i16)                               df(0)
(%o16)                                 1 
</pre></td></tr></table>
<hr size="6">
<a name="Definitions-for-input-and-output"></a>
<a name="SEC249"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC248" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC250" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC247" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC247" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC264" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 68.2 Definitions for input and output </h2>

<p>Example: 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) s: openw(&quot;C:\\home\\file.txt&quot;);
(%o1)                 #&lt;output stream C:\home\file.txt&gt;
(%i2) control: &quot;~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2tand an integer: ~20t~d~%&quot;$
(%i3) printf( s,control, 'true,[1,2,3],42 )$
(%o3)                                false
(%i4) close(s);
(%o4)                                true
(%i5) s: openr(&quot;C:\\home\\file.txt&quot;);
(%o5)                 #&lt;input stream C:\home\file.txt&gt;
(%i6) while stringp( tmp:readline(s) ) do print(tmp)$
  An atom:          true 
  and a list:       one two three  
  and an integer:   42 
(%i7) close(s)$
</pre></td></tr></table>

<dl>
<dt><u>Function:</u> <b>close</b><i> (<var>stream</var>) </i>
<a name="IDX1878"></a>
</dt>
<dd><p>Closes <var>stream</var> and returns <code>true</code> if <var>stream</var> had been open. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>flength</b><i> (<var>stream</var>)</i>
<a name="IDX1879"></a>
</dt>
<dd><p>Returns the number of elements in <var>stream</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>fposition</b><i> (<var>stream</var>)</i>
<a name="IDX1880"></a>
</dt>
<dt><u>Function:</u> <b>fposition</b><i> (<var>stream</var>, <var>pos</var>)</i>
<a name="IDX1881"></a>
</dt>
<dd><p>Returns the current position in <var>stream</var>, if <var>pos</var> is not used.
If <var>pos</var> is used,
<code>fposition</code> sets the position in <var>stream</var>.
<var>pos</var> has to be a positive number,
the first element in <var>stream</var> is in position 1.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>freshline</b><i> () </i>
<a name="IDX1882"></a>
</dt>
<dt><u>Function:</u> <b>freshline</b><i> (<var>stream</var>) </i>
<a name="IDX1883"></a>
</dt>
<dd><p>Writes a new line to <var>stream</var>,
if the position is not at the beginning of a line.
<code>freshline</code> does not work properly with the streams <code>true</code> and <code>false</code>. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>newline</b><i> () </i>
<a name="IDX1884"></a>
</dt>
<dt><u>Function:</u> <b>newline</b><i> (<var>stream</var>) </i>
<a name="IDX1885"></a>
</dt>
<dd><p>Writes a new line to <var>stream</var>.
<code>newline</code> does not work properly with the streams <code>true</code> and <code>false</code>.
See <code>sprint</code> for an example of using <code>newline</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>opena</b><i> (<var>file</var>) </i>
<a name="IDX1886"></a>
</dt>
<dd><p>Returns an output stream to <var>file</var>.
If an existing file is opened, <code>opena</code> appends elements at the end of file.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>openr</b><i> (<var>file</var>) </i>
<a name="IDX1887"></a>
</dt>
<dd><p>Returns an input stream to <var>file</var>.
If <var>file</var> does not exist, it will be created.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>openw</b><i> (<var>file</var>) </i>
<a name="IDX1888"></a>
</dt>
<dd><p>Returns an output stream to <var>file</var>.
If <var>file</var> does not exist, it will be created.
If an existing file is opened, <code>openw</code> destructively modifies <var>file</var>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>printf</b><i> (<var>dest</var>, <var>string</var>)</i>
<a name="IDX1889"></a>
</dt>
<dt><u>Function:</u> <b>printf</b><i> (<var>dest</var>, <var>string</var>, <var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1890"></a>
</dt>
<dd><p><code>printf</code> is like FORMAT in Common Lisp. 
(From gcl.info: &quot;format produces formatted output by outputting the characters of control-string string and observing that a tilde introduces a directive.
The character after the tilde,
possibly preceded by prefix parameters and modifiers,
specifies what kind of formatting is desired.
Most directives use one or more elements of args to create their output.&quot;)
</p>
<p>The following description and the examples may give an idea of using <code>printf</code>.
See Lisp reference for more information.
Note that there are some directives, which do not work in Maxima.
For example, <code>~:[</code> fails.
<code>printf</code> is designed with the intention, that <code>~s</code> is read as <code>~a</code>.
Also note that the selection directive <code>~[</code> is zero-indexed.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">   ~%       new line
   ~&amp;       fresh line
   ~t       tab
   ~$       monetary
   ~d       decimal integer
   ~b       binary integer
   ~o       octal integer
   ~x       hexadecimal integer
   ~br      base-b integer
   ~r       spell an integer
   ~p       plural
   ~f       floating point
   ~e       scientific notation
   ~g       ~f or ~e, depending upon magnitude
   ~a       as printed by Maxima function print
   ~s       like ~a
   ~~       ~
   ~&lt;       justification, ~&gt; terminates
   ~(       case conversion, ~) terminates 
   ~[       selection, ~] terminates 
   ~{       iteration, ~} terminates
</pre></td></tr></table>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) printf( false, &quot;~s ~a ~4f ~a ~@r&quot;, 
&quot;String&quot;,sym,bound,sqrt(8),144), bound = 1.234;
(%o1)                 String sym 1.23 2*sqrt(2) CXLIV
(%i2) printf( false,&quot;~{~a ~}&quot;,[&quot;one&quot;,2,&quot;THREE&quot;] );
(%o2)                          one 2 THREE 
(%i3) printf( true,&quot;~{~{~9,1f ~}~%~}&quot;,mat ),
mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
      1.1       2.0       3.3 
      4.0       5.0       6.0 
      7.0       8.9       9.0 
(%i4) control: &quot;~:(~r~) bird~p ~[is~;are~] singing.&quot;$
(%i5) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
(%o5)                    Two birds are singing.
</pre></td></tr></table>
<p>If <var>dest</var> is a stream or <code>true</code>, then <code>printf</code> returns <code>false</code>.
Otherwise, <code>printf</code> returns a string containing the output.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>readline</b><i> (<var>stream</var>) </i>
<a name="IDX1891"></a>
</dt>
<dd><p>Returns a string containing the characters from the current position in <var>stream</var> up to the end of the line or <var>false</var> if the end of the file is encountered.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sprint</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1892"></a>
</dt>
<dd><p>Evaluates and displays its arguments one after the other `on a line' starting at the leftmost position.
The numbers are printed with the '-' right next to the number,
and it disregards line length.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) for n:0 thru 16 do sprint( fib(n) )$
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 
</pre></td></tr></table>
<p>In xmaxima you might wish to add <code>,newline()</code>, if you prefer line breaking prior to printing.
See <code>ascii</code> for an example.
</p>
</dd></dl>

<hr size="6">
<a name="Definitions-for-characters"></a>
<a name="SEC250"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC249" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC251" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC247" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC247" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC264" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 68.3 Definitions for characters </h2>

<dl>
<dt><u>Function:</u> <b>alphacharp</b><i> (<var>char</var>)    </i>
<a name="IDX1893"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char</var> is an alphabetic character. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>alphanumericp</b><i> (<var>char</var>) </i>
<a name="IDX1894"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char</var> is an alphabetic character or a digit. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ascii</b><i> (<var>int</var>) </i>
<a name="IDX1895"></a>
</dt>
<dd><p>Returns the character corresponding to the ASCII number <var>int</var>.
( -1 &lt; int &lt; 256 )
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) for n from 0 thru 255 do ( tmp: ascii(n),
if alphacharp(tmp) then sprint(tmp) ), newline()$
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g
h i j k l m n o p q r s t u v w x y z
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cequal</b><i> (<var>char_1</var>, <var>char_2</var>)          </i>
<a name="IDX1896"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char_1</var> and <var>char_2</var> are the same. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cequalignore</b><i> (<var>char_1</var>, <var>char_2</var>)    </i>
<a name="IDX1897"></a>
</dt>
<dd><p>Like <code>cequal</code> but ignores case. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cgreaterp</b><i> (<var>char_1</var>, <var>char_2</var>)       </i>
<a name="IDX1898"></a>
</dt>
<dd><p>Returns <code>true</code> if the ASCII number of <var>char_1</var> is greater than the number of <var>char_2</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cgreaterpignore</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX1899"></a>
</dt>
<dd><p>Like <code>cgreaterp</code> but ignores case. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>charp</b><i> (<var>obj</var>) </i>
<a name="IDX1900"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>obj</var> is a Maxima-character.
See introduction for example.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cint</b><i> (<var>char</var>) </i>
<a name="IDX1901"></a>
</dt>
<dd><p>Returns the ASCII number of <var>char</var>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>clessp</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX1902"></a>
</dt>
<dd><p>Returns <code>true</code> if the ASCII number of <var>char_1</var> is less than the number of <var>char_2</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>clesspignore</b><i> (<var>char_1</var>, <var>char_2</var>)</i>
<a name="IDX1903"></a>
</dt>
<dd><p>Like <code>clessp</code> but ignores case. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>constituent</b><i> (<var>char</var>)   </i>
<a name="IDX1904"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char</var> is a graphic character and not the space character.
A graphic character is a character one can see, plus the space character.
(<code>constituent</code> is defined by Paul Graham, ANSI Common Lisp, 1996, page 67.)
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) for n from 0 thru 255 do ( tmp: ascii(n),
if constituent(tmp) then sprint(tmp) ), newline()$
! &quot; #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? @ A B
C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
d e f g h i j k l m n o p q r s t u v w x y z { | } ~
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>cunlisp</b><i> (<var>lisp_char</var>) </i>
<a name="IDX1905"></a>
</dt>
<dd><p>Converts a Lisp-character into a Maxima-character.
(You wont need it.)
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>digitcharp</b><i> (<var>char</var>)    </i>
<a name="IDX1906"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char</var> is a digit. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>lcharp</b><i> (<var>obj</var>) </i>
<a name="IDX1907"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>obj</var> is a Lisp-character.
(You wont need it.)
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>lowercasep</b><i> (<var>char</var>)    </i>
<a name="IDX1908"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char</var> is a lowercase character. 
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>newline</b>
<a name="IDX1909"></a>
</dt>
<dd><p>The character newline. 
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>space</b>
<a name="IDX1910"></a>
</dt>
<dd><p>The character space.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>tab</b>
<a name="IDX1911"></a>
</dt>
<dd><p>The character tab.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>uppercasep</b><i> (<var>char</var>)    </i>
<a name="IDX1912"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>char</var> is an uppercase character. 
</p>
</dd></dl>

<hr size="6">
<a name="Definitions-for-strings"></a>
<a name="SEC251"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC250" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC247" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC247" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC264" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 68.4 Definitions for strings </h2>

<dl>
<dt><u>Function:</u> <b>sunlisp</b><i> (<var>lisp_string</var>) </i>
<a name="IDX1913"></a>
</dt>
<dd><p>Converts a Lisp-string into a Maxima-string.
(In general you wont need it.)
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>lstringp</b><i> (<var>obj</var>) </i>
<a name="IDX1914"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>obj</var> is a Lisp-string.
(In general you wont need it.)
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>stringp</b><i> (<var>obj</var>) </i>
<a name="IDX1915"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>obj</var> is a Maxima-string.
See introduction for example.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>charat</b><i> (<var>string</var>, <var>n</var>) </i>
<a name="IDX1916"></a>
</dt>
<dd><p>Returns the <var>n</var>-th character of <var>string</var>.
The first character in <var>string</var> is returned with <var>n</var> = 1.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) charat(&quot;Lisp&quot;,1);
(%o2)                           L
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>charlist</b><i> (<var>string</var>) </i>
<a name="IDX1917"></a>
</dt>
<dd><p>Returns the list of all characters in <var>string</var>. 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) charlist(&quot;Lisp&quot;);
(%o2)                     [L, i, s, p]
(%i3) %[1];
(%o3)                           L
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>parsetoken</b><i> (<var>string</var>)  </i>
<a name="IDX1918"></a>
</dt>
<dd><p><code>parsetoken</code> converts the first token in <var>string</var> to the corresponding number or returns <code>false</code> if the number cannot be determined .
The delimiter set for tokenizing is <code>{space, comma, semicolon, tab, newline}</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) 2*parsetoken(&quot;1.234 5.678&quot;);
(%o2)                         2.468
</pre></td></tr></table>
<p>For parsing you can also use function parse_string.
See description in file 'share\contrib\eval_string.lisp'. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sconc</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1919"></a>
</dt>
<dd><p>Evaluates its arguments and concatenates them into a string.
<code>sconc</code> is like <code>sconcat</code> but returns a Maxima string.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sconc(&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3));
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) stringp(%);
(%o3)                         true
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>scopy</b><i> (<var>string</var>) </i>
<a name="IDX1920"></a>
</dt>
<dd><p>Returns a copy of <var>string</var> as a new string. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sdowncase</b><i> (<var>string</var>) </i>
<a name="IDX1921"></a>
</dt>
<dt><u>Function:</u> <b>sdowncase</b><i> (<var>string</var>, <var>start</var>) </i>
<a name="IDX1922"></a>
</dt>
<dt><u>Function:</u> <b>sdowncase</b><i> (<var>string</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX1923"></a>
</dt>
<dd><p>Like <code>supcase</code>, but uppercase characters are converted to lowercase. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sequal</b><i> (<var>string_1</var>, <var>string_2</var>) </i>
<a name="IDX1924"></a>
</dt>
<dd><p>Returns <code>true</code> if <var>string_1</var> and <var>string_2</var> are the same length and contain the same characters. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sequalignore</b><i> (<var>string_1</var>, <var>string_2</var>)</i>
<a name="IDX1925"></a>
</dt>
<dd><p>Like <code>sequal</code> but ignores case. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sexplode</b><i> (<var>string</var>)</i>
<a name="IDX1926"></a>
</dt>
<dd><p><code>sexplode</code> is an alias for function <code>charlist</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>simplode</b><i> (<var>list</var>)  </i>
<a name="IDX1927"></a>
</dt>
<dt><u>Function:</u> <b>simplode</b><i> (<var>list</var>, <var>delim</var>)  </i>
<a name="IDX1928"></a>
</dt>
<dd><p><code>simplode</code> takes a list of expressions and concatenates them into a string.
If no delimiter <var>delim</var> is used, <code>simplode</code> is like <code>sconc</code> and uses no delimiter.
<var>delim</var> can be any string.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) simplode([&quot;xx[&quot;,3,&quot;]:&quot;,expand((x+y)^3)]);
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) simplode( sexplode(&quot;stars&quot;),&quot; * &quot; );
(%o3)                   s * t * a * r * s
(%i4) simplode( [&quot;One&quot;,&quot;more&quot;,&quot;coffee.&quot;],&quot; &quot; );
(%o4)                   One more coffee.
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sinsert</b><i> (<var>seq</var>, <var>string</var>, <var>pos</var>)  </i>
<a name="IDX1929"></a>
</dt>
<dd><p>Returns a string that is a concatenation of <code>substring (<var>string</var>, 1, <var>pos</var> - 1)</code>,
the string <var>seq</var> and <code>substring (<var>string</var>, <var>pos</var>)</code>.
Note that the first character in <var>string</var> is in position 1.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) s: &quot;A submarine.&quot;$
(%i3) sconc( substring(s,1,3),&quot;yellow &quot;,substring(s,3) );
(%o3)                  A yellow submarine.
(%i4) sinsert(&quot;hollow &quot;,s,3);
(%o4)                  A hollow submarine.
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sinvertcase</b><i> (<var>string</var>)  </i>
<a name="IDX1930"></a>
</dt>
<dt><u>Function:</u> <b>sinvertcase</b><i> (<var>string</var>, <var>start</var>)  </i>
<a name="IDX1931"></a>
</dt>
<dt><u>Function:</u> <b>sinvertcase</b><i> (<var>string</var>, <var>start</var>, <var>end</var>)  </i>
<a name="IDX1932"></a>
</dt>
<dd><p>Returns <var>string</var> except that each character from position <var>start</var> to <var>end</var> is inverted.
If <var>end</var> is not given,
all characters from start to the <var>end</var> of <var>string</var> are replaced.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sinvertcase(&quot;sInvertCase&quot;);
(%o2)                      SiNVERTcASE
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>slength</b><i> (<var>string</var>) </i>
<a name="IDX1933"></a>
</dt>
<dd><p>Returns the number of characters in <var>string</var>. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>smake</b><i> (<var>num</var>, <var>char</var>) </i>
<a name="IDX1934"></a>
</dt>
<dd><p>Returns a new string with a number of <var>num</var> characters <var>char</var>. 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) smake(3,&quot;w&quot;);
(%o2)                          www
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>smismatch</b><i> (<var>string_1</var>, <var>string_2</var>) </i>
<a name="IDX1935"></a>
</dt>
<dt><u>Function:</u> <b>smismatch</b><i> (<var>string_1</var>, <var>string_2</var>, <var>test</var>) </i>
<a name="IDX1936"></a>
</dt>
<dd><p>Returns the position of the first character of <var>string_1</var> at which <var>string_1</var> and <var>string_2</var> differ or <code>false</code>.
Default test function for matching is <code>sequal</code>.
If <code>smismatch</code> should ignore case, use <code>sequalignore</code> as test.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) smismatch(&quot;seven&quot;,&quot;seventh&quot;);
(%o2)                           6
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>split</b><i> (<var>string</var>)  </i>
<a name="IDX1937"></a>
</dt>
<dt><u>Function:</u> <b>split</b><i> (<var>string</var>, <var>delim</var>)  </i>
<a name="IDX1938"></a>
</dt>
<dt><u>Function:</u> <b>split</b><i> (<var>string</var>, <var>delim</var>, <var>multiple</var>)  </i>
<a name="IDX1939"></a>
</dt>
<dd><p>Returns the list of all tokens in <var>string</var>.
Each token is an unparsed string.
<code>split</code> uses <var>delim</var> as delimiter.
If <var>delim</var> is not given, the space character is the default delimiter.
<var>multiple</var> is a boolean variable with <code>true</code> by default.
Multiple delimiters are read as one.
This is useful if tabs are saved as multiple space characters.
If <var>multiple</var> is set to <code>false</code>, each delimiter is noted.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) split(&quot;1.2   2.3   3.4   4.5&quot;);
(%o2)                 [1.2, 2.3, 3.4, 4.5]
(%i3) split(&quot;first;;third;fourth&quot;,&quot;;&quot;,false);
(%o3)               [first, , third, fourth]
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sposition</b><i> (<var>char</var>, <var>string</var>) </i>
<a name="IDX1940"></a>
</dt>
<dd><p>Returns the position of the first character in <var>string</var> which matches <var>char</var>.
The first character in <var>string</var> is in position 1.
For matching characters ignoring case see <code>ssearch</code>.
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>)  </i>
<a name="IDX1941"></a>
</dt>
<dt><u>Function:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>)  </i>
<a name="IDX1942"></a>
</dt>
<dt><u>Function:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>)  </i>
<a name="IDX1943"></a>
</dt>
<dt><u>Function:</u> <b>sremove</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>)  </i>
<a name="IDX1944"></a>
</dt>
<dd><p>Returns a string like <var>string</var> but without all substrings matching <var>seq</var>.
Default test function for matching is <code>sequal</code>.
If <code>sremove</code> should ignore case while searching for <var>seq</var>, use <code>sequalignore</code> as test.
Use <var>start</var> and <var>end</var> to limit searching.
Note that the first character in <var>string</var> is in position 1.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) sremove(&quot;n't&quot;,&quot;I don't like coffee.&quot;);
(%o2)                   I do like coffee.
(%i3) sremove (&quot;DO &quot;,%,'sequalignore);
(%o3)                    I like coffee.
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>)  </i>
<a name="IDX1945"></a>
</dt>
<dt><u>Function:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>)  </i>
<a name="IDX1946"></a>
</dt>
<dt><u>Function:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>)  </i>
<a name="IDX1947"></a>
</dt>
<dt><u>Function:</u> <b>sremovefirst</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>)  </i>
<a name="IDX1948"></a>
</dt>
<dd><p>Like <code>sremove</code> except that only the first substring that matches <code>seq</code> is removed. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>sreverse</b><i> (<var>string</var>) </i>
<a name="IDX1949"></a>
</dt>
<dd><p>Returns a string with all the characters of <var>string</var> in reverse order. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>)  </i>
<a name="IDX1950"></a>
</dt>
<dt><u>Function:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>)  </i>
<a name="IDX1951"></a>
</dt>
<dt><u>Function:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>)  </i>
<a name="IDX1952"></a>
</dt>
<dt><u>Function:</u> <b>ssearch</b><i> (<var>seq</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>)</i>
<a name="IDX1953"></a>
</dt>
<dd><p>Returns the position of the first substring of <var>string</var> that matches the string <var>seq</var>.
Default test function for matching is <code>sequal</code>.
If <code>ssearch</code> should ignore case, use <code>sequalignore</code> as test.
Use <var>start</var> and <var>end</var> to limit searching.
Note that the first character in <var>string</var> is in position 1.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) ssearch(&quot;~s&quot;,&quot;~{~S ~}~%&quot;,'sequalignore);
(%o1)                                  4
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ssort</b><i> (<var>string</var>) </i>
<a name="IDX1954"></a>
</dt>
<dt><u>Function:</u> <b>ssort</b><i> (<var>string</var>, <var>test</var>) </i>
<a name="IDX1955"></a>
</dt>
<dd><p>Returns a string that contains all characters from <var>string</var> in an order such there are no two successive characters <var>c</var> and <var>d</var> such that <code>test (<var>c</var>, <var>d</var>)</code> is <code>false</code> and <code>test (<var>d</var>, <var>c</var>)</code> is <code>true</code>.
Default test function for sorting is <var>clessp</var>.
The set of test functions is <code>{clessp, clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore}</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) ssort(&quot;I don't like Mondays.&quot;);
(%o2)                    '.IMaddeiklnnoosty
(%i3) ssort(&quot;I don't like Mondays.&quot;,'cgreaterpignore);
(%o3)                 ytsoonnMlkIiedda.'   
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>) </i>
<a name="IDX1956"></a>
</dt>
<dt><u>Function:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>) </i>
<a name="IDX1957"></a>
</dt>
<dt><u>Function:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>) </i>
<a name="IDX1958"></a>
</dt>
<dt><u>Function:</u> <b>ssubst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX1959"></a>
</dt>
<dd><p>Returns a string like <var>string</var> except that all substrings matching <var>old</var> are replaced by <var>new</var>.
<var>old</var> and <var>new</var> need not to be of the same length.
Default test function for matching is <code>sequal</code>.
If <code>ssubst</code> should ignore case while searching for old, use <code>sequalignore</code> as test.
Use <var>start</var> and <var>end</var> to limit searching.
Note that the first character in <var>string</var> is in position 1.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) ssubst(&quot;like&quot;,&quot;hate&quot;,&quot;I hate Thai food. I hate green tea.&quot;);
(%o2)          I like Thai food. I like green tea.
(%i3) ssubst(&quot;Indian&quot;,&quot;thai&quot;,%,'sequalignore,8,12);
(%o3)         I like Indian food. I like green tea.
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>) </i>
<a name="IDX1960"></a>
</dt>
<dt><u>Function:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>) </i>
<a name="IDX1961"></a>
</dt>
<dt><u>Function:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>) </i>
<a name="IDX1962"></a>
</dt>
<dt><u>Function:</u> <b>ssubstfirst</b><i> (<var>new</var>, <var>old</var>, <var>string</var>, <var>test</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX1963"></a>
</dt>
<dd><p>Like <code>subst</code> except that only the first substring that matches <var>old</var> is replaced. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>strim</b><i> (<var>seq</var>,<var>string</var>) </i>
<a name="IDX1964"></a>
</dt>
<dd><p>Returns a string like <var>string</var>,
but with all characters that appear in <var>seq</var> removed from both ends. 
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) &quot;/* comment */&quot;$
(%i3) strim(&quot; /*&quot;,%);
(%o3)                        comment
(%i4) slength(%);
(%o4)                           7
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>striml</b><i> (<var>seq</var>, <var>string</var>) </i>
<a name="IDX1965"></a>
</dt>
<dd><p>Like <code>strim</code> except that only the left end of <var>string</var> is trimmed. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>strimr</b><i> (<var>seq</var>, <var>string</var>) </i>
<a name="IDX1966"></a>
</dt>
<dd><p>Like <code>strim</code> except that only the right end of string is trimmed. 
</p>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>substring</b><i> (<var>string</var>, <var>start</var>)</i>
<a name="IDX1967"></a>
</dt>
<dt><u>Function:</u> <b>substring</b><i> (<var>string</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX1968"></a>
</dt>
<dd><p>Returns the substring of <var>string</var> beginning at position <var>start</var> and ending at position <var>end</var>.
The character at position <var>end</var> is not included.
If <var>end</var> is not given, the substring contains the rest of the string.
Note that the first character in <var>string</var> is in position 1.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) substring(&quot;substring&quot;,4);
(%o2)                        string
(%i3) substring(%,4,6);
(%o3)                          in
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>supcase</b><i> (<var>string</var>) </i>
<a name="IDX1969"></a>
</dt>
<dt><u>Function:</u> <b>supcase</b><i> (<var>string</var>, <var>start</var>) </i>
<a name="IDX1970"></a>
</dt>
<dt><u>Function:</u> <b>supcase</b><i> (<var>string</var>, <var>start</var>, <var>end</var>) </i>
<a name="IDX1971"></a>
</dt>
<dd><p>Returns <var>string</var> except that lowercase characters from position <var>start</var> to <var>end</var> are replaced by the corresponding uppercase ones.
If <var>end</var> is not given,
all lowercase characters from <var>start</var> to the end of <var>string</var> are replaced.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) supcase(&quot;english&quot;,1,2);
(%o2)                        English
</pre></td></tr></table>
</dd></dl>

<dl>
<dt><u>Function:</u> <b>tokens</b><i> (<var>string</var>) </i>
<a name="IDX1972"></a>
</dt>
<dt><u>Function:</u> <b>tokens</b><i> (<var>string</var>, <var>test</var>) </i>
<a name="IDX1973"></a>
</dt>
<dd><p>Returns a list of tokens, which have been extracted from <var>string</var>.
The tokens are substrings whose characters satisfy a certain test function.
If test is not given, <var>constituent</var> is used as the default test.
<code>{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp}</code> is the set of test functions. 
(The Lisp-version of <code>tokens</code> is written by Paul Graham. ANSI Common Lisp, 1996, page 67.)
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(%i1) load(&quot;stringproc&quot;)$
(%i2) tokens(&quot;24 October 2005&quot;);
(%o2)                  [24, October, 2005]
(%i3) tokens(&quot;05-10-24&quot;,'digitcharp);
(%o3)                     [05, 10, 24]
(%i4) map(parsetoken,%);
(%o4)                      [5, 10, 24]
</pre></td></tr></table>
</dd></dl>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC247" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_69.html#SEC252" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_72.html#SEC264" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>September, 20 2006</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
