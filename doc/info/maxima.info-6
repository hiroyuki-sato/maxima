This is maxima.info, produced by makeinfo version 4.1 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: SPECINT,  Next: Definitions for Special Functions,  Prev: GAMALG,  Up: Special Functions

SPECINT
=======

   - The Hypergeometric Special Functions Package HYPGEO is still under
development.  At the moment it will find the Laplace Transform or
rather, the integral from 0 to INF of some special functions or
combinations of them.  The factor, EXP(-P*var) must be explicitly
stated.  The syntax is as follows: SPECINT(EXP(-P*var)*expr,var); where
var is the variable of integration and expr may be any expression
containing special functions (at your own risk).  Special function
notation follows:
     %J[index](expr)         Bessel Funct 1st Kind
     %K[index](expr)           "     "    2nd Kind
     %IBES[     ](    )      Modified Bessel Funct 1st Kind
     %HE[     ](  )          Hermite Poly
     %P[  ]( )               Legendre Funct
     %Q[  ]( )               Legendre of second kind
     HSTRUVE[ ]( )           Struve H Function
     LSTRUVE[ ]( )             "    L Function
     %F[ ]([],[],expr)       Hypergeometric Function
     GAMMA()
     GAMMAGREEK()
     GAMMAINCOMPLETE()
     SLOMMEL
     %M[]()                  Whittaker Funct 1st Kind
     %W[]()                     "       "    2nd  "

For a better feeling for what it can do, do DEMO(HYPGEO,DEMO,SHARE1); .


File: maxima.info,  Node: Definitions for Special Functions,  Prev: SPECINT,  Up: Special Functions

Definitions for Special Functions
=================================

 - Function: AIRY (X)
     returns the Airy function Ai of real argument X.  The file
     SHARE1;AIRY FASL contains routines to evaluate the Airy functions
     Ai(X), Bi(X), and their derivatives dAi(X), dBi(X).  Ai and Bi
     satisfy the AIRY eqn diff(y(x),x,2)-x*y(x)=0.  Read SHARE1;AIRY
     USAGE for details.


 - Function: ASYMP
     - A preliminary version of a program to find the asymptotic
     behavior of Feynman diagrams has been installed on the SHARE1;
     directory.  For further information, see the file SHARE1;ASYMP
     USAGE.  (For Asymptotic Analysis functions, see ASYMPA.)


 - Function: ASYMPA
     - Asymptotic Analysis - The file SHARE1;ASYMPA > contains
     simplification functions for asymptotic analysis, including the
     big-O and little-o functions that are widely used in complexity
     analysis and numerical analysis.  Do BATCH("asympa.mc"); .  (For
     asymptotic behavior of Feynman diagrams, see ASYMP.)


 - Function: BESSEL (Z,A)
     returns the Bessel function J for complex Z and real A > 0.0 .
     Also an array BESSELARRAY is set up such that BESSELARRAY[I] =
     J[I+A- ENTIER(A)](Z).


 - Function: BESSEL_J [v](z)
     The Bessel function of the first kind of order v and argument z.
     It is defined by
          		       INF
          		       ====	  k  - v - 2 k  v + 2 k
          		       \     (- 1)  2	       z
           		        >    --------------------------
          		       /        k! GAMMA(v + k + 1)
          		       ====
          		       k = 0


 - Function: BESSEL_Y [v](z)
     The Bessel function of the second kind of order v and argument z.
     It is defined by
                             COS(%PI v) BESSEL_J (z) - BESSEL_J   (z)
                                                v              - v
                             ----------------------------------------
                                            SIN(%PI v)

     when v is not an integer.  When v is an integer n, the limit as v
     approaches n is taken.


 - Function: BESSEL_I [v](z)
     The modified Bessel function of the first kind of order v and
     argument z.    It is defined by

          			   INF
          			   ====	  - v - 2 k  v + 2 k
          			   \	 2	    z
          (D1) 			    >	 -------------------
          			   /	 k! GAMMA(v + k + 1)
          			   ====
          			   k = 0


 - Function: BESSEL_K [v](z)
     The modified Bessel function of the second kind of order v and
     argument z.  It is defined by

          		%PI CSC(%PI v) (BESSEL_I   (z) - BESSEL_I (z))
          					- v		 v
          (D3) 	        ----------------------------------------------
          				      2
     when v is not an integer.  If v is an integer n, then the limit as
     v approaches n is taken.

 - Variable: BESSELEXPAND
     default: FALSE  Controls expansion of the Bessel functions when
     the order half of an  odd integer.  In this case, the Bessel
     functions can be expanded in  terms of other elementary functions.
     When BESSELEXPAND is true, the  Bessel function is expanded.

          (C1) bessel_j[3/2](z);
          
          (D1)                            BESSEL_J   (z)
                                                  3/2
          (C2) besselexpand:true;
          
          (D2)                                 TRUE
          (C3) bessel_j[3/2](z);
          
                                                   COS(z)   SIN(z)
                                  SQRT(2) SQRT(z) (------ - ------)
                                                     z         2
                                                              z
          (D3)                  - ---------------------------------
                                              SQRT(%PI)

 - Function: BETA (X, Y)
     same as GAMMA(X)*GAMMA(Y)/GAMMA(X+Y).


 - Function: GAMMA (X)
     the gamma function. GAMMA(I)=(I-1)!  for I a positive integer.
     For the Euler-Mascheroni constant, see %GAMMA.  See also the
     MAKEGAMMA function.  The variable GAMMALIM[1000000] (which see)
     controls simplification of the gamma function.


 - Variable: GAMMALIM
     default: [1000000] controls simplification of the gamma function
     for integral and rational number arguments.  If the absolute value
     of the argument is not greater than GAMMALIM, then simplification
     will occur.  Note that the FACTLIM switch controls simplification
     of the result of GAMMA of an integer argument as well.


 - Function: INTOPOIS (A)
     converts A into a Poisson encoding.


 - Function: MAKEFACT (exp)
     transforms occurrences of binomial,gamma, and beta functions in
     exp to factorials.


 - Function: MAKEGAMMA (exp)
     transforms occurrences of binomial,factorial, and beta functions
     in exp to gamma functions.


 - Function: NUMFACTOR (exp)
     gives the numerical factor multiplying the expression exp which
     should be a single term.  If the gcd of all the terms in a sum is
     desired the CONTENT function may be used.
          (C1) GAMMA(7/2);
          (D1)               15 SQRT(%PI)
                             ------------
                                  8
          (C2) NUMFACTOR(%);
                              15
          (D2)                --
                               8

 - Function: OUTOFPOIS (A)
     converts A from Poisson encoding to general representation.  If A
     is not in Poisson form, it will make the conversion, i.e.  it will
     look like the result of OUTOFPOIS(INTOPOIS(A)).  This function is
     thus a canonical simplifier for sums of powers of SIN's and COS's
     of a particular type.


 - Function: POISDIFF (A, B)
     differentiates A with respect to B.  B must occur only in the trig
     arguments or only in the coefficients.


 - Function: POISEXPT (A, B)
     B a positive integer) is functionally identical to INTOPOIS(A**B).


 - Function: POISINT (A, B)
     integrates in a similarly restricted sense (to POISDIFF).
     Non-periodic terms in B are dropped if B is in the trig arguments.


 - Variable: POISLIM
     default: [5] - determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].


 - Function: POISMAP (series, sinfn, cosfn)
     will map the functions sinfn on the sine terms and cosfn on the
     cosine terms of the poisson series given.  sinfn and cosfn are
     functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.


 - Function: POISPLUS (A, B)
     is functionally identical to INTOPOIS(A+B).


 - Function: POISSIMP (A)
     converts A into a Poisson series for A in general representation.


 - special symbol: POISSON
     - The Symbol /P/ follows the line label of Poisson series
     expressions.


 - Function: POISSUBST (A, B, C)
     substitutes A for B in C.  C is a Poisson series.  (1) Where B is
     a variable U, V, W, X, Y, or Z then A must be an expression linear
     in those variables (e.g. 6*U+4*V).  (2) Where B is other than
     those variables, then A must also be free of those variables, and
     furthermore, free of sines or cosines.  POISSUBST(A, B, C, D, N)
     is a special type of substitution which operates on A and B as in
     type (1) above, but where D is a Poisson series, expands COS(D)
     and SIN(D) to order N so as to provide the result of substituting
     A+D for B in C.  The idea is that D is an expansion in terms of a
     small parameter.  For example, POISSUBST(U,V,COS(V),E,3) results
     in COS(U)*(1-E^2/2) - SIN(U)*(E-E^3/6).


 - Function: POISTIMES (A, B)
     is functionally identical to INTOPOIS(A*B).


 - Function: POISTRIM ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the U,
     V,..., Z in a term.  Terms for which POISTRIM is TRUE (for the
     coefficients of that term) are eliminated during multiplication.


 - Function: PRINTPOIS (A)
     prints a Poisson series in a readable format.  In common with
     OUTOFPOIS, it will convert A into a Poisson encoding first, if
     necessary.


 - Function: PSI (X)
     derivative of LOG(GAMMA(X)).  At this time, MACSYMA does not have
     numerical evaluation capabilities for PSI.  For information on the
     PSI[N](X) notation, see POLYGAMMA.



File: maxima.info,  Node: Orthogonal Polynomials,  Next: Elliptic Functions,  Prev: Special Functions,  Up: Top

Orthogonal Polynomials
**********************

* Menu:

* Introduction to Orthogonal Polynomials::
* Definitions for Orthogonal Polynomials::


File: maxima.info,  Node: Introduction to Orthogonal Polynomials,  Next: Definitions for Orthogonal Polynomials,  Up: Orthogonal Polynomials

Introduction to Orthogonal Polynomials
======================================

   The specfun package, located in the share directory,  contains Maxima
code for the evaluation of all orthogonal polynomials listed in Chapter
22 of Abramowitz and Stegun. These include Chebyshev, Laguerre,
Hermite, Jacobi, Legendre, and ultraspherical (Gegenbauer) polynomials.
Additionally, specfun contains code for spherical Bessel, spherical
Hankel, and spherical harmonic functions.

   The following table lists each  function in specfun, its Maxima
name, restrictions on its arguments ( m  and  n  must be integers), and
a reference to the algorithm specfun uses to evaluate it.  With few
exceptions, specfun follows the conventions of Abramowitz and Stegun.
Before you use specfun, check that specfun's conventions match your
expectations.

   A&S refers to Abramowitz and Stegun, _Handbook of Mathematical
Functions_ (10th printing, December 1972), G&R to Gradshteyn and Ryzhik,
_Table of Integrals, Series, and Products_ (1980 corrected and enlarged
edition), and Merzbacher to _Quantum Mechanics_ (2ed, 1970).

_Function_         _Maxima Name_      _Restrictions_     _Reference(s)_
Chebyshev T        chebyshev_t(n, x)  n > -1             A&S 22.5.31
Chebyshev U        chebyshev_u(n, x)  n > -1             A&S 22.5.32
generalized        gen_laguerre(n,a,x)n > -1             A&S page 789
Laguerre                                                 
Laguerre           laguerre(n,x)      n > -1             A&S 22.5.67
Hermite            hermite(n,x)        n > -1            A&S 22.4.40,
                                                         22.5.41
Jacobi             jacobi_p(n,a,b,x)   n > -1, a, b >    A&S page 789
                                      -1                 
associated         assoc_legendre_p(n,m,x)n > -1             A&S 22.5.37,
Legendre P                                               8.6.6, 8.2.5
associated         assoc_legendre_q(n,m,x)n > -1, m > -1     G & R 8.706
Legendre Q                                               
Legendre P         legendre_p(n,m,x)  n > -1             A&S 22.5.35
Legendre Q         legendre_q(n,m,x)  n > -1             A&S 8.6.19
spherical Hankel   spherical_hankel1(n,n > -1             A&S 10.1.36
1st                x)                                    
spherical Hankel   spherical_hankel2(n,n > -1             A&S 10.1.17
2nd                x)                                    
spherical Bessel   spherical_bessel_j(n,x)n > -1             A&S 10.1.8,
J                                                        10.1.15
spherical Bessel   spherical_bessel_y(n,x)n > -1             A&S 10.1.9,
Y                                                        10.1.15
spherical          spherical_harmonic(n,m,x,y)n > -1, |m| <= n   Merzbacher 9.64
harmonic                                                 
ultraspherical     ultraspherical(n,a,x) n > -1            A&S 22.5.27
(Gegenbauer)                                             

   The specfun package is primarily intended for symbolic computation.
It is hoped  that it gives accurate floating point results as well;
however, no claims are made  that the algorithms are well suited for
numerical evaluation.  Some effort, however, has been made to provide
good numerical performance.  When all arguments, except for the order,
are floats (but not bfloats), many functions in specfun call a float
modedeclared version of the Jacobi function.  This  greatly speeds
floating point evaluation of the orthogonal polynomials.

   specfun handles most domain errors  by returning an unevaluated
function.  No attempt has been made to define simplification rules
(based on recursion relations) for unevaluated functions.  Users should
be aware that it is possible for an expression involving sums of
unevaluated special functions to vanish, yet Maxima is unable to reduce
it to zero.  Be careful.

   To access functions in specfun, you must first load specfun.o.
Alternatively, you may append autoload statements to your init.lsp file
(located in your working directory). To autoload  the hermite function,
for example, append
        (defprop |$hermite| #"specfun.o" autoload)
        (add2lnc '|$hermite| $props)
   to your init.lsp file.  An example use of specfun is
     (c1) load("specfun.o")$
     (c2) [hermite(0,x),hermite(1,x),hermite(2,x)];
     (d2) [1,2*x,-2*(1-2*x^2)]
     (c3) diff(hermite(n,x),x);
     (d3) 2*n*hermite(n-1,x)

   When using the compiled version of specfun, be especially careful to
use the correct number of function arguments; calling them with too
few arguments may generate a fatal error messages.  For example
     (c1) load("specfun")$
     /* chebyshev_t requires two arguments. */
     (c2) chebyshev_t(8);
     Error: Caught fatal error [memory may be damaged]
     Fast links are on: do (si::use-fast-links nil) for debugging
     Error signalled by MMAPCAR.
     Broken at SIMPLIFY.  Type :H for Help.
   Maxima code translated into Lisp handles such errors more gracefully.
If specfun.LISP is installed on your machine, the same computation
results in  a clear error message.  For example
     (c1) load("specfun.LISP")$
     (c2) chebyshev_t(8);
     Error: Expected 2 args but received 1 args
     Fast links are on: do (si::use-fast-links nil) for debugging
     Error signalled by MACSYMA-TOP-LEVEL.
     Broken at |$CHEBYSHEV_T|.  Type :H for Help.
   Generally, compiled code runs faster than translated code; however,
translated code may be better for program development.

   For some functions, when the order is symbolic but has been declared
to be an integer, specfun will return a series representation.  (The
series representation is not used by specfun for any computations.) You
may use this feature to find symbolic values for special values
orthogonal polynomials.  An example:
     (c1) load("specfun")$
     (c2) legendre_p(n,1);
     (d2)        legendre_p(n, 1)
     /* Declare n to be an integer; now legendre_p(n,1) evaluates to 1. */
     (c3) declare(n,integer)$
     (c4) legendre_p(n,1);
     (d4)        1
     (c5) ultraspherical(n,3/2,1);
     (d4)         (n+1)*gamma (n+3) / (2*gamma (n+2))
   Although the preceding example doesn't show it, two terms of the sum
are added outside the summation.  Removing these two terms avoids
errors associated with  0^0 terms in a sum that should evaluate to 1,
but evaluate to 0 in a Maxima summation. Because the sum index runs
from 1 to n - 1, the lower sum index will exceed the upper sum index
when  n = 0; setting sumhack to true provides a fix. For example:

     (c1) load("specfun.o")$
     (c2) declare(n,integer)$
     (c3) e : legendre_p(n,x)$
     (c4) ev(e,sum,n=0);
     Lower bound to SUM: 1
     is greater than the upper bound: - 1
      -- an error.  Quitting.  To debug this try DEBUGMODE(TRUE);)
     (c5) ev(e,sum,n=0),sumhack : true;
     (d5)         1

   Most  functions in specfun have a gradef property; derivatives with
respect to the order or other function parameters aren't unevaluated.

   The specfun package and its documentation were written by Barton
Willis of the University of Nebraska at Kearney. It is released under
the terms of the General Public License (GPL).  Send bug reports and
comments on this package to willisb@unk.edu.  In your  report, please
include Maxima and specfun version information.  The specfun version
may be found using get:
      (c2) get('specfun,'version);
      (d2)          110


File: maxima.info,  Node: Definitions for Orthogonal Polynomials,  Prev: Introduction to Orthogonal Polynomials,  Up: Orthogonal Polynomials

Definitions for Orthogonal Polynomials
======================================

 - Function: ASSOC_LEGENDRE_P (n, m, x)
     [specfun package] return the associated Legendre function of the
     first kind for  integers  n > -1  and  m > -1.  When  | m | > n
     and  n >= 0, we have   assoc_legendre_p (n, m, x) = 0.  Reference:
     A&S 22.5.37 page 779,  A&S 8.6.6 (second equation) page 334, and
     A&S 8.2.5 page 333.  To access this function, load("specfun").
     See *Note ASSOC_LEGENDRE_Q::, *Note LEGENDRE_P::, and *Note
     LEGENDRE_Q::.

 - Function: ASSOC_LEGENDRE_Q (n, m, x)
     [specfun package] return the associated Legendre function of the
     second kind for  integers  n > -1  and  m > -1.

     Reference: Gradshteyn and Ryzhik  8.706 page 1000.

     To access this function, load("specfun").

     See also ASSOC_LEGENDRE_P, LEGENDRE_P, and LEGENDRE_Q.

 - Function: CHEBYSHEV_T (n, x)
     [specfun package] return the Chebyshev function of the first kind
     for  integers  n > -1.

     Reference: A&S 22.5.31 page 778 and A&S 6.1.22 page 256.

     To access this function, load("specfun").

     See also CHEBYSHEV_U.


 - Function: CHEBYSHEV_U (n, x)
     [specfun package] return the Chebyshev function of the second kind
     for integers  n > -1.

     Reference: A&S, 22.8.3 page 783  and A&S 6.1.22 page 256.

     To access this function, load("specfun").

     See also CHEBYSHEV_T.


 - Function: GEN_LAGUERRE (n, a, x)
     [specfun package] return the generalized Laguerre polynomial for
     integers  n > -1.

     To access this function, load("specfun").

     Reference: table on page 789 in A&S.

 - Function: HERMITE (n,x)
     [specfun package] return the Hermite polynomial for integers  n >
     -1.

     To access this function, load("specfun").

     Reference:  A&S 22.5.40 and 22.5.41, page 779.


 - Function: JACOBI_P (n, a, b, x)
     [specfun package] return the Jacobi polynomial for integers  n >
     -1  and  a  and  b  symbolic or  a > -1  and b > -1.  (The Jacobi
     polynomials are actually defined for all  a  and  b ; however, the
     Jacobi polynomial weight  (1-x)^a(1+x)^b isn't integrable for  a
     <= -1 or  b <= -1. )

     When a, b, and  x  are floats (but not bfloats) specfun calls a
     special modedeclared version of jacobi_p.  For numerical values,
     the modedeclared version is much faster than the other version.
     Many  functions in specfun are computed as a special case of the
     Jacobi polynomials; they also enjoy the  speed boost from the
     modedeclared version of  jacobi.

     If  n  has been declared to be an integer, jacobi_p (n, a, b, x)
     returns a summation representation for the Jacobi function.
     Because Maxima simplifies 0^0  to  0  in a sum, two terms of the
     sum are added outside the summation.

     To access this function, load("specfun").

     Reference:  table on page 789 in A&S.


 - Function: LAGUERRE (n, x)
     [specfun package] return the Laguerre polynomial for integers  n >
     -1.

     Reference: A&S 22.5.16, page 778 and A&S page 789.

     To access this function, load("specfun").

     See also GEN_LAGUERRE.


 - Function: LEGENDRE_P (n, x)
     [specfun package] return the Legendre polynomial of the first kind
     for  integers  n > -1.

     Reference: A&S 22.5.35 page 779.

     To access this function, load("specfun").

     See *Note LEGENDRE_Q::.


 - Function: LEGENDRE_Q (n, x)
     [specfun package] return the Legendre polynomial of the first kind
     for  integers  n > -1.

     Reference: A&S 8.6.19 page 334.

     To access this function, load("specfun").

     See also LEGENDRE_P.


 - Function: SPHERICAL_BESSEL_J (n, x)
     [specfun package] return the spherical Bessel function of the
     first kind for  integers  n > -1.

     Reference: A&S 10.1.8 page 437 and A&S 10.1.15 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL1, SPHERICAL_HANKEL2, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_BESSEL_Y (n, x)
     [specfun package] return the spherical Bessel function of the
     second kind for  integers  n > -1.

     Reference: A&S 10.1.9 page 437 and 10.1.15 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL1, SPHERICAL_HANKEL2, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_HANKEL1 (n,x)
     [specfun package] return the spherical hankel function  of the
     first kind for  integers  n > -1.

     Reference: A&S 10.1.36 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL2, SPHERICAL_BESSEL_J, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_HANKEL2 (n,x)
     [specfun package] return the spherical hankel function  of the
     second kind for  integers  n > -1.

     Reference:  A&S 10.1.17 page 439.

     To access this function, load("specfun").

     See also SPHERICAL_HANKEL1, SPHERICAL_BESSEL_J, and
     SPHERICAL_BESSEL_Y.


 - Function: SPHERICAL_HARMONIC (n, m, x, y)
     [specfun package] return the spherical harmonic function for
     integers  n > -1 and  | m | <= n .

     Reference:  Merzbacher 9.64.

     To access this function, load("specfun").

     See also ASSOC_LEGENDRE_P


 - Function: ULTRASPHERICAL (n,a,x)
     [specfun package] return the ultraspherical polynomials for
     integers  n > -1.  The ultraspherical polynomials are also known
     as Gegenbauer polynomials.

     Reference: A&S 22.5.27

     To access this function, load("specfun").

     See also JACOBI_P.



File: maxima.info,  Node: Elliptic Functions,  Next: Limits,  Prev: Orthogonal Polynomials,  Up: Top

Elliptic Functions
******************

* Menu:

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::


File: maxima.info,  Node: Introduction to Elliptic Functions and Integrals,  Next: Definitions for Elliptic Functions,  Up: Top

Introduction to Elliptic Functions and Integrals
================================================

   Maxima includes support for Jacobian elliptic functions and for
complete and incomplete elliptic integrals.  This includes symbolic
manipulation of these functions and numerical evaluation as well.
Definitions of these functions and many of their properties can by
found in Abramowitz and Stegun, Chapter 16-17.  As much as possible, we
use the definitions and relationships given there.

   In particular, all elliptic functions and integrals use the parameter
m instead of the modulus k or the modular angle \alpha.  This is one
area where we differ from Abramowitz and Stegun who use the modular
angle for the elliptic functions.  The following relationships are true:
m = k^2 and k = \sin(\alpha)

   The elliptic functions and integrals are primarily intended to
support symbolic computation.  Therefore, most of derivatives of the
functions and integrals are known.  However, if floating-point values
are given, a floating-point result is returned.

   Support for most of the other properties of elliptic functions and
integrals other than derivatives has not yet been written.

   Some examples of elliptic functions:
     (C1) jacobi_sn(u,m);
     (D1)                            JACOBI_SN(u, m)
     (C2) jacobi_sn(u,1);
     (D2)                                TANH(u)
     (C3) jacobi_sn(u,0);
     (D3)                                SIN(u)
     (C4) diff(jacobi_sn(u,m),u);
     (D4)                    JACOBI_CN(u, m) JACOBI_DN(u, m)
     (C5) diff(jacobi_sn(u,m),m);
     (D5) JACOBI_CN(u, m) JACOBI_DN(u, m)
     
           ELLIPTIC_E(ASIN(JACOBI_SN(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m
     
                 2
        JACOBI_CN (u, m) JACOBI_SN(u, m)
      + --------------------------------
                   2 (1 - m)

   Some examples of elliptic integrals:
     (C1) elliptic_f(phi,m);
     (D1)                          ELLIPTIC_F(PHI, m)
     (C2) elliptic_f(phi,0);
     (D2)                                  PHI
     (C3) elliptic_f(phi,1);
                                           PHI   %PI
     (D3)                          LOG(TAN(--- + ---))
                                            2     4
     (C4) elliptic_e(phi,1);
     (D4)                               SIN(PHI)
     (C5) elliptic_e(phi,0);
     (D5)                                  PHI
     (C6) elliptic_kc(1/2);
                                                 1
     (D6)                            ELLIPTIC_KC(-)
                                                 2
     (C7) makegamma(%);
                                             2 1
                                        GAMMA (-)
                                               4
     (D7)                              -----------
                                       4 SQRT(%PI)
     (C8) diff(elliptic_f(phi,m),phi);
                                            1
     (D8)                         ---------------------
                                                2
                                  SQRT(1 - m SIN (PHI))
     (C9) diff(elliptic_f(phi,m),m);
           ELLIPTIC_E(PHI, m) - (1 - m) ELLIPTIC_F(PHI, m)
     (D9) (-----------------------------------------------
                                  m
     
                                 COS(PHI) SIN(PHI)
                             - ---------------------)/(2 (1 - m))
                                             2
                               SQRT(1 - m SIN (PHI))

   Support for elliptic functions and integrals was written by Raymond
Toy.  It is placed under the terms of the General Public License (GPL)
that governs the distribution of Maxima.


File: maxima.info,  Node: Definitions for Elliptic Functions,  Next: Definitions for Elliptic Integrals,  Prev: Introduction to Elliptic Functions and Integrals,  Up: Top

Definitions for Elliptic Functions
==================================

 - Function: JACOBI_SN (u, m)
     The Jacobian elliptic function sn(u,m).

 - Function: JACOBI_CN (u, m)
     The Jacobian elliptic function cn(u,m).

 - Function: JACOBI_DN (u, m)
     The Jacobian elliptic function dn(u,m).

 - Function: JACOBI_NS (u, m)
     The Jacobian elliptic function ns(u,m) = 1/sn(u,m).

 - Function: JACOBI_SC (u, m)
     The Jacobian elliptic function sc(u,m) = sn(u,m)/cn(u,m).

 - Function: JACOBI_SD (u, m)
     The Jacobian elliptic function sd(u,m) = sn(u,m)/dn(u,m).

 - Function: JACOBI_NC (u, m)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 - Function: JACOBI_CS (u, m)
     The Jacobian elliptic function cs(u,m) = cn(u,m)/sn(u,m).

 - Function: JACOBI_CD (u, m)
     The Jacobian elliptic function cd(u,m) = cn(u,m)/dn(u,m).

 - Function: JACOBI_ND (u, m)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 - Function: JACOBI_DS (u, m)
     The Jacobian elliptic function ds(u,m) = dn(u,m)/sn(u,m).

 - Function: JACOBI_DC (u, m)
     The Jacobian elliptic function dc(u,m) = dn(u,m)/cn(u,m).

 - Function: INVERSE_JACOBI_SN (u, m)
     The inverse of the Jacobian elliptic function sn(u,m).

 - Function: INVERSE_JACOBI_CN (u, m)
     The inverse of the Jacobian elliptic function cn(u,m).

 - Function: INVERSE_JACOBI_DN (u, m)
     The inverse of the Jacobian elliptic function dn(u,m).

 - Function: INVERSE_JACOBI_NS (u, m)
     The inverse of the Jacobian elliptic function ns(u,m).

 - Function: INVERSE_JACOBI_SC (u, m)
     The inverse of the Jacobian elliptic function sc(u,m).

 - Function: INVERSE_JACOBI_SD (u, m)
     The inverse of the Jacobian elliptic function sd(u,m).

 - Function: INVERSE_JACOBI_NC (u, m)
     The inverse of the Jacobian elliptic function nc(u,m).

 - Function: INVERSE_JACOBI_CS (u, m)
     The inverse of the Jacobian elliptic function cs(u,m).

 - Function: INVERSE_JACOBI_CD (u, m)
     The inverse of the Jacobian elliptic function cd(u,m).

 - Function: INVERSE_JACOBI_ND (u, m)
     The inverse of the Jacobian elliptic function nc(u,m).

 - Function: INVERSE_JACOBI_DS (u, m)
     The inverse of the Jacobian elliptic function ds(u,m).

 - Function: INVERSE_JACOBI_DC (u, m)
     The inverse of the Jacobian elliptic function dc(u,m).


File: maxima.info,  Node: Definitions for Elliptic Integrals,  Prev: Definitions for Elliptic Functions,  Up: Top

Definitions for Elliptic Integrals
==================================

 - Function: ELLIPTIC_F (phi, m)
     The incomplete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *Note ELLIPTIC_E::, *Note ELLIPTIC_KC::

 - Function: ELLIPTIC_E (phi, m)
     The incomplete elliptic integral of the second kind, defined as
     ELLIPTIC_E(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi) See
     also *Note ELLIPTIC_E::, *Note ELLIPTIC_EC::

 - Function: ELLIPTIC_EU (u, m)
     The incomplete elliptic integral of the second kind, defined as
     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     where tau = sn(u,m)

     This is related to ELLIPTIC_E by ELLIPTIC_EU(u, m) =
     ELLIPTIC_E(asin(sn(u,m)),m) See also *Note ELLIPTIC_E::.

 - Function: ELLIPTIC_PI (n, phi, m)
     The incomplete elliptic integral of the third kind, defined as
     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Only the derivative with respect to phi is known by MAXIMA.

 - Function: ELLIPTIC_KC (m)
     The complete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use MAKEGAMMA to evaluate them.

 - Function: ELLIPTIC_EC (m)
     The complete elliptic integral of the second kind, defined as

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use MAKEGAMMA to evaluate them.


File: maxima.info,  Node: Limits,  Next: Differentiation,  Prev: Elliptic Functions,  Up: Top

Limits
******

* Menu:

* Definitions for Limits::


File: maxima.info,  Node: Definitions for Limits,  Prev: Limits,  Up: Limits

Definitions for Limits
======================

 - Variable: LHOSPITALLIM
     default: [4] - the maximum number of times L'Hospital's rule is
     used in LIMIT.  This prevents infinite looping in cases like
     LIMIT(COT(X)/CSC(X),X,0).


 - Function: LIMIT (exp, var, val, dir)
     finds the limit of exp as the real variable var approaches the
     value val from the direction dir.  Dir may have the value PLUS for
     a limit from above, MINUS for a limit from below, or may be
     omitted (implying a two-sided limit is to be computed).  For the
     method see Wang, P., "Evaluation of Definite Integrals by Symbolic
     Manipulation" - Ph.D. Thesis - MAC TR-92 October 1971.  LIMIT uses
     the following special symbols: INF (positive infinity) and MINF
     (negative infinity).  On output it may also use UND (undefined),
     IND (indefinite but bounded) and INFINITY (complex infinity).
     LHOSPITALLIM[4] is the maximum number of times L'Hospital's rule
     is used in LIMIT.  This prevents infinite looping in cases like
     LIMIT(COT(X)/CSC(X),X,0).  TLIMSWITCH[FALSE] when true will cause
     the limit package to use Taylor series when possible.
     LIMSUBST[FALSE] prevents LIMIT from attempting substitutions on
     unknown forms.  This is to avoid bugs like
     LIMIT(F(N)/F(N+1),N,INF); giving 1.  Setting LIMSUBST to TRUE will
     allow such substitutions.  Since LIMIT is often called upon to
     simplify constant expressions, for example, INF-1, LIMIT may be
     used in such cases with only one argument, e.g. LIMIT(INF-1); Do
     EXAMPLE(LIMIT); for examples.


 - Function: TLIMIT (exp,var,val,dir)
     is just the function LIMIT with TLIMSWITCH set to TRUE.


 - Variable: TLIMSWITCH
     default: [FALSE] - if true will cause the limit package to use
     Taylor series when possible.



File: maxima.info,  Node: Differentiation,  Next: Integration,  Prev: Limits,  Up: Top

Differentiation
***************

* Menu:

* Definitions for Differentiation::


File: maxima.info,  Node: Definitions for Differentiation,  Prev: Differentiation,  Up: Differentiation

Definitions for Differentiation
===============================

 - Function: ANTID (G,X,U(X))
     A routine for evaluating integrals of expressions involving an
     arbitrary unspecified function and its derivatives.  It may be used
     by LOAD(ANTID); , after which, the function ANTIDIFF may be used.
     E.g.  ANTIDIFF(G,X,U(X)); where G is the expression involving U(X)
     (U(X) arbitrary) and its derivatives, whose integral with respect
     to X is desired.  The functions NONZEROANDFREEOF and LINEAR are
     also defined, as well as ANTID.  ANTID is the same as ANTIDIFF
     except that it returns a list of two parts, the first part is the
     integrated part of the expression and the second part of the list
     is the non-integrable remainder.


 - Function: ANTIDIFF -
     See ANTID.


 - property: ATOMGRAD
     - the atomic gradient property of an expression.  May be set by
     GRADEF.


 - Function: ATVALUE (form, list, value)
     enables the user to assign the boundary value value to form at the
     points specified by list.
          (C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2)$
              The form must be a function, f(v1,v2,...), or a derivative,
     DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in which the functional
     arguments explicitly appear (ni is the order of differentiation
     with respect vi).      The list of equations determine the
     "boundary" at which the value is given; list may be a list of
     equations, as above, or a single equation, vi = expr.      The
     symbols @1, @2,... will be used to represent the functional
     variables v1,v2,... when atvalues are displayed.
     PRINTPROPS([f1, f2,...], ATVALUE) will display the atvalues of the
     functions f1,f2,... as specified in previously given uses of the
     ATVALUE function. If the list contains just one element then the
     element can be given without being in a list.  If a first argument
     of ALL is given then atvalues for all functions which have them
     will be displayed.  Do EXAMPLE(ATVALUE); for an example.


 - Function: CARTAN -
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     present implementation is due to F.B. Estabrook and H.D. Wahlquist.
     The program is self-explanatory and can be accessed by doing
     batch("cartan"); which will give a description with examples.


 - Function: DEL (v)
     This is the differential of the variable v.  This commonly occurs
     when DIFF is called without the dependent variable being given.
     Then the differential of the expression is computed.  For example:
          (C1) diff(x);
          
          (D1) 				    DEL(x)
          (C2) diff(x^2);
          
          (D2) 				  2 x DEL(x)
          (C3) diff(sin(x^2));
          
          				       2
          (D3) 			      2 x COS(x ) DEL(x)


 - Function: DELTA (t)
     This is the Dirac Delta function.  Currently only LAPLACE knows
     about the DELTA function:
          (C1) LAPLACE(DELTA(T-A)*SIN(B*T),T,S);
          Is A positive, negative or zero?
          POS;
                                                    - A S
          (D1)                           SIN(A B) %E

 - Variable: DEPENDENCIES
     default: [] - the list of atoms which have functional dependencies
     (set up by the DEPENDS or GRADEF functions).  The command
     DEPENDENCIES has been replaced by the DEPENDS command.  Do
     DESCRIBE(DEPENDS);


 - Function: DEPENDS (funlist1,varlist1,funlist2,varlist2,...)
     declares functional dependencies for variables to be used by DIFF.

          DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T)
     informs DIFF that F and G depend on X and Y, that R and S depend
     on U,V, and W, and that U depends on T.  The arguments to DEPENDS
     are evaluated.  The variables in each funlist are declared to
     depend on all the variables in the next varlist.  A funlist can
     contain the name of an atomic variable or array.  In the latter
     case, it is assumed that all the elements of the array depend on
     all the variables in the succeeding varlist.  Initially, DIFF(F,X)
     is 0; executing DEPENDS(F,X) causes future differentiations of F
     with respect to X to give dF/dX or Y (if DERIVABBREV:TRUE).
          (C1) DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T);
          (D1)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
          (C2) DEPENDENCIES;
          (D2)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
          (C3) DIFF(R.S,U);
                                         dR           dS
          (D3)                           -- . S + R . --
                                         dU           dU
     Since MACSYMA knows the chain rule for symbolic derivatives, it
     takes advantage of the given dependencies as follows:
          (C4) DIFF(R.S,T);
                                     dR dU             dS dU
          (D4)                      (-- --) . S + R . (-- --)
                                     dU dT             dU dT
          If we set
          (C5) DERIVABBREV:TRUE;
          (D5)                                 TRUE
          then re-executing the command C4, we obtain
          (C6) ''C4;
          (D6)                      (R  U ) . S + R . (S  U )
                                      U  T              U  T
     To eliminate a previously declared dependency, the REMOVE command
     can be used.  For example, to say that R no longer depends on U as
     declared in C1, the user can type
          REMOVE(R,DEPENDENCY)
     This will eliminate all dependencies that may have been declared
     for R.
          (C7) REMOVE(R,DEPENDENCY);
          (D7)                                 DONE
          (C8) ''C4;
          (D8)                             R . (S  U )
                                            U    T
     CAVEAT: DIFF is the only MACSYMA command which uses DEPENDENCIES
     information.  The arguments to INTEGRATE, LAPLACE, etc. must be
     given their dependencies explicitly in the command, e.g.,
     INTEGRATE(F(X),X).


 - Variable: DERIVABBREV
     default: [FALSE] if TRUE will cause derivatives to display as
     subscripts.


 - Function: DERIVDEGREE (exp, dv, iv)
     finds the highest degree of the derivative of the dependent
     variable dv with respect to the independent variable iv occuring
     in exp.
          (C1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X**2$
          (C2) DERIVDEGREE(%,Y,X);
          (D2)                           2

 - Function: DERIVLIST (var1,...,vark)
     causes only differentiations with respect to the indicated
     variables, within the EV command.


 - Variable: DERIVSUBST
     default: [FALSE] - controls non-syntactic substitutions such as
          SUBST(X,'DIFF(Y,T),'DIFF(Y,T,2));
     If DERIVSUBST is set to true, this gives 'DIFF(X,T).


 - Function: DIFF (exp, v1, n1, v2, n2, ...)
     DIFF differentiates exp with respect to each vi, ni times.  If
     just the first derivative with respect to one variable is desired
     then the form DIFF(exp,v) may be used.  If the noun form of the
     function is required (as, for example, when writing a differential
     equation), 'DIFF should be used and this will display in a two
     dimensional format.  DERIVABBREV[FALSE] if TRUE will cause
     derivatives to display as subscripts.  DIFF(exp) gives the "total
     differential", that is, the sum of the derivatives of exp with
     respect to each of its variables times the function DEL of the
     variable.  No further simplification of DEL is offered.
          (C1) DIFF(EXP(F(X)),X,2);
                                       2
                                F(X)  d             F(X)  d         2
          (D1)                %E     (--- F(X)) + %E     (-- (F(X)))
                                        2                 dX
                                      dX
          (C2) DERIVABBREV:TRUE$
          (C3) 'INTEGRATE(F(X,Y),Y,G(X),H(X));
                                          H(X)
                                         /
                                         [
          (D3)                           I     F(X, Y) dY
                                         ]
                                         /
                                          G(X)
          (C4) DIFF(%,X);
                      H(X)
                     /
                     [
          (D4)       I     F(X, Y)  dY + F(X, H(X)) H(X)  - F(X, G(X)) G(X)
                     ]            X                     X                  X
                     /
                      G(X)
     For the tensor package, the following modifications have been
     incorporated: 1) the derivatives of any indexed objects in exp
     will have the variables vi appended as additional arguments.  Then
     all the derivative indices will be sorted.  2) the vi may be
     integers from 1 up to the value of the variable DIMENSION[default
     value: 4].  This will cause the differentiation to be carried out
     wrt the vith member of the list COORDINATES which should be set to
     a list of the names of the coordinates, e.g., [x,y,z,t]. If
     COORDINATES is bound to an atomic variable, then that variable
     subscripted by vi will be used for the variable of
     differentiation.  This permits an array of coordinate names or
     subscripted names like X[1], X[2],... to be used.  If COORDINATES
     has not been assigned a value, then the variables will be treated
     as in 1) above.


 - special symbol: DIFF
     [flag] for ev causes all differentiations indicated in exp to be
     performed.

 - Function: DSCALAR (function)
     applies the scalar d'Alembertian to the scalar function.
          (C41) DEPENDENCIES(FIELD(R));
          (D41)                           [FIELD(R)]
          (C42) DSCALAR(FIELD);
          (D43)
              -M
            %E  ((FIELD  N - FIELD  M + 2 FIELD   ) R + 4 FIELD )
                       R  R       R  R         R R             R
          
          - -----------------------------------------------------
                                       2 R

 - Function: EXPRESS (expression)
     The result uses the noun form of any derivatives arising from
     expansion of the vector differential operators.  To force
     evaluation of these derivatives, the built-in EV function can be
     used together with the DIFF evflag, after using the built-in
     DEPENDS function to establish any new implicit dependencies.


 - Function: GENDIFF
     Sometimes DIFF(E,X,N) can be reduced even though N is symbolic.
          batch("gendif")$
     and you can try, for example,

          DIFF(%E^(A*X),X,Q)
     by using GENDIFF rather than DIFF.  Unevaluable items come out
     quoted.  Some items are in terms of "GENFACT", which see.


 - Function: GRADEF (f(x1, ..., xn), g1, ..., gn)
     defines the derivatives of the function f with respect to its n
     arguments.  That is, df/dxi = gi, etc.  If fewer than n gradients,
     say i, are given, then they refer to the first i arguments of f.
     The xi are merely dummy variables as in function definition
     headers and are used to indicate the ith argument of f.  All
     arguments to GRADEF except the first are evaluated so that if g is
     a defined function then it is invoked and the result is used.
     Gradients are needed when, for example, a function is not known
     explicitly but its first derivatives are and it is desired to
     obtain higher order derivatives.  GRADEF may also be used to
     redefine the derivatives of MACSYMA's predefined functions (e.g.
     GRADEF(SIN(X),SQRT(1-SIN(X)**2)) ).  It is not permissible to use
     GRADEF on subscripted functions.  GRADEFS is a list of the
     functions which have been given gradients by use of the GRADEF
     command (i.e. GRADEF(f(x1, ..., xn), g1, ..., gn)).
     PRINTPROPS([f1,f2,...],GRADEF) may be used to display the gradefs
     of the functions f1,f2,..  GRADEF(a,v,exp) may be used to state
     that the derivative of the atomic variable a with respect to v is
     exp.  This automatically does a DEPENDS(a,v).
     PRINTPROPS([a1,a2,...],ATOMGRAD) may be used to display the atomic
     gradient properties of a1,a2,...


 - Variable: GRADEFS
     default: [] - a list of the functions which have been given
     gradients by use of the GRADEF command (i.e. GRADEF(f(x1, ..., xn),
     g1, ..., gn).)


 - Function: LAPLACE (exp, ovar, lvar)
     takes the Laplace transform of exp with respect to the variable
     ovar and transform parameter lvar.  Exp may only involve the
     functions EXP, LOG, SIN, COS, SINH, COSH, and ERF.  It may also be
     a linear, constant coefficient differential equation in which case
     ATVALUE of the dependent variable will be used.  These may be
     supplied either before or after the transform is taken.  Since the
     initial conditions must be specified at zero, if one has boundary
     conditions imposed elsewhere he can impose these on the general
     solution and eliminate the constants by solving the general
     solution for them and substituting their values back. Exp may also
     involve convolution integrals.  Functional relationships must be
     explicitly represented in order for LAPLACE to work properly. That
     is, if F depends on X and Y it must be written as F(X,Y) wherever
     F occurs as in LAPLACE('DIFF(F(X,Y),X),X,S).  LAPLACE is not
     affected by DEPENDENCIES set up with the DEPENDS command.
          (C1) LAPLACE(%E**(2*T+A)*SIN(T)*T,T,S);
                               A
                           2 %E  (S - 2)
          (D1)            ---------------
                                  2     2
                          ((S - 2)  + 1)

 - Function: UNDIFF (exp)
     returns an expression equivalent to exp but with all derivatives
     of indexed objects replaced by the noun form of the DIFF function
     with arguments which would yield that indexed object if the
     differentiation were carried out.  This is useful when it is
     desired to replace a differentiated indexed object with some
     function definition and then carry out the differentiation by
     saying EV(...,DIFF).



File: maxima.info,  Node: Integration,  Next: Equations,  Prev: Differentiation,  Up: Top

Integration
***********

* Menu:

* Introduction to Integration::
* Definitions for Integration::


File: maxima.info,  Node: Introduction to Integration,  Next: Definitions for Integration,  Prev: Integration,  Up: Integration

Introduction to Integration
===========================

   MACSYMA has several routines for handling integration.  The
INTEGRATE command makes use of most of them.  There is also the ANTID
package, which handles an unspecified function (and its derivatives, of
course).  For numerical uses, there is the ROMBERG function.  There is
also an adaptave integrator which uses the Newton-Cotes 8 panel
quadrature rule, called QUANC8.  Hypergeometric Functions are being
worked on, do DESCRIBE(SPECINT); for details.  Generally speaking,
MACSYMA only handles integrals which are integrable in terms of the
"elementary functions" (rational functions, trigonometrics, logs,
exponentials, radicals, etc.) and a few extensions (error function,
dilogarithm).  It does not handle integrals in terms of unknown
functions such as g(x) and h(x).

