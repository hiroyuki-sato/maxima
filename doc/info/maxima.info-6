This is maxima.info, produced by makeinfo version 4.5 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynomials

Definitions for Polynomials
===========================

 - Variable: ALGEBRAIC
     default: [FALSE] must be set to TRUE in order for the
     simplification of algebraic integers to take effect.

 - Variable: BERLEFACT
     default: [TRUE] if FALSE then the Kronecker factoring algorithm
     will be used otherwise the Berlekamp algorithm, which is the
     default, will be used.


 - Function: BEZOUT (p1, p2, var)
     an alternative to the RESULTANT command.  It returns a matrix.
     DETERMINANT of this matrix is the desired resultant.


 - Function: BOTHCOEF (exp, var)
     returns a list whose first member is the coefficient of var in exp
     (as found by RATCOEF if exp is in CRE form otherwise by COEFF) and
     whose second member is the remaining part of exp.  That is, [A,B]
     where exp=A*var+B.
          (%i1) ISLINEAR(EXP,VAR):=BLOCK([C],
                  C:BOTHCOEF(RAT(EXP,VAR),VAR),
                  IS(FREEOF(VAR,C) AND C[1]#0))$
          (%i2) ISLINEAR((R**2-(X-R)**2)/X,X);
          (%o2)                              TRUE

 - Function: COEFF (exp, v, n)
     obtains the coefficient of v**n in exp.  n may be omitted if it is
     1.  v may be an atom, or complete subexpression of exp e.g., X,
     SIN(X), A[I+1], X+Y, etc. (In the last case the expression (X+Y)
     should occur in exp).  Sometimes it may be necessary to expand or
     factor exp in order to make v^n explicit.  This is not done
     automatically by COEFF.
          (%i1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));
          (%o1)                         2 A + 1 = 5
          (%i2) COEFF(Y+X*%E**X+1,X,0);
          (%o2)                            Y + 1

 - Function: COMBINE (exp)
     simplifies the sum exp by combining terms with the same
     denominator into a single term.


 - Function: CONTENT (p1, var1, ..., varn)
     returns a list whose first element is the greatest common divisor
     of the coefficients of the terms of the polynomial p1 in the
     variable varn (this is the content) and whose second element is
     the polynomial p1 divided by the content.
          (%i1) CONTENT(2*X*Y+4*X**2*Y**2,Y);
          (%o1)            [2*X, 2*X*Y**2+Y].

 - Function: DENOM (exp)
     returns the denominator of the rational expression exp.


 - Function: DIVIDE (p1, p2, var1, ..., varn)
     computes the quotient and remainder of the polynomial p1 divided
     by the polynomial p2, in a main polynomial variable, varn.  The
     other variables are as in the RATVARS function.  The result is a
     list whose first element is the quotient and whose second element
     is the remainder.
          (%i1) DIVIDE(X+Y,X-Y,X);
          (%o1)                        [1, 2 Y]
          (%i2) DIVIDE(X+Y,X-Y);
          (%o2)                      [ - 1, 2 X]

     (Note that Y is the main variable in %i2)


 - Function: ELIMINATE ([eq1,eq2,...,eqn],[v1,v2,...,vk])
     eliminates variables from equations (or expressions assumed equal
     to zero) by taking successive resultants. This returns a list of
     n-k expressions with the k variables v1,...,vk eliminated.  First
     v1 is eliminated yielding n-1 expressions, then v2 is, etc.  If
     k=n then a single expression in a list is returned free of the
     variables v1,...,vk.  In this case SOLVE is called to solve the
     last resultant for the last variable.  Example:
          (%i1) EXP1:2*X^2+Y*X+Z;
                                              2
          (%o1)                   Z + X Y + 2 X
          (%i2) EXP2:3*X+5*Y-Z-1;
          (%o2)                - Z + 5 Y + 3 X - 1
          (%i3) EXP3:Z^2+X-Y^2+5;
                                 2    2
          (%o3)                  Z  - Y  + X + 5
          (%i4) ELIMINATE([EXP3,EXP2,EXP1],[Y,Z]);
                      8         7         6          5          4
          (%o3) [7425 X  - 1170 X  + 1299 X  + 12076 X  + 22887 X
                                         3         2
                                 - 5154 X  - 1291 X  + 7688 X + 15376]

 - Function: EZGCD (p1, p2, ...)
     gives a list whose first element is the g.c.d of the polynomials
     p1,p2,...  and whose remaining elements are the polynomials
     divided by the g.c.d.  This always uses the EZGCD algorithm.


 - Variable: FACEXPAND
     default: [TRUE] controls whether the irreducible factors returned
     by FACTOR are in expanded (the default) or recursive (normal CRE)
     form.


 - Function: FACTCOMB (exp)
     tries to combine the coefficients of factorials in exp with the
     factorials themselves by converting, for example, (N+1)*N!  into
     (N+1)!.  SUMSPLITFACT[TRUE] if set to FALSE will cause
     MINFACTORIAL to be applied after a FACTCOMB.
          (%i1) (N+1)^B*N!^B;
                                                B   B
          (%o1)                           (N + 1)  N!
          (%i2) FACTCOMB(%);

 - Function: FACTOR (exp)
     factors the expression exp, containing any number of variables or
     functions, into factors irreducible over the integers.
     FACTOR(exp, p) factors exp over the field of integers with an
     element adjoined whose minimum polynomial is p.  FACTORFLAG[FALSE]
     if FALSE suppresses the factoring of integer factors of rational
     expressions.  DONTFACTOR may be set to a list of variables with
     respect to which factoring is not to occur.  (It is initially
     empty).  Factoring also will not take place with respect to any
     variables which are less important (using the variable ordering
     assumed for CRE form) than those on the DONTFACTOR list.
     SAVEFACTORS[FALSE] if TRUE causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.  BERLEFACT[TRUE] if FALSE then the
     Kronecker factoring algorithm will be used otherwise the Berlekamp
     algorithm, which is the default, will be used.  INTFACLIM[1000] is
     the largest divisor which will be tried when factoring a bignum
     integer.  If set to FALSE (this is the case when the user calls
     FACTOR explicitly), or if the integer is a fixnum (i.e.  fits in
     one machine word), complete factorization of the integer will be
     attempted.  The user's setting of INTFACLIM is used for internal
     calls to FACTOR. Thus, INTFACLIM may be reset to prevent MACSYMA
     from taking an inordinately long time factoring large integers.
     NEWFAC[FALSE] may be set to true to use the new factoring routines.
     Do EXAMPLE(FACTOR); for examples.


 - Variable: FACTORFLAG
     default: [FALSE] if FALSE suppresses the factoring of integer
     factors of rational expressions.


 - Function: FACTOROUT (exp,var1,var2,...)
     rearranges the sum exp into a sum of terms of the form
     f(var1,var2,...)*g where g is a product of expressions not
     containing the vari's and f is factored.


 - Function: FACTORSUM (exp)
     tries to group terms in factors of exp which are sums into groups
     of terms such that their sum is factorable.  It can recover the
     result of EXPAND((X+Y)^2+(Z+W)^2) but it can't recover
     EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.
          (%i1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;
                2      2                            2      2
          (%o1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X
                               2        2    2            2
                  + 2 U V X + U  X + A W  + V  + 2 U V + U
          (%i2) FACTORSUM(%);
                                             2          2
          (%o2)                 (X + 1) (A (Z + W)  + (V + U) )

 - Function: FASTTIMES (p1, p2)
     multiplies the polynomials p1 and p2 by using a special algorithm
     for multiplication of polynomials.  They should be multivariate,
     dense, and nearly the same size.  Classical multiplication is of
     order N*M where N and M are the degrees.  FASTTIMES is of order
     MAX(N,M)**1.585.


 - Function: FULLRATSIMP (exp)
     When non-rational expressions are involved, one call to RATSIMP
     followed as is usual by non-rational ("general") simplification
     may not be sufficient to return a simplified result.  Sometimes,
     more than one such call may be necessary.  The command FULLRATSIMP
     makes this process convenient.  FULLRATSIMP repeatedly applies
     RATSIMP followed by non-rational simplification to an expression
     until no further change occurs.  For example, consider For the
     expression  EXP:   (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1) .
     RATSIMP(EXP); gives (X^(2*A)-2*X^A+1)/(X^A-1) .  FULLRATSIMP(EXP);
     gives   X^A-1 .  The problem may be seen by looking at RAT(EXP);
     which gives  ((X^(A/2))^4-2*(X^(A/2))^2+1)/(X^A-1) .
     FULLRATSIMP(exp,var1,...,varn) takes one or more arguments similar
     to RATSIMP and RAT.


 - Function: FULLRATSUBST (a,b,c)
     is the same as RATSUBST except that it calls itself recursively on
     its result until that result stops changing.  This function is
     useful when the replacement expression and the replaced expression
     have one or more variables in common.  FULLRATSUBST will also
     accept its arguments in the format of LRATSUBST.  That is, the
     first argument may be a single substitution equation or a list of
     such equations, while the second argument is the expression being
     processed.  There is a demo available by DEMO("lrats.dem"); .


 - Function: GCD (p1, p2, var1, ...)
     computes the greatest common divisor of p1 and p2.  The flag
     GCD[SPMOD] determines which algorithm is employed.  Setting GCD to
     EZ, EEZ, SUBRES, RED, or SPMOD selects the EZGCD, New EEZ GCD,
     subresultant PRS, reduced, or modular algorithm, respectively.  If
     GCD:FALSE then GCD(p1,p2,var) will always return 1 for all var.
     Many functions (e.g.  RATSIMP, FACTOR, etc.) cause gcd's to be
     taken implicitly.  For homogeneous polynomials it is recommended
     that GCD:SUBRES be used.  To take the gcd when an algebraic is
     present, e.g. GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , ALGEBRAIC must be
     TRUE and GCD must not be EZ.  SUBRES is a new algorithm, and people
     who have been using the RED setting should probably change it to
     SUBRES.  The GCD flag, default: [SPMOD], if FALSE will also
     prevent the greatest common divisor from being taken when
     expressions are converted to CRE form.  This will sometimes speed
     the calculation if gcds are not required.


 - Function: GCDEX (f,g)
 - Function: GCDEX (f,g,var)
     returns a list containing [a,b,u] where u is the gcd of f and g,
     and u = a*f + b*g.   The arguments f and g should b univariate
     polynomials, or else polynomials in VAR a supplied main variable
     since we need to be in a principal ideal domain for this to work.
     The gcd means the gcd regarding f and g as univariate polynomials
     with coefficients being rational functions in the other variables.

     The algorithm is simply the euclidean algorithm, where we have a
     sequence of `lis[i]:[a[i],b[i],r[i]] ..' which are all
     perpendicular to `[f,g,-1]' and the next one is built as if `q =
     quotient(r[i]/r[i+1])' then `lis[i+2]:lis[i]-q*lis[i+1]', and it
     terminates at `lis[i+1]' when the remainder `r[i+2]' is zero.
          (%i1) gcdex(x^2+1,x^3+4);
          
                                        2
                                       x  + 4 x - 1  x + 4
          (%o1)/R/                   [- ------------, -----, 1]
                                            17        17
          
          (%i2) %o1.[x^2+1,x^3+4,-1];
          (%o2)                                   0

     note that the gcd in the following is `1' since we work in
     `k(y)[x]', not the  `y+1' we would expect in `k[y,x] '

          (%i4) gcdex(x*(y+1),y^2-1,x);
          
                                                1
          (%o4)                            [0, ------, 1]
                                               2
                                              y  - 1


 - Function: GCFACTOR (n)
     factors the gaussian integer n over the gaussians, i.e.  numbers
     of the form a + b i where a and b are rational integers (i.e.
     ordinary integers).  Factors are normalized by making a and b
     non-negative.


 - Function: GFACTOR (exp)
     factors the polynomial exp over the Gaussian integers (i.  e.
     with SQRT(-1) = %I adjoined).  This is like FACTOR(exp,A**2+1)
     where A is %I.
          (%i1)  GFACTOR(X**4-1);
          (%o1)        (X - 1) (X + 1) (X + %I) (X - %I)

 - Function: GFACTORSUM (exp)
     is similar to FACTORSUM but applies GFACTOR instead of FACTOR.


 - Function: HIPOW (exp, v)
     the highest explicit exponent of v in exp.  Sometimes it may be
     necessary to expand exp since this is not done automatically by
     HIPOW.  Thus HIPOW(Y**3*X**2+X*Y**4,X) is 2.


 - Variable: INTFACLIM
     default: [1000] is the largest divisor which will be tried when
     factoring a bignum integer.  If set to FALSE (this is the case
     when the user calls FACTOR explicitly), or if the integer is a
     fixnum (i.e. fits in one machine word), complete factorization of
     the integer will be attempted.  The user's setting of INTFACLIM is
     used for internal calls to FACTOR. Thus, INTFACLIM may be reset to
     prevent MACSYMA from taking an inordinately long time factoring
     large integers.


 - Variable: KEEPFLOAT
     default: [FALSE] - if set to TRUE will prevent floating point
     numbers from being rationalized when expressions which contain
     them are converted to CRE form.


 - Function: LRATSUBST (list,exp)
     is analogous to SUBST(list_of_equations,exp) except that it uses
     RATSUBST instead of SUBST.  The first argument of LRATSUBST must
     be an equation or a list of equations identical in format to that
     accepted by SUBST (see DESCRIBE(SUBST);).  The substitutions are
     made in the order given by the list of equations, that is, from
     left to right.  A demo is available by doing DEMO("lrats.dem"); .


 - Variable: MODULUS
     default: [FALSE] - if set to a positive prime p, then all
     arithmetic in the rational function routines will be done modulo p.
     That is all integers will be reduced to less than p/2 in absolute
     value (if p=2 then all integers are reduced to 1 or 0).  This is
     the so called "balanced" modulus system, e.g. N MOD 5 = -2, -1, 0,
     1, or 2.  Warning: If EXP is already in CRE form when you reset
     MODULUS, then you may need to re-rat EXP, e.g.
     EXP:RAT(RATDISREP(EXP)), in order to get correct results. (If
     MODULUS is set to a positive non-prime integer, this setting will
     be accepted, but a warning will be given.)


 - Variable: NEWFAC
     default: [FALSE], if TRUE then FACTOR will use the new factoring
     routines.


 - Function: NUM (exp)
     obtains the numerator, exp1, of the rational expression exp =
     exp1/exp2.


 - Function: QUOTIENT (p1, p2, var1, ...)
     computes the quotient of the polynomial p1 divided by the
     polynomial p2.


 - Function: RAT (exp, v1, ..., vn)
     converts exp to CRE form by expanding and combining all terms over
     a common denominator and cancelling out the greatest common
     divisor of the numerator and denominator as well as converting
     floating point numbers to rational numbers within a tolerance of
     RATEPSILON[2.0E-8].  The variables are ordered according to the
     v1,...,vn as in RATVARS, if these are specified.  RAT does not
     generally simplify functions other than + , - , * , / , and
     exponentiation to an integer power whereas RATSIMP does handle
     these cases.  Note that atoms (numbers and names) in CRE form are
     not the same as they are in the general form.  Thus RAT(X)- X
     results in RAT(0) which has a different internal representation
     than 0.  RATFAC[FALSE] when TRUE invokes a partially factored form
     for CRE rational expressions.  During rational operations the
     expression is maintained as fully factored as possible without an
     actual call to the factor package.  This should always save space
     and may save some time in some computations.  The numerator and
     denominator are still made relatively prime (e.g.  RAT((X^2
     -1)^4/(X+1)^2); yields (X-1)^4*(X+1)^2), but the factors within
     each part may not be relatively prime.  RATPRINT[TRUE] if FALSE
     suppresses the printout of the message informing the user of the
     conversion of floating point numbers to rational numbers.
     KEEPFLOAT[FALSE] if TRUE prevents floating point numbers from being
     converted to rational numbers.  (Also see the RATEXPAND and
     RATSIMP functions.)
          (%i1) ((X-2*Y)**4/(X**2-4*Y**2)**2+1)*(Y+A)*(2*Y+X)
                  /(4*Y**2+X**2);
                                                     4
                                            (X - 2 Y)
                        (Y + A) (2 Y + X) (------------ + 1)
                                             2      2 2
                                           (X  - 4 Y )
          (%o1)          ------------------------------------
                                        2    2
                                     4 Y  + X
          (%i2) RAT(%,Y,A,X);
                                      2 A + 2 Y
          (%o2)/R/                     ---------
                                       X + 2 Y

 - Variable: RATALGDENOM
     default: [TRUE] - if TRUE allows rationalization of denominators
     wrt.  radicals to take effect.  To do this one must use CRE form
     in algebraic mode.


 - Function: RATCOEF (exp, v, n)
     returns the coefficient, C, of the expression v**n in the
     expression exp.  n may be omitted if it is 1.  C will be free
     (except possibly in a non-rational sense) of the variables in v.
     If no coefficient of this type exists, zero will be returned.
     RATCOEF expands and rationally simplifies its first argument and
     thus it may produce answers different from those of COEFF which is
     purely syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y
     whereas COEFF returns 1.  RATCOEF(exp,v,0), viewing exp as a sum,
     gives a sum of those terms which do not contain v.  Therefore if v
     occurs to any negative powers, RATCOEF should not be used.  Since
     exp is rationally simplified before it is examined, coefficients
     may not appear quite the way they were envisioned.
          (%i1) S:A*X+B*X+5$
          (%i2) RATCOEF(S,A+B);
          (%o2)               X

 - Function: RATDENOM (exp)
     obtains the denominator of the rational expression exp.  If exp is
     in general form then the DENOM function should be used instead,
     unless one wishes to get a CRE result.


 - Variable: RATDENOMDIVIDE
     default: [TRUE] - if FALSE will stop the splitting up of the terms
     of the numerator of RATEXPANDed expressions from occurring.


 - Function: RATDIFF (exp, var)
     differentiates the rational expression exp (which must be a ratio
     of polynomials or a polynomial in the variable var) with respect
     to var.  For rational expressions this is much faster than DIFF.
     The result is left in CRE form.  However, RATDIFF should not be
     used on factored CRE forms; use DIFF instead for such expressions.
          (%i1) (4*X**3+10*X-11)/(X**5+5);
                                                   3
                                                4 X  + 10 X - 11
          (%o1)                                  ----------------
                                                      5
                                                     X
          (%i2) MODULUS:3$
          (%i3) MOD(%o1);
                                          2
                                         X  + X - 1
          (%o3)                      --------------------
                                     4    3    2
                                    X  + X  + X  + X + 1
          (%i4) RATDIFF(%o1,X);
                                    5    4    3
                                   X  - X  - X  + X - 1
          (%o4)                ------------------------------
                               8    7    5    4    3
                              X  - X  + X  - X  + X  - X + 1

 - Function: RATDISREP (exp)
     changes its argument from CRE form to general form.  This is
     sometimes convenient if one wishes to stop the "contagion", or use
     rational functions in non-rational contexts.  Most CRE functions
     will work on either CRE or non-CRE expressions, but the answers may
     take different forms.  If RATDISREP is given a non-CRE for an
     argument, it returns its argument unchanged.  See also TOTALDISREP.


 - Variable: RATEPSILON
     default: [2.0E-8] - the tolerance used in the conversion of
     floating point numbers to rational numbers.


 - Function: RATEXPAND (exp)
     expands exp by multiplying out products of sums and exponentiated
     sums, combining fractions over a common denominator, cancelling
     the greatest common divisor of the numerator and denominator, then
     splitting the numerator (if a sum) into its respective terms
     divided by the denominator.  This is accomplished by converting
     exp to CRE form and then back to general form.  The switch
     RATEXPAND, default: [FALSE], if TRUE will cause CRE expressions to
     be fully expanded when they are converted back to general form or
     displayed, while if it is FALSE then they will be put into a
     recursive form. (see RATSIMP) RATDENOMDIVIDE[TRUE] - if FALSE will
     stop the splitting up of the terms of the numerator of RATEXPANDed
     expressions from occurring.  KEEPFLOAT[FALSE] if set to TRUE will
     prevent floating point numbers from being rationalized when
     expressions which contain them are converted to CRE form.
          (%i1) RATEXPAND((2*X-3*Y)**3);
                          3         2       2        3
          (%o1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X
          (%i2) (X-1)/(X+1)**2+1/(X-1);
                                        X - 1       1
          (%o2)                         -------- + -----
                                              2   X - 1
                                       (X + 1)
          (%i3) EXPAND(%o2);
                                   X              1           1
          (%o3)                ------------ - ------------ + -----
                               2              2             X - 1
                              X  + 2 X + 1   X  + 2 X + 1
          (%i4) RATEXPAND(%o2);
                                       2
                                    2 X                 2
          (%o4)                 --------------- + ---------------
                                3    2            3    2
                               X  + X  - X - 1   X  + X  - X - 1

 - Variable: RATFAC
     default: [FALSE] - when TRUE invokes a partially factored form for
     CRE rational expressions.  During rational operations the
     expression is maintained as fully factored as possible without an
     actual call to the factor package.  This should always save space
     and may save some time in some computations.  The numerator and
     denominator are still made relatively prime, for example RAT((X^2
     -1)^4/(X+1)^2);  yields (X-1)^4*(X+1)^2), but the factors within
     each part may not be relatively prime.  In the CTENSR (Component
     Tensor Manipulation) Package, if RATFAC is TRUE, it causes the
     Ricci, Einstein, Riemann, and Weyl tensors and the Scalar
     Curvature to be factored automatically.  ** This should only be
     set for cases where the tensorial components are known to consist
     of few terms **.  Note: The RATFAC and RATWEIGHT schemes are
     incompatible and may not both be used at the same time.


 - Function: RATNUMER (exp)
     obtains the numerator of the rational expression exp.  If exp is
     in general form then the NUM function should be used instead,
     unless one wishes to get a CRE result.


 - Function: RATNUMP (exp)
     is TRUE if exp is a rational number (includes integers) else FALSE.


 - Function: RATP (exp)
     is TRUE if exp is in CRE or extended CRE form else FALSE.


 - Variable: RATPRINT
     default: [TRUE] - if FALSE suppresses the printout of the message
     informing the user of the conversion of floating point numbers to
     rational numbers.


 - Function: RATSIMP (exp)
     rationally" simplifies (similar to RATEXPAND) the expression exp
     and all of its subexpressions including the arguments to non-
     rational functions.  The result is returned as the quotient of two
     polynomials in a recursive form, i.e.  the coefficients of the
     main variable are polynomials in the other variables.  Variables
     may, as in RATEXPAND, include non-rational functions (e.g.
     SIN(X**2+1) ) but with RATSIMP, the arguments to non-rational
     functions are rationally simplified.  Note that RATSIMP is
     affected by some of the variables which affect RATEXPAND.
     RATSIMP(exp,v1,v2,...,vn) - enables rational simplification with
     the specification of variable ordering as in RATVARS.
     RATSIMPEXPONS[FALSE] - if TRUE will cause exponents of expressions
     to be RATSIMPed automatically during simplification.
          (%i1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);
                                                     2          2
                              X          (LOG(X) + 1)  - LOG (X)
          (%o1)          SIN(------) = %E
                             2
                            X  + X
          (%i2) RATSIMP(%);
                                            1          2
          (%o2)                        SIN(-----) = %E X
                                          X + 1
          (%i3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));
                                 3/2
                          (X - 1)    - SQRT(X - 1) (X + 1)
          (%o3)            --------------------------------
                              SQRT(X - 1) SQRT(X + 1)
          (%i4) RATSIMP(%);
                                           2
          (%o4)                      - -----------
                                      SQRT(X + 1)
          (%i5)  X**(A+1/A),RATSIMPEXPONS:TRUE;
                              2
                             A  + 1
                             ------
                               A
          (%o5)              X

 - Variable: RATSIMPEXPONS
     default: [FALSE] - if TRUE will cause exponents of expressions to
     be RATSIMPed automatically during simplification.


 - Function: RATSUBST (a, b, c)
     substitutes a for b in c.  b may be a sum, product, power, etc.
     RATSUBST knows something of the meaning of expressions whereas
     SUBST does a purely syntactic substitution.  Thus
     SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas RATSUBST would return Z+A.
     RADSUBSTFLAG[FALSE] if TRUE permits RATSUBST to make substitutions
     like U for SQRT(X) in X.  Do EXAMPLE(RATSUBST); for examples.


 - Function: RATVARS (var1, var2, ..., varn)
     forms its n arguments into a list in which the rightmost variable
     varn will be the main variable of future rational expressions in
     which it occurs, and the other variables will follow in sequence.
     If a variable is missing from the RATVARS list, it will be given
     lower priority than the leftmost variable var1. The arguments to
     RATVARS can be either variables or non-rational functions (e.g.
     SIN(X)).  The variable RATVARS is a list of the arguments which
     have been given to this function.


 - Function: RATWEIGHT (v1, w1, ..., vn, wn)
     assigns a weight of wi to the variable vi.  This causes a term to
     be replaced by 0 if its weight exceeds the value of the variable
     RATWTLVL [default is FALSE which means no truncation].  The weight
     of a term is the sum of the products of the weight of a variable
     in the term times its power.  Thus the weight of 3*v1**2*v2 is
     2*w1+w2.  This truncation occurs only when multiplying or
     exponentiating CRE forms of expressions.
          (%i5) RATWEIGHT(A,1,B,1);
          (%o5)                         [[B, 1], [A, 1]]
          (%i6) EXP1:RAT(A+B+1)$
          (%i7) %**2;
                                2                  2
          (%o7)/R/              B  + (2 A + 2) B + A  + 2 A + 1
          (%i8) RATWTLVL:1$
          (%i9) EXP1**2;
          (%o9)/R/                       2 B + 2 A + 1
     Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
     both be used at the same time.


 - Variable: RATWEIGHTS
     - a list of weight assignments (set up by the RATWEIGHT function),
     RATWEIGHTS; or RATWEIGHT(); will show you the list.

          KILL(...,RATWEIGHTS)
     and
          SAVE(...,RATWEIGHTS);
     both work.


 - Variable: RATWEYL
     default: [] - one of the switches controlling the simplification
     of components of the Weyl conformal tensor; if TRUE, then the
     components will be rationally simplified; if FACRAT is TRUE then
     the results will be factored as well.


 - Variable: RATWTLVL
     default: [FALSE] - used in combination with the RATWEIGHT function
     to control the truncation of rational (CRE form) expressions (for
     the default value of FALSE, no truncation occurs).


 - Function: REMAINDER (p1, p2, var1, ...)
     computes the remainder of the polynomial p1 divided by the
     polynomial p2.


 - Function: RESULTANT (p1, p2, var)
     computes the resultant of the two polynomials p1 and p2,
     eliminating the variable var.  The resultant is a determinant of
     the coefficients of var in p1 and p2 which equals zero if and only
     if p1 and p2 have a non-constant factor in common.  If p1 or p2
     can be factored, it may be desirable to call FACTOR before calling
     RESULTANT.  RESULTANT[SUBRES] - controls which algorithm will be
     used to compute the resultant.  SUBRES for subresultant prs [the
     default], MOD for modular resultant algorithm, and RED for reduced
     prs.  On most problems SUBRES should be best.  On some large
     degree univariate or bivariate problems MOD may be better.
     Another alternative is the BEZOUT command which takes the same
     arguments as RESULTANT and returns a matrix.  DETERMINANT of this
     matrix is the desired resultant.


 - Variable: SAVEFACTORS
     default: [FALSE] - if TRUE causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.


 - Function: SQFR (exp)
     is similar to FACTOR except that the polynomial factors are
     "square-free." That is, they have factors only of degree one.  This
     algorithm, which is also used by the first stage of FACTOR,
     utilizes the fact that a polynomial has in common with its nth
     derivative all its factors of degree > n.  Thus by taking gcds
     with the polynomial of the derivatives with respect to each
     variable in the polynomial, all factors of degree > 1 can be found.
          (%i1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);
                                       2               2
          (%o1)                       (X  - 1) (2 X + 1)

 - Function: TELLRAT (poly)
     adds to the ring of algebraic integers known to MACSYMA, the
     element which is the solution of the polynomial with integer
     coefficients.  MACSYMA initially knows about %I and all roots of
     integers. TELLRAT(X); means substitute 0 for X in rational
     functions.  There is a command UNTELLRAT which takes kernels and
     removes TELLRAT properties.  When TELLRATing a multivariate
     polynomial, e.g. TELLRAT(X^2-Y^2);, there would be an ambiguity as
     to whether to substitute Y^2 for X^2 or vice versa.  The system
     will pick a particular ordering, but if the user wants to specify
     which, e.g.  TELLRAT(Y^2=X^2); provides a syntax which says
     replace Y^2 by X^2.  TELLRAT and UNTELLRAT both can take any
     number of arguments, and TELLRAT(); returns a list of the current
     substitutions.  Note: When you TELLRAT reducible polynomials, you
     want to be careful not to attempt to rationalize a denominator
     with a zero divisor.  E.g.  TELLRAT(W^3-1)$ ALGEBRAIC:TRUE$
     RAT(1/(W^2-W)); will give "quotient by zero".  This error can be
     avoided by setting RATALGDENOM:FALSE$.  ALGEBRAIC[FALSE] must be
     set to TRUE in order for the simplification of algebraic integers
     to take effect.  Do EXAMPLE(TELLRAT); for examples.


 - Function: TOTALDISREP (exp)
     converts every subexpression of exp from CRE to general form.  If
     exp is itself in CRE form then this is identical to RATDISREP but
     if not then RATDISREP would return exp unchanged while TOTALDISREP
     would "totally disrep" it.  This is useful for ratdisrepping
     expressions e.g., equations, lists, matrices, etc. which have some
     subexpressions in CRE form.


 - Function: UNTELLRAT (x)
     takes kernels and removes TELLRAT properties.



File: maxima.info,  Node: Constants,  Next: Logarithms,  Prev: Polynomials,  Up: Top

Constants
*********

* Menu:

* Definitions for Constants::


File: maxima.info,  Node: Definitions for Constants,  Prev: Constants,  Up: Constants

Definitions for Constants
=========================

 - Variable: E
     - The base of natural logarithms, e, is represented in MACSYMA as
     %E.


 - Variable: FALSE
     - the Boolean constant, false. (NIL in LISP)


 - Variable: MINF
     - real minus infinity.


 - Variable: PI
     - "pi" is represented in MACSYMA as %PI.


 - Variable: TRUE
     - the Boolean constant, true. (T in LISP)



File: maxima.info,  Node: Logarithms,  Next: Trigonometric,  Prev: Constants,  Up: Top

Logarithms
**********

* Menu:

* Definitions for Logarithms::


File: maxima.info,  Node: Definitions for Logarithms,  Prev: Logarithms,  Up: Logarithms

Definitions for Logarithms
==========================

 - Function: LOG (X)
     the natural logarithm.

     LOGEXPAND[TRUE] - causes LOG(A^B) to become B*LOG(A).  If it is set
     to ALL, LOG(A*B) will also simplify to LOG(A)+LOG(B).  If it is
     set to SUPER, then LOG(A/B) will also simplify to LOG(A)-LOG(B)
     for rational numbers a/b, a#1.  (LOG(1/B), for B integer, always
     simplifies.)  If it is set to FALSE, all of these simplifications
     will be turned off.

     LOGSIMP[TRUE] - if FALSE then no simplification of %E to a power
     containing LOG's is done.

     LOGNUMER[FALSE] - if TRUE then negative floating point arguments to
     LOG will always be converted to their absolute value before the
     log is taken.  If NUMER is also TRUE, then negative integer
     arguments to LOG will also be converted to their absolute value.

     LOGNEGINT[FALSE] - if TRUE implements the rule LOG(-n) ->
     LOG(n)+%i*%pi for n a positive integer.

     %E_TO_NUMLOG[FALSE] - when TRUE, "r" some rational number, and "x"
     some expression, %E^(r*LOG(x)) will be simplified into x^r .  It
     should be noted that the RADCAN command also does this
     transformation, and more complicated transformations of this ilk
     as well.  The LOGCONTRACT command "contracts" expressions
     containing LOG.


 - Variable: LOGABS
     default: [FALSE] - when doing indefinite integration where logs
     are generated, e.g. INTEGRATE(1/X,X), the answer is given in terms
     of LOG(ABS(...)) if LOGABS is TRUE, but in terms of LOG(...) if
     LOGABS is FALSE.  For definite integration, the LOGABS:TRUE
     setting is used, because here "evaluation" of the indefinite
     integral at the endpoints is often needed.


 - Variable: LOGARC
     default: [FALSE] - if TRUE will cause the inverse circular and
     hyperbolic functions to be converted into logarithmic form.
     LOGARC(exp) will cause this conversion for a particular expression
     without setting the switch or having to re-evaluate the expression
     with EV.


 - Variable: LOGCONCOEFFP
     default:[FALSE] - controls which coefficients are contracted when
     using LOGCONTRACT.  It may be set to the name of a predicate
     function of one argument.  E.g. if you like to generate SQRTs, you
     can do LOGCONCOEFFP:'LOGCONFUN$ LOGCONFUN(M):=FEATUREP(M,INTEGER)
     OR RATNUMP(M)$ .  Then LOGCONTRACT(1/2*LOG(X)); will give
     LOG(SQRT(X)).


 - Function: LOGCONTRACT (exp)
     recursively scans an exp, transforming subexpressions of the form
     a1*LOG(b1) + a2*LOG(b2) + c into LOG(RATSIMP(b1^a1 * b2^a2)) + c
          (%i1) 2*(A*LOG(X) + 2*A*LOG(Y))$
          (%i2) LOGCONTRACT(%);
                                                  2  4
          (%o3)                             A LOG(X  Y )
     If you do DECLARE(N,INTEGER); then LOGCONTRACT(2*A*N*LOG(X)); gives
     A*LOG(X^(2*N)).  The coefficients that "contract" in this manner
     are those such as the 2 and the N here which satisfy
     FEATUREP(coeff,INTEGER).  The user can control which coefficients
     are contracted by setting the option LOGCONCOEFFP[FALSE] to the
     name of a predicate function of one argument.  E.g. if you like to
     generate SQRTs, you can do LOGCONCOEFFP:'LOGCONFUN$
     LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$ .  Then
     LOGCONTRACT(1/2*LOG(X)); will give LOG(SQRT(X)).


 - Variable: LOGEXPAND
     default: [TRUE] - causes LOG(A^B) to become B*LOG(A).  If it is
     set to ALL, LOG(A*B) will also simplify to LOG(A)+LOG(B).  If it
     is set to SUPER, then LOG(A/B) will also simplify to LOG(A)-LOG(B)
     for rational numbers a/b, a#1.  (LOG(1/B), for B integer, always
     simplifies.)  If it is set to FALSE, all of these simplifications
     will be turned off.


 - Variable: LOGNEGINT
     default: [FALSE] - if TRUE implements the rule LOG(-n) ->
     LOG(n)+%i*%pi   for n a positive integer.


 - Variable: LOGNUMER
     default: [FALSE] - if TRUE then negative floating point arguments
     to LOG will always be converted to their absolute value before the
     log is taken.  If NUMER is also TRUE, then negative integer
     arguments to LOG will also be converted to their absolute value.


 - Variable: LOGSIMP
     default: [TRUE] - if FALSE then no simplification of %E to a power
     containing LOG's is done.


 - Function: PLOG (X)
     the principal branch of the complex-valued natural logarithm with
     -%PI < CARG(X) <= +%PI .


 - Function: POLARFORM (exp)
     returns R*%E^(%I*THETA) where R and THETA are purely real.



File: maxima.info,  Node: Trigonometric,  Next: Special Functions,  Prev: Logarithms,  Up: Top

Trigonometric
*************

* Menu:

* Introduction to Trigonometric::
* Definitions for Trigonometric::


File: maxima.info,  Node: Introduction to Trigonometric,  Next: Definitions for Trigonometric,  Prev: Trigonometric,  Up: Trigonometric

Introduction to Trigonometric
=============================

   - MACSYMA has many Trig functions defined.  Not all Trig identities
are programmed, but it is possible for the user to add many of them
using the pattern matching capabilities of the system.  The Trig
functions defined in MACSYMA are: ACOS, ACOSH, ACOT, ACOTH, ACSC,
ACSCH, ASEC, ASECH, ASIN, ASINH, ATAN, ATANH, COS, COSH, COT, COTH,
CSC, CSCH, SEC, SECH, SIN, SINH, TAN, and TANH.  There are a number of
commands especially for handling Trig functions, see TRIGEXPAND,
TRIGREDUCE, and the switch TRIGSIGN.  Two SHARE packages extend the
simplification rules built into MACSYMA, NTRIG and ATRIG1.  Do
DESCRIBE(cmd) for details.


File: maxima.info,  Node: Definitions for Trigonometric,  Prev: Introduction to Trigonometric,  Up: Trigonometric

Definitions for Trigonometric
=============================

 - Function: ACOS
     - Arc Cosine


 - Function: ACOSH
     - Hyperbolic Arc Cosine


 - Function: ACOT
     - Arc Cotangent


 - Function: ACOTH
     - Hyperbolic Arc Cotangent


 - Function: ACSC
     - Arc Cosecant


 - Function: ACSCH
     - Hyperbolic Arc Cosecant


 - Function: ASEC
     - Arc Secant


 - Function: ASECH
     - Hyperbolic Arc Secant


 - Function: ASIN
     - Arc Sine


 - Function: ASINH
     - Hyperbolic Arc Sine


 - Function: ATAN
     - Arc Tangent


 - Function: ATAN2 (Y,X)
     yields the value of ATAN(Y/X) in the interval -%PI to %PI.


 - Function: ATANH
     - Hyperbolic Arc Tangent


 - Function: ATRIG1
     - SHARE1;ATRIG1 FASL contains several additional simplification
     rules for inverse trig functions.  Together with rules already
     known to Macsyma, the following angles are fully implemented: 0,
     %PI/6, %PI/4, %PI/3, and %PI/2.  Corresponding angles in the other
     three quadrants are also available.  Do LOAD(ATRIG1); to use them.


 - Function: COS
     - Cosine


 - Function: COSH
     - Hyperbolic Cosine


 - Function: COT
     - Cotangent


 - Function: COTH
     - Hyperbolic Cotangent


 - Function: CSC
     - Cosecant


 - Function: CSCH
     - Hyperbolic Cosecant


 - Variable: HALFANGLES
     default: [FALSE] - if TRUE causes half-angles to be simplified
     away.


 - Function: SEC
     - Secant


 - Function: SECH
     - Hyperbolic Secant


 - Function: SIN
     - Sine


 - Function: SINH
     - Hyperbolic Sine


 - Function: TAN
     - Tangent


 - Function: TANH
     - Hyperbolic Tangent


 - Function: TRIGEXPAND (exp)
     expands trigonometric and hyperbolic functions of sums of angles
     and of multiple angles occurring in exp.  For best results, exp
     should be expanded.  To enhance user control of simplification,
     this function expands only one level at a time, expanding sums of
     angles or multiple angles.  To obtain full expansion into sines
     and cosines immediately, set the switch TRIGEXPAND:TRUE.
     TRIGEXPAND default: [FALSE] - if TRUE causes expansion of all
     expressions containing SINs and COSs occurring subsequently.
     HALFANGLES[FALSE] - if TRUE causes half-angles to be simplified
     away.  TRIGEXPANDPLUS[TRUE] - controls the "sum" rule for
     TRIGEXPAND, expansion of sums (e.g. SIN(X+Y)) will take place only
     if TRIGEXPANDPLUS is TRUE.  TRIGEXPANDTIMES[TRUE] - controls the
     "product" rule for TRIGEXPAND, expansion of products (e.g.
     SIN(2*X)) will take place only if TRIGEXPANDTIMES is TRUE.
          (%i1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;
                                        2           2
          (%o1)                     - SIN (X) + 3 COS (X) + X
          (%i2) TRIGEXPAND(SIN(10*X+Y));
          (%o2)               COS(10 X) SIN(Y) + SIN(10 X) COS(Y)

 - Variable: TRIGEXPANDPLUS
     default: [TRUE] - controls the "sum" rule for TRIGEXPAND.  Thus,
     when the TRIGEXPAND command is used or the TRIGEXPAND switch set
     to TRUE, expansion of sums (e.g. SIN(X+Y)) will take place only if
     TRIGEXPANDPLUS is TRUE.


 - Variable: TRIGEXPANDTIMES
     default: [TRUE] - controls the "product" rule for TRIGEXPAND.
     Thus, when the TRIGEXPAND command is used or the TRIGEXPAND switch
     set to TRUE, expansion of products (e.g. SIN(2*X)) will take place
     only if TRIGEXPANDTIMES is TRUE.


 - Variable: TRIGINVERSES
     default: [ALL] - controls the simplification of the composition of
     trig and hyperbolic functions with their inverse functions: If
     ALL, both e.g. ATAN(TAN(X)) and TAN(ATAN(X)) simplify to X.  If
     TRUE, the arcfunction(function(x)) simplification is turned off.
     If FALSE, both the arcfun(fun(x)) and fun(arcfun(x))
     simplifications are turned off.


 - Function: TRIGREDUCE (exp, var)
     combines products and powers of trigonometric and hyperbolic SINs
     and COSs of var into those of multiples of var.  It also tries to
     eliminate these functions when they occur in denominators.  If var
     is omitted then all variables in exp are used.  Also see the
     POISSIMP function (6.6).
          (%i4) TRIGREDUCE(-SIN(X)^2+3*COS(X)^2+X);
          (%o4)                        2 COS(2 X) + X + 1
          The trigonometric simplification routines will use declared
          information in some simple cases.  Declarations about variables are
          used as follows, e.g.
          (%i5) DECLARE(J, INTEGER, E, EVEN, O, ODD)$
          (%i6) SIN(X + (E + 1/2)*%PI)$
          (%o6)                      COS(X)
          (%i7) SIN(X + (O + 1/2) %PI);
          (%o7)                     - COS(X)

 - Variable: TRIGSIGN
     default: [TRUE] - if TRUE permits simplification of negative
     arguments to trigonometric functions. E.g., SIN(-X) will become
     -SIN(X) only if TRIGSIGN is TRUE.


 - Function: TRIGSIMP (expr)
     employs the identities sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 to simplify expressions containing tan, sec, etc. to
     sin, cos, sinh, cosh so that further simplification may be
     obtained by using TRIGREDUCE on the result.  Some examples may be
     seen by doing DEMO("trgsmp.dem"); .  See also the TRIGSUM function.


 - Function: TRIGRAT (trigexp)
     gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; trigexp is a rational fraction of several sin, cos or
     tan, the arguments of them are linear forms in some variables (or
     kernels) and %pi/n (n integer) with integer coefficients. The
     result is a simplifyed fraction with numerator and denominator
     linear in sin and cos.  Thus TRIGRAT linearize always when it is
     possible.(written by D. Lazard).

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          
          (%o1) 		        sqrt(3) sin(2 a) + cos(2 a) - 1

     Here is another example (for which the function was intended); see
     [Davenport, Siret, Tournier, Calcul Formel, Masson (or in english,
     Addison-Wesley), section 1.5.5, Morley theorem). Timings are on
     VAX 780.

          (%i4)   c:%pi/3-a-b;
          
          					   %pi
          (%o4) 				 - b - a + ---
          					    3
          
          (%i5)   bc:sin(a)*sin(3*c)/sin(a+b);
          
          			     sin(a) sin(3 b + 3 a)
          (%o5) 			     ---------------------
          				  sin(b + a)
          
          (%i6)   ba:bc,c=a,a=c$
          
          (%i7)   ac2:ba^2+bc^2-2*bc*ba*cos(b);
          
          	2       2
               sin (a) sin (3 b + 3 a)
          (%o7) -----------------------
          	      2
          	   sin (b + a)
          
          					%pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
          					 3
           - --------------------------------------------------------
          			   %pi
          		   sin(a - ---) sin(b + a)
          			    3
          
                2	        2	  %pi
             sin (3 a) sin (b + a - ---)
          			   3
           + ---------------------------
          	     2	   %pi
          	  sin (a - ---)
          		    3
          
          (%i9)   trigrat(ac2);
          Totaltime= 65866 msec.  GCtime= 7716 msec.
          
          (%o9)
          - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
          
          - 2 sqrt(3) sin(4 b + 2 a)
          
          + 2 cos(4 b + 2 a) - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
          
          + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
          
          + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
          
          + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
          
             - 9)/4


File: maxima.info,  Node: Special Functions,  Next: Orthogonal Polynomials,  Prev: Trigonometric,  Up: Top

Special Functions
*****************

* Menu:

* Introduction to Special Functions::
* GAMALG::
* SPECINT::
* Definitions for Special Functions::


File: maxima.info,  Node: Introduction to Special Functions,  Next: GAMALG,  Prev: Special Functions,  Up: Special Functions

Introduction to Special Functions
=================================

 - %J:
     [index](expr) - Bessel Funct 1st Kind (in SPECINT)


 - %K: [index](expr)
     Bessel Funct 2nd Kind (in SPECINT)

     Constant, in ODE2



File: maxima.info,  Node: GAMALG,  Next: SPECINT,  Prev: Introduction to Special Functions,  Up: Special Functions

GAMALG
======

   - A Dirac gamma matrix algebra program which takes traces of and
does manipulations on gamma matrices in n dimensions.  It may be loaded
into MACSYMA by LOADFILE("gam"); A preliminary manual is contained in
the file SHARE;GAM USAGE and may be printed using
PRINTFILE(GAM,USAGE,SHARE);

