This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Introduction to itensor,  Next: Definitions for itensor,  Prev: itensor,  Up: itensor

28.1 Introduction to itensor
============================

Maxima implements symbolic tensor manipulation of two distinct types:
component tensor manipulation (`ctensor' package) and indicial tensor
manipulation (`itensor' package).

   Nota bene: Please see the note on 'new tensor notation' below.

   Component tensor manipulation means that geometrical tensor objects
are represented as arrays or matrices. Tensor operations such as
contraction or covariant differentiation are carried out by actually
summing over repeated (dummy) indices with `do' statements.  That is,
one explicitly performs operations on the appropriate tensor components
stored in an array or matrix.

   Indicial tensor manipulation is implemented by representing tensors
as functions of their covariant, contravariant and derivative indices.
Tensor operations such as contraction or covariant differentiation are
performed by manipulating the indices themselves rather than the
components to which they correspond.

   These two approaches to the treatment of differential, algebraic and
analytic processes in the context of Riemannian geometry have various
advantages and disadvantages which reveal themselves only through the
particular nature and difficulty of the user's problem.  However, one
should keep in mind the following characteristics of the two
implementations:

   The representation of tensors and tensor operations explicitly in
terms of their components makes `ctensor' easy to use. Specification of
the metric and the computation of the induced tensors and invariants is
straightforward. Although all of Maxima's powerful simplification
capacity is at hand, a complex metric with intricate functional and
coordinate dependencies can easily lead to expressions whose size is
excessive and whose structure is hidden. In addition, many calculations
involve intermediate expressions which swell causing programs to
terminate before completion. Through experience, a user can avoid many
of these difficulties.

   Because of the special way in which tensors and tensor operations
are represented in terms of symbolic operations on their indices,
expressions which in the component representation would be unmanageable
can sometimes be greatly simplified by using the special routines for
symmetrical objects in `itensor'. In this way the structure of a large
expression may be more transparent. On the other hand, because of the
the special indicial representation in `itensor', in some cases the
user may find difficulty with the specification of the metric, function
definition, and the evaluation of differentiated "indexed" objects.

28.1.1 New tensor notation
--------------------------

Until now, the `itensor' package in Maxima has used a notation that
sometimes led to incorrect index ordering. Consider the following, for
instance:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   This result is incorrect unless `a' happens to be a symmetric tensor.
The reason why this happens is that although `itensor' correctly
maintains the order within the set of covariant and contravariant
indices, once an index is raised or lowered, its position relative to
the other set of indices is lost.

   To avoid this problem, a new notation has been developed that
remains fully compatible with the existing notation and can be used
interchangeably. In this notation, contravariant indices are inserted
in the appropriate positions in the covariant index list, but with a
minus sign prepended.  Functions like `contract' and `ishow' are now
aware of this new index notation and can process tensors appropriately.

   In this new notation, the previous example yields a correct result:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   Presently, the only code that makes use of this notation is the
`lc2kdt' function. Through this notation, it achieves consistent
results as it applies the metric tensor to resolve Levi-Civita symbols
without resorting to numeric indices.

   Since this code is brand new, it probably contains bugs. While it
has been tested to make sure that it doesn't break anything using the
"old" tensor notation, there is a considerable chance that "new"
tensors will fail to interoperate with certain functions or features.
These bugs will be fixed as they are encountered... until then, caveat
emptor!

28.1.2 Indicial tensor manipulation
-----------------------------------

The indicial tensor manipulation package may be loaded by
`load(itensor)'. Demos are also available: try `demo(tensor)'.

   In `itensor' a tensor is represented as an "indexed object" .  This
is a function of 3 groups of indices which represent the covariant,
contravariant and derivative indices.  The covariant indices are
specified by a list as the first argument to the indexed object, and
the contravariant indices by a list as the second argument. If the
indexed object lacks either of these groups of indices then the empty
list `[]' is given as the corresponding argument.  Thus, `g([a,b],[c])'
represents an indexed object called `g' which has two covariant indices
`(a,b)', one contravariant index (`c') and no derivative indices.

   The derivative indices, if they are present, are appended as
additional arguments to the symbolic function representing the tensor.
They can be explicitly specified by the user or be created in the
process of differentiation with respect to some coordinate variable.
Since ordinary differentiation is commutative, the derivative indices
are sorted alphanumerically, unless `iframe_flag' is set to `true',
indicating that a frame metric is being used. This canonical ordering
makes it possible for Maxima to recognize that, for example,
`t([a],[b],i,j)' is the same as `t([a],[b],j,i)'.  Differentiation of
an indexed object with respect to some coordinate whose index does not
appear as an argument to the indexed object would normally yield zero.
This is because Maxima would not know that the tensor represented by
the indexed object might depend implicitly on the corresponding
coordinate.  By modifying the existing Maxima function `diff' in
`itensor', Maxima now assumes that all indexed objects depend on any
variable of differentiation unless otherwise stated.  This makes it
possible for the summation convention to be extended to derivative
indices. It should be noted that `itensor' does not possess the
capabilities of raising derivative indices, and so they are always
treated as covariant.

   The following functions are available in the tensor package for
manipulating indexed objects.  At present, with respect to the
simplification routines, it is assumed that indexed objects do not by
default possess symmetry properties. This can be overridden by setting
the variable `allsym[false]' to `true', which will result in treating
all indexed objects completely symmetric in their lists of covariant
indices and symmetric in their lists of contravariant indices.

   The `itensor' package generally treats tensors as opaque objects.
Tensorial equations are manipulated based on algebraic rules,
specifically symmetry and contraction rules. In addition, the `itensor'
package understands covariant differentiation, curvature, and torsion.
Calculations can be performed relative to a metric of moving frame,
depending on the setting of the `iframe_flag' variable.

   A sample session below demonstrates how to load the `itensor'
package, specify the name of the metric, and perform some simple
calculations.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Definitions for itensor,  Prev: Introduction to itensor,  Up: itensor

28.2 Definitions for itensor
============================

28.2.1 Managing indexed objects
-------------------------------

 -- Function: entertensor (<name>)
     is a function which, by prompting, allows one to create an indexed
     object called <name> with any number of tensorial and derivative
     indices. Either a single index or a list of indices (which may be
     null) is acceptable input (see the example under `covdiff').


 -- Function: changename (<old>, <new>, <expr>)
     will change the name of all indexed objects called <old> to <new>
     in <expr>. <old> may be either a symbol or a list of the form
     `[<name>, <m>, <n>]' in which case only those indexed objects
     called <name> with <m> covariant and <n> contravariant indices
     will be renamed to <new>.


 -- Function: listoftens
     Lists all tensors in a tensorial expression, complete with their
     indices. E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Function: ishow (<expr>)
     displays <expr> with the indexed objects in it shown having their
     covariant indices as subscripts and contravariant indices as
     superscripts. The derivative indices are displayed as subscripts,
     separated from the covariant indices by a comma (see the examples
     throughout this document).


 -- Function: indices (<expr>)
     Returns a list of two elements.  The first is a list of the free
     indices in <expr> (those that occur only once). The second is the
     list of the dummy indices in <expr> (those that occur exactly
     twice) as the following example demonstrates.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     A tensor product containing the same index more than twice is
     syntactically illegal. `indices' attempts to deal with these
     expressions in a reasonable manner; however, when it is called to
     operate upon such an illegal expression, its behavior should be
     considered undefined.


 -- Function: rename (<expr>)
 -- Function: rename (<expr>, <count>)
     Returns an expression equivalent to <expr> but with the dummy
     indices in each term chosen from the set `[%1, %2,...]', if the
     optional second argument is omitted. Otherwise, the dummy indices
     are indexed beginning at the value of <count>.  Each dummy index
     in a product will be different. For a sum, `rename' will operate
     upon each term in the sum resetting the counter with each term. In
     this way `rename' can serve as a tensorial simplifier. In
     addition, the indices will be sorted alphanumerically (if `allsym'
     is `true') with respect to covariant or contravariant indices
     depending upon the value of `flipflag'.  If `flipflag' is `false'
     then the indices will be renamed according to the order of the
     contravariant indices. If `flipflag' is `true' the renaming will
     occur according to the order of the covariant indices. It often
     happens that the combined effect of the two renamings will reduce
     an expression more than either one by itself.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7


 -- Option variable: flipflag
     Default: `false'. If `false' then the indices will be renamed
     according to the order of the contravariant indices, otherwise
     according to the order of the covariant indices.

     If `flipflag' is `false' then `rename' forms a list of the
     contravariant indices as they are encountered from left to right
     (if `true' then of the covariant indices). The first dummy index
     in the list is renamed to `%1', the next to `%2', etc.  Then
     sorting occurs after the `rename'-ing (see the example under
     `rename').


 -- Function: defcon (<tensor_1>)
 -- Function: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     gives <tensor_1> the property that the contraction of a product of
     <tensor_1> and <tensor_2> results in <tensor_3> with the
     appropriate indices.  If only one argument, <tensor_1>, is given,
     then the contraction of the product of <tensor_1> with any indexed
     object having the appropriate indices (say `my_tensor') will yield
     an indexed object with that name, i.e. `my_tensor', and with a new
     set of indices reflecting the contractions performed.      For
     example, if `imetric:g', then `defcon(g)' will implement the
     raising and lowering of indices through contraction with the metric
     tensor.      More than one `defcon' can be given for the same
     indexed object; the latest one given which applies in a particular
     contraction will be used.  `contractions' is a list of those
     indexed objects which have been given contraction properties with
     `defcon'.


 -- Function: remcon (<tensor_1>, ..., <tensor_n>)
 -- Function: remcon (all)
     removes all the contraction properties from the <tensor_1>, ...,
     <tensor_n>). `remcon(all)' removes all contraction properties from
     all indexed objects.


 -- Function: contract (<expr>)
     Carries out the tensorial contractions in <expr> which may be any
     combination of sums and products. This function uses the
     information given to the `defcon' function. For best results,
     `expr' should be fully expanded. `ratexpand' is the fastest way to
     expand products and powers of sums if there are no variables in
     the denominators of the terms. The `gcd' switch should be `false'
     if GCD cancellations are unnecessary.


 -- Function: indexed_tensor (<tensor>)
     Must be executed before assigning components to a <tensor> for
     which a built in value already exists as with `ichr1', `ichr2',
     `icurvature'. See the example under `icurvature'.


 -- Function: components (<tensor>, <expr>)
     permits one to assign an indicial value to an expression <expr>
     giving the values of the components of <tensor>. These are
     automatically substituted for the tensor whenever it occurs with
     all of its indices. The tensor must be of the form `t([...],[...])'
     where either list may be empty. <expr> can be any indexed
     expression involving other objects with the same free indices as
     <tensor>. When used to assign values to the metric tensor wherein
     the components contain dummy indices one must be careful to define
     these indices to avoid the generation of multiple dummy indices.
     Removal of this assignment is given to the function `remcomps'.

     It is important to keep in mind that `components' cares only about
     the valence of a tensor, not about any particular index ordering.
     Thus assigning components to, say, `x([i,-j],[])', `x([-j,i],[])',
     or `x([i],[j])' all produce the same result, namely components
     being assigned to a tensor named `x' with valence `(1,1)'.

     Components can be assigned to an indexed expression in four ways,
     two of which involve the use of the `components' command:

     1) As an indexed expression. For instance:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) As a matrix:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) As a function. You can use a Maxima function to specify the
     components of a tensor based on its indices. For instance, the
     following code assigns `kdelta' to `h' if `h' has the same number
     of covariant and contravariant indices and no derivative indices,
     and `g' otherwise:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Using Maxima's pattern matching capabilities, specifically the
     `defrule' and `applyb1' commands:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Function: remcomps (<tensor>)
     Unbinds all values from <tensor> which were assigned with the
     `components' function.


 -- Function: showcomps (<tensor>)
     Shows component assignments of a tensor, as made using the
     `components' command. This function can be particularly useful
     when a matrix is assigned to an indicial tensor using
     `components', as demonstrated by the following example:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     The `showcomps' command can also display components of a tensor of
     rank higher than 2.


 -- Function: idummy ()
     Increments `icounter' and returns as its value an index of the form
     `%n' where n is a positive integer.  This guarantees that dummy
     indices which are needed in forming expressions will not conflict
     with indices already in use (see the example under `indices').


 -- Option variable: idummyx
     Default value: `%'

     Is the prefix for dummy indices (see the example under `indices').


 -- Option variable: icounter
     Default value: `1'

     Determines the numerical suffix to be used in generating the next
     dummy index in the tensor package.  The prefix is determined by
     the option `idummy' (default: `%').

 -- Function: kdelta (<L1>, <L2>)
     is the generalized Kronecker delta function defined in the
     `itensor' package with <L1> the list of covariant indices and <L2>
     the list of contravariant indices.  `kdelta([i],[j])' returns the
     ordinary Kronecker delta.  The command `ev(<expr>,kdelta)' causes
     the evaluation of an expression containing `kdelta([],[])' to the
     dimension of the manifold.

     In what amounts to an abuse of this notation, `itensor' also allows
     `kdelta' to have 2 covariant and no contravariant, or 2
     contravariant and no covariant indices, in effect providing a
     co(ntra)variant "unit matrix" capability. This is strictly
     considered a programming aid and not meant to imply that
     `kdelta([i,j],[])' is a valid tensorial object.


 -- Function: kdels (<L1>, <L2>)
     Symmetricized Kronecker delta, used in some calculations. For
     instance:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Function: levi_civita (<L>)
     is the permutation (or Levi-Civita) tensor which yields 1 if the
     list <L> consists of an even permutation of integers, -1 if it
     consists of an odd permutation, and 0 if some indices in <L> are
     repeated.


 -- Function: lc2kdt (<expr>)
     Simplifies expressions containing the Levi-Civita symbol,
     converting these to Kronecker-delta expressions when possible. The
     main difference between this function and simply evaluating the
     Levi-Civita symbol is that direct evaluation often results in
     Kronecker expressions containing numerical indices. This is often
     undesirable as it prevents further simplification.  The `lc2kdt'
     function avoids this problem, yielding expressions that are more
     easily simplified with `rename' or `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     The `lc2kdt' function sometimes makes use of the metric tensor.
     If the metric tensor was not defined previously with `imetric',
     this results in an error.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g


 -- Function: lc_l
     Simplification rule used for expressions containing the
     unevaluated Levi-Civita symbol (`levi_civita'). Along with `lc_u',
     it can be used to simplify many expressions more efficiently than
     the evaluation of `levi_civita'.  For example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0


 -- Function: lc_u
     Simplification rule used for expressions containing the
     unevaluated Levi-Civita symbol (`levi_civita'). Along with `lc_u',
     it can be used to simplify many expressions more efficiently than
     the evaluation of `levi_civita'.  For details, see `lc_l'.


 -- Function: canten (<expr>)
     Simplifies <expr> by renaming (see `rename') and permuting dummy
     indices. `rename' is restricted to sums of tensor products in
     which no derivatives are present. As such it is limited and should
     only be used if `canform' is not capable of carrying out the
     required simplification.

     The `canten' function returns a mathematically correct result only
     if its argument is an expression that is fully symmetric in its
     indices.  For this reason, `canten' returns an error if `allsym'
     is not set to `true'.


 -- Function: concan (<expr>)
     Similar to `canten' but also performs index contraction.


28.2.2 Tensor symmetries
------------------------

 -- Option variable: allsym
     Default: `false'. if `true' then all indexed objects are assumed
     symmetric in all of their covariant and contravariant indices. If
     `false' then no symmetries of any kind are assumed in these
     indices. Derivative indices are always taken to be symmetric
     unless `iframe_flag' is set to `true'.


 -- Function: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declares symmetry properties for <tensor> of <m> covariant and <n>
     contravariant indices. The <cov_i> and <contr_i> are
     pseudofunctions expressing symmetry relations among the covariant
     and contravariant indices respectively.  These are of the form
     `symoper(<index_1>, <index_2>,...)' where `symoper' is one of
     `sym', `anti' or `cyc' and the <index_i> are integers indicating
     the position of the index in the <tensor>.  This will declare
     <tensor> to be symmetric, antisymmetric or cyclic respectively in
     the <index_i>. `symoper(all)' is also an allowable form which
     indicates all indices obey the symmetry condition. For example,
     given an object `b' with 5 covariant indices,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declares `b'
     symmetric in its first and second and antisymmetric in its third
     and fourth covariant indices, and cyclic in all of its
     contravariant indices.  Either list of symmetry declarations may
     be null.  The function which performs the simplifications is
     `canform' as the example below illustrates.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Function: remsym (<tensor>, <m>, <n>)
     Removes all symmetry properties from <tensor> which has <m>
     covariant indices and <n> contravariant indices.

 -- Function: canform (<expr>)
     Simplifies <expr> by renaming dummy indices and reordering all
     indices as dictated by symmetry conditions imposed on them. If
     `allsym' is `true' then all indices are assumed symmetric,
     otherwise symmetry information provided by `decsym' declarations
     will be used. The dummy indices are renamed in the same manner as
     in the `rename' function. When `canform' is applied to a large
     expression the calculation may take a considerable amount of time.
     This time can be shortened by calling `rename' on the expression
     first.  Also see the example under `decsym'. Note: `canform' may
     not be able to reduce an expression completely to its simplest
     form although it will always return a mathematically correct
     result.

28.2.3 Indicial tensor calculus
-------------------------------

 -- Function: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     is the usual Maxima differentiation function which has been
     expanded in its abilities for `itensor'. It takes the derivative
     of <expr> with respect to <v_1> <n_1> times, with respect to <v_2>
     <n_2> times, etc. For the tensor package, the function has been
     modified so that the <v_i> may be integers from 1 up to the value
     of the variable `dim'.  This will cause the differentiation to be
     carried out with respect to the <v_i>th member of the list
     `vect_coords'.  If `vect_coords' is bound to an atomic variable,
     then that variable subscripted by <v_i> will be used for the
     variable of differentiation.  This permits an array of coordinate
     names or subscripted names like `x[1]', `x[2]', ...  to be used.

 -- Function: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Indicial differentiation. Unlike `diff', which differentiates with
     respect to an independent variable, `idiff)' can be used to
     differentiate with respect to a coordinate. For an indexed object,
     this amounts to appending the <v_i> as derivative indices.
     Subsequently, derivative indices will be sorted, unless
     `iframe_flag' is set to `true'.

     `idiff' can also differentiate the determinant of the metric
     tensor. Thus, if `imetric' has been bound to `G' then
     `idiff(determinant(g),k)' will return
     `2*determinant(g)*ichr2([%i,k],[%i])' where the dummy index `%i'
     is chosen appropriately.


 -- Function: liediff (<v>, <ten>)
     Computes the Lie-derivative of the tensorial expression <ten> with
     respect to the vector field <v>. <ten> should be any indexed
     tensor expression; <v> should be the name (without indices) of a
     vector field. For example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Function: rediff (<ten>)
     Evaluates all occurrences of the `idiff' command in the tensorial
     expression <ten>.


 -- Function: undiff (<expr>)
     Returns an expression equivalent to <expr> but with all derivatives
     of indexed objects replaced by the noun form of the `idiff'
     function. Its arguments would yield that indexed object if the
     differentiation were carried out.  This is useful when it is
     desired to replace a differentiated indexed object with some
     function definition resulting in <expr> and then carry out the
     differentiation by saying `ev(<expr>, idiff)'.


 -- Function: evundiff (<expr>)
     Equivalent to the execution of `undiff', followed by `ev' and
     `rediff'.

     The point of this operation is to easily evalute expressions that
     cannot be directly evaluated in derivative form. For instance, the
     following causes an error:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     However, if `icurvature' is entered in noun form, it can be
     evaluated using `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j

     Note: In earlier versions of Maxima, derivative forms of the
     Christoffel-symbols also could not be evaluated. This has been
     fixed now, so `evundiff' is no longer necessary for expressions
     like this:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2


 -- Function: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Set to zero, in <expr>, all occurrences of the <tensor_i> that
     have no derivative indices.


 -- Function: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Set to zero, in <expr>, all occurrences of the <tensor_i> that
     have derivative indices.


 -- Function: flushnd (<expr>, <tensor>, <n>)
     Set to zero, in <expr>, all occurrences of the differentiated
     object <tensor> that have <n> or more derivative indices as the
     following example demonstrates.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Function: coord (<tensor_1>, <tensor_2>, ...)
     Gives <tensor_i> the coordinate differentiation property that the
     derivative of contravariant vector whose name is one of the
     <tensor_i> yields a Kronecker delta. For example, if `coord(x)' has
     been done then `idiff(x([],[i]),j)' gives `kdelta([i],[j])'.
     `coord' is a list of all indexed objects having this property.


 -- Function: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Function: remcoord (all)
     Removes the coordinate differentiation property from the `tensor_i'
     that was established by the function `coord'.  `remcoord(all)'
     removes this property from all indexed objects.


 -- Function: makebox (<expr>)
     Display <expr> in the same manner as `show'; however, any tensor
     d'Alembertian occurring in <expr> will be indicated using the
     symbol `[]'.  For example, `[]p([m],[n])' represents
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Function: conmetderiv (<expr>, <tensor>)
     Simplifies expressions containing ordinary derivatives of both
     covariant and contravariant forms of the metric tensor (the
     current restriction).  For example, `conmetderiv' can relate the
     derivative of the contravariant metric tensor with the Christoffel
     symbols as seen from the following:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Function: simpmetderiv (<expr>)
 -- Function: simpmetderiv (<expr>[, <stop>])
     Simplifies expressions containing products of the derivatives of
     the metric tensor. Specifically, `simpmetderiv' recognizes two
     identities:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     hence


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     and


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     which follows from the symmetries of the Christoffel symbols.

     The `simpmetderiv' function takes one optional parameter which,
     when present, causes the function to stop after the first
     successful substitution in a product expression. The
     `simpmetderiv' function also makes use of the global variable
     <flipflag> which determines how to apply a "canonical" ordering to
     the product indices.

     Put together, these capabilities can be used to achieve powerful
     simplifications that are difficult or impossible to accomplish
     otherwise.  This is demonstrated through the following example
     that explicitly uses the partial simplification features of
     `simpmetderiv' to obtain a contractible expression:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     See also `weyl.dem' for an example that uses `simpmetderiv' and
     `conmetderiv' together to simplify contractions of the Weyl tensor.


 -- Function: flush1deriv (<expr>, <tensor>)
     Set to zero, in `expr', all occurrences of `tensor' that have
     exactly one derivative index.


28.2.4 Tensors in curved spaces
-------------------------------

 -- Function: imetric (<g>)
 -- System variable: imetric
     Specifies the metric by assigning the variable `imetric:<g>' in
     addition, the contraction properties of the metric <g> are set up
     by executing the commands `defcon(<g>),defcon(<g>,<g>,kdelta)'.
     The variable `imetric' (unbound by default), is bound to the
     metric, assigned by the `imetric(<g>)' command.


 -- Function: idim (<n>)
     Sets the dimensions of the metric. Also initializes the
     antisymmetry properties of the Levi-Civita symbols for the given
     dimension.


 -- Function: ichr1 ([<i>, <j>, <k>])
     Yields the Christoffel symbol of the first kind via the definition
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     To evaluate the Christoffel symbols for a particular metric, the
     variable `imetric' must be assigned a name as in the example under
     `chr2'.


 -- Function: ichr2 ([<i>, <j>], [<k>])
     Yields the Christoffel symbol of the second kind defined by the
     relation
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Function: icurvature ([<i>, <j>, <k>], [<h>])
     Yields the Riemann curvature tensor in terms of the Christoffel
     symbols of the second kind (`ichr2').  The following notation is
     used:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Function: covdiff (<expr>, <v_1>, <v_2>, ...)
     Yields the covariant derivative of <expr> with respect to the
     variables <v_i> in terms of the Christoffel symbols of the second
     kind (`ichr2').  In order to evaluate these, one should use
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the covariant indices: [i,j];
          Enter a list of the contravariant indices: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4)                                  g
          (%i5) ishow(ev(%th(2),ichr2))$
                   %1 %4  k
                  g      a     (g       - g       + g      )
                          i %1   s %4,j    j s,%4    j %4,s
          (%t5) - ------------------------------------------
                                      2
              %1 %3  k
             g      a     (g       - g       + g      )
                     %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                                 2
              k %2  %1
             g     a    (g        - g        + g       )
                    i j   s %2,%1    %1 s,%2    %1 %2,s     k
           + ------------------------------------------- + a
                                  2                         i j,s
          (%i6)


 -- Function: lorentz_gauge (<expr>)
     Imposes the Lorentz condition by substituting 0 for all indexed
     objects in <expr> that have a derivative index identical to a
     contravariant index.


 -- Function: igeodesic_coords (<expr>, <name>)
     Causes undifferentiated Christoffel symbols and first derivatives
     of the metric tensor vanish in <expr>. The <name> in the
     `igeodesic_coords' function refers to the metric <name> (if it
     appears in <expr>) while the connection coefficients must be
     called with the names `ichr1' and/or `ichr2'. The following example
     demonstrates the verification of the cyclic identity satisfied by
     the Riemann curvature tensor using the `igeodesic_coords' function.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0


28.2.5 Moving frames
--------------------

Maxima now has the ability to perform calculations using moving frames.
These can be orthonormal frames (tetrads, vielbeins) or an arbitrary
frame.

   To use frames, you must first set `iframe_flag' to `true'. This
causes the Christoffel-symbols, `ichr1' and `ichr2', to be replaced by
the more general frame connection coefficients `icc1' and `icc2' in
calculations. Speficially, the behavior of `covdiff' and `icurvature'
is changed.

   The frame is defined by two tensors: the inverse frame field (`ifri',
the dual basis tetrad), and the frame metric `ifg'. The frame metric is
the identity matrix for orthonormal frames, or the Lorentz metric for
orthonormal frames in Minkowski spacetime. The inverse frame field
defines the frame base (unit vectors).  Contraction properties are
defined for the frame field and the frame metric.

   When `iframe_flag' is true, many `itensor' expressions use the frame
metric `ifg' instead of the metric defined by `imetric' for raising and
lowerind indices.

   IMPORTANT: Setting the variable `iframe_flag' to `true' does NOT
undefine the contraction properties of a metric defined by a call to
`defcon' or `imetric'. If a frame field is used, it is best to define
the metric by assigning its name to the variable `imetric' and NOT
invoke the `imetric' function.

   Maxima uses these two tensors to define the frame coefficients
(`ifc1' and `ifc2') which form part of the connection coefficients
(`icc1' and `icc2'), as the following example demonstrates:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

   An alternate method is used to compute the frame bracket (`ifb') if
the `iframe_bracket_form' flag is set to `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Function: iframes ()
     Since in this version of Maxima, contraction identities for `ifr'
     and `ifri' are always defined, as is the frame bracket (`ifb'),
     this function does nothing.


 -- Variable: ifb
     The frame bracket. The contribution of the frame metric to the
     connection coefficients is expressed using the frame bracket:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     The frame bracket itself is defined in terms of the frame field
     and frame metric. Two alternate methods of computation are used
     depending on the value of `frame_bracket_form'. If true (the
     default) or if the `itorsion_flag' is `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variable: icc1
     Connection coefficients of the first kind. In `itensor', defined as


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     In this expression, if `iframe_flag' is true, the
     Christoffel-symbol `ichr1' is replaced with the frame connection
     coefficient `ifc1'.  If `itorsion_flag' is `false', `ikt1' will be
     omitted. It is also omitted if a frame base is used, as the
     torsion is already calculated as part of the frame bracket.
     Lastly, of `inonmet_flag' is `false', `inmc1' will not be present.


 -- Variable: icc2
     Connection coefficients of the second kind. In `itensor', defined
     as


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     In this expression, if `iframe_flag' is true, the
     Christoffel-symbol `ichr2' is replaced with the frame connection
     coefficient `ifc2'.  If `itorsion_flag' is `false', `ikt2' will be
     omitted. It is also omitted if a frame base is used, as the
     torsion is already calculated as part of the frame bracket.
     Lastly, of `inonmet_flag' is `false', `inmc2' will not be present.


 -- Variable: ifc1
     Frame coefficient of the first kind (also known as Ricci-rotation
     coefficients.) This tensor represents the contribution of the
     frame metric to the connection coefficient of the first kind.
     Defined as:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variable: ifc2
     Frame coefficient of the first kind. This tensor represents the
     contribution of the frame metric to the connection coefficient of
     the first kind. Defined as a permutation of the frame bracket
     (`ifb') with the appropriate indices raised and lowered as
     necessary:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variable: ifr
     The frame field. Contracts with the inverse frame field (`ifri') to
     form the frame metric (`ifg').


 -- Variable: ifri
     The inverse frame field. Specifies the frame base (dual basis
     vectors). Along with the frame metric, it forms the basis of all
     calculations based on frames.


 -- Variable: ifg
     The frame metric. Defaults to `kdelta', but can be changed using
     `components'.


 -- Variable: ifgi
     The inverse frame metric. Contracts with the frame metric (`ifg')
     to `kdelta'.


 -- Option variable: iframe_bracket_form
     Default value: `true'

     Specifies how the frame bracket (`ifb') is computed.


28.2.6 Torsion and nonmetricity
-------------------------------

Maxima can now take into account torsion and nonmetricity. When the flag
`itorsion_flag' is set to `true', the contribution of torsion is added
to the connection coefficients. Similarly, when the flag `inonmet_flag'
is true, nonmetricity components are included.

 -- Variable: inm
     The nonmetricity vector. Conformal nonmetricity is defined through
     the covariant derivative of the metric tensor. Normally zero, the
     metric tensor's covariant derivative will evaluate to the
     following when `inonmet_flag' is set to `true':


          g     =- g  inm
           ij;k     ij   k


 -- Variable: inmc1
     Covariant permutation of the nonmetricity vector components.
     Defined as


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: inmc2
     Contravariant permutation of the nonmetricity vector components.
     Used in the connection coefficients if `inonmet_flag' is `true'.
     Defined as:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: ikt1
     Covariant permutation of the torsion tensor (also known as
     contorsion).  Defined as:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: ikt2
     Contravariant permutation of the torsion tensor (also known as
     contorsion).  Defined as:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitute `ifg' in place of `g' if a frame metric is used.)


 -- Variable: itr
     The torsion tensor. For a metric with torsion, repeated covariant
     differentiation on a scalar function will not commute, as
     demonstrated by the following example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


28.2.7 Exterior algebra
-----------------------

The `itensor' package can perform operations on totally antisymmetric
covariant tensor fields. A totally antisymmetric tensor field of rank
(0,L) corresponds with a differential L-form. On these objects, a
multiplication operation known as the exterior product, or wedge
product, is defined.

   Unfortunately, not all authors agree on the definition of the wedge
product. Some authors prefer a definition that corresponds with the
notion of antisymmetrization: in these works, the wedge product of two
vector fields, for instance, would be defined as

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   More generally, the product of a p-form and a q-form would be
defined as

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   where `D' stands for the Kronecker-delta.

   Other authors, however, prefer a "geometric" definition that
corresponds with the notion of the volume element:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   and, in the general case

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Since `itensor' is a tensor algebra package, the first of these two
definitions appears to be the more natural one. Many applications,
however, utilize the second definition. To resolve this dilemma, a flag
has been implemented that controls the behavior of the wedge product: if
`igeowedge_flag' is `false' (the default), the first, "tensorial"
definition is used, otherwise the second, "geometric" definition will
be applied.

 -- Operator: "~"
     The wedge product operator is denoted by the tilde `~'. This is a
     binary operator. Its arguments should be expressions involving
     scalars, covariant tensors of rank one, or covariant tensors of
     rank `l' that have been declared antisymmetric in all covariant
     indices.

     The behavior of the wedge product operator is controlled by the
     `igeowedge_flag' flag, as in the following example:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operator: "|"
     The vertical bar `|' denotes the "contraction with a vector" binary
     operation. When a totally antisymmetric covariant tensor is
     contracted with a contravariant vector, the result is the same
     regardless which index was used for the contraction. Thus, it is
     possible to define the contraction operation in an index-free
     manner.

     In the `itensor' package, contraction with a vector is always
     carried out with respect to the first index in the literal sorting
     order. This ensures better simplification of expressions involving
     the `|' operator. For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note that it is essential that the tensors used with the `|'
     operator be declared totally antisymmetric in their covariant
     indices. Otherwise, the results will be incorrect.


 -- Function: extdiff (<expr>, <i>)
     Computes the exterior derivative of <expr> with respect to the
     index <i>. The exterior derivative is formally defined as the wedge
     product of the partial derivative operator and a differential
     form. As such, this operation is also controlled by the setting of
     `igeowedge_flag'.  For instance:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k


 -- Function: hodge (<expr>)
     Compute the Hodge-dual of <expr>. For instance:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Option variable: igeowedge_flag
     Default value: `false'

     Controls the behavior of the wedge product and exterior
     derivative. When set to `false' (the default), the notion of
     differential forms will correspond with that of a totally
     antisymmetric covariant tensor field.  When set to `true',
     differential forms will agree with the notion of the volume
     element.


28.2.8 Exporting TeX expressions
--------------------------------

The `itensor' package provides limited support for exporting tensor
expressions to TeX. Since `itensor' expressions appear as function
calls, the regular Maxima `tex' command will not produce the expected
output. You can try instead the `tentex' command, which attempts to
translate tensor expressions into appropriately indexed TeX objects.

 -- Function: tentex (<expr>)
     To use the `tentex' function, you must first load `tentex', as in
     the following example:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note the use of the `idummyx' assignment, to avoid the appearance
     of the percent sign in the TeX expression, which may lead to
     compile errors.

     NB: This version of the `tentex' function is somewhat experimental.


28.2.9 Interfacing with ctensor
-------------------------------

The `itensor' package has the ability to generate Maxima code that can
then be executed in the context of the `ctensor' package. The function
that performs this task is `ic_convert'.

 -- Function: ic_convert (<eqn>)
     Converts the `itensor' equation <eqn> to a `ctensor' assignment
     statement.  Implied sums over dummy indices are made explicit
     while indexed objects are transformed into arrays (the array
     subscripts are in the order of covariant followed by contravariant
     indices of the indexed objects). The derivative of an indexed
     object will be replaced by the noun form of `diff' taken with
     respect to `ct_coords' subscripted by the derivative index. The
     Christoffel symbols `ichr1' and `ichr2' will be translated to
     `lcs' and `mcs', respectively and if `metricconvert' is `true'
     then all occurrences of the metric with two covariant
     (contravariant) indices will be renamed to `lg' (`ug'). In
     addition, `do' loops will be introduced summing over all free
     indices so that the transformed assignment statement can be
     evaluated by just doing `ev'. The following examples demonstrate
     the features of this function.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


28.2.10 Reserved words
----------------------

The following Maxima words are used by the `itensor' package internally
and should not be redefined:

       Keyword    Comments
       ------------------------------------------
       indices2() Internal version of indices()
       conti      Lists contravariant indices
       covi       Lists covariant indices of a indexed object
       deri       Lists derivative indices of an indexed object
       name       Returns the name of an indexed object
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: atensor,  Prev: itensor,  Up: Top

29 ctensor
**********

* Menu:

* Introduction to ctensor::
* Definitions for ctensor::


File: maxima.info,  Node: Introduction to ctensor,  Next: Definitions for ctensor,  Prev: ctensor,  Up: ctensor

29.1 Introduction to ctensor
============================

`ctensor' is a component tensor manipulation package.  To use the
`ctensor' package, type `load(ctensor)'.  To begin an interactive
session with `ctensor', type `csetup()'.  You are first asked to
specify the dimension of the manifold. If the dimension is 2, 3 or 4
then the list of coordinates defaults to `[x,y]', `[x,y,z]' or
`[x,y,z,t]' respectively.  These names may be changed by assigning a
new list of coordinates to the variable `ct_coords' (described below)
and the user is queried about this. Care must be taken to avoid the
coordinate names conflicting with other object definitions.

   Next, the user enters the metric either directly or from a file by
specifying its ordinal position.  The metric is stored in the matrix
`lg'. Finally, the metric inverse is computed and stored in the matrix
`ug'. One has the option of carrying out all calculations in a power
series.

   A sample protocol is begun below for the static, spherically
symmetric metric (standard coordinates) which will be applied to the
problem of deriving Einstein's vacuum equations (which lead to the
Schwarzschild solution) as an example. Many of the functions in
`ctensor' will be displayed for the standard metric as examples.

     (%i1) load(ctensor);
     (%o1)      /share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Definitions for ctensor,  Prev: Introduction to ctensor,  Up: ctensor

29.2 Definitions for ctensor
============================

29.2.1 Initialization and setup
-------------------------------

 -- Function: csetup ()
     A function in the `ctensor' (component tensor) package which
     initializes the package and allows the user to enter a metric
     interactively. See `ctensor' for more details.

 -- Function: cmetric (<dis>)
 -- Function: cmetric ()
     A function in the `ctensor' (component tensor) package that
     computes the metric inverse and sets up the package for further
     calculations.

     If `cframe_flag' is false, the function computes the inverse metric
     `ug' from the (user-defined) matrix `lg'. The metric determinant is
     also computed and stored in the variable `gdet'. Furthermore, the
     package determines if the metric is diagonal and sets the value of
     `diagmetric' accordingly. If the optional argument <dis> is
     present and not equal to `false', the user is prompted to see the
     metric inverse.

     If `cframe_flag' is `true', the function expects that the values of
     `fri' (the inverse frame matrix) and `lfg' (the frame metric) are
     defined. From these, the frame matrix `fr' and the inverse frame
     metric `ufg' are computed.


 -- Function: ct_coordsys (<coordinate_system>, <extra_arg>)
 -- Function: ct_coordsys (<coordinate_system>)
     Sets up a predefined coordinate system and metric. The argument
     <coordinate_system> can be one of the following symbols:


            SYMBOL               Dim Coordinates       Description/comments
            --------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Cartesian 2D coordinate system
            polar                 2  [r,phi]           Polar coordinate system
            elliptic              2  [u,v]             Elliptic coordinate system
            confocalelliptic      2  [u,v]             Confocal elliptic coordinates
            bipolar               2  [u,v]             Bipolar coordinate system
            parabolic             2  [u,v]             Parabolic coordinate system
            cartesian3d           3  [x,y,z]           Cartesian 3D coordinate system
            polarcylindrical      3  [r,theta,z]       Polar 2D with cylindrical z
            ellipticcylindrical   3  [u,v,z]           Elliptic 2D with cylindrical z
            confocalellipsoidal   3  [u,v,w]           Confocal ellipsoidal
            bipolarcylindrical    3  [u,v,z]           Bipolar 2D with cylindrical z
            paraboliccylindrical  3  [u,v,z]           Parabolic 2D with cylindrical z
            paraboloidal          3  [u,v,phi]         Paraboloidal coordinates
            conical               3  [u,v,w]           Conical coordinates
            toroidal              3  [u,v,phi]         Toroidal coordinates
            spherical             3  [r,theta,phi]     Spherical coordinate system
            oblatespheroidal      3  [u,v,phi]         Oblate spheroidal coordinates
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]         Prolate spheroidal coordinates
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]     Ellipsoidal coordinates
            cartesian4d           4  [x,y,z,t]         Cartesian 4D coordinate system
            spherical4d           4  [r,theta,eta,phi] Spherical 4D coordinate system
            exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild metric
            interiorschwarzschild 4  [t,z,u,v]         Interior Schwarzschild metric
            kerr_newman           4  [t,r,theta,phi]   Charged axially symmetric metric

     `coordinate_system' can also be a list of transformation functions,
     followed by a list containing the coordinate variables. For
     instance, you can specify a spherical metric as follows:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Transformation functions can also be used when `cframe_flag' is
     `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     The optional argument <extra_arg> can be any one of the following:

     `cylindrical' tells `ct_coordsys' to attach an additional
     cylindrical coordinate.

     `minkowski' tells `ct_coordsys' to attach an additional coordinate
     with negative metric signature.

     `all' tells `ct_coordsys' to call `cmetric' and `christof(false)'
     after setting up the metric.

     If the global variable `verbose' is set to `true', `ct_coordsys'
     displays the values of `dim', `ct_coords', and either `lg' or
     `lfg' and `fri', depending on the value of `cframe_flag'.


 -- Function: init_ctensor ()
     Initializes the `ctensor' package.

     The `init_ctensor' function reinitializes the `ctensor' package.
     It removes all arrays and matrices used by `ctensor', resets all
     flags, resets `dim' to 4, and resets the frame metric to the
     Lorentz-frame.


29.2.2 The tensors of curved space
----------------------------------

The main purpose of the `ctensor' package is to compute the tensors of
curved space(time), most notably the tensors used in general relativity.

   When a metric base is used, `ctensor' can compute the following
tensors:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   `ctensor' can also work using moving frames. When `cframe_flag' is
set to `true', the following tensors can be calculated:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Function: christof (<dis>)
     A function in the `ctensor' (component tensor) package.  It
     computes the Christoffel symbols of both kinds.  The argument
     <dis> determines which results are to be immediately displayed.
     The Christoffel symbols of the first and second kinds are stored
     in the arrays `lcs[i,j,k]' and `mcs[i,j,k]' respectively and
     defined to be symmetric in the first two indices. If the argument
     to `christof' is `lcs' or `mcs' then the unique non-zero values of
     `lcs[i,j,k]' or `mcs[i,j,k]', respectively, will be displayed. If
     the argument is `all' then the unique non-zero values of
     `lcs[i,j,k]' and `mcs[i,j,k]' will be displayed.  If the argument
     is `false' then the display of the elements will not occur. The
     array elements `mcs[i,j,k]' are defined in such a manner that the
     final index is contravariant.


 -- Function: ricci (<dis>)
     A function in the `ctensor' (component tensor) package. `ricci'
     computes the covariant (symmetric) components `ric[i,j]' of the
     Ricci tensor.  If the argument <dis> is `true', then the non-zero
     components are displayed.


 -- Function: uricci (<dis>)
     This function first computes the covariant components `ric[i,j]'
     of the Ricci tensor.  Then the mixed Ricci tensor is computed
     using the contravariant metric tensor.  If the value of the
     argument <dis> is `true', then these mixed components, `uric[i,j]'
     (the index `i' is covariant and the index `j' is contravariant),
     will be displayed directly.  Otherwise, `ricci(false)' will simply
     compute the entries of the array `uric[i,j]' without displaying
     the results.


 -- Function: scurvature ()
     Returns the scalar curvature (obtained by contracting the Ricci
     tensor) of the Riemannian manifold with the given metric.


 -- Function: einstein (<dis>)
     A function in the `ctensor' (component tensor) package.
     `einstein' computes the mixed Einstein tensor after the
     Christoffel symbols and Ricci tensor have been obtained (with the
     functions `christof' and `ricci').  If the argument <dis> is
     `true', then the non-zero values of the mixed Einstein tensor
     `ein[i,j]' will be displayed where `j' is the contravariant index.
     The variable `rateinstein' will cause the rational simplification
     on these components. If `ratfac' is `true' then the components will
     also be factored.


 -- Function: leinstein (<dis>)
     Covariant Einstein-tensor. `leinstein' stores the values of the
     covariant Einstein tensor in the array `lein'. The covariant
     Einstein-tensor is computed from the mixed Einstein tensor `ein'
     by multiplying it with the metric tensor. If the argument <dis> is
     `true', then the non-zero values of the covariant Einstein tensor
     are displayed.


 -- Function: riemann (<dis>)
     A function in the `ctensor' (component tensor) package.  `riemann'
     computes the Riemann curvature tensor from the given metric and
     the corresponding Christoffel symbols. The following index
     conventions are used:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     This notation is consistent with the notation used by the `itensor'
     package and its `icurvature' function.  If the optional argument
     <dis> is `true', the non-zero components `riem[i,j,k,l]' will be
     displayed.  As with the Einstein tensor, various switches set by
     the user control the simplification of the components of the
     Riemann tensor.  If `ratriemann' is `true', then rational
     simplification will be done. If `ratfac' is `true' then each of
     the components will also be factored.

     If the variable `cframe_flag' is `false', the Riemann tensor is
     computed directly from the Christoffel-symbols. If `cframe_flag' is
     `false', the covariant Riemann-tensor is computed first from the
     frame field coefficients.


 -- Function: lriemann (<dis>)
     Covariant Riemann-tensor (`lriem[]').

     Computes the covariant Riemann-tensor as the array `lriem'. If the
     argument <dis> is `true', unique nonzero values are displayed.

     If the variable `cframe_flag' is `true', the covariant Riemann
     tensor is computed directly from the frame field coefficients.
     Otherwise, the (3,1) Riemann tensor is computed first.

     For information on index ordering, see `riemann'.


 -- Function: uriemann (<dis>)
     Computes the contravariant components of the Riemann curvature
     tensor as array elements `uriem[i,j,k,l]'.  These are displayed if
     <dis> is `true'.


 -- Function: rinvariant ()
     Forms the Kretchmann-invariant (`kinvariant') obtained by
     contracting the tensors

          lriem[i,j,k,l]*uriem[i,j,k,l].

     This object is not automatically simplified since it can be very
     large.


 -- Function: weyl (<dis>)
     Computes the Weyl conformal tensor.  If the argument <dis> is
     `true', the non-zero components `weyl[i,j,k,l]' will be displayed
     to the user.  Otherwise, these components will simply be computed
     and stored.  If the switch `ratweyl' is set to `true', then the
     components will be rationally simplified; if `ratfac' is `true'
     then the results will be factored as well.


29.2.3 Taylor series expansion
------------------------------

The `ctensor' package has the ability to truncate results by assuming
that they are Taylor-series approximations. This behavior is controlled
by the `ctayswitch' variable; when set to true, `ctensor' makes use
internally of the function `ctaylor' when simplifying results.

   The `ctaylor' function is invoked by the following `ctensor'
functions:


         Function     Comments
         ---------------------------------
         christof()   For mcs only
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Function: ctaylor ()
     The `ctaylor' function truncates its argument by converting it to
     a Taylor-series using `taylor', and then calling `ratdisrep'. This
     has the combined effect of dropping terms higher order in the
     expansion variable `ctayvar'. The order of terms that should be
     dropped is defined by `ctaypov'; the point around which the series
     expansion is carried out is specified in `ctaypt'.

     As an example, consider a simple metric that is a perturbation of
     the Minkowski metric. Without further restrictions, even a diagonal
     metric produces expressions for the Einstein tensor that are far
     too complex:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     However, if we recompute this example as an approximation that is
     linear in the variable `l', we get much simpler expressions:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r

     This capability can be useful, for instance, when working in the
     weak field limit far from a gravitational source.


29.2.4 Frame fields
-------------------

When the variable `cframe_flag' is set to true, the `ctensor' package
performs its calculations using a moving frame.

 -- Function: frame_bracket (<fr>, <fri>, <diagframe>)
     The frame bracket (`fb[]').

     Computes the frame bracket according to the following definition:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


29.2.5 Algebraic classification
-------------------------------

A new feature (as of November, 2004) of `ctensor' is its ability to
compute the Petrov classification of a 4-dimensional spacetime metric.
For a demonstration of this capability, see the file
`share/tensor/petrov.dem'.

 -- Function: nptetrad ()
     Computes a Newman-Penrose null tetrad (`np') and its raised-index
     counterpart (`npi'). See `petrov' for an example.

     The null tetrad is constructed on the assumption that a
     four-diemensional orthonormal frame metric with metric signature
     (-,+,+,+) is being used.  The components of the null tetrad are
     related to the inverse frame matrix as follows:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Function: psi (<dis>)
     Computes the five Newman-Penrose coefficients `psi[0]'...`psi[4]'.
     If `psi' is set to `true', the coefficients are displayed.  See
     `petrov' for an example.

     These coefficients are computed from the Weyl-tensor in a
     coordinate base.  If a frame base is used, the Weyl-tensor is
     first converted to a coordinate base, which can be a
     computationally expensive procedure. For this reason, in some
     cases it may be more advantageous to use a coordinate base in the
     first place before the Weyl tensor is computed. Note however, that
     constructing a Newman-Penrose null tetrad requires a frame base.
     Therefore, a meaningful computation sequence may begin with a
     frame base, which is then used to compute `lg' (computed
     automatically by `cmetric' and then `ug'. At this point, you can
     switch back to a coordinate base by setting `cframe_flag' to false
     before beginning to compute the Christoffel symbols. Changing to a
     frame base at a later stage could yield inconsistent results, as
     you may end up with a mixed bag of tensors, some computed in a
     frame base, some in a coordinate base, with no means to
     distinguish between the two.


 -- Function: petrov ()
     Computes the Petrov classification of the metric characterized by
     `psi[0]'...`psi[4]'.

     For example, the following demonstrates how to obtain the
     Petrov-classification of the Kerr metric:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     The Petrov classification function is based on the algorithm
     published in "Classifying geometries in general relativity: III
     Classification in practice" by Pollney, Skea, and d'Inverno,
     Class. Quant. Grav. 17 2885-2902 (2000).  Except for some simple
     test cases, the implementation is untested as of December 19,
     2004, and is likely to contain errors.


29.2.6 Torsion and nonmetricity
-------------------------------

`ctensor' has the ability to compute and include torsion and
nonmetricity coefficients in the connection coefficients.

   The torsion coefficients are calculated from a user-supplied tensor
`tr', which should be a rank (2,1) tensor. From this, the torsion
coefficients `kt' are computed according to the following formulae:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Note that only the mixed-index tensor is calculated and stored in the
array `kt'.

   The nonmetricity coefficients are calculated from the user-supplied
nonmetricity vector `nm'. From this, the nonmetricity coefficients
`nmc' are computed as follows:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   where D stands for the Kronecker-delta.

   When `ctorsion_flag' is set to `true', the values of `kt' are
substracted from the mixed-indexed connection coefficients computed by
`christof' and stored in `mcs'. Similarly, if `cnonmet_flag' is set to
`true', the values of `nmc' are substracted from the mixed-indexed
connection coefficients.

   If necessary, `christof' calls the functions `contortion' and
`nonmetricity' in order to compute `kt' and `nm'.

 -- Function: contortion (<tr>)
     Computes the (2,1) contortion coefficients from the torsion tensor
     <tr>.


 -- Function: nonmetricity (<nm>)
     Computes the (2,1) nonmetricity coefficients from the nonmetricity
     vector <nm>.


29.2.7 Miscellaneous features
-----------------------------

 -- Function: ctransform (<M>)
     A function in the `ctensor' (component tensor) package which will
     perform a coordinate transformation upon an arbitrary square
     symmetric matrix <M>. The user must input the functions which
     define the transformation.  (Formerly called `transform'.)


 -- Function: findde (<A>, <n>)
     returns a list of the unique differential equations (expressions)
     corresponding to the elements of the <n> dimensional square array
     <A>. Presently, <n> may be 2 or 3. `deindex' is a global list
     containing the indices of <A> corresponding to these unique
     differential equations. For the Einstein tensor (`ein'), which is
     a two dimensional array, if computed for the metric in the example
     below, `findde' gives the following independent differential
     equations:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Function: cograd ()
     Computes the covariant gradient of a scalar function allowing the
     user to choose the corresponding vector name as the example under
     `contragrad' illustrates.

 -- Function: contragrad ()
     Computes the contravariant gradient of a scalar function allowing
     the user to choose the corresponding vector name as the example
     below for the Schwarzschild metric illustrates:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Function: dscalar ()
     computes the tensor d'Alembertian of the scalar function once
     dependencies have been declared upon the function. For example:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Function: checkdiv ()
     computes the covariant divergence of the mixed second rank tensor
     (whose first index must be covariant) by printing the
     corresponding n components of the vector field (the divergence)
     where n = `dim'. If the argument to the function is `g' then the
     divergence of the Einstein tensor will be formed and must be zero.
     In addition, the divergence (vector) is given the array name `div'.

 -- Function: cgeodesic (<dis>)
     A function in the `ctensor' (component tensor) package.
     `cgeodesic' computes the geodesic equations of motion for a given
     metric.  They are stored in the array `geod[i]'.  If the argument
     <dis> is `true' then these equations are displayed.


 -- Function: bdvac (<f>)
     generates the covariant components of the vacuum field equations of
     the Brans- Dicke gravitational theory. The scalar field is
     specified by the argument <f>, which should be a (quoted) function
     name with functional dependencies, e.g., `'p(x)'.

     The components of the second rank covariant field tensor are
     represented by the array `bd'.


 -- Function: invariant1 ()
     generates the mixed Euler- Lagrange tensor (field equations) for
     the invariant density of R^2. The field equations are the
     components of an array named `inv1'.


 -- Function: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     generates the mixed Euler- Lagrange tensor (field equations) for
     the invariant density of `ric[i,j]*uriem[i,j]'. The field
     equations are the components of an array named `inv2'.


 -- Function: bimetric ()
     *** NOT YET IMPLEMENTED ***

     generates the field equations of Rosen's bimetric theory. The field
     equations are the components of an array named `rosen'.


29.2.8 Utility functions
------------------------

 -- Function: diagmatrixp (<M>)
     Returns `true' if <M> is a diagonal matrix or (2D) array.


 -- Function: symmetricp (<M>)
     Returns `true' if <M> is a symmetric matrix or (2D) array.


 -- Function: ntermst (<f>)
     gives the user a quick picture of the "size" of the doubly
     subscripted tensor (array) <f>.  It prints two element lists where
     the second element corresponds to NTERMS of the components
     specified by the first elements.  In this way, it is possible to
     quickly find the non-zero expressions and attempt simplification.


 -- Function: cdisplay (<ten>)
     displays all the elements of the tensor <ten>, as represented by a
     multidimensional array. Tensors of rank 0 and 1, as well as other
     types of variables, are displayed as with `ldisplay'. Tensors of
     rank 2 are displayed as 2-dimensional matrices, while tensors of
     higher rank are displayed as a list of 2-dimensional matrices. For
     instance, the Riemann-tensor of the Schwarzschild metric can be
     viewed as:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Function: deleten (<L>, <n>)
     Returns a new list consisting of <L> with the <n>'th element
     deleted.

29.2.9 Variables used by `ctensor'
----------------------------------

 -- Option variable: dim
     Default value: 4

     An option in the `ctensor' (component tensor) package.  `dim' is
     the dimension of the manifold with the default 4. The command
     `dim: n' will reset the dimension to any other value `n'.


 -- Option variable: diagmetric
     Default value: `false'

     An option in the `ctensor' (component tensor) package.  If
     `diagmetric' is `true' special routines compute all geometrical
     objects (which contain the metric tensor explicitly) by taking
     into consideration the diagonality of the metric. Reduced run
     times will, of course, result. Note: this option is set
     automatically by `csetup' if a diagonal metric is specified.


 -- Option variable: ctrgsimp
     Causes trigonometric simplifications to be used when tensors are
     computed. Presently, `ctrgsimp' affects only computations
     involving a moving frame.


 -- Option variable: cframe_flag
     Causes computations to be performed relative to a moving frame as
     opposed to a holonomic metric. The frame is defined by the inverse
     frame array `fri' and the frame metric `lfg'. For computations
     using a Cartesian frame, `lfg' should be the unit matrix of the
     appropriate dimension; for computations in a Lorentz frame, `lfg'
     should have the appropriate signature.


 -- Option variable: ctorsion_flag
     Causes the contortion tensor to be included in the computation of
     the connection coefficients. The contortion tensor itself is
     computed by `contortion' from the user-supplied tensor `tr'.


 -- Option variable: cnonmet_flag
     Causes the nonmetricity coefficients to be included in the
     computation of the connection coefficients. The nonmetricity
     coefficients are computed from the user-supplied nonmetricity
     vector `nm' by the function `nonmetricity'.


 -- Option variable: ctayswitch
     If set to `true', causes some `ctensor' computations to be carried
     out using Taylor-series expansions. Presently, `christof', `ricci',
     `uricci', `einstein', and `weyl' take into account this setting.


 -- Option variable: ctayvar
     Variable used for Taylor-series expansion if `ctayswitch' is set to
     `true'.


 -- Option variable: ctaypov
     Maximum power used in Taylor-series expansion when `ctayswitch' is
     set to `true'.


 -- Option variable: ctaypt
     Point around which Taylor-series expansion is carried out when
     `ctayswitch' is set to `true'.


 -- System variable: gdet
     The determinant of the metric tensor `lg'. Computed by `cmetric'
     when `cframe_flag' is set to `false'.


 -- Option variable: ratchristof
     Causes rational simplification to be applied by `christof'.


 -- Option variable: rateinstein
     Default value: `true'

     If `true' rational simplification will be performed on the
     non-zero components of Einstein tensors; if `ratfac' is `true'
     then the components will also be factored.


 -- Option variable: ratriemann
     Default value: `true'

     One of the switches which controls simplification of Riemann
     tensors; if `true', then rational simplification will be done; if
     `ratfac' is `true' then each of the components will also be
     factored.


 -- Option variable: ratweyl
     Default value: `true'

     If `true', this switch causes the `weyl' function to apply
     rational simplification to the values of the Weyl tensor. If
     `ratfac' is `true', then the components will also be factored.

 -- Variable: lfg
     The covariant frame metric. By default, it is initialized to the
     4-dimensional Lorentz frame with signature (+,+,+,-). Used when
     `cframe_flag' is `true'.

 -- Variable: ufg
     The inverse frame metric. Computed from `lfg' when `cmetric' is
     called while `cframe_flag' is set to `true'.

 -- Variable: riem
     The (3,1) Riemann tensor. Computed when the function `riemann' is
     invoked. For information about index ordering, see the description
     of `riemann'.

     if `cframe_flag' is `true', `riem' is computed from the covariant
     Riemann-tensor `lriem'.


 -- Variable: lriem
     The covariant Riemann tensor. Computed by `lriemann'.


 -- Variable: uriem
     The contravariant Riemann tensor. Computed by `uriemann'.


 -- Variable: ric
     The mixed Ricci-tensor. Computed by `ricci'.


 -- Variable: uric
     The contravariant Ricci-tensor. Computed by `uricci'.


 -- Variable: lg
     The metric tensor. This tensor must be specified (as a `dim' by
     `dim' matrix) before other computations can be performed.


 -- Variable: ug
     The inverse of the metric tensor. Computed by `cmetric'.


 -- Variable: weyl
     The Weyl tensor. Computed by `weyl'.


 -- Variable: fb
     Frame bracket coefficients, as computed by `frame_bracket'.


 -- Variable: kinvariant
     The Kretchmann invariant. Computed by `rinvariant'.


 -- Variable: np
     A Newman-Penrose null tetrad. Computed by `nptetrad'.


 -- Variable: npi
     The raised-index Newman-Penrose null tetrad. Computed by
     `nptetrad'.  Defined as `ug.np'. The product `np.transpose(npi)'
     is constant:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variable: tr
     User-supplied rank-3 tensor representing torsion. Used by
     `contortion'.

 -- Variable: kt
     The contortion tensor, computed from `tr' by `contortion'.

 -- Variable: nm
     User-supplied nonmetricity vector. Used by `nonmetricity'.

 -- Variable: nmc
     The nonmetricity coefficients, computed from `nm' by
     `nonmetricity'.


 -- System variable: tensorkill
     Variable indicating if the tensor package has been initialized.
     Set and used by `csetup', reset by `init_ctensor'.


 -- Option variable: ct_coords
     Default value: `[]'

     An option in the `ctensor' (component tensor) package.
     `ct_coords' contains a list of coordinates.  While normally
     defined when the function `csetup' is called, one may redefine the
     coordinates with the assignment `ct_coords: [j1, j2, ..., jn]'
     where the j's are the new coordinate names.  See also `csetup'.


29.2.10 Reserved names
----------------------

The following names are used internally by the `ctensor' package and
should not be redefined:

       Name         Description
       ---------------------------------------
       _lg()        Evaluates to lfg if frame metric used, lg otherwise
       _ug()        Evaluates to ufg if frame metric used, ug otherwise
       cleanup()    Removes items drom the deindex list
       contract4()  Used by psi()
       filemet()    Used by csetup() when reading the metric from a file
       findde1()    Used by findde()
       findde2()    Used by findde()
       findde3()    Used by findde()
       kdelt()      Kronecker-delta (not generalized)
       newmet()     Used by csetup() for setting up a metric interactively
       setflags()   Used by init_ctensor()
       readvalue()
       resimp()
       sermet()     Used by csetup() for entering a metric as Taylor-series
       txyzsum()
       tmetric()    Frame metric, used by cmetric() when cframe_flag:true
       triemann()   Riemann-tensor in frame base, used when cframe_flag:true
       tricci()     Ricci-tensor in frame base, used when cframe_flag:true
       trrc()       Ricci rotation coefficients, used by christof()
       yesp()

29.2.11 Changes
---------------

In November, 2004, the `ctensor' package was extensively rewritten.
Many functions and variables have been renamed in order to make the
package compatible with the commercial version of Macsyma.

       New Name     Old Name        Description
       --------------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
       lgeod[]      EM              Geodesic equations
       ein[]        G[]             Mixed Einstein-tensor
       ric[]        LR[]            Mixed Ricci-tensor
       ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
       ctaypov      MINP            Maximum power in Taylor-series expansion
       cgeodesic()  MOTION          Compute geodesic equations
       ct_coords    OMEGA           Metric coordinates
       ctayvar      PARAM           Taylor-series expansion variable
       lriem[]      R[]             Covariant Riemann-tensor
       uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
       ratriemann   RATRIEMAN       Rational simplification of the Riemann-tensor
       uric[]       RICCI[]         Contravariant Ricci-tensor
       uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
       cmetric()    SETMETRIC()     Set up the metric
       ctaypt       TAYPT           Point for Taylor-series expansion
       ctayswitch   TAYSWITCH       Taylor-series setting switch
       csetup()     TSETUP()        Start interactive setup session
       ctransform() TTRANSFORM()    Interactive coordinate transformation
       uriem[]      UR[]            Contravariant Riemann-tensor
       weyl[]       W[]             (3,1) Weyl-tensor


File: maxima.info,  Node: atensor,  Next: Series,  Prev: ctensor,  Up: Top

30 atensor
**********

* Menu:

* Introduction to atensor::
* Definitions for atensor::


File: maxima.info,  Node: Introduction to atensor,  Next: Definitions for atensor,  Prev: atensor,  Up: atensor

30.1 Introduction to atensor
============================

`atensor' is an algebraic tensor manipulation package. To use `atensor',
type `load(atensor)', followed by a call to the `init_atensor' function.

   The essence of `atensor' is a set of simplification rules for the
noncommutative (dot) product operator ("`.'"). `atensor' recognizes
several algebra types; the corresponding simplification rules are put
into effect when the `init_atensor' function is called.

   The capabilities of `atensor' can be demonstrated by defining the
algebra of quaternions as a Clifford-algebra Cl(0,2) with two basis
vectors. The three quaternionic imaginary units are then the two basis
vectors and their product, i.e.:

         i = v     j = v     k = v  . v
              1         2         1    2

   Although the `atensor' package has a built-in definition for the
quaternion algebra, it is not used in this example, in which we
endeavour to build the quaternion multiplication table as a matrix:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  . v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  . v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  . v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  . v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  . v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   `atensor' recognizes as base vectors indexed symbols, where the
symbol is that stored in `asymbol' and the index runs between 1 and
`adim'.  For indexed symbols, and indexed symbols only, the bilinear
forms `sf', `af', and `av' are evaluated. The evaluation substitutes
the value of `aform[i,j]' in place of `fun(v[i],v[j])' where `v'
represents the value of `asymbol' and `fun' is either `af' or `sf'; or,
it substitutes `v[aform[i,j]]' in place of `av(v[i],v[j])'.

   Needless to say, the functions `sf', `af' and `av' can be redefined.

   When the `atensor' package is loaded, the following flags are set:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   If you wish to experiment with a nonassociative algebra, you may also
consider setting `dotassoc' to `false'. In this case, however,
`atensimp' will not always be able to obtain the desired
simplifications.


File: maxima.info,  Node: Definitions for atensor,  Prev: Introduction to atensor,  Up: atensor

30.2 Definitions for atensor
============================

 -- Function: init_atensor (<alg_type>, <opt_dims>)
 -- Function: init_atensor (<alg_type>)
     Initializes the `atensor' package with the specified algebra type.
     <alg_type> can be one of the following:

     `universal': The universal algebra has no commutation rules.

     `grassmann': The Grassman algebra is defined by the commutation
     relation `u.v+v.u=0'.

     `clifford': The Clifford algebra is defined by the commutation
     relation `u.v+v.u=-2*sf(u,v)' where `sf' is a symmetric
     scalar-valued function. For this algebra, <opt_dims> can be up to
     three nonnegative integers, representing the number of positive,
     degenerate, and negative dimensions of the algebra, respectively.
     If any <opt_dims> values are supplied, `atensor' will configure the
     values of `adim' and `aform' appropriately. Otherwise, `adim' will
     default to 0 and `aform' will not be defined.

     `symmetric': The symmetric algebra is defined by the commutation
     relation `u.v-v.u=0'.

     `symplectic': The symplectic algebra is defined by the commutation
     relation `u.v-v.u=2*af(u,v)' where `af' is an antisymmetric
     scalar-valued function. For the symplectic algebra, <opt_dims> can
     be up to two nonnegative integers, representing the nondegenerate
     and degenerate dimensions, respectively. If any <opt_dims> values
     are supplied, `atensor' will configure the values of `adim' and
     `aform' appropriately. Otherwise, `adim' will default to 0 and
     `aform' will not be defined.

     `lie_envelop': The algebra of the Lie envelope is defined by the
     commutation relation `u.v-v.u=2*av(u,v)' where `av' is an
     antisymmetric function.

     The `init_atensor' function also recognizes several predefined
     algebra types:

     `complex' implements the algebra of complex numbers as the
     Clifford algebra Cl(0,1). The call `init_atensor(complex)' is
     equivalent to `init_atensor(clifford,0,0,1)'.

     `quaternion' implements the algebra of quaternions. The call
     `init_atensor(quaternion)' is equivalent to
     `init_atensor(clifford,0,0,2)'.

     `pauli' implements the algebra of Pauli-spinors as the
     Clifford-algebra Cl(3,0). A call to `init_atensor(pauli)' is
     equivalent to `init_atensor(clifford,3)'.

     `dirac' implements the algebra of Dirac-spinors as the
     Clifford-algebra Cl(3,1). A call to `init_atensor(dirac)' is
     equivalent to `init_atensor(clifford,3,0,1)'.


 -- Function: atensimp (<expr>)
     Simplifies an algebraic tensor expression <expr> according to the
     rules configured by a call to `init_atensor'. Simplification
     includes recursive application of commutation relations and
     resolving calls to `sf', `af', and `av' where applicable. A
     safeguard is used to ensure that the function always terminates,
     even for complex expressions.


 -- Function: alg_type
     The algebra type. Valid values are `universal', `grassmann',
     `clifford', `symmetric', `symplectic' and `lie_envelop'.


 -- Variable: adim
     Default value: 0

     The dimensionality of the algebra. `atensor' uses the value of
     `adim' to determine if an indexed object is a valid base vector.
     See `abasep'.


 -- Variable: aform
     Default value: `ident(3)'

     Default values for the bilinear forms `sf', `af', and `av'. The
     default is the identity matrix `ident(3)'.


 -- Variable: asymbol
     Default value: `v'

     The symbol for base vectors..


 -- Function: sf (<u>, <v>)
     A symmetric scalar function that is used in commutation relations.
     The default implementation checks if both arguments are base
     vectors using `abasep' and if that is the case, substitutes the
     corresponding value from the matrix `aform'.


 -- Function: af (<u>, <v>)
     An antisymmetric scalar function that is used in commutation
     relations.  The default implementation checks if both arguments
     are base vectors using `abasep' and if that is the case,
     substitutes the corresponding value from the matrix `aform'.


 -- Function: av (<u>, <v>)
     An antisymmetric function that is used in commutation relations.
     The default implementation checks if both arguments are base
     vectors using `abasep' and if that is the case, substitutes the
     corresponding value from the matrix `aform'.

     For instance:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Function: abasep (<v>)
     Checks if its argument is an `atensor' base vector. That is, if it
     is an indexed symbol, with the symbol being the same as the value
     of `asymbol', and the index having a numeric value between 1 and
     `adim'.



File: maxima.info,  Node: Series,  Next: Number Theory,  Prev: atensor,  Up: Top

31 Series
*********

* Menu:

* Introduction to Series::
* Definitions for Series::


File: maxima.info,  Node: Introduction to Series,  Next: Definitions for Series,  Prev: Series,  Up: Series

31.1 Introduction to Series
===========================

Maxima contains functions `taylor' and `powerseries' for finding the
series of differentiable functions.   It also has tools such as `nusum'
capable of finding the closed form of some series.   Operations such as
addition and multiplication work as usual on series. This section
presents the global variables which control the expansion.


File: maxima.info,  Node: Definitions for Series,  Prev: Introduction to Series,  Up: Series

31.2 Definitions for Series
===========================

 -- Option variable: cauchysum
     Default value: `false'

     When multiplying together sums with `inf' as their upper limit, if
     `sumexpand' is `true' and `cauchysum' is `true' then the Cauchy
     product will be used rather than the usual product.  In the Cauchy
     product the index of the inner summation is a function of the
     index of the outer one rather than varying independently.

     Example:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0


 -- Function: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     For each function <f_i> of one variable <x_i>, `deftaylor' defines
     <expr_i> as the Taylor series about zero.  <expr_i> is typically a
     polynomial in <x_i> or a summation; more general expressions are
     accepted by `deftaylor' without complaint.

     `powerseries (<f_i>(<x_i>), <x_i>, 0)' returns the series defined
     by `deftaylor'.

     `deftaylor' returns a list of the functions <f_1>, ..., <f_n>.
     `deftaylor' evaluates its arguments.

     Example:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200


 -- Option variable: maxtayorder
     Default value: `true'

     When `maxtayorder' is `true', then during algebraic manipulation
     of (truncated) Taylor series, `taylor' tries to retain as many
     terms as are known to be correct.


 -- Function: niceindices (<expr>)
     Renames the indices of sums and products in <expr>.  `niceindices'
     attempts to rename each index to the value of `niceindicespref[1]',
     unless that name appears in the summand or multiplicand, in which
     case `niceindices' tries the succeeding elements of
     `niceindicespref' in turn, until an unused variable is found.  If
     the entire list is exhausted, additional indices are constructed
     by appending integers to the value of `niceindicespref[1]', e.g.,
     `i0', `i1', `i2', ....

     `niceindices' returns an expression.  `niceindices' evaluates its
     argument.

     Example:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1


 -- Option variable: niceindicespref
     Default value: `[i, j, k, l, m, n]'

     `niceindicespref' is the list from which `niceindices' takes the
     names of indices for sums and products.

     The elements of `niceindicespref' are typically names of variables,
     although that is not enforced by `niceindices'.

     Example:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1


 -- Function: nusum (<expr>, <x>, <i_0>, <i_1>)
     Carries out indefinite hypergeometric summation of <expr> with
     respect to <x> using a decision procedure due to R.W. Gosper.
     <expr> and the result must be expressible as products of integer
     powers, factorials, binomials, and rational functions.

     The terms "definite" and "indefinite summation" are used
     analogously to "definite" and "indefinite integration".  To sum
     indefinitely means to give a symbolic result for the sum over
     intervals of variable length, not just e.g. 0 to inf.  Thus, since
     there is no formula for the general partial sum of the binomial
     series, `nusum' can't do it.

     `nusum' and `unsum' know a little about sums and differences of
     finite products.  See also `unsum'.

     Examples:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1


 -- Function: pade (<taylor_series>, <numer_deg_bound>,
          <denom_deg_bound>)
     Returns a list of all rational functions which have the given
     Taylor series expansion where the sum of the degrees of the
     numerator and the denominator is less than or equal to the
     truncation level of the power series, i.e.  are "best"
     approximants, and which additionally satisfy the specified degree
     bounds.

     <taylor_series> is a univariate Taylor series.  <numer_deg_bound>
     and <denom_deg_bound> are positive integers specifying degree
     bounds on the numerator and denominator.

     <taylor_series> can also be a Laurent series, and the degree
     bounds can be `inf' which causes all rational functions whose total
     degree is less than or equal to the length of the power series to
     be returned.  Total degree is defined as `<numer_deg_bound> +
     <denom_deg_bound>'.  Length of a power series is defined as
     `"truncation level" + 1 - min(0, "order of series")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     There is no rational function of degree 4 numerator/denominator,
     with this power series expansion.  You must in general have degree
     of the numerator and degree of the denominator adding up to at
     least the degree of the power series, in order to have enough
     unknown coefficients to solve.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]


 -- Option variable: powerdisp
     Default value: `false'

     When `powerdisp' is `true', a sum is displayed with its terms in
     order of increasing power.  Thus a polynomial is displayed as a
     truncated power series, with the constant term first and the
     highest power last.

     By default, terms of a sum are displayed in order of decreasing
     power.


 -- Function: powerseries (<expr>, <x>, <a>)
     Returns the general form of the power series expansion for <expr>
     in the variable <x> about the point <a> (which may be `inf' for
     infinity).

     If `powerseries' is unable to expand <expr>, `taylor' may give the
     first several terms of the series.

     When `verbose' is `true', `powerseries' prints progress messages.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2


 -- Option variable: psexpand
     Default value: `false'

     When `psexpand' is `true', an extended rational function
     expression is displayed fully expanded.  The switch `ratexpand'
     has the same effect.

     When `psexpand' is `false', a multivariate expression is displayed
     just as in the rational function package.

     When `psexpand' is  `multi', then terms with the same total degree
     in the variables are grouped together.


 -- Function: revert (<expr>, <x>)
 -- Function: revert2 (<expr>, <x>, <n>)
     These functions return the reversion of <expr>, a Taylor series
     about zero in the variable <x>.  `revert' returns a polynomial of
     degree equal to the highest power in <expr>.  `revert2' returns a
     polynomial of degree <n>, which may be greater than, equal to, or
     less than the degree of <expr>.

     `load ("revert")' loads these functions.

     Examples:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2


 -- Function: taylor (<expr>, <x>, <a>, <n>)
 -- Function: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Function: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Function: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
     `taylor (<expr>, <x>, <a>, <n>)' expands the expression <expr> in
     a truncated Taylor or Laurent series in the variable <x> around
     the point <a>, containing terms through `(<x> - <a>)^<n>'.

     If <expr> is of the form `<f>(<x>)/<g>(<x>)' and `<g>(<x>)' has no
     terms up to degree <n> then `taylor' attempts to expand `<g>(<x>)'
     up to degree `2 <n>'.  If there are still no nonzero terms,
     `taylor' doubles the degree of the expansion of `<g>(<x>)' so long
     as the degree of the expansion is less than or equal to `<n>
     2^taylordepth'.

     `taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' returns a
     truncated power series of degree <n> in all variables <x_1>,
     <x_2>, ...  about the point `(<a>, <a>, ...)'.

     `taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)'  returns a truncated power series in the variables <x_1>,
     <x_2>, ...  about the point `(<a_1>, <a_2>, ...)', truncated at
     <n_1>, <n_2>, ....

     `taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' returns a truncated power series in the variables
     <x_1>, <x_2>, ...  about the point `(<a_1>, <a_2>, ...)',
     truncated at <n_1>, <n_2>, ....

     `taylor (<expr>, [<x>, <a>, <n>, 'asymp])' returns an expansion of
     <expr> in negative powers of `<x> - <a>'.  The highest order term
     is `(<x> - <a>)^<-n>'.

     When `maxtayorder' is `true', then during algebraic manipulation
     of (truncated) Taylor series, `taylor' tries to retain as many
     terms as are known to be correct.

     When `psexpand' is `true', an extended rational function
     expression is displayed fully expanded.  The switch `ratexpand'
     has the same effect.  When `psexpand' is `false', a multivariate
     expression is displayed just as in the rational function package.
     When `psexpand' is  `multi', then terms with the same total degree
     in the variables are grouped together.

     See also the `taylor_logexpand' switch for controlling expansion.

     Examples:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360


 -- Option variable: taylordepth
     Default value: 3

     If there are still no nonzero terms, `taylor' doubles the degree
     of the expansion of `<g>(<x>)' so long as the degree of the
     expansion is less than or equal to `<n> 2^taylordepth'.


 -- Function: taylorinfo (<expr>)
     Returns information about the Taylor series <expr>.  The return
     value is a list of lists.  Each list comprises the name of a
     variable, the point of expansion, and the degree of the expansion.

     `taylorinfo' returns `false' if <expr> is not a Taylor series.

     Example:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]


 -- Function: taylorp (<expr>)
     Returns `true' if <expr> is a Taylor series, and `false' otherwise.


 -- Option variable: taylor_logexpand
     Default value: `true'

     `taylor_logexpand' controls expansions of logarithms in `taylor'
     series.

     When `taylor_logexpand' is `true', all logarithms are expanded
     fully so that zero-recognition problems involving logarithmic
     identities do not disturb the expansion process.  However, this
     scheme is not always mathematically correct since it ignores
     branch information.

     When `taylor_logexpand' is set to `false', then the only expansion
     of logarithms that occur is that necessary to obtain a formal
     power series.


 -- Option variable: taylor_order_coefficients
     Default value: `true'

     `taylor_order_coefficients' controls the ordering of coefficients
     in a Taylor series.

     When `taylor_order_coefficients' is `true', coefficients of taylor
     series are ordered canonically.


 -- Function: taylor_simplifier (<expr>)
     Simplifies coefficients of the power series <expr>.  `taylor'
     calls this function.


 -- Option variable: taylor_truncate_polynomials
     Default value: `true'

     When `taylor_truncate_polynomials' is `true', polynomials are
     truncated based upon the input truncation levels.

     Otherwise, polynomials input to `taylor' are considered to have
     infinite precison.


 -- Function: taytorat (<expr>)
     Converts <expr> from `taylor' form to canonical rational
     expression (CRE) form.  The effect is the same as `rat (ratdisrep
     (<expr>))', but faster.


 -- Function: trunc (<expr>)
     Annotates the internal representation of the general expression
     <expr> so that it is displayed as if its sums were truncated
     Taylor series.  <expr> is not otherwise modified.

     Example:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true


 -- Function: unsum (<f>, <n>)
     Returns the first backward difference `<f>(<n>) - <f>(<n> - 1)'.
     Thus `unsum' in a sense is the inverse of `sum'.

     See also `nusum'.

     Examples:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


 -- Option variable: verbose
     Default value: `false'

     When `verbose' is `true', `powerseries' prints progress messages.



File: maxima.info,  Node: Number Theory,  Next: Symmetries,  Prev: Series,  Up: Top

32 Number Theory
****************

* Menu:

* Definitions for Number Theory::


File: maxima.info,  Node: Definitions for Number Theory,  Prev: Number Theory,  Up: Number Theory

32.1 Definitions for Number Theory
==================================

 -- Function: bern (<n>)
     Returns the <n>'th Bernoulli number for integer <n>.  Bernoulli
     numbers equal to zero are suppressed if `zerobern' is `false'.

     See also `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798


 -- Function: bernpoly (<x>, <n>)
     Returns the <n>'th Bernoulli polynomial in the variable <x>.


 -- Function: bfzeta (<s>, <n>)
     Returns the Riemann zeta function for the argument <s>.  The
     return value is a big float (bfloat); <n> is the number of digits
     in the return value.

     `load ("bffac")' loads this function.


 -- Function: bfhzeta (<s>, <h>, <n>)
     Returns the Hurwitz zeta function for the arguments <s> and <h>.
     The return value is a big float (bfloat); <n> is the number of
     digits in the return value.

     The Hurwitz zeta function is defined as

          sum ((k+h)^-s, k, 0, inf)

     `load ("bffac")' loads this function.


 -- Function: binomial (<x>, <y>)
     The binomial coefficient `<x>!/(<y>! (<x> - <y>)!)'.  If <x> and
     <y> are integers, then the numerical value of the binomial
     coefficient is computed.  If <y>, or <x - y>, is an integer, the
     binomial coefficient is expressed as a polynomial.

     Examples:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)


 -- Function: burn (<n>)
     Returns the <n>'th Bernoulli number for integer <n>.  `burn' may
     be more efficient than `bern' for large, isolated <n> (perhaps <n>
     greater than 105 or so), as `bern' computes all the Bernoulli
     numbers up to index <n> before returning.

     `burn' exploits the observation that (rational) Bernoulli numbers
     can be approximated by (transcendental) zetas with tolerable
     efficiency.

     `load ("bffac")' loads this function.


 -- Function: cf (<expr>)
     Converts <expr> into a continued fraction.  <expr> is an expression
     comprising continued fractions and square roots of integers.
     Operands in the expression may be combined with arithmetic
     operators.  Aside from continued fractions and square roots,
     factors in the expression must be integer or rational numbers.
     Maxima does not know about operations on continued fractions
     outside of `cf'.

     `cf' evaluates its arguments after binding `listarith' to `false'.
     `cf' returns a continued fraction, represented as a list.

     A continued fraction `a + 1/(b + 1/(c + ...))' is represented by
     the list `[a, b, c, ...]'.  The list elements `a', `b', `c', ...
     must evaluate to integers.  <expr> may also contain `sqrt (n)'
     where `n' is an integer.  In this case `cf' will give as many
     terms of the continued fraction as the value of the variable
     `cflength' times the period.

     A continued fraction can be evaluated to a number by evaluating
     the arithmetic representation returned by `cfdisrep'.  See also
     `cfexpand' for another way to evaluate a continued fraction.

     See also `cfdisrep', `cfexpand', and `cflength'.

     Examples:

        * <expr> is an expression comprising continued fractions and
          square roots of integers.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controls how many periods of the continued fraction
          are computed for algebraic, irrational numbers.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * A continued fraction can be evaluated by evaluating the
          arithmetic representation returned by `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima does not know about operations on continued fractions
          outside of `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Function: cfdisrep (<list>)
     Constructs and returns an ordinary arithmetic expression of the
     form `a + 1/(b + 1/(c + ...))' from the list representation of a
     continued fraction `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2


 -- Function: cfexpand (<x>)
     Returns a matrix of the numerators and denominators of the last
     (column 1) and next-to-last (column 2) convergents of the
     continued fraction <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993//33102 = 3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902


 -- Option variable: cflength
     Default value: 1

     `cflength' controls the number of terms of the continued fraction
     the function `cf' will give, as the value `cflength' times the
     period.  Thus the default is to give one period.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


 -- Function: divsum (<n>, <k>)
 -- Function: divsum (<n>)
     `divsum (<n>, <k>)' returns the sum of the divisors of <n> raised
     to the <k>'th power.

     `divsum (<n>)' returns the sum of the divisors of <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210


 -- Function: euler (<n>)
     Returns the <n>'th Euler number for nonnegative integer <n>.

     For the Euler-Mascheroni constant, see `%gamma'.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]


 -- Constant: %gamma
     The Euler-Mascheroni constant, 0.5772156649015329 ....


 -- Function: factorial (<x>)
     Represents the factorial function. Maxima treats `factorial (<x>)'
     the same as `<x>!'.  See `!'.


 -- Function: fib (<n>)
     Returns the <n>'th Fibonacci number.  `fib(0)' equal to 0 and
     `fib(1)' equal to 1, and `fib (-<n>)' equal to `(-1)^(<n> + 1) *
     fib(<n>)'.

     After calling `fib', `prevfib' is equal to `fib (<x> - 1)', the
     Fibonacci number preceding the last one computed.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


 -- Function: fibtophi (<expr>)
     Expresses Fibonacci numbers in terms of the constant `%phi', which
     is `(1 + sqrt(5))/2', approximately 1.61803399.

     By default, Maxima does not know about `%phi'.  After executing
     `tellrat (%phi^2 - %phi - 1)' and `algebraic: true', `ratsimp' can
     simplify some expressions containing `%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) ratsimp (fibtophi (%));
          (%o3)                           0


 -- Function: inrt (<x>, <n>)
     Returns the integer <n>'th root of the absolute value of <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]


 -- Function: jacobi (<p>, <q>)
     Returns the Jacobi symbol of <p> and <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]


 -- Function: lcm (<expr_1>, ..., <expr_n>)
     Returns the least common multiple of its arguments.  The arguments
     may be general expressions as well as integers.

     `load ("functs")' loads this function.


 -- Function: minfactorial (<expr>)
     Examines <expr> for occurrences of two factorials which differ by
     an integer.  `minfactorial' then turns one into a polynomial times
     the other.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)


 -- Function: partfrac (<expr>, <var>)
     Expands the expression <expr> in partial fractions with respect to
     the main variable <var>.  `partfrac' does a complete partial
     fraction decomposition.  The algorithm employed is based on the
     fact that the denominators of the partial fraction expansion (the
     factors of the original denominator) are relatively prime.  The
     numerators can be written as linear combinations of denominators,
     and the expansion falls out.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)


 -- Function: primep (<n>)
     Returns `true' if `n' is a prime, `false' if not.


 -- Function: qunit (<n>)
     Returns the principal unit of the real quadratic number field
     `sqrt (<n>)' where <n> is an integer, i.e., the element whose norm
     is unity.  This amounts to solving Pell's equation `a^2 - <n> b^2
     = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1


 -- Function: totient (<n>)
     Returns the number of integers less than or equal to <n> which are
     relatively prime to <n>.


 -- Option variable: zerobern
     Default value: `true'

     When `zerobern' is `false', `bern' excludes the Bernoulli numbers
     which are equal to zero.  See `bern'.


 -- Function: zeta (<n>)
     Returns the Riemann zeta function if <x> is a negative integer, 0,
     1, or a positive even number, and returns a noun form `zeta (<n>)'
     for all other arguments, including rational noninteger, floating
     point, and complex arguments.

     See also `bfzeta' and `zeta%pi'.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90


 -- Option variable: zeta%pi
     Default value: `true'

     When `zeta%pi' is `true', `zeta' returns an expression
     proportional to `%pi^n' for even integer `n'.  Otherwise, `zeta'
     returns a noun form `zeta (n)' for even integer `n'.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)



File: maxima.info,  Node: Symmetries,  Next: Groups,  Prev: Number Theory,  Up: Top

33 Symmetries
*************

* Menu:

* Definitions for Symmetries::


File: maxima.info,  Node: Definitions for Symmetries,  Prev: Symmetries,  Up: Symmetries

33.1 Definitions for Symmetries
===============================

 -- Function: comp2pui (<n>, <l>)
     re'alise le passage des fonctions syme'triques comple`tes,
     donnee's dans la liste <l>, aux fonctions syme'triques
     e'le'mentaires de 0 a` <n>. Si la liste <l> contient moins de
     `<n>+1' e'le'ments les valeurs formelles viennent la completer. Le
     premier e'le'ment de la liste <l> donne le cardinal de l'alphabet
     si il existe, sinon on le met e'gal a <n>.

          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]


 -- Function: cont2part (<pc>, <lvar>)
     rend le polyno^me partitionne' associe' a` la forme  contracte'e
     <pc> dont les variables sont dans <lvar>.

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

     Autres fonctions de changements de repre'sentations :

     `contract', `explose', `part2cont', `partpol', `tcontract',
     `tpartpol'.


 -- Function: contract (<psym>, <lvar>)
     rend une forme contracte'e (i.e. un mono^me par orbite sous
     l'action du groupe syme'trique) du polyno^me <psym> en les
     variables contenues dans la liste <lvar>. La fonction `explose'
     re'alise l'ope'ration inverse. La fonction `tcontract' teste en
     plus la syme'trie du polyno^me.

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

     Autres fonctions de changements de repre'sentations :

     `cont2part', `explose', `part2cont', `partpol', `tcontract',
     `tpartpol'.


 -- Function: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     calcul l'image directe (voir M. GIUSTI, D. LAZARD et A. VALIBOUZE,
     ISSAC 1988, Rome) associe'e a` la fonction <f>, en les listes de
     variables <lvar_1>, ..., <lvar_n>, et aux polyno^mes <p_1>, ...,
     <p_n> d'une variable <y>. l'arite' de la fonction <f> est
     importante pour le calcul. Ainsi, si l'expression de <f> ne depend
     pas d'une variable, non seulement il est inutile de donner cette
     variable mais cela diminue conside'rablement lees calculs si on ne
     le fait pas.

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     Recherche du polyno^me dont les racines sont les somme a+u ou a est
     racine de z^2  - e1* z + e2 et u est racine de z^2  - f1* z + f2

          (%i1) ratsimp (direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     `direct' peut prendre deux drapeaux possibles : `elementaires' et
     `puissances' (valeur par de'faut) qui permettent de de'composer
     les polyno^mes syme'triques apparaissant dans ce calcul par les
     fonctions syme'triques e'le'mentaires ou les fonctions puissances
     respectivement.

     Fonctions de `sym' utilis'ees dans cette fonction :

     `multi_orbit' (donc `orbit'), `pui_direct', `multi_elem' (donc
     `elem'), `multi_pui' (donc `pui'), `pui2ele', `ele2pui' (si le
     drapeau `direct' est a` `puissances').


 -- Function: ele2comp (<m>, <l>)
     passe des fonctions syme'triques e'le'mentaires aux fonctions
     comple`tes. Similaire a` `comp2ele' et `comp2pui'.

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2pui', `elem', `mon2schur',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc', `schur2comp'.


 -- Function: ele2polynome (<l>, <z>)
     donne le polyno^me en <z> dont les fonctions syme'triques
     e'le'mentaires des racines sont dans la liste <l>.  `<l> = [<n>,
     <e_1>, ..., <e_n>]' ou` <n> est le degre' du polyno^me et <e_i> la
     <i>-ie`me fonction syme'trique e'le'mentaire.

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22

     La re'ciproque: `polynome2ele (<P>, <z>)'

     Autres fonctions a` voir :

     `polynome2ele', `pui2polynome'.


 -- Function: ele2pui (<m>, <l>)
     passe des fonctions syme'triques e'le'mentaires aux fonctions
     comple`tes. Similaire a` `comp2ele' et `comp2pui'.

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `elem', `mon2schur',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc', `schur2comp'.


 -- Function: elem (<ele>, <sym>, <lvar>)
     de'compose le polyno^me syme'trique <sym>, en les variables
     contenues de la liste <lvar>, par les fonctions syme'triques
     e'le'mentaires contenues dans la liste <ele>. Si le premier
     e'le'ment de <ele> est donne' ce sera le cardinal de l'alphabet
     sinon on prendra le degre' du polyno^me <sym>. Si il manque des
     valeurs a` la liste <ele> des valeurs formelles du type "ei" sont
     rajoute'es. Le polyno^me <sym> peut etre donne' sous 3 formes
     diffe'rentes : contracte'e (`elem' doit alors valoir 1 sa valeur
     par de'faut), partitionne'e (`elem' doit alors valoir 3) ou
     e'tendue (i.e. le polyno^me en entier) (`elem' doit alors valoir
     2). L'utilsation de la fonction `pui' se re'alise sur le me^me
     mode`le.

     Sur un alphabet de cardinal 3 avec e1, la premie`re fonction
     syme'trique e'le'mentaire, valant 7, le polyno^me syme'trique en 3
     variables dont la forme contracte'e (ne de'pendant ici que de deux
     de ses variables) est x^4-2*x*y se de'compose ainsi en les
     fonctions syme'triques e'le'mentaires :

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `mon2schur',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc', `schur2comp'.


 -- Function: explose (<pc>, <lvar>)
     rend le polyno^me syme'trique associe' a` la forme contracte'e
     <pc>. La liste <lvar> contient les variables.

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

     Autres fonctions de changements de repre'sentations :

     `contract', `cont2part', `part2cont', `partpol', `tcontract',
     `tpartpol'.


 -- Function: kostka (<part_1>, <part_2>)
     e'crite par P. ESPERET, calcule le nombre de Kostka associe' aux
     partition <part_1> et <part_2>.

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6


 -- Function: lgtreillis (<n>, <m>)
     rend la liste des partitions de poids <n> et de longueur <m>.

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]

     Voir e'galement : `ltreillis', `treillis' et `treinat'.


 -- Function: ltreillis (<n>, <m>)
     rend la liste des partitions de poids <n> et de longueur
     infe'rieure ou e'gale a` <m>.

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]

     Voir e'galement : `lgtreillis', `treillis' et `treinat'.


 -- Function: mon2schur (<l>)
     la liste <l> repre'sente la fonction de Schur S_<l>:  On a <l> =
     [<i_1>, <i_2>, ..., <i_q>] avec <i_1> <= <i_2> <= ... <= <i_q>.
     La fonction de Schur est S_[<i_1>, <i_2>, ..., <i_q>] est le
     mineur de la matrice infinie (h_{i-j}) <i> >= 1, <j> >= 1 compose'
     des q premie`res lignes et des colonnes <i_1> + 1, <i_2> + 2, ...,
     <i_q> + <q>.

     On e'crit cette fonction de Schur en fonction des formes
     monomiales en utilisant les fonctions `treinat' et `kostka'. La
     forme rendue est un polyno^me syme'trique dans une de ses
     repre'sentations contracte'es avec les variables <x_1>, <x_2>, ....

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     ce qui veut dire que pour 3 variables cela donne :

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem',
     `multi_elem', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc', `schur2comp'.


 -- Function: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     de'compose un polyno^me multi-syme'trique sous la forme
     multi-contracte'e <multi_pc> en les groupes de variables contenue
     dans la liste de listes <l_var> sur les groupes de fonctions
     syme'triques e'le'mentaires contenues dans <l_elem>.

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem',
     `mon2schur', `multi_pui', `pui', `pui2comp', `pui2ele',
     `puireduc', `schur2comp'.


 -- Function: multi_orbit (<P>, [<lvar_1>, <lvar_2>, ..., <lvar_p>])
     <P> est un polyno^me en l'ensemble des variables contenues dans
     les listes <lvar_1>, <lvar_2>, ..., <lvar_p>.  Cette fonction
     rame`ne l'orbite du polyno^me <P> sous l'action du produit des
     groupes syme'triques des ensembles de variables repre'sente's par
     ces <p> listes.

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]

     Voir e'galement : `orbit' pour l'action d'un seul groupe
     syme'trique.


 -- Function: multi_pui
     est a` la fonction `pui' ce que la fonction `multi_elem' est a` la
     fonction `elem'.

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3, [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2


 -- Function: multinomial (<r>, <part>)
     ou` <r> est le poids de la partition <part>. Cette fonction
     rame`ne le coefficient multinomial associe' : si les parts de la
     partitions part sont <i_1>, <i_2>, ..., <i_k>, le re'sultat de
     `multinomial' est `<r>!/(<i_1>! <i_2>! ... <i_k>!)'.


 -- Function: multsym (<ppart_1>, <ppart_2>, <n>)
     re'alise le produit de deux polyno^mes syme'triques de <n>
     variables en ne travaillant que modulo l'action du groupe
     syme'trique d'ordre <n>. Les polyno^mes sont dans leur
     repre'sentation partitionne'e.

     Soient les 2 polyno^mes syme'triques en `x', `y': `3*(x + y) +
     2*x*y' et `5*(x^2 + y^2)' dont les formes partitionne'es sont
     respectivement `[[3, 1], [2, 1, 1]]' et `[[5, 2]]', alors leur
     produit sera donne' par :

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]

     soit `10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 + y^3)'.

     Fonctions de changements de repre'sentations d'un polyno^me
     syme'trique :

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tcontract', `tpartpol'.


 -- Function: orbit (<P>, <lvar>)
     calcul l'orbite du polyno^me <P> en les variables de la liste
     <lvar> sous l'action du groupe syme'trique de l'ensemble des
     variables contenues dans la liste <lvar>.

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]

     Voir e'galement : `multi_orbit' pour l'action d'un produit de
     groupes syme'triques sur un polyno^me.


 -- Function: part2cont (<ppart>, <lvar>)
     passe de la forme partitionne'e a` la forme contracte'e d'un
     polyno^me syme'trique. La forme contracte'e est rendue avec les
     variables contenues dans <lvar>.

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

     Autres fonctions de changements de repre'sentations :

     `contract', `cont2part', `explose', `partpol', `tcontract',
     `tpartpol'.


 -- Function: partpol (<psym>, <lvar>)
     <psym> est un polyno^me syme'trique en les variables de <lvar>.
     Cette fonction rame`ne sa repre'sentation partitionne'e.

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]

     Autres fonctions de changements de repre'sentations :

     `contract', `cont2part', `explose', `part2cont', `tcontract',
     `tpartpol'.


 -- Function: permut (<l>)
     rame`ne la liste des permutations de la liste <l>.


 -- Function: polynome2ele (<P>, <x>)
     donne la liste `<l> = [<n>, <e_1>, ..., <e_n>]' ou` <n> est le
     degre' du polyno^me <P> en la variable <x> et <e_i> la <i>-ieme
     fonction syme'trique e'le'mentaire des racines de <P>.

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22

     La re'ciproque : `ele2polynome (<l>, <x>)'


 -- Function: prodrac (<l>, <k>)
     <l> est une liste contenant les fonctions syme'triques
     e'le'mentaires sur un ensemble <A>. `prodrac' rend le polyno^me
     dont les racines sont les produits <k> a` <k> des e'le'ments de
     <A>.


 -- Function: pui (<l>, <sym>, <lvar>)
     de'compose le polyno^me syme'trique <sym>, en les variables
     contenues de la liste <lvar>, par les fonctions puissances
     contenues dans la liste <l>. Si le premier e'le'ment de <l> est
     donne' ce sera le cardinal de l'alphabet sinon on prendra le
     degre' du polyno^me <sym>. Si il manque des valeurs a` la liste
     <l>, des valeurs formelles du type "pi" sont rajoute'es. Le
     polyno^me sym peut etre donne' sous 3 formes diffe'rentes :
     contracte'e (`pui' doit alors valoir 1 sa valeur par de'faut),
     partitionne'e (`pui' doit alors valoir 3) ou e'tendue (i.e. le
     polyno^me en entier) (`pui' doit alors valoir 2). La fonction
     `elem' s'utilise de la me^me manie`re.

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem', `mon2schur',
     `multi_elem', `multi_pui', `pui2comp', `pui2ele', `puireduc',
     `schur2comp'.


 -- Function: pui2comp (<n>, <lpui>)
     rend la liste des <n> premie`res fonctions comple`tes (avec en
     te^te le cardinal) en fonction des fonctions puissance donne'es
     dans la liste <lpui>. Si la liste <lpui> est vide le cardinal est
     N sinon c'est son premier e'le'ment similaire a` `comp2ele' et
     `comp2pui'.

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem',
     `mon2schur', `multi_elem', `multi_pui', `pui', `pui2ele',
     `puireduc', `schur2comp'.


 -- Function: pui2ele (<n>, <lpui>)
     re'alise le passage des fonctions puissances aux fonctions
     syme'triques e'le'mentaires.  Si le drapeau `pui2ele' est
     `girard', on re'cupe`re la liste des fonctions syme'triques
     e'le'mentaires de 1 a` <n>, et s'il est e'gal a` `close', la
     <n>-ie`me fonction syme'trique e'le'mentaire.

     Autres fonctions de changements de bases :

     `comp2ele', `comp2pui', `ele2comp', `ele2pui', `elem',
     `mon2schur', `multi_elem', `multi_pui', `pui', `pui2comp',
     `puireduc', `schur2comp'.


 -- Function: pui2polynome (<x>, <lpui>)
     calcul le polyno^me en <x> dont les fonctions puissances des
     racines sont donne'es dans la liste <lpui>.

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1

     Autres fonctions a` voir : `polynome2ele', `ele2polynome'.


 -- Function: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])
     Soit <f> un polynome en <n> blocs de variables <lvar_1>, ...,
     <lvar_n>.  Soit <c_i> le nombre de variables dans <lvar_i> . Et
     <SC> le produit des <n> groupes syme'triques de degre' <c_1>, ...,
     <c_n>. Ce groupe agit naturellement sur <f>.  La liste <orbite>
     est l'orbite, note'e `<SC>(<f>)', de la fonction <f> sous l'action
     de <SC>. (Cette liste peut e^tre obtenue avec la fonction :
     `multi_orbit').  Les di sont des entiers tels que <c_1> <= <d_1>,
     <c_2> <= <d_2>, ..., <c_n> <= <d_n>.  Soit <SD> le produit des
     groupes syme'triques <S_d1> x <S_d2> x ... x <S_dn>.

     La fonction `pui_direct' rame`ne les <n> premie`res fonctions
     puissances de `<SD>(<f>)' de'duites des fonctions puissances de
     `<SC>(<f>)' ou` <n> est le cardinal de `<SD>(<f>)'.

     Le re'sultat est rendue sous forme multi-contracte'e par rapport a
     <SD>.  i.e. on ne conserve qu'un e'le'ment par orbite sous
     l'action de <SD>).

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a], [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]


 -- Function: puireduc (<n>, <lpui>)
     <lpui> est une liste dont le premier e'le'ment est un entier <m>.
     `puireduc' donne les <n> premie`res fonctions puissances en
     fonction des <m> premie`res.

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2


 -- Function: resolvante (<P>, <x>, <f>, [<x_1>, ..., <x_d>])
     calcule la re'solvante du polyno^me <P> de la variable <x> et de
     degre' <n> >= <d> par la fonction <f> exprime'e en les variables
     <x_1>, ..., <x_d>. Il est important pour l'efficacite' des calculs
     de ne pas mettre dans la liste `[<x_1>, ..., <x_d>]' les variables
     n'intervenant pas dans la fonction de transformation <f>.

     Afin de rendre plus efficaces les calculs on peut mettre des
     drapeaux a` la variable `resolvante' afin que des algorithmes
     ade'quates soient utilise's :

     Si la fonction <f> est unitaire :
        * un polyno^me d'une variable,

        *   line'aire ,

        *   alterne'e,

        *   une somme de variables,

        *   syme'trique en les variables qui apparaissent dans son
          expression,

        *   un produit de variables,

        * la fonction de la re'solvante de Cayley (utilisable qu'en
          degre' 5)

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          generale,
     le drapeau de `resolvante' pourra e^tre respectivement :
        *   unitaire,

        *   lineaire,

        *   alternee,

        *   somme,

        *   produit,

        *   cayley,

        *   generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1, [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840, - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvante de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     Pour la re'solvante de Cayley, les 2 derniers arguments sont
     neutres et le polyno^me donne' en entre'e doit ne'cessairement
     e^tre de degre' 5.

     Voir e'galement :

     `resolvante_bipartite', `resolvante_produit_sym',
     `resolvante_unitaire', `resolvante_alternee1', `resolvante_klein',
     `resolvante_klein3', `resolvante_vierer', `resolvante_diedrale'.


 -- Function: resolvante_alternee1 (<P>, <x>)
     calcule la transformation de `<P>(<x>)' de degre <n> par la
     fonction $\prod_{1\leq i<j\leq n-1} (x_i-x_j)$.

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante' ,
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_bipartite'.


 -- Function: resolvante_bipartite (<P>, <x>)
     calcule la transformation de `<P>(<x>)' de degre <n> (<n> pair)
     par la fonction $x_1x_2\ldots x_{n/2}+x_{n/2+1}\ldotsx_n$

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante' ,
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_alternee1'.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire', `resolvante',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale', `resolvante_alternee1'.


 -- Function: resolvante_diedrale (<P>, <x>)
     calcule la transformation de `<P>(<x>)' par la fonction `<x_1>
     <x_2> + <x_3> <x_4>'.

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante_vierer', `resolvante'.


 -- Function: resolvante_klein (<P>, <x>)
     calcule la transformation de `<P>(<x>)' par la fonction `<x_1>
     <x_2> <x_4> + <x_4>'.

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante', `resolvante_klein3',
     `resolvante_vierer', `resolvante_diedrale'.


 -- Function: resolvante_klein3 (<P>, <x>)
     calcule la transformation de `<P>(<x>)' par la fonction `<x_1>
     <x_2> <x_4> + <x_4>'.

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante',
     `resolvante_vierer', `resolvante_diedrale'.


 -- Function: resolvante_produit_sym (<P>, <x>)
     calcule la liste toutes les r\'esolvantes produit du polyn\^ome
     `<P>(<x>)'.

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvante produit "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     Voir e'galement :

     `resolvante', `resolvante_unitaire', `resolvante_alternee1',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale'.


 -- Function: resolvante_unitaire (<P>, <Q>, <x>)
     calcule la r\'esolvante du polyn\^ome `<P>(<x>)' par le polyn\^ome
     `<Q>(<x>)'.

     Voir e'galement :

     `resolvante_produit_sym', `resolvante', `resolvante_alternee1',
     `resolvante_klein', `resolvante_klein3', `resolvante_vierer',
     `resolvante_diedrale'.


 -- Function: resolvante_vierer (<P>, <x>)
     calcule la transformation de `<P>(<x>)' par la fonction `<x_1>
     <x_2> - <x_3> <x_4>'.

     Voir e'galement :

     `resolvante_produit_sym', `resolvante_unitaire',
     `resolvante_alternee1', `resolvante_klein', `resolvante_klein3',
     `resolvante', `resolvante_diedrale'.


 -- Function: schur2comp (<P>, <l_var>)
     <P> est un polyno^mes en les variables contenues dans la liste
     <l_var>. Chacune des variables de <l_var> repre'sente une fonction
     syme'trique comple`te. On repre'sente dans <l_var> la ie`me
     fonction syme'trique comple`te comme la concate'nation de la
     lettre `h' avec l'entier <i> : `h<i>'.  Cette fonction donne
     l'expression de <P> en fonction des fonctions de Schur.

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3


 -- Function: somrac (<l>, <k>)
     la liste <l> contient les fonctions syme'triques e'le'mentaires
     d'un polyno^me <P> . On calcul le polyno^mes dont les racines sont
     les sommes <K> a` <K> distinctes des racines de <P>.

     Voir e'galement `prodrac'.


 -- Function: tcontract (<pol>, <lvar>)
     teste si le polyno^me pol est syme'trique en les variables
     contenues dans la liste <lvar>. Si oui il rend une forme
     contracte'e comme la fonction `contract'.

     Autres fonctions de changements de repre'sentations :

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tpartpol'.


 -- Function: tpartpol (<pol>, <lvar>)
     teste si le polyno^me pol est syme'trique en les variables
     contenues dans la liste <lvar>. Si oui il rend sa forme partionne'e
     comme la fonction `partpol'.

     Autres fonctions de changements de repre'sentations :

     `contract', `cont2part', `explose', `part2cont', `partpol',
     `tcontract'.


 -- Function: treillis (<n>)
     rame`ne toutes les partitions de poids <n>.

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Voir e'galement : `lgtreillis', `ltreillis' et `treinat'.


 -- Function: treinat (<part>)
     rame`ne la liste des partitions infe'rieures a` la partition
     <part> pour l'ordre naturel.

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     Voir e'galement : `lgtreillis', `ltreillis' et `treillis'.



File: maxima.info,  Node: Groups,  Next: Runtime Environment,  Prev: Symmetries,  Up: Top

34 Groups
*********

* Menu:

* Definitions for Groups::


File: maxima.info,  Node: Definitions for Groups,  Prev: Groups,  Up: Groups

34.1 Definitions for Groups
===========================

 -- Function: todd_coxeter (<relations>, <subgroup>)
 -- Function: todd_coxeter (<relations>)
     Find the order of G/H where G is the Free Group modulo
     <relations>, and H is the subgroup of G generated by <subgroup>.
     <subgroup> is an optional argument, defaulting to [].  In doing
     this it produces a multiplication table for the right action of G
     on G/H, where the cosets are enumerated [H,Hg2,Hg3,...].  This can
     be seen internally in the `$todd_coxeter_state'.

     The multiplication tables for the variables are in
     `table:todd_coxeter_state[2]'.  Then `table[i]' gives the table for
     the ith variable.  `mulcoset(coset,i) := table[varnum][coset];'

     Example:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20
          (%i7) table:todd_coxeter_state[2]$
          (%i8) table[1];
          (%o8) {Array: (SIGNED-BYTE 30) #(0 2 1 3 7 6 5 4 8 11 17 9 12 14 #

          13 20 16 10 18 19 15 0 0 0 0 0 0 0 0 0 0 0 0

            0 0 0)}

     Note only the elements 1 thru 20 of this array `%o8' are
     meaningful.  `table[1][4] = 7' indicates coset4.var1 = coset7



File: maxima.info,  Node: Runtime Environment,  Next: Miscellaneous Options,  Prev: Groups,  Up: Top

35 Runtime Environment
**********************

* Menu:

* Introduction for Runtime Environment::
* Interrupts::
* Definitions for Runtime Environment::


File: maxima.info,  Node: Introduction for Runtime Environment,  Next: Interrupts,  Prev: Runtime Environment,  Up: Runtime Environment

35.1 Introduction for Runtime Environment
=========================================

`maxima-init.mac' is a file which is loaded automatically when Maxima
starts.  You can use `maxima-init.mac' to customize your Maxima
environment.  `maxima-init.mac', if it exists, is typically placed in
the directory named by `:lisp (default-userdir)', although it can be in
any directory searched by the function `file_search'.

   Here is an example `maxima-init.mac' file:

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   In this example, `setup_autoload' tells Maxima to load the specified
file (`specfun.mac') if any of the functions (`ultraspherical',
`assoc_legendre_p') are called but not yet defined.  Thus you needn't
remember to load the file before calling the functions.

   The statement `showtime: all' tells Maxima to set the `showtime'
variable.  The `maxima-init.mac' file can contain any other assignments
or other Maxima statements.


File: maxima.info,  Node: Interrupts,  Next: Definitions for Runtime Environment,  Prev: Introduction for Runtime Environment,  Up: Runtime Environment

35.2 Interrupts
===============

The user can stop a time-consuming computation with the ^C (control-C)
character.  The default action is to stop the computation and print
another user prompt.  In this case, it is not possible to restart a
stopped computation.

   If the variable `*debugger-hook*' is set to `nil', by executing

     :lisp (setq *debugger-hook* nil)

then upon receiving ^C, Maxima will enter the Lisp debugger, and the
user may use the debugger to inspect the Lisp environment.  The stopped
computation can be restarted by entering `continue' in the Lisp
debugger.  The means of returning to Maxima from the Lisp debugger
(other than running the computation to completion) is different for
each version of Lisp.

   On Unix systems, the character ^Z (control-Z) causes Maxima to stop
altogether, and control is returned to the shell prompt.  The `fg'
command causes Maxima to resume from the point at which it was stopped.


File: maxima.info,  Node: Definitions for Runtime Environment,  Prev: Interrupts,  Up: Runtime Environment

35.3 Definitions for Runtime Environment
========================================

 -- Declaration: feature
     Maxima understands two distinct types of features, system features
     and features which apply to mathematical expressions.  See also
     `status' for information about system features.  See also
     `features' and `featurep' for information about mathematical
     features.

     `feature' itself is not the name of a function or variable.


 -- Function: featurep (<a>, <f>)
     Attempts to determine whether the object <a> has the feature <f>
     on the basis of the facts in the current database.  If so, it
     returns `true', else `false'.

     Note that `featurep' returns `false' when neither <f> nor the
     negation of <f> can be established.

     `featurep' evaluates its argument.

     See also `declare' and `features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true


 -- Function: room ()
 -- Function: room (true)
 -- Function: room (false)
     Prints out a description of the state of storage and stack
     management in Maxima. `room' calls the Lisp function of the same
     name.

        * `room ()' prints out a moderate description.

        * `room (true)' prints out a verbose description.

        * `room (false)' prints out a terse description.


 -- Function: status (feature)
 -- Function: status (feature, <putative_feature>)
 -- Function: status (status)
     Returns information about the presence or absence of certain
     system-dependent features.

        * `status (feature)' returns a list of system features.  These
          include Lisp version, operating system type, etc.  The list
          may vary from one Lisp type to another.

        * `status (feature, <putative_feature>)' returns `true' if
          <putative_feature> is on the list of items returned by
          `status (feature)' and `false' otherwise.  `status' quotes
          the argument <putative_feature>.  The double single quotes
          operator, `''', defeats the quotation.  A feature whose name
          contains a special character, such as a hyphen, must be given
          as a string argument. For example, `status (feature,
          "ansi-cl")'.

        * `status (status)' returns a two-element list `[feature,
          status]'.  `feature' and `status' are the two arguments
          accepted by the `status' function; it is unclear if this list
          has additional significance.

     The variable `features' contains a list of features which apply to
     mathematical expressions. See `features' and `featurep' for more
     information.


 -- Function: time (%o1, %o2, %o3, ...)
     Returns a list of the times, in seconds, taken to compute the
     output lines `%o1', `%o2', `%o3', .... The time returned is
     Maxima's estimate of the internal computation time, not the
     elapsed time. `time' can only be applied to output line variables;
     for any other variables, `time' returns `unknown'.

     Set `showtime: true' to make Maxima print out the computation time
     and elapsed time with each output line.


 -- Function: timedate ()
     Returns a string representing the current time and date.  The
     string has the format `HH:MM:SS Day, mm/dd/yyyy (GMT-n)', where
     the fields are hours, minutes, seconds, day of week, month, day of
     month, year, and hours different from GMT.

     The return value is a Lisp string.

     Example:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate reports current time", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)



File: maxima.info,  Node: Miscellaneous Options,  Next: Rules and Patterns,  Prev: Runtime Environment,  Up: Top

36 Miscellaneous Options
************************

* Menu:

* Introduction to Miscellaneous Options::
* Share::
* Definitions for Miscellaneous Options::


File: maxima.info,  Node: Introduction to Miscellaneous Options,  Next: Share,  Prev: Miscellaneous Options,  Up: Miscellaneous Options

36.1 Introduction to Miscellaneous Options
==========================================

In this section various options are discussed which have a global effect
on the operation of Maxima.   Also various lists such as the list of all
user defined functions, are discussed.


File: maxima.info,  Node: Share,  Next: Definitions for Miscellaneous Options,  Prev: Introduction to Miscellaneous Options,  Up: Miscellaneous Options

36.2 Share
==========

The Maxima "share" directory contains programs and other files of
interest to Maxima users, but not part of the core implementation of
Maxima.  These programs are typically loaded via `load' or
`setup_autoload'.

   `:lisp *maxima-sharedir*' displays the location of the share
directory within the user's file system.

   `printfile ("share.usg")' prints an out-of-date list of share
packages.  Users may find it more informative to browse the share
directory using a file system browser.


File: maxima.info,  Node: Definitions for Miscellaneous Options,  Prev: Share,  Up: Miscellaneous Options

36.3 Definitions for Miscellaneous Options
==========================================

 -- System variable: aliases
     Default value: `[]'

     `aliases' is the list of atoms which have a user defined alias
     (set up by the `alias', `ordergreat', `orderless' functions or by
     declaring the atom a `noun' with `declare').

 -- Declaration: alphabetic
     `declare (<char>, alphabetic)' adds `char' to Maxima's alphabet,
     which initially contains the letters `A' through `Z', `a' through
     `z', `%' and `_'.  <char> is specified as a string of length 1,
     e.g., `"~"'.

          (%i1) declare ("~", alphabetic);
          (%o1)                         done
          (%i2) foo~bar;
          (%o2)                        foo~bar
          (%i3) atom (foo~bar);
          (%o3)                         true


 -- Function: apropos (<string>)
     Searches for Maxima names which have <string> appearing anywhere
     within them.  Thus, `apropos (exp)' returns a list of all the flags
     and functions which have `exp' as part of their names, such as
     `expand', `exp', and `exponentialize'.  Thus if you can only
     remember part of the name of something you can use this command to
     find the rest of the name.  Similarly, you could say `apropos
     (tr_)' to find a list of many of the switches relating to the
     translator, most of which begin with `tr_'.


 -- Function: args (<expr>)
     Returns the list of arguments of `expr', which may be any kind of
     expression other than an atom.  Only the arguments of the
     top-level operator are extracted; subexpressions of `expr' appear
     as elements or subexpressions of elements of the list of arguments.

     The order of the items in the list may depend on the global flag
     `inflag'.

     `args (<expr>)' is equivalent to `substpart ("[", <expr>, 0)'.
     See also `substpart'.

     See also `op'.


 -- Option variable: genindex
     Default value: `i'

     `genindex' is the alphabetic prefix used to generate the next
     variable of summation when necessary.


 -- Option variable: gensumnum
     Default value: 0

     `gensumnum' is the numeric suffix used to generate the next
     variable of summation.  If it is set to `false' then the index
     will consist only of `genindex' with no numeric suffix.


 -- Constant: inf
     Real positive infinity.


 -- Constant: infinity
     Complex infinity, an infinite magnitude of arbitrary phase angle.
     See also `inf' and `minf'.


 -- System variable: infolists
     Default value: `[]'

     `infolists' is a list of the names of all of the information lists
     in Maxima. These are:

    `labels'
          All bound `%i', `%o', and `%t' labels.

    `values'
          All bound atoms which are user variables, not Maxima options
          or switches, created by `:' or `::' or functional binding.

    `functions'
          All user-defined functions, created by `:=' or `define'.

    `arrays'
          All declared and undeclared arrays, created by `:', `::', or
          `:='.

    `macros'
          All user-defined macro functions.

    `myoptions'
          All options ever reset by the user (whether or not they are
          later reset to their default values).

    `rules'
          All user-defined pattern matching and simplification rules,
          created by `tellsimp', `tellsimpafter', `defmatch', or
          `defrule'.

    `aliases'
          All atoms which have a user-defined alias, created by the
          `alias', `ordergreat', `orderless' functions or by declaring
          the atom as a `noun' with `declare'.

    `dependencies'
          All atoms which have functional dependencies, created by the
          `depends' or `gradef' functions.

    `gradefs'
          All functions which have user-defined derivatives, created by
          the `gradef' function.

    `props'
          All atoms which have any property other than those mentioned
          above, such as properties established by `atvalue' or
          `matchdeclare', etc., as well as properties established in
          the `declare' function.

    `let_rule_packages'
          All user-defined `let' rule packages plus the special package
          `default_let_rule_package'.  (`default_let_rule_package' is
          the name of the rule package used when one is not explicitly
          set by the user.)


 -- Function: integerp (<expr>)
     Returns `true' if <expr> is a literal numeric integer, otherwise
     `false'.

     `integerp' returns false if its argument is a symbol, even if the
     argument is declared integer.

     Examples:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Option variable: m1pbranch
     Default value: `false'

     `m1pbranch' is the principal branch for `-1' to a power.
     Quantities such as `(-1)^(1/3)' (that is, an "odd" rational
     exponent) and `(-1)^(1/4)' (that is, an "even" rational exponent)
     are handled as follows:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Function: numberp (<expr>)
     Returns `true' if <expr> is a literal integer, rational number,
     floating point number, or bigfloat, otherwise `false'.

     `numberp' returns false if its argument is a symbol, even if the
     argument is a symbolic number such as `%pi' or `%i', or declared
     to be even, odd, integer, rational, irrational, real, imaginary,
     or complex.

     Examples:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Function: properties (<a>)
     Returns a list of the names of all the properties associated with
     the atom <a>.


 -- Special symbol: props
     `props' are atoms which have any property other than those
     explicitly mentioned in `infolists', such as atvalues,
     matchdeclares, etc., as well as properties specified in the
     `declare' function.


 -- Function: propvars (<prop>)
     Returns a list of those atoms on the `props' list which have the
     property indicated by <prop>.  Thus `propvars (atvalue)' returns a
     list of atoms which have atvalues.


 -- Function: put (<atom>, <value>, <indicator>)
     Assigns <value> to the property (specified by <indicator>) of
     <atom>.  <indicator> may be the name of any property, not just a
     system-defined property.

     `put' evaluates its arguments.  `put' returns <value>.

     Examples:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Function: qput (<atom>, <value>, <indicator>)
     Assigns <value> to the property (specified by <indicator>) of
     <atom>.  This is the same as `put', except that the arguments are
     quoted.

     Example:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Function: rem (<atom>, <indicator>)
     Removes the property indicated by <indicator> from <atom>.


 -- Function: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Function: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Function: remove ("<a>", operator)
 -- Function: remove (<a>, transfun)
 -- Function: remove (all, <p>)
     Removes properties associated with atoms.

     `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' removes property `p_k'
     from atom `a_k'.

     `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' removes
     properties `<p_1>, ..., <p_n>' from atoms <a_1>, ..., <a_m>.
     There may be more than one pair of lists.

     `remove (all, <p>)' removes the property <p> from all atoms which
     have it.

     The removed properties may be system-defined properties such as
     `function', `macro', or `mode_declare', or user-defined properties.

     A property may be `transfun' to remove the translated Lisp version
     of a function.  After executing this, the Maxima version of the
     function is executed rather than the translated version.

     `remove ("<a>", operator)' or, equivalently, `remove ("<a>", op)'
     removes from <a> the operator properties declared by `prefix',
     `infix', `nary', `postfix', `matchfix', or `nofix'.  Note that the
     name of the operator must be written as a quoted string.

     `remove' always returns `done' whether or not an atom has a
     specified property.  This behavior is unlike the more specific
     remove functions `remvalue', `remarray', `remfunction', and
     `remrule'.


 -- Function: remvalue (<name_1>, ..., <name_n>)
 -- Function: remvalue (all)
     Removes the values of user variables <name_1>, ..., <name_n>
     (which can be subscripted) from the system.

     `remvalue (all)' removes the values of all variables in `values',
     the list of all variables given names by the user (as opposed to
     those which are automatically assigned by Maxima).

     See also `values'.


 -- Function: rncombine (<expr>)
     Transforms <expr> by combining all terms of <expr> that have
     identical denominators or denominators that differ from each other
     by numerical factors only.  This is slightly different from the
     behavior of `combine', which collects terms that have identical
     denominators.

     Setting `pfeformat: true' and using `combine' yields results
     similar to those that can be obtained with `rncombine', but
     `rncombine' takes the additional step of cross-multiplying
     numerical denominator factors.  This results in neater forms, and
     the possibility of recognizing some cancellations.


 -- Function: scalarp (<expr>)
     Returns `true' if <expr> is a number, constant, or variable
     declared `scalar' with `declare', or composed entirely of numbers,
     constants, and such variables, but not containing matrices or
     lists.


 -- Function: setup_autoload (<filename>, <function_1>, ...,
          <function_n>)
     Specifies that if any of <function_1>, ..., <function_n> are
     referenced and not yet defined, <filename> is loaded via `load'.
     <filename> usually contains definitions for the functions
     specified, although that is not enforced.

     `setup_autoload' does not work for array functions.

     `setup_autoload' quotes its arguments.

     Example:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2



File: maxima.info,  Node: Rules and Patterns,  Next: Lists,  Prev: Miscellaneous Options,  Up: Top

37 Rules and Patterns
*********************

* Menu:

* Introduction to Rules and Patterns::
* Definitions for Rules and Patterns::


File: maxima.info,  Node: Introduction to Rules and Patterns,  Next: Definitions for Rules and Patterns,  Prev: Rules and Patterns,  Up: Rules and Patterns

37.1 Introduction to Rules and Patterns
=======================================

This section describes user-defined pattern matching and simplification
rules.  There are two groups of functions which implement somewhat
different pattern matching schemes.  In one group are `tellsimp',
`tellsimpafter', `defmatch', `defrule', `apply1', `applyb1', and
`apply2'.  In the other group are `let' and `letsimp'.  Both schemes
define patterns in terms of pattern variables declared by
`matchdeclare'.

   Pattern-matching rules defined by `tellsimp' and `tellsimpafter' are
applied automatically by the Maxima simplifier.  Rules defined by
`defmatch', `defrule', and `let' are applied by an explicit function
call.

   There are additional mechanisms for rules applied to polynomials by
`tellrat', and for commutative and noncommutative algebra in `affine'
package.


File: maxima.info,  Node: Definitions for Rules and Patterns,  Prev: Introduction to Rules and Patterns,  Up: Rules and Patterns

37.2 Definitions for Rules and Patterns
=======================================

 -- Function: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repeatedly applies <rule_1> to <expr> until it fails, then
     repeatedly applies the same rule to all subexpressions of <expr>,
     left to right, until <rule_1> has failed on all subexpressions.
     Call the result of transforming <expr> in this manner <expr_2>.
     Then <rule_2> is applied in the same fashion starting at the top
     of <expr_2>.  When <rule_n> fails on the final subexpression, the
     result is returned.

     `maxapplydepth' is the depth of the deepest subexpressions
     processed by `apply1' and `apply2'.

     See also `applyb1', `apply2', and `let'.


 -- Function: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     If <rule_1> fails on a given subexpression, then <rule_2> is
     repeatedly applied, etc.  Only if all rules fail on a given
     subexpression is the whole set of rules repeatedly applied to the
     next subexpression.  If one of the rules succeeds, then the same
     subexpression is reprocessed, starting with the first rule.

     `maxapplydepth' is the depth of the deepest subexpressions
     processed by `apply1' and `apply2'.

     See also `apply1' and `let'.


 -- Function: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repeatedly applies <rule_1> to the deepest subexpression of <expr>
     until it fails, then repeatedly applies the same rule one level
     higher (i.e., larger subexpressions), until <rule_1> has failed on
     the top-level expression.  Then <rule_2> is applied in the same
     fashion to the result of <rule_1>.  After <rule_n> has been
     applied to the top-level expression, the result is returned.

     `applyb1' is similar to `apply1' but works from the bottom up
     instead of from the top down.

     `maxapplyheight' is the maximum height which `applyb1' reaches
     before giving up.

     See also `apply1', `apply2', and `let'.


 -- Option variable: current_let_rule_package
     Default value: `default_let_rule_package'

     `current_let_rule_package' is the name of the rule package that is
     used by functions in the `let' package (`letsimp', etc.) if no
     other rule package is specified.  This variable may be assigned
     the name of any rule package defined via the `let' command.

     If a call such as `letsimp (expr, rule_pkg_name)' is made, the
     rule package `rule_pkg_name' is used for that function call only,
     and the value of `current_let_rule_package' is not changed.


 -- Option variable: default_let_rule_package
     Default value: `default_let_rule_package'

     `default_let_rule_package' is the name of the rule package used
     when one is not explicitly set by the user with `let' or by
     changing the value of `current_let_rule_package'.


 -- Function: defmatch (<progname>, <pattern>, <x_1>, ..., <x_n>)
     Creates a function `<progname> (<expr>, <y_1>, ..., <y_n>)' which
     tests <expr> to see if it matches <pattern>.

     <pattern> is an expression containing the pattern variables <x_1>,
     ..., <x_n> and pattern parameters, if any.  The pattern variables
     are given explicitly as arguments to `defmatch' while the pattern
     parameters are declared by the `matchdeclare' function.

     The first argument to the created function <progname> is an
     expression to be matched against the pattern and the other
     arguments are the actual variables <y_1>, ..., <y_n> in the
     expression which correspond to the dummy variables <x_1>, ...,
     <x_n> in the pattern.

     If the match is successful, <progname> returns a list of equations
     whose left sides are the pattern variables and pattern parameters,
     and whose right sides are the expressions which the pattern
     variables and parameters matched.  The pattern parameters, but not
     the variables, are assigned the subexpressions they match.  If the
     match fails, <progname> returns `false'.

     Any variables not declared as pattern parameters in `matchdeclare'
     or as variables in `defmatch' match only themselves.

     A pattern which contains no pattern variables or parameters
     returns `true' if the match succeeds.

     See also `matchdeclare', `defrule', `tellsimp', and
     `tellsimpafter'.

     Examples:

     This `defmatch' defines the function `linearp (expr, y)', which
     tests `expr' to see if it is of the form `a*y + b' such that `a'
     and `b' do not contain `y'.

          (%i1) matchdeclare (a, freeof(x), b, freeof(x))$
          (%i2) defmatch (linearp, a*x + b, x)$
          (%i3) linearp (3*z + (y+1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y

     If the third argument to `defmatch' in line (%i2) had been
     omitted, then `linear' would only match expressions linear in <x>,
     not in any other variable.

          (%i1) matchdeclare ([a, f], true)$
          (%i2) constinterval (l, h) := constantp (h - l)$
          (%i3) matchdeclare (b, constinterval (a))$
          (%i4) matchdeclare (x, atom)$
          (%i5) (remove (integrate, outative),
                    defmatch (checklimits, 'integrate (f, x, a, b)),
                    declare (integrate, outative))$
          (%i6) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o6)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i7) checklimits (%);
          (%o7)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
          (%i8) a;
          (%o8)                        x + %pi
          (%i9) b;
          (%o9)                       x + 2 %pi
          (%i10) f;
          (%o10)                       sin(t)
          (%i11) x;
          (%o11)                          t


 -- Function: defrule (<rulename>, <pattern>, <replacement>)
     Defines and names a replacement rule for the given pattern.  If
     the rule named <rulename> is applied to an expression (by
     `apply1', `applyb1', or `apply2'), every subexpression matching
     the pattern will be replaced by the replacement. All variables in
     the replacement which have been assigned values by the pattern
     match are assigned those values in the replacement which is then
     simplified.

     The rules themselves can be treated as functions which transform
     an expression by one operation of the pattern match and
     replacement.  If the match fails, the original expression is
     returned.


 -- Function: disprule (<rulename_1>, ..., <rulename_2>)
 -- Function: disprule (all)
     Display rules with the names <rulename_1>, ..., <rulename_n>, as
     returned by `defrule', `tellsimp', or `tellsimpafter', or a
     pattern defined by `defmatch'.  Each rule is displayed with an
     intermediate expression label (`%t').

     `disprule (all)' displays all rules.

     `disprule' quotes its arguments.  `disprule' returns the list of
     intermediate expression labels corresponding to the displayed
     rules.

     See also `letrules', which displays rules defined by `let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Function: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- Function: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <package_name>)
     Defines a substitution rule for `letsimp' such that <prod> is
     replaced by <repl>.  <prod> is a product of positive or negative
     powers of the following terms:

        * Atoms which `letsimp' will search for literally unless
          previous to calling `letsimp' the `matchdeclare' function is
          used to associate a predicate with the atom.  In this case
          `letsimp' will match the atom to any term of a product
          satisfying the predicate.

        * Kernels such as `sin(x)', `n!', `f(x,y)', etc.  As with atoms
          above `letsimp' will look for a literal match unless
          `matchdeclare' is used to associate a predicate with the
          argument of the kernel.

     A term to a positive power will only match a term having at least
     that power.  A term to a negative power on the other hand will
     only match a term with a power at least as negative.  In the case
     of negative powers in <prod> the switch `letrat' must be set to
     `true'.  See also `letrat'.

     If a predicate is included in the `let' function followed by a
     list of arguments, a tentative match (i.e. one that would be
     accepted if the predicate were omitted) is accepted only if
     `predname (arg_1', ..., arg_n')' evaluates to `true' where
     <arg_i'> is the value matched to <arg_i>.  The <arg_i> may be the
     name of any atom or the argument of any kernel appearing in <prod>.
     <repl> may be any rational expression. If any of the atoms or
     arguments from <prod> appear in <repl> the appropriate
     substitutions are made.  The global flag `letrat' controls the
     simplification of quotients by `letsimp'.  When `letrat' is
     `false', `letsimp' simplifies the numerator and denominator of
     <expr> separately, and does not simplify the quotient.
     Substitutions such as `n!/n' goes to `(n-1)!' then fail.  When
     `letrat' is `true', then the numerator, denominator, and the
     quotient are simplified in that order.

     These substitution functions allow you to work with several rule
     packages at once.  Each rule package can contain any number of
     `let' rules and is referenced by a user-defined name.  `let
     ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
     <package_name>)' adds the rule <predname> to the rule package
     <package_name>.  `letsimp (<expr>, <package_name>)' applies the
     rules in <package_name>.  `letsimp (<expr>, <package_name1>,
     <package_name2>, ...)' is equivalent to `letsimp (<expr>,
     <package_name1>)' followed by `letsimp (%, <package_name2>)', ....

     `current_let_rule_package' is the name of the rule package that is
     presently being used.  This variable may be assigned the name of
     any rule package defined via the `let' command.  Whenever any of
     the functions comprising the `let' package are called with no
     package name, the package named by `current_let_rule_package' is
     used.  If a call such as `letsimp (<expr>, <rule_pkg_name>)' is
     made, the rule package <rule_pkg_name> is used for that `letsimp'
     command only, and `current_let_rule_package' is not changed.  If
     not otherwise specified, `current_let_rule_package' defaults to
     `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Option variable: letrat
     Default value: `false'

     When `letrat' is `false', `letsimp' simplifies the numerator and
     denominator of a ratio separately, and does not simplify the
     quotient.

     When `letrat' is `true', the numerator, denominator, and their
     quotient are simplified in that order.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Function: letrules ()
 -- Function: letrules (<package_name>)
     Displays the rules in a rule package.  `letrules ()' displays the
     rules in the current rule package.  `letrules (<package_name>)'
     displays the rules in `package_name'.

     The current rule package is named by `current_let_rule_package'.
     If not otherwise specified, `current_let_rule_package' defaults to
     `default_let_rule_package'.

     See also `disprule', which displays rules defined by `tellsimp'
     and `tellsimpafter'.


 -- Function: letsimp (<expr>)
 -- Function: letsimp (<expr>, <package_name>)
 -- Function: letsimp (<expr>, <package_name_1>, ..., <package_name_n>)
     Repeatedly applies the substitution rules defined by `let' until
     no further change is made to <expr>.

     `letsimp (<expr>)' uses the rules from `current_let_rule_package'.

     `letsimp (<expr>, <package_name>)' uses the rules from
     <package_name> without changing `current_let_rule_package'.

     `letsimp (<expr>, <package_name_1>, ..., <package_name_n>)' is
     equivalent to `letsimp (<expr>, <package_name_1>', followed by
     `letsimp (%, <package_name_2>)', and so on.


 -- Option variable: let_rule_packages
     Default value: `[default_let_rule_package]'

     `let_rule_packages' is a list of all user-defined let rule packages
     plus the default package `default_let_rule_package'.


 -- Function: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associates a predicate <pred_k> with a variable or list of
     variables <a_k> so that <a_k> matches expressions for which the
     predicate returns anything other than `false'.

     The predicate is the name of a function, a function call missing
     the last argument, or `true' or `all'.  Any expression matches
     `true' or `all'.  If the predicate is specified as a function call,
     the expression to be tested is appended to the list of arguments;
     the arguments are evaluated at the time the match is evaluated.
     Otherwise, the predicate is specified as a function name, and the
     expression to be tested is the sole argument.  A predicate
     function need not be defined when `matchdeclare' is called; the
     predicate is not evaluated until a match is attempted.

     A `matchdeclare' predicate cannot be any kind of expression other
     than a function name or function call.  In particular, a predicate
     cannot be a `lambda' or `block'.

     If an expression satisfies a match predicate, the match variable
     is assigned the expression, except for match variables which are
     operands of addition `+' or multiplication `*'.  Only addition and
     multiplication are handled specially; other n-ary operators (both
     built-in and user-defined) are treated like ordinary functions.

     In the case of addition and multiplication, the match variable may
     be assigned a single expression which satisfies the match
     predicate, or a sum or product (respectively) of such expressions.
     Such multiple-term matching is greedy: predicates are evaluated in
     the order in which their associated variables appear in the match
     pattern, and a term which satisfies more than one predicate is
     taken by the first predicate which it satisfies.  Each predicate
     is tested against all operands of the sum or product before the
     next predicate is evaluated.  In addition, if 0 or 1
     (respectively) satisfies a match predicate, and there are no other
     terms which satisfy the predicate, 0 or 1 is assigned to the match
     variable associated with the predicate.

     The algorithm for processing addition and multiplication patterns
     makes some match results (for example, a pattern in which a "match
     anything" variable appears) dependent on the ordering of terms in
     the match pattern and in the expression to be matched.  However,
     if all match predicates are mutually exclusive, the match result
     is insensitive to ordering, as one match predicate cannot accept
     terms matched by another.

     Calling `matchdeclare' with a variable <a> as an argument changes
     the `matchdeclare' property for <a>, if one was already declared;
     only the most recent `matchdeclare' is in effect when a rule is
     defined, Later changes to the `matchdeclare' property (via
     `matchdeclare' or `remove') do not affect existing rules.

     `propvars (matchdeclare)' returns the list of all variables for
     which there is a `matchdeclare' property.  `printprops (<a>,
     matchdeclare)' returns the predicate for variable `a'.
     `printprops (all, matchdeclare)' returns the list of predicates
     for all `matchdeclare' variables.  `remove (<a>, matchdeclare)'
     removes the `matchdeclare' property from <a>.

     The functions `defmatch', `defrule', `tellsimp', `tellsimpafter',
     and `let' construct rules which test expressions against patterns.

     `matchdeclare' quotes its arguments.  `matchdeclare' always
     returns `done'.

     Examples:

        * `q' matches an expression not containing `x' or `%e'.

          (%i1) matchdeclare (q, freeof (x, %e))$


 -- Function: matchfix (<ldelimiter>, <rdelimiter>)
 -- Function: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)
     Declares a matchfix operator with left and right delimiters
     <ldelimiter> and <rdelimiter>.  The delimiters are specified as
     strings.

     A "matchfix" operator is a function of any number of arguments,
     such that the arguments occur between matching left and right
     delimiters.  The delimiters may be any strings, so long as the
     parser can distinguish the delimiters from the operands and other
     expressions and operators.  In practice this rules out unparseable
     delimiters such as `%', `,', `$' and `;', and may require
     isolating the delimiters with white space.  The right delimiter
     can be the same or different from the left delimiter.

     A left delimiter can be associated with only one right delimiter;
     two different matchfix operators cannot have the same left
     delimiter.

     An existing operator may be redeclared as a matchfix operator
     without changing its other properties.  In particular, built-in
     operators such as addition `+' can be declared matchfix, but
     operator functions cannot be defined for built-in operators.

     `matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)' declares
     the argument part-of-speech <arg_pos> and result part-of-speech
     <pos>, and the delimiters <ldelimiter> and <rdelimiter>.

     The function to carry out a matchfix operation is an ordinary
     user-defined function.  The operator function is defined in the
     usual way with the function definition operator `:=' or `define'.
     The arguments may be written between the delimiters, or with the
     left delimiter as a quoted string and the arguments following in
     parentheses.  `dispfun (<ldelimiter>)' displays the function
     definition.

     The only built-in matchfix operator is the list constructor `[ ]'.
     Parentheses `( )' and double-quotes `" "' act like matchfix
     operators, but are not treated as such by the Maxima parser.

     `matchfix' evaluates its arguments.  `matchfix' returns its first
     argument, <ldelimiter>.

     Examples:

        * Delimiters may be almost any strings.

          (%i1) matchfix ("@", "~");
          (%o1)                          "@"
          (%i2) @ a, b, c ~;
          (%o2)                       @a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                         ">>"
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                         "foo"
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                       @p, q~

        * Matchfix operators are ordinary user-defined functions.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Function: remlet (<prod>, <name>)
 -- Function: remlet ()
 -- Function: remlet (all)
 -- Function: remlet (all, <name>)
     Deletes the substitution rule, prod -> repl, most recently defined
     by the `let' function.  If name is supplied the rule is deleted
     from the rule package name.

     `remlet()' and `remlet(all)' delete all substitution rules from
     the current rule package.  If the name of a rule package is
     supplied, e.g. `remlet (all, <name>)', the rule package <name> is
     also deleted.

     If a substitution is to be changed using the same product,
     `remlet' need not be called, just redefine the substitution using
     the same product (literally) with the `let' function and the new
     replacement and/or predicate name.  Should `remlet (<prod>)' now be
     called the original substitution rule is revived.

     See also `remrule', which removes a rule defined by `tellsimp' or
     `tellsimpafter'.


 -- Function: remrule (<op>, <rulename>)
 -- Function: remrule (<op>, all)
     Removes rules defined by `tellsimp' or `tellsimpafter'.

     `remrule (<op>, <rulename>)' removes the rule with the name
     `rulename' from the operator <op>.  When <op> is a built-in or
     user-defined operator (as defined by `infix', `prefix', etc.),
     <op> and <rulename> must be enclosed in double quote marks.

     `remrule (<op>, all)' removes all rules for the operator <op>.

     See also `remlet', which removes a rule defined by `let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@");
          (%o3)                          @
          (%i4) tellsimp (aa @ bb, bb/aa);
          (%o4)                   [@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @ bb, quux (%pi, %e), quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@", "@rule1");
          (%o10)                         @
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @ bb, quux (%pi, %e), quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @ bb, quux(%pi, %e),
                                                             quux(%e, %pi)]


 -- Function: tellsimp (<pattern>, <replacement>)
     is similar to `tellsimpafter' but places new information before
     old so that it is applied before the built-in simplification rules.

     `tellsimp' is used when it is important to modify the expression
     before the simplifier works on it, for instance if the simplifier
     "knows" something about the expression, but what it returns is not
     to your liking.  If the simplifier "knows" something about the
     main operator of the expression, but is simply not doing enough for
     you, you probably want to use `tellsimpafter'.

     The pattern may not be a sum, product, single variable, or number.

     `rules' is the list of rules defined by `defrule', `defmatch',
     `tellsimp', and `tellsimpafter'.

     Examples:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Function: tellsimpafter (<pattern>, <replacement>)
     Defines a simplification rule which the Maxima simplifier applies
     after built-in simplification rules.  <pattern> is an expression,
     comprising pattern variables (declared by `matchdeclare') and
     other atoms and operators, considered literals for the purpose of
     pattern matching.  <replacement> is substituted for an actual
     expression which matches <pattern>; pattern variables in
     <replacement> are assigned the values matched in the actual
     expression.

     <pattern> may be any nonatomic expression in which the main
     operator is not a pattern variable; the simplification rule is
     associated with the main operator.  The names of functions (with
     one exception, described below), lists, and arrays may appear in
     <pattern> as the main operator only as literals (not pattern
     variables); this rules out expressions such as `aa(x)' and `bb[y]'
     as patterns, if `aa' and `bb' are pattern variables.  Names of
     functions, lists, and arrays which are pattern variables may
     appear as operators other than the main operator in <pattern>.

     There is one exception to the above rule concerning names of
     functions.  The name of a subscripted function in an expression
     such as `aa[x](y)' may be a pattern variable, because the main
     operator is not `aa' but rather the Lisp atom `mqapply'.  This is
     a consequence of the representation of expressions involving
     subscripted functions.

     Simplification rules are applied after evaluation (if not
     suppressed through quotation or the flag `noeval').  Rules
     established by `tellsimpafter' are applied in the order they were
     defined, and after any built-in rules.  Rules are applied
     bottom-up, that is, applied first to subexpressions before
     application to the whole expression.  It may be necessary to
     repeatedly simplify a result (for example, via the quote-quote
     operator `''' or the flag `infeval') to ensure that all rules are
     applied.

     Pattern variables are treated as local variables in simplification
     rules.  Once a rule is defined, the value of a pattern variable
     does not affect the rule, and is not affected by the rule.  An
     assignment to a pattern variable which results from a successful
     rule match does not affect the current assignment (or lack of it)
     of the pattern variable.  However, as with all atoms in Maxima,
     the properties of pattern variables (as declared by `put' and
     related functions) are global.

     The rule constructed by `tellsimpafter' is named after the main
     operator of `pattern'.  Rules for built-in operators, and
     user-defined operators defined by `infix', `prefix', `postfix',
     `matchfix', and `nofix', have names which are Maxima strings.
     Rules for other functions have names which are ordinary Maxima
     identifiers.

     The treatment of noun and verb forms is slightly confused. If a
     rule is defined for a noun (or verb) form and a rule for the
     corresponding verb (or noun) form already exists, the
     newly-defined rule applies to both forms (noun and verb).  If a
     rule for the corresponding verb (or noun) form does not exist, the
     newly-defined rule applies only to the noun (or verb) form.

     The rule constructed by `tellsimpafter' is an ordinary Lisp
     function.  If the name of the rule is `$foorule1', the construct
     `:lisp (trace $foorule1)' traces the function, and `:lisp
     (symbol-function '$foorule1' displays its definition.

     `tellsimpafter' quotes its arguments.  `tellsimpafter' returns the
     list of rules for the main operator of <pattern>, including the
     newly established rule.

     See also `matchdeclare', `defmatch', `defrule', `tellsimp', `let',
     `kill', `remrule', and `clear_rules'.

     Examples:

     <pattern> may be any nonatomic expression in which the main
     operator is not a pattern variable.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Rules are applied in the order they were defined.  If two rules
     can match an expression, the rule which was defined first is
     applied.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     Pattern variables are treated as local variables in simplification
     rules.  (Compare to `defmatch', which treats pattern variables as
     global variables.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     As with all atoms, properties of pattern variables are global even
     though values are local.  In this example, an assignment property
     is declared via `define_variable'.  This is a property of the atom
     `bb' throughout Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Rules are named after main operators.  Names of rules for built-in
     and user-defined operators are strings, while names for other
     functions are ordinary identifiers.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^


 -- Function: clear_rules ()
     Executes `kill (rules)' and then resets the next rule number to 1
     for addition `+', multiplication `*', and exponentiation `^'.



File: maxima.info,  Node: Lists,  Next: Sets,  Prev: Rules and Patterns,  Up: Top

38 Lists
********

* Menu:

* Introduction to Lists::
* Definitions for Lists::


File: maxima.info,  Node: Introduction to Lists,  Next: Definitions for Lists,  Prev: Lists,  Up: Lists

38.1 Introduction to Lists
==========================

Lists are the basic building block for Maxima and Lisp.   All data types
other than arrays, hash tables, numbers are represented as Lisp lists,
These Lisp lists have the form

     ((MPLUS) $A 2)

to indicate an expression `a+2'.   At Maxima level one would see the
infix notation `a+2'.   Maxima also has lists which are printed as

     [1, 2, 7, x+y]

for a list with 4 elements.  Internally this corresponds to a Lisp list
of the form

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

The flag which denotes the type field of the Maxima expression is a list
itself, since after it has been through the simplifier the list would
become

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))

