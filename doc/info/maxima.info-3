This is maxima.info, produced by makeinfo version 4.5 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Expressions,  Prev: SYNTAX,  Up: Expressions

Definitions for Expressions
===========================

 - Function: AT (exp, list)
     will evaluate exp (which may be any expression) with the variables
     assuming the values as specified for them in the list of equations
     or the single equation similar to that given to the ATVALUE
     function.  If a subexpression depends on any of the variables in
     list but it hasn't had an atvalue specified and it can't be
     evaluated then a noun form of the AT will be returned which will
     display in a two-dimensional form.  Do EXAMPLE(AT); for an example.


 - Function: BOX (expr)
     returns expr enclosed in a box.  The box is actually part of the
     expression.
          BOX(expr,label)
     encloses expr in a labelled box.  label is a name which will be
     truncated in display if it is too long.      BOXCHAR["] - is the
     character used to draw the box in this and in the DPART and LPART
     functions.


 - Variable: BOXCHAR
     default: ["] is the character used to draw the box in the BOX and
     in the DPART and LPART functions.


 - special operator: CONSTANT
     - makes ai a constant as is %PI.


 - Function: CONSTANTP (exp)
     is TRUE if exp is a constant (i.e.  composed of numbers and %PI,
     %E, %I or any variables bound to a constant or DECLAREd constant)
     else FALSE.  Any function whose arguments are constant is also
     considered to be a constant.


 - Function: CONTRACT (exp)
     carries out all possible contractions in exp, which may be any
     well-formed combination of sums and products.  This function uses
     the information given to the DEFCON function.  Since all tensors
     are considered to be symmetric in all indices, the indices are
     sorted into alphabetical order.  Also all dummy indices are
     renamed using the symbols !1,!2,... to permit the expression to be
     simplified as much as possible by reducing equivalent terms to a
     canonical form.  For best results exp should be fully expanded.
     RATEXPAND is the fastest way to expand products and powers of sums
     if there are no variables in the denominators of the terms.  The
     GCD switch should be FALSE if gcd cancellations are unnecessary.


 - Function: DECLARE (a1, f1, a2, f2, ...)
     gives the atom ai the flag fi.  The ai's and fi's may also be
     lists of atoms and flags respectively in which case each of the
     atoms gets all of the properties.  The possible flags and their
     meanings are:

     CONSTANT - makes ai a constant as is %PI.

     MAINVAR - makes ai a MAINVAR.  The ordering scale for atoms:
     numbers < constants (e.g. %E,%PI) < scalars < other variables <
     mainvars.

     SCALAR - makes ai a scalar.

     NONSCALAR - makes ai behave as does a list or matrix with respect
     to the dot operator.

     NOUN - makes the function ai a noun so that it won't be evaluated
     automatically.

     EVFUN - makes ai known to the EV function so that it will get
     applied if its name is mentioned.  Initial evfuns are
          FACTOR, TRIGEXPAND,
          TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, and RADCAN

     EVFLAG - makes ai known to the EV function so that it will be
     bound to TRUE during the execution of EV if it is mentioned.
     Initial evflags are
          FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE,
          KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
          RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER,
          RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER,
          PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
          EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM,
          NUMER_PBRANCH, M1PBRANCH, DOTSCRULES, and LOGEXPAND

     BINDTEST - causes ai to signal an error if it ever is used in a
     computation unbound.  DECLARE([var1, var2, ...], BINDTEST) causes
     MACSYMA to give an error message whenever any of the vari occur
     unbound in a computation.  MACSYMA currently recognizes and uses
     the following features of objects:
          EVEN, ODD, INTEGER, RATIONAL, IRRATIONAL, REAL, IMAGINARY,
          and COMPLEX
     he useful features of functions include:
           INCREASING,
          DECREASING, ODDFUN (odd function), EVENFUN (even function),
          COMMUTATIVE (or SYMMETRIC), ANTISYMMETRIC, LASSOCIATIVE and
          RASSOCIATIVE
     DECLARE(F,INCREASING) is in all respects equivalent to

          ASSUME(KIND(F,INCREASING))
     The ai and fi may also be lists of objects or features.  The
     command
          FEATUREP(object,feature)
     may be used to determine if an object has been DECLAREd to have
     "feature".  See DESCRIBE(FEATURES); .


 - Function: DISOLATE (exp, var1, var2, ..., varN)
     is similar to ISOLATE(exp, var) (Do DESCRIBE(ISOLATE);) except
     that it enables the user to isolate more than one variable
     simultaneously.  This might be useful, for example, if one were
     attempting to change variables in a multiple integration, and that
     variable change involved two or more of the integration variables.
     This function is autoloaded from `simplification/disol.mac'.  A
     demo is available by `demo("disol")$'.


 - Function: DISPFORM (exp)
     returns the external representation of exp (wrt its main
     operator).  This should be useful in conjunction with PART which
     also deals with the external representation.  Suppose EXP is -A .
     Then the internal representation of EXP is "*"(-1,A), while the
     external representation is "-"(A). DISPFORM(exp,ALL) converts the
     entire expression (not just the top-level) to external format.  For
     example, if EXP:SIN(SQRT(X)), then FREEOF(SQRT,EXP) and
     FREEOF(SQRT,DISPFORM(EXP)) give TRUE, while
     FREEOF(SQRT,DISPFORM(EXP,ALL)) gives FALSE.


 - Function: DISTRIB (exp)
     distributes sums over products.  It differs from EXPAND in that it
     works at only the top level of an expression, i.e. it doesn't
     recurse and it is faster than EXPAND.  It differs from MULTTHRU in
     that it expands all sums at that level. For example,
     DISTRIB((A+B)*(C+D)) -> A C + A D + B C + B D MULTTHRU
     ((A+B)*(C+D)) -> (A + B) C + (A + B) D DISTRIB (1/((A+B)*(C+D)))
     ->  1/ ((A+B) *(C+D)) EXPAND(1/((A+B)*(C+D)),1,0) -> 1/(A C + A D
     + B C + B D)


 - Function: DPART (exp, n1, ..., nk)
     selects the same subexpression as PART, but instead of just
     returning that subexpression as its value, it returns the whole
     expression with the selected subexpression displayed inside a box.
     The box is actually part of the expression.
          (%i1) DPART(X+Y/Z**2,1,2,1);
                                 Y
          (%o1)                  ---- + X
                                   2
                               *****
                               * Z *
                               *****

 - Function: EXP (X)
     the exponential function.  It is represented internally as %E^X.
     DEMOIVRE[FALSE] - if TRUE will cause %E^(A+B*%I) to become
     %E^A*(COS(B)+%I*SIN(B)) if B is free of %I.  A and B are not
     expanded.    %EMODE[TRUE] - when TRUE %E^(%PI*%I*X) will be
     simplified as follows: it will become COS(%PI*X)+%I*SIN(%PI*X) if
     X is an integer or a multiple of 1/2, 1/3, 1/4, or 1/6 and thus
     will simplify further.  For other numerical X it will become
     %E^(%PI*%I*Y) where Y is X-2*k for some integer k such that
     ABS(Y)<1.  If %EMODE is FALSE no simplification of %E^(%PI*%I*X)
     will take place.    %ENUMER[FALSE] - when TRUE will cause %E to be
     converted into 2.718...  whenever NUMER is TRUE.  The default is
     that this conversion will take place only if the exponent in %E^X
     evaluates to a number.


 - Variable: EXPTISOLATE
     default: [FALSE] if TRUE will cause ISOLATE(expr,var); to examine
     exponents of atoms (like %E) which contain var.


 - Variable: EXPTSUBST
     default: [FALSE] if TRUE permits substitutions such as Y for %E**X
     in %E**(A*X) to take place.


 - Function: FREEOF (x1, x2, ..., exp)
     yields TRUE if the xi do not occur in exp and FALSE otherwise.
     The xi are atoms or they may be subscripted names, functions (e.g.
     SIN(X) ), or operators enclosed in "s.  If 'var' is a "dummy
     variable" of 'exp', then FREEOF(var,exp); will return TRUE.
     "Dummy variables" are mathematical things like the index of a sum
     or product, the limit variable, and the definite integration
     variable.  Example: FREEOF(I,'SUM(F(I),I,0,N)); returns TRUE.  Do
     EXAMPLE(FREEOF); for more examples.


 - Function: GENFACT (X, Y, Z)
     is the generalized factorial of X which is:
     X*(X-Z)*(X-2*Z)*...*(X-(Y-1)*Z).  Thus, for integral X,
     GENFACT(X,X,1)=X!  and GENFACT(X,X/2,2)=X!!


 - Function: IMAGPART (exp)
     returns the imaginary part of the expression exp.


 - Function: INDICES (exp)
     returns a list of two elements.  The first is a list of the free
     indices in exp (those that occur only once); the second is the
     list of dummy indices in exp (those that occur exactly twice).


 - Function: INFIX (op)
     - INFIX operators are used to denote functions of two arguments,
     one given before the operator and one after, e.g. A^2 .  The
     INFIX("x") function is a syntax extention function to declare x to
     be an INFIX operator.  Do DESCRIBE(SYNTAX); for more details.


 - Variable: INFLAG
     default: [FALSE] if set to TRUE, the functions for part extraction
     will look at the internal form of exp.  Note that the simplifier
     re-orders expressions.  Thus FIRST(X+Y) will be X if INFLAG is
     TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same
     results).  Also, setting INFLAG to TRUE and calling PART/SUBSTPART
     is the same as calling INPART/SUBSTINPART.  Functions affected by
     the setting of INFLAG are: PART, SUBSTPART, FIRST, REST, LAST,
     LENGTH, the FOR ... IN construct, MAP, FULLMAP, MAPLIST, REVEAL
     and PICKAPART.


 - Function: INPART (exp, n1, ..., nk)
     is similar to PART but works on the internal representation of the
     expression rather than the displayed form and thus may be faster
     since no formatting is done.  Care should be taken with respect to
     the order of subexpressions in sums and products (since the order
     of variables in the internal form is often different from that in
     the displayed form) and in dealing with unary minus, subtraction,
     and division (since these operators are removed from the
     expression). PART(X+Y,0) or INPART(X+Y,0) yield +, though in order
     to refer to the operator it must be enclosed in "s.  For example
     ...IF INPART(%o9,0)="+" THEN ...
          (%i1)  X+Y+W*Z;
          (%o1)                  W Z + Y + X
          (%i2)  INPART(%o1,3,2);
          (%o2)                  Z
          (%i3)  PART(%o1,1,2);
          (%o3)                  Z
          (%i4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
                                                G(X + 1)
          (%o4)                      LIMIT   F(X)
                                    X ->0-
          (%i5) INPART(%,1,2);
          (%o5)                            G(X + 1)

 - Function: ISOLATE (exp, var)
     returns exp with subexpressions which are sums and which do not
     contain var replaced by intermediate expression labels (these
     being atomic symbols like %t1, %t2, ...).  This is often useful to
     avoid unnecessary expansion of subexpressions which don't contain
     the variable of interest.  Since the intermediate labels are bound
     to the subexpressions they can all be substituted back by
     evaluating the expression in which they occur.  EXPTISOLATE[FALSE]
     if TRUE will cause ISOLATE to examine exponents of atoms (like %E)
     which contain var.  ISOLATE_WRT_TIMES[FALSE] if TRUE, then ISOLATE
     will also isolate wrt products.  E.g. compare both settings of the
     switch on ISOLATE(EXPAND((A+B+C)^2),C); .  Do EXAMPLE(ISOLATE);
     for examples.


 - Variable: ISOLATE_WRT_TIMES
     default: [FALSE] - if set to TRUE, then ISOLATE will also isolate
     wrt products.  E.g. compare both settings of the switch on
     ISOLATE(EXPAND((A+B+C)^2),C); .


 - Variable: LISTCONSTVARS
     default: [FALSE] - if TRUE will cause LISTOFVARS to include %E,
     %PI, %I, and any variables declared constant in the list it
     returns if they appear in the expression LISTOFVARS is called on.
     The default is to omit these.


 - Variable: LISTDUMMYVARS
     default: [TRUE] - if FALSE, "dummy variables" in the expression
     will not be included in the list returned by LISTOFVARS.  (The
     meaning of "dummy variables" is as given in DESCRIBE(FREEOF):
     "Dummy variables" are mathematical things like the index of a sum
     or product, the limit variable, and the definite integration
     variable.)  Example: LISTOFVARS('SUM(F(I),I,0,N)); gives [I,N] if
     LISTDUMMYVARS is TRUE, and [N] if LISTDUMMYVARS is FALSE.


 - Function: LISTOFVARS (exp)
     yields a list of the variables in exp.  LISTCONSTVARS[FALSE] if
     TRUE will cause LISTOFVARS to include %E, %PI, %I, and any
     variables declared constant in the list it returns if they appear
     in exp.  The default is to omit these.
          (%i1) LISTOFVARS(F(X[1]+Y)/G**(2+A));
          (%o1)                            [X[1], Y, A, G]

 - Function: LFREEOF (list, exp)
     For each member m of list, calls FREEOF(m,exp).  It returns false
     if any call to FREEOF does and true otherwise.

 - Function: LOPOW (exp, v)
     the lowest exponent of v which explicitly appears in exp.  Thus

          LOPOW((X+Y)**2+(X+Y)**A,X+Y) ==> MIN(A,2)
     .


 - Function: LPART (label, expr, n1, ..., nk)
     is similar to DPART but uses a labelled box. A labelled box is
     similar to the one produced by DPART but it has a name in the top
     line.


 - Function: MULTTHRU (exp)
     multiplies a factor (which should be a sum) of exp by the other
     factors of exp.  That is exp is f1*f2*...*fn where at least one
     factor, say fi, is a sum of terms.  Each term in that sum is
     multiplied by the other factors in the product.  (Namely all the
     factors except fi).  MULTTHRU does not expand exponentiated sums.
     This function is the fastest way to distribute products
     (commutative or noncommutative) over sums.  Since quotients are
     represented as products MULTTHRU can be used to divide sums by
     products as well.  MULTTHRU(exp1, exp2) multiplies each term in
     exp2 (which should be a sum or an equation) by exp1.  If exp1 is
     not itself a sum then this form is equivalent to
     MULTTHRU(exp1*exp2).
          (%i1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;
                         1        X         F(X)
          (%o1)       - ----- + -------- - --------
                       X - Y          2          3
                               (X - Y)    (X - Y)
          (%i2) MULTTHRU((X-Y)**3,%);
                              2
          (%o2)       - (X - Y)  + X (X - Y) - F(X)
          (%i3) RATEXPAND(%o2);
                                     2
          (%o3)                    - Y  + X Y - F(X)
          (%i4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);
                                   10  2              2  2
                          (B  + A )   S  + 2 A B S + A  B
          (%o4)            --------------------------------
                                             2
                                        A B S
          (%i5) MULTTHRU(%);
                                                    10
                                  2   A B   (B  + A)
          (%o5)                    - + --- + -------
                                  S    2      A B
                                      S
          (notice that (B+A)**10 is not expanded)
          (%i6) MULTTHRU(A.(B+C.(D+E)+F));
          (%o6)                A . F + A . (C . (E + D)) + A . B
          (compare with similar example under EXPAND)

 - Function: NOUNIFY (f)
     returns the noun form of the function name f.  This is needed if
     one wishes to refer to the name of a verb function as if it were a
     noun.  Note that some verb functions will return their noun forms
     if they can't be evaluated for certain arguments.  This is also
     the form returned if a function call is preceded by a quote.


 - Function: NTERMS (exp)
     gives the number of terms that exp would have if it were fully
     expanded out and no cancellations or combination of terms
     occurred. Note that expressions like SIN(E), SQRT(E), EXP(E), etc.
     count as just one term regardless of how many terms E has (if it
     is a sum).


 - Function: OP (exp)
     Returns the operator of the expression, and functions the same way
     as PART(exp,0).  It observes the setting of the INPART flag.  It
     may not return the same value as the commercial Macsyma.


 - Function: OPERATORP (exp, ool)
     Uses OP to get the operator of the expression and either compares
     it to ool, if it is a operator, or checks if it is a member of ool
     if it is a list.


 - Function: OPTIMIZE (exp)
     returns an expression that produces the same value and side
     effects as exp but does so more efficiently by avoiding the
     recomputation of common subexpressions.  OPTIMIZE also has the side
     effect of "collapsing" its argument so that all common
     subexpressions are shared.  Do EXAMPLE(OPTIMIZE); for examples.


 - Variable: OPTIMPREFIX
     default: [%] - The prefix used for generated symbols by the
     OPTIMIZE command.


 - Function: ORDERGREAT (V1, ..., Vn)
     sets up aliases for the variables V1, ..., Vn such that V1 > V2 >
     ...  > Vn > any other variable not mentioned as an argument.  See
     also ORDERLESS.  Caveat:  do EXAMPLE(ORDERGREAT); for some
     specifics.


 - Function: ORDERGREATP (exp1,exp2)
     returns TRUE if exp2 precedes exp1 in the ordering set up with the
     ORDERGREAT function (see DESCRIBE(ORDERGREAT);).


 - Function: ORDERLESS (V1, ..., Vn)
     sets up aliases for the variables V1, ..., Vn such that V1 < V2 <
     ...  < Vn < any other variable not mentioned as an argument.  Thus
     the complete ordering scale is: numerical constants < declared
     constants < declared scalars < first argument to ORDERLESS < ...
     < last argument to ORDERLESS < variables which begin with A < ...
     < variables which begin with Z < last argument to ORDERGREAT <
     ... < first argument to ORDERGREAT < declared MAINVARs.  Caveat: do
     EXAMPLE(ORDERLESS); for some specifics.  For another ordering
     scheme, see DESCRIBE(MAINVAR);.


 - Function: ORDERLESSP (exp1,exp2)
     returns TRUE if exp1 precedes exp2 in the ordering set up by the
     ORDERLESS command (see DESCRIBE(ORDERLESS);).


 - Function: PART (exp, n1, ..., nk)
     deals with the displayed form of exp. It obtains the part of exp
     as specified by the indices n1,...,nk.  First part n1 of exp is
     obtained, then part n2 of that, etc.  The result is part nk of ...
     part n2 of part n1 of exp.  Thus PART(Z+2*Y,2,1) yields 2.  PART
     can be used to obtain an element of a list, a row of a matrix, etc.
     If the last argument to a Part function is a list of indices then
     several subexpressions are picked out, each one corresponding to an
     index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.  PIECE holds
     the last expression selected when using the Part functions.  It is
     set during the execution of the function and thus may be referred
     to in the function itself as shown below.  If PARTSWITCH[FALSE] is
     set to TRUE then END is returned when a selected part of an
     expression doesn't exist, otherwise an error message is given.
     For examples, do EXAMPLE(PART);


 - Function: PARTITION (exp, var)
     returns a list of two expressions.  They are (1) the factors of
     exp (if it is a product), the terms of exp (if it is a sum), or
     the list (if it is a list) which don't contain var and, (2) the
     factors, terms, or list which do.
          (%i1) PARTITION(2*A*X*F(X),X);
          (%o1)                 [ 2 A , X F(X) ]
          (%i2) PARTITION(A+B,X);
          (%o2)                 [ A + B , 0 ]
          (%i3) PARTITION([A,B,F(A),C],A);
          (%o3)                [[B,C],[A,F(A)]]

 - Variable: PARTSWITCH
     default: [FALSE] - if set to TRUE then END is returned when a
     selected part of an expression doesn't exist, otherwise an error
     message is given.


 - Function: PICKAPART (exp,depth)
     will assign E labels to all subexpressions of exp down to the
     specified integer depth.  This is useful for dealing with large
     expressions and for automatically assigning parts of an expression
     to a variable without having to use the part functions.
          (%i1) EXP:(A+B)/2+SIN(X^2)/3-LOG(1+SQRT(X+1));
                                                           2
                                                      SIN(X )   B + A
          (%o1)               - LOG(SQRT(X + 1) + 1) + ------- + -----
                                                         3        2
          (%i2) PICKAPART(%,1);
          (%t2)                    - LOG(SQRT(X + 1) + 1)
                                              2
                                         SIN(X )
          (%t3)                           -------
                                            3
                                          B + A
          (%t4)                            -----
                                            2
          (%o4)                         %t4 + %t3 + %t2

 - Variable: PIECE
     - holds the last expression selected when using the Part
     functions.  It is set during the execution of the function and thus
     may be referred to in the function itself.


 - Function: POWERS (expr, var)
     gives the powers of var occuring in expr.  To use it, do
     LOAD(POWERS);.  For details on usage, do PRINTFILE("powers.usg");.


 - Function: PRODUCT (exp, ind, lo, hi)
     gives the product of the values of exp as the index ind varies
     from lo to hi.  The evaluation is similar to that of SUM.  No
     simplification of products is available at this time.  If hi is
     one less than lo, we have an "empty product" and PRODUCT returns 1
     rather than erring out.  Also see DESCRIBE(PRODHACK).
          (%i1)  PRODUCT(X+I*(I+1)/2,I,1,4);
          (%o1)             (X + 1) (X + 3) (X + 6) (X + 10)

 - Function: REALPART (exp)
     gives the real part of exp. REALPART and IMAGPART will work on
     expressions involving trigonometic and hyperbolic functions, as
     well as SQRT, LOG, and exponentiation.


 - Function: RECTFORM (exp)
     returns an expression of the form A + B*%I, where A and B are
     purely real.


 - Function: REMBOX (expr, arg)
     removes boxes from expr according to arg.  If arg is UNLABELED
     then all unlabelled boxes are removed.  If arg is the name of some
     label then only boxes with that label are removed.  If arg is
     omitted then all boxes labelled and unlabelled are removed.


 - Function: SUM (exp, ind, lo, hi)
     performs a summation of the values of exp as the index ind varies
     from lo to hi.  If the upper and lower limits differ by an integer
     then each term in the sum is evaluated and added together.
     Otherwise, if the SIMPSUM [FALSE] is TRUE the result is
     simplified.  This simplification may sometimes be able to produce a
     closed form.  If SIMPSUM is FALSE or if 'SUM is used, the value is
     a sum noun form which is a representation of the sigma notation
     used in mathematics.  If hi is one less than lo, we have an "empty
     sum" and SUM returns 0 rather than erring out.  Sums may be
     differentiated, added, subtracted, or multiplied with some
     automatic simplification being performed.  Also see
     DESCRIBE(SUMHACK).  CAUCHYSUM[FALSE] when TRUE causes the Cauchy
     product to be used when multiplying sums together rather than the
     usual product.  In the Cauchy product the index of the inner
     summation is a function of the index of the outer one rather than
     varying independently.  GENINDEX[I] is the alphabetic prefix used
     to generate the next variable of summation.  GENSUMNUM[0] is the
     numeric suffix used to generate the next variable of summation.
     If it is set to FALSE then the index will consist only of GENINDEX
     with no numeric suffix.  Do EXAMPLE(SUM); for examples.  See also
     SUMCONTRACT, INTOSUM, BASHINDICES, and NICEINDICES.


 - Function: LSUM (exp, ind, list)
     performs the sum of EXP for each element IND of the LIST.
          (%i10) lsum(x^i,i,[1,2,7]);
          
                                      7    2
          (%o10)                      x  + x  + x
     If the last element LIST argument does not evaluate, or does not
     evaluate to a Maxima list then the answer is left in noun form
          (%i13) lsum(i^2,i,rootsof(x^3-1));
          
                               ====
                               \      2
          (%o13)                 >    i
                               /
                               ====
                                             3
                               i in ROOTSOF(x  - 1)


 - special symbol: VERB
     - the opposite of "noun", i.e. a function form which "does
     something" ("action" - for most functions the usual case).  E.g.
     INTEGRATE integrates a function, unless it is DECLAREd to be a
     "noun", in which case it represents the INTEGRAL of the function.
     See NOUN, NOUNIFY, and VERBIFY.


 - Function: VERBIFY (f)
     returns the function name f in its verb form (See also VERB, NOUN,
     and NOUNIFY).



File: maxima.info,  Node: Simplification,  Next: Plotting,  Prev: Expressions,  Up: Top

Simplification
**************

* Menu:

* Definitions for Simplification::


File: maxima.info,  Node: Definitions for Simplification,  Prev: Simplification,  Up: Simplification

Definitions for Simplification
==============================

* Menu:

 - Function: APPLY_NOUNS (exp)
     causes the application of noun forms in an expression.  E.g.
     EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This gives the
     same result as EV(EXP,NOUNS); except that it can be faster and use
     less storage.  It also can be used in translated code, where EV
     may cause problems.  Note that it is called APPLY_NOUNS, not
     EV_NOUNS, because what it does is to APPLY the rules corresponding
     to the noun-form operators, which is not evaluation.


 - Variable: ASKEXP
     default: [] contains the expression upon which ASKSIGN is called.
     A user may enter a MACSYMA break with ^A and inspect this
     expression in order to answer questions asked by ASKSIGN.

 - Function: ASKINTEGER (exp,<optional-arg>)
     exp is any valid macsyma expression and optional-arg is
     EVEN,ODD,INTEGER and defaults to INTEGER if not given.  This
     function attempts to determine from the data-base whether exp is
     EVEN, ODD or just an INTEGER.  It will ask the user if it cannot
     tell otherwise and attempt to install the information in the
     data-base if possible.


 - Function: ASKSIGN (exp)
     first attempts to determine whether the specified expression is
     positive, negative, or zero.  If it cannot, it asks the user the
     necessary questions to complete its deduction.  The user's answer
     is recorded in the data base for the duration of the current
     computation (one "C-line"). The value of ASKSIGN is one of POS,
     NEG, or ZERO.


 - Variable: DEMOIVRE
     default: [FALSE] if TRUE will cause
          %E^(A+B*%I) ==> %E^A*(COS(B)+%I*SIN(B))
     if B is free of %I.  A and B are not expanded.  DEMOIVRE:TRUE; is
     the way to reverse the effect of EXPONENTIALIZE:TRUE;

     DEMOIVRE(exp) will cause the conversion without setting the switch
     or having to re-evaluate the expression with EV.


 - Variable: DOMAIN
     default: [REAL] - if set to COMPLEX, SQRT(X^2) will remain
     SQRT(X^2) instead of returning ABS(X).  The notion of a "domain" of
     simplification is still in its infancy, and controls little more
     than this at the moment.


 - Function: EXPAND (exp)
     will cause products of sums and exponentiated sums to be
     multiplied out, numerators of rational expressions which are sums
     to be split into their respective terms, and multiplication
     (commutative and non-commutative) to be distributed over addition
     at all levels of exp.  For polynomials one should usually use
     RATEXPAND which uses a more efficient algorithm (see
     DESCRIBE(RATEXPAND);).  MAXNEGEX[1000] and MAXPOSEX[1000] control
     the maximum negative and positive exponents, respectively, which
     will expand.  EXPAND(exp,p,n) expands exp, using p for MAXPOSEX
     and n for MAXNEGEX.  This is useful in order to expand part but
     not all of an expression.  EXPON[0] - the exponent of the largest
     negative power which is automatically expanded (independent of
     calls to EXPAND).  For example if EXPON is 4 then (X+1)^(-5) will
     not be automatically expanded.  EXPOP[0] - the highest positive
     exponent which is automatically expanded.  Thus (X+1)^3, when
     typed, will be automatically expanded only if EXPOP is greater
     than or equal to 3.  If it is desired to have (X+1)^N expanded
     where N is greater than EXPOP then executing EXPAND((X+1)^N) will
     work only if MAXPOSEX is not less than N.  The EXPAND flag used
     with EV (see EV) causes expansion.

     The file `simplification/facexp.mac' contains several related
     functions (in particular FACSUM, FACTORFACSUM and COLLECTTERMS,
     which are autoloaded) and variables (NEXTLAYERFACTOR and
     FACSUM_COMBINE) that provide the user with the ability to structure
     expressions by controlled expansion.  Brief function descriptions
     are available in `simplification/facexp.usg'.  A demo is available
     by doing `demo("facexp")$'.


 - Function: EXPANDWRT (exp,var1,var2,...)
     expands exp with respect to the vari.  All products involving the
     vari appear explicitly.  The form returned will be free of
     products of sums of expressions that are not free of the vari.
     The vari may be variables, operators, or expressions.  By default,
     denominators are not expanded, but this can be controlled by means
     of the switch EXPANDWRT_DENOM.  This function is autoloaded from
     `simplification/stopex.mac'.


 - Variable: EXPANDWRT_DENOM
     default:[FALSE] controls the treatment of rational expressions by
     EXPANDWRT.  If TRUE, then both the numerator and denominator of
     the expression will be expanded according to the arguments of
     EXPANDWRT, but if EXPANDWRT_DENOM is FALSE, then only the
     numerator will be expanded in that way.


 - Function: EXPANDWRT_FACTORED (exp, var1, var2, ..., varN)
     is similar to EXPANDWRT, but treats expressions that are products
     somewhat differently.  EXPANDWRT_FACTORED will perform the
     required expansion only on those factors of exp that contain the
     variables in its argument list argument list.  This function is
     autoloaded from `simplification/stopex.mac'.


 - Variable: EXPON
     default: [0] - the exponent of the largest negative power which is
     automatically expanded (independent of calls to EXPAND).  For
     example if EXPON is 4 then (X+1)^(-5) will not be automatically
     expanded.


 - Variable: EXPONENTIALIZE
     default: [FALSE] if TRUE will cause all circular and hyperbolic
     functions to be converted to exponential form.  (Setting
     DEMOIVRE:TRUE; will reverse the effect.)  EXPONENTIALIZE(exp) will
     cause the conversion to exponential form of an expression without
     setting the switch or having to re-evaluate the expression with EV.


 - Variable: EXPOP
     default: [0] - the highest positive exponent which is
     automatically expanded.  Thus (X+1)^3, when typed, will be
     automatically expanded only if EXPOP is greater than or equal to 3.
     If it is desired to have (X+1)^n expanded where n is greater than
     EXPOP then executing EXPAND((X+1)^n) will work only if MAXPOSEX is
     not less than n.


 - Variable: FACTLIM
     default: [-1] gives the highest factorial which is automatically
     expanded.  If it is -1 then all integers are expanded.


 - Function: INTOSUM (expr)
     will take all things that a summation is multiplied by, and put
     them inside the summation. If the index is used in the outside
     expression, then the function tries to find a reasonable index,
     the same as it does for SUMCONTRACT.  This is essentially the
     reverse idea of the OUTATIVE property of summations, but note that
     it does not remove this property, it only bypasses it.  In some
     cases, a SCANMAP(MULTTHRU,expr) may be necessary before the
     INTOSUM.


 - declaration: LASSOCIATIVE
     - If DECLARE(G,LASSOCIATIVE); is done, this tells the simplifier
     that G is left-associative.  E.g.  G(G(A,B),G(C,D)) will simplify
     to G(G(G(A,B),C),D).


 - declaration: LINEAR
     - One of MACSYMA's OPPROPERTIES.  For univariate f so declared,
     "expansion" F(X+Y) -> F(X)+F(Y), F(A*X) -> A*F(X) takes place
     where A is a "constant".  For functions F of >=2 args, "linearity"
     is defined to be as in the case of 'SUM or 'INTEGRATE, i.e.
     F(A*X+B,X) -> A*F(X,X)+B*F(1,X) for A,B FREEOF X.  (LINEAR is just
     ADDITIVE + OUTATIVE.)


 - declaration: MAINVAR
     - You may DECLARE variables to be MAINVAR.  The ordering scale for
     atoms is essentially: numbers < constants (e.g. %E,%PI) < scalars
     < other variables < mainvars.  E.g. compare EXPAND((X+Y)^4); with
     (DECLARE(X,MAINVAR), EXPAND((X+Y)^4)); .  (Note: Care should be
     taken if you elect to use the above feature.  E.g. if you subtract
     an expression in which X is a MAINVAR from one in which X isn't a
     MAINVAR, resimplification e.g. with EV(expression,SIMP) may be
     necessary if cancellation is to occur.  Also, if you SAVE an
     expression in which X is a MAINVAR, you probably should also SAVE
     X.)


 - Variable: MAXAPPLYDEPTH
     default: [10000] - the maximum depth to which APPLY1 and APPLY2
     will delve.


 - Variable: MAXAPPLYHEIGHT
     default: [10000] - the maximum height to which APPLYB1 will reach
     before giving up.


 - Variable: MAXNEGEX
     default: [1000] - the largest negative exponent which will be
     expanded by the EXPAND command (see also MAXPOSEX).


 - Variable: MAXPOSEX
     default: [1000] - the largest exponent which will be expanded with
     the EXPAND command (see also MAXNEGEX).


 - declaration: MULTIPLICATIVE
     - If DECLARE(F,MULTIPLICATIVE) has been executed, then: (1) If F
     is univariate, whenever the simplifier encounters F applied to a
     product, F will be distributed over that product.  I.e. F(X*Y);
     will simplify to F(X)*F(Y).  (2) If F is a function of 2 or more
     arguments, multiplicativity is defined as multiplicativity in the
     first argument to F, i.e.  F(G(X)*H(X),X); will simplify to
     F(G(X),X)*F(H(X),X).  This simplification does not occur when F is
     applied to expressions of the form
     PRODUCT(X[I],I,lower-limit,upper-limit).


 - Variable: NEGDISTRIB
     default: [TRUE] - when TRUE allows -1 to be distributed over an
     expression.  E.g. -(X+Y) becomes -Y-X.  Setting it to FALSE will
     allow -(X+Y) to be displayed like that.  This is sometimes useful
     but be very careful: like the SIMP flag, this is one flag you do
     not want to set to FALSE as a matter of course or necessarily for
     other than local use in your MACSYMA.


 - Variable: NEGSUMDISPFLAG
     default: [TRUE] - when TRUE, X-Y displays as X-Y instead of as
     -Y+X.  Setting it to FALSE causes the special check in display for
     the difference of two expressions to not be done.  One application
     is that thus A+%I*B and A-%I*B may both be displayed the same way.


 - special symbol: NOEVAL
     - suppresses the evaluation phase of EV.  This is useful in
     conjunction with other switches and in causing expressions to be
     resimplified without being reevaluated.


 - declaration: NOUN
     - One of the options of the DECLARE command.  It makes a function
     so DECLAREd a "noun", meaning that it won't be evaluated
     automatically.


 - Variable: NOUNDISP
     default: [FALSE] - if TRUE will cause NOUNs to display with a
     single quote.  This switch is always TRUE when displaying function
     definitions.


 - special symbol: NOUNS
     (EVFLAG) when used as an option to the EV command, converts all
     "noun" forms occurring in the expression being EV'd to "verbs",
     i.e.  evaluates them.  See also NOUN, NOUNIFY, VERB, and VERBIFY.


 - special symbol: NUMER
     causes some mathematical functions (including exponentiation) with
     numerical arguments to be evaluated in floating point. It causes
     variables in exp which have been given numervals to be replaced by
     their values.  It also sets the FLOAT switch on.


 - Function: NUMERVAL (var1, exp1, var2, exp2, ...)
     declares vari to have a numerval of expi which is evaluated and
     substituted for the variable in any expressions in which the
     variable occurs if the NUMER flag is TRUE. (see the EV function).


 - Variable: OPPROPERTIES
     - the list of the special operator-properties handled by the
     MACSYMA simplifier: LINEAR, ADDITIVE, MULTIPLICATIVE, OUTATIVE,
     EVENFUN, ODDFUN, COMMUTATIVE, SYMMETRIC, ANTISYMMETRIC, NARY,
     LASSOCIATIVE, and RASSOCIATIVE.


 - Variable: OPSUBST
     default:[TRUE] - if FALSE, SUBST will not attempt to substitute
     into the operator of an expression.  E.g. (OPSUBST:FALSE,
     SUBST(X^2,R,R+R[0])); will work.


 - declaration: OUTATIVE
     - If DECLARE(F,OUTATIVE) has been executed, then: (1) If F is
     univariate, whenever the simplifier encounters F applied to a
     product, that product will be partitioned into factors that are
     constant and factors that are not and the constant factors will be
     pulled out.  I.e. F(A*X); will simplify to A*F(X) where A is a
     constant.  Non-atomic constant factors will not be pulled out.
     (2) If F is a function of 2 or more arguments, outativity is
     defined as in the case of 'SUM or 'INTEGRATE, i.e. F(A*G(X),X);
     will simplify to A*F(G(X),X) for A free-of X.  Initially, 'SUM,
     'INTEGRATE, and 'LIMIT are declared to be OUTATIVE.


 - declaration: POSFUN
     - POSitive FUNction, e.g. DECLARE(F,POSFUN); IS(F(X)>0); -> TRUE.


 - Variable: PRODHACK
     default: [FALSE] - if set to TRUE then PRODUCT(F(I),I,3,1); will
     yield 1/F(2), by the identity PRODUCT(F(I),I,A,B) =
     1/PRODUCT(F(I),I,B+1,A-1) when A>B.


 - Function: RADCAN (exp)
     simplifies exp, which can contain logs, exponentials, and
     radicals, by converting it into a form which is canonical over a
     large class of expressions and a given ordering of variables; that
     is, all functionally equivalent forms are mapped into a unique
     form.  For a somewhat larger class of expressions, RADCAN produces
     a regular form.  Two equivalent expressions in this class will not
     necessarily have the same appearance, but their difference will be
     simplified by RADCAN to zero.  For some expressions RADCAN can be
     quite time consuming.  This is the cost of exploring certain
     relationships among the components of the expression for
     simplifications based on factoring and partial-fraction expansions
     of exponents.  %E_TO_NUMLOG (default: [FALSE]) - when set to TRUE,
     for "r" some rational number, and "x" some expression,
     %E^(r*LOG(x)) will be simplified into x^r .  RADEXPAND[TRUE] when
     set to FALSE will inhibit certain transformations:
     RADCAN(SQRT(1-X)) will remain SQRT(1-X) and will not become %I
     SQRT(X-1).  RADCAN(SQRT(X^2-2*X+1)) will remain SQRT(X^2-2*X + 1)
     and will not be transformed to X- 1.  Do EXAMPLE(RADCAN); for
     examples.


 - Variable: RADEXPAND
     default: [TRUE] - if set to ALL will cause nth roots of factors of
     a product which are powers of n to be pulled outside of the
     radical.  E.g. if RADEXPAND is ALL, SQRT(16*X^2) will become 4*X .
     More particularly, consider SQRT(X^2).  (a) If RADEXPAND is ALL or
     ASSUME(X>0) has been done, SQRT(X^2) will become X.  (b) If
     RADEXPAND is TRUE and DOMAIN is REAL (its default), SQRT(X^2) will
     become ABS(X).  (c) If RADEXPAND is FALSE, or RADEXPAND is TRUE
     and DOMAIN is COMPLEX, SQRT(X^2) will be returned.  (The notion of
     DOMAIN with settings of REAL or COMPLEX is still in its infancy.
     Note that its setting here only matters when RADEXPAND is TRUE.)


 - Variable: RADPRODEXPAND
     - this switch has been renamed RADEXPAND.


 - Variable: RADSUBSTFLAG
     default: [FALSE] - if TRUE permits RATSUBST to make substitutions
     such as U for SQRT(X) in X.


 - declaration: RASSOCIATIVE
     - If DECLARE(G,RASSOCIATIVE); is done, this tells the simplifier
     that G is right-associative.  E.g.  G(G(A,B),G(C,D)) will simplify
     to G(A,G(B,G(C,D))).


 - Function: SCSIMP (exp,rule1, rule2,...,rulen)
     Sequential Comparative Simplification [Stoute]) takes an
     expression (its first argument) and a set of identities, or rules
     (its other arguments) and tries simplifying.  If a smaller
     expression is obtained, the process repeats.  Otherwise after all
     simplifications are tried, it returns the original answer.  For
     examples, try EXAMPLE(SCSIMP); .


 - Function: SIMP
     causes exp to be simplified regardless of the setting of the
     switch SIMP which inhibits simplification if FALSE.


 - Variable: SIMPSUM
     default: [FALSE] - if TRUE, the result of a SUM is simplified.
     This simplification may sometimes be able to produce a closed
     form.  If SIMPSUM is FALSE or if 'SUM is used, the value is a sum
     noun form which is a representation of the sigma notation used in
     mathematics.


 - Function: SUMCONTRACT (expr)
     will combine all sums of an addition that have upper and lower
     bounds that differ by constants. The result will be an expression
     containing one summation for each set of such summations added to
     all appropriate extra terms that had to be extracted to form this
     sum.  SUMCONTRACT will combine all compatible sums and use one of
     the indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.  It may be
     necessary to do an INTOSUM(expr) before the SUMCONTRACT.


 - Variable: SUMEXPAND
     default: [FALSE] if TRUE, products of sums and exponentiated sums
     are converted into nested sums. For example:
                  SUMEXPAND:TRUE$
                  SUM(F(I),I,0,M)*SUM(G(J),J,0,N); ->
                                  'SUM('SUM(F(I1)*G(I2),I2,0,N),I1,0,M)
                  SUM(F(I),I,0,M)^2; -> 'SUM('SUM(F(I3)*F(I4),I4,0,M),I3,0,M)

     If FALSE, they are left alone.  See also CAUCHYSUM.


 - Variable: SUMHACK
     default: [FALSE] - if set to TRUE then SUM(F(I),I,3,1); will yield
     -F(2), by the identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1)
     when A>B.


 - Variable: SUMSPLITFACT
     default: [TRUE] - if set to FALSE will cause MINFACTORIAL to be
     applied after a FACTCOMB.


 - declaration: SYMMETRIC
     - If DECLARE(H,SYMMETRIC); is done, this tells the simplifier that
     H is a symmetric function.  E.g. H(X,Z,Y) will simplify to H(X, Y,
     Z).  This is the same as COMMUTATIVE.


 - Function: UNKNOWN (exp)
     returns TRUE iff exp contains an operator or function not known to
     the built-in simplifier.



File: maxima.info,  Node: Plotting,  Next: Input and Output,  Prev: Simplification,  Up: Top

Plotting
********

* Menu:

* Definitions for Plotting::

