This is maxima.info, produced by makeinfo version 4.1 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Simplification,  Next: Plotting,  Prev: Expressions,  Up: Top

Simplification
**************

* Menu:

* Definitions for Simplification::


File: maxima.info,  Node: Definitions for Simplification,  Prev: Simplification,  Up: Simplification

Definitions for Simplification
==============================

* Menu:

 - Function: APPLY_NOUNS (exp)
     causes the application of noun forms in an expression.  E.g.
     EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This gives the
     same result as EV(EXP,NOUNS); except that it can be faster and use
     less storage.  It also can be used in translated code, where EV
     may cause problems.  Note that it is called APPLY_NOUNS, not
     EV_NOUNS, because what it does is to APPLY the rules corresponding
     to the noun-form operators, which is not evaluation.


 - Variable: ASKEXP
     default: [] contains the expression upon which ASKSIGN is called.
     A user may enter a MACSYMA break with ^A and inspect this
     expression in order to answer questions asked by ASKSIGN.

 - Function: ASKINTEGER (exp,<optional-arg>)
     exp is any valid macsyma expression and optional-arg is
     EVEN,ODD,INTEGER and defaults to INTEGER if not given.  This
     function attempts to determine from the data-base whether exp is
     EVEN, ODD or just an INTEGER.  It will ask the user if it cannot
     tell otherwise and attempt to install the information in the
     data-base if possible.


 - Function: ASKSIGN (exp)
     first attempts to determine whether the specified expression is
     positive, negative, or zero.  If it cannot, it asks the user the
     necessary questions to complete its deduction.  The user's answer
     is recorded in the data base for the duration of the current
     computation (one "C-line"). The value of ASKSIGN is one of POS,
     NEG, or ZERO.


 - Variable: DEMOIVRE
     default: [FALSE] if TRUE will cause
          %E^(A+B*%I) ==> %E^A*(COS(B)+%I*SIN(B))
     if B is free of %I.  A and B are not expanded.  DEMOIVRE:TRUE; is
     the way to reverse the effect of EXPONENTIALIZE:TRUE;

     DEMOIVRE(exp) will cause the conversion without setting the switch
     or having to re-evaluate the expression with EV.


 - Variable: DOMAIN
     default: [REAL] - if set to COMPLEX, SQRT(X^2) will remain
     SQRT(X^2) instead of returning ABS(X).  The notion of a "domain" of
     simplification is still in its infancy, and controls little more
     than this at the moment.


 - Function: EXPAND (exp)
     will cause products of sums and exponentiated sums to be
     multiplied out, numerators of rational expressions which are sums
     to be split into their respective terms, and multiplication
     (commutative and non-commutative) to be distributed over addition
     at all levels of exp.  For polynomials one should usually use
     RATEXPAND which uses a more efficient algorithm (see
     DESCRIBE(RATEXPAND);).  MAXNEGEX[1000] and MAXPOSEX[1000] control
     the maximum negative and positive exponents, respectively, which
     will expand.  EXPAND(exp,p,n) expands exp, using p for MAXPOSEX
     and n for MAXNEGEX.  This is useful in order to expand part but
     not all of an expression.  EXPON[0] - the exponent of the largest
     negative power which is automatically expanded (independent of
     calls to EXPAND).  For example if EXPON is 4 then (X+1)^(-5) will
     not be automatically expanded.  EXPOP[0] - the highest positive
     exponent which is automatically expanded.  Thus (X+1)^3, when
     typed, will be automatically expanded only if EXPOP is greater
     than or equal to 3.  If it is desired to have (X+1)^N expanded
     where N is greater than EXPOP then executing EXPAND((X+1)^N) will
     work only if MAXPOSEX is not less than N.  The EXPAND flag used
     with EV (see EV) causes expansion.

     The file `simplification/facexp.mac' contains several related
     functions (in particular FACSUM, FACTORFACSUM and COLLECTTERMS,
     which are autoloaded) and variables (NEXTLAYERFACTOR and
     FACSUM_COMBINE) that provide the user with the ability to structure
     expressions by controlled expansion.  Brief function descriptions
     are available in `simplification/facexp.usg'.  A demo is available
     by doing `demo("facexp")$'.


 - Function: EXPANDWRT (exp,var1,var2,...)
     expands exp with respect to the vari.  All products involving the
     vari appear explicitly.  The form returned will be free of
     products of sums of expressions that are not free of the vari.
     The vari may be variables, operators, or expressions.  By default,
     denominators are not expanded, but this can be controlled by means
     of the switch EXPANDWRT_DENOM.  This function is autoloaded from
     `simplification/stopex.mac'.


 - Variable: EXPANDWRT_DENOM
     default:[FALSE] controls the treatment of rational expressions by
     EXPANDWRT.  If TRUE, then both the numerator and denominator of
     the expression will be expanded according to the arguments of
     EXPANDWRT, but if EXPANDWRT_DENOM is FALSE, then only the
     numerator will be expanded in that way.


 - Function: EXPANDWRT_FACTORED (exp, var1, var2, ..., varN)
     is similar to EXPANDWRT, but treats expressions that are products
     somewhat differently.  EXPANDWRT_FACTORED will perform the
     required expansion only on those factors of exp that contain the
     variables in its argument list argument list.  This function is
     autoloaded from `simplification/stopex.mac'.


 - Variable: EXPON
     default: [0] - the exponent of the largest negative power which is
     automatically expanded (independent of calls to EXPAND).  For
     example if EXPON is 4 then (X+1)^(-5) will not be automatically
     expanded.


 - Variable: EXPONENTIALIZE
     default: [FALSE] if TRUE will cause all circular and hyperbolic
     functions to be converted to exponential form.  (Setting
     DEMOIVRE:TRUE; will reverse the effect.)  EXPONENTIALIZE(exp) will
     cause the conversion to exponential form of an expression without
     setting the switch or having to re-evaluate the expression with EV.


 - Variable: EXPOP
     default: [0] - the highest positive exponent which is
     automatically expanded.  Thus (X+1)^3, when typed, will be
     automatically expanded only if EXPOP is greater than or equal to 3.
     If it is desired to have (X+1)^n expanded where n is greater than
     EXPOP then executing EXPAND((X+1)^n) will work only if MAXPOSEX is
     not less than n.


 - Variable: FACTLIM
     default: [-1] gives the highest factorial which is automatically
     expanded.  If it is -1 then all integers are expanded.


 - Function: INTOSUM (expr)
     will take all things that a summation is multiplied by, and put
     them inside the summation. If the index is used in the outside
     expression, then the function tries to find a reasonable index,
     the same as it does for SUMCONTRACT.  This is essentially the
     reverse idea of the OUTATIVE property of summations, but note that
     it does not remove this property, it only bypasses it.  In some
     cases, a SCANMAP(MULTTHRU,expr) may be necessary before the
     INTOSUM.


 - declaration: LASSOCIATIVE
     - If DECLARE(G,LASSOCIATIVE); is done, this tells the simplifier
     that G is left-associative.  E.g.  G(G(A,B),G(C,D)) will simplify
     to G(G(G(A,B),C),D).


 - declaration: LINEAR
     - One of MACSYMA's OPPROPERTIES.  For univariate f so declared,
     "expansion" F(X+Y) -> F(X)+F(Y), F(A*X) -> A*F(X) takes place
     where A is a "constant".  For functions F of >=2 args, "linearity"
     is defined to be as in the case of 'SUM or 'INTEGRATE, i.e.
     F(A*X+B,X) -> A*F(X,X)+B*F(1,X) for A,B FREEOF X.  (LINEAR is just
     ADDITIVE + OUTATIVE.)


 - declaration: MAINVAR
     - You may DECLARE variables to be MAINVAR.  The ordering scale for
     atoms is essentially: numbers < constants (e.g. %E,%PI) < scalars
     < other variables < mainvars.  E.g. compare EXPAND((X+Y)^4); with
     (DECLARE(X,MAINVAR), EXPAND((X+Y)^4)); .  (Note: Care should be
     taken if you elect to use the above feature.  E.g. if you subtract
     an expression in which X is a MAINVAR from one in which X isn't a
     MAINVAR, resimplification e.g. with EV(expression,SIMP) may be
     necessary if cancellation is to occur.  Also, if you SAVE an
     expression in which X is a MAINVAR, you probably should also SAVE
     X.)


 - Variable: MAXAPPLYDEPTH
     default: [10000] - the maximum depth to which APPLY1 and APPLY2
     will delve.


 - Variable: MAXAPPLYHEIGHT
     default: [10000] - the maximum height to which APPLYB1 will reach
     before giving up.


 - Variable: MAXNEGEX
     default: [1000] - the largest negative exponent which will be
     expanded by the EXPAND command (see also MAXPOSEX).


 - Variable: MAXPOSEX
     default: [1000] - the largest exponent which will be expanded with
     the EXPAND command (see also MAXNEGEX).


 - declaration: MULTIPLICATIVE
     - If DECLARE(F,MULTIPLICATIVE) has been executed, then: (1) If F
     is univariate, whenever the simplifier encounters F applied to a
     product, F will be distributed over that product.  I.e. F(X*Y);
     will simplify to F(X)*F(Y).  (2) If F is a function of 2 or more
     arguments, multiplicativity is defined as multiplicativity in the
     first argument to F, i.e.  F(G(X)*H(X),X); will simplify to
     F(G(X),X)*F(H(X),X).  This simplification does not occur when F is
     applied to expressions of the form
     PRODUCT(X[I],I,lower-limit,upper-limit).


 - Variable: NEGDISTRIB
     default: [TRUE] - when TRUE allows -1 to be distributed over an
     expression.  E.g. -(X+Y) becomes -Y-X.  Setting it to FALSE will
     allow -(X+Y) to be displayed like that.  This is sometimes useful
     but be very careful: like the SIMP flag, this is one flag you do
     not want to set to FALSE as a matter of course or necessarily for
     other than local use in your MACSYMA.


 - Variable: NEGSUMDISPFLAG
     default: [TRUE] - when TRUE, X-Y displays as X-Y instead of as
     -Y+X.  Setting it to FALSE causes the special check in display for
     the difference of two expressions to not be done.  One application
     is that thus A+%I*B and A-%I*B may both be displayed the same way.


 - special symbol: NOEVAL
     - suppresses the evaluation phase of EV.  This is useful in
     conjunction with other switches and in causing expressions to be
     resimplified without being reevaluated.


 - declaration: NOUN
     - One of the options of the DECLARE command.  It makes a function
     so DECLAREd a "noun", meaning that it won't be evaluated
     automatically.


 - Variable: NOUNDISP
     default: [FALSE] - if TRUE will cause NOUNs to display with a
     single quote.  This switch is always TRUE when displaying function
     definitions.


 - special symbol: NOUNS
     (EVFLAG) when used as an option to the EV command, converts all
     "noun" forms occurring in the expression being EV'd to "verbs",
     i.e.  evaluates them.  See also NOUN, NOUNIFY, VERB, and VERBIFY.


 - special symbol: NUMER
     causes some mathematical functions (including exponentiation) with
     numerical arguments to be evaluated in floating point. It causes
     variables in exp which have been given numervals to be replaced by
     their values.  It also sets the FLOAT switch on.


 - Function: NUMERVAL (var1, exp1, var2, exp2, ...)
     declares vari to have a numerval of expi which is evaluated and
     substituted for the variable in any expressions in which the
     variable occurs if the NUMER flag is TRUE. (see the EV function).


 - Variable: OPPROPERTIES
     - the list of the special operator-properties handled by the
     MACSYMA simplifier: LINEAR, ADDITIVE, MULTIPLICATIVE, OUTATIVE,
     EVENFUN, ODDFUN, COMMUTATIVE, SYMMETRIC, ANTISYMMETRIC, NARY,
     LASSOCIATIVE, and RASSOCIATIVE.


 - Variable: OPSUBST
     default:[TRUE] - if FALSE, SUBST will not attempt to substitute
     into the operator of an expression.  E.g. (OPSUBST:FALSE,
     SUBST(X^2,R,R+R[0])); will work.


 - declaration: OUTATIVE
     - If DECLARE(F,OUTATIVE) has been executed, then: (1) If F is
     univariate, whenever the simplifier encounters F applied to a
     product, that product will be partitioned into factors that are
     constant and factors that are not and the constant factors will be
     pulled out.  I.e. F(A*X); will simplify to A*F(X) where A is a
     constant.  Non-atomic constant factors will not be pulled out.
     (2) If F is a function of 2 or more arguments, outativity is
     defined as in the case of 'SUM or 'INTEGRATE, i.e. F(A*G(X),X);
     will simplify to A*F(G(X),X) for A free-of X.  Initially, 'SUM,
     'INTEGRATE, and 'LIMIT are declared to be OUTATIVE.


 - declaration: POSFUN
     - POSitive FUNction, e.g. DECLARE(F,POSFUN); IS(F(X)>0); -> TRUE.


 - Variable: PRODHACK
     default: [FALSE] - if set to TRUE then PRODUCT(F(I),I,3,1); will
     yield 1/F(2), by the identity PRODUCT(F(I),I,A,B) =
     1/PRODUCT(F(I),I,B+1,A-1) when A>B.


 - Function: RADCAN (exp)
     simplifies exp, which can contain logs, exponentials, and
     radicals, by converting it into a form which is canonical over a
     large class of expressions and a given ordering of variables; that
     is, all functionally equivalent forms are mapped into a unique
     form.  For a somewhat larger class of expressions, RADCAN produces
     a regular form.  Two equivalent expressions in this class will not
     necessarily have the same appearance, but their difference will be
     simplified by RADCAN to zero.  For some expressions RADCAN can be
     quite time consuming.  This is the cost of exploring certain
     relationships among the components of the expression for
     simplifications based on factoring and partial-fraction expansions
     of exponents.  %E_TO_NUMLOG (default: [FALSE]) - when set to TRUE,
     for "r" some rational number, and "x" some expression,
     %E^(r*LOG(x)) will be simplified into x^r .  RADEXPAND[TRUE] when
     set to FALSE will inhibit certain transformations:
     RADCAN(SQRT(1-X)) will remain SQRT(1-X) and will not become %I
     SQRT(X-1).  RADCAN(SQRT(X^2-2*X+1)) will remain SQRT(X^2-2*X + 1)
     and will not be transformed to X- 1.  Do EXAMPLE(RADCAN); for
     examples.


 - Variable: RADEXPAND
     default: [TRUE] - if set to ALL will cause nth roots of factors of
     a product which are powers of n to be pulled outside of the
     radical.  E.g. if RADEXPAND is ALL, SQRT(16*X^2) will become 4*X .
     More particularly, consider SQRT(X^2).  (a) If RADEXPAND is ALL or
     ASSUME(X>0) has been done, SQRT(X^2) will become X.  (b) If
     RADEXPAND is TRUE and DOMAIN is REAL (its default), SQRT(X^2) will
     become ABS(X).  (c) If RADEXPAND is FALSE, or RADEXPAND is TRUE
     and DOMAIN is COMPLEX, SQRT(X^2) will be returned.  (The notion of
     DOMAIN with settings of REAL or COMPLEX is still in its infancy.
     Note that its setting here only matters when RADEXPAND is TRUE.)


 - Variable: RADPRODEXPAND
     - this switch has been renamed RADEXPAND.


 - Variable: RADSUBSTFLAG
     default: [FALSE] - if TRUE permits RATSUBST to make substitutions
     such as U for SQRT(X) in X.


 - declaration: RASSOCIATIVE
     - If DECLARE(G,RASSOCIATIVE); is done, this tells the simplifier
     that G is right-associative.  E.g.  G(G(A,B),G(C,D)) will simplify
     to G(A,G(B,G(C,D))).


 - Function: SCSIMP (exp,rule1, rule2,...,rulen)
     Sequential Comparative Simplification [Stoute]) takes an
     expression (its first argument) and a set of identities, or rules
     (its other arguments) and tries simplifying.  If a smaller
     expression is obtained, the process repeats.  Otherwise after all
     simplifications are tried, it returns the original answer.  For
     examples, try EXAMPLE(SCSIMP); .


 - Function: SIMP
     causes exp to be simplified regardless of the setting of the
     switch SIMP which inhibits simplification if FALSE.


 - Variable: SIMPSUM
     default: [FALSE] - if TRUE, the result of a SUM is simplified.
     This simplification may sometimes be able to produce a closed
     form.  If SIMPSUM is FALSE or if 'SUM is used, the value is a sum
     noun form which is a representation of the sigma notation used in
     mathematics.


 - Function: SUMCONTRACT (expr)
     will combine all sums of an addition that have upper and lower
     bounds that differ by constants. The result will be an expression
     containing one summation for each set of such summations added to
     all appropriate extra terms that had to be extracted to form this
     sum.  SUMCONTRACT will combine all compatible sums and use one of
     the indices from one of the sums if it can, and then try to form a
     reasonable index if it cannot use any supplied.  It may be
     necessary to do an INTOSUM(expr) before the SUMCONTRACT.


 - Variable: SUMEXPAND
     default: [FALSE] if TRUE, products of sums and exponentiated sums
     are converted into nested sums. For example:
                  SUMEXPAND:TRUE$
                  SUM(F(I),I,0,M)*SUM(G(J),J,0,N); ->
                                  'SUM('SUM(F(I1)*G(I2),I2,0,N),I1,0,M)
                  SUM(F(I),I,0,M)^2; -> 'SUM('SUM(F(I3)*F(I4),I4,0,M),I3,0,M)

     If FALSE, they are left alone.  See also CAUCHYSUM.


 - Variable: SUMHACK
     default: [FALSE] - if set to TRUE then SUM(F(I),I,3,1); will yield
     -F(2), by the identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1)
     when A>B.


 - Variable: SUMSPLITFACT
     default: [TRUE] - if set to FALSE will cause MINFACTORIAL to be
     applied after a FACTCOMB.


 - declaration: SYMMETRIC
     - If DECLARE(H,SYMMETRIC); is done, this tells the simplifier that
     H is a symmetric function.  E.g. H(X,Z,Y) will simplify to H(X, Y,
     Z).  This is the same as COMMUTATIVE.


 - Function: UNKNOWN (exp)
     returns TRUE iff exp contains an operator or function not known to
     the built-in simplifier.



File: maxima.info,  Node: Plotting,  Next: Input and Output,  Prev: Simplification,  Up: Top

Plotting
********

* Menu:

* Definitions for Plotting::


File: maxima.info,  Node: Definitions for Plotting,  Prev: Plotting,  Up: Plotting

Definitions for Plotting
========================

 - Variable: IN_NETMATH [FALSE]
     If not nil, then plot2d will output a representation of the plot
     which is suitable for openplot functions.

 - Function: OPENPLOT_CURVES list rest-options
     Takes a list of curves such as
          [[x1,y1,x2,y2,...],[u1,v1,u2,v2,...],..]
          or
           [[[x1,y1],[x2,y2],...],.. ]
     and plots them.  This is similar to xgraph_curves, but uses the
     open plot routines.  Addtional symbol arguments may be given such
     as ` "{xrange -3 4}" ' The following plots two curves, using big
     points, labeling the first one `jim' and the second one `jane'.
          openplot_curves([["{plotpoints 1} {pointsize 6} {label jim}
                {text {xaxislabel {joe is nice}}}"] ,
                [1,2,3,4,5,6,7,8],
                ["{label jane} {color pink } "], [3,1,4,2,5,7]]);

     Some other special keywords are xfun, color, plotpoints,
     linecolors, pointsize, nolines, bargraph, labelposition,
     xaxislabel, and yaxislabel.


 - Function: PLOT2D (expr,range,...,options,..)
 - Function: PLOT2D ([expr1,expr2,..,exprn],xrange,...,options,..)
 - Function: PLOT2D (parametric_expr)
 - Function: PLOT2D ([..,expr,..,parametric_expr,..],xrange,...,options)
     EXPR is an expression to be plotted on y axis as a function of 1
     variable.  RANGE is of the form [var,min,max] and expr is assumed
     to be an expression to be plotted against VAR.  In the second form
     of the function a list of expressions may be given to plot against
     VAR.   Truncation in the y direction will be performed, for the
     default y range.   It may be specified as an option or using
     SET_PLOT_OPTION.

          (C1) plot2d(sin(x),[x,-5,5]);
          (C2) plot2d(sec(x),[x,-2,2],[y,-20,20],[nticks,200]);

     Anywhere there may be an EXPR you may also use a parametric
     expression: PARAMETRIC_EXPR is a Maxima list of the form
     `[parametric, xexpr, yexpr, trange, ..options]' Here XEXPR and
     YEXPR are functions of 1 variable VAR which is the first element
     of the range TRANGE.  The plot is of the path traced out by the
     pair `[XEXPR, YEXPR]' as VAR varies in TRANGE.  In the following
     example, we plot a circle, then we do the plot with only a few
     points used, so that we get a star, and finally we plot this
     together with an ordinary function of X.

          (C1) plot2d([parametric,cos(t),sin(t),[t,-%pi*2,%pi*2]]);
          (C2) plot2d([parametric,cos(t),sin(t),[t,-%pi*2,%pi*2],
                  [nticks,8]]);
          (C3) plot2d([x^3+2,[parametric,cos(t),sin(t),[t,-5,5]]],
                  [x,-3,3]);


 - Function: xgraph_curves (list)
     graphs the list of `point sets' given in list by using xgraph.

     A point set may be of the form

          [x0,y0,x1,y1,x2,y2,...] or
          [[x0,y0],[x1,y1],....]
     A point set may also contain symbols which give labels or other
     information.

           xgraph_curves([pt_set1,pt_set2,pt_set3]);
     would graph the three point sets as three curves.

          pt_set:append(["NoLines: True","LargePixels: true"],
                  [x0,y0,x1,y1,...])

     would make the point set [and subsequent ones], have no lines
     between points, and to use large pixels.  See the man page on
     xgraph for more options to specify.

          pt_set:append([concat("\"","x^2+y")],[x0,y0,x1,y1,...])

     would make there be a "label" of "x^2+y" for this particular point
     set.    The `"' at the beginning is what tells xgraph this is a
     label.

          pt_set:append([concat("TitleText: Sample Data")],[x0,...])

     would make the main title of the plot be "Sample Data" instead of
     "Maxima PLot".

     To make a bar graph with bars which are .2 units wide, and to plot
     two possibly different such bar graphs:
          xgraph_curves(
                 [append(["BarGraph: true","NoLines: true","BarWidth: .2"],
                         create_list([i-.2,i^2],i,1,3)),
                  append(["BarGraph: true","NoLines: true","BarWidth: .2"],
                     create_list([i+.2,.7*i^2],i,1,3))
          ]);

     A temporary file `xgraph-out' is used.


 - Variable: PLOT_OPTIONS
     Members of this list indicate defaults for plotting.  They may be
     altered using SET_PLOT_OPTION

          [X, - 3, 3]
          [Y, - 3, 3]

     are the x range and y range respectively.

     [TRANSFORM_XY, FALSE] if not false, should be the output of

          make_transform([x,y,z], [f1(x,y,z),f2(x,y,z),f3(x,y,z)])
     which produces a transformation from 3 space to 3 space, which
     will be applied to the graph.   A built in one is polar_xy which
     gives the same as

          make_transform([r,th,z],[r*cos(th),r*sin(th),z])

     [RUN_VIEWER,TRUE] if not false, means run the viewer software -
     don't just output a data file.

     [GRID,30,30] means plot3d should divide the x range into 30
     intervals and similarly the y range.

     [COLOUR_Z,false] applies to colouring done with plot_format ps.

     [PLOT_FORMAT,OPENMATH] is for plot3d and currently  OPENMATH,
     GNUPLOT, PS, and GEOMVIEW are supported.

     There are good quality public domain viewers for these formats.
     They are openmath, izic, gnuplot, ghostview, and geomview.

     The Openmath viewer is in the distribution, and is based on tcl/tk.
     The executable is `maxima/bin/omplotdata'.  The viewer lets you
     zoom in, slide around, and rotate (if 3 dimensional).  This format
     is also the one used by netmath, for making plots with Netmath.
     (see `http://www.ma.utexas.edu/users/wfs/netmath.html')

     geomview is from the Geometry Center at the University of
     Minnesota, and is available from
     `http://www.geom.umn.edu/software/download/geomview.html' or by
     anonymous ftp from
     `ftp://ftp.geom.umn.edu/pub/software/geomview/'.  It is currently
     not quite as pretty as izic, but provides excellent support for
     multiple objects and multiple lights.

     gnuplot is everywhere as is ghostview.   We also provide mgnuplot,
     a tcl interface for gnuplot, which lets you rotate the plots using
     the mouse and a scale.

     izic is available by ftp from zenon.inria.fr.  Contact one of

     {fournier,kajler,mourrain}@sophia.inria.fr.

     It has beautiful colour gouraud shading, and very fast wireframe.
     It runs on X windows.


 - Function: PLOT3D (expr,xrange,yrange,...,options,..)
 - Function: PLOT3D ([expr1,expr2,expr3],xrange,yrange,...,options,..)
          plot3d(2^(-u^2+v^2),[u,-5,5],[v,-7,7]);
     would plot z = 2^(-u^2+v^2) with u and v varying in [-5,5] and
     [-7,7] respectively, and with u on the x axis, and v on the y axis.

     An example of the second pattern of arguments is
          plot3d([cos(x)*(3+y*cos(x/2)),sin(x)*(3+y*cos(x/2)),y*sin(x/2)],
             [x,-%pi,%pi],[y,-1,1],['grid,50,15])

     which will plot a moebius band, parametrized by the 3 expressions
     given as the first argument to plot3d.  An additional optional
     argument [grid,50,15] gives the grid number of rectangles in the x
     direction and y direction.

          /* REal part of z ^ 1/3 */
           plot3d(r^.33*cos(th/3),[r,0,1],[th,0,6*%pi],
               ['grid,12,80],['PLOT_FORMAT,ps],
               ['TRANSFORM_XY,POLAR_TO_XY],['VIEW_DIRECTION,1,1,1.4],
               ['COLOUR_Z,true])

     Here the View_direction indicates the direction from which we take
     a projection.  We actually do this from infinitely far away, but
     parallel to the line from view_direction to the origin.  This is
     currently only used in 'ps' plot_format, since the other viewers
     allow interactive rotating of the object.

     Another example is a moebius band:
          plot3d([cos(x)*(3+y*cos(x/2)),
                    sin(x)*(3+y*cos(x/2)),y*sin(x/2)],
                     [x,-%pi,%pi],[y,-1,1],['grid,50,15]);

     or a klein bottle:

          plot3d([5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0) - 10.0,
                    -5*sin(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0),
                     5*(-sin(x/2)*cos(y)+cos(x/2)*sin(2*y))],
                     [x,-%pi,%pi],[y,-%pi,%pi],['grid,40,40])

     or a torus
          plot3d([cos(y)*(10.0+6*cos(x)),
                     sin(y)*(10.0+6*cos(x)),
                     -6*sin(x)], [x,0,2*%pi],[y,0,2*%pi],
                      ['grid,40,40])
     We can output to gnplot too:

           plot3d(2^(x^2-y^2),[x,-1,1],[y,-2,2],[plot_format,gnuplot])

     Sometimes you may need to define a function to plot the
     expression.  All the arguments to plot3d are evaluated before
     being passed to plot3d, and so trying to make an expression which
     does just what you want may be difficult, and it is just easier to
     make a function.
          M:MATRIX([1,2,3,4],[1,2,3,2],[1,2,3,4],[1,2,3,3])$
          f(x,y):=float(M[?round(x),?round(y)]);
          plot3d(f,[x,1,4],[y,1,4],['grid,4,4]);


 - Function: PLOT2D_PS (expr,range)
     writes to pstream a sequence of postscript commands which plot
     EXPR for RANGE.  EXPR should be an expression of 1 variable.
     RANGE should be of the form [variable,min,max] over which to plot
     expr.  see CLOSEPS.


 - Function: CLOSEPS ()
     This should usually becalled at the end of a sequence of plotting
     commands.   It closes the current output stream PSTREAM, and sets
     it to nil.   It also may be called at the start of a plot, to
     ensure pstream is closed if it was open.    All commands which
     write to pstream, open it if necessary.   CLOSEPS is separate from
     the other plotting commands, since we may want to plot 2 ranges or
     superimpose several plots, and so must keep the stream open.

 - Function: SET_PLOT_OPTION (option)
     option is of the format of one of the elements of the PLOT_OPTIONS
     list.  Thus
          SET_PLOT_OPTION([grid,30,40])
     would change the default grid used by plot3d.   Note that if the
     symbol grid has a value, then you should quote it here:
          SET_PLOT_OPTION(['grid,30,40])
     so that the value will not be substituted.

 - Function: PSDRAW_CURVE (ptlist)
     Draws a curve connecting the points in PTLIST.   The latter may be
     of the form [x0,y0,x1,y1,...] or [[x0,y0],[x1,y1],...]  The
     function JOIN is handy for taking a list of x's and a list of y's
     and splicing them together.  PSDRAW_CURVE simply invokes the more
     primitive function PSCURVE.   Here is the definition:

          (defun $psdraw_curve (lis)
            (p "newpath")
            ($pscurve lis)
            (p "stroke"))

     ?DRAW2D  may also be used to produce a list
           points1:?draw2d(1/x,[.05,10],.03)


 - Function: PSCOM (com)
     COM will be inserted in the poscript file eg
            pscom("4.5 72 mul 5.5 72 mul translate  14 14 scale");



File: maxima.info,  Node: Input and Output,  Next: Floating Point,  Prev: Plotting,  Up: Top

Input and Output
****************

* Menu:

* Introduction to Input and Output::
* FILES::
* PLAYBACK::
* Definitions for Input and Output::


File: maxima.info,  Node: Introduction to Input and Output,  Next: FILES,  Prev: Input and Output,  Up: Input and Output

Introduction to Input and Output
================================


File: maxima.info,  Node: FILES,  Next: PLAYBACK,  Prev: Introduction to Input and Output,  Up: Input and Output

FILES
=====

   - A file is simply an area on a particular storage device which
contains data or text.  The only storage devices which are used on the
MC machine are disks and tapes.  Files on the disks are figuratively
grouped into "directories".  A directory is just a list of all the
files stored under a given user name.  Do DESCRIBE(FILEOP); for details
of how you may inspect your files using MACSYMA.  Other commands which
deal with files are: SAVE, FASSAVE, STORE, LOAD, LOADFILE, RESTORE,
UNSTORE, STRINGOUT, BATCH, BATCON, DEMO, WRITEFILE, CLOSEFILE, DELFILE,
REMFILE, and APPENDFILE.


File: maxima.info,  Node: PLAYBACK,  Next: Definitions for Input and Output,  Prev: FILES,  Up: Input and Output

PLAYBACK
========

   It is possible to play back the input lines in a temporary scroll
down window, and so not lose ones current work.  This can be done by
typing Function  E.  A numeric argument tells it the line number to
start at, otherwise it will go back about 40 lines.

