This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynomials

12.2 Definitions for Polynomials
================================

 -- Option variable: algebraic
     Default value: `false'

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.


 -- Option variable: berlefact
     Default value: `true'

     When `berlefact' is `false' then the Kronecker factoring algorithm
     will be used otherwise the Berlekamp algorithm, which is the
     default, will be used.


 -- Function: bezout (<p1>, <p2>, <x>)
     an alternative to the `resultant' command.  It returns a matrix.
     `determinant' of this matrix is the desired resultant.


 -- Function: bothcoef (<expr>, <x>)
     Returns a list whose first member is the coefficient of <x> in
     <expr> (as found by `ratcoef' if <expr> is in CRE form otherwise
     by `coeff') and whose second member is the remaining part of
     <expr>.  That is, `[A, B]' where `<expr> = A*<x> + B'.

     Example:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Function: coeff (<expr>, <x>, <n>)
     Returns the coefficient of `<x>^<n>' in <expr>.  <n> may be
     omitted if it is 1.  <x> may be an atom, or complete subexpression
     of <expr> e.g., `sin(x)', `a[i+1]', `x + y', etc. (In the last
     case the expression `(x + y)' should occur in <expr>).  Sometimes
     it may be necessary to expand or factor <expr> in order to make
     `<x>^<n>' explicit.  This is not done automatically by `coeff'.

     Examples:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1


 -- Function: combine (<expr>)
     Simplifies the sum <expr> by combining terms with the same
     denominator into a single term.


 -- Function: content (<p_1>, <x_1>, ..., <x_n>)
     Returns a list whose first element is the greatest common divisor
     of the coefficients of the terms of the polynomial <p_1> in the
     variable <x_n> (this is the content) and whose second element is
     the polynomial <p_1> divided by the content.

     Examples:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Function: denom (<expr>)
     Returns the denominator of the rational expression <expr>.


 -- Function: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     computes the quotient and remainder of the polynomial <p_1>
     divided by the polynomial <p_2>, in a main polynomial variable,
     <x_n>.  The other variables are as in the `ratvars' function.  The
     result is a list whose first element is the quotient and whose
     second element is the remainder.

     Examples:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note that `y' is the main variable in the second example.


 -- Function: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Eliminates variables from equations (or expressions assumed equal
     to zero) by taking successive resultants. This returns a list of
     `<n> - <k>' expressions with the <k> variables <x_1>, ..., <x_k>
     eliminated.  First <x_1> is eliminated yielding `<n> - 1'
     expressions, then `x_2' is eliminated, etc.  If `<k> = <n>' then a
     single expression in a list is returned free of the variables
     <x_1>, ..., <x_k>.  In this case `solve' is called to solve the
     last resultant for the last variable.

     Example:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Function: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Returns a list whose first element is the g.c.d of the polynomials
     <p_1>, <p_2>, <p_3>, ...  and whose remaining elements are the
     polynomials divided by the g.c.d.  This always uses the `ezgcd'
     algorithm.


 -- Option variable: facexpand
     Default value: `true'

     `facexpand' controls whether the irreducible factors returned by
     `factor' are in expanded (the default) or recursive (normal CRE)
     form.


 -- Function: factcomb (<expr>)
     Tries to combine the coefficients of factorials in <expr> with the
     factorials themselves by converting, for example, `(n + 1)*n!'
     into `(n + 1)!'.

     `sumsplitfact' if set to `false' will cause `minfactorial' to be
     applied after a `factcomb'.


 -- Function: factor (<expr>)
     Factors the expression <expr>, containing any number of variables
     or functions, into factors irreducible over the integers.  `factor
     (<expr>, p)' factors <expr> over the field of integers with an
     element adjoined whose minimum polynomial is p.

     `factorflag' if `false' suppresses the factoring of integer factors
     of rational expressions.

     `dontfactor' may be set to a list of variables with respect to
     which factoring is not to occur.  (It is initially empty).
     Factoring also will not take place with respect to any variables
     which are less important (using the variable ordering assumed for
     CRE form) than those on the `dontfactor' list.

     `savefactors' if `true' causes the factors of an expression which
     is a product of factors to be saved by certain functions in order
     to speed up later factorizations of expressions containing some of
     the same factors.

     `berlefact' if `false' then the Kronecker factoring algorithm will
     be used otherwise the Berlekamp algorithm, which is the default,
     will be used.

     `intfaclim' is the largest divisor which will be tried when
     factoring a bignum integer.  If set to `false' (this is the case
     when the user calls `factor' explicitly), or if the integer is a
     fixnum (i.e.  fits in one machine word), complete factorization of
     the integer will be attempted.  The user's setting of `intfaclim'
     is used for internal calls to `factor'. Thus, `intfaclim' may be
     reset to prevent Maxima from taking an inordinately long time
     factoring large integers.

     Examples:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Option variable: factorflag
     Default value: `false'

     When `factorflag' is `false', suppresses the factoring of integer
     factors of rational expressions.


 -- Function: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranges the sum <expr> into a sum of terms of the form `f
     (<x_1>, <x_2>, ...)*g' where `g' is a product of expressions not
     containing any <x_i> and `f' is factored.


 -- Function: factorsum (<expr>)
     Tries to group terms in factors of <expr> which are sums into
     groups of terms such that their sum is factorable.  `factorsum' can
     recover the result of `expand ((x + y)^2 + (z + w)^2)' but it
     can't recover `expand ((x + 1)^2 + (x + y)^2)' because the terms
     have variables in common.

     Example:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Function: fasttimes (<p_1>, <p_2>)
     Returns the product of the polynomials <p_1> and <p_2> by using a
     special algorithm for multiplication of polynomials.  `p_1' and
     `p_2' should be multivariate, dense, and nearly the same size.
     Classical multiplication is of order `n_1 n_2' where `n_1' is the
     degree of `p_1' and `n_2' is the degree of `p_2'.  `fasttimes' is
     of order `max (n_1, n_2)^1.585'.


 -- Function: fullratsimp (<expr>)
     `fullratsimp' repeatedly applies `ratsimp' followed by
     non-rational simplification to an expression until no further
     change occurs, and returns the result.

     When non-rational expressions are involved, one call to `ratsimp'
     followed as is usual by non-rational ("general") simplification
     may not be sufficient to return a simplified result.  Sometimes,
     more than one such call may be necessary.  `fullratsimp' makes
     this process convenient.

     `fullratsimp (<expr>, <x_1>, ..., <x_n>)' takes one or more
     arguments similar to `ratsimp' and `rat'.

     Example:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Function: fullratsubst (<a>, <b>, <c>)
     is the same as `ratsubst' except that it calls itself recursively
     on its result until that result stops changing.  This function is
     useful when the replacement expression and the replaced expression
     have one or more variables in common.

     `fullratsubst' will also accept its arguments in the format of
     `lratsubst'.  That is, the first argument may be a single
     substitution equation or a list of such equations, while the
     second argument is the expression being processed.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' is equivalent to `ratsubst' except that it
          recurses until its result stops changing.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' also accepts a list of equations or a single
          equation as first argument.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' may cause an indefinite recursion.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
     Returns the greatest common divisor of <p_1> and <p_2>.  The flag
     `gcd' determines which algorithm is employed.  Setting `gcd' to
     `ez', `eez', `subres', `red', or `spmod' selects the `ezgcd', New
     `eez' `gcd', subresultant `prs', reduced, or modular algorithm,
     respectively.  If `gcd' `false' then GCD(p1,p2,var) will always
     return 1 for all var.  Many functions (e.g.  `ratsimp', `factor',
     etc.) cause gcd's to be taken implicitly.  For homogeneous
     polynomials it is recommended that `gcd' equal to `subres' be
     used.  To take the gcd when an algebraic is present, e.g.
     GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , `algebraic' must be `true' and
     `gcd' must not be `ez'.  `subres' is a new algorithm, and people
     who have been using the `red' setting should probably change it to
     `subres'.

     The `gcd' flag, default: `subres', if `false' will also prevent
     the greatest common divisor from being taken when expressions are
     converted to canonical rational expression (CRE) form.  This will
     sometimes speed the calculation if gcds are not required.


 -- Function: gcdex (<f>, <g>)
 -- Function: gcdex (<f>, <g>, <x>)
     Returns a list `[<a>, <b>, <u>]' where <u> is the greatest common
     divisor (gcd) of <f> and <g>, and <u> is equal to `<a> <f> + <b>
     <g>'.  The arguments <f> and <g> should be univariate polynomials,
     or else polynomials in <x> a supplied main variable since we need
     to be in a principal ideal domain for this to work.  The gcd means
     the gcd regarding <f> and <g> as univariate polynomials with
     coefficients being rational functions in the other variables.

     `gcdex' implements the Euclidean algorithm, where we have a
     sequence of `L[i]: [a[i], b[i], r[i]]' which are all perpendicular
     to `[f, g, -1]' and the next one is built as if `q =
     quotient(r[i]/r[i+1])' then `L[i+2]: L[i] - q L[i+1]', and it
     terminates at `L[i+1]' when the remainder `r[i+2]' is zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note that the gcd in the following is `1' since we work in
     `k(y)[x]', not the  `y+1' we would expect in `k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1


 -- Function: gcfactor (<n>)
     Factors the Gaussian integer <n> over the Gaussian integers, i.e.,
     numbers of the form `<a> + <b> `%i'' where <a> and <b> are
     rational integers (i.e.,  ordinary integers).  Factors are
     normalized by making <a> and <b> non-negative.


 -- Function: gfactor (<expr>)
     Factors the polynomial <expr> over the Gaussian integers (that is,
     the integers with the imaginary unit `%i' adjoined).  This is like
     `factor (<expr>, <a>^2+1)' where <a> is `%i'.

     Example:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Function: gfactorsum (<expr>)
     is similar to `factorsum' but applies `gfactor' instead of
     `factor'.


 -- Function: hipow (<expr>, <x>)
     Returns the highest explicit exponent of <x> in <expr>.  <x> may
     be a variable or a general expression.  If <x> does not appear in
     <expr>, `hipow' returns `0'.

     `hipow' does not consider expressions equivalent to `expr'.  In
     particular, `hipow' does not expand `expr', so `hipow (<expr>,
     <x>)' and `hipow (expand (<expr>, <x>))' may yield different
     results.

     Examples:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Option variable: intfaclim
     Default value: 1000

     `intfaclim' is the largest divisor which will be tried when
     factoring a bignum integer.

     When `intfaclim' is `false' (this is the case when the user calls
     `factor' explicitly), or if the integer is a fixnum (i.e., fits in
     one machine word), factors of any size are considered.
     `intfaclim' is set to `false' when factors are computed in
     `divsum', `totient', and `primep'.

     Internal calls to `factor' respect the user-specified value of
     `intfaclim'.  Setting `intfaclim' to a smaller value may reduce the
     time spent factoring large integers.


 -- Option variable: keepfloat
     Default value: `false'

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.


 -- Function: lratsubst (<L>, <expr>)
     is analogous to `subst (<L>, <expr>)' except that it uses
     `ratsubst' instead of `subst'.

     The first argument of `lratsubst' is an equation or a list of
     equations identical in format to that accepted by `subst'.  The
     substitutions are made in the order given by the list of equations,
     that is, from left to right.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Option variable: modulus
     Default value: `false'

     When `modulus' is a positive number <p>, operations on rational
     numbers (as returned by `rat' and related functions) are carried
     out modulo <p>, using the so-called "balanced" modulus system in
     which `<n> modulo <p>' is defined as an integer <k> in
     `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' when <p> is odd, or
     `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' when <p> is even, such that
     `<a> <p> + <k>' equals <n> for some integer <a>.

     If <expr> is already in canonical rational expression (CRE) form
     when `modulus' is reset, then you may need to re-rat <expr>, e.g.,
     `expr: rat (ratdisrep (expr))', in order to get correct results.

     Typically `modulus' is set to a prime number.  If `modulus' is set
     to a positive non-prime integer, this setting is accepted, but a
     warning message is displayed.  Maxima will allow zero or a
     negative integer to be assigned to `modulus', although it is not
     clear if that has any useful consequences.


 -- Function: num (<expr>)
     Returns the numerator of <expr> if it is a ratio.  If <expr> is
     not a ratio, <expr> is returned.

     `num' evaluates its argument.


 -- Function: polydecomp (<p>, <x>)
     Decomposes the polynomial <p> in the variable <x> into the
     functional composition of polynomials in <x>.  `polydecomp'
     returns a list `[<p_1>, ..., <p_n>]' such that

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))

     is equal to <p>.  The degree of <p_i> is greater than 1 for <i>
     less than <n>.

     Such a decomposition is not unique.

     Examples:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     The following function composes `L = [e_1, ..., e_n]' as functions
     in `x'; it is the inverse of polydecomp:

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-express above example using `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note that though `compose (polydecomp (<p>, <x>), <x>)' always
     returns <p> (unexpanded), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' does not necessarily return `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Function: quotient (<p_1>, <p_2>)
 -- Function: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Returns the polynomial <p_1> divided by the polynomial <p_2>.  The
     arguments <x_1>, ..., <x_n> are interpreted as in `ratvars'.

     `quotient' returns the first element of the two-element list
     returned by `divide'.


 -- Function: rat (<expr>)
 -- Function: rat (<expr>, <x_1>, ..., <x_n>)
     Converts <expr> to canonical rational expression (CRE) form by
     expanding and combining all terms over a common denominator and
     cancelling out the greatest common divisor of the numerator and
     denominator, as well as converting floating point numbers to
     rational numbers within a tolerance of `ratepsilon'.  The
     variables are ordered according to the <x_1>, ..., <x_n>, if
     specified, as in `ratvars'.

     `rat' does not generally simplify functions other than addition
     `+', subtraction `-', multiplication `*', division `/', and
     exponentiation to an integer power, whereas `ratsimp' does handle
     those cases.  Note that atoms (numbers and variables) in CRE form
     are not the same as they are in the general form.  For example,
     `rat(x)- x' yields `rat(0)' which has a different internal
     representation than 0.

     When `ratfac' is `true', `rat' yields a partially factored form
     for CRE.  During rational operations the expression is maintained
     as fully factored as possible without an actual call to the factor
     package.  This should always save space and may save some time in
     some computations.  The numerator and denominator are still made
     relatively prime (e.g.  `rat ((x^2 - 1)^4/(x + 1)^2)' yields `(x -
     1)^4 (x + 1)^2)', but the factors within each part may not be
     relatively prime.

     `ratprint' if `false' suppresses the printout of the message
     informing the user of the conversion of floating point numbers to
     rational numbers.

     `keepfloat' if `true' prevents floating point numbers from being
     converted to rational numbers.

     See also `ratexpand' and  `ratsimp'.

     Examples:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Option variable: ratalgdenom
     Default value: `true'

     When `ratalgdenom' is `true', allows rationalization of
     denominators with respect to radicals to take effect.
     `ratalgdenom' has an effect only when canonical rational
     expressions (CRE) are used in algebraic mode.


 -- Function: ratcoef (<expr>, <x>, <n>)
 -- Function: ratcoef (<expr>, <x>)
     Returns the coefficient of the expression `<x>^<n>' in the
     expression <expr>.  If omitted, <n> is assumed to be 1.

     The return value is free (except possibly in a non-rational sense)
     of the variables in <x>.  If no coefficient of this type exists, 0
     is returned.

     `ratcoef' expands and rationally simplifies its first argument and
     thus it may produce answers different from those of `coeff' which
     is purely syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y
     whereas `coeff' returns 1.

     `ratcoef (<expr>, <x>, 0)', viewing <expr> as a sum, returns a sum
     of those terms which do not contain <x>.  Therefore if <x> occurs
     to any negative powers, `ratcoef' should not be used.

     Since <expr> is rationally simplified before it is examined,
     coefficients may not appear quite the way they were envisioned.

     Example:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Function: ratdenom (<expr>)
     Returns the denominator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `denom' is similar, but returns an ordinary expression instead of
     a CRE.  Also, `denom' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratdenom' are not considered ratios by `denom'.


 -- Option variable: ratdenomdivide
     Default value: `true'

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     Examples:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Function: ratdiff (<expr>, <x>)
     Differentiates the rational expression <expr> with respect to <x>.
     <expr> must be a ratio of polynomials or a polynomial in <x>.  The
     argument <x> may be a variable or a subexpression of <expr>.

     The result is equivalent to `diff', although perhaps in a
     different form.  `ratdiff' may be faster than `diff', for rational
     expressions.

     `ratdiff' returns a canonical rational expression (CRE) if `expr'
     is a CRE.  Otherwise, `ratdiff' returns a general expression.

     `ratdiff' considers only the dependence of <expr> on <x>, and
     ignores any dependencies established by `depends'.

     Example:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Function: ratdisrep (<expr>)
     Returns its argument as a general expression.  If <expr> is a
     general expression, it is returned unchanged.

     Typically `ratdisrep' is called to convert a canonical rational
     expression (CRE) into a general expression.  This is sometimes
     convenient if one wishes to stop the "contagion", or use rational
     functions in non-rational contexts.

     See also `totaldisrep'.


 -- Option variable: ratepsilon
     Default value: 2.0e-8

     `ratepsilon' is the tolerance used in the conversion of floating
     point numbers to rational numbers.


 -- Function: ratexpand (<expr>)
 -- Option variable: ratexpand
     Expands <expr> by multiplying out products of sums and
     exponentiated sums, combining fractions over a common denominator,
     cancelling the greatest common divisor of the numerator and
     denominator, then splitting the numerator (if a sum) into its
     respective terms divided by the denominator.

     The return value of `ratexpand' is a general expression, even if
     <expr> is a canonical rational expression (CRE).

     The switch `ratexpand' if `true' will cause CRE expressions to be
     fully expanded when they are converted back to general form or
     displayed, while if it is `false' then they will be put into a
     recursive form.  See also `ratsimp'.

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.

     Examples:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Option variable: ratfac
     Default value: `false'

     When `ratfac' is `true', canonical rational expressions (CRE) are
     manipulated in a partially factored form.

     During rational operations the expression is maintained as fully
     factored as possible without calling `factor'.  This should always
     save space and may save time in some computations.  The numerator
     and denominator are made relatively prime, for example `rat ((x^2
     - 1)^4/(x + 1)^2)' yields `(x - 1)^4 (x + 1)^2)', but the factors
     within each part may not be relatively prime.

     In the `ctensr' (Component Tensor Manipulation) package, Ricci,
     Einstein, Riemann, and Weyl tensors and the scalar curvature are
     factored automatically when `ratfac' is `true'.  `ratfac' should
     only be set for cases where the tensorial components are known to
     consist of few terms.

     The `ratfac' and `ratweight' schemes are incompatible and may not
     both be used at the same time.


 -- Function: ratnumer (<expr>)
     Returns the numerator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `num' is similar, but returns an ordinary expression instead of a
     CRE.  Also, `num' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratnumer' are not considered ratios by `num'.


 -- Function: ratnump (<expr>)
     Returns `true' if <expr> is a literal integer or ratio of literal
     integers, otherwise `false'.


 -- Function: ratp (<expr>)
     Returns `true' if <expr> is a canonical rational expression (CRE)
     or extended CRE, otherwise `false'.

     CRE are created by `rat' and related functions.  Extended CRE are
     created by `taylor' and related functions.


 -- Option variable: ratprint
     Default value: `true'

     When `ratprint' is `true', a message informing the user of the
     conversion of floating point numbers to rational numbers is
     displayed.


 -- Function: ratsimp (<expr>)
 -- Function: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifies the expression <expr> and all of its subexpressions,
     including the arguments to non-rational functions.  The result is
     returned as the quotient of two polynomials in a recursive form,
     that is, the coefficients of the main variable are polynomials in
     the other variables.  Variables may include non-rational functions
     (e.g., `sin (x^2 + 1)') and the arguments to any such functions
     are also rationally simplified.

     `ratsimp (<expr>, <x_1>, ..., <x_n>)' enables rational
     simplification with the specification of variable ordering as in
     `ratvars'.

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.

     See also `ratexpand'.  Note that `ratsimp' is affected by some of
     the flags which affect `ratexpand'.

     Examples:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Option variable: ratsimpexpons
     Default value: `false'

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.


 -- Function: ratsubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c> and returns the resulting
     expression.  <b> may be a sum, product, power, etc.

     `ratsubst' knows something of the meaning of expressions whereas
     `subst' does a purely syntactic substitution.  Thus `subst (a, x +
     y, x + y + z)' returns `x + y + z' whereas `ratsubst' returns `z +
     a'.

     When `radsubstflag' is `true', `ratsubst' makes substitutions for
     radicals in expressions which don't explicitly contain them.

     Examples:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Function: ratvars (<x_1>, ..., <x_n>)
 -- Function: ratvars ()
 -- System variable: ratvars
     Declares main variables <x_1>, ..., <x_n> for rational expressions.
     <x_n>, if present in a rational expression, is considered the main
     variable.  Otherwise, <x_[n-1]> is considered the main variable if
     present, and so on through the preceding variables to <x_1>, which
     is considered the main variable only if none of the succeeding
     variables are present.

     If a variable in a rational expression is not present in the
     `ratvars' list, it is given a lower priority than <x_1>.

     The arguments to `ratvars' can be either variables or non-rational
     functions such as `sin(x)'.

     The variable `ratvars' is a list of the arguments of the function
     `ratvars' when it was called most recently.  Each call to the
     function `ratvars' resets the list.  `ratvars ()' clears the list.


 -- Function: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Function: ratweight ()
     Assigns a weight <w_i> to the variable <x_i>.  This causes a term
     to be replaced by 0 if its weight exceeds the value of the
     variable `ratwtlvl' (default yields no truncation).  The weight of
     a term is the sum of the products of the weight of a variable in
     the term times its power.  For example, the weight of `3 x_1^2
     x_2' is `2 w_1 + w_2'.  Truncation according to `ratwtlvl' is
     carried out only when multiplying or exponentiating canonical
     rational expressions (CRE).

     `ratweight ()' returns the cumulative list of weight assignments.

     Note: The `ratfac' and `ratweight' schemes are incompatible and
     may not both be used at the same time.

     Examples:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- System variable: ratweights
     Default value: `[]'

     `ratweights' is the list of weights assigned by `ratweight'.  The
     list is cumulative: each call to `ratweight' places additional
     items in the list.

     `kill (ratweights)' and `save (ratweights)' both work as expected.


 -- Option variable: ratwtlvl
     Default value: `false'

     `ratwtlvl' is used in combination with the `ratweight' function to
     control the truncation of canonical rational expressions (CRE).
     For the default value of `false', no truncation occurs.


 -- Function: remainder (<p_1>, <p_2>)
 -- Function: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Returns the remainder of the polynomial <p_1> divided by the
     polynomial <p_2>.  The arguments <x_1>, ..., <x_n> are interpreted
     as in `ratvars'.

     `remainder' returns the second element of the two-element list
     returned by `divide'.


 -- Function: resultant (<p_1>, <p_2>, <x>)
 -- Variable: resultant
     Computes the resultant of the two polynomials <p_1> and <p_2>,
     eliminating the variable <x>.  The resultant is a determinant of
     the coefficients of <x> in <p_1> and <p_2>, which equals zero if
     and only if <p_1> and <p_2> have a non-constant factor in common.

     If <p_1> or <p_2> can be factored, it may be desirable to call
     `factor' before calling `resultant'.

     The variable `resultant' controls which algorithm will be used to
     compute the resultant.  `subres' for subresultant prs, `mod' for
     modular resultant algorithm, and `red' for reduced prs.  On most
     problems `subres' should be best.  On some large degree univariate
     or bivariate problems `mod' may be better.

     The function `bezout' takes the same arguments as `resultant' and
     returns a matrix.  The determinant of the return value is the
     desired resultant.


 -- Option variable: savefactors
     Default value: `false'

     When `savefactors' is `true', causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.


 -- Function: sqfr (<expr>)
     is similar to `factor' except that the polynomial factors are
     "square-free."  That is, they have factors only of degree one.
     This algorithm, which is also used by the first stage of `factor',
     utilizes the fact that a polynomial has in common with its n'th
     derivative all its factors of degree greater than n.  Thus by
     taking greatest common divisors with the polynomial of the
     derivatives with respect to each variable in the polynomial, all
     factors of degree greater than 1 can be found.

     Example:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)


 -- Function: tellrat (<p_1>, ..., <p_n>)
 -- Function: tellrat ()
     Adds to the ring of algebraic integers known to Maxima the
     elements which are the solutions of the polynomials <p_1>, ...,
     <p_n>.  Each argument <p_i> is a polynomial with integer
     coefficients.

     `tellrat (<x>)' effectively means substitute 0 for <x> in rational
     functions.

     `tellrat ()' returns a list of the current substitutions.

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.

     Maxima initially knows about the imaginary unit `%i' and all roots
     of integers.

     There is a command `untellrat' which takes kernels and removes
     `tellrat' properties.

     When `tellrat''ing a multivariate polynomial, e.g., `tellrat (x^2
     - y^2)', there would be an ambiguity as to whether to substitute
     `<y>^2' for `<x>^2' or vice versa.  Maxima picks a particular
     ordering, but if the user wants to specify which, e.g.  `tellrat
     (y^2 = x^2)' provides a syntax which says replace `<y>^2' by
     `<x>^2'.

     Examples:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Function: totaldisrep (<expr>)
     Converts every subexpression of <expr> from canonical rational
     expressions (CRE) to general form and returns the result.  If
     <expr> is itself in CRE form then `totaldisrep' is identical to
     `ratdisrep'.

     `totaldisrep' may be useful for ratdisrepping expressions such as
     equations, lists, matrices, etc., which have some subexpressions
     in CRE form.


 -- Function: untellrat (<x_1>, ..., <x_n>)
     Removes `tellrat' properties from <x_1>, ..., <x_n>.



File: maxima.info,  Node: Constants,  Next: Logarithms,  Prev: Polynomials,  Up: Top

13 Constants
************

* Menu:

* Definitions for Constants::


File: maxima.info,  Node: Definitions for Constants,  Prev: Constants,  Up: Constants

13.1 Definitions for Constants
==============================

 -- Constant: %e
     - the base of natural logarithms, e, is represented in Maxima as
     `%e'.


 -- Constant: false
     - the Boolean constant, false. (NIL in Lisp)


 -- Constant: inf
     - real positive infinity.


 -- Constant: infinity
     - complex infinity.


 -- Constant: minf
     - real minus infinity.


 -- Constant: %pi
     - "pi" is represented in Maxima as `%pi'.


 -- Constant: true
     - the Boolean constant, true. (T in Lisp)



File: maxima.info,  Node: Logarithms,  Next: Trigonometric,  Prev: Constants,  Up: Top

14 Logarithms
*************

* Menu:

* Definitions for Logarithms::


File: maxima.info,  Node: Definitions for Logarithms,  Prev: Logarithms,  Up: Logarithms

14.1 Definitions for Logarithms
===============================

 -- Option variable: %e_to_numlog
     Default value: `false'

     When `true', `r' some rational number, and `x' some expression,
     `%e^(r*log(x))' will be simplified into `x^r' .  It should be
     noted that the `radcan' command also does this transformation, and
     more complicated transformations of this ilk as well.  The
     `logcontract' command "contracts" expressions containing `log'.


 -- Function: li [<s>] (<z>)
     Represents the polylogarithm function of order <s> and argument
     <z>, defined by the infinite series

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' is `- log (1 - z)'.  `li [2]' and `li [3]' are the
     dilogarithm and trilogarithm functions, respectively.

     When the order is 1, the polylogarithm simplifies to `- log (1 -
     z)', which in turn simplifies to a numerical value if <z> is a
     real or complex floating point number or the `numer' evaluation
     flag is present.

     When the order is 2 or 3, the polylogarithm simplifies to a
     numerical value if <z> is a real floating point number or the
     `numer' evaluation flag is present.

     Examples:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Function: log (<x>)
     Represents the natural (base e) logarithm of <x>.

     Maxima does not have a built-in function for the base 10 logarithm
     or other bases.  `log10(x) := log(x) / log(10)' is a useful
     definition.

     Simplification and evaluation of logarithms is governed by several
     global flags:

     `logexpand' - causes `log(a^b)' to become `b*log(a)'.  If it is
     set to `all', `log(a*b)' will also simplify to `log(a)+log(b)'.
     If it is set to `super', then `log(a/b)' will also simplify to
     `log(a)-log(b)' for rational numbers `a/b', `a#1'.  (`log(1/b)',
     for `b' integer, always simplifies.)  If it is set to `false', all
     of these simplifications will be turned off.

     `logsimp' - if `false' then no simplification of `%e' to a power
     containing `log''s is done.

     `lognumer' - if `true' then negative floating point arguments to
     `log' will always be converted to their absolute value before the
     `log' is taken.  If `numer' is also `true', then negative integer
     arguments to `log' will also be converted to their absolute value.

     `lognegint' - if `true' implements the rule `log(-n)' ->
     `log(n)+%i*%pi' for `n' a positive integer.

     `%e_to_numlog' - when `true', `r' some rational number, and `x'
     some expression, `%e^(r*log(x))' will be simplified into `x^r' .
     It should be noted that the `radcan' command also does this
     transformation, and more complicated transformations of this ilk
     as well.  The `logcontract' command "contracts" expressions
     containing `log'.


 -- Option variable: logabs
     Default value: `false'

     When doing indefinite integration where logs are generated, e.g.
     `integrate(1/x,x)', the answer is given in terms of
     `log(abs(...))' if `logabs' is `true', but in terms of `log(...)'
     if `logabs' is `false'.  For definite integration, the
     `logabs:true' setting is used, because here "evaluation" of the
     indefinite integral at the endpoints is often needed.


 -- Option variable: logarc
     Default value: `false'

     If `true' will cause the inverse circular and hyperbolic functions
     to be converted into logarithmic form.  `logarc(<exp>)' will cause
     this conversion for a particular expression <exp> without setting
     the switch or having to re-evaluate the expression with `ev'.


 -- Option variable: logconcoeffp
     Default value: `false'

     Controls which coefficients are contracted when using
     `logcontract'.  It may be set to the name of a predicate function
     of one argument.  E.g. if you like to generate SQRTs, you can do
     `logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or
     ratnump(m)$' .  Then `logcontract(1/2*log(x));' will give
     `log(sqrt(x))'.


 -- Function: logcontract (<expr>)
     Recursively scans the expression <expr>, transforming
     subexpressions of the form `a1*log(b1) + a2*log(b2) + c' into
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     If you do `declare(n,integer);' then `logcontract(2*a*n*log(x));'
     gives `a*log(x^(2*n))'.  The coefficients that "contract" in this
     manner are those such as the 2 and the `n' here which satisfy
     `featurep(coeff,integer)'.  The user can control which
     coefficients are contracted by setting the option `logconcoeffp'
     to the name of a predicate function of one argument.  E.g. if you
     like to generate SQRTs, you can do `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Then
     `logcontract(1/2*log(x));' will give `log(sqrt(x))'.


 -- Option variable: logexpand
     Default value: `true'

     Causes `log(a^b)' to become `b*log(a)'.  If it is set to `all',
     `log(a*b)' will also simplify to `log(a)+log(b)'.  If it is set to
     `super', then `log(a/b)' will also simplify to `log(a)-log(b)' for
     rational numbers `a/b', `a#1'.  (`log(1/b)', for integer `b',
     always simplifies.)  If it is set to `false', all of these
     simplifications will be turned off.


 -- Option variable: lognegint
     Default value: `false'

     If `true' implements the rule `log(-n)' -> `log(n)+%i*%pi' for `n'
     a positive integer.


 -- Option variable: lognumer
     Default value: `false'

     If `true' then negative floating point arguments to `log' will
     always be converted to their absolute value before the `log' is
     taken.  If `numer' is also `true', then negative integer arguments
     to `log' will also be converted to their absolute value.


 -- Option variable: logsimp
     Default value: `true'

     If `false' then no simplification of `%e' to a power containing
     `log''s is done.


 -- Function: plog (<x>)
     Represents the principal branch of the complex-valued natural
     logarithm with `-%pi' < `carg(<x>)' <= `+%pi' .



File: maxima.info,  Node: Trigonometric,  Next: Special Functions,  Prev: Logarithms,  Up: Top

15 Trigonometric
****************

* Menu:

* Introduction to Trigonometric::
* Definitions for Trigonometric::


File: maxima.info,  Node: Introduction to Trigonometric,  Next: Definitions for Trigonometric,  Prev: Trigonometric,  Up: Trigonometric

15.1 Introduction to Trigonometric
==================================

Maxima has many trigonometric functions defined.  Not all trigonometric
identities are programmed, but it is possible for the user to add many
of them using the pattern matching capabilities of the system.  The
trigonometric functions defined in Maxima are: `acos', `acosh', `acot',
`acoth', `acsc', `acsch', `asec', `asech', `asin', `asinh', `atan',
`atanh', `cos', `cosh', `cot', `coth', `csc', `csch', `sec', `sech',
`sin', `sinh', `tan', and `tanh'.  There are a number of commands
especially for handling trigonometric functions, see `trigexpand',
`trigreduce', and the switch `trigsign'.  Two share packages extend the
simplification rules built into Maxima, `ntrig' and `atrig1'.  Do
`describe(<command>)' for details.


File: maxima.info,  Node: Definitions for Trigonometric,  Prev: Introduction to Trigonometric,  Up: Trigonometric

15.2 Definitions for Trigonometric
==================================

 -- Function: acos (<x>)
     - Arc Cosine.


 -- Function: acosh (<x>)
     - Hyperbolic Arc Cosine.


 -- Function: acot (<x>)
     - Arc Cotangent.


 -- Function: acoth (<x>)
     - Hyperbolic Arc Cotangent.


 -- Function: acsc (<x>)
     - Arc Cosecant.


 -- Function: acsch (<x>)
     - Hyperbolic Arc Cosecant.


 -- Function: asec (<x>)
     - Arc Secant.


 -- Function: asech (<x>)
     - Hyperbolic Arc Secant.


 -- Function: asin (<x>)
     - Arc Sine.


 -- Function: asinh (<x>)
     - Hyperbolic Arc Sine.


 -- Function: atan (<x>)
     - Arc Tangent.


 -- Function: atan2 (<y>, <x>)
     - yields the value of `atan(<y>/<x>)' in the interval `-%pi' to
     `%pi'.


 -- Function: atanh (<x>)
     - Hyperbolic Arc Tangent.


 -- Package: atrig1
     The `atrig1' package contains several additional simplification
     rules for inverse trigonometric functions.  Together with rules
     already known to Maxima, the following angles are fully
     implemented: `0', `%pi/6', `%pi/4', `%pi/3', and `%pi/2'.
     Corresponding angles in the other three quadrants are also
     available.  Do `load(atrig1);' to use them.


 -- Function: cos (<x>)
     - Cosine.


 -- Function: cosh (<x>)
     - Hyperbolic Cosine.


 -- Function: cot (<x>)
     - Cotangent.


 -- Function: coth (<x>)
     - Hyperbolic Cotangent.


 -- Function: csc (<x>)
     - Cosecant.


 -- Function: csch (<x>)
     - Hyperbolic Cosecant.


 -- Option variable: halfangles
     Default value: `false'

     When `halfangles' is `true', half-angles are simplified away.


 -- Package: ntrig
     The `ntrig' package contains a set of simplification rules that are
     used to simplify trigonometric function whose arguments are of the
     form `<f>(<n> %pi/10)' where <f> is any of the functions `sin',
     `cos', `tan', `csc', `sec' and `cot'.


 -- Function: sec (<x>)
     - Secant.


 -- Function: sech (<x>)
     - Hyperbolic Secant.


 -- Function: sin (<x>)
     - Sine.


 -- Function: sinh (<x>)
     - Hyperbolic Sine.


 -- Function: tan (<x>)
     - Tangent.


 -- Function: tanh (<x>)
     - Hyperbolic Tangent.


 -- Function: trigexpand (<expr>)
     Expands trigonometric and hyperbolic functions of sums of angles
     and of multiple angles occurring in <expr>.  For best results,
     <expr> should be expanded.  To enhance user control of
     simplification, this function expands only one level at a time,
     expanding sums of angles or multiple angles.  To obtain full
     expansion into sines and cosines immediately, set the switch
     `trigexpand: true'.

     `trigexpand' is governed by the following global flags:

    `trigexpand'
          If `true' causes expansion of all expressions containing
          sin's and cos's occurring subsequently.

    `halfangles'
          If `true' causes half-angles to be simplified away.

    `trigexpandplus'
          Controls the "sum" rule for `trigexpand', expansion of sums
          (e.g. `sin(x + y)') will take place only if `trigexpandplus'
          is `true'.

    `trigexpandtimes'
          Controls the "product" rule for `trigexpand', expansion of
          products (e.g. `sin(2 x)') will take place only if
          `trigexpandtimes' is `true'.

     Examples:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Option variable: trigexpandplus
     Default value: `true'

     `trigexpandplus' controls the "sum" rule for `trigexpand'.  Thus,
     when the `trigexpand' command is used or the `trigexpand' switch
     set to `true', expansion of sums (e.g. `sin(x+y))' will take place
     only if `trigexpandplus' is `true'.


 -- Option variable: trigexpandtimes
     Default value: `true'

     `trigexpandtimes' controls the "product" rule for `trigexpand'.
     Thus, when the `trigexpand' command is used or the `trigexpand'
     switch set to `true', expansion of products (e.g. `sin(2*x)') will
     take place only if `trigexpandtimes' is `true'.


 -- Option variable: triginverses
     Default value: `all'

     `triginverses' controls the simplification of the composition of
     trigonometric and hyperbolic functions with their inverse
     functions.

     If `all', both e.g. `atan(tan(<x>))' and `tan(atan(<x>))' simplify
     to <x>.

     If `true', the `<arcfun>(<fun>(<x>))' simplification is turned off.

     If `false', both the `<arcfun>(<fun>(<x>))' and
     `<fun>(<arcfun>(<x>))' simplifications are turned off.


 -- Function: trigreduce (<expr>, <x>)
 -- Function: trigreduce (<expr>)
     Combines products and powers of trigonometric and hyperbolic sin's
     and cos's of <x> into those of multiples of <x>.  It also tries to
     eliminate these functions when they occur in denominators.  If <x>
     is omitted then all variables in <expr> are used.

     See also `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     The trigonometric simplification routines will use declared
     information in some simple cases.  Declarations about variables are
     used as follows, e.g.

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Option variable: trigsign
     Default value: `true'

     When `trigsign' is `true', it permits simplification of negative
     arguments to trigonometric functions. E.g., `sin(-x)' will become
     `-sin(x)' only if `trigsign' is `true'.


 -- Function: trigsimp (<expr>)
     Employs the identities sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 to simplify expressions containing `tan', `sec',
     etc., to `sin', `cos', `sinh', `cosh'.

     `trigreduce', `ratsimp', and `radcan' may be able to further
     simplify the result.

     `demo ("trgsmp.dem")' displays some examples of `trigsimp'.


 -- Function: trigrat (<expr>)
     Gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; <expr> is a rational fraction of several `sin', `cos'
     or `tan', the arguments of them are linear forms in some variables
     (or kernels) and `%pi/<n>' (<n> integer) with integer
     coefficients. The result is a simplified fraction with numerator
     and denominator linear in `sin' and `cos'.  Thus `trigrat'
     linearize always when it is possible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     The following example is taken from Davenport, Siret, and
     Tournier, Calcul Formel, Masson (or in English, Addison-Wesley),
     section 1.5.5, Morley theorem.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4



File: maxima.info,  Node: Special Functions,  Next: Elliptic Functions,  Prev: Trigonometric,  Up: Top

16 Special Functions
********************

* Menu:

* Introduction to Special Functions::
* specint::
* Definitions for Special Functions::


File: maxima.info,  Node: Introduction to Special Functions,  Next: specint,  Prev: Special Functions,  Up: Special Functions

16.1 Introduction to Special Functions
======================================


File: maxima.info,  Node: specint,  Next: Definitions for Special Functions,  Prev: Introduction to Special Functions,  Up: Special Functions

16.2 specint
============

`hypgeo' is a package for handling Laplace transforms of special
functions.  `hyp' is a package for handling generalized Hypergeometric
functions.

   `specint' attempts to compute the definite integral (over the range
from zero to infinity) of an expression containing special functions.
When the integrand contains a factor `exp (-s t)', the result is a
Laplace transform.

   The syntax is as follows:

     specint (exp (-s*<t>) * <expr>, <t>);

   where <t> is the variable of integration and <expr> is an expression
containing special functions.

   If `specint' cannot compute the integral, the return value may
contain various Lisp symbols, including
`other-defint-to-follow-negtest', `other-lt-exponential-to-follow',
`product-of-y-with-nofract-indices', etc.; this is a bug.

   Special function notation follows:

     bessel_j (index, expr)         Bessel function, 1st kind
     bessel_y (index, expr)         Bessel function, 2nd kind
     bessel_i (index, expr)         Modified Bessel function, 1st kind
     bessel_k (index, expr)         Modified Bessel function, 2nd kind
     %he[n] (z)                     Hermite polynomial (Nota bene: `he', not `h'. See A&S 22.5.18)
     %p[u,v] (z)                    Legendre function
     %q[u,v] (z)                    Legendre function, 2nd kind
     hstruve[n] (z)                 Struve H function
     lstruve[n] (z)                 Struve L function
     %f[p,q] ([], [], expr)         Generalized Hypergeometric function
     gamma()                        Gamma function
     gammagreek(a,z)                Incomplete gamma function
     gammaincomplete(a,z)           Tail of incomplete gamma function
     slommel
     %m[u,k] (z)                    Whittaker function, 1st kind
     %w[u,k] (z)                    Whittaker function, 2nd kind
     erfc (z)                       Complement of the erf function
     ei (z)                         Exponential integral (?)
     kelliptic (z)                  Complete elliptic integral of the first kind (K)
     %d [n] (z)                     Parabolic cylinder function

   `demo ("hypgeo")' displays several examples of Laplace transforms
computed by `specint'.

   This is a work in progress.  Some of the function names may change.


File: maxima.info,  Node: Definitions for Special Functions,  Prev: specint,  Up: Special Functions

16.3 Definitions for Special Functions
======================================

 -- Function: airy (<x>)
     The Airy function Ai.  If the argument <x> is a number, the
     numerical value of `airy (<x>)' is returned.  Otherwise, an
     unevaluated expression `airy (<x>)' is returned.

     The Airy equation `diff (y(x), x, 2) - x y(x) = 0' has two
     linearly independent solutions, named `ai' and `bi'. This equation
     is very popular as an approximation to more complicated problems
     in many mathematical physics settings.

     `load ("airy")' loads the functions `ai', `bi', `dai', and `dbi'.

     The `airy' package contains routines to compute `ai' and `bi' and
     their derivatives `dai' and `dbi'. The result is a floating point
     number if the argument is a number, and an unevaluated expression
     otherwise.

     An error occurs if the argument is large enough to cause an
     overflow in the exponentials, or a loss of accuracy in `sin' or
     `cos'. This makes the range of validity about -2800 to 10^38 for
     `ai' and `dai', and -2800 to 25 for `bi' and `dbi'.

     These derivative rules are known to Maxima:
        * `diff (ai(x), x)' yields `dai(x)',

        * `diff (dai(x), x)' yields `x ai(x)',

        * `diff (bi(x), x)' yields `dbi(x)',

        * `diff (dbi(x), x)' yields `x bi(x)'.

     Function values are computed from the convergent Taylor series for
     `abs(<x>) < 3', and from the asymptotic expansions for `<x> < -3'
     or `<x> > 3' as needed.  This results in only very minor numerical
     discrepancies at `<x> = 3' and `<x> = -3'.  For details, see
     Abramowitz and Stegun, Handbook of Mathematical Functions, Section
     10.4 and Table 10.11.

     `ev (taylor (ai(x), x, 0, 9), infeval)' yields a floating point
     Taylor expansions of the function `ai'.  A similar expression can
     be constructed for `bi'.


 -- Function: airy_ai (<x>)
     The Airy function Ai, as defined in Abramowitz and Stegun,
     Handbook of Mathematical Functions, Section 10.4.

     The Airy equation `diff (y(x), x, 2) - x y(x) = 0' has two
     linearly independent solutions, `y = Ai(x)' and `y = Bi(x)'.  The
     derivative `diff (airy_ai(x), x)' is `airy_dai(x)'.

     If the argument `x' is a real or complex floating point number,
     the numerical value of `airy_ai' is returned when possible.

     See also `airy_bi', `airy_dai', `airy_dbi'.

 -- Function: airy_dai (<x>)
     The derivative of the Airy function Ai `airy_ai(x)'.

     See `airy_ai'.

 -- Function: airy_bi (<x>)
     The Airy function Bi, as defined in Abramowitz and Stegun,
     Handbook of Mathematical Functions, Section 10.4, is the second
     solution of the Airy equation `diff (y(x), x, 2) - x y(x) = 0'.

     If the argument `x' is a real or complex floating point number,
     the numerical value of `airy_bi' is returned when possible.  In
     other cases the unevaluated expression is returned.

     The derivative `diff (airy_bi(x), x)' is `airy_dbi(x)'.

     See `airy_ai', `airy_dbi'.

 -- Function: airy_dbi (<x>)
     The derivative of the Airy Bi function `airy_bi(x)'.

     See `airy_ai' and `airy_bi'.

 -- Function: asympa
     `asympa' is a package for asymptotic analysis. The package contains
     simplification functions for asymptotic analysis, including the
     "big O" and "little o" functions that are widely used in
     complexity analysis and numerical analysis.

     `load ("asympa")' loads this package.


 -- Function: bessel (<z>, <a>)
     The Bessel function of the first kind.

     This function is deprecated.  Write `bessel_j (<z>, <a>)' instead.


 -- Function: bessel_j (<v>, <z>)
     The Bessel function of the first kind of order v and argument z.

     `bessel_j' computes the array `besselarray' such that `besselarray
     [i] = bessel_j [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_j' is defined as
                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     although the infinite series is not used for computations.


 -- Function: bessel_y (<v>, <z>)
     The Bessel function of the second kind of order v and argument z.

     `bessel_y' computes the array `besselarray' such that `besselarray
     [i] = bessel_y [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_y' is defined as
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     when v is not an integer.  When v is an integer n, the limit as v
     approaches n is taken.


 -- Function: bessel_i (<v>, <z>)
     The modified Bessel function of the first kind of order v and
     argument z.

     `bessel_i' computes the array `besselarray' such that `besselarray
     [i] = bessel_i [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_i' is defined as
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     although the infinite series is not used for computations.


 -- Function: bessel_k (<v>, <z>)
     The modified Bessel function of the second kind of order v and
     argument z.

     `bessel_k' computes the array `besselarray' such that `besselarray
     [i] = bessel_k [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_k' is defined as
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     when v is not an integer.  If v is an integer n, then the limit as
     v approaches n is taken.


 -- Option variable: besselexpand
     Default value: `false'

     Controls expansion of the Bessel functions when the order is half
     of an odd integer.  In this case, the Bessel functions can be
     expanded in terms of other elementary functions.  When
     `besselexpand' is `true', the Bessel function is expanded.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Function: j0 (<x>)
     The Bessel function of the first kind of order 0.

     This function is deprecated.  Write `bessel_j (0, <x>)' instead.


 -- Function: j1 (<x>)
     The Bessel function of the first kind of order 1.

     This function is deprecated.  Write `bessel_j (1, <x>)' instead.


 -- Function: jn (<x>, <n>)
     The Bessel function of the first kind of order <n>.

     This function is deprecated.  Write `bessel_j (<n>, <x>)' instead.


 -- Function: i0 (<x>)
     The modified Bessel function of the first kind of order 0.

     This function is deprecated.  Write `bessel_i (0, <x>)' instead.


 -- Function: i1 (<x>)
     The modified Bessel function of the first kind of order 1.

     This function is deprecated.  Write `bessel_i (1, `x')' instead.


 -- Function: beta (<x>, <y>)
     The beta function, defined as `gamma(x) gamma(y)/gamma(x + y)'.


 -- Function: gamma (<x>)
     The gamma function.

     See also `makegamma'.

     The variable `gammalim' controls simplification of the gamma
     function.

     The Euler-Mascheroni constant is `%gamma'.


 -- Option variable: gammalim
     Default value: 1000000

     `gammalim' controls simplification of the gamma function for
     integral and rational number arguments.  If the absolute value of
     the argument is not greater than `gammalim', then simplification
     will occur.  Note that the `factlim' switch controls
     simplification of the result of `gamma' of an integer argument as
     well.


 -- Function: intopois (<a>)
     Converts <a> into a Poisson encoding.


 -- Function: makefact (<expr>)
     Transforms instances of binomial, gamma, and beta functions in
     <expr> into factorials.

     See also `makegamma'.


 -- Function: makegamma (<expr>)
     Transforms instances of binomial, factorial, and beta functions in
     <expr> into gamma functions.

     See also `makefact'.


 -- Function: numfactor (<expr>)
     Returns the numerical factor multiplying the expression <expr>,
     which should be a single term.

     `content' returns the greatest common divisor (gcd) of all terms
     in a sum.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8


 -- Function: outofpois (<a>)
     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, `outofpois' carries out the conversion,
     i.e., the return value is `outofpois (intopois (<a>))'.  This
     function is thus a canonical simplifier for sums of powers of sine
     and cosine terms of a particular type.


 -- Function: poisdiff (<a>, <b>)
     Differentiates <a> with respect to <b>. <b> must occur only in the
     trig arguments or only in the coefficients.


 -- Function: poisexpt (<a>, <b>)
     Functionally identical to `intopois (<a>^<b>)'.  <b> must be a
     positive integer.


 -- Function: poisint (<a>, <b>)
     Integrates in a similarly restricted sense (to `poisdiff').
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.


 -- Option variable: poislim
     Default value: 5

     `poislim' determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].


 -- Function: poismap (<series>, <sinfn>, <cosfn>)
     will map the functions <sinfn> on the sine terms and <cosfn> on
     the cosine terms of the Poisson series given.  <sinfn> and <cosfn>
     are functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.


 -- Function: poisplus (<a>, <b>)
     Is functionally identical to `intopois (a + b)'.


 -- Function: poissimp (<a>)
     Converts <a> into a Poisson series for <a> in general
     representation.


 -- Special symbol: poisson
     The symbol `/P/' follows the line label of Poisson series
     expressions.


 -- Function: poissubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., `6*u +
     4*v').

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands `cos(<d>)' and
     `sin(<d>)' to order <n> so as to provide the result of
     substituting `<a> + <d>' for <b> in <c>.  The idea is that <d> is
     an expansion in terms of a small parameter.  For example,
     `poissubst (u, v, cos(v), %e, 3)' yields `cos(u)*(1 - %e^2/2) -
     sin(u)*(%e - %e^3/6)'.


 -- Function: poistimes (<a>, <b>)
     Is functionally identical to `intopois (<a>*<b>)'.


 -- Function: poistrim ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the <u>,
     <v>, ..., <z> in a term.  Terms for which `poistrim' is `true'
     (for the coefficients of that term) are eliminated during
     multiplication.


 -- Function: printpois (<a>)
     Prints a Poisson series in a readable format.  In common with
     `outofpois', it will convert <a> into a Poisson encoding first, if
     necessary.


 -- Function: psi (<x>)
 -- Function: psi [<n>](<x>)
     The derivative of `log (gamma (x))'.

     Maxima does not know how to compute a numerical value of `psi'.
     However, the function `bfpsi' in the `bffac' package can compute
     numerical values.



File: maxima.info,  Node: Elliptic Functions,  Next: Limits,  Prev: Special Functions,  Up: Top

17 Elliptic Functions
*********************

* Menu:

* Introduction to Elliptic Functions and Integrals::
* Definitions for Elliptic Functions::
* Definitions for Elliptic Integrals::


File: maxima.info,  Node: Introduction to Elliptic Functions and Integrals,  Next: Definitions for Elliptic Functions,  Up: Top

17.1 Introduction to Elliptic Functions and Integrals
=====================================================

Maxima includes support for Jacobian elliptic functions and for
complete and incomplete elliptic integrals.  This includes symbolic
manipulation of these functions and numerical evaluation as well.
Definitions of these functions and many of their properties can by
found in Abramowitz and Stegun, Chapter 16-17.  As much as possible, we
use the definitions and relationships given there.

   In particular, all elliptic functions and integrals use the parameter
m instead of the modulus k or the modular angle \alpha.  This is one
area where we differ from Abramowitz and Stegun who use the modular
angle for the elliptic functions.  The following relationships are true:
m = k^2 and k = \sin(\alpha)

   The elliptic functions and integrals are primarily intended to
support symbolic computation.  Therefore, most of derivatives of the
functions and integrals are known.  However, if floating-point values
are given, a floating-point result is returned.

   Support for most of the other properties of elliptic functions and
integrals other than derivatives has not yet been written.

   Some examples of elliptic functions:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Some examples of elliptic integrals:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Support for elliptic functions and integrals was written by Raymond
Toy.  It is placed under the terms of the General Public License (GPL)
that governs the distribution of Maxima.


File: maxima.info,  Node: Definitions for Elliptic Functions,  Next: Definitions for Elliptic Integrals,  Prev: Introduction to Elliptic Functions and Integrals,  Up: Top

17.2 Definitions for Elliptic Functions
=======================================

 -- Function: jacobi_sn (<u>, <m>)
     The Jacobian elliptic function sn(u,m).

 -- Function: jacobi_cn (<u>, <m>)
     The Jacobian elliptic function cn(u,m).

 -- Function: jacobi_dn (<u>, <m>)
     The Jacobian elliptic function dn(u,m).

 -- Function: jacobi_ns (<u>, <m>)
     The Jacobian elliptic function ns(u,m) = 1/sn(u,m).

 -- Function: jacobi_sc (<u>, <m>)
     The Jacobian elliptic function sc(u,m) = sn(u,m)/cn(u,m).

 -- Function: jacobi_sd (<u>, <m>)
     The Jacobian elliptic function sd(u,m) = sn(u,m)/dn(u,m).

 -- Function: jacobi_nc (<u>, <m>)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 -- Function: jacobi_cs (<u>, <m>)
     The Jacobian elliptic function cs(u,m) = cn(u,m)/sn(u,m).

 -- Function: jacobi_cd (<u>, <m>)
     The Jacobian elliptic function cd(u,m) = cn(u,m)/dn(u,m).

 -- Function: jacobi_nd (<u>, <m>)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 -- Function: jacobi_ds (<u>, <m>)
     The Jacobian elliptic function ds(u,m) = dn(u,m)/sn(u,m).

 -- Function: jacobi_dc (<u>, <m>)
     The Jacobian elliptic function dc(u,m) = dn(u,m)/cn(u,m).

 -- Function: inverse_jacobi_sn (<u>, <m>)
     The inverse of the Jacobian elliptic function sn(u,m).

 -- Function: inverse_jacobi_cn (<u>, <m>)
     The inverse of the Jacobian elliptic function cn(u,m).

 -- Function: inverse_jacobi_dn (<u>, <m>)
     The inverse of the Jacobian elliptic function dn(u,m).

 -- Function: inverse_jacobi_ns (<u>, <m>)
     The inverse of the Jacobian elliptic function ns(u,m).

 -- Function: inverse_jacobi_sc (<u>, <m>)
     The inverse of the Jacobian elliptic function sc(u,m).

 -- Function: inverse_jacobi_sd (<u>, <m>)
     The inverse of the Jacobian elliptic function sd(u,m).

 -- Function: inverse_jacobi_nc (<u>, <m>)
     The inverse of the Jacobian elliptic function nc(u,m).

 -- Function: inverse_jacobi_cs (<u>, <m>)
     The inverse of the Jacobian elliptic function cs(u,m).

 -- Function: inverse_jacobi_cd (<u>, <m>)
     The inverse of the Jacobian elliptic function cd(u,m).

 -- Function: inverse_jacobi_nd (<u>, <m>)
     The inverse of the Jacobian elliptic function nc(u,m).

 -- Function: inverse_jacobi_ds (<u>, <m>)
     The inverse of the Jacobian elliptic function ds(u,m).

 -- Function: inverse_jacobi_dc (<u>, <m>)
     The inverse of the Jacobian elliptic function dc(u,m).


File: maxima.info,  Node: Definitions for Elliptic Integrals,  Prev: Definitions for Elliptic Functions,  Up: Top

17.3 Definitions for Elliptic Integrals
=======================================

 -- Function: elliptic_f (<phi>, <m>)
     The incomplete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *Note elliptic_e:: and *Note elliptic_kc::.


 -- Function: elliptic_e (<phi>, <m>)
     The incomplete elliptic integral of the second kind, defined as

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *Note elliptic_e:: and *Note elliptic_ec::.


 -- Function: elliptic_eu (<u>, <m>)
     The incomplete elliptic integral of the second kind, defined as

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     where tau = sn(u,m)

     This is related to elliptic_e by elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) See also *Note elliptic_e::.

 -- Function: elliptic_pi (<n>, <phi>, <m>)
     The incomplete elliptic integral of the third kind, defined as

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Only the derivative with respect to phi is known by Maxima.

 -- Function: elliptic_kc (<m>)
     The complete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use `makegamma' to evaluate them.

 -- Function: elliptic_ec (<m>)
     The complete elliptic integral of the second kind, defined as

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use `makegamma' to evaluate them.


File: maxima.info,  Node: Limits,  Next: Differentiation,  Prev: Elliptic Functions,  Up: Top

18 Limits
*********

* Menu:

* Definitions for Limits::


File: maxima.info,  Node: Definitions for Limits,  Prev: Limits,  Up: Limits

18.1 Definitions for Limits
===========================

 -- Option variable: lhospitallim
     Default: 4

     `lhospitallim' is the maximum number of times L'Hospital's rule is
     used in `limit'.  This prevents infinite looping in cases like
     `limit (cot(x)/csc(x), x, 0)'.


 -- Function: limit (<expr>, <x>, <val>, <dir>)
 -- Function: limit (<expr>, <x>, <val>)
 -- Function: limit (<expr>)
     Computes the limit of <expr> as the real variable <x> approaches
     the value <val> from the direction <dir>.  <dir> may have the
     value `plus' for a limit from above, `minus' for a limit from
     below, or may be omitted (implying a two-sided limit is to be
     computed).

     `limit' uses the following special symbols: `inf' (positive
     infinity) and `minf' (negative infinity).  On output it may also
     use `und' (undefined), `ind' (indefinite but bounded) and
     `infinity' (complex infinity).

     `lhospitallim' is the maximum number of times L'Hospital's rule is
     used in `limit'.  This prevents infinite looping in cases like
     `limit (cot(x)/csc(x), x, 0)'.

     `tlimswitch' when true will cause the limit package to use Taylor
     series when possible.

     `limsubst' prevents `limit' from attempting substitutions on
     unknown forms.  This is to avoid bugs like `limit (f(n)/f(n+1), n,
     inf)' giving 1.  Setting `limsubst' to `true' will allow such
     substitutions.

     `limit' with one argument is often called upon to simplify
     constant expressions, for example, `limit (inf-1)'.

     `example (limit)' displays some examples.

     For the method see Wang, P., "Evaluation of Definite Integrals by
     Symbolic Manipulation", Ph.D. thesis, MAC TR-92, October 1971.


 -- Option variable: limsubst
     default value: `false' - prevents `limit' from attempting
     substitutions on unknown forms.  This is to avoid bugs like `limit
     (f(n)/f(n+1), n, inf)' giving 1.  Setting `limsubst' to `true'
     will allow such substitutions.


 -- Function: tlimit (<expr>, <x>, <val>, <dir>)
 -- Function: tlimit (<expr>, <x>, <val>)
 -- Function: tlimit (<expr>)
     Returns `limit' with `tlimswitch' set to `true'.


 -- Option variable: tlimswitch
     Default value: `false'

     When `tlimswitch' is `true', it causes the limit package to use
     Taylor series when possible.



File: maxima.info,  Node: Differentiation,  Next: Integration,  Prev: Limits,  Up: Top

19 Differentiation
******************

* Menu:

* Definitions for Differentiation::


File: maxima.info,  Node: Definitions for Differentiation,  Prev: Differentiation,  Up: Differentiation

19.1 Definitions for Differentiation
====================================

 -- Function: antid (<expr>, <x>, <u(x)>)
     Returns a two-element list, such that an antiderivative of <expr>
     with respect to <x> can be constructed from the list.  The
     expression <expr> may contain an unknown function <u> and its
     derivatives.

     Let <L>, a list of two elements, be the return value of `antid'.
     Then `<L>[1] + 'integrate (<L>[2], <x>)' is an antiderivative of
     <expr> with respect to <x>.

     When `antid' succeeds entirely, the second element of the return
     value is zero.  Otherwise, the second element is nonzero, and the
     first element is nonzero or zero.  If `antid' cannot make any
     progress, the first element is zero and the second nonzero.

     `load ("antid")' loads this function.  The `antid' package also
     defines the functions `nonzeroandfreeof' and `linear'.

     `antid' is related to `antidiff' as follows.  Let <L>, a list of
     two elements, be the return value of `antid'.  Then the return
     value of `antidiff' is equal to `<L>[1] + 'integrate (<L>[2], <x>)'
     where <x> is the variable of integration.

     Examples:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Function: antidiff (<expr>, <x>, <u>(<x>))
     Returns an antiderivative of <expr> with respect to <x>.  The
     expression <expr> may contain an unknown function <u> and its
     derivatives.

     When `antidiff' succeeds entirely, the resulting expression is
     free of integral signs (that is, free of the `integrate' noun).
     Otherwise, `antidiff' returns an expression which is partly or
     entirely within an integral sign.  If `antidiff' cannot make any
     progress, the return value is entirely within an integral sign.

     `load ("antid")' loads this function.  The `antid' package also
     defines the functions `nonzeroandfreeof' and `linear'.

     `antidiff' is related to `antid' as follows.  Let <L>, a list of
     two elements, be the return value of `antid'.  Then the return
     value of `antidiff' is equal to `<L>[1] + 'integrate (<L>[2], <x>)'
     where <x> is the variable of integration.

     Examples:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Property: atomgrad
     `atomgrad' is the atomic gradient property of an expression.  This
     property is assigned by `gradef'.


 -- Function: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Function: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Assigns the value <c> to <expr> at the point `<x> = <a>'.
     Typically boundary values are established by this mechanism.

     <expr> is a function evaluation, `<f>(<x_1>, ..., <x_m>)', or a
     derivative, `diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ...,
     <x_n>, <n_m>)' in which the function arguments explicitly appear.
     <n_i> is the order of differentiation with respect to <x_i>.

     The point at which the atvalue is established is given by the list
     of equations `[<x_1> = <a_1>, ..., <x_m> = <a_m>]'.  If there is a
     single variable <x_1>, the sole equation may be given without
     enclosing it in a list.

     `printprops ([<f_1>, <f_2>, ...], atvalue)' displays the atvalues
     of the functions `<f_1>, <f_2>, ...' as specified by calls to
     `atvalue'.  `printprops (<f>, atvalue)' displays the atvalues of
     one function <f>.  `printprops (all, atvalue)' displays the
     atvalues of all functions for which atvalues are defined.

     The symbols `@1', `@2', ... represent the variables <x_1>, <x_2>,
     ... when atvalues are displayed.

     `atvalue' evaluates its arguments.  `atvalue' returns <c>, the
     atvalue.

     Examples:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Function: cartan -
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     `cartan' package implements the functions `ext_diff' and
     `lie_diff', along with the operators `~' (wedge product) and `|'
     (contraction of a form with a vector.)  Type `demo (tensor)' to
     see a brief description of these commands along with examples.

     `cartan' was implemented by F.B. Estabrook and H.D. Wahlquist.


 -- Function: del (<x>)
     `del (<x>)' represents the differential of the variable x.

     `diff' returns an expression containing `del' if an independent
     variable is not specified.  In this case, the return value is the
     so-called "total differential".

     Examples:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Function: delta (<t>)
     The Dirac Delta function.

     Currently only `laplace' knows about the `delta' function.

     Example:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- System variable: dependencies
     Default value: `[]'

     `dependencies' is the list of atoms which have functional
     dependencies, assigned by `depends' or `gradef'.  The
     `dependencies' list is cumulative: each call to `depends' or
     `gradef' appends additional items.

     See `depends' and `gradef'.


 -- Function: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declares functional dependencies among variables for the purpose
     of computing derivatives.  In the absence of declared dependence,
     `diff (f, x)' yields zero.  If `depends (f, x)' is declared, `diff
     (f, x)' yields a symbolic derivative (that is, a `diff' noun).

     Each argument <f_1>, <x_1>, etc., can be the name of a variable or
     array, or a list of names.  Every element of <f_i> (perhaps just a
     single element) is declared to depend on every element of <x_i>
     (perhaps just a single element).  If some <f_i> is the name of an
     array or contains the name of an array, all elements of the array
     depend on <x_i>.

     `diff' recognizes indirect dependencies established by `depends'
     and applies the chain rule in these cases.

     `remove (<f>, dependency)' removes all dependencies declared for
     <f>.

     `depends' returns a list of the dependencies established.  The
     dependencies are appended to the global variable `dependencies'.
     `depends' evaluates its arguments.

     `diff' is the only Maxima command which recognizes dependencies
     established by `depends'.  Other functions (`integrate',
     `laplace', etc.)  only recognize dependencies explicitly
     represented by their arguments.  For example, `integrate' does not
     recognize the dependence of `f' on `x' unless explicitly
     represented as `integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Option variable: derivabbrev
     Default value: `false'

     When `derivabbrev' is `true', symbolic derivatives (that is,
     `diff' nouns) are displayed as subscripts.  Otherwise, derivatives
     are displayed in the Leibniz notation `dy/dx'.


 -- Function: derivdegree (<expr>, <y>, <x>)
     Returns the highest degree of the derivative of the dependent
     variable <y> with respect to the independent variable <x> occuring
     in <expr>.

     Example:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Function: derivlist (<var_1>, ..., <var_k>)
     Causes only differentiations with respect to the indicated
     variables, within the `ev' command.


 -- Option variable: derivsubst
     Default value: `false'

     When `derivsubst' is `true', a non-syntactic substitution such as
     `subst (x, 'diff (y, t), 'diff (y, t, 2))' yields `'diff (x, t)'.


 -- Function: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Function: diff (<expr>, <x>, <n>)
 -- Function: diff (<expr>, <x>)
 -- Function: diff (<expr>)
     Returns the derivative or differential of <expr> with respect to
     some or all variables in <expr>.

     `diff (<expr>, <x>, <n>)' returns the <n>'th derivative of <expr>
     with respect to <x>.

     `diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' returns the mixed
     partial derivative of <expr> with respect to <x_1>, ..., <x_m>.
     It is equivalent to `diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)'.

     `diff (<expr>, <x>)' returns the first derivative of <expr> with
     respect to the variable <x>.

     `diff (<expr>)' returns the total differential of <expr>, that is,
     the sum of the derivatives of <expr> with respect to each its
     variables times the differential `del' of each variable.  No
     further simplification of `del' is offered.

     The noun form of `diff' is required in some contexts, such as
     stating a differential equation.  In these cases, `diff' may be
     quoted (as `'diff') to yield the noun form instead of carrying out
     the differentiation.

     When `derivabbrev' is `true', derivatives are displayed as
     subscripts.  Otherwise, derivatives are displayed in the Leibniz
     notation, `dy/dx'.

     Examples:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

     (1) The derivatives of any indexed objects in <expr> will have the
     variables <x_i> appended as additional arguments.  Then all the
     derivative indices will be sorted.

     (2) The <x_i> may be integers from 1 up to the value of the
     variable `dimension' [default value: 4].  This will cause the
     differentiation to be carried out with respect to the <x_i>'th
     member of the list `coordinates' which should be set to a list of
     the names of the coordinates, e.g., `[x, y, z, t]'. If
     `coordinates' is bound to an atomic variable, then that variable
     subscripted by <x_i> will be used for the variable of
     differentiation.  This permits an array of coordinate names or
     subscripted names like `X[1]', `X[2]', ... to be used.  If
     `coordinates' has not been assigned a value, then the variables
     will be treated as in (1) above.


 -- Special symbol: diff
     When `diff' is present as an `evflag' in call to `ev', all
     differentiations indicated in `expr' are carried out.


 -- Function: dscalar (<f>)
     Applies the scalar d'Alembertian to the scalar function <f>.

     `load ("ctensor")' loads this function.


 -- Function: express (<expr>)
     Expands differential operator nouns into expressions in terms of
     partial derivatives.  `express' recognizes the operators `grad',
     `div', `curl', `laplacian'.  `express' also expands the cross
     product `~'.

     Symbolic derivatives (that is, `diff' nouns) in the return value
     of express may be evaluated by including `diff' in the `ev'
     function call or command line.  In this context, `diff' acts as an
     `evfun'.

     `load ("vect")' loads this function.

     Examples:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Function: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Function: gradef (<a>, <x>, <expr>)
     Defines the partial derivatives (i.e., the components of the
     gradient) of the function <f> or variable <a>.

     `gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' defines
     `d<f>/d<x_i>' as <g_i>, where <g_i> is an expression; <g_i> may be
     a function call, but not the name of a function.  The number of
     partial derivatives <m> may be less than the number of arguments
     <n>, in which case derivatives are defined with respect to <x_1>
     through <x_m> only.

     `gradef (<a>, <x>, <expr>)' defines the derivative of variable <a>
     with respect to <x> as <expr>.  This also establishes the
     dependence of <a> on <x> (via `depends (<a>, <x>)').

     The first argument `<f>(<x_1>, ..., <x_n>)' or <a> is quoted, but
     the remaining arguments <g_1>, ..., <g_m> are evaluated.  `gradef'
     returns the function or variable for which the partial derivatives
     are defined.

     `gradef' can redefine the derivatives of Maxima's built-in
     functions.  For example, `gradef (sin(x), sqrt (1 - sin(x)^2))'
     redefines the derivative of `sin'.

     `gradef' cannot define partial derivatives for a subscripted
     function.

     `printprops ([<f_1>, ..., <f_n>], gradef)' displays the partial
     derivatives of the functions <f_1>, ..., <f_n>, as defined by
     `gradef'.

     `printprops ([<a_n>, ..., <a_n>], atomgrad)' displays the partial
     derivatives of the variables <a_n>, ..., <a_n>, as defined by
     `gradef'.

     `gradefs' is the list of the functions for which partial
     derivatives have been defined by `gradef'.  `gradefs' does not
     include any variables for which partial derivatives have been
     defined by `gradef'.

     Gradients are needed when, for example, a function is not known
     explicitly but its first derivatives are and it is desired to
     obtain higher order derivatives.


 -- System variable: gradefs
     Default value: `[]'

     `gradefs' is the list of the functions for which partial
     derivatives have been defined by `gradef'.  `gradefs' does not
     include any variables for which partial derivatives have been
     defined by `gradef'.


 -- Function: laplace (<expr>, <t>, <s>)
     Attempts to compute the Laplace transform of <expr> with respect
     to the variable <t> and transform parameter <s>.  If `laplace'
     cannot find a solution, a noun `'laplace' is returned.

     `laplace' recognizes in <expr> the functions `delta', `exp',
     `log', `sin', `cos', `sinh', `cosh', and `erf', as well as
     `derivative', `integrate', `sum', and `ilt'.  If some other
     functions are present, `laplace' may not be able to compute the
     transform.

     <expr> may also be a linear, constant coefficient differential
     equation in which case `atvalue' of the dependent variable is used.
     The required atvalue may be supplied either before or after the
     transform is computed.  Since the initial conditions must be
     specified at zero, if one has boundary conditions imposed
     elsewhere he can impose these on the general solution and
     eliminate the constants by solving the general solution for them
     and substituting their values back.

     `laplace' recognizes convolution integrals of the form `integrate
     (f(x) * g(t - x), x, 0, t)'; other kinds of convolutions are not
     recognized.

     Functional relations must be explicitly represented in <expr>;
     implicit relations, established by `depends', are not recognized.
     That is, if <f> depends on <x> and <y>, `f (x, y)' must appear in
     <expr>.

     See also `ilt', the inverse Laplace transform.

     Examples:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0



File: maxima.info,  Node: Integration,  Next: Equations,  Prev: Differentiation,  Up: Top

20 Integration
**************

* Menu:

* Introduction to Integration::
* Definitions for Integration::


File: maxima.info,  Node: Introduction to Integration,  Next: Definitions for Integration,  Prev: Integration,  Up: Integration

20.1 Introduction to Integration
================================

Maxima has several routines for handling integration.  The `integrate'
function makes use of most of them.  There is also the `antid' package,
which handles an unspecified function (and its derivatives, of course).
For numerical uses, there is the `romberg' function; an adaptave
integrator which uses the Newton-Cotes 8 panel quadrature rule, called
`quanc8'; and a set of adaptive integrators from Quadpack, named
`quad_qag', `quad_qags', etc.  Hypergeometric functions are being
worked on, see `specint' for details.  Generally speaking, Maxima only
handles integrals which are integrable in terms of the "elementary
functions" (rational functions, trigonometrics, logs, exponentials,
radicals, etc.) and a few extensions (error function, dilogarithm).  It
does not handle integrals in terms of unknown functions such as `g(x)'
and `h(x)'.


File: maxima.info,  Node: Definitions for Integration,  Prev: Introduction to Integration,  Up: Integration

20.2 Definitions for Integration
================================

 -- Function: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Makes the change of variable given by `<f(x,y)> = 0' in all
     integrals occurring in <expr> with integration with respect to <x>.
     The new variable is <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     An expression containing a noun form, such as the instances of
     `'integrate' above, may be evaluated by `ev' with the `nouns' flag.
     For example, the expression returned by `changevar' above may be
     evaluated by `ev (%o3, nouns)'.

     `changevar' may also be used to changes in the indices of a sum or
     product.  However, it must be realized that when a change is made
     in a sum or product, this change must be a shift, i.e., `i = j+
     ...', not a higher degree function.  E.g.,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Function: dblint (<f>, <r>, <s>, <a>, <b>)
     A double-integral routine which was written in top-level Maxima
     and then translated and compiled to machine code.  Use `load
     (dblint)' to access this package.  It uses the Simpson's rule
     method in both the x and y directions to calculate

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     The function <f> must be a translated or compiled function of two
     variables, and <r> and <s> must each be a translated or compiled
     function of one variable, while <a> and <b> must be floating point
     numbers. The routine has two global variables which determine the
     number of divisions of the x and y intervals: `dblint_x' and
     `dblint_y', both of which are initially 10, and can be changed
     independently to other integer values (there are `2*dblint_x+1'
     points computed in the x direction, and `2*dblint_y+1' in the y
     direction).  The routine subdivides the X axis and then for each
     value of X it first computes `<r>(x)' and `<s>(x)'; then the Y
     axis between `<r>(x)' and `<s>(x)' is subdivided and the integral
     along the Y axis is performed using Simpson's rule; then the
     integral along the X axis is done using Simpson's rule with the
     function values being the Y-integrals. This procedure may be
     numerically unstable for a great variety of reasons, but is
     reasonably fast: avoid using it on highly oscillatory functions
     and functions with singularities (poles or branch points in the
     region).  The Y integrals depend on how far apart `<r>(x)' and
     `<s>(x)' are, so if the distance `<s>(x) - <r>(x)' varies rapidly
     with X, there may be substantial errors arising from truncation
     with different step-sizes in the various Y integrals. One can
     increase `dblint_x' and `dblint_y' in an effort to improve the
     coverage of the region, at the expense of computation time. The
     function values are not saved, so if the function is very
     time-consuming, you will have to wait for re-computation if you
     change anything (sorry).  It is required that the functions <f>,
     <r>, and <s> be either translated or compiled prior to calling
     `dblint'. This will result in orders of magnitude speed
     improvement over interpreted code in many cases!

     `demo (dblint)' executes a demonstration of `dblint' applied to an
     example problem.


 -- Function: defint (<expr>, <x>, <a>, <b>)
     Attempts to compute a definite integral.  `defint' is called by
     `integrate' when limits of integration are specified, i.e., when
     `integrate' is called as `integrate (<expr>, <x>, <a>, <b>)'.
     Thus from the user's point of view, it is sufficient to call
     `integrate'.

     `defint' returns a symbolic expression, either the computed
     integral or the noun form of the integral.  See `quad_qag' and
     related functions for numerical approximation of definite
     integrals.


 -- Function: erf (<x>)
     Represents the error function, whose derivative is:
     `2*exp(-x^2)/sqrt(%pi)'.


 -- Option variable: erfflag
     Default value: `true'

     When `erfflag' is `false', prevents `risch' from introducing the
     `erf' function in the answer if there were none in the integrand to
     begin with.


 -- Function: ilt (<expr>, <t>, <s>)
     Computes the inverse Laplace transform of <expr> with respect to
     <t> and parameter <s>.  <expr> must be a ratio of polynomials
     whose denominator has only linear and quadratic factors.  By using
     the functions `laplace' and `ilt' together with the `solve' or
     `linsolve' functions the user can solve a single differential or
     convolution integral equation or a set of them.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Function: integrate (<expr>, <x>)
 -- Function: integrate (<expr>, <x>, <a>, <b>)
     Attempts to symbolically compute the integral of <expr> with
     respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
     integral, while `integrate (<expr>, <x>, <a>, <b>)' is a definite
     integral, with limits of integration <a> and <b>.  The limits
     should not contain <x>, although `integrate' does not enforce this
     restriction.  <a> need not be less than <b>.  If <b> is equal to
     <a>, `integrate' returns zero.

     See `quad_qag' and related functions for numerical approximation
     of definite integrals.  See `residue' for computation of residues
     (complex integration).  See `antid' for an alternative means of
     computing indefinite integrals.

     The integral (an expression free of `integrate') is returned if
     `integrate' succeeds.  Otherwise the return value is the noun form
     of the integral (the quoted operator `'integrate') or an
     expression containing one or more noun forms.  The noun form of
     `integrate' is displayed with an integral sign.

     In some circumstances it is useful to construct a noun form by
     hand, by quoting `integrate' with a single quote, e.g.,
     `'integrate (<expr>, <x>)'.  For example, the integral may depend
     on some parameters which are not yet computed.  The noun may be
     applied to its arguments by `ev (<i>, nouns)' where <i> is the
     noun form of interest.

     `integrate' handles definite integrals separately from indefinite,
     and employs a range of heuristics to handle each case.  Special
     cases of definite integrals include limits of integration equal to
     zero or infinity (`inf' or `minf'), trigonometric functions with
     limits of integration equal to zero and `%pi' or `2 %pi', rational
     functions, integrals related to the definitions of the `beta' and
     `psi' functions, and some logarithmic and trigonometric integrals.
     Processing rational functions may include computation of residues.
     If an applicable special case is not found, an attempt will be
     made to compute the indefinite integral and evaluate it at the
     limits of integration.  This may include taking a limit as a limit
     of integration goes to infinity or negative infinity; see also
     `ldefint'.

     Special cases of indefinite integrals include trigonometric
     functions, exponential and logarithmic functions, and rational
     functions.  `integrate' may also make use of a short table of
     elementary integrals.

     `integrate' may carry out a change of variable if the integrand
     has the form `f(g(x)) * diff(g(x), x)'.  `integrate' attempts to
     find a subexpression `g(x)' such that the derivative of `g(x)'
     divides the integrand.  This search may make use of derivatives
     defined by the `gradef' function.  See also `changevar' and
     `antid'.

     If none of the preceding heuristics find the indefinite integral,
     the Risch algorithm is executed.  The flag `risch' may be set as
     an `evflag', in a call to `ev' or on the command line, e.g., `ev
     (integrate (<expr>, <x>), risch)' or `integrate (<expr>, <x>),
     risch'.  If `risch' is present, `integrate' calls the `risch'
     function without attempting heuristics first. See also `risch'.

     `integrate' works only with functional relations represented
     explicitly with the `f(x)' notation.  `integrate' does not respect
     implicit dependencies established by the `depends' function.

     `integrate' may need to know some property of a parameter in the
     integrand.  `integrate' will first consult the `assume' database,
     and, if the variable of interest is not there, `integrate' will
     ask the user.  Depending on the question, suitable responses are
     `yes;' or `no;', or `pos;', `zero;', or `neg;'.

     `integrate' is not, by default, declared to be linear. See
     `declare' and `linear'.

     `integrate' attempts integration by parts only in a few special
     cases.

     Examples:

        * Elementary indefinite and definite integrals.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Use of `assume' and interactive query.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Change of variable. There are two changes of variable in this
          example: one using a derivative established by `gradef', and
          one using the derivation `diff(r(x))' of an unspecified
          function `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * Return value contains the `'integrate' noun form.  In this
          example, Maxima can extract one factor of the denominator of
          a rational function, but cannot factor the remainder or
          otherwise find its integral.  `grind' shows the noun form
          `'integrate' in the result.  See also `integrate_use_rootsof'
          for more on integrals of rational functions.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Defining a function in terms of an integral.  The body of a
          function is not evaluated when the function is defined.  Thus
          the body of `f_1' in this example contains the noun form of
          `integrate'.  The double-single-quotes operator `''' causes
          the integral to be evaluated, and the result becomes the body
          of `f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- System variable: integration_constant_counter
     Default value: 0

     `integration_constant_counter' is a counter which is updated each
     time a constant of integration (named by Maxima, e.g.,
     `integrationconstant1') is introduced into an expression by
     indefinite integration of an equation.


 -- Option variable: integrate_use_rootsof
     Default value: `false'

     When `integrate_use_rootsof' is `true' and the denominator of a
     rational function cannot be factored, `integrate' returns the
     integral in a form which is a sum over the roots (not yet known)
     of the denominator.

     For example, with `integrate_use_rootsof' set to `false',
     `integrate' returns an unsolved integral of a rational function in
     noun form:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Now we set the flag to be true and the unsolved part of the
     integral will be expressed as a summation over the roots of the
     denominator of the rational function:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                       2 x + 1
                                                   2            5 atan(-------)
                                              log(x  + x + 1)          sqrt(3)
                                            - --------------- + ---------------
                                                    14             7 sqrt(3)

     Alternatively the user may compute the roots of the denominator
     separately, and then express the integrand in terms of these roots,
     e.g., `1/((x - a)*(x - b)*(x - c))' or `1/((x^2 - (a+b)*x +
     a*b)*(x - c))' if the denominator is a cubic polynomial.
     Sometimes this will help Maxima obtain a more useful result.


 -- Function: ldefint (<expr>, <x>, <a>, <b>)
     Attempts to compute the definite integral of <expr> by using
     `limit' to evaluate the indefinite integral of <expr> with respect
     to <x> at the upper limit <b> and at the lower limit <a>.  If it
     fails to compute the definite integral, `ldefint' returns an
     expression containing limits as noun forms.

     `ldefint' is not called from `integrate', so executing `ldefint
     (<expr>, <x>, <a>, <b>)' may yield a different result than
     `integrate (<expr>, <x>, <a>, <b>)'.  `ldefint' always uses the
     same method to evaluate the definite integral, while `integrate'
     may employ various heuristics and may recognize some special cases.


 -- Function: potential (<givengradient>)
     The calculation makes use of the global variable
     `potentialzeroloc[0]' which must be `nonlist' or of the form

          [indeterminatej=expressionj, indeterminatek=expressionk, ...]

     the former being equivalent to the nonlist expression for all
     right-hand sides in the latter.  The indicated right-hand sides
     are used as the lower limit of integration.  The success of the
     integrations may depend upon their values and order.
     `potentialzeroloc' is initially set to 0.


 -- Function: qq
     The package `qq' (which may be loaded with `load ("qq")') contains
     a function `quanc8' which can take either 3 or 4 arguments. The 3
     arg version computes the integral of the function specified as the
     first argument over the interval from lo to hi as in `quanc8
     ('function, lo, hi)'.  The function name should be quoted.  The 4
     arg version will compute the integral of the function or
     expression (first arg) with respect to the variable (second arg)
     over the interval from `lo' to `hi' as in `quanc8(<f(x) or
     expression in x>, x, lo, hi)'.  The method used is the
     Newton-Cotes 8th order polynomial quadrature, and the routine is
     adaptive. It will thus spend time dividing the interval only when
     necessary to achieve the error conditions specified by the global
     variables `quanc8_relerr' (default value=1.0e-4) and
     `quanc8_abserr' (default value=1.0e-8) which give the relative
     error test:

          |integral(function) - computed value| < quanc8_relerr*|integral(function)|

     and the absolute error test:

          |integral(function) - computed value| < quanc8_abserr

     `printfile ("qq.usg")' yields additional information.


 -- Function: quanc8 (<expr>, <a>, <b>)
     An adaptive integrator.  Demonstration and usage files are
     provided.  The method is to use Newton-Cotes 8-panel quadrature
     rule, hence the function name `quanc8', available in 3 or 4 arg
     versions.  Absolute and relative error checks are used.  To use it
     do `load ("qq")'.  See also `qq'.


 -- Function: residue (<expr>, <z>, <z_0>)
     Computes the residue in the complex plane of the expression <expr>
     when the variable <z> assumes the value <z_0>.  The residue is the
     coefficient of `(<z> - <z_0>)^(-1)' in the Laurent series for
     <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Function: risch (<expr>, <x>)
     Integrates <expr> with respect to <x> using the transcendental
     case of the Risch algorithm.  (The algebraic case of the Risch
     algorithm has not been implemented.)  This currently handles the
     cases of nested exponentials and logarithms which the main part of
     `integrate' can't do.  `integrate' will automatically apply `risch'
     if given these cases.

     `erfflag', if `false', prevents `risch' from introducing the `erf'
     function in the answer if there were none in the integrand to begin
     with.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Function: romberg (<expr>, <x>, <a>, <b>)
 -- Function: romberg (<expr>, <a>, <b>)
     Romberg integration.  There are two ways to use this function.
     The first is an inefficient way like the definite integral version
     of `integrate': `romberg (<integrand>, <variable of integration>,
     <lower limit>, <upper limit>)'.

     Examples:

          (%i1) showtime: true$
          (%i2) romberg (sin(y), y, 0, %pi);
          Evaluation took 0.00 seconds (0.01 elapsed) using 25.293 KB.
          (%o2)                   2.000000016288042
          (%i3) 1/((x-1)^2+1/100) + 1/((x-2)^2+1/1000) + 1/((x-3)^2+1/200)$
          (%i4) f(x) := ''%$
          (%i5) rombergtol: 1e-6$
          (%i6) rombergit: 15$
          (%i7) romberg (f(x), x, -5, 5);
          Evaluation took 11.97 seconds (12.21 elapsed) using 12.423 MB.
          (%o7)                   173.6730736617464

     The second is an efficient way that is used as follows:

          romberg (<function name>, <lower limit>, <upper limit>);

     Continuing the above example, we have:
          (%i8) f(x) := (mode_declare ([function(f), x], float), ''(%th(5)))$
          (%i9) translate(f);
          (%o9)                          [f]
          (%i10) romberg (f, -5, 5);
          Evaluation took 3.51 seconds (3.86 elapsed) using 6.641 MB.
          (%o10)                  173.6730736617464

     The first argument must be a translated or compiled function.  (If
     it is compiled it must be declared to return a `flonum'.)  If the
     first argument is not already translated, `romberg' will not
     attempt to translate it but will give an error.

     The accuracy of the integration is governed by the global variables
     `rombergtol' (default value 1.E-4) and `rombergit' (default value
     11).  `romberg' will return a result if the relative difference in
     successive approximations is less than `rombergtol'.  It will try
     halving the stepsize `rombergit' times before it gives up.  The
     number of iterations and function evaluations which `romberg' will
     do is governed by `rombergabs' and `rombergmin'.

     `romberg' may be called recursively and thus can do double and
     triple integrals.

     Example:
          (%i1) assume (x > 0)$
          (%i2) integrate (integrate (x*y/(x+y), y, 0, x/2), x, 1, 3)$
          (%i3) radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o3)             - --------------------------
                                          3
          (%i4) %,numer;
          (%o4)                   .8193023963959073
          (%i5) define_variable (x, 0.0, float, "Global variable in function F")$
          (%i6) f(y) := (mode_declare (y, float), x*y/(x+y))$
          (%i7) g(x) := romberg ('f, 0, x/2)$
          (%i8) romberg (g, 1, 3);
          (%o8)                   .8193022864324522

     The advantage with this way is that the function `f' can be used
     for other purposes, like plotting. The disadvantage is that you
     have to think up a name for both the function `f' and its free
     variable `x'.  Or, without the global:

          (%i1) g_1(x) := (mode_declare (x, float), romberg (x*y/(x+y), y, 0, x/2))$
          (%i2) romberg (g_1, 1, 3);
          (%o2)                   .8193022864324522

     The advantage here is shortness.

          (%i3) q (a, b) := romberg (romberg (x*y/(x+y), y, 0, x/2), x, a, b)$
          (%i4) q (1, 3);
          (%o4)                   .8193022864324522

     It is even shorter this way, and the variables do not need to be
     declared because they are in the context of `romberg'.  Use of
     `romberg' for multiple integrals can have great disadvantages,
     though.  The amount of extra calculation needed because of the
     geometric information thrown away by expressing multiple integrals
     this way can be incredible.  The user should be sure to understand
     and use the `rombergtol' and `rombergit' switches.


 -- Option variable: rombergabs
     Default value: 0.0

     Assuming that successive estimates produced by `romberg' are
     `y[0]', `y[1]', `y[2]', etc., then `romberg' will return after `n'
     iterations if (roughly speaking)

           (abs(y[n]-y[n-1]) <= rombergabs or
           abs(y[n]-y[n-1])/(if y[n]=0.0 then 1.0 else y[n]) <= rombergtol)

     is `true'.  (The condition on the number of iterations given by
     `rombergmin' must also be satisfied.)  Thus if `rombergabs' is 0.0
     (the default) you just get the relative error test.  The
     usefulness of the additional variable comes when you want to
     perform an integral, where the dominant contribution comes from a
     small region.  Then you can do the integral over the small
     dominant region first, using the relative accuracy check, followed
     by the integral over the rest of the region using the absolute
     accuracy check.

     Example:  Suppose you want to compute

          'integrate (exp(-x), x, 0, 50)

     (numerically) with a relative accuracy of  1 part in 10000000.
     Define the function.  `n' is a counter, so we can see how many
     function evaluations were needed.  First of all try doing the
     whole integral at once.

          (%i1) f(x) := (mode_declare (n, integer, x, float), n:n+1, exp(-x))$
          (%i2) translate(f)$
          Warning-> n is an undefined global variable.
          (%i3) block ([rombergtol: 1.e-6, romberabs: 0.0], n:0, romberg (f, 0, 50));
          (%o3)                   1.000000000488271
          (%i4) n;
          (%o4)                          257

     That approach required 257 function evaluations.   Now do the
     integral intelligently, by first doing      `'integrate (exp(-x),
     x, 0, 10)' and then setting `rombergabs' to 1.E-6 times (this
     partial integral).  This approach takes only 130 function
     evaluations.

          (%i5) block ([rombergtol: 1.e-6, rombergabs:0.0, sum:0.0],
            n: 0, sum: romberg (f, 0, 10), rombergabs: sum*rombergtol, rombergtol:0.0,
                sum + romberg (f, 10, 50));
          (%o5)                   1.000000001234793
          (%i6) n;
          (%o6)                          130

     So if `f(x)' were a function that took a long time to compute, the
     second method would be about 2 times quicker.


 -- Option variable: rombergit
     Default value: 11

     The accuracy of the `romberg' integration command is governed by
     the global variables `rombergtol' and `rombergit'.  `romberg' will
     return a result if the relative difference in successive
     approximations is less than `rombergtol'.  It will try halving the
     stepsize `rombergit' times before it gives up.


 -- Option variable: rombergmin
     Default value: 0

     `rombergmin' governs the minimum number of function evaluations
     that `romberg' will make.  `romberg' will evaluate its first arg.
     at least `2^(rombergmin+2)+1' times.  This is useful for
     integrating oscillatory functions, when the normal converge test
     might sometimes wrongly pass.


 -- Option variable: rombergtol
     Default value: 1e-4

     The accuracy of the `romberg' integration command is governed by
     the global variables `rombergtol' and `rombergit'.  `romberg' will
     return a result if the relative difference in successive
     approximations is less than `rombergtol'.  It will try halving the
     stepsize `rombergit' times before it gives up.


 -- Function: tldefint (<expr>, <x>, <a>, <b>)
     Equivalent to `ldefint' with `tlimswitch' set to `true'.


 -- Function: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, <epsrel>, <limit>)
     Numerically evaluate the integral

     integrate (f(x), x, a, b)

     using a simple adaptive integrator.

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.  <key> is the integrator to be used and should be an
     integer between 1 and 6, inclusive.  The value of <key> selects
     the order of the Gauss-Kronrod integration rule.

     The numerical integration is done adaptively by subdividing the
     integration region into sub-intervals until the desired accuracy is
     achieved.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qag' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          if no problems were encountered;

    `1'
          if too many sub-intervals were done;

    `2'
          if excessive roundoff error is detected;

    `3'
          if extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Function: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limit>)
     Numerically integrate the given function using adaptive quadrature
     with extrapolation.  The function to be integrated is <f(x)>, with
     dependent variable <x>, and the function is to be integrated
     between the limits <a> and <b>.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qags' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.

     Examples:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note that `quad_qags' is more accurate and efficient than
     `quad_qag' for this integrand.


 -- Function: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limit>)
     Numerically evaluate one of the following integrals

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, a, minf, inf)

     using the Quadpack QAGI routine.  The function to be integrated is
     <f(x)>, with dependent variable <x>, and the function is to be
     integrated over an infinite range.

     The parameter <inftype> determines the integration interval as
     follows:

    `inf'
          The interval is from <a> to positive infinity.

    `minf'
          The interval is from negative infinity to <a>.

    `both'
          The interval is the entire real line.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qagi' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Function: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limit>)
     Numerically compute the Cauchy principal value of

     integrate (f(x)/(x - c), x, a, b)

     using the Quadpack QAWC routine.  The function to be integrated is
     `<f(x)>/(<x> - <c>)', with dependent variable <x>, and the function
     is to be integrated over the interval <a> to <b>.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qawc' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                   3 alpha                       3 alpha
                   -------                       -------
                      2            alpha/2          2          alpha/2
                2 4        atan(4 4       )   2 4        atan(4       )   alpha
              - --------------------------- - -------------------------)/2
                          alpha                        alpha
                       2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Function: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
     Numerically compute the a Fourier-type integral using the Quadpack
     QAWF routine.  The integral is

     integrate (f(x)*w(x), x, a, inf)

     The weight function w is selected by <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     The optional arguments are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

    <maxp1>
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.

    <limlst>
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     <epsabs> and <limit> are the desired relative error and the
     maximum number of subintervals, respectively.  <epsrel> defaults
     to 1e-8 and <limit> is 200.

     `quad_qawf' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Function: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          <epsabs>, <limit>, <maxp1>, <limlst>)
     Numerically compute the integral using the Quadpack QAWO routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     The optional arguments are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

    <maxp1>
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.

    <limlst>
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     <epsabs> and <limit> are the desired relative error and the
     maximum number of subintervals, respectively.  <epsrel> defaults
     to 1e-8 and <limit> is 200.

     `quad_qawo' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Function: quad_qaws (<f(x)>, <x>, <a>, <b>, <alfa>, <beta>, <wfun>,
          <epsabs>, <limit>)
     Numerically compute the integral using the Quadpack QAWS routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <wfun>:

    `1'
          w(x) = (x - a)^alfa (b - x)^beta

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alfa (b - x)^beta log(b - x)

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a) log(b - x)

     The optional arguments are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

     <epsabs> and <limit> are the desired relative error and the
     maximum number of subintervals, respectively.  <epsrel> defaults
     to 1e-8 and <limit> is 200.

     `quad_qaws' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Equations,  Next: Differential Equations,  Prev: Integration,  Up: Top

21 Equations
************

* Menu:

* Definitions for Equations::


File: maxima.info,  Node: Definitions for Equations,  Prev: Equations,  Up: Equations

21.1 Definitions for Equations
==============================

 -- System variable: %rnum_list
     Default value: `[]'

     `%rnum_list' is the list of variables introduced in solutions by
     `algsys'.  `%r' variables are added to `%rnum_list' in the order
     they are created.  This is convenient for doing substitutions into
     the solution later on.  It's recommended to use this list rather
     than doing `concat ('%r, j)'.


 -- Option variable: algexact
     Default value: `false'

     `algexact' affects the behavior of `algsys' as follows:

     If `algexact' is `true', `algsys' always calls `solve' and then
     uses `realroots' on `solve''s failures.

     If `algexact' is `false', `solve' is called only if the eliminant
     was not univariate, or if it was a quadratic or biquadratic.

     Thus `algexact: true' doesn't guarantee only exact solutions, just
     that `algsys' will first try as hard as it can to give exact
     solutions, and only yield approximations when all else fails.


 -- Function: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Function: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Solves the simultaneous polynomials <expr_1>, ..., <expr_m> or
     polynomial equations <eqn_1>, ..., <eqn_m> for the variables
     <x_1>, ..., <x_n>.  An expression <expr> is equivalent to an
     equation `<expr> = 0'.  There may be more equations than variables
     or vice versa.

     `algsys' returns a list of solutions, with each solution given as
     a list of equations stating values of the variables <x_1>, ...,
     <x_n> which satisfy the system of equations.  If `algsys' cannot
     find a solution, an empty list `[]' is returned.

     The symbols `%r1', `%r2', ..., are introduced as needed to
     represent arbitrary parameters in the solution; these variables
     are also appended to the list `%rnum_list'.

     The method is as follows:

     (1) First the equations are factored and split into subsystems.

     (2) For each subsystem <S_i>, an equation <E> and a variable <x>
     are selected.  The variable is chosen to have lowest nonzero
     degree.  Then the resultant of <E> and <E_j> with respect to <x>
     is computed for each of the remaining equations <E_j> in the
     subsystem <S_i>.  This yields a new subsystem <S_i'> in one fewer
     variables, as <x> has been eliminated.  The process now returns to
     (1).

     (3) Eventually, a subsystem consisting of a single equation is
     obtained.  If the equation is multivariate and no approximations in
     the form of floating point numbers have been introduced, then
     `solve' is called to find an exact solution.

     In some cases, `solve' is not be able to find a solution, or if it
     does the solution may be a very large expression.

     If the equation is univariate and is either linear, quadratic, or
     biquadratic, then again `solve' is called if no approximations have
     been introduced.  If approximations have been introduced or the
     equation is not univariate and neither linear, quadratic, or
     biquadratic, then if the switch `realonly' is `true', the function
     `realroots' is called to find the real-valued solutions.  If
     `realonly' is `false', then `allroots' is called which looks for
     real and complex-valued solutions.

     If `algsys' produces a solution which has fewer significant digits
     than required, the user can change the value of `algepsilon' to a
     higher value.

     If `algexact' is set to `true', `solve' will always be called.

     (4) Finally, the solutions obtained in step (3) are substituted
     into previous levels and the solution process returns to (1).

     When `algsys' encounters a multivariate equation which contains
     floating point approximations (usually due to its failing to find
     exact solutions at an earlier stage), then it does not attempt to
     apply exact methods to such equations and instead prints the
     message: "`algsys' cannot solve - system too complicated."

     Interactions with `radcan' can produce large or complicated
     expressions.  In that case, it may be possible to isolate parts of
     the result with `pickapart' or `reveal'.

     Occasionally, `radcan' may introduce an imaginary unit `%i' into a
     solution which is actually real-valued.

     Examples:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Function: allroots (<expr>)
 -- Function: allroots (<eqn>)
     Computes numerical approximations of the real and complex roots of
     the polynomial <expr> or polynomial equation <eqn> of one variable.

     The flag `polyfactor' when `true' causes `allroots' to factor the
     polynomial over the real numbers if the polynomial is real, or
     over the complex numbers, if the polynomial is complex.

     `allroots' may give inaccurate results in case of multiple roots.
     If the polynomial is real, `allroots (%i*<p>)') may yield more
     accurate approximations than `allroots (<p>)', as `allroots'
     invokes a different algorithm in that case.

     `allroots' rejects non-polynomials.  It requires that the numerator
     after `rat''ing should be a polynomial, and it requires that the
     denominator be at most a complex number.  As a result of this
     `allroots' will always return an equivalent (but factored)
     expression, if `polyfactor' is `true'.

     For complex polynomials an algorithm by Jenkins and Traub is used
     (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  For real
     polynomials the algorithm used is due to Jenkins (Algorithm 493,
     ACM TOMS, vol. 1, (1975), p.178).

     Examples:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Option variable: backsubst
     Default value: `true'

     When `backsubst' is `false', prevents back substitution after the
     equations have been triangularized.  This may be helpful in very
     big problems where back substitution would cause the generation of
     extremely large expressions.


 -- Option variable: breakup
     Default value: `true'

     When `breakup' is `true', `solve' expresses solutions of cubic and
     quartic equations in terms of common subexpressions, which are
     assigned to intermediate expression labels (`%t1', `%t2', etc.).
     Otherwise, common subexpressions are not identified.

     `breakup: true' has an effect only when `programmode' is `false'.

     Examples:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Function: dimension (<eqn>)
 -- Function: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' is a package for dimensional analysis.  `load ("dimen")'
     loads this package.  `demo ("dimen")' displays a short
     demonstration.


 -- Option variable: dispflag
     Default value: `true'

     If set to `false' within a `block' will inhibit the display of
     output generated by the solve functions called from within  the
     `block'.  Termination of the `block' with a dollar sign, $, sets
     `dispflag' to `false'.


 -- Function: funcsolve (<eqn>, <g>(<t>))
     Returns `[<g>(<t>) = ...]'  or `[]', depending on whether or not
     there exists a rational function `<g>(<t>)' satisfying <eqn>,
     which must be a first order, linear polynomial in (for this case)
     `<g>(<t>)' and `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Warning: this is a very rudimentary implementation - many safety
     checks and obvious generalizations are missing.


 -- Option variable: globalsolve
     Default value: `false'

     When `globalsolve' is `true', solved-for variables are assigned
     the solution values found by `linsolve', and by `solve' when
     solving two or more linear equations.

     When `globalsolve' is `false', solutions found by `linsolve' and
     by `solve' when solving two or more linear equations are expressed
     as equations, and the solved-for variables are not assigned.

     When solving anything other than two or more linear equations,
     `solve' ignores `globalsolve'.  Other functions which solve
     equations (e.g., `algsys') always ignore `globalsolve'.

     Examples:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Function: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' is a package for solving integral equations.  `load
     ("inteqn")' loads this package.

     <ie> is the integral equation; <unk> is the unknown function;
     <tech> is the technique to be tried from those given above (<tech>
     = `first' means: try the first technique which finds a solution;
     <tech> = `all' means: try all applicable techniques); <n> is the
     maximum number of terms to take for `taylor', `neumann',
     `firstkindseries', or `fredseries' (it is also the maximum depth
     of recursion for the differentiation method); <guess> is the
     initial guess for `neumann' or `firstkindseries'.

     Default values for the 2nd thru 5th parameters are:

     <unk>: `<p>(<x>)', where <p> is the first function encountered in
     an integrand which is unknown to Maxima and <x> is the variable
     which occurs as an argument to the first occurrence of <p> found
     outside of an integral in the case of `secondkind' equations, or
     is the only other variable besides the variable of integration in
     `firstkind' equations.  If the attempt to search for <x> fails,
     the user will be asked to supply the independent variable.

     tech: `first'

     n: 1

     guess: `none' which will cause `neumann' and `firstkindseries' to
     use `<f>(<x>)' as an initial guess.


 -- Option variable: ieqnprint
     Default value: `true'

     `ieqnprint' governs the behavior of the result returned by the
     `ieqn' command. When `ieqnprint' is `false', the lists returned by
     the `ieqn' function are of the form

     [<solution>, <technique used>, <nterms>, <flag>]

     where <flag> is absent if the solution is exact.

     Otherwise, it is the word `approximate' or `incomplete'
     corresponding to an inexact or non-closed form solution,
     respectively. If a series method was used, <nterms> gives the
     number of terms taken (which could be less than the n given to
     `ieqn' if an error prevented generation of further terms).


 -- Function: lhs (<expr>)
     Returns the left-hand side (that is, the first argument) of the
     expression <expr>, when the operator of <expr> is one of the
     relational operators `< <= = # equal notequal >= >', one of the
     assignment operators `:= ::= : ::', or a user-defined binary infix
     operator, as declared by `infix'.

     When <expr> is an atom or its operator is something other than the
     ones listed above, `lhs' returns <expr>.

     See also `rhs'.

     Examples:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Function: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Solves the list of simultaneous linear equations for the list of
     variables.  The expressions must each be polynomials in the
     variables and may be equations.

     When `globalsolve' is `true', each solved-for variable is bound to
     its value in the solution of the equations.

     When `backsubst' is `false', `linsolve' does not carry out back
     substitution after the equations have been triangularized.  This
     may be necessary in very big problems where back substitution
     would cause the generation of extremely large expressions.

     When `linsolve_params' is `true', `linsolve' also generates the
     `%r' symbols used to represent arbitrary parameters described in
     the manual under `algsys'.  Otherwise, `linsolve' solves an
     under-determined system of equations with some variables expressed
     in terms of others.

     When `programmode' is `false', `linsolve' displays the solution
     with intermediate expression (`%t') labels, and returns the list
     of labels.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Option variable: linsolvewarn
     Default value: `true'

     When `linsolvewarn' is `true', `linsolve' prints a message
     "Dependent equations eliminated".


 -- Option variable: linsolve_params
     Default value: `true'

     When `linsolve_params' is `true', `linsolve' also generates the
     `%r' symbols used to represent arbitrary parameters described in
     the manual under `algsys'.  Otherwise, `linsolve' solves an
     under-determined system of equations with some variables expressed
     in terms of others.


 -- System variable: multiplicities
     Default value: `not_set_yet'

     `multiplicities' is set to a list of the multiplicities of the
     individual solutions returned by `solve' or `realroots'.


 -- Function: nroots (<p>, <low>, <high>)
     Returns the number of real roots of the real univariate polynomial
     <p> in the half-open interval `(<low>, <high>]'.  The endpoints of
     the interval may be `minf' or `inf'.  infinity and plus infinity.

     `nroots' uses the method of Sturm sequences.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Function: nthroot (<p>, <n>)
     where p is a polynomial with integer coefficients and n is a
     positive integer returns q, a polynomial over the integers, such
     that q^n=p or prints an error message indicating that p is not a
     perfect nth power. This routine is much faster than `factor' or
     even `sqfr'.


 -- Option variable: programmode
     Default value: `true'

     When `programmode' is `true', `solve', `realroots', `allroots',
     and `linsolve' return solutions as elements in a list.  (Except
     when `backsubst' is set to `false', in which case `programmode:
     false' is assumed.)

     When `programmode' is `false', `solve', etc.  create intermediate
     expression labels `%t1', `t2', etc., and assign the solutions to
     them.


 -- Option variable: realonly
     Default value: `false'

     When `realonly' is `true', `algsys' returns only those solutions
     which are free of `%i'.


 -- Function: realroots (<poly>, <bound>)
     Finds all of the real roots of the real univariate polynomial poly
     within a tolerance of bound which, if less than 1, causes all
     integral roots to be found exactly.  The parameter bound may be
     arbitrarily small in order to achieve any desired accuracy.  The
     first argument may also be an equation.  `realroots' sets
     `multiplicities', useful in case of multiple roots.  `realroots
     (<p>)' is equivalent to `realroots (<p>, rootsepsilon)'.
     `rootsepsilon' is a real number used to establish the confidence
     interval for the roots.  Do `example (realroots)' for an example.


 -- Function: rhs (<expr>)
     Returns the right-hand side (that is, the second argument) of the
     expression <expr>, when the operator of <expr> is one of the
     relational operators `< <= = # equal notequal >= >', one of the
     assignment operators `:= ::= : ::', or a user-defined binary infix
     operator, as declared by `infix'.

     When <expr> is an atom or its operator is something other than the
     ones listed above, `rhs' returns 0.

     See also `lhs'.

     Examples:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Option variable: rootsconmode
     Default value: `true'

     `rootsconmode' governs the behavior of the `rootscontract'
     command.  See `rootscontract' for details.


 -- Function: rootscontract (<expr>)
     Converts products of roots into roots of products.  For example,
     `rootscontract (sqrt(x)*y^(3/2))' yields `sqrt(x*y^3)'.

     When `radexpand' is `true' and `domain' is `real', `rootscontract'
     converts `abs' into `sqrt', e.g., `rootscontract (abs(x)*sqrt(y))'
     yields `sqrt(x^2*y)'.

     There is an option `rootsconmode' affecting `rootscontract' as
     follows:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     When `rootsconmode' is `false', `rootscontract' contracts only
     with respect to rational number exponents whose denominators are
     the same.  The key to the `rootsconmode: true' examples is simply
     that 2 divides into 4 but not into 3.  `rootsconmode: all'
     involves taking the least common multiple of the denominators of
     the exponents.

     `rootscontract' uses `ratsimp' in a manner similar to
     `logcontract'.

     Examples:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Option variable: rootsepsilon
     Default value: 1.0e-7

     `rootsepsilon' is the tolerance which establishes the confidence
     interval for the roots found by the `realroots' function.


 -- Function: solve (<expr>, <x>)
 -- Function: solve (<expr>)
 -- Function: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Solves the algebraic equation <expr> for the variable <x> and
     returns a list of solution equations in <x>.  If <expr> is not an
     equation, the equation `<expr> = 0' is assumed in its place.  <x>
     may be a function (e.g. `f(x)'), or other non-atomic expression
     except a sum or product. <x> may be omitted if <expr> contains
     only one variable.  <expr> may be a rational expression, and may
     contain trigonometric functions, exponentials, etc.

     The following method is used:

     Let <E> be the expression and <X> be the variable.  If <E> is
     linear in <X> then it is trivially solved for <X>.  Otherwise if
     <E> is of the form `A*X^N + B' then the result is `(-B/A)^1/N)'
     times the `N''th roots of unity.

     If <E> is not linear in <X> then the gcd of the exponents of <X>
     in <E> (say <N>) is divided into the exponents and the
     multiplicity of the roots is multiplied by <N>.  Then `solve' is
     called again on the result.  If <E> factors then `solve' is called
     on each of the factors.  Finally `solve' will use the quadratic,
     cubic, or quartic formulas where necessary.

     In the case where <E> is a polynomial in some function of the
     variable to be solved for, say `F(X)', then it is first solved for
     `F(X)' (call the result <C>), then the equation `F(X)=C' can be
     solved for <X> provided the inverse of the function <F> is known.

     `breakup' if `false' will cause `solve' to express the solutions of
     cubic or quartic equations as single expressions rather than as
     made up of several common subexpressions which is the default.

     `multiplicities' - will be set to a list of the multiplicities of
     the individual solutions returned by `solve', `realroots', or
     `allroots'.  Try `apropos (solve)' for the switches which affect
     `solve'.  `describe' may then by used on the individual switch
     names if their purpose is not clear.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' solves a
     system of simultaneous (linear or non-linear) polynomial equations
     by calling `linsolve' or `algsys' and returns a list of the
     solution lists in the variables.  In the case of `linsolve' this
     list would contain a single list of solutions.  It takes two lists
     as arguments.  The first list represents the equations to be
     solved; the second list is a list of the unknowns to be
     determined.  If the total number of variables in the equations is
     equal to the number of equations, the second argument-list may be
     omitted.  For linear systems if the given equations are not
     compatible, the message `inconsistent' will be displayed (see the
     `solve_inconsistent_error' switch); if no unique solution exists,
     then `singular' will be displayed.

     When `programmode' is `false', `solve' displays solutions with
     intermediate expression (`%t') labels, and returns the list of
     labels.

     When `globalsolve' is `true' and the problem is to solve two or
     more linear equations, each solved-for variable is bound to its
     value in the solution of the equations.

     Examples:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Option variable: solvedecomposes
     Default value: `true'

     When `solvedecomposes' is `true', `solve' calls `polydecomp' if
     asked to solve polynomials.


 -- Option variable: solveexplicit
     Default value: `false'

     When `solveexplicit' is `true', inhibits `solve' from returning
     implicit solutions, that is, solutions of the form `F(x) = 0'
     where `F' is some function.


 -- Option variable: solvefactors
     Default value: `true'

     When `solvefactors' is `false', `solve' does not try to factor the
     expression.  The `false' setting may be desired in some cases
     where factoring is not necessary.


 -- Option variable: solvenullwarn
     Default value: `true'

     When `solvenullwarn' is `true', `solve' prints a warning message
     if called with either a null equation list or a null variable list.
     For example, `solve ([], [])' would print two warning messages and
     return `[]'.


 -- Option variable: solveradcan
     Default value: `false'

     When `solveradcan' is `true', `solve' calls `radcan' which makes
     `solve' slower but will allow certain problems containing
     exponentials and logarithms to be solved.


 -- Option variable: solvetrigwarn
     Default value: `true'

     When `solvetrigwarn' is `true', `solve' may print a message saying
     that it is using inverse trigonometric functions to solve the
     equation, and thereby losing solutions.


 -- Option variable: solve_inconsistent_error
     Default value: `true'

     When `solve_inconsistent_error' is `true', `solve' and `linsolve'
     give an error if the equations to be solved are inconsistent.

     If `false', `solve' and `linsolve' return an empty list `[]' if
     the equations are inconsistent.

     Example:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equations:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Differential Equations,  Next: Numerical,  Prev: Equations,  Up: Top

22 Differential Equations
*************************

* Menu:

* Definitions for Differential Equations::


File: maxima.info,  Node: Definitions for Differential Equations,  Prev: Differential Equations,  Up: Differential Equations

22.1 Definitions for Differential Equations
===========================================

 -- Function: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)
     Solves boundary value problem for second order differential
     equation.  Here: <solution> is a general solution to the equation,
     as found by `ode2', <xval1> is an equation for the independent
     variable in the form `<x> = <x0>', and <yval1> is an equation for
     the dependent variable in the form `<y> = <y0>'.  The <xval2> and
     <yval2> are equations for these variables at another point.  See
     `ode2' for example of usage.


 -- Function: desolve (<eqn>, <x>)
 -- Function: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     The function `dsolve' solves systems of linear ordinary
     differential equations using Laplace transform.  Here the <eqn>'s
     are differential equations in the dependent variables <x_1>, ...,
     <x_n>.  The functional relationships must be explicitly indicated
     in both the equations and the variables. For example

          'diff(f,x,2)=sin(x)+'diff(g,x);
          'diff(f,x)+x^2-f=2*'diff(g,x,2);

     is not the proper format.  The correct way is:

          'diff(f(x),x,2)=sin(x)+'diff(g(x),x);
          'diff(f(x),x)+x^2-f=2*'diff(g(x),x,2);

     The call is then `desolve([%o3,%o4],[f(x),g(x)]);' .

     If initial conditions at 0 are known, they should be supplied
     before calling `desolve' by using `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     If `desolve' cannot obtain a solution, it returns `false'.


 -- Function: ic1 (<solution>, <xval>, <yval>)
     Solves initial value problem for first order differential equation.
     Here: <solution> is a general solution to the equation, as found
     by `ode2', <xval> is an equation for the independent variable in
     the form `<x> = <x0>', and <yval> is an equation for the dependent
     variable in the form `<y> = <y0>'. See `ode2' for example of usage.


 -- Function: ic2 (<solution>, <xval>, <yval>, <dval>)
     Solves initial value problem for second order differential
     equation.  Here: <solution> is a general solution to the equation,
     as found by `ode2', <xval> is an equation for the independent
     variable in the form `<x> = <x0>', <yval> is an equation for the
     dependent variable in the form `<y> = <y0>', and <dval> is an
     equation for the derivative of the dependent variable with respect
     to independent variable evaluated at the point <xval>.  See `ode2'
     for example of usage.


 -- Function: ode2 (<eqn>, <dvar>, <ivar>)
     The function `ode2' solves ordinary differential equations of
     first or second order.  It takes three arguments: an ODE <eqn>,
     the dependent variable <dvar>, and the independent variable <ivar>.
     When successful, it returns either an explicit or implicit
     solution for the dependent variable.  `%c' is used to represent
     the constant in the case of first order equations, and `%k1' and
     `%k2' the constants for second order equations.  If `ode2' cannot
     obtain a solution for whatever reason, it returns `false', after
     perhaps printing out an error message.  The methods implemented
     for first order equations in the order in which they are tested
     are: linear, separable, exact - perhaps requiring an integrating
     factor, homogeneous, Bernoulli's equation, and a generalized
     homogeneous method.  For second order: constant coefficient,
     exact, linear homogeneous with non-constant coefficients which can
     be transformed to constant coefficient, the Euler or
     equidimensional equation, the method of variation of parameters,
     and equations which are free of either the independent or of the
     dependent variable so that they can be reduced to two first order
     linear equations to be solved sequentially.  In the course of
     solving ODEs, several variables are set purely for informational
     purposes: `method' denotes the method of solution used e.g.
     `linear', `intfactor' denotes any integrating factor used,
     `odeindex' denotes the index for Bernoulli's method or for the
     generalized homogeneous method, and `yp' denotes the particular
     solution for the variation of parameters technique.

     In order to solve initial value problems (IVPs) and boundary value
     problems (BVPs), the routine `ic1' is available for first order
     equations, and `ic2' and `bc2' for second order IVPs and BVPs,
     respectively.

     Example:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Numerical,  Next: Statistics,  Prev: Differential Equations,  Up: Top

23 Numerical
************

* Menu:

* Introduction to Numerical::
* Fourier packages::
* Definitions for Numerical::
* Definitions for Fourier Series::


File: maxima.info,  Node: Introduction to Numerical,  Next: Fourier packages,  Prev: Numerical,  Up: Numerical

23.1 Introduction to Numerical
==============================


File: maxima.info,  Node: Fourier packages,  Next: Definitions for Numerical,  Prev: Introduction to Numerical,  Up: Numerical

23.2 Fourier packages
=====================

The `fft' package comprises functions for the numerical (not symbolic)
computation of the fast Fourier transform.  `load ("fft")' loads this
package.  See `fft'.

   The `fourie' package comprises functions for the symbolic computation
of Fourier series.  `load ("fourie")' loads this package.  There are
functions in the `fourie' package to calculate Fourier integral
coefficients and some functions for manipulation of expressions.  See
`Definitions for Fourier Series'.


File: maxima.info,  Node: Definitions for Numerical,  Next: Definitions for Fourier Series,  Prev: Fourier packages,  Up: Numerical

23.3 Definitions for Numerical
==============================

 -- Function: polartorect (<magnitude_array>, <phase_array>)
     Translates complex values of the form `r %e^(%i t)' to the form `a
     + b %i'.  `load ("fft")' loads this function into Maxima. See also
     `fft'.

     The magnitude and phase, `r' and `t', are taken from
     <magnitude_array> and <phase_array>, respectively. The original
     values of the input arrays are replaced by the real and imaginary
     parts, `a' and `b', on return. The outputs are calculated as

          a: r cos (t)
          b: r sin (t)

     The input arrays must be the same size and 1-dimensional.  The
     array size need not be a power of 2.

     `polartorect' is the inverse function of `recttopolar'.


 -- Function: recttopolar (<real_array>, <imaginary_array>)
     Translates complex values of the form `a + b %i' to the form `r
     %e^(%i t)'.  `load ("fft")' loads this function into Maxima. See
     also `fft'.

     The real and imaginary parts, `a' and `b', are taken from
     <real_array> and <imaginary_array>, respectively. The original
     values of the input arrays are replaced by the magnitude and
     angle, `r' and `t', on return. The outputs are calculated as

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     The computed angle is in the range `-%pi' to `%pi'.

     The input arrays must be the same size and 1-dimensional.  The
     array size need not be a power of 2.

     `recttopolar' is the inverse function of `polartorect'.


 -- Function: ift (<real_array>, <imaginary_array>)
     Fast inverse discrete Fourier transform. `load ("fft")' loads this
     function into Maxima.

     `ift' carries out the inverse complex fast Fourier transform on
     1-dimensional floating point arrays. The inverse transform is
     defined as

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     See `fft' for more details.


 -- Function: fft (<real_array>, <imaginary_array>)
 -- Function: ift (<real_array>, <imaginary_array>)
 -- Function: recttopolar (<real_array>, <imaginary_array>)
 -- Function: polartorect (<magnitude_array>, <phase_array>)
     Fast Fourier transform and related functions. `load ("fft")' loads
     these functions into Maxima.

     `fft' and `ift' carry out the complex fast Fourier transform and
     inverse transform, respectively, on 1-dimensional floating point
     arrays. The size of <imaginary_array> must equal the size of
     <real_array>.

     `fft' and `ift' operate in-place. That is, on return from `fft' or
     `ift', the original content of the input arrays is replaced by the
     output.  The `fillarray' function can make a copy of an array,
     should it be necessary.

     The discrete Fourier transform and inverse transform are defined
     as follows. Let `x' be the original data, with

          x[i]: real_array[i] + %i imaginary_array[i]

     Let `y' be the transformed data. The forward and inverse
     transforms are

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Suitable arrays can be allocated by the `array' function. For
     example:

          array (my_array, float, n-1)$

     declares a 1-dimensional array with n elements, indexed from 0
     through n-1 inclusive. The number of elements n must be equal to
     2^m for some m.

     `fft' can be applied to real data (imaginary array all zeros) to
     obtain sine and cosine coefficients. After calling `fft', the sine
     and cosine coefficients, say `a' and `b', can be calculated as

          a[0]: real_array[0]
          b[0]: 0

     and

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     for j equal to 1 through n/2-1, and

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     `recttopolar' translates complex values of the form `a + b %i' to
     the form `r %e^(%i t)'. See `recttopolar'.

     `polartorect' translates complex values of the form `r %e^(%i t)'
     to the form `a + b %i'. See `polartorect'.

     `demo ("fft")' displays a demonstration of the `fft' package.


 -- Option variable: fortindent
     Default value: 0

     `fortindent' controls the left margin indentation of expressions
     printed out by the `fortran' command.  0 gives normal printout
     (i.e., 6 spaces), and positive values will causes the expressions
     to be printed farther to the right.


 -- Function: fortran (<expr>)
     Prints <expr> as a Fortran statement.  The output line is indented
     with spaces.  If the line is too long, `fortran' prints
     continuation lines.  `fortran' prints the exponentiation operator
     `^' as `**', and prints a complex number `a + b %i' in the form
     `(a,b)'.

     <expr> may be an equation. If so, `fortran' prints an assignment
     statement, assigning the right-hand side of the equation to the
     left-hand side.  In particular, if the right-hand side of <expr>
     is the name of a matrix, then `fortran' prints an assignment
     statement for each element of the matrix.

     If <expr> is not something recognized by `fortran', the expression
     is printed in `grind' format without complaint.  `fortran' does
     not know about lists, arrays, or functions.

     `fortindent' controls the left margin of the printed lines.  0 is
     the normal margin (i.e., indented 6 spaces). Increasing
     `fortindent' causes expressions to be printed further to the right.

     When `fortspaces' is `true', `fortran' fills out each printed line
     with spaces to 80 columns.

     `fortran' evaluates its arguments; quoting an argument defeats
     evaluation.  `fortran' always returns `done'.

     Examples:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Option variable: fortspaces
     Default value: `false'

     When `fortspaces' is `true', `fortran' fills out each printed line
     with spaces to 80 columns.


 -- Function: horner (<expr>, <x>)
 -- Function: horner (<expr>)
     Returns a rearranged representation of <expr> as in Horner's rule,
     using <x> as the main variable if it is specified.  `x' may be
     omitted in which case the main variable of the canonical rational
     expression form of <expr> is used.

     `horner' sometimes improves stability if `expr' is to be
     numerically evaluated.  It is also useful if Maxima is used to
     generate programs to be run in Fortran. See also `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Function: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Function: find_root (<f>, <a>, <b>)
     Finds the zero of function <f> as variable <x> varies over the
     range `[<a>, <b>]'.  The function must have a different sign at
     each endpoint.  If this condition is not met, the action of the
     function is governed by `find_root_error'.  If `find_root_error'
     is `true' then an error occurs, otherwise the value of
     `find_root_error' is returned (thus for plotting `find_root_error'
     might be set to 0.0).  Otherwise (given that Maxima can evaluate
     the first argument in the specified range, and that it is
     continuous) `find_root' is guaranteed to come up with the zero (or
     one of them if there is more than one zero).  The accuracy of
     `find_root' is governed by `find_root_abs' and `find_root_rel'
     which must be non-negative floating point numbers.  `find_root'
     will stop when the first arg evaluates to something less than or
     equal to `find_root_abs' or if successive approximants to the root
     differ by no more than `find_root_rel * <one of the approximants>'.
     The default values of `find_root_abs' and `find_root_rel' are 0.0
     so `find_root' gets as good an answer as is possible with the
     single precision arithmetic we have.  The first arg may be an
     equation.  The order of the last two args is irrelevant.  Thus

          find_root (sin(x) = x/2, x, %pi, 0.1);

     is equivalent to

          find_root (sin(x) = x/2, x, 0.1, %pi);

     The method used is a binary search in the range specified by the
     last two args.  When it thinks the function is close enough to
     being linear, it starts using linear interpolation.

     Examples:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Option variable: find_root_abs
     Default value: 0.0

     `find_root_abs' is the accuracy of the `find_root' command is
     governed by `find_root_abs' and `find_root_rel' which must be
     non-negative floating point numbers.  `find_root' will stop when
     the first arg evaluates to something less than or equal to
     `find_root_abs' or if successive approximants to the root differ
     by no more than `find_root_rel * <one of the approximants>'.  The
     default values of `find_root_abs' and `find_root_rel' are 0.0 so
     `find_root' gets as good an answer as is possible with the single
     precision arithmetic we have.


 -- Option variable: find_root_error
     Default value: `true'

     `find_root_error' governs the behavior of `find_root'.  When
     `find_root' is called, it determines whether or not the function
     to be solved satisfies the condition that the values of the
     function at the endpoints of the interpolation interval are
     opposite in sign.  If they are of opposite sign, the interpolation
     proceeds.  If they are of like sign, and `find_root_error' is
     `true', then an error is signaled.  If they are of like sign and
     `find_root_error' is not `true', the value of `find_root_error' is
     returned.  Thus for plotting, `find_root_error' might be set to
     0.0.


 -- Option variable: find_root_rel
     Default value: 0.0

     `find_root_rel' is the accuracy of the `find_root' command is
     governed by `find_root_abs' and `find_root_rel' which must be
     non-negative floating point numbers.  `find_root' will stop when
     the first arg evaluates to something less than or equal to
     `find_root_abs' or if successive approximants to the root differ
     by no more than `find_root_rel * <one of the approximants>'.  The
     default values of `find_root_abs' and `find_root_rel' are 0.0 so
     `find_root' gets as good an answer as is possible with the single
     precision arithmetic we have.



File: maxima.info,  Node: Definitions for Fourier Series,  Prev: Definitions for Numerical,  Up: Numerical

23.4 Definitions for Fourier Series
===================================

 -- Function: equalp (<x>, <y>)
     Returns `true' if `equal (<x>, <y>)' otherwise `false' (doesn't
     give an error message like `equal (x, y)' would do in this case).


 -- Function: remfun (<f>, <expr>)
 -- Function: remfun (<f>, <expr>, <x>)
     `remfun (<f>, <expr>)' replaces all occurrences of `<f> (<arg>)'
     by <arg> in <expr>.

     `remfun (<f>, <expr>, <x>)' replaces all occurrences of `<f>
     (<arg>)' by <arg> in <expr> only if <arg> contains the variable
     <x>.


 -- Function: funp (<f>, <expr>)
 -- Function: funp (<f>, <expr>, <x>)
     `funp (<f>, <expr>)' returns `true' if <expr> contains the
     function <f>.

     `funp (<f>, <expr>, <x>)' returns `true' if <expr> contains the
     function <f> and the variable <x> is somewhere in the argument of
     one of the instances of <f>.


 -- Function: absint (<f>, <x>, <halfplane>)
 -- Function: absint (<f>, <x>)
 -- Function: absint (<f>, <x>, <a>, <b>)
     `absint (<f>, <x>, <halfplane>)' returns the indefinite integral
     of <f> with respect to <x> in the given halfplane (`pos', `neg',
     or `both').  <f> may contain expressions of the form `abs (x)',
     `abs (sin (x))', `abs (a) * exp (-abs (b) * abs (x))'.

     `absint (<f>, <x>)' is equivalent to `absint (<f>, <x>, pos)'.

     `absint (<f>, <x>, <a>, <b>)' returns the definite integral of <f>
     with respect to <x> from <a> to <b>.  <f> may include absolute
     values.


 -- Function: fourier (<f>, <x>, <p>)
     Returns a list of the Fourier coefficients of `<f>(<x>)' defined
     on the interval `[-%pi, %pi]'.


 -- Function: foursimp (<l>)
     Simplifies `sin (n %pi)' to 0 if `sinnpiflag' is `true' and `cos
     (n %pi)' to `(-1)^n' if `cosnpiflag' is `true'.


 -- Option variable: sinnpiflag
     Default value: `true'

     See `foursimp'.


 -- Option variable: cosnpiflag
     Default value: `true'

     See `foursimp'.


 -- Function: fourexpand (<l>, <x>, <p>, <limit>)
     Constructs and returns the Fourier series from the list of Fourier
     coefficients <l> up through <limit> terms (<limit> may be `inf').
     <x> and <p> have same meaning as in `fourier'.


 -- Function: fourcos (<f>, <x>, <p>)
     Returns the Fourier cosine coefficients for `<f>(<x>)' defined on
     `[0, %pi]'.


 -- Function: foursin (<f>, <x>, <p>)
     Returns the Fourier sine coefficients for `<f>(<x>)' defined on
     `[0, %pi]'.


 -- Function: totalfourier (<f>, <x>, <p>)
     Returns `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.


 -- Function: fourint (<f>, <x>)
     Constructs and returns a list of the Fourier integral coefficients
     of `<f>(<x>)' defined on `[minf, inf]'.


 -- Function: fourintcos (<f>, <x>)
     Returns the Fourier cosine integral coefficients for `<f>(<x>)' on
     `[0, inf]'.


 -- Function: fourintsin (<f>, <x>)
     Returns the Fourier sine integral coefficients for `<f>(<x>)' on
     `[0, inf]'.



File: maxima.info,  Node: Statistics,  Next: Arrays and Tables,  Prev: Numerical,  Up: Top

24 Statistics
*************

* Menu:

* Definitions for Statistics::


File: maxima.info,  Node: Definitions for Statistics,  Prev: Statistics,  Up: Statistics

24.1 Definitions for Statistics
===============================

 -- Function: gauss (<mean>, <sd>)
     Returns a random floating point number from a normal distribution
     with mean <mean> and standard deviation <sd>.



File: maxima.info,  Node: Arrays and Tables,  Next: Matrices and Linear Algebra,  Prev: Statistics,  Up: Top

25 Arrays and Tables
********************

* Menu:

* Definitions for Arrays and Tables::


File: maxima.info,  Node: Definitions for Arrays and Tables,  Prev: Arrays and Tables,  Up: Arrays and Tables

25.1 Definitions for Arrays and Tables
======================================

 -- Function: array (<name>, <dim_1>, ..., <dim_n>)
 -- Function: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Function: array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)
     Creates an n-dimensional array.  n may be less than or equal to 5.
     The subscripts for the i'th dimension are the integers running
     from 0 to <dim_i>.

     `array (<name>, <dim_1>, ..., <dim_n>)' creates a general array.

     `array (<name>, <type>, <dim_1>, ..., <dim_n>)' creates an array,
     with elements of a specified type.  <type> can be `fixnum' for
     integers of limited size or `flonum' for floating-point numbers.

     `array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)' creates
     m arrays, all of the same dimensions.

     If the user assigns to a subscripted variable before declaring the
     corresponding array, an undeclared array is created.  Undeclared
     arrays, otherwise known as hashed arrays (because hash coding is
     done on the subscripts), are more general than declared arrays.
     The user does not declare their maximum size, and they grow
     dynamically by hashing as more elements are assigned values.  The
     subscripts of undeclared arrays need not even be numbers.  However,
     unless an array is rather sparse, it is probably more efficient to
     declare it when possible than to leave it undeclared.  The `array'
     function can be used to transform an undeclared array into a
     declared array.


 -- Function: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Evaluates `<A> [<i_1>, ..., <i_n>]', where <A> is an array and
     <i_1>, ..., <i_n> are integers.

     This is reminiscent of `apply', except the first argument is an
     array instead of a function.


 -- Function: arrayinfo (<A>)
     Returns a list of information about the array <A>.  For hashed
     arrays it returns a list of `hashed', the number of subscripts,
     and the subscripts of every element which has a value.  For
     declared arrays it returns a list of `declared', the number of
     subscripts, and the bounds that were given the the `array'
     function when it was called on <A>.  Do `example(arrayinfo);' for
     an example.


 -- Function: arraymake (<name>, [<i_1>, ..., <i_n>])
     Returns the expression `<name> [<i_1>, ..., <i_n>]'.

     This is reminiscent of `funmake', except the return value is an
     unevaluated array reference instead of an unevaluated function
     call.


 -- System variable: arrays
     Default value: `[]'

     `arrays' is a list of all the arrays that have been allocated,
     both declared and undeclared.

     See also `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray', and `rearray'.


 -- Function: bashindices (<expr>)
     Transforms the expression <expr> by giving each summation and
     product a unique index. This gives `changevar' greater precision
     when it is working with summations or products.  The form of the
     unique index is `j<number>'. The quantity <number> is determined by
     referring to `gensumnum', which can be changed by the user.  For
     example, `gensumnum:0$' resets it.


 -- Function: fillarray (<A>, <B>)
     Fills array <A> from <B>, which is a list or an array.

     If <A> is a floating-point (integer) array then <B> should be
     either a list of floating-point (integer) numbers or another
     floating-point (integer) array.

     If the dimensions of the arrays are different <A> is filled in
     row-major order.  If there are not enough elements in <B> the last
     element is used to fill out the rest of <A>.  If there are too
     many the remaining ones are thrown away.

     `fillarray' returns its first argument.


 -- Function: listarray (<A>)
     Returns a list of the elements of a declared or hashed array <A>.
     The order is row-major.  Elements which are not yet defined are
     represented by `#####'.


 -- Function: make_array (<type>, <dim_1>, ..., <dim_n>)
     Creates and returns a Lisp array.  <type> may be `any', `flonum',
     `fixnum', `hashed' or `functional'.  There are n indices, and the
     i'th index runs from 0 to <dim_i> - 1.

     The advantage of `make_array' over `array' is that the return
     value doesn't have a name, and once a pointer to it goes away, it
     will also go away.  For example, if `y: make_array (...)' then `y'
     points to an object which takes up space, but after `y: false',
     `y' no longer points to that object, so the object can be garbage
     collected.

     `y: make_array ('functional, 'f, 'hashed, 1)' - the second
     argument to `make_array' in this case is the function to call to
     calculate array elements, and the rest of the arguments are passed
     recursively to `make_array' to generate the "memory" for the array
     function object.


 -- Function: rearray (<A>, <dim_1>, ..., <dim_n>)
     Changes the dimensions of an array.  The new array will be filled
     with the elements of the old one in row-major order.  If the old
     array was too small, the remaining elements are filled with
     `false', `0.0' or `0', depending on the type of the array.  The
     type of the array cannot be changed.


 -- Function: remarray (<A_1>, ..., <A_n>)
 -- Function: remarray (all)
     Removes arrays and array associated functions and frees the
     storage occupied.

     `remarray (all)' removes all items in the global list `arrays'.

     It may be necessary to use this function if it is desired to
     redefine the values in a hashed array.

     `remarray' returns the list of arrays removed.


 -- Function: subvar (<x>, <i>)
     Evaluates the subscripted expression `<x>[<i>]'.

     `subvar' evaluates its arguments.

     `arraymake (<x>, [<i>]' constructs the expression `<x>[<i>]', but
     does not evaluate it.

     Examples:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Option variable: use_fast_arrays
     - if `true' then only two types of arrays are recognized.

     1) The art-q array (t in Common Lisp) which may have several
     dimensions indexed by integers, and may hold any Lisp or Maxima
     object as an entry.  To construct such an array, enter
     `a:make_array(any,3,4);' then `a' will have as value, an array
     with twelve slots, and the indexing is zero based.

     2) The Hash_table array which is the default type of array created
     if one does `b[x+1]:y^2' (and `b' is not already an array, a list,
     or a matrix - if it were one of these an error would be caused
     since `x+1' would not be a valid subscript for an art-q array, a
     list or a matrix). Its indices (also known as keys) may be any
     object.  It only takes one key at a time (`b[x+1,u]:y' would
     ignore the `u').  Referencing is done by `b[x+1] ==> y^2'.  Of
     course the key may be a list, e.g. `b[[x+1,u]]:y' would be valid.
     This is incompatible with the old Maxima hash arrays, but saves
     consing.

     An advantage of storing the arrays as values of the symbol is that
     the usual conventions about local variables of a function apply to
     arrays as well.  The Hash_table type also uses less consing and is
     more efficient than the old type of Maxima hashar.  To obtain
     consistent behaviour in translated and compiled code set
     `translate_fast_arrays' to be `true'.



File: maxima.info,  Node: Matrices and Linear Algebra,  Next: Affine,  Prev: Arrays and Tables,  Up: Top

26 Matrices and Linear Algebra
******************************

* Menu:

* Introduction to Matrices and Linear Algebra::
* Definitions for Matrices and Linear Algebra::


File: maxima.info,  Node: Introduction to Matrices and Linear Algebra,  Next: Definitions for Matrices and Linear Algebra,  Prev: Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

26.1 Introduction to Matrices and Linear Algebra
================================================

* Menu:

* Dot::
* Vectors::
* eigen::


File: maxima.info,  Node: Dot,  Next: Vectors,  Prev: Introduction to Matrices and Linear Algebra,  Up: Introduction to Matrices and Linear Algebra

26.1.1 Dot
----------

The operator `.' represents noncommutative multiplication and scalar
product.  When the operands are 1-column or 1-row matrices `a' and `b',
the expression `a.b' is equivalent to `sum (a[i]*b[i], i, 1,
length(a))'.  If `a' and `b' are not complex, this is the scalar
product, also called the inner product or dot product, of `a' and `b'.
The scalar product is defined as `conjugate(a).b' when `a' and `b' are
complex; `innerproduct' in the `eigen' package provides the complex
scalar product.

   When the operands are more general matrices, the product is the
matrix product `a' and `b'.  The number of rows of `b' must equal the
number of columns of `a', and the result has number of rows equal to
the number of rows of `a' and number of columns equal to the number of
columns of `b'.

   To distinguish `.' as an arithmetic operator from the decimal point
in a floating point number, it may be necessary to leave spaces on
either side.  For example, `5.e3' is `5000.0' but `5 . e3' is `5' times
`e3'.

   There are several flags which govern the simplification of
expressions involving `.', namely `dot', `dot0nscsimp', `dot0simp',
`dot1simp', `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
`dotident', and `dotscrules'.


File: maxima.info,  Node: Vectors,  Next: eigen,  Prev: Dot,  Up: Introduction to Matrices and Linear Algebra

26.1.2 Vectors
--------------

`vect' is a package of functions for vector analysis.  `load ("vect")'
loads this package, and `demo ("vect")' displays a demonstration.

   The vector analysis package can combine and simplify symbolic
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is governed by
several flags, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.  There
are also functions for deriving the scalar or vector potential of a
field.

   The `vect' package contains these functions: `vectorsimp',
`scalefactors', `express', `potential', and `vectorpotential'.

   Warning: the `vect' package declares the dot operator `.' to be a
commutative operator.


File: maxima.info,  Node: eigen,  Prev: Vectors,  Up: Introduction to Matrices and Linear Algebra

26.1.3 eigen
------------

The package `eigen' contains several functions devoted to the symbolic
computation of eigenvalues and eigenvectors.  Maxima loads the package
automatically if one of the functions `eigenvalues' or `eigenvectors'
is invoked.  The package may be loaded explicitly as `load ("eigen")'.

   `demo ("eigen")' displays a demonstration of the capabilities of
this package.  `batch ("eigen")' executes the same demonstration, but
without the user prompt between successive computations.

   The functions in the `eigen' package are `innerproduct',
`unitvector', `columnvector', `gramschmidt', `eigenvalues',
`eigenvectors', `uniteigenvectors', and `similaritytransform'.


File: maxima.info,  Node: Definitions for Matrices and Linear Algebra,  Prev: Introduction to Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

26.2 Definitions for Matrices and Linear Algebra
================================================

 -- Function: addcol (<M>, <list_1>, ..., <list_n>)
     Appends the column(s) given by the one or more lists (or matrices)
     onto the matrix <M>.


 -- Function: addrow (<M>, <list_1>, ..., <list_n>)
     Appends the row(s) given by the one or more lists (or matrices)
     onto the matrix <M>.


 -- Function: adjoint (<M>)
     Returns the adjoint of the matrix <M>.  The adjoint matrix is the
     transpose of the matrix of cofactors of <M>.


 -- Function: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ...,
          <x_n>])
     Returns the augmented coefficient matrix for the variables <x_1>,
     ..., <x_n> of the system of linear equations <eqn_1>, ...,
     <eqn_m>.  This is the coefficient matrix with a column adjoined for
     the constant terms in each equation (i.e., those terms not
     dependent upon <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Function: charpoly (<M>, <x>)
     Returns the characteristic polynomial for the matrix <M> with
     respect to variable <x>.  That is, `determinant (<M> - diagmatrix
     (length (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Function: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Returns the coefficient matrix for the variables <x_1>, ..., <x_n>
     of the system of linear equations <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Function: col (<M>, <i>)
     Returns the <i>'th column of the matrix <M>.  The return value is
     a matrix.


 -- Function: columnvector (<L>)
 -- Function: covect (<L>)
     Returns a matrix of one column and `length (<L>)' rows, containing
     the elements of the list <L>.

     `covect' is a synonym for `columnvector'.

     `load ("eigen")' loads this function.

     This is useful if you want to use parts of the outputs of the
     functions in this package in matrix calculations.

     Example:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Function: conjugate (<x>)
     Returns the complex conjugate of <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Function: copymatrix (<M>)
     Returns a copy of the matrix <M>.  This is the only way to make a
     copy aside from copying <M> element by element.

     Note that an assignment of one matrix to another, as in `m2: m1',
     does not copy `m1'.  An assignment `m2 [i,j]: x' or `setelmx (x,
     i, j, m2' also modifies `m1 [i,j]'.  Creating a copy with
     `copymatrix' and then using assignment creates a separate,
     modified copy.


 -- Function: determinant (<M>)
     Computes the determinant of <M> by a method similar to Gaussian
     elimination.

     The form of the result depends upon the setting of the switch
     `ratmx'.

     There is a special routine for computing sparse determinants which
     is called when the switches `ratmx' and `sparse' are both `true'.


 -- Option variable: detout
     Default value: `false'

     When `detout' is `true', the determinant of a matrix whose inverse
     is computed is factored out of the inverse.

     For this switch to have an effect `doallmxops' and `doscmxops'
     should be `false' (see their descriptions).  Alternatively this
     switch can be given to `ev' which causes the other two to be set
     correctly.

     Example:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Function: diagmatrix (<n>, <x>)
     Returns a diagonal matrix of size <n> by <n> with the diagonal
     elements all equal to <x>.  `diagmatrix (<n>, 1)' returns an
     identity matrix (same as `ident (<n>)').

     <n> must evaluate to an integer, otherwise `diagmatrix' complains
     with an error message.

     <x> can be any kind of expression, including another matrix.  If
     <x> is a matrix, it is not copied; all diagonal elements refer to
     the same instance, <x>.


 -- Option variable: doallmxops
     Default value: `true'

     When `doallmxops' is `true', all operations relating to matrices
     are carried out.  When it is `false' then the setting of the
     individual `dot' switches govern which operations are performed.


 -- Option variable: domxexpt
     Default value: `true'

     When `domxexpt' is `true', a matrix exponential, `exp (<M>)' where
     <M> is a matrix, is interpreted as a matrix with element `[i,j'
     equal to `exp (m[i,j])'.  Otherwise `exp (<M>)' evaluates to `exp
     (<ev(M)>'.

     `domxexpt' affects all expressions of the form `<base>^<power>'
     where <base> is an expression assumed scalar or constant, and
     <power> is a list or matrix.

     Example:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Option variable: domxmxops
     Default value: `true'

     When `domxmxops' is `true', all matrix-matrix or matrix-list
     operations are carried out (but not scalar-matrix operations); if
     this switch is `false' such operations are not carried out.


 -- Option variable: domxnctimes
     Default value: `false'

     When `domxnctimes' is `true', non-commutative products of matrices
     are carried out.


 -- Option variable: dontfactor
     Default value: `[]'

     `dontfactor' may be set to a list of variables with respect to
     which factoring is not to occur.  (The list is initially empty.)
     Factoring also will not take place with respect to any variables
     which are less important, according the variable ordering assumed
     for canonical rational expression (CRE) form, than those on the
     `dontfactor' list.


 -- Option variable: doscmxops
     Default value: `false'

     When `doscmxops' is `true', scalar-matrix operations are carried
     out.


 -- Option variable: doscmxplus
     Default value: `false'

     When `doscmxplus' is `true', scalar-matrix operations yield a
     matrix result.  This switch is not subsumed under `doallmxops'.


 -- Option variable: dot0nscsimp
     Default value: `true'

     When `dot0nscsimp' is `true', a non-commutative product of zero
     and a nonscalar term is simplified to a commutative product.


 -- Option variable: dot0simp
     Default value: `true'

     When `dot0simp' is `true', a non-commutative product of zero and a
     scalar term is simplified to a commutative product.


 -- Option variable: dot1simp
     Default value: `true'

     When `dot1simp' is `true', a non-commutative product of one and
     another term is simplified to a commutative product.


 -- Option variable: dotassoc
     Default value: `true'

     When `dotassoc' is `true', an expression `(A.B).C' simplifies to
     `A.(B.C)'.


 -- Option variable: dotconstrules
     Default value: `true'

     When `dotconstrules' is `true', a non-commutative product of a
     constant and another term is simplified to a commutative product.
     Turning on this flag effectively turns on `dot0simp',
     `dot0nscsimp', and `dot1simp' as well.


 -- Option variable: dotdistrib
     Default value: `false'

     When `dotdistrib' is `true', an expression `A.(B + C)' simplifies
     to `A.B + A.C'.


 -- Option variable: dotexptsimp
     Default value: `true'

     When `dotexptsimp' is `true', an expression `A.A' simplifies to
     `A^^2'.


 -- Option variable: dotident
     Default value: 1

     `dotident' is the value returned by `X^^0'.


 -- Option variable: dotscrules
     Default value: `false'

     When `dotscrules' is `true', an expression `A.SC' or `SC.A'
     simplifies to `SC*A' and `A.(SC*B)' simplifies to `SC*(A.B)'.


 -- Function: echelon (<M>)
     Returns the echelon form of the matrix <M>, as produced by
     Gaussian elimination.  The echelon form is computed from <M> by
     elementary row operations such that the first non-zero element in
     each row in the resulting matrix is one and the column elements
     under the first one in each row are all zero.

     `triangularize' also carries out Gaussian elimination, but it does
     not normalize the leading non-zero element in each row.

     `lu_factor' and `cholesky' are other functions which yield
     triangularized matrices.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Function: eigenvalues (<M>)
 -- Function: eivals (<M>)
     Returns a list of two lists containing the eigenvalues of the
     matrix <M>.  The first sublist of the return value is the list of
     eigenvalues of the matrix, and the second sublist is the list of
     the multiplicities of the eigenvalues in the corresponding order.

     `eivals' is a synonym for `eigenvalues'.

     `eigenvalues' calls the function `solve' to find the roots of the
     characteristic polynomial of the matrix.  Sometimes `solve' may
     not be able to find the roots of the polynomial; in that case some
     other functions in this package (except `innerproduct',
     `unitvector', `columnvector' and `gramschmidt') will not work.

     In some cases the eigenvalues found by `solve' may be complicated
     expressions.  (This may happen when `solve' returns a
     not-so-obviously real expression for an eigenvalue which is known
     to be real.)  It may be possible to simplify the eigenvalues using
     some other functions.

     The package `eigen.mac' is loaded automatically when `eigenvalues'
     or `eigenvectors' is referenced.  If `eigen.mac' is not already
     loaded, `load ("eigen")' loads it.  After loading, all functions
     and variables in the package are available.


 -- Function: eigenvectors (<M>)
 -- Function: eivects (<M>)
     takes a matrix <M> as its argument and returns a list of lists the
     first sublist of which is the output of `eigenvalues' and the
     other sublists of which are the eigenvectors of the matrix
     corresponding to those eigenvalues respectively.  The calculated
     eigenvectors and the unit eigenvectors of the matrix are the right
     eigenvectors and the right unit eigenvectors respectively.

     `eivects' is a synonym for `eigenvectors'.

     The package `eigen.mac' is loaded automatically when `eigenvalues'
     or `eigenvectors' is referenced.  If `eigen.mac' is not already
     loaded, `load ("eigen")' loads it.  After loading, all functions
     and variables in the package are available.

     The flags that affect this function are:

     `nondiagonalizable' is set to `true' or `false' depending on
     whether the matrix is nondiagonalizable or diagonalizable after
     `eigenvectors' returns.

     `hermitianmatrix' when `true', causes the degenerate eigenvectors
     of the Hermitian matrix to be orthogonalized using the
     Gram-Schmidt algorithm.

     `knowneigvals' when `true' causes the `eigen' package to assume the
     eigenvalues of the matrix are known to the user and stored under
     the global name `listeigvals'.  `listeigvals' should be set to a
     list similar to the output `eigenvalues'.

     The function `algsys' is used here to solve for the eigenvectors.
     Sometimes if the eigenvalues are messy, `algsys' may not be able
     to find a solution.  In some cases, it may be possible to simplify
     the eigenvalues by first finding them using `eigenvalues' command
     and then using other functions to reduce them to something simpler.
     Following simplification, `eigenvectors' can be called again with
     the `knowneigvals' flag set to `true'.


 -- Function: ematrix (<m>, <n>, <x>, <i>, <j>)
     Returns an <m> by <n> matrix, all elements of which are zero
     except for the `[<i>, <j>]' element which is <x>.


 -- Function: entermatrix (<m>, <n>)
     Returns an <m> by <n> matrix, reading the elements interactively.

     If <n> is equal to <m>, Maxima prompts for the type of the matrix
     (diagonal, symmetric, antisymmetric, or general) and for each
     element.  Each response is terminated by a semicolon `;' or dollar
     sign `$'.

     If <n> is not equal to <m>, Maxima prompts for each element.

     The elements may be any expressions, which are evaluated.
     `entermatrix' evaluates its arguments.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matrix entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Function: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Function: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Function: genmatrix (<a>, <i_2>, <j_2>)
     Returns a matrix generated from <a>, taking element
     `<a>[<i_1>,<j_1>]' as the upper-left element and `<a>[<i_2>,<j_2>]'
     as the lower-right element of the matrix.  Here <a> is an array
     (created by `array' but not by `make_array') or an array function.
     (An array function is created like other functions with `:=' or
     `define', but arguments are enclosed in square brackets instead of
     parentheses.)

     If <j_1> is omitted, it is assumed equal to <i_1>.  If both <j_1>
     and <i_1> are omitted, both are assumed equal to 1.

     If a selected element `i,j' of the array is undefined, the matrix
     will contain a symbolic element `<a>[i,j]'.

          (%i1) h[i,j] := 1/(i+j-1)$
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2)$
          (%i4) a[1,1]: %e$
          (%i5) a[2,2]: %pi$
          (%i6) kill (a[1,2], a[2,1])$
          (%i7) genmatrix (a, 2, 2);
                                  [  %e    a     ]
                                  [         1, 2 ]
          (%o7)                   [              ]
                                  [ a       %pi  ]
                                  [  2, 1        ]


 -- Function: gramschmidt (<x>)
 -- Function: gschmit (<x>)
     Carries out the Gram-Schmidt orthogonalization algorithm on <x>,
     which is either a matrix or a list of lists.  <x> is not modified
     by `gramschmidt'.

     If <x> is a matrix, the algorithm is applied to the rows of <x>.
     If <x> is a list of lists, the algorithm is applied to the
     sublists, which must have equal numbers of elements.  In either
     case, the return value is a list of lists, the sublists of which
     are orthogonal and span the same space as <x>.  If the dimension
     of the span of <x> is less than the number of rows or sublists,
     some sublists of the return value are zero.

     `factor' is called at each stage of the algorithm to simplify
     intermediate results.  As a consequence, the return value may
     contain factored integers.

     `gschmit' (note spelling) is a synonym for `gramschmidt'.

     `load ("eigen")' loads this function.

     Example:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]


 -- Function: hach (<a>, <b>, <m>, <n>, <l>)
     `hach' is an implementation of Hacijan's linear programming
     algorithm.

     `load ("kach")' loads this function.  `demo ("kach")' executes a
     demonstration of this function.


 -- Function: ident (<n>)
     Returns an <n> by <n> identity matrix.


 -- Function: innerproduct (<x>, <y>)
 -- Function: inprod (<x>, <y>)
     Returns the inner product (also called the scalar product or dot
     product) of <x> and <y>, which are lists of equal length, or both
     1-column or 1-row matrices of equal length.  The return value is
     `conjugate (x) . y', where `.' is the noncommutative
     multiplication operator.

     `load ("eigen")' loads this function.

     `inprod' is a synonym for `innerproduct'.


 -- Function: invert (<M>)
     Returns the inverse of the matrix <M>.  The inverse is computed by
     the adjoint method.

     This allows a user to compute the inverse of a matrix with bfloat
     entries or polynomials with floating pt. coefficients without
     converting to cre-form.

     Cofactors are computed by the `determinant' function, so if
     `ratmx' is `false' the inverse is computed without changing the
     representation of the elements.

     The current implementation is inefficient for matrices of high
     order.

     When `detout' is `true', the determinant is factored out of the
     inverse.

     The elements of the inverse are not automatically expanded.  If
     <M> has polynomial elements, better appearing output can be
     generated by `expand (invert (m)), detout'.  If it is desirable to
     then divide through by the determinant this can be accomplished by
     `xthru (%)' or alternatively from scratch by

          expand (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     See `^^' (noncommutative exponent) for another method of inverting
     a matrix.


 -- Option variable: lmxchar
     Default value: `['

     `lmxchar' is the character displayed as the left delimiter of a
     matrix.  See also `rmxchar'.

     Example:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Function: matrix (<row_1>, ..., <row_n>)
     Returns a rectangular matrix which has the rows <row_1>, ...,
     <row_n>.  Each row is a list of expressions.  All rows must be the
     same length.

     The operations `+' (addition), `-' (subtraction), `*'
     (multiplication), and `/' (division), are carried out element by
     element when the operands are two matrices, a scalar and a matrix,
     or a matrix and a scalar.  The operation `^' (exponentiation,
     equivalently `**') is carried out element by element if the
     operands are a scalar and a matrix or a matrix and a scalar, but
     not if the operands are two matrices.  All operations are normally
     carried out in full, including `.' (noncommutative multiplication).

     Matrix multiplication is represented by the noncommutative
     multiplication operator `.'.  The corresponding noncommutative
     exponentiation operator is `^^'.  For a matrix `<A>', `<A>.<A> =
     <A>^^2' and `<A>^^-1' is the inverse of <A>, if it exists.

     There are switches for controlling simplification of expressions
     involving dot and matrix-list operations.  These are `doallmxops',
     `domxexpt' `domxmxops', `doscmxops', and `doscmxplus'.

     There are additional options which are related to matrices. These
     are: `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix', and `sparse'.

     There are a number of functions which take matrices as arguments
     or yield matrices as return values.  See `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon', and `rank'.

     Examples:

        * Construction of matrices from lists.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Addition, element by element.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Subtraction, element by element.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplication, element by element.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * Division, element by element.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matrix to a scalar exponent, element by element.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Scalar base to a matrix exponent, element by element.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Matrix base to a matrix exponent. This is not carried out
          element by element.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Noncommutative matrix multiplication.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Noncommutative matrix exponentiation.  A scalar base <b> to a
          matrix power <M> is carried out element by element and so
          `b^^m' is the same as `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * A matrix raised to a -1 exponent with noncommutative
          exponentiation is the matrix inverse, if it exists.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Function: matrixmap (<f>, <M>)
     Returns a matrix with element `i,j' equal to `<f>(<M>[i,j])'.

     See also `map', `fullmap', `fullmapl', and `apply'.


 -- Function: matrixp (<expr>)
     Returns `true' if <expr> is a matrix, otherwise `false'.


 -- Option variable: matrix_element_add
     Default value: `+'

     `matrix_element_add' is the operation invoked in place of addition
     in a matrix multiplication.  `matrix_element_add' can be assigned
     any n-ary operator (that is, a function which handles any number
     of arguments).  The assigned value may be the name of an operator
     enclosed in quote marks, the name of a function, or a lambda
     expression.

     See also `matrix_element_mult' and `matrix_element_transpose'.

     Example:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Option variable: matrix_element_mult
     Default value: `*'

     `matrix_element_mult' is the operation invoked in place of
     multiplication in a matrix multiplication.  `matrix_element_mult'
     can be assigned any binary operator.  The assigned value may be
     the name of an operator enclosed in quote marks, the name of a
     function, or a lambda expression.

     The dot operator `.' is a useful choice in some contexts.

     See also `matrix_element_add' and `matrix_element_transpose'.

     Example:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Option variable: matrix_element_transpose
     Default value: `false'

     `matrix_element_transpose' is the operation applied to each
     element of a matrix when it is transposed.  `matrix_element_mult'
     can be assigned any unary operator.  The assigned value may be the
     name of an operator enclosed in quote marks, the name of a
     function, or a lambda expression.

     When `matrix_element_transpose' equals `transpose', the
     `transpose' function is applied to every element.  When
     `matrix_element_transpose' equals `nonscalars', the `transpose'
     function is applied to every nonscalar element.  If some element
     is an atom, the `nonscalars' option applies `transpose' only if
     the atom is declared nonscalar, while the `transpose' option
     always applies `transpose'.

     The default value, `false', means no operation is applied.

     See also `matrix_element_add' and `matrix_element_mult'.

     Examples:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Function: mattrace (<M>)
     Returns the trace (that is, the sum of the elements on the main
     diagonal) of the square matrix <M>.

     `mattrace' is called by `ncharpoly', an alternative to Maxima's
     `charpoly'.

     `load ("nchrpl")' loads this function.


 -- Function: minor (<M>, <i>, <j>)
     Returns the <i>, <j> minor of the matrix <M>.  That is, <M> with
     row <i> and column <j> removed.


 -- Function: ncexpt (<a>, <b>)
     If a non-commutative exponential expression is too wide to be
     displayed as `<a>^^<b>' it appears as `ncexpt (<a>,<b>)'.

     `ncexpt' is not the name of a function or operator; the name only
     appears in output, and is not recognized in input.


 -- Function: ncharpoly (<M>, <x>)
     Returns the characteristic polynomial of the matrix <M> with
     respect to <x>.  This is an alternative to Maxima's `charpoly'.

     `ncharpoly' works by computing traces of powers of the given
     matrix, which are known to be equal to sums of powers of the roots
     of the characteristic polynomial.  From these quantities the
     symmetric functions of the roots can be calculated, which are
     nothing more than the coefficients of the characteristic
     polynomial.  `charpoly' works by forming the determinant of `<x> *
     ident [n] - a'.  Thus `ncharpoly' wins, for example, in the case
     of large dense matrices filled with integers, since it avoids
     polynomial arithmetic altogether.

     `load ("nchrpl")' loads this file.


 -- Function: newdet (<M>, <n>)
     Computes the determinant of the matrix or array <M> by the
     Johnson-Gentleman tree minor algorithm.  The argument <n> is the
     order; it is optional if <M> is a matrix.


 -- Declaration: nonscalar
     Makes atoms behave as does a list or matrix with respect to the
     dot operator.


 -- Function: nonscalarp (<expr>)
     Returns `true' if <expr> is a non-scalar, i.e., it contains atoms
     declared as non-scalars, lists, or matrices.


 -- Function: permanent (<M>, <n>)
     Computes the permanent of the matrix <M>.  A permanent is like a
     determinant but with no sign changes.


 -- Function: rank (<M>)
     Computes the rank of the matrix <M>.  That is, the order of the
     largest non-singular subdeterminant of <M>.

     <rank> may return the wrong answer if it cannot determine that a
     matrix element that is equivalent to zero is indeed so.


 -- Option variable: ratmx
     Default value: `false'

     When `ratmx' is `false', determinant and matrix addition,
     subtraction, and multiplication are performed in the
     representation of the matrix elements and cause the result of
     matrix inversion to be left in general representation.

     When `ratmx' is `true', the 4 operations mentioned above are
     performed in CRE form and the result of matrix inverse is in CRE
     form.  Note that this may cause the elements to be expanded
     (depending on the setting of `ratfac') which might not always be
     desired.


 -- Function: row (<M>, <i>)
     Returns the <i>'th row of the matrix <M>.  The return value is a
     matrix.


 -- Option variable: scalarmatrixp
     Default value: `true'

     When `scalarmatrixp' is `true', then whenever a 1 x 1 matrix is
     produced as a result of computing the dot product of matrices it
     is simplified to a scalar, namely the sole element of the matrix.

     When `scalarmatrixp' is `all', then all 1 x 1 matrices are
     simplified to scalars.

     When `scalarmatrixp' is `false', 1 x 1 matrices are not simplified
     to scalars.


 -- Function: scalefactors (<coordinatetransform>)
     Here coordinatetransform evaluates to the form [[expression1,
     expression2, ...], indeterminate1, indeterminat2, ...], where
     indeterminate1, indeterminate2, etc. are the curvilinear
     coordinate variables and where a set of rectangular Cartesian
     components is given in terms of the curvilinear coordinates by
     [expression1, expression2, ...].  `coordinates' is set to the
     vector [indeterminate1, indeterminate2,...], and `dimension' is
     set to the length of this vector.  SF[1], SF[2], ...,
     SF[DIMENSION] are set to the coordinate scale factors, and `sfprod'
     is set to the product of these scale factors.  Initially,
     `coordinates' is [X, Y, Z], `dimension' is 3, and
     SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to 3-dimensional
     rectangular Cartesian coordinates.  To expand an expression into
     physical components in the current coordinate system, there is a
     function with usage of the form


 -- Function: setelmx (<x>, <i>, <j>, <M>)
     Assigns <x> to the (<i>, <j>)'th element of the matrix <M>, and
     returns the altered matrix.

     `<M> [<i>, <j>]: <x>' has the same effect, but returns <x> instead
     of <M>.


 -- Function: similaritytransform (<M>)
 -- Function: simtran (<M>)
     `similaritytransform' computes a similarity transform of the
     matrix `M'.  It returns a list which is the output of the
     `uniteigenvectors' command.  In addition if the flag
     `nondiagonalizable' is `false' two global matrices `leftmatrix'
     and `rightmatrix' are computed.  These matrices have the property
     that `leftmatrix . <M> . rightmatrix' is a diagonal matrix with
     the eigenvalues of <M> on the diagonal.  If `nondiagonalizable' is
     `true' the left and right matrices are not computed.

     If the flag `hermitianmatrix' is `true' then `leftmatrix' is the
     complex conjugate of the transpose of `rightmatrix'.  Otherwise
     `leftmatrix' is the inverse of `rightmatrix'.

     `rightmatrix' is the matrix the columns of which are the unit
     eigenvectors of <M>.  The other flags (see `eigenvalues' and
     `eigenvectors') have the same effects since `similaritytransform'
     calls the other functions in the package in order to be able to
     form `rightmatrix'.

     `load ("eigen")' loads this function.

     `simtran' is a synonym for `similaritytransform'.


 -- Option variable: sparse
     Default value: `false'

     When `sparse' is `true', and if `ratmx' is `true', then
     `determinant' will use special routines for computing sparse
     determinants.


 -- Function: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Function: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Function: submatrix (<M>, <j_1>, ..., <j_n>)
     Returns a new matrix composed of the matrix <M> with rows <i_1>,
     ..., <i_m> deleted, and columns <j_1>, ..., <j_n> deleted.


 -- Function: transpose (<M>)
     Returns the transpose of <M>.

     If <M> is a matrix, the return value is another matrix <N> such
     that `N[i,j] = M[j,i]'.

     Otherwise <M> is a list, and the return value is a matrix <N> of
     `length (m)' rows and 1 column, such that `N[i,1] = M[i]'.


 -- Function: triangularize (<M>)
     Returns the upper triangular form of the matrix `M', as produced
     by Gaussian elimination.  The return value is the same as
     `echelon', except that the leading nonzero coefficient in each row
     is not normalized to 1.

     `lu_factor' and `cholesky' are other functions which yield
     triangularized matrices.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Function: uniteigenvectors (<M>)
 -- Function: ueivects (<M>)
     Computes unit eigenvectors of the matrix <M>.  The return value is
     a list of lists, the first sublist of which is the output of the
     `eigenvalues' command, and the other sublists of which are the
     unit eigenvectors of the matrix corresponding to those eigenvalues
     respectively.

     The flags mentioned in the description of the `eigenvectors'
     command have the same effects in this one as well.

     When `knowneigvects' is `true', the `eigen' package assumes that
     the eigenvectors of the matrix are known to the user and are
     stored under the global name `listeigvects'.  `listeigvects'
     should be set to a list similar to the output of the
     `eigenvectors' command.

     If `knowneigvects' is set to `true' and the list of eigenvectors
     is given the setting of the flag `nondiagonalizable' may not be
     correct.  If that is the case please set it to the correct value.
     The author assumes that the user knows what he is doing and will
     not try to diagonalize a matrix the eigenvectors of which do not
     span the vector space of the appropriate dimension.

     `load ("eigen")' loads this function.

     `ueivects' is a synonym for `uniteigenvectors'.


 -- Function: unitvector (<x>)
 -- Function: uvect (<x>)
     Returns <x>/norm(<x>); this is a unit vector in the same direction
     as <x>.

     `load ("eigen")' loads this function.

     `uvect' is a synonym for `unitvector'.


 -- Function: vectorsimp (<expr>)
     Applies simplifications and expansions according to the following
     global flags:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus', and
     `expandlaplacianprod'.

     All these flags have default value `false'. The `plus' suffix
     refers to employing additivity or distributivity.  The `prod'
     suffix refers to the expansion for an operand that is any kind of
     product.

    `expandcrosscross'
          Simplifies p ~ (q ~ r) to (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifies curl curl p to grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifies laplacian p to div grad p.

    `expandcross'
          Enables `expandcrossplus' and `expandcrosscross'.

    `expandplus'
          Enables `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', and `expandlaplacianplus'.

    `expandprod'
          Enables `expandgradprod', `expanddivprod', and
          `expandlaplacianprod'.

     These flags have all been declared `evflag'.


 -- Option variable: vect_cross
     Default value: `false'

     When `vect_cross' is `true', it allows DIFF(X~Y,T) to work where ~
     is defined in SHARE;VECT (where VECT_CROSS is set to `true',
     anyway.)


 -- Function: zeromatrix (<m>, <n>)
     Returns an <m> by <n> matrix, all elements of which are zero.


 -- Special symbol: "["
 -- Special symbol: "]"
     `[' and `]' mark the beginning and end, respectively, of a list.

     `[' and `]' also enclose the subscripts of a list, array, hash
     array, or array function.

     Examples:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Affine,  Next: itensor,  Prev: Matrices and Linear Algebra,  Up: Top

27 Affine
*********

* Menu:

* Definitions for Affine::


File: maxima.info,  Node: Definitions for Affine,  Prev: Affine,  Up: Affine

27.1 Definitions for Affine
===========================

 -- Function: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Solves the simultaneous linear equations <expr_1>, ..., <expr_m>
     for the variables <x_1>, ..., <x_n>.  Each <expr_i> may be an
     equation or a general expression; if given as a general
     expression, it is treated as an equation of the form `<expr_i> =
     0'.

     The return value is a list of equations of the form `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' where <a_1>, ..., <a_n> are all free
     of <x_1>, ..., <x_n>.

     `fast_linsolve' is faster than `linsolve' for system of equations
     which are sparse.


 -- Function: grobner_basis ([<expr_1>, ..., <expr_m>])
     Returns a Groebner basis for the equations <expr_1>, ..., <expr_m>.
     The function `polysimp' can then be used to simplify other
     functions relative to the equations.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' yields 0 if and only if <f> is in the ideal
     generated by <expr_1>, ..., <expr_m>, that is, if and only if <f>
     is a polynomial combination of the elements of <expr_1>, ...,
     <expr_m>.


 -- Function: set_up_dot_simplifications (<eqns>,
          <check_through_degree>)
 -- Function: set_up_dot_simplifications (<eqns>)
     The <eqns> are polynomial equations in non commutative variables.
     The value of `current_variables' is the list of variables used for
     computing degrees.  The equations must be homogeneous, in order
     for the procedure to terminate.

     If you have checked overlapping simplifications in
     `dot_simplifications' above the degree of <f>, then the following
     is true: `dotsimp (<f>)' yields 0 if and only if <f> is in the
     ideal generated by the equations, i.e., if and only if <f> is a
     polynomial combination of the elements of the equations.

     The degree is that returned by `nc_degree'.   This in turn is
     influenced by the weights of individual variables.


 -- Function: declare_weight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Assigns weights <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectively.  These are the weights used in computing `nc_degree'.


 -- Function: nc_degree (<p>)
     Returns the degree of a noncommutative polynomial <p>.  See
     `declare_weights'.


 -- Function: dotsimp (<f>)
     Returns 0 if and only if <f> is in the ideal generated by the
     equations, i.e., if and only if <f> is a polynomial combination of
     the elements of the equations.


 -- Function: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     If `set_up_dot_simplifications' has been previously done, finds
     the central polynomials in the variables <x_1>, ..., <x_n> in the
     given degree, <n>.

     For example:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];


 -- Function: check_overlaps (<n>, <add_to_simps>)
     Checks the overlaps thru degree <n>, making sure that you have
     sufficient simplification rules in each degree, for `dotsimp' to
     work correctly.  This process can be speeded up if you know before
     hand what the dimension of the space of monomials is.  If it is of
     finite global dimension, then `hilbert' should be used.  If you
     don't know the monomial dimensions, do not specify a
     `rank_function'.  An optional third argument `reset', `false' says
     don't bother to query about resetting things.


 -- Function: mono ([<x_1>, ..., <x_n>], <n>)
     Returns the list of independent monomials relative to the current
     dot simplifications of degree <n> in the variables <x_1>, ...,
     <x_n>.


 -- Function: monomial_dimensions (<n>)
     Compute the Hilbert series through degree <n> for the current
     algebra.


 -- Function: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>,
          ..., <m_n>])
     Makes a list of the coefficients of the noncommutative polynomials
     <p_1>, ..., <p_n> of the noncommutative monomials <m_1>, ...,
     <m_n>.  The coefficients should be scalars.   Use
     `list_nc_monomials' to build the list of monomials.


 -- Function: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Function: list_nc_monomials (<p>)
     Returns a list of the non commutative monomials occurring in a
     polynomial <p> or a list of polynomials <p_1>, ..., <p_n>.


 -- Option variable: all_dotsimp_denoms
     Default value: `false'

     When `all_dotsimp_denoms' is a list, the denominators encountered
     by `dotsimp' are appended to the list.  `all_dotsimp_denoms' may
     be initialized to an empty list `[]' before calling `dotsimp'.

     By default, denominators are not collected by `dotsimp'.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Affine,  Up: Top

28 itensor
**********

* Menu:

* Introduction to itensor::
* Definitions for itensor::

