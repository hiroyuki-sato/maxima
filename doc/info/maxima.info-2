This is maxima.info, produced by makeinfo version 4.6 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definitions for Integration,  Prev: Introduction to Integration,  Up: Integration

Definitions for Integration
===========================

 - Function: CHANGEVAR (exp,f(x,y),y,x)
     makes the change of variable given by f(x,y) = 0 in all integrals
     occurring in exp with integration with respect to x; y is the new
     variable.
              (C1) 'INTEGRATE(%E**SQRT(A*Y),Y,0,4);
                                  4
                                 /
                                 [    SQRT(A) SQRT(Y)
              (D1)               I (%E               ) dY
                                 ]
                                 /
                                  0
              (C2) CHANGEVAR(D1,Y-Z^2/A,Z,Y);
                                             2 SQRT(A)
                                            /
                                            [              Z
                                          2 I          Z %E  dZ
                                            ]
                                            /
                                             0
              (D4)                        ---------------------
                                                    A
     CHANGEVAR may also be used to changes in the indices of a sum or
     product.  However, it must be realized that when a change is made
     in a sum or product, this change must be a shift, i.e. I=J+ ...,
     not a higher degree function.  E.g.
          (C3) SUM(A[I]*X^(I-2),I,0,INF);
                                         INF
                                         ====
                                         \         I - 2
          (D3)                            >    A  X
                                         /      I
                                         ====
                                         I = 0
          (C4) CHANGEVAR(%,I-2-N,N,I);
                                        INF
                                        ====
                                        \               N
          (D4)                           >      A      X
                                        /        N + 2
                                        ====
                                        N = - 2

 - Function: DBLINT ('F,'R,'S,a,b)
     a double-integral routine which was written in top-level macsyma
     and then translated and compiled to machine code.  Use
     LOAD(DBLINT); to access this package.  It uses the Simpson's Rule
     method in both the x and y directions to calculate /B /S(X) |  | |
     |    F(X,Y) DY DX .  |  | /A /R(X) The function F(X,Y) must be a
     translated or compiled function of two variables, and R(X) and
     S(X) must each be a translated or compiled function of one
     variable, while a and b must be floating point numbers. The
     routine has two global variables which determine the number of
     divisions of the x and y intervals: DBLINT_X and DBLINT_Y, both of
     which are initially 10, and can be changed independently to other
     integer values (there are 2*DBLINT_X+1 points computed in the x
     direction, and 2*DBLINT_Y+1 in the y direction).  The routine
     subdivides the X axis and then for each value of X it first
     computes R(X) and S(X); then the Y axis between R(X) and S(X) is
     subdivided and the integral along the Y axis is performed using
     Simpson's Rule; then the integral along the X axis is done using
     Simpson's Rule with the function values being the Y-integrals. This
     procedure may be numerically unstable for a great variety of
     reasons, but is reasonably fast: avoid using it on highly
     oscillatory functions and functions with singularities (poles or
     branch points in the region).  The Y integrals depend on how far
     apart R(X) and S(X) are, so if the distance S(X)-R(X) varies
     rapidly with X, there may be substantial errors arising from
     truncation with different step-sizes in the various Y integrals.
     One can increase DBLINT_X and DBLINT_Y in an effort to improve the
     coverage of the region, at the expense of computation time. The
     function values are not saved, so if the function is very
     time-consuming, you will have to wait for re-computation if you
     change anything (sorry).  It is required that the functions F, R,
     and S be either translated or compiled prior to calling DBLINT.
     This will result in orders of magnitude speed improvement over
     interpreted code in many cases!  The file SHARE1;DBLINT DEMO can
     be run in batch or demo mode to illustrate the usage on a sample
     problem; the file SHARE1;DBLNT DEMO1 is an extension of the DEMO
     which also makes use of other numerical aids, FLOATDEFUNK and
     QUANC8.  Please send all bug notes and questions to LPH


 - Function: DEFINT (exp, var, low, high)
     DEFinite INTegration, the same as INTEGRATE(exp,var,low,high).
     This uses symbolic methods, if you wish to use a numerical method
     try ROMBERG(exp,var,low,high).


 - Function: ERF (X)
     the error function, whose derivative is: 2*EXP(-X^2)/SQRT(%PI).


 - Variable: ERFFLAG
     default: [TRUE] if FALSE prevents RISCH from introducing the ERF
     function in the answer if there were none in the integrand to
     begin with.


 - Variable: ERRINTSCE
     default: [TRUE] - If a call to the INTSCE routine is not of the
     form

          EXP(A*X+B)*COS(C*X)^N*SIN(C*X)

     then the regular integration program will be invoked if the switch
     ERRINTSCE[TRUE] is TRUE.  If it is FALSE then INTSCE will err out.


 - Function: ILT (exp, lvar, ovar)
     takes the inverse Laplace transform of exp with respect to lvar
     and parameter ovar.  exp must be a ratio of polynomials whose
     denominator has only linear and quadratic factors.  By using the
     functions LAPLACE and ILT together with the SOLVE or LINSOLVE
     functions the user can solve a single differential or convolution
     integral equation or a set of them.
          (C1) 'INTEGRATE(SINH(A*X)*F(T-X),X,0,T)+B*F(T)=T**2;
                        T
                       /
                       [                                     2
          (D1)         I (SINH(A X) F(T - X)) dX + B F(T) = T
                       ]
                       /
                       0
          (C2) LAPLACE(%,T,S);
                      A LAPLACE(F(T), T, S)
          (D2)        ---------------------
                              2    2
                             S  - A
                                                    2
                          + B LAPLACE(F(T), T, S) = --
                                                     3
                                                    S
          (C3) LINSOLVE([%],['LAPLACE(F(T),T,S)]);
          SOLUTION
                                                  2      2
                                               2 S  - 2 A
          (E3)       LAPLACE(F(T), T, S) = --------------------
                                              5         2     3
                                           B S  + (A - A  B) S
          (D3)                         [E3]
          (C4) ILT(E3,S,T);
          IS  A B (A B - 1)  POSITIVE, NEGATIVE, OR ZERO?
          POS;
                                                 2
                                 SQRT(A) SQRT(A B  - B) T
                          2 COSH(------------------------)
                                            B
          (D4)  F(T) =  - --------------------------------
                                         A
                        2
                     A T             2
                  + ------- + ------------------
                    A B - 1    3  2      2
                              A  B  - 2 A  B + A

 - Function: INTEGRATE (exp, var)
     integrates exp with respect to var or returns an integral
     expression (the noun form) if it cannot perform the integration
     (see note 1 below).  Roughly speaking three stages are used:
        *     (1) INTEGRATE sees if the integrand is of the form
          F(G(X))*DIFF(G(X),X) by testing whether the derivative of some
          subexpression (i.e. G(X) in the above case) divides the
          integrand.  If so it looks up F in a table of integrals and
          substitutes G(X) for X in the integral of F.  This may make
          use of gradients in taking the derivative.  (If an unknown
          function appears in the integrand it must be eliminated in
          this stage or else INTEGRATE will return the noun form of the
          integrand.)

        *     (2) INTEGRATE tries to match the integrand to a form for
          which a specific method can be used, e.g.  trigonometric
          substitutions.

        *     (3) If the first two stages fail it uses the Risch
          algorithm.      Functional relationships must be explicitly
          represented in order for INTEGRATE to work properly.
          INTEGRATE is not affected by DEPENDENCIES set up with the
          DEPENDS command.  INTEGRATE(exp, var, low, high) finds the
          definite integral of exp with respect to var from low to high
          or returns the noun form if it cannot perform the
          integration.  The limits should not contain var.  Several
          methods are used, including direct substitution in the
          indefinite integral and contour integration.  Improper
          integrals may use the names INF for positive infinity and
          MINF for negative infinity.  If an integral "form" is desired
          for manipulation (for example, an integral which cannot be
          computed until some numbers are substituted for some
          parameters), the noun form 'INTEGRATE may be used and this
          will display with an integral sign.  (See Note 1 below.)
          The function LDEFINT uses LIMIT to evaluate the integral at
          the lower and upper limits.      Sometimes during integration
          the user may be asked what the sign of an expression is.
          Suitable responses are POS;, ZERO;, or NEG;.

          (C1) INTEGRATE(SIN(X)**3,X);
                              3
                           COS (X)
          (D1)             ------- - COS(X)
                              3
          (C2) INTEGRATE(X**A/(X+1)**(5/2),X,0,INF);
          IS  A + 1  POSITIVE, NEGATIVE, OR ZERO?
          POS;
          IS  2 A - 3  POSITIVE, NEGATIVE, OR ZERO?
          NEG;
                                      3
          (D2)            BETA(A + 1, - - A)
                                      2
          (C3) GRADEF(Q(X),SIN(X**2));
          (D3)                              Q(X)
          (C4) DIFF(LOG(Q(R(X))),X);
                                     d             2
                                    (-- R(X)) SIN(R (X))
                                     dX
          (D4)                      --------------------
                                          Q(R(X))
          (C5) INTEGRATE(%,X);
          (D5)                          LOG(Q(R(X)))
     (Note 1) The fact that MACSYMA does not perform certain integrals
     does not always imply that the integral does not exist in closed
     form. In the example below the integration call returns the noun
     form but the integral can be found fairly easily. For example, one
     can compute the roots of `X^3+X+1 = 0' to rewrite the integrand in
     the form
          1/((X-A)*(X-B)*(X-C))
     where A, B and C are the roots. MACSYMA will integrate this
     equivalent form although the integral is quite complicated.
          (C6) INTEGRATE(1/(X^3+X+1),X);
                                    /
                                    [     1
          (D6)                      I ---------- dX
                                    ]  3
                                    / X  + X + 1

 - Variable: INTEGRATION_CONSTANT_COUNTER
     - a counter which is updated each time a constant of integration
     (called by MACSYMA, e.g., "INTEGRATIONCONSTANT1") is introduced
     into an expression by indefinite integration of an equation.


 - Variable: INTEGRATE_USE_ROOTSOF
     default: [false] If not false then when the denominator of an
     rational function cannot be factored, we give the integral in a
     form which is a sum over the roots of the denominator:

          (C4) integrate(1/(1+x+x^5),x);
          
                /	 2
                [ x  - 4 x + 5
                I ------------ dx				   2 x + 1
                ]	 3    2		       2	    5 ATAN(-------)
                / x  - x  + 1	  LOG(x  + x + 1)	   SQRT(3)
          (D4)  ----------------- - --------------- + ---------------
          	      7		        14	       7 SQRT(3)
     but now we set the flag to be true and the first part of the
     integral will undergo further simplification.
          (C5) INTEGRATE_USE_ROOTSOF:true;
          
          (D5) 			      TRUE

          (C6) integrate(1/(1+x+x^5),x);
          
               ====        2
               \       (%R1  - 4 %R1 + 5) LOG(x - %R1)
                >      -------------------------------
               /                    2
               ====            3 %R1  - 2 %R1
                               3    2
               %R1 in ROOTSOF(x  - x  + 1)
          (D6) ----------------------------------------------------------
                        7
          
                                                                   2 x + 1
                                               2            5 ATAN(-------)
                                          LOG(x  + x + 1)          SQRT(3)
                                        - --------------- + ---------------
                                                14             7 SQRT(3)

     Note that it may be that we want to approximate the roots in the
     complex plane, and then provide the function factored, since we
     will then be able to group the roots and their complex conjugates,
     so as to give a better answer.


 - Function: INTSCE (expr,var)
     INTSCE LISP contains a routine, written by Richard Bogen, for
     integrating products of sines,cosines and exponentials of the form
            EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M
     The call is INTSCE(expr,var) expr may be any expression, but if it
     is not in the above form then the regular integration program will
     be invoked if the switch ERRINTSCE[TRUE] is TRUE.  If it is FALSE
     then INTSCE will err out.


 - Function: LDEFINT (exp,var,ll,ul)
     yields the definite integral of exp by using LIMIT to evaluate the
     indefinite integral of exp with respect to var at the upper limit
     ul and at the lower limit ll.


 - Function: POTENTIAL (givengradient)
     The calculation makes use of the global variable
          POTENTIALZEROLOC[0]
      which must be NONLIST or of the form

          [indeterminatej=expressionj, indeterminatek=expressionk, ...]
     the former being equivalent to the nonlist expression for all
     right-hand sides in the latter.  The indicated right-hand sides
     are used as the lower limit of integration.  The success of the
     integrations may depend upon their values and order.
     POTENTIALZEROLOC is initially set to 0.


 - Function: QQ
     - The file SHARE1;QQ FASL (which may be loaded with LOAD("QQ");)
     contains a function QUANC8 which can take either 3 or 4 arguments.
     The 3 arg version computes the integral of the function specified
     as the first argument over the interval from lo to hi as in
     QUANC8('function name,lo,hi); .  The function name should be
     quoted.  The 4 arg version will compute the integral of the
     function or expression (first arg) with respect to the variable
     (second arg) over the interval from lo to hi as in QUANC8(<f(x) or
     expression in x>,x,lo,hi).  The method used is the Newton-Cotes
     8th order polynomial quadrature, and the routine is adaptive. It
     will thus spend time dividing the interval only when necessary to
     achieve the error conditions specified by the global variables
     QUANC8_RELERR (default value=1.0e-4) and QUANC8_ABSERR (default
     value=1.0e-8) which give the relative error test:
     |integral(function)-computed value|<
     quanc8_relerr*|integral(function)| and the absolute error test:
     |integral(function)-computed value|<quanc8_abserr.  Do
     PRINTFILE(QQ,USAGE,SHARE1) for details.


 - Function: QUANC8 ('function name,lo,hi)
     An adaptive integrator, available in SHARE1;QQ FASL.  DEMO and
     USAGE files are provided.  The method is to use Newton-Cotes
     8-panel quadrature rule, hence the function name QUANC8, available
     in 3 or 4 arg versions.  Absolute and relative error checks are
     used.  To use it do LOAD("QQ");  For more details do DESCRIBE(QQ);
     .


 - Function: RESIDUE (exp, var, val)
     computes the residue in the complex plane of the expression exp
     when the variable var assumes the value val.  The residue is the
     coefficient of (var-val)**(-1) in the Laurent series for exp.
          (C1) RESIDUE(S/(S**2+A**2),S,A*%I);
                                  1
          (D1)                    -
                                  2
          (C2) RESIDUE(SIN(A*X)/X**4,X,0);
                                  3
                                 A
          (D2)                 - --
                                 6

 - Function: RISCH (exp, var)
     integrates exp with respect to var using the transcendental case
     of the Risch algorithm.  (The algebraic case of the Risch
     algorithm has not been implemented.)  This currently handles the
     cases of nested exponentials and logarithms which the main part of
     INTEGRATE can't do.  INTEGRATE will automatically apply RISCH if
     given these cases.  ERFFLAG[TRUE] - if FALSE prevents RISCH from
     introducing the ERF function in the answer if there were none in
     the integrand to begin with.
          (C1) RISCH(X^2*ERF(X),X);
                      2     2
                   - X     X             3           2
                 %E     (%E   SQRT(%PI) X  ERF(X) + X  + 1)
          (D1)   ------------------------------------------
                                3 SQRT(%PI)
          (C2) DIFF(%,X),RATSIMP;
                                           2
          (D2)                            X  ERF(X)

 - Function: ROMBERG (exp,var,ll,ul)
     or ROMBERG(exp,ll,ul) - Romberg Integration.  You need not load in
     any file to use ROMBERG, it is autoloading.  There are two ways to
     use this function.  The first is an inefficient way like the
     definite integral version of INTEGRATE:
     ROMBERG(<integrand>,<variable of integration>,<lower limit>,
              <upper limit>);
          Examples:
                  ROMBERG(SIN(Y),Y,1,%PI);
                          TIME= 39 MSEC.          1.5403023
                  F(X):=1/(X^5+X+1);
                  ROMBERG(F(X),X,1.5,0);
                          TIME= 162 MSEC.         - 0.75293843
     The second is an efficient way that is used as follows:

          ROMBERG(<function name>,<lower limit>,<upper limit>);

          Example:
          F(X):=(MODE_DECLARE([FUNCTION(F),X],FLOAT),1/(X^5+X+1));
          TRANSLATE(F);
          ROMBERG(F,1.5,0);
                  TIME= 13 MSEC.          - 0.75293843
     The first argument must be a TRANSLATEd or compiled function.  (If
     it is compiled it must be declared to return a FLONUM.)  If the
     first argument is not already TRANSLATEd, ROMBERG will not attempt
     to TRANSLATE it but will give an error.  The accuracy of the
     integration is governed by the global variables ROMBERGTOL
     (default value 1.E-4) and ROMBERGIT (default value 11).  ROMBERG
     will return a result if the relative difference in successive
     approximations is less than ROMBERGTOL.  It will try halving the
     stepsize ROMBERGIT times before it gives up.  The number of
     iterations and function evaluations which ROMBERG will do is
     governed by ROMBERGABS and ROMBERGMIN, do
     DESCRIBE(ROMBERGABS,ROMBERGMIN); for details.  ROMBERG may be
     called recursively and thus can do double and triple integrals.
          Example:
          INTEGRATE(INTEGRATE(X*Y/(X+Y),Y,0,X/2),X,1,3);
                                  13/3 (2 LOG(2/3) + 1)
          %,NUMER;
                                  0.81930233
          DEFINE_VARIABLE(X,0.0,FLOAT,"Global variable in function F")$
          F(Y):=(MODE_DECLARE(Y,FLOAT), X*Y/(X+Y) )$
          G(X):=ROMBERG('F,0,X/2)$
          ROMBERG(G,1,3);
                                   0.8193023
     The advantage with this way is that the function F can be used for
     other purposes, like plotting. The disadvantage is that you have
     to think up a name for both the function F and its free variable X.
     Or, without the global:
                  G1(X):=(MODE_DECLARE(X,FLOAT), ROMBERG(X*Y/(X+Y),Y,0,X/2))$
                  ROMBERG(G1,1,3);
                                          0.8193023
     The advantage here is shortness.
                  Q(A,B):=ROMBERG(ROMBERG(X*Y/(X+Y),Y,0,X/2),X,A,B)$
                  Q(1,3);
                                          0.8193023
     It is even shorter this way, and the variables do not need to be
     declared because they are in the context of ROMBERG.  Use of
     ROMBERG for multiple integrals can have great disadvantages,
     though.  The amount of extra calculation needed because of the
     geometric information thrown away by expressing multiple integrals
     this way can be incredible.  The user should be sure to understand
     and use the ROMBERGTOL and ROMBERGIT switches.


 - Variable: ROMBERGABS
     default: [0.0] (0.0B0) Assuming that successive estimates produced
     by ROMBERG are Y[0], Y[1], Y[2] etc., then ROMBERG will return
     after N iterations if (roughly speaking)  (ABS(Y[N]-Y[N-1]) <=
     ROMBERGABS OR  ABS(Y[N]-Y[N-1])/(IF Y[N]=0.0 THEN 1.0 ELSE Y[N])
     <= ROMBERGTOL) is TRUE.  (The condition on the number of
     iterations given by ROMBERGMIN must also be satisfied.)  Thus if
     ROMBERGABS is 0.0 (the default) you just get the relative error
     test.  The usefulness of the additional variable comes when you
     want to perform an integral, where the dominant contribution comes
     from a small region.  Then you can do the integral over the small
     dominant region first, using the relative accuracy check, followed
     by the integral over the rest of the region using the absolute
     accuracy check.  Example:  Suppose you want to compute
             Integral(exp(-x),x,0,50)
     (numerically) with a relative accuracy of  1 part in 10000000.
     Define the function.  N is a counter, so we can see how many
     function evaluations were needed.
          F(X):=(MODE_DECLARE(N,INTEGER,X,FLOAT),N:N+1,EXP(-X))$
          TRANSLATE(F)$
            /* First of all try doing the whole integral at once */
          BLOCK([ROMBERGTOL:1.E-6,ROMBERABS:0.],N:0,ROMBERG(F,0,50));
                        ==> 1.00000003
          N; ==> 257  /* Number of function evaluations*/

     Now do the integral intelligently, by first doing
     Integral(exp(-x),x,0,10) and then setting ROMBERGABS to 1.E-6*(this
         partial integral).
          BLOCK([ROMBERGTOL:1.E-6,ROMBERGABS:0.,SUM:0.],
            N:0,SUM:ROMBERG(F,0,10),ROMBERGABS:SUM*ROMBERGTOL,ROMBERGTOL:0.,
                SUM+ROMBERG(F,10,50));  ==> 1.00000001  /* Same as before */
          N;  ==> 130
     So if F(X) were a function that took a long time to compute, the
     second method would be about 2 times quicker.


 - Variable: ROMBERGIT
     default: [11] - The accuracy of the ROMBERG integration command is
     governed by the global variables ROMBERGTOL[1.E-4] and
     ROMBERGIT[11].  ROMBERG will return a result if the relative
     difference in successive approximations is less than ROMBERGTOL.
     It will try halving the stepsize ROMBERGIT times before it gives
     up.


 - Variable: ROMBERGMIN
     default: [0] - governs the minimum number of function evaluations
     that ROMBERG will make.  ROMBERG will evaluate its first arg. at
     least 2^(ROMBERGMIN+2)+1 times.  This is useful for integrating
     oscillatory functions, when the normal converge test might
     sometimes wrongly pass.


 - Variable: ROMBERGTOL
     default: [1.E-4] - The accuracy of the ROMBERG integration command
     is governed by the global variables ROMBERGTOL[1.E-4] and
     ROMBERGIT[11].  ROMBERG will return a result if the relative
     difference in successive approximations is less than ROMBERGTOL.
     It will try halving the stepsize ROMBERGIT times before it gives
     up.


 - Function: TLDEFINT (exp,var,ll,ul)
     is just LDEFINT with TLIMSWITCH set to TRUE.



File: maxima.info,  Node: Equations,  Next: Differential Equations,  Prev: Integration,  Up: Top

Equations
*********

* Menu:

* Definitions for Equations::


File: maxima.info,  Node: Definitions for Equations,  Prev: Equations,  Up: Equations

Definitions for Equations
=========================

 - Variable: %RNUM_LIST
     default: [] - When %R variables are introduced in solutions by the
     ALGSYS command, they are added to %RNUM_LIST in the order they are
     created.  This is convenient for doing substitutions into the
     solution later on.  It's recommended to use this list rather than
     doing CONCAT('%R,J).

 - Variable: ALGEXACT
     default: [FALSE] affects the behavior of ALGSYS as follows: If
     ALGEXACT is TRUE, ALGSYS always calls SOLVE and then uses REALROOTS
     on SOLVE's failures.  If ALGEXACT is FALSE, SOLVE is called only if
     the eliminant was not univariate, or if it was a quadratic or
     biquadratic.  Thus ALGEXACT:TRUE doesn't guarantee only exact
     solutions, just that ALGSYS will first try as hard as it can to
     give exact solutions, and only yield approximations when all else
     fails.

 - Function: ALGSYS ([exp1, exp2, ...], [var1, var2, ...])
     solves the list of simultaneous polynomials or polynomial
     equations (which can be non-linear) for the list of variables.
     The symbols %R1, %R2, etc.  will be used to represent arbitrary
     parameters when needed for the solution (the variable %RNUM_LIST
     holds these).  In the process described below, ALGSYS is entered
     recursively if necessary.      The method is as follows: (1) First
     the equations are FACTORed and split into subsystems.  (2) For
     each subsystem Si, an equation E and a variable var are selected
     (the var is chosen to have lowest nonzero degree).  Then the
     resultant of E and Ej with respect to var is computed for each of
     the remaining equations Ej in the subsystem Si.  This yields a new
     subsystem S'i in one fewer variables (var has been eliminated).
     The process now returns to (1).  (3) Eventually, a subsystem
     consisting of a single equation is obtained.  If the equation is
     multivariate and no approximations in the form of floating point
     numbers have been introduced, then SOLVE is called to find an
     exact solution.  (The user should realize that SOLVE may not be
     able to produce a solution or if it does the solution may be a
     very large expression.)      If the equation is univariate and is
     either linear, quadratic, or bi-quadratic, then again SOLVE is
     called if no approximations have been introduced.  If
     approximations have been introduced or the equation is not
     univariate and neither linear, quadratic, or bi-quadratic, then if
     the switch REALONLY[FALSE] is TRUE, the function REALROOTS is
     called to find the real-valued solutions.  If REALONLY:FALSE then
     ALLROOTS is called which looks for real and complex-valued
     solutions.  If ALGSYS produces a solution which has fewer
     significant digits than required, the user can change the value of
     ALGEPSILON[10^8] to a higher value.  If ALGEXACT[FALSE] is set to
     TRUE, SOLVE will always be called.  (4) Finally, the solutions
     obtained in step (3) are re-inserted into previous levels and the
     solution process returns to (1).  The user should be aware of
     several caveats:     When ALGSYS encounters a multivariate
     equation which contains floating point approximations (usually due
     to its failing to find exact solutions at an earlier stage), then
     it does not attempt to apply exact methods to such equations and
     instead prints the message:         "ALGSYS cannot solve - system
     too complicated."      Interactions with RADCAN can produce large
     or complicated expressions.  In that case, the user may use
     PICKAPART or REVEAL to analyze the solution.  Occasionally, RADCAN
     may introduce an apparent %I into a solution which is actually
     real-valued.  Do EXAMPLE(ALGSYS); for examples.


 - Function: ALLROOTS (poly)
     finds all the real and complex roots of the real polynomial poly
     which must be univariate and may be an equation, e.g.  poly=0.
     For complex polynomials an algorithm by Jenkins and Traub is used
     (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  For real
     polynomials the algorithm used is due to Jenkins (Algorithm 493,
     TOMS, vol. 1, (1975), p.178).  The flag POLYFACTOR[FALSE] when
     true causes ALLROOTS to factor the polynomial over the real
     numbers if the polynomial is real, or over the complex numbers, if
     the polynomial is complex.  ALLROOTS may give inaccurate results
     in case of multiple roots.  (If poly is real and you get
     inaccurate answers, you may want to try ALLROOTS(%I*poly);) Do
     EXAMPLE(ALLROOTS); for an example.  ALLROOTS rejects
     non-polynomials.  It requires that the numerator after RATting
     should be a polynomial, and it requires that the denominator be at
     most a complex number.  As a result of this ALLROOTS will always
     return an equivalent (but factored) expression, if POLYFACTOR is
     TRUE.


 - Variable: BACKSUBST
     default: [TRUE] if set to FALSE will prevent back substitution
     after the equations have been triangularized.  This may be
     necessary in very big problems where back substitution would cause
     the generation of extremely large expressions.  (On MC this could
     cause storage capacity to be exceeded.)


 - Variable: BREAKUP
     default: [TRUE] if FALSE will cause SOLVE to express the solutions
     of cubic or quartic equations as single expressions rather than as
     made up of several common subexpressions which is the default.
     BREAKUP:TRUE only works when PROGRAMMODE is FALSE.


 - Function: DIMENSION (equation or list of equations)
     The file "share1/dimen.mc" contains functions for automatic
     dimensional analysis.  LOAD(DIMEN); will load it up for you.
     There is a demonstration available in share1/dimen.dem.  Do
     DEMO("dimen"); to run it.


 - Variable: DISPFLAG
     default: [TRUE] if set to FALSE within a BLOCK will inhibit the
     display of output generated by the solve functions called from
     within  the BLOCK.  Termination of the BLOCK with a dollar sign,
     $, sets DISPFLAG to FALSE.


 - Function: FUNCSOLVE (eqn,g(t))
     gives [g(t) = ...]  or [], depending on whether or not there
     exists a rational fcn g(t) satisfying eqn, which must be a first
     order, linear polynomial in (for this case) g(t) and g(t+1).
          (C1) FUNCSOLVE((N+1)*FOO(N)-(N+3)*FOO(N+1)/(N+1) =
              (N-1)/(N+2),FOO(N));
                                             N
          (D1)               FOO(N) = ---------------
                                      (N + 1) (N + 2)
     Warning: this is a very rudimentary implementation-many safety
     checks and obvious generalizations are missing.


 - Variable: GLOBALSOLVE
     default: [FALSE] if set to TRUE then variables which are SOLVEd
     for will be set to the solution of the set of simultaneous
     equations.


 - Function: IEQN (ie,unk,tech,n,guess)
     Integral Equation solving routine.  Do LOAD(INTEQN); to access it.
     CAVEAT: To free some storage, a KILL(LABELS) is included in this
     file.  Therefore, before loading the integral equation package,
     the user should give names to any expressions he wants to keep.
     ie is the integral equation; unk is the unknown function; tech is
     the technique to be tried from those given above (tech = FIRST
     means: try the first technique which finds a solution; tech = ALL
     means: try all applicable techniques); n is the maximum number of
     terms to take for TAYLOR, NEUMANN, FIRSTKINDSERIES, or FREDSERIES
     (it is also the maximum depth of recursion for the differentiation
     method); guess is the initial guess for NEUMANN or FIRSTKINDSERIES.
     Default values for the 2nd thru 5th parameters are: unk: P(X),
     where P is the first function encountered in an integrand which is
     unknown to MACSYMA and X is the variable which occurs as an
     argument to the first occurrence of P found outside of an integral
     in the case of SECONDKIND equations, or is the only other variable
     besides the variable of integration in FIRSTKIND equations.  If the
     attempt to search for X fails, the user will be asked to supply the
     independent variable; tech: FIRST; n: 1; guess: NONE, which will
     cause NEUMANN and FIRSTKINDSERIES to use F(X) as an initial guess.


 - Variable: IEQNPRINT
     default: [TRUE] - governs the behavior of the result returned by
     the IEQN command (which see).  If IEQNPRINT is set to FALSE, the
     lists returned by the IEQN function are of the form    [SOLUTION,
     TECHNIQUE USED, NTERMS, FLAG] where FLAG is absent if the solution
     is exact.  Otherwise, it is the word APPROXIMATE or INCOMPLETE
     corresponding to an inexact or non-closed form solution,
     respectively. If a series method was used, NTERMS gives the number
     of terms taken (which could be less than the n given to IEQN if an
     error prevented generation of further terms).


 - Function: LHS (eqn)
     the left side of the equation eqn.


 - Function: LINSOLVE ([exp1, exp2, ...], [var1, var2, ...])
     solves the list of simultaneous linear equations for the list of
     variables.  The expi must each be polynomials in the variables and
     may be equations.  If GLOBALSOLVE[FALSE] is set to TRUE then
     variables which are SOLVEd for will be set to the solution of the
     set of simultaneous equations.  BACKSUBST[TRUE] if set to FALSE
     will prevent back substitution after the equations have been
     triangularized.  This may be necessary in very big problems where
     back substitution would cause the generation of extremely large
     expressions.  (On MC this could cause the storage capacity to be
     exceeded.)  LINSOLVE_PARAMS[TRUE] If TRUE, LINSOLVE also generates
     the %Ri symbols used to represent arbitrary parameters described
     in the manual under ALGSYS.  If FALSE, LINSOLVE behaves as before,
     i.e. when it meets up with an under-determined system of
     equations, it solves for some of the variables in terms of others.
          (C1) X+Z=Y$
          (C2) 2*A*X-Y=2*A**2$
          (C3) Y-2*Z=2$
          (C4) LINSOLVE([D1,D2,D3],[X,Y,Z]),GLOBALSOLVE:TRUE;
          SOLUTION
          (E4)                            X : A + 1
          (E5)                             Y : 2 A
          (E6)                            Z : A - 1
          (D6)                          [E4, E5, E6]

 - Variable: LINSOLVEWARN
     default: [TRUE] - if FALSE will cause the message "Dependent
     equations eliminated" to be suppressed.


 - Variable: LINSOLVE_PARAMS
     default: [TRUE] - If TRUE, LINSOLVE also generates the %Ri symbols
     used to represent arbitrary parameters described in the manual
     under ALGSYS.  If FALSE, LINSOLVE behaves as before, i.e.  when it
     meets up with an under-determined system of equations, it solves
     for some of the variables in terms of others.


 - Variable: MULTIPLICITIES
     default: [NOT_SET_YET] - will be set to a list of the
     multiplicities of the individual solutions returned by SOLVE or
     REALROOTS.


 - Function: NROOTS (poly, low, high)
     finds the number of real roots of the real univariate polynomial
     poly in the half-open interval (low,high].  The endpoints of the
     interval may also be MINF,INF respectively for minus infinity and
     plus infinity.  The method of Sturm sequences is used.
          (C1) POLY1:X**10-2*X**4+1/2$
          (C2) NROOTS(POLY1,-6,9.1);
          RAT REPLACED 0.5 BY 1/2 = 0.5
          (D2)                               4

 - Function: NTHROOT (p,n)
     where p is a polynomial with integer coefficients and n is a
     positive integer returns q, a polynomial over the integers, such
     that q^n=p or prints an error message indicating that p is not a
     perfect nth power. This routine is much faster than FACTOR or even
     SQFR.


 - Variable: PROGRAMMODE
     default: [TRUE] - when FALSE will cause SOLVE, REALROOTS,
     ALLROOTS, and LINSOLVE to print E-labels (intermediate line
     labels) to label answers.  When TRUE, SOLVE, etc. return answers
     as elements in a list.  (Except when BACKSUBST is set to FALSE, in
     which case PROGRAMMODE:FALSE is also used.)


 - Variable: REALONLY
     default: [FALSE] - if TRUE causes ALGSYS to return only those
     solutions which are free of %I.


 - Function: REALROOTS (poly, bound)
     finds all of the real roots of the real univariate polynomial poly
     within a tolerance of bound which, if less than 1, causes all
     integral roots to be found exactly.  The parameter bound may be
     arbitrarily small in order to achieve any desired accuracy.  The
     first argument may also be an equation.  REALROOTS sets
     MULTIPLICITIES, useful in case of multiple roots.  REALROOTS(poly)
     is equivalent to REALROOTS(poly,ROOTSEPSILON).
     ROOTSEPSILON[1.0E-7] is a real number used to establish the
     confidence interval for the roots.  Do EXAMPLE(REALROOTS); for an
     example.


 - Function: RHS (eqn)
     the right side of the equation eqn.


 - Variable: ROOTSCONMODE
     default: [TRUE] - Determines the behavior of the ROOTSCONTRACT
     command.  Do DESCRIBE(ROOTSCONTRACT); for details.


 - Function: ROOTSCONTRACT (exp)
     converts products of roots into roots of products.  For example,
          ROOTSCONTRACT(SQRT(X)*Y^(3/2)) ==> SQRT(X*Y^3)
     When RADEXPAND is TRUE and DOMAIN is REAL (their defaults),
     ROOTSCONTRACT converts ABS into SQRT, e.g.

          ROOTSCONTRACT(ABS(X)*SQRT(Y)) ==> SQRT(X^2*Y)

     There is an option ROOTSCONMODE (default value TRUE), affecting
     ROOTSCONTRACT as follows:



          Problem            Value of        Result of applying
                            ROOTSCONMODE        ROOTSCONTRACT
          
          X^(1/2)*Y^(3/2)      FALSE          (X*Y^3)^(1/2)
          X^(1/2)*Y^(1/4)      FALSE          X^(1/2)*Y^(1/4)
          X^(1/2)*Y^(1/4)      TRUE           (X*Y^(1/2))^(1/2)
          X^(1/2)*Y^(1/3)      TRUE           X^(1/2)*Y^(1/3)
          X^(1/2)*Y^(1/4)      ALL            (X^2*Y)^(1/4)
          X^(1/2)*Y^(1/3)      ALL            (X^3*Y^2)^(1/6)

     The above examples and more may be tried out by typing

          EXAMPLE(ROOTSCONTRACT);

     When ROOTSCONMODE is FALSE, ROOTSCONTRACT contracts only wrt
     rational number exponents whose denominators are the same.  The
     key to the ROOTSCONMODE:TRUE$ examples is simply that 2 divides
     into 4 but not into 3.  ROOTSCONMODE:ALL$ involves taking the lcm
     (least common multiple) of the denominators of the exponents.
     ROOTSCONTRACT uses RATSIMP in a manner similar to LOGCONTRACT (see
     the manual).


 - Variable: ROOTSEPSILON
     default: [1.0E-7] - a real number used to establish the confidence
     interval for the roots found by the REALROOTS function.


 - Function: SOLVE (exp, var)
     solves the algebraic equation exp for the variable var and returns
     a list of solution equations in var.  If exp is not an equation,
     it is assumed to be an expression to be set equal to zero.  Var
     may be a function (e.g. F(X)), or other non-atomic expression
     except a sum or product. It may be omitted if exp contains only one
     variable.  Exp may be a rational expression, and may contain
     trigonometric functions, exponentials, etc.  The following method
     is used: Let E be the expression and X be the variable.  If E is
     linear in X then it is trivially solved for X.  Otherwise if E is
     of the form A*X**N+B then the result is (-B/A)**(1/N) times the
     Nth roots of unity.  If E is not linear in X then the gcd of the
     exponents of X in E (say N) is divided into the exponents and the
     multiplicity of the roots is multiplied by N.  Then SOLVE is
     called again on the result.  If E factors then SOLVE is called on
     each of the factors.  Finally SOLVE will use the quadratic, cubic,
     or quartic formulas where necessary.  In the case where E is a
     polynomial in some function of the variable to be solved for, say
     F(X), then it is first solved for F(X) (call the result C), then
     the equation F(X)=C can be solved for X provided the inverse of
     the function F is known.  BREAKUP[TRUE] if FALSE will cause SOLVE
     to express the solutions of cubic or quartic equations as single
     expressions rather than as made up of several common
     subexpressions which is the default.  MULTIPLICITIES[NOT_SET_YET]
     - will be set to a list of the multiplicities of the individual
     solutions returned by SOLVE, REALROOTS, or ALLROOTS.  Try
     APROPOS(SOLVE) for the switches which affect SOLVE.  DESCRIBE may
     then by used on the individual switch names if their purpose is not
     clear.  SOLVE([eq1, ..., eqn], [v1, ..., vn]) solves a system of
     simultaneous (linear or non-linear) polynomial equations by
     calling LINSOLVE or ALGSYS and returns a list of the solution
     lists in the variables.  In the case of LINSOLVE this list would
     contain a single list of solutions.  It takes two lists as
     arguments.  The first list (eqi, i=1,...,n) represents the
     equations to be solved; the second list is a list of the unknowns
     to be determined.  If the total number of variables in the
     equations is equal to the number of equations, the second
     argument-list may be omitted.  For linear systems if the given
     equations are not compatible, the message INCONSISTENT will be
     displayed (see the SOLVE_INCONSISTENT_ERROR switch); if no unique
     solution exists, then SINGULAR will be displayed.  For examples, do
     EXAMPLE(SOLVE);


 - Variable: SOLVEDECOMPOSES
     default: [TRUE] - if TRUE, will induce SOLVE to use POLYDECOMP
     (see POLYDECOMP) in attempting to solve polynomials.


 - Variable: SOLVEEXPLICIT
     default: [FALSE] - if TRUE, inhibits SOLVE from returning implicit
     solutions i.e. of the form F(x)=0.


 - Variable: SOLVEFACTORS
     default: [TRUE] - if FALSE then SOLVE will not try to factor the
     expression.  The FALSE setting may be desired in some cases where
     factoring is not necessary.


 - Variable: SOLVENULLWARN
     default: [TRUE] - if TRUE the user will be warned if he calls
     SOLVE with either a null equation list or a null variable list.
     For example, SOLVE([],[]); would print two warning messages and
     return [].


 - Variable: SOLVERADCAN
     default: [FALSE] - if TRUE then SOLVE will use RADCAN which will
     make SOLVE slower but will allow certain problems containing
     exponentials and logs to be solved.


 - Variable: SOLVETRIGWARN
     default: [TRUE] - if set to FALSE will inhibit printing by SOLVE
     of the warning message saying that it is using inverse
     trigonometric functions to solve the equation, and thereby losing
     solutions.


 - Variable: SOLVE_INCONSISTENT_ERROR
     default: [TRUE] - If TRUE, SOLVE and LINSOLVE give an error if
     they meet up with a set of inconsistent linear equations, e.g.
     SOLVE([A+B=1,A+B=2]).  If FALSE, they return [] in this case.
     (This is the new mode, previously gotten only by calling ALGSYS.)


 - Function: ZRPOLY
     - This is no longer available in Maxima. See ALLROOTS for a
     function    to compute the roots of a polynomial.


 - Function: ZSOLVE
     This is not available with Maxima anymore.  Documentation is left
     for  historical purposes.

     - For those who can make use of approximate numerical solutions to
     problems, there is a package which calls a routine which has been
     translated from the IMSL fortran library to solve N simultaneous
     non-linear equations in N unknowns.  It uses black-box techniques
     that probably aren't desirable if an exact solution can be
     obtained from one of the smarter solvers (LINSOLVE, ALGSYS, etc).
     But for things that the other solvers don't attempt to handle,
     this can probably give some very useful results.  For
     documentation, do PRINTFILE("zsolve.usg");.  For a demo do
     batch("zsolve.mc")$



File: maxima.info,  Node: Differential Equations,  Next: Numerical,  Prev: Equations,  Up: Top

Differential Equations
**********************

* Menu:

* Definitions for Differential Equations::


File: maxima.info,  Node: Definitions for Differential Equations,  Prev: Differential Equations,  Up: Differential Equations

Definitions for Differential Equations
======================================

 - Function: DESOLVE ([eq1,...,eqn],[var1,...,varn])
     where the eq's are differential equations in the dependent
     variables var1,...,varn.  The functional relationships must be
     explicitly indicated in both the equations and the variables. For
     example
          (C1) 'DIFF(F,X,2)=SIN(X)+'DIFF(G,X);
          (C2) 'DIFF(F,X)+X^2-F=2*'DIFF(G,X,2);
          is NOT the proper format.  The correct way is:
          (C3) 'DIFF(F(X),X,2)=SIN(X)+'DIFF(G(X),X);
          (C4) 'DIFF(F(X),X)+X^2-F(X)=2*'DIFF(G(X),X,2);
          The call is then DESOLVE([D3,D4],[F(X),G(X)]);
          If initial conditions at 0 are known, they should be supplied before
          calling DESOLVE by using ATVALUE.
          (C11) 'DIFF(F(X),X)='DIFF(G(X),X)+SIN(X);
                                  d         d
          (D11)                   -- F(X) = -- G(X) + SIN(X)
                                  dX        dX
          (C12) 'DIFF(G(X),X,2)='DIFF(F(X),X)-COS(X);
                                   2
                                  d          d
          (D12)                   --- G(X) = -- F(X) - COS(X)
                                    2        dX
                                  dX
          (C13) ATVALUE('DIFF(G(X),X),X=0,A);
          (D13)                                A
          (C14) ATVALUE(F(X),X=0,1);
          (D14)                                1
          (C15) DESOLVE([D11,D12],[F(X),G(X)]);
                          X                            X
          (D16) [F(X)=A %E  - A+1, G(X) = COS(X) + A %E  - A + G(0) - 1]
          /* VERIFICATION */
          (C17) [D11,D12],D16,DIFF;
                            X       X      X                X
          (D17)        [A %E  = A %E , A %E  - COS(X) = A %E  - COS(X)]

     If DESOLVE cannot obtain a solution, it returns "FALSE".


 - Function: IC1 (exp,var,var)
     In order to solve initial value problems (IVPs) and boundary value
     problems (BVPs), the routine IC1 is available in the ODE2 package
     for first order equations, and IC2 and BC2 for second order IVPs
     and BVPs, respectively.  Do LOAD(ODE2) to access these.  They are
     used as in the following examples:
          (C3) IC1(D2,X=%PI,Y=0);
                                   COS(X) + 1
          (D3)               Y = - ----------
                                        3
                                       X
          (C4) 'DIFF(Y,X,2) + Y*'DIFF(Y,X)^3 = 0;
                                 2
                                d Y      dY 3
          (D4)                  --- + Y (--)  = 0
                                  2      dX
                                dX
          (C5) ODE2(%,Y,X);
                           3
                          Y  - 6 %K1 Y - 6 X
          (D7)            ------------------ = %K2
                                  3
          (C8) RATSIMP(IC2(D7,X=0,Y=0,'DIFF(Y,X)=2));
                               3
                            2 Y  - 3 Y + 6 X
          (D9)            - ---------------- = 0
                                   3
          (C10) BC2(D7,X=0,Y=1,X=1,Y=3);
                           3
                          Y  - 10 Y - 6 X
          (D11)           --------------- = - 3
                                 3


 - Function: ODE (equation,y,x)
     This no longer exists in Maxima.  The documentation is left here
     for historical purposes.

     a pot-pourri of Ordinary Differential solvers combined in such a
     way as to attempt more and more difficult methods as each fails.
     For example, the first attempt is with ODE2, so therefore, a user
     using ODE can assume he has all the capabilities of ODE2 at the
     very beginning and if he has been using ODE2 in programs they will
     still run if he substitutes ODE (the returned values, and calling
     sequence are identical).  In addition, ODE has a number of user
     features which can assist an experienced ODE solver if the basic
     system cannot handle the equation.  The equation is of the same
     form as required for ODE2 (which see) and the y and x are
     dependent and independent variables, as with ODE2.  For more
     details, do PRINTFILE(ODE,USAGE,SHARE); .


 - Function: ODE2 (exp,dvar,ivar)
     takes three arguments: an ODE of first or second order (only the
     left hand side need be given if the right hand side is 0), the
     dependent variable, and the independent variable.  When
     successful, it returns either an explicit or implicit solution for
     the dependent variable.  %C is used to represent the constant in
     the case of first order equations, and %K1 and %K2 the constants
     for second order equations.  If ODE2 cannot obtain a solution for
     whatever reason, it returns FALSE, after perhaps printing out an
     error message.  The methods implemented for first order equations
     in the order in which they are tested are: linear, separable,
     exact - perhaps requiring an integrating factor, homogeneous,
     Bernoulli's equation, and a generalized homogeneous method.  For
     second order: constant coefficient, exact, linear homogeneous with
     non-constant coefficients which can be transformed to constant
     coefficient, the Euler or equidimensional equation, the method of
     variation of parameters, and equations which are free of either the
     independent or of the dependent variable so that they can be
     reduced to two first order linear equations to be solved
     sequentially.  In the course of solving ODEs, several variables
     are set purely for informational purposes: METHOD denotes the
     method of solution used e.g. LINEAR, INTFACTOR denotes any
     integrating factor used, ODEINDEX denotes the index for
     Bernoulli's method or for the generalized homogeneous method, and
     YP denotes the particular solution for the variation of parameters
     technique.



File: maxima.info,  Node: Numerical,  Next: Statistics,  Prev: Differential Equations,  Up: Top

Numerical
*********

* Menu:

* Introduction to Numerical::
* DCADRE::
* ELLIPT::
* FOURIER::
* NDIFFQ::
* Definitions for Numerical::


File: maxima.info,  Node: Introduction to Numerical,  Next: DCADRE,  Prev: Numerical,  Up: Numerical

Introduction to Numerical
=========================


File: maxima.info,  Node: DCADRE,  Next: ELLIPT,  Prev: Introduction to Numerical,  Up: Numerical

DCADRE
======

The following is obsolete and does not exist in Maxima 5.9.  We leave
the documentation here for historical purposes.

   To make an interface to fortran libraries in the current MAXIMA look
at the examples in "maxima/src/fortdef.lsp"  - The IMSL version of
Romberg integration is now available in Macsyma.  For documentation, Do
PRINTFILE(DCADRE,USAGE,IMSL1); .  For a demo, do batch("dcadre.mc");
This is a numerical integration package using cautious, adaptive
Romberg extrapolation.  The DCADRE package is written to call the IMSL
fortran library routine DCADRE. This is documentation for that program.
Send bugs/comments to KMP To load this package, do
       LOADFILE("imsl")$
   For a demo of this package, do
       batch("dcadre.mc");
   The worker function takes the following syntax:
IMSL_ROMBERG(fn,low,hi) where fn is a function of 1 argument; low and
hi should be the lower and upper bounds of integration. fn must return
floating point values.  IMSL_ROMBERG(exp,var,low,hi)   where exp should
be integrated over the range var=low to hi. The result   of evaluating
exp must always be a floating point number.
FAST_IMSL_ROMBERG(fn,low,hi)   This function does no error checking but
may achieve a speed gain over   the IMSL_ROMBERG function. It expects
that fn is a Lisp function (or   translated Macsyma function) which
accepts a floating point argument   and that it always returns a
floating point value.

   Returns either  [SUCCESS, answer, error] where answer is the result
of the integration and   error is the estimated bound on the absolute
error of the output, DCADRE,   as described in PURPOSE below.  or
[WARNING, n, answer, error] where n is a warning code, answer is the
answer,   and error is the estimated bound on the absolute error of the
output, DCADRE,   as described in PURPOSE below. The following warnings
may occur:      65 = One or more singularities were successfully
handled.       66 = In some subinterval(s), the estimate of the
integral was accepted           merely because the estimated error was
small, even though no regular           behavior was recognized.  or
[ERROR, errorcode] where error code is the IMSL-generated    error
code. The following error codes may occur:      131 = Failure due to
insufficient internal working storage.       132 = Failure. This may be
due to too much noise in function            (relative to the given
error requirements) or due to an            ill-behaved integrand.
133 = RERR is greater than 0.1 or less than 0.0 or is too small
   for the precision of the machine.

   The following flags have an influence upon the operation of
IMSL_ROMBERG -

   ROMBERG_AERR [Default 1.0E-5] - Desired absolute error in answer.

   ROMBERG_RERR [Default 0.0] - Desired relative error in the answer.

   Note: If IMSL signals an error, a message will be printed on the
user's         console stating the nature of the error. (This error
message         may be supressed by setting IMSLVERBOSE to FALSE.)

   Note: Because this uses a translated Fortran routine, it may not be
      recursively invoked. It does not call itself, but the user should
       be aware that he may not type ^A in the middle of an
IMSL_ROMBERG         computation, begin another calculation using the
same package,         and expect to win - IMSL_ROMBERG will complain if
it was already         doing one project when you invoke it. This
should cause minimal         problems.

   Purpose (modified version of the IMSL documentation)
---------------------------------------------------

   DCADRE attempts to solve the following problem: Given a real-valued
function F of one argument, two real numbers A and B, find a number

   DCADRE such that:

     |   / B               |        [                              | / B      | ]
     |   [                 |        [                              | [        | ]
     |   I F(x)dx - DCADRE | <= max [ ROMBERG_AERR, ROMBERG_RERR * | I F(x)dx | ]
     |   ]                 |        [                              | ]        | ]
     |   / A               |        [                              | / A      | ]
   Algorithm (modified version of the IMSL documentation)

   This routine uses a scheme whereby DCADRE is computed as the sum of
estimates for the integral of F(x) over suitably chosen subintervals of
the given interval of integration. Starting with the interval of
integration itself as the first such subinterval, cautious Romberg
extrapolation is used to find an acceptable estimate on a given
subinterval. If this attempt fails, the subinterval is divided into two
subintervals of equal length, each of which is considered separately.
Programming Notes (modified version of the IMSL documentation)

   * 1. DCADRE (the translated-Fortran base for IMSL_ROMBERG) can, in
     many cases,    handle jump discontinuities and certain algebraic
     discontinuities. See    reference for full details.

   * 2. The relative error parameter ROMBERG_RERR must be in the
     interval [0.0,0.1].     For example, ROMBERG_RERR=0.1 indicates
     that the estimate of the intergral    is to be correct to one
     digit, where as ROMBERG_RERR=1.0E-4 calls for four    digits of
     accuracy. If DCADRE determines that the relative accuracy
     requirement cannot be satisfied, IER is set to 133 (ROMBERG_RERR
     should be    large enough that, when added to 100.0, the result is
     a number greater than    100.0 (this will not be true of very tiny
     floating point numbers due to    the nature of machine
     arithmetic)).

   * 3. The absolute error parameter, ROMBERG_AERR, should be
     nonnegative. In    order to give a reasonable value for
     ROMBERG_AERR, the user must know    the approximate magnitude of
     the integral being computed. In many cases,    it is satisfactory
     to use AERR=0.0. In this case, only the relative error
     requirement is satisfied in the compuatation.

   * 4. We quote from the reference, "A very cautious man would accept
     DCADRE    only if IER [the warning or error code] is 0 or 65. The
     merely reasonable    man would keep the faith even if IER is 66.
     The adventurous man is quite    often right in accepting DCADRE
     even if the IER is 131 or 132." Even when    IER is not 0, DCADRE
     returns the best estimate that has been computed.

   For references on this technique, see de Boor, Calr, "CADRE: An
Algorithm for Numerical Quadrature,"   Mathematical Software (John R.
Rice, Ed.), New York, Academic Press,   1971, Chapter 7.


File: maxima.info,  Node: ELLIPT,  Next: FOURIER,  Prev: DCADRE,  Up: Numerical

ELLIPT
======

- A package on the SHARE directory for Numerical routines for Elliptic
Functions and Complete Elliptic Integrals.  (Notation of Abramowitz and
Stegun, Chs 16 and 17) Do LOAD(ELLIPT); to use this package.  At
present all arguments MUST be floating point.  You'll get nonsense
otherwise.  Be warned.  The functions available are: Jacobian elliptic
functions

     AM(U,M) - amplitude with modulus M
     AM1(U,M1) - amplitude with complementary modulus M1
     AM(U,M):=AM1(U,1-M); so use AM1 if M ~ 1
     SN(U,M):=SIN(AM(U,M));
     CN(U,M):=COS(AM(U,M));
     DN(U,M):=SQRT(1-M*SN(U,M)^2);
     (These functions come defined like this.  Others CD, NS etc.  may be
     similarly defined.)
     Complete Elliptic Integrals
     ELLIPTK(M) - Complete elliptic integral of first kind
     ELLIPTK1(M1) - Same but with complementary modulus.
     ELLIPTK(M):=ELLIPTK1(1-M); so use if M ~ 1
     ELLIPTE(M) - Complete elliptic integral of second kind
     ELLIPTE1(M1) - Same but with complementary modulus.
     ELLIPTE(M):=ELLIPTE1(1-M); so use if M ~ 1


File: maxima.info,  Node: FOURIER,  Next: NDIFFQ,  Prev: ELLIPT,  Up: Numerical

FOURIER
=======

- There is a Fast Fourier Transform package, do DESCRIBE(FFT) for
details.  There is also a Fourier Series package.  It may be loaded
with LOAD(FOURIE).  It will also calculate Fourier integral
coefficients and has various other functions to do such things as
replace all occurrences of F(ARG) by ARG in expression (like changing
ABS(a*x+b) to a*x+b).  Do PRINTFILE(FOURIE,USAGE,DSK,SHARE1); for a
list of the functions included.


File: maxima.info,  Node: NDIFFQ,  Next: Definitions for Numerical,  Prev: FOURIER,  Up: Numerical

NDIFFQ
======

a package residing on the SHARE directory for numerical solutions of
differential equations.  LOAD("NDIFFQ"); will load it in for use.  An
example of its use would be:

     Define_Variable(N,0.3,FLOAT);
     Define_Variable(H,0.175,FLOAT);
     F(X,E):=(Mode_Declare([X,E],FLOAT),N*EXP(X)/(E+X^(2*H)*EXP(H*X)));
     Compile(F);
     Array([X,E],FLOAT,35);
     Init_Float_Array(X,1.0E-3,6.85); /* Fills X with the interval */
     E[0]:5.0;                        /* Initial condition */
     Runge_Kutta(F,X,E);              /* Solve it */
     Graph2(X,E);                     /* Graph the solution */
   p.s. Runge_Kutta(F,X,E,E_Prime) would be the call for a second-order
equation.


File: maxima.info,  Node: Definitions for Numerical,  Prev: NDIFFQ,  Up: Numerical

Definitions for Numerical
=========================

 - Function: FFT (real-array, imag-array)
     Fast Fourier Transform.  This package may be loaded by doing
     LOAD(FFT); There is also an IFT command, for Inverse Fourier
     Transform.  These functions perform a (complex) fast fourier
     transform on either 1 or 2 dimensional FLOATING-POINT arrays,
     obtained by:
          ARRAY(<ary>,FLOAT,<dim1>); or
          ARRAY(<ary>,FLOAT,<dim1>,<dim2>);
     For 1D arrays
          <dim1> = 2^n-1
     and for 2D arrays
          <dim1>=<dim2>=2^n-1
     (i.e. the array is square).  (Recall that MACSYMA arrays are
     indexed from a 0 origin so that there will be 2^n and (2^n)^2
     arrays elements in the above two cases.)  This package also
     contains two other functions, POLARTORECT and RECTTOPOLAR.  Do
     DESCRIBE(cmd) for details. For details on the implementation, do
     PRINTFILE(FFT,USAGE,SHARE); .


 - Variable: FORTINDENT
     default: [0] - controls the left margin indentation of expressions
     printed out by the FORTRAN command.  0 gives normal printout (i.e.
     6 spaces), and positive values will causes the expressions to be
     printed farther to the right.


 - Function: FORTMX (name,matrix)
     converts a MACSYMA matrix into a sequence of FORTRAN assignment
     statements of the form name(i,j)=<corresponding matrix element>.
     This command is now obsolete.  FORTMX(name,matrix); may now be
     done as FORTRAN(name=matrix);.  (If "name" is bound,
     FORTRAN('name=matrix); may be necessary.)  Please convert code that
     uses the FORTMX command as it may be flushed some day.


 - Function: FORTRAN (exp)
     converts exp into a FORTRAN linear expression in legal FORTRAN
     with 6 spaces inserted at the beginning of each line, continuation
     lines, and ** rather than ^ for exponentiation.  When the option
     FORTSPACES[FALSE] is TRUE, the FORTRAN command fills out to 80
     columns using spaces.  If FORTRAN is called on a bound symbolic
     atom, e.g. FORTRAN(X); where X:A*B$ has been done, then X={value
     of X}, e.g.  X=A*B will be generated.  In particular, if e.g.
     M:MATRIX(...); has been done, then FORTRAN(M); will generate the
     appropriate assignment statements of the form
     name(i,j)=<corresponding matrix element>.  FORTINDENT[0] controls
     the left margin of expressions printed out, 0 is the normal margin
     (i.e. indented 6 spaces), increasing it will cause the expression
     to be printed further to the right.


 - Variable: FORTSPACES
     default: [FALSE] - if TRUE, the FORTRAN command fills out to 80
     columns using spaces.


 - Function: HORNER (exp, var)
     will convert exp into a rearranged representation as in Horner's
     rule, using var as the main variable if it is specified.  Var may
     also be omitted in which case the main variable of the CRE form of
     exp is used.  HORNER sometimes improves stability if expr is to be
     numerically evaluated.  It is also useful if MACSYMA is used to
     generate programs to be run in FORTRAN (see DESCRIBE(STRINGOUT);)
          (C1) 1.0E-20*X^2-5.5*X+5.2E20;
                                          2
          (D1)                   1.0E-20 X  - 5.5 X + 5.2E+20
          (C2) HORNER(%,X),KEEPFLOAT:TRUE;
          (D2)                  X (1.0E-20 X - 5.5) + 5.2E+20
          (C3) D1,X=1.0E20;
          ARITHMETIC OVERFLOW
          (C4) D2,X=1.0E20;
          (D4)                          6.9999999E+19

 - Function: IFT (real-array, imag-array)
     Inverse Fourier Transform.  Do LOAD(FFT); to load in this package.
     These functions (FFT and IFT) perform a (complex) fast fourier
     transform on either 1 or 2 dimensional FLOATING-POINT arrays,
     obtained by: ARRAY(<ary>,FLOAT,<dim1>); or
     ARRAY(<ary>,FLOAT,<dim1>,<dim2>); For 1D arrays <dim1> must equal
     2^n-1, and for 2D arrays <dim1>=<dim2>=2^n-1 (i.e. the array is
     square).  (Recall that MACSYMA arrays are indexed from a 0 origin
     so that there will be 2^n and (2^n)^2 arrays elements in the above
     two cases.)  For details on the implementation, do
     PRINTFILE(FFT,USAGE,SHARE); .


 - Function: INTERPOLATE (func,x,a,b)
     finds the zero of func as x varies.  The last two args give the
     range to look in.  The function must have a different sign at each
     endpoint.  If this condition is not met, the action of the of the
     function is governed by INTPOLERROR[TRUE]).  If INTPOLERROR is
     TRUE then an error occurs, otherwise the value of INTPOLERROR is
     returned (thus for plotting INTPOLERROR might be set to 0.0).
     Otherwise (given that MACSYMA can evaluate the first argument in
     the specified range, and that it is continuous) INTERPOLATE is
     guaranteed to come up with the zero (or one of them if there is
     more than one zero).  The accuracy of INTERPOLATE is governed by
     INTPOLABS[0.0] and INTPOLREL[0.0] which must be non-negative
     floating point numbers.  INTERPOLATE will stop when the first arg
     evaluates to something less than or equal to INTPOLABS or if
     successive approximants to the root differ by no more than
     INTPOLREL * <one of the approximants>.  The default values of
     INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets as good an
     answer as is possible with the single precision arithmetic we
     have.  The first arg may be an equation.  The order of the last
     two args is irrelevant.  Thus

          INTERPOLATE(SIN(X)=X/2,X,%PI,.1);
             is equivalent to
          INTERPOLATE(SIN(X)=X/2,X,.1,%PI);
     The method used is a binary search in the range specified by the
     last two args.  When it thinks the function is close enough to
     being linear, it starts using linear interpolation.  An
     alternative syntax has been added to interpolate, this replaces the
     first two arguments by a function name.  The function MUST be
     TRANSLATEd or compiled function of one argument.  No checking of
     the result is done, so make sure the function returns a floating
     point number.

          F(X):=(MODE_DECLARE(X,FLOAT),SIN(X)-X/2.0);
          INTERPOLATE(SIN(X)-X/2,X,0.1,%PI)       time= 60 msec
          INTERPOLATE(F(X),X,0.1,%PI);            time= 68 msec
          TRANSLATE(F);
          INTERPOLATE(F(X),X,0.1,%PI);            time= 26 msec
          INTERPOLATE(F,0.1,%PI);                 time=  5 msec

     There is also a Newton method interpolation routine, do
     DESCRIBE(NEWTON); .


 - Variable: INTPOLABS
     default: [0.0] - The accuracy of the INTERPOLATE command is
     governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
     non-negative floating point numbers.  INTERPOLATE will stop when
     the first arg evaluates to something less than or equal to
     INTPOLABS or if successive approximants to the root differ by no
     more than INTPOLREL * <one of the approximants>.  The default
     values of INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets as
     good an answer as is possible with the single precision arithmetic
     we have.


 - Variable: INTPOLERROR
     default: [TRUE] - Governs the behavior of INTERPOLATE.  When
     INTERPOLATE is called, it determines whether or not the function
     to be interpolated satisfies the condition that the values of the
     function at the endpoints of the interpolation interval are
     opposite in sign.  If they are of opposite sign, the interpolation
     proceeds.  If they are of like sign, and INTPOLERROR is TRUE, then
     an error is signaled.  If they are of like sign and INTPOLERROR is
     not TRUE, the value of INTPOLERROR is returned.  Thus for
     plotting, INTPOLERROR might be set to 0.0.


 - Variable: INTPOLREL
     default: [0.0] - The accuracy of the INTERPOLATE command is
     governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
     non-negative floating point numbers.  INTERPOLATE will stop when
     the first arg evaluates to something less than or equal to
     INTPOLABS or if successive approximants to the root differ by no
     more than INTPOLREL * <one of the approximants>.  The default
     values of INTPOLABS and INTPOLREL are 0.0 so INTERPOLATE gets as
     good an answer as is possible with the single precision arithmetic
     we have.


 - Function: NEWTON (exp,var,X0,eps)
     The file NEWTON 1 on the SHARE directory contains a function which
     will do interpolation using Newton's method.  It may be accessed
     by LOAD(NEWTON); .  The Newton method can do things that
     INTERPOLATE will refuse to handle, since INTERPOLATE requires that
     everything evaluate to a flonum. Thus
     NEWTON(x^2-a^2,x,a/2,a^2/100); will say that it can't tell if
     flonum*a^2<a^2/100. Doing ASSUME(a>0); and then doing NEWTON again
     works. You get x=a+<small flonum>*a which is symbolic all the way.
     INTERPOLATE(x^2-a^2,x,a/2,2*a); complains that .5*a is not
     flonum...  An adaptive integrator which uses the Newton-Cotes 8
     panel quadrature rule is available in SHARE1;QQ FASL.  Do
     DESCRIBE(QQ) for details.


 - Function: POLARTORECT (magnitude-array, phase-array)
     converts from magnitude and phase form into real and imaginary
     form putting the real part in the magnitude array and the
     imaginary part into the phase array

          <real>=<magnitude>*COS(<phase>) ==>
            <imaginary>=<magnitude>*SIN(<phase>

     This function is part of the FFT package.  Do LOAD(FFT); to use
     it.  Like FFT and IFT this function accepts 1 or 2 dimensional
     arrays.  However, the array dimensions need not be a power of 2,
     nor need the 2D arrays be square.


 - Function: RECTTOPOLAR (real-array, imag-array)
     undoes POLARTORECT.  The phase is given in the range from -%PI to
     %PI.  This function is part of the FFT package.  Do LOAD(FFT); to
     use it.  Like FFT and IFT this function accepts 1 or 2 dimensional
     arrays.  However, the array dimensions need not be a power of 2,
     nor need the 2D arrays be square.



File: maxima.info,  Node: Statistics,  Next: Arrays and Tables,  Prev: Numerical,  Up: Top

Statistics
**********

* Menu:

* Definitions for Statistics::


File: maxima.info,  Node: Definitions for Statistics,  Prev: Statistics,  Up: Statistics

Definitions for Statistics
==========================

 - Function: GAUSS (mean,sd)
     returns a random floating point number from a normal distribution
     with mean MEAN and standard deviation SD.  This is part of the
     BESSEL function package, do LOAD(BESSEL); to use it.



File: maxima.info,  Node: Arrays and Tables,  Next: Matrices and Linear Algebra,  Prev: Statistics,  Up: Top

Arrays and Tables
*****************

* Menu:

* Definitions for Arrays and Tables::


File: maxima.info,  Node: Definitions for Arrays and Tables,  Prev: Arrays and Tables,  Up: Arrays and Tables

Definitions for Arrays and Tables
=================================

 - Function: ARRAY (name, dim1, dim2, ..., dimk)
 - Function: ARRAY (name, type, dim1, dim2, ..., dimk)
     This sets up a k-dimensional array.  A maximum of five dimensions
     may be used.  In the first form, a general array is created.  In
     the second form, an array meant to have elements of the specified
     type is created.  TYPE can be fixnum for integers of limited size
     or flonum for floating-point numbers.

     The subscripts for the ith dimension are the integers running from
     0 to dimi.  If the user assigns to a subscripted variable before
     declaring the corresponding array, an undeclared array is set up.
     If the user has more than one array to be set up the same way,
     they may all be set up at the same time, by
     ARRAY([list-of-names],dim1, dim2, ..., dimk).  Undeclared arrays,
     otherwise known as hashed arrays (because hash coding is done on
     the subscripts), are more general than declared arrays.  The user
     does not declare their maximum size, and they grow dynamically by
     hashing as more elements are assigned values.  The subscripts of
     undeclared arrays need not even be numbers.  However, unless an
     array is rather sparse, it is probably more efficient to declare
     it when possible than to leave it undeclared.  The ARRAY function
     can be used to transform an undeclared array into a declared array.


 - Function: ARRAYAPPLY (array,[sub1, ... ,subk])
     is like APPLY except the first argument is an array.


 - Function: ARRAYINFO (a)
     returns a list of information about the array a.  For hashed
     arrays it returns a list of "HASHED", the number of subscripts,
     and the subscripts of every element which has a value.  For
     declared arrays it returns a list of "DECLARED", the number of
     subscripts, and the bounds that were given the the ARRAY function
     when it was called on a.  Do EXAMPLE(ARRAYINFO); for an example.


 - Function: ARRAYMAKE (name,[i1,i2,...])
     returns name[i1,i2,...].


 - Variable: ARRAYS
     default: [] a list of all the arrays that have been allocated,
     both declared and undeclared.  Functions which deal with arrays
     are: ARRAY, ARRAYAPPLY, ARRAYINFO, ARRAYMAKE, FILLARRAY,
     LISTARRAY, and REARRAY.

 - Function: BASHINDICES (expr)
     - transforms the expression expr by giving each summation and
     product a unique index. This gives CHANGEVAR greater precision
     when it is working with summations or products.  The form of the
     unique index is J<number>. The quantity <number> is determined by
     referring to GENSUMNUM, which can be changed by the user.  For
     example, GENSUMNUM:0$ resets it.


 - Function: FILLARRAY (array,list-or-array)
     fills array from list-or-array.  If array is a floating-point
     (integer) array then list-or-array should be either a list of
     floating-point (integer) numbers or another floating-point
     (integer) array.  If the dimensions of the arrays are different
     array is filled in row-major order.  If there are not enough
     elements in list-or-array the last element is used to fill out the
     rest of array.  If there are too many the remaining ones are thrown
     away.  FILLARRAY returns its first argument.


 - Function: GETCHAR (a, i)
     returns the ith character of the quoted string or atomic name a.
     This function is useful in manipulating the LABELS list.


 - Function: LISTARRAY (array)
     returns a list of the elements of a declared or hashed array.  the
     order is row-major.  Elements which you have not defined yet will
     be represented by #####.


 - Function: MAKE_ARRAY (type,dim1,dim2,...,dimn)
     - creates an array.  "type" may be 'ANY, 'FLONUM, 'FIXNUM, 'HASHED
     or 'FUNCTIONAL.  This is similar to the ARRAY command, except that
     the created array is a functional array object.  The advantage of
     this over ARRAY is that it doesn't have a name, and once a pointer
     to it goes away, it will also go away.  e.g.  Y:MAKE_ARRAY(....);
     Y now points to an object which takes up space, but do Y:FALSE,
     and Y no longer points to that object, so the object will get
     garbage collected.  Note: the "dimi" here are different from the
     ARRAY command, since they go from 0 to i-1, i.e.  a "dimension" of
     10 means you have elements from 0 to 9.
     Y:MAKE_ARRAY('FUNCTIONAL,'F,'HASHED,1) - The second argument to
     MAKE_ARRAY in this case is the function to call to calculate array
     elements, and the rest of the arguments are passed recursively to
     MAKE_ARRAY to generate the "memory" for the array function object.


 - Function: REARRAY (array,dim1, ... ,dimk)
     can be used to change the size or dimensions of an array.  The new
     array will be filled with the elements of the old one in row-major
     order.  If the old array was too small, FALSE, 0.0 or 0 will be
     used to fill the remaining elements, depending on the type of the
     array.  The type of the array cannot be changed.


 - Function: REMARRAY (name1, name2, ...)
     removes arrays and array associated functions and frees the
     storage occupied.  If name is ALL then all arrays are removed.  It
     may be necessary to use this function if it is desired to redefine
     the values in a hashed array.


 - Variable: USE_FAST_ARRAYS
     [TRUE on Lispm] - If TRUE then only two types of arrays are
     recognized.

     1) The art-q array (t in common lisp) which may have several
     dimensions indexed by integers, and may hold any lisp or macsyma
     object as an entry.  To construct such an array, enter
     A:MAKE_ARRAY(ANY,3,4); then A will have as value, an array with
     twelve slots, and the indexing is zero based.

     2) The Hash_table array which is the default type of array created
     if one does B[X+1]:Y^2 (and B is not already an array,a list, or a
     matrix- if it were one of these an error would be caused since x+1
     would not be a valid subscript for an art-q array,a list or a
     matrix ).  Its indices (also known as keys) may be any object.  It
     only takes ONE KEY at a time (B[X+1,U]:Y would ignore the u)
     Referencing is done by B[X+1]==> Y^2.  Of course the key may be a
     list, eg B[[x+1,u]]:y would be valid.  This is in- compatible with
     the old Macsyma hash arrays, but saves consing.

     An advantage of storing the arrays as values of the symbol is that
     the usual conventions about local variables of a function apply to
     arrays as well.  The Hash_table type also uses less consing and is
     more efficient than the old type of macsyma hashar.  To obtain
     consistent behaviour in translated and compiled code set
     TRANSLATE_FAST_ARRAYS [TRUE] to be TRUE.



File: maxima.info,  Node: Matrices and Linear Algebra,  Next: Affine,  Prev: Arrays and Tables,  Up: Top

Matrices and Linear Algebra
***************************

* Menu:

* Introduction to Matrices and Linear Algebra::
* Definitions for Matrices and Linear Algebra::


File: maxima.info,  Node: Introduction to Matrices and Linear Algebra,  Next: Definitions for Matrices and Linear Algebra,  Prev: Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

Introduction to Matrices and Linear Algebra
===========================================

* Menu:

* DOT::
* VECTORS::


File: maxima.info,  Node: DOT,  Next: VECTORS,  Prev: Introduction to Matrices and Linear Algebra,  Up: Introduction to Matrices and Linear Algebra

DOT
---

- . The dot operator, for matrix (non-commutative) multiplication.
When "." is used in this way, spaces should be left on both sides of
it, e.g. A . B.  This distinguishes it plainly from a decimal point in
a floating point number.  Do APROPOS(DOT); for a list of the switches
which affect the dot operator.


File: maxima.info,  Node: VECTORS,  Prev: DOT,  Up: Introduction to Matrices and Linear Algebra

VECTORS
-------

- The file SHARE;VECT > contains a vector analysis package,
share/vect.dem contains a corresponding demonstration, and SHARE;VECT
ORTH contains definitions of various orthogonal curvilinear coordinate
systems.  LOAD(VECT); will load this package for you.  The vector
analysis package can combine and simplify symbolic expressions
including dot products and cross products, together with the gradient,
divergence, curl, and Laplacian operators.  The distribution of these
operators over sums or products is under user control, as are various
other expansions, including expansion into components in any specific
orthogonal coordinate systems.  There is also a capability for deriving
the scalar or vector potential of a field.  The package contains the
following commands: VECTORSIMP, SCALEFACTORS, EXPRESS, POTENTIAL, and
VECTORPOTENTIAL.  Do DESCRIBE(cmd) on these command names, or
PRINTFILE(VECT,USAGE,SHARE); for details.  Warning:  The VECT package
declares "." to be a commutative operator.


File: maxima.info,  Node: Definitions for Matrices and Linear Algebra,  Prev: Introduction to Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

Definitions for Matrices and Linear Algebra
===========================================

 - Function: ADDCOL (M,list1,list2,...,listn)
     appends the column(s) given by the one or more lists (or matrices)
     onto the matrix M.


 - Function: ADDROW (M,list1,list2,...,listn)
     appends the row(s) given by the one or more lists (or matrices)
     onto the matrix M.


 - Function: ADJOINT (matrix)
     computes the adjoint of a matrix.


 - Function: AUGCOEFMATRIX ([eq1, ...], [var1, ...])
     the augmented coefficient matrix for the variables var1,... of the
     system of linear equations eq1,....  This is the coefficient
     matrix with a column adjoined for the constant terms in each
     equation (i.e. those not dependent upon var1,...).  Do
     EXAMPLE(AUGCOEFMATRIX); for an example.


 - Function: CHARPOLY (M, var)
     computes the characteristic polynomial for Matrix M with respect
     to var.  That is, DETERMINANT(M - DIAGMATRIX(LENGTH(M),var)).  For
     examples of this command, do EXAMPLE(CHARPOLY); .


 - Function: COEFMATRIX ([eq1, ...], [var1, ...])
     the coefficient matrix for the variables var1,... of the system of
     linear equations eq1,...


 - Function: COL (M,i)
     gives a matrix of the ith column of the matrix M.


 - Function: COLUMNVECTOR (X)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     COLUMNVECTOR takes a LIST as its argument and returns a column
     vector the components of which are the elements of the list.  The
     first element is the first component,...etc...(This is useful if
     you want to use parts of the outputs of the functions in this
     package in matrix calculations.)


 - Function: CONJUGATE (X)
     a function in the EIGEN package on the SHARE directory.  It
     returns the complex conjugate of its argument.  This package may
     be loaded by LOAD(EIGEN); .  For a complete description of this
     package, do PRINTFILE("eigen.usg"); .


 - Function: COPYMATRIX (M)
     creates a copy of the matrix M.  This is the only way to make a
     copy aside from recreating M elementwise.  Copying a matrix may be
     useful when SETELMX is used.


 - Function: DETERMINANT (M)
     computes the determinant of M by a method similar to Gaussian
     elimination.  The form of the result depends upon the setting of
     the switch RATMX.  There is a special routine for dealing with
     sparse determininants which can be used by setting the switches
     RATMX:TRUE and SPARSE:TRUE.


 - Variable: DETOUT
     default: [FALSE] if TRUE will cause the determinant of a matrix
     whose inverse is computed to be kept outside of the inverse.  For
     this switch to have an effect DOALLMXOPS and DOSCMXOPS should be
     FALSE (see their descriptions).  Alternatively this switch can be
     given to EV which causes the other two to be set correctly.


 - Function: DIAGMATRIX (n, x)
     returns a diagonal matrix of size n by n with the diagonal
     elements all x.  An identity matrix is created by DIAGMATRIX(n,1),
     or one may use IDENT(n).


 - Variable: DOALLMXOPS
     default: [TRUE] if TRUE all operations relating to matrices are
     carried out.  If it is FALSE then the setting of the individual
     DOT switches govern which operations are performed.


 - Variable: DOMXEXPT
     default: [TRUE] if TRUE,
          %E^MATRIX([1,2],[3,4]) ==>
          MATRIX([%E,%E^2],[%E^3,%E^4])
     In general, this transformation affects expressions of the form
     <base>^<power> where <base> is an expression assumed scalar or
     constant, and <power> is a list or matrix.  This transformation is
     turned off if this switch is set to FALSE.


 - Variable: DOMXMXOPS
     default: [TRUE] if TRUE then all matrix-matrix or matrix-list
     operations are carried out (but not scalar-matrix operations); if
     this switch is FALSE they are not.


 - Variable: DOMXNCTIMES
     default: [FALSE] Causes non-commutative products of matrices to be
     carried out.


 - Variable: DONTFACTOR
     default: [] may be set to a list of variables with respect to
     which factoring is not to occur.  (It is initially empty).
     Factoring also will not take place with respect to any variables
     which are less important (using the variable ordering assumed for
     CRE form) than those on the DONTFACTOR list.


 - Variable: DOSCMXOPS
     default: [FALSE] if TRUE then scalar-matrix operations are
     performed.


 - Variable: DOSCMXPLUS
     default: [FALSE] if TRUE will cause SCALAR + MATRIX to give a
     matrix answer.  This switch is not subsumed under DOALLMXOPS.


 - Variable: DOT0NSCSIMP
     default: [TRUE] Causes a non-commutative product of zero and a
     nonscalar term to be simplified to a commutative product.


 - Variable: DOT0SIMP
     default: [TRUE] Causes a non-commutative product of zero and a
     scalar term to be simplified to a commutative product.


 - Variable: DOT1SIMP
     default: [TRUE] Causes a non-commutative product of one and
     another term to be simplified to a commutative product.


 - Variable: DOTASSOC
     default: [TRUE] when TRUE causes (A.B).C to simplify to A.(B.C)


 - Variable: DOTCONSTRULES
     default: [TRUE] Causes a non-commutative product of a constant and
     another term to be simplified to a commutative product.  Turning
     on this flag effectively turns on DOT0SIMP, DOT0NSCSIMP, and
     DOT1SIMP as well.


 - Variable: DOTDISTRIB
     default: [FALSE] if TRUE will cause A.(B+C) to simplify to A.B+A.C


 - Variable: DOTEXPTSIMP
     default: [TRUE] when TRUE causes A.A to simplify to A^^2


 - Variable: DOTIDENT
     default: [1]  The value to be returned by X^^0.


 - Variable: DOTSCRULES
     default: [FALSE] when TRUE will cause A.SC or SC.A to simplify to
     SC*A and A.(SC*B) to simplify to SC*(A.B)


 - Function: ECHELON (M)
     produces the echelon form of the matrix M.  That is, M with
     elementary row operations performed on it such that the first
     non-zero element in each row in the resulting matrix is a one and
     the column elements under the first one in each row are all zero.
                                  [2  1 - A  -5 B ]
          (D2)                    [               ]
                                  [A    B      C  ]
          
          (C3) ECHELON(D2);
                           [      A - 1        5 B      ]
                           [1   - -----      - ---      ]
                           [        2           2       ]
          (D3)             [                            ]
                           [                2 C + 5 A B ]
                           [0     1         ------------]
                           [                       2    ]
                           [                2 B + A  - A]

 - Function: EIGENVALUES (mat)
     There is a package on the SHARE; directory which contains
     functions for computing EIGENVALUES and EIGENVECTORS and related
     matrix computations.  For information on it do
     PRINTFILE(EIGEN,USAGE,SHARE); .  EIGENVALUES(mat) takes a MATRIX
     as its argument and returns a list of lists the first sublist of
     which is the list of eigenvalues of the matrix and the other
     sublist of which is the list of the multiplicities of the
     eigenvalues in the corresponding order.  [ The MACSYMA function
     SOLVE is used here to find the roots of the characteristic
     polynomial of the matrix.  Sometimes SOLVE may not be able to find
     the roots of the polynomial;in that case nothing in this package
     except CONJUGATE, INNERPRODUCT, UNITVECTOR, COLUMNVECTOR and
     GRAMSCHMIDT will work unless you know the eigenvalues.  In some
     cases SOLVE may generate very messy eigenvalues.  You may want to
     simplify the answers yourself before you go on.  There are
     provisions for this and they will be explained below.  ( This
     usually happens when SOLVE returns a not-so-obviously real
     expression for an eigenvalue which is supposed to be real...)]
     The EIGENVALUES command is available directly from MACSYMA.  To
     use the other functions you must have loaded in the EIGEN package,
     either by a previous call to EIGENVALUES, or by doing
     LOADFILE("eigen"); .


 - Function: EIGENVECTORS (MAT)
     takes a MATRIX as its argument and returns a list of lists the
     first sublist of which is the output of the EIGENVALUES command
     and the other sublists of which are the eigenvectors of the matrix
     corresponding to those eigenvalues respectively.  This function
     will work directly from MACSYMA, but if you wish to take advantage
     of the flags for controlling it (see below), you must first load
     in the EIGEN package from the SHARE; directory.  You may do that by
     LOADFILE("eigen");.  The flags that affect this function are:
     NONDIAGONALIZABLE[FALSE] will be set to TRUE or FALSE depending on
     whether the matrix is nondiagonalizable or diagonalizable after an
     EIGENVECTORS command is executed.  HERMITIANMATRIX[FALSE] If set
     to TRUE will cause the degenerate eigenvectors of the hermitian
     matrix to be orthogonalized using the Gram-Schmidt algorithm.
     KNOWNEIGVALS[FALSE] If set to TRUE the EIGEN package will assume
     the eigenvalues of the matrix are known to the user and stored
     under the global name LISTEIGVALS.  LISTEIGVALS should be set to a
     list similar to the output of the EIGENVALUES command.  ( The
     MACSYMA function ALGSYS is used here to solve for the
     eigenvectors. Sometimes if the eigenvalues are messy, ALGSYS may
     not be able to produce a solution.  In that case you are advised
     to try to simplify the eigenvalues by first finding them using
     EIGENVALUES command and then using whatever marvelous tricks you
     might have to reduce them to something simpler.  You can then use
     the KNOWNEIGVALS flag to proceed further. )


 - Function: EMATRIX (m, n, x, i, j)
     will create an m by n matrix all of whose elements are zero except
     for the i,j element which is x.


 - Function: ENTERMATRIX (m, n)
     allows one to enter a matrix element by element with MACSYMA
     requesting values for each of the m*n entries.
          (C1) ENTERMATRIX(3,3);
          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
           4. General
          
          Answer 1, 2, 3 or 4
          1;
          Row 1 Column 1:  A;
          Row 2 Column 2:  B;
          Row 3 Column 3:  C;
          Matrix entered.
                                           [ A  0  0 ]
                                           [         ]
          (D1)                             [ 0  B  0 ]
                                           [         ]
                                           [ 0  0  C ]

 - Function: GENMATRIX (array, i2, j2, i1, j1)
     generates a matrix from the array using array(i1,j1) for the first
     (upper-left) element and array(i2,j2) for the last (lower-right)
     element of the matrix.  If j1=i1 then j1 may be omitted. If
     j1=i1=1 then i1 and j1 may both be omitted. If a selected element
     of the array doesn't exist a symbolic one will be used.
          (C1) H[I,J]:=1/(I+J-1)$
          (C2) GENMATRIX(H,3,3);
                                     [   1  1]
                                     [1  -  -]
                                     [   2  3]
                                     [       ]
                                     [1  1  1]
          (D2)                       [-  -  -]
                                     [2  3  4]
                                     [       ]
                                     [1  1  1]
                                     [-  -  -]
                                     [3  4  5]

 - Function: GRAMSCHMIDT (X)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     GRAMSCHMIDT takes a LIST of lists the sublists of which are of
     equal length and not necessarily orthogonal (with respect to the
     innerproduct defined above) as its argument and returns a similar
     list each sublist of which is orthogonal to all others.  (Returned
     results may contain integers that are factored.  This is due to
     the fact that the MACSYMA function FACTOR is used to simplify each
     substage of the Gram-Schmidt algorithm.  This prevents the
     expressions from getting very messy and helps to reduce the sizes
     of the numbers that are produced along the way.)


 - Function: HACH (a,b,m,n,l)
     An implementation of Hacijan's linear programming algorithm is
     available by doing BATCH("kach.mc"$.  Details of use are available
     by doing BATCH("kach.dem");


 - Function: IDENT (n)
     produces an n by n identity matrix.


 - Function: INNERPRODUCT (X,Y)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     INNERPRODUCT takes two LISTS of equal length as its arguments and
     returns their inner (scalar) product defined by (Complex Conjugate
     of X).Y (The "dot" operation is the same as the usual one defined
     for vectors).


 - Function: INVERT (matrix)
     finds the inverse of a matrix using the adjoint method.  This
     allows a user to compute the inverse of a matrix with bfloat
     entries or polynomials with floating pt. coefficients without
     converting to cre-form.  The DETERMINANT command is used to compute
     cofactors, so if RATMX is FALSE (the default) the inverse is
     computed without changing the representation of the elements.  The
     current implementation is inefficient for matrices of high order.
     The DETOUT flag if true keeps the determinant factored out of the
     inverse.  Note: the results are not automatically expanded.  If
     the matrix originally had polynomial entries, better appearing
     output can be generated by EXPAND(INVERT(mat)),DETOUT.  If it is
     desirable to then divide through by the determinant this can be
     accomplished by XTHRU(%) or alternatively from scratch by
     EXPAND(ADJOINT(mat))/EXPAND(DETERMINANT(mat)).
     INVERT(mat):=ADJOINT(mat)/DETERMINANT(mat).  See also
     DESCRIBE("^^"); for another method of inverting a matrix.


 - Variable: LMXCHAR
     default: [[] - The character used to display the (left) delimiter
     of a matrix (see also RMXCHAR).


 - Function: MATRIX (row1, ..., rown)
     defines a rectangular matrix with the indicated rows.  Each row
     has the form of a list of expressions, e.g.  [A, X**2, Y, 0] is a
     list of 4 elements.  There are a number of MACSYMA commands which
     deal with matrices, for example:  DETERMINANT, CHARPOLY,
     GENMATRIX, ADDCOL, ADDROW, COPYMATRIX, TRANSPOSE, ECHELON, and
     RANK.  There is also a package on the SHARE directory for
     computing EIGENVALUES.  Try DESCRIBE on these for more information.
     Matrix multiplication is effected by using the dot operator, ".",
     which is also convenient if the user wishes to represent other
     non-commutative algebraic operations.  The exponential of the "."
     operation is "^^" .  Thus, for a matrix A, A.A = A^^2 and, if it
     exists, A^^-1 is the inverse of A.  The operations +,-,*,** are
     all element-by-element operations; all operations are normally
     carried out in full, including the . (dot) operation.  Many
     switches exist for controlling simplification rules involving dot
     and matrix-list operations.  Options Relating to Matrices:
     LMXCHAR, RMXCHAR, RATMX, LISTARITH, DETOUT, DOALLMXOPS, DOMXEXPT
     DOMXMXOPS, DOSCMXOPS, DOSCMXPLUS, SCALARMATRIX, and SPARSE.  Do
     DESCRIBE(option) for details on them.


 - Function: MATRIXMAP (fn, M)
     will map the function fn onto each element of the matrix M.


 - Function: MATRIXP (exp)
     is TRUE if exp is a matrix else FALSE.


 - Variable: MATRIX_ELEMENT_ADD
     default: [+] - May be set to "?"; may also be the name of a
     function, or a LAMBDA expression.  In this way, a rich variety of
     algebraic structures may be simulated.  For more details, do
     DEMO("matrix.dem1"); and DEMO("matrix.dem2");.


 - Variable: MATRIX_ELEMENT_MULT
     default: [*] - May be set to "."; may also be the name of a
     function, or a LAMBDA expression.  In this way, a rich variety of
     algebraic structures may be simulated.  For more details, do
     DEMO("matrix.dem1"); and DEMO("matrix.dem2");


 - Variable: MATRIX_ELEMENT_TRANSPOSE
     default: [FALSE] - Other useful settings are TRANSPOSE and
     NONSCALARS; may also be the name of a function, or a LAMBDA
     expression.  In this way, a rich variety of algebraic structures
     may be simulated.  For more details, do DEMO("matrix.dem1"); and
     DEMO("matrix.dem2");.


 - Function: MATTRACE (M)
     computes the trace [sum of the elements on the main diagonal] of
     the square matrix M.  It is used by NCHARPOLY, an alternative to
     MACSYMA's CHARPOLY.  It is used by doing LOADFILE("nchrpl");


 - Function: MINOR (M, i, j)
     computes the i,j minor of the matrix M.  That is, M with row i and
     column j removed.


 - Function: NCEXPT (A,B)
     if an (non-commutative) exponential expression is too wide to be
     displayed as A^^B it will appear as NCEXPT(A,B).


 - Function: NCHARPOLY (M,var)
     finds the characteristic polynomial of the matrix M with respect
     to var.  This is an alternative to MACSYMA's CHARPOLY.  NCHARPOLY
     works by computing traces of powers of the given matrix, which are
     known to be equal to sums of powers of the roots of the
     characteristic polynomial.  From these quantities the symmetric
     functions of the roots can be calculated, which are nothing more
     than the coefficients of the characteristic polynomial.  CHARPOLY
     works by forming the determinant of VAR * IDENT [N] - A.  Thus
     NCHARPOLY wins, for example, in the case of large dense matrices
     filled with integers, since it avoids polynomial arithmetic
     altogether.  It may be used by doing LOADFILE("nchrpl");


 - Function: NEWDET (M,n)
     also computes the determinant of M but uses the Johnson-Gentleman
     tree minor algorithm.  M may be the name of a matrix or array.
     The argument n is the order; it is optional if M is a matrix.


 - declaration: NONSCALAR
     - makes ai behave as does a list or matrix with respect to the dot
     operator.


 - Function: NONSCALARP (exp)
     is TRUE if exp is a non-scalar, i.e.  it contains atoms declared
     as non-scalars, lists, or matrices.


 - Function: PERMANENT (M,n)
     computes the permanent of the matrix M.  A permanent is like a
     determinant but with no sign changes.


 - Function: RANK (M)
     computes the rank of the matrix M.  That is, the order of the
     largest non-singular subdeterminant of M.  Caveat: RANK may return
     the wrong answer if it cannot determine that a matrix element that
     is equivalent to zero is indeed so.


 - Variable: RATMX
     default: [FALSE] - if FALSE will cause determinant and matrix
     addition, subtraction, and multiplication to be performed in the
     representation of the matrix elements and will cause the result of
     matrix inversion to be left in general representation.  If it is
     TRUE, the 4 operations mentioned above will be performed in CRE
     form and the result of matrix inverse will be in CRE form.  Note
     that this may cause the elements to be expanded (depending on the
     setting of RATFAC) which might not always be desired.


 - Function: ROW (M, i)
     gives a matrix of the ith row of matrix M.


 - Variable: SCALARMATRIXP
     default: [TRUE] - if TRUE, then whenever a 1 x 1 matrix is
     produced as a result of computing the dot product of matrices it
     will be converted to a scalar, namely the only element of the
     matrix.  If set to ALL, then this conversion occurs whenever a 1 x
     1 matrix is simplified.  If set to FALSE, no conversion will be
     done.


 - Function: SETELMX (x, i, j, M)
     changes the i,j element of M to x.  The altered matrix is returned
     as the value.  The notation M[i,j]:x may also be used, altering M
     in a similar manner, but returning x as the value.


 - Function: SIMILARITYTRANSFORM (MAT)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     SIMILARITYTRANSFORM takes a MATRIX as its argument and returns a
     list which is the output of the UNITEIGENVECTORS command.  In
     addition if the flag NONDIAGONALIZABLE is FALSE two global
     matrices LEFTMATRIX and RIGHTMATRIX will be generated.  These
     matrices have the property that LEFTMATRIX.MAT.RIGHTMATRIX is a
     diagonal matrix with the eigenvalues of MAT on the diagonal.  If
     NONDIAGONALIZABLE is TRUE these two matrices will not be
     generated.  If the flag HERMITIANMATRIX is TRUE then LEFTMATRIX is
     the complex conjugate of the transpose of RIGHTMATRIX.  Otherwise
     LEFTMATRIX is the inverse of RIGHTMATRIX.  RIGHTMATRIX is the
     matrix the columns of which are the unit eigenvectors of MAT.  The
     other flags (see DESCRIBE(EIGENVALUES); and
     DESCRIBE(EIGENVECTORS);) have the same effects since
     SIMILARITYTRANSFORM calls the other functions in the package in
     order to be able to form RIGHTMATRIX.


 - Variable: SPARSE
     default: [FALSE] - if TRUE and if RATMX:TRUE then DETERMINANT will
     use special routines for computing sparse determinants.


 - Function: SUBMATRIX (m1, ..., M, n1, ...)
     creates a new matrix composed of the matrix M with rows mi
     deleted, and columns ni deleted.


 - Function: TRANSPOSE (M)
     produces the transpose of the matrix M.


 - Function: TRIANGULARIZE (M)
     produces the upper triangular form of the matrix M which needn't
     be square.


 - Function: UNITEIGENVECTORS (MAT)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     UNITEIGENVECTORS takes a MATRIX as its argument and returns a list
     of lists the first sublist of which is the output of the
     EIGENVALUES command and the other sublists of which are the unit
     eigenvectors of the matrix corresponding to those eigenvalues
     respectively.  The flags mentioned in the description of the
     EIGENVECTORS command have the same effects in this one as well.  In
     addition there is a flag which may be useful :
     KNOWNEIGVECTS[FALSE] - If set to TRUE the EIGEN package will assume
     that the eigenvectors of the matrix are known to the user and are
     stored under the global name LISTEIGVECTS.  LISTEIGVECTS should be
     set to a list similar to the output of the EIGENVECTORS command.
     (If KNOWNEIGVECTS is set to TRUE and the list of eigenvectors is
     given the setting of the flag NONDIAGONALIZABLE may not be
     correct.  If that is the case please set it to the correct value.
     The author assumes that the user knows what he is doing and will
     not try to diagonalize a matrix the eigenvectors of which do not
     span the vector space of the appropriate dimension...)


 - Function: UNITVECTOR (X)
     a function in the EIGEN package.  Do LOAD(EIGEN) to use it.
     UNITVECTOR takes a LIST as its argument and returns a unit list.
     (i.e. a list with unit magnitude).


 - Function: VECTORSIMP (vectorexpression)
     This function employs additional simplifications, together with
     various optional expansions according to the settings of the
     following global flags:

          EXPANDALL, EXPANDDOT, EXPANDDOTPLUS, EXPANDCROSS, EXPANDCROSSPLUS,
          EXPANDCROSSCROSS, EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD,
          EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD, EXPANDCURL, EXPANDCURLPLUS,
          EXPANDCURLCURL, EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS,
          EXPANDLAPLACIANPROD.

     All these flags have default value FALSE. The PLUS suffix refers to
     employing additivity or distributivity.  The PROD suffix refers to
     the expansion for an operand that is any kind of product.
     EXPANDCROSSCROSS refers to replacing p~(q~r) with (p.r)*q-(p.q)*r,
     and EXPANDCURLCURL refers to replacing CURL CURL p with GRAD DIV p
     + DIV GRAD p.  EXPANDCROSS:TRUE has the same effect as
     EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other flags,
     EXPANDPLUS and EXPANDPROD, have the same effect as setting all
     similarly suffixed flags true.  When TRUE, another flag named
     EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
     composition DIV GRAD.  All of these flags are initially FALSE.  For
     convenience, all of these flags have been declared EVFLAG.  For
     orthogonal curvilinear coordinates, the global variables
     COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are
     set by the function invocation


 - Variable: VECT_CROSS
     default:[FALSE] - If TRUE allows DIFF(X~Y,T) to work where ~ is
     defined in SHARE;VECT (where VECT_CROSS is set to TRUE, anyway.)


 - Function: ZEROMATRIX (m,n)
     takes integers m,n as arguments and returns an m by n matrix of
     0's.


 - special symbol: "["
     - [ and ] are the characters which MACSYMA uses to delimit a list.


File: maxima.info,  Node: Affine,  Next: Tensor,  Prev: Matrices and Linear Algebra,  Up: Top

Affine
******

* Menu:

* Definitions for Affine::


File: maxima.info,  Node: Definitions for Affine,  Prev: Affine,  Up: Affine

Definitions for Affine
======================

 - Function: FAST_LINSOLVE (eqns,variables)
     Solves the linear system of equations EQNS for the variables
     VARIABLES  and returns a result suitable to SUBLIS.  The function
     is faster than linsolve for system of equations which are sparse.


 - Function: GROBNER_BASIS (eqns)
     Takes as argument a macsyma list of equations and returns a
     grobner basis for them.  The function POLYSIMP may now be used to
     simplify other functions relative to the equations.

     GROBNER_BASIS([3*X^2+1,Y*X])$

     POLYSIMP(Y^2*X+X^3*9+2)==> -3*x+2

     Polysimp(f)==> 0 if and only if f is in the ideal generated by the
     EQNS  ie.  if and only if f is a polynomial combination of the
     elements of EQNS.


 - Function: SET_UP_DOT_SIMPLIFICATIONS (eqns,[check-thru-degree])
     The eqns are polynomial equations in non commutative variables.
     The value of CURRENT_VARIABLES is the list of variables used for
     computing degrees.  The equations must be homogeneous, in order
     for the procedure to terminate.

     If you have checked overlapping simplifications in
     DOT_SIMPLIFICATIONS above the degree of f, then the following is
     true: DOTSIMP(f)==> 0 if and only if f is in the ideal generated
     by the EQNS  ie.  if and only if f is a polynomial combination of
     the elements of EQNS.

     The degree is that returned by NC_DEGREE.   This in turn is
     influenced by the weights of individual variables.


 - Function: DECLARE_WEIGHT (var1,wt1,var2,wt2,...)
     Assigns VAR1 weight WT1, VAR2 weight wt2..  These are the weights
     used in computing NC_DEGREE.


 - Function: NC_DEGREE (poly)
     Degree of a non commutative polynomial.  See DECLARE_WEIGHTS.


 - Function: DOTSIMP (f)
     ==> 0 if and only if f is in the ideal generated by the EQNS  ie.
     if and only if f is a polynomial combination of the elements of
     EQNS.


 - Function: FAST_CENTRAL_ELEMENTS (variables,degree)
     if SET_UP_DOT_SIMPLIFICATIONS has been previously done, finds the
     central polynomials in the variables in the given degree, For
     example:
          set_up_dot_simplifications([y.x+x.y],3);
          fast_central_elements([x,y],2);
          [y.y,x.x];

 - Function: CHECK_OVERLAPS (degree,add-to-simps)
     checks the overlaps thru degree, making sure that you have
     sufficient simplification rules in each degree, for dotsimp to
     work correctly.  This process can be speeded up if you know before
     hand what the dimension of the space of monomials is.  If it is of
     finite global dimension, then HILBERT should be used.  If you
     don't know the monomial dimensions, do not specify a
     RANK_FUNCTIION.  An optional third argument RESET, false says
     don't bother to query about resetting things.


 - Function: MONO (vari,n)
     VARI is a list of variables.   Returns the list of independent
     monomials relative to the current dot_simplifications, in degree N


 - Function: MONOMIAL_DIMENSIONS (n)
     Compute the hilbert series through degreen n for the current
     algebra.


 - Function: EXTRACT_LINEAR_EQUATIONS (List_nc_polys,monoms)
     Makes a list of the coefficients of the polynomials in
     list_nc_polys of the monoms.  MONOMS is a list of noncommutative
     monomials.   The coefficients should be scalars.   Use
     LIST_NC_MONOMIALS to build the list of monoms.


 - Function: LIST_NC_MONOMIALS (polys_or_list)
     returns a list of the non commutative monomials occurring in a
     polynomial or a collection of polynomials.


 - Function: PCOEFF (poly monom [variables-to-exclude-from-cof
          (list-variables monom)])
     This function is called from lisp level, and uses internal poly
     format.

          CL-MAXIMA>>(setq me (st-rat #$x^2*u+y+1$))
          (#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))
          
          CL-MAXIMA>>(pcoeff me (st-rat #$x^2$))
          (#:U 1 1)

     Rule: if a variable appears in monom it must be to the exact power,
     and if it is in variables to exclude it may not appear unless it
     was in monom to the exact power.  (pcoeff pol 1 ..) will exclude
     variables like substituting them to be zero.


 - Function: NEW-DISREP (poly)
     From lisp this returns the general maxima format for an arg which
     is in st-rat form:

          (displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))
          
                 2
          Y + U X  + 1

 - Function: CREATE_LIST (form,var1,list1,var2,list2,...)
     Create a list by evaluating FORM with VAR1 bound to each element
     of LIST1, and for each such binding bind VAR2 to each element of
     LIST2,...  The number of elements in the result will be
     length(list1)*length(list2)*...  Each VARn must actually be a
     symbol-it will not be evaluated.  The LISTn args will be evaluated
     once at the beginning of the iteration.


          (C82) create_list1(x^i,i,[1,3,7]);
          (D82) [X,X^3,X^7]

     With a double iteration:
          (C79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (D79) [[A,E],[A,F],[A,H],[B,E],[B,F],[B,H]]

     Instead of LISTn two args maybe supplied each of which should
     evaluate to a number.   These will be the inclusive lower and
     upper bounds for the iteration.

          (C81) create_list([i,j],i,[1,2,3],j,1,i);
          (D81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note that the limits or list for the j variable can depend on the
     current value of i.


 - Variable: ALL_DOTSIMP_DENOMS
     if its value is FALSE the denominators encountered in getting
     dotsimps will not be collected.   To collect the denoms
          ALL_DOTSIMP_DENOMS:[];

     and they will be nconc'd onto the end of the list.



File: maxima.info,  Node: Tensor,  Next: Ctensor,  Prev: Affine,  Up: Top

Tensor
******

* Menu:

* Introduction to Tensor::
* Definitions for Tensor::


File: maxima.info,  Node: Introduction to Tensor,  Next: Definitions for Tensor,  Prev: Tensor,  Up: Tensor

Introduction to Tensor
======================

- Indicial Tensor Manipulation package.  It may be loaded by
LOADFILE("itensr"); A manual for the Tensor packages is available in
share/tensor.descr.  A demo is available by DEMO("itenso.dem1"); (and
additional demos are in ("itenso.dem2"), ("itenso.dem3") and following).

   - There are two tensor packages in MACSYMA, CTENSR and ITENSR.
CTENSR is Component Tensor Manipulation, and may be accessed with
LOAD(CTENSR); .  ITENSR is Indicial Tensor Manipulation, and is loaded
by doing LOAD(ITENSR); A manual for CTENSR AND ITENSR is available from
the LCS Publications Office.  Request MIT/LCS/TM-167.  In addition,
demos exist on the TENSOR; directory under the filenames CTENSO DEMO1,
DEMO2, etc. and ITENSO DEMO1, DEMO2, etc.  Do DEMO("ctenso.dem1"); or
DEMO("itenso.dem2"); Send bugs or comments to RP or TENSOR.


File: maxima.info,  Node: Definitions for Tensor,  Prev: Introduction to Tensor,  Up: Tensor

Definitions for Tensor
======================

 - Function: CANFORM (exp)
     [Tensor Package] Simplifies exp by renaming dummy indices and
     reordering all indices as dictated by symmetry conditions imposed
     on them. If ALLSYM is TRUE then all indices are assumed symmetric,
     otherwise symmetry information provided by DECSYM declarations
     will be used. The dummy indices are renamed in the same manner as
     in the RENAME function. When CANFORM is applied to a large
     expression the calculation may take a considerable amount of time.
     This time can be shortened by calling RENAME on the expression
     first.  Also see the example under DECSYM. Note: CANFORM may not
     be able to reduce an expression completely to its simplest form
     although it will always return a mathematically correct result.


 - Function: CANTEN (exp)
     [Tensor Package] Simplifies exp by renaming (see RENAME) and
     permuting dummy indices. CANTEN is restricted to sums of tensor
     products in which no derivatives are present. As such it is limited
     and should only be used if CANFORM is not capable of carrying out
     the required simplification.


 - Function: CARG (exp)
     returns the argument (phase angle) of exp.  Due to the conventions
     and restrictions, principal value cannot be guaranteed unless exp
     is numeric.


 - Variable: COUNTER
     default: [1] determines the numerical suffix to be used in
     generating the next dummy index in the tensor package.  The prefix
     is determined by the option DUMMYX[#].


 - Function: DEFCON (tensor1,<tensor2,tensor3>)
     gives tensor1 the property that the contraction of a product of
     tensor1 and tensor2 results in tensor3 with the appropriate
     indices.  If only one argument, tensor1, is given, then the
     contraction of the product of tensor1 with any indexed object
     having the appropriate indices (say tensor) will yield an indexed
     object with that name, i.e.tensor, and with a new set of indices
     reflecting the contractions performed.      For example, if
     METRIC: G, then DEFCON(G) will implement the raising and lowering
     of indices through contraction with the metric tensor.      More
     than one DEFCON can be given for the same indexed object; the
     latest one given which applies in a particular contraction will be
     used.  CONTRACTIONS is a list of those indexed objects which have
     been given contraction properties with DEFCON.


 - Function: FLUSH (exp,tensor1,tensor2,...)
     Tensor Package - will set to zero, in exp, all occurrences of the
     tensori that have no derivative indices.


 - Function: FLUSHD (exp,tensor1,tensor2,...)
     Tensor Package - will set to zero, in exp, all occurrences of the
     tensori that have derivative indices.


 - Function: FLUSHND (exp,tensor,n)
     Tensor Package - will set to zero, in exp, all occurrences of the
     differentiated object tensor that have n or more derivative
     indices as the following example demonstrates.
          (C1) SHOW(A([I],[J,R],K,R)+A([I],[J,R,S],K,R,S));
                                         J R S      J R
          (D1)                          A        + A
                                         I,K R S    I,K R
          (C2) SHOW(FLUSHND(D1,A,3));
                                               J R
          (D2)                                A
                                               I,K R

 - Function: KDELTA (L1,L2)
     is the generalized Kronecker delta function defined in the Tensor
     package with L1 the list of covariant indices and L2 the list of
     contravariant indices.  KDELTA([i],[j]) returns the ordinary
     Kronecker delta.  The command EV(EXP,KDELTA) causes the evaluation
     of an expression containing KDELTA([],[]) to the dimension of the
     manifold.


 - Function: LC (L)
     is the permutation (or Levi-Civita) tensor which yields 1 if the
     list L consists of an even permutation of integers, -1 if it
     consists of an odd permutation, and 0 if some indices in L are
     repeated.


 - Function: LORENTZ (exp)
     imposes the Lorentz condition by substituting 0 for all indexed
     objects in exp that have a derivative index identical to a
     contravariant index.


 - Function: MAKEBOX (exp)
     will display exp in the same manner as SHOW; however, any tensor
     d'Alembertian occurring in exp will be indicated using the symbol
     [].  For example, []P([M],[N]) represents
     G([],[I,J])*P([M],[N],I,J).


 - Function: METRIC (G)
     specifies the metric by assigning the variable METRIC:G; in
     addition, the contraction properties of the metric G are set up by
     executing the commands DEFCON(G), DEFCON(G,G,KDELTA).  The
     variable METRIC, default: [], is bound to the metric, assigned by
     the METRIC(g) command.


 - Function: NTERMSG ()
     gives the user a quick picture of the "size" of the Einstein
     tensor.  It returns a list of pairs whose second elements give the
     number of terms in the components specified by the first elements.


 - Function: NTERMSRCI ()
     returns a list of pairs, whose second elements give the number of
     terms in the RICCI component specified by the first elements.  In
     this way, it is possible to quickly find the non-zero expressions
     and attempt simplification.


 - Function: NZETA (Z)
     returns the complex value of the Plasma Dispersion Function for
     complex Z.
          NZETAR(Z) ==> REALPART(NZETA(Z))
     NZETAI(Z) returns IMAGPART(NZETA(Z)).  This function is related to
     the complex error function by
          NZETA(Z) = %I*SQRT(%PI)*EXP(-Z^2)*(1-ERF(-%I*Z)).


 - Function: RAISERIEMANN (dis)
     returns the contravariant components of the Riemann curvature
     tensor as array elements UR[I,J,K,L].  These are displayed if dis
     is TRUE.


 - Variable: RATEINSTEIN
     default: [] - if TRUE rational simplification will be performed on
     the non-zero components of Einstein tensors; if FACRAT:TRUE then
     the components will also be factored.


 - Variable: RATRIEMAN
     - This switch has been renamed RATRIEMANN.


 - Variable: RATRIEMANN
     default: [] - one of the switches which controls simplification of
     Riemann tensors; if TRUE, then rational simplification will be
     done; if FACRAT:TRUE then each of the components will also be
     factored.


 - Function: REMCON (tensor1,tensor2,...)
     removes all the contraction properties from the tensori.
     REMCON(ALL) removes all contraction properties from all indexed
     objects.


 - Function: RICCICOM (dis)
     Tensor package) This function first computes the covariant
     components LR[i,j] of the Ricci tensor (LR is a mnemonic for
     "lower Ricci").  Then the mixed Ricci tensor is computed using the
     contravariant metric tensor.  If the value of the argument to
     RICCICOM is TRUE, then these mixed components, RICCI[i,j] (the
     index i is covariant and the index j is contravariant), will be
     displayed directly.  Otherwise, RICCICOM(FALSE) will simply
     compute the entries of the array RICCI[i,j] without displaying the
     results.


 - Function: RINVARIANT ()
     Tensor package) forms the invariant obtained by contracting the
     tensors
          R[i,j,k,l]*UR[i,j,k,l].

     This object is not

     automatically simplified since it can be very large.


 - Function: SCURVATURE ()
     returns the scalar curvature (obtained by contracting the Ricci
     tensor) of the Riemannian manifold with the given metric.


 - Function: SETUP ()
     this has been renamed to TSETUP();  Sets up a metric for Tensor
     calculations.


 - Function: WEYL (dis)
     computes the Weyl conformal tensor.  If the argument dis is TRUE,
     the non-zero components W[I,J,K,L] will be displayed to the user.
     Otherwise, these components will simply be computed and stored.
     If the switch RATWEYL is set to TRUE, then the components will be
     rationally simplified; if FACRAT is TRUE then the results will be
     factored as well.



File: maxima.info,  Node: Ctensor,  Next: Series,  Prev: Tensor,  Up: Top

Ctensor
*******

* Menu:

* Introduction to Ctensor::
* Definitions for Ctensor::


File: maxima.info,  Node: Introduction to Ctensor,  Next: Definitions for Ctensor,  Prev: Ctensor,  Up: Ctensor

Introduction to Ctensor
=======================

- Component Tensor Manipulation Package.  To use the CTENSR package,
type TSETUP(); which automatically loads it from within MACSYMA (if it
is not already loaded) and then prompts the user to input his
coordinate system.  The user is first asked to specify the dimension of
the manifold. If the dimension is 2, 3 or 4 then the list of
coordinates defaults to [X,Y], [X,Y,Z] or [X,Y,Z,T] respectively.
These names may be changed by assigning a new list of coordinates to
the variable OMEGA (described below) and the user is queried about this.
** Care must be taken to avoid the coordinate names conflicting with
other object definitions **.  Next, the user enters the metric either
directly or from a file by specifying its ordinal position. As an
example of a file of common metrics, see TENSOR;METRIC FILE. The metric
is stored in the matrix LG. Finally, the metric inverse is computed and
stored in the matrix UG. One has the option of carrying out all
calculations in a power series.  A sample protocol is begun below for
the static, spherically symmetric metric (standard coordinates) which
will be applied to the problem of deriving Einstein's vacuum equations
(which lead to the Schwarzschild solution) as an example. Many of the
functions in CTENSR will be displayed for the standard metric as
examples.
     (C2) TSETUP();
     
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     N;
     Do you want to
     1. Enter a new metric?
     2. Enter a metric from a file?
     3. Approximate a metric with a Taylor series?
     Enter 1, 2 or 3
     1;
     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:  A;
     Row 2 Column 2:  X^2;
     Row 3 Column 3:  X^2*SIN(Y)^2;
     Row 4 Column 4:  -D;
     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     DEPENDS([A,D],X);
     Do you wish to see the metric?
     Y;
                               [ A  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  X       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   X  SIN (Y)   0  ]
                               [                        ]
                               [ 0  0       0       - D ]
     Do you wish to see the metric inverse?
     N;


File: maxima.info,  Node: Definitions for Ctensor,  Prev: Introduction to Ctensor,  Up: Ctensor

Definitions for Ctensor
=======================

 - Function: CHR1 ([i,j,k])
     yields the Christoffel symbol of the first kind via the definition
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k

     To evaluate the Christoffel symbols for a particular metric, the
     variable METRIC must be assigned a name as in the example under
     CHR2.


 - Function: CHR2 ([i,j],[k])
     yields the Christoffel symbol of the second kind defined by the
     relation
                                 ks
              CHR2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 - Function: CHRISTOF (arg)
     A function in the CTENSR (Component Tensor Manipulation) package.
     It computes the Christoffel symbols of both kinds.  The arg
     determines which results are to be immediately displayed.  The
     Christoffel symbols of the first and second kinds are stored in
     the arrays LCS[i,j,k] and MCS[i,j,k] respectively and defined to
     be symmetric in the first two indices. If the argument to CHRISTOF
     is LCS or MCS then the unique non-zero values of LCS[i,j,k] or
     MCS[i,j,k], respectively, will be displayed. If the argument is ALL
     then the unique non-zero values of LCS[i,j,k] and MCS[i,j,k] will
     be displayed.  If the argument is FALSE then the display of the
     elements will not occur. The array elements MCS[i,j,k] are defined
     in such a manner that the final index is contravariant.


 - Function: COVDIFF (exp,v1,v2,...)
     yields the covariant derivative of exp with respect to the
     variables vi in terms of the Christoffel symbols of the second
     kind (CHR2).  In order to evaluate these, one should use
     EV(exp,CHR2).


 - Function: CURVATURE ([i,j,k],[h])
     Indicial Tensor Package) yields the Riemann curvature tensor in
     terms of the Christoffel symbols of the second kind (CHR2).  The
     following notation is used:
                         h            h           h        %1        h
                CURVATURE     = - CHR2      - CHR2     CHR2    + CHR2
                         i j k        i k,j       %1 j     i k       i j,k
                                        h         %1
                                  + CHR2      CHR2
                                        %1 k      i j

 - Variable: DIAGMETRIC
     default:[] - An option in the CTENSR (Component Tensor
     Manipulation) package.  If DIAGMETRIC is TRUE special routines
     compute all geometrical objects (which contain the metric tensor
     explicitly) by taking into consideration the diagonality of the
     metric. Reduced run times will, of course, result. Note: this
     option is set automatically by TSETUP if a diagonal metric is
     specified.


 - Variable: DIM
     default:[4] - An option in the CTENSR (Component Tensor
     Manipulation) package.  DIM is the dimension of the manifold with
     the default 4. The command DIM:N; will reset the dimension to any
     other integral value.


 - Function: EINSTEIN (dis)
     A function in the CTENSR (Component Tensor Manipulation) package.
     EINSTEIN computes the mixed Einstein tensor after the Christoffel
     symbols and Ricci tensor have been obtained (with the functions
     CHRISTOF and RICCICOM).  If the argument dis is TRUE, then the
     non-zero values of the mixed Einstein tensor G[i,j] will be
     displayed where j is the contravariant index.  RATEINSTEIN[TRUE]
     if TRUE will cause the rational simplification on these
     components. If RATFAC[FALSE] is TRUE then the components will also
     be factored.


 - Function: LRICCICOM (dis)
     A function in the CTENSR (Component Tensor Manipulation) package.
     LRICCICOM computes the covariant (symmetric) components LR[i,j] of
     the Ricci tensor.  If the argument dis is TRUE, then the non-zero
     components are displayed.


 - Function: MOTION (dis)
     A function in the CTENSR (Component Tensor Manipulation) package.
     MOTION computes the geodesic equations of motion for a given
     metric.  They are stored in the array EM[i].  If the argument dis
     is TRUE then these equations are displayed.


 - Variable: OMEGA
     default:[] - An option in the CTENSR (Component Tensor
     Manipulation) package.  OMEGA assigns a list of coordinates to the
     variable. While normally defined when the function TSETUP is
     called, one may redefine the coordinates with the assignment
     OMEGA:[j1,j2,...jn] where the j's are the new coordinate names. A
     call to OMEGA will return the coordinate name list.  Also see
     DESCRIBE(TSETUP); .


 - Function: RIEMANN (dis)
     A function in the CTENSR (Component Tensor Manipulation) Package.
     RIEMANN computes the Riemann curvature tensor from the given
     metric and the corresponding Christoffel symbols.  If dis is TRUE,
     the non-zero components R[i,j,k,l] will be displayed. All the
     indicated indices are covariant.  As with the Einstein tensor,
     various switches set by the user control the simplification of the
     components of the Riemann tensor.  If RATRIEMAN[TRUE] is TRUE then
     rational simplification will be done. If RATFAC[FALSE] is TRUE then
     each of the components will also be factored.


 - Function: TRANSFORM
     - The TRANSFORM command in the CTENSR package has been renamed to
     TTRANSFORM.


 - Function: TSETUP ()
     A function in the CTENSR (Component Tensor Manipulation) package
     which automatically loads the CTENSR package from within MACSYMA
     (if it is not already loaded) and then prompts the user to make
     use of it.  Do DESCRIBE(CTENSR); for more details.


 - Function: TTRANSFORM (matrix)
     A function in the CTENSR (Component Tensor Manipulation) package
     which will perform a coordinate transformation upon an arbitrary
     square symmetric matrix. The user must input the functions which
     define the transformation.  (Formerly called TRANSFORM.)



File: maxima.info,  Node: Series,  Next: Number Theory,  Prev: Ctensor,  Up: Top

Series
******

* Menu:

* Introduction to Series::
* Definitions for Series::


File: maxima.info,  Node: Introduction to Series,  Next: Definitions for Series,  Prev: Series,  Up: Series

Introduction to Series
======================

Maxima contains functions `Taylor' and `Powerseries' for finding the
series of differentiable functions.   It also has tools such as `Nusum'
capable of finding the closed form of some series.   Operations such as
addition and multiplication work as usual on series. This section
presents the various global various variables which control the
expansion.


File: maxima.info,  Node: Definitions for Series,  Prev: Introduction to Series,  Up: Series

Definitions for Series
======================

 - Variable: CAUCHYSUM
     default: [FALSE] - When multiplying together sums with INF as
     their upper limit, if SUMEXPAND is TRUE and CAUCHYSUM is set to
     TRUE then the Cauchy product will be used rather than the usual
     product.  In the Cauchy product the index of the inner summation
     is a function of the index of the outer one rather than varying
     independently.  That is: SUM(F(I),I,0,INF)*SUM(G(J),J,0,INF)
     becomes SUM(SUM(F(I)*G(J-I),I,0,J),J,0,INF)


 - Function: DEFTAYLOR (function, exp)
     allows the user to define the Taylor series (about 0) of an
     arbitrary function of one variable as exp which may be a
     polynomial in that variable or which may be given implicitly as a
     power series using the SUM function.      In order to display the
     information given to DEFTAYLOR one can use POWERSERIES(F(X),X,0).
     (see below).
          (C1) DEFTAYLOR(F(X),X**2+SUM(X**I/(2**I*I!**2),
                  I,4,INF));
          (D1)                          [F]
          (C2) TAYLOR(%E**SQRT(F(X)),X,0,4);
                               2         3          4
                              X    3073 X    12817 X
          (D2)/R/     1 + X + -- + ------- + -------- +  . . .
                              2     18432     307200

 - Variable: MAXTAYORDER
     default: [TRUE] - if TRUE, then during algebraic manipulation of
     (truncated) Taylor series, TAYLOR will try to retain as many terms
     as are certain to be correct.


 - Function: NICEINDICES (expr)
     will take the expression and change all the indices of sums and
     products to something easily understandable. It makes each index
     it can "I" , unless "I" is in the internal expression, in which
     case it sequentially tries J,K,L,M,N,I0,I1,I2,I3,I4,...  until it
     finds a legal index.


 - Variable: NICEINDICESPREF
     default: [I,J,K,L,M,N] - the list which NICEINDICES uses to find
     indices for sums and products.  This allows the user to set the
     order of preference of how NICEINDICES finds the "nice indices".
     E.g.  NICEINDICESPREF:[Q,R,S,T,INDEX]$.  Then if NICEINDICES finds
     that it cannot use any of these as indices in a particular
     summation, it uses the first as a base to try and tack on numbers.
     Here, if the list is exhausted, Q0, then Q1, etc, will be tried.


 - Function: NUSUM (exp,var,low,high)
     performs indefinite summation of exp with respect to var using a
     decision procedure due to R.W. Gosper.  exp and the potential
     answer must be expressible as products of nth powers, factorials,
     binomials, and rational functions.  The terms "definite" and
     "indefinite summation" are used analogously to "definite" and
     "indefinite integration".  To sum indefinitely means to give a
     closed form for the sum over intervals of variable length, not
     just e.g. 0 to inf.  Thus, since there is no formula for the
     general partial sum of the binomial series, NUSUM can't do it.


 - Function: PADE (taylor-series,num-deg-bound,denom-deg-bound)
     returns a list of all rational functions which have the given
     taylor-series expansion where the sum of the degrees of the
     numerator and the denominator is less than or equal to the
     truncation level of the power series, i.e.  are "best"
     approximants, and which additionally satisfy the specified degree
     bounds.  Its first argument must be a univariate taylor-series;
     the second and third are positive integers specifying degree
     bounds on the numerator and denominator.  PADE's first argument
     can also be a Laurent series, and the degree bounds can be INF
     which causes all rational functions whose total degree is less
     than or equal to the length of the power series to be returned.
     Total degree is num-degree + denom-degree.  Length of a power
     series is "truncation level" + 1 - minimum(0,"order of series").

          (C15) ff:taylor(1+x+x^2+x^3,x,0,3);
                                               2    3
          (D15)/T/                    1 + X + X  + X  + . . .
          (C16) pade(ff,1,1);
                                                  1
          (D16)                              [- -----]
                                                X - 1
          (c1) ff:taylor(-(83787*X^10-45552*X^9-187296*X^8
                            +387072*X^7+86016*X^6-1507328*X^5
                            +1966080*X^4+4194304*X^3-25165824*X^2
                            +67108864*X-134217728)
                 /134217728,x,0,10);
          (C25) PADE(ff,4,4);
          (D25) []
     There is no rational function of degree 4 numerator/denominator,
     with this power series expansion.  You must in general have degree
     of the numerator and degree of the denominator adding up to at
     least the degree of the power series, in order to have enough
     unknown coefficients to solve.
          (C26) PADE(ff,5,5);
          (D26) [-(520256329*X^5-96719020632*X^4-489651410240*X^3
                     -1619100813312*X^2 -2176885157888*X-2386516803584)
          	/(47041365435*X^5+381702613848*X^4+1360678489152*X^3
                          +2856700692480*X^2
          	        +3370143559680*X+2386516803584)]


 - Variable: POWERDISP
     default: [FALSE] - if TRUE will cause sums to be displayed with
     their terms in the reverse order.  Thus polynomials would display
     as truncated power series, i.e., with the lowest power first.


 - Function: POWERSERIES (exp, var, pt)
     generates the general form of the power series expansion for exp
     in the variable var about the point pt (which may be INF for
     infinity).  If POWERSERIES is unable to expand exp, the TAYLOR
     function may give the first several terms of the series.
     VERBOSE[FALSE] - if TRUE will cause comments about the progress of
     POWERSERIES to be printed as the execution of it proceeds.
          (C1) VERBOSE:TRUE$
          (C2) POWERSERIES(LOG(SIN(X)/X),X,0);
          Can't expand
                                           LOG(SIN(X))
          So we'll try again after applying the rule:
                                                  d
                                                / -- (SIN(X))
                                                [ dX
                                  LOG(SIN(X)) = I ----------- dX
                                                ]   SIN(X)
                                                /
          In the first simplification we have returned:
                                       /
                                       [
                                       I COT(X) dX - LOG(X)
                                       ]
                                       /
                              INF
                              ====        I1  2 I1             2 I1
                              \      (- 1)   2     BERN(2 I1) X
                               >     ------------------------------
                              /                I1 (2 I1)!
                              ====
                              I1 = 1
          (D2)                -------------------------------------
                                                2

 - Variable: PSEXPAND
     default: [FALSE] - if TRUE will cause extended rational function
     expressions to display fully expanded.  (RATEXPAND will also cause
     this.)  If FALSE, multivariate expressions will be displayed just
     as in the rational function package.  If PSEXPAND:MULTI, then
     terms with the same total degree in the variables are grouped
     together.


 - Function: REVERT (expression,variable)
     Does reversion of Taylor Series.  "Variable" is the variable the
     original Taylor expansion is in.  Do LOAD(REVERT) to access this
     function.  Try

          REVERT2(expression,variable,hipower)
      also.  REVERT only works on expansions around 0.


 - Function: SRRAT (exp)
     this command has been renamed to TAYTORAT.


 - Function: TAYLOR (exp, var, pt, pow)
     expands the expression exp in a truncated Taylor series (or
     Laurent series, if required) in the variable var around the point
     pt.  The terms through (var-pt)**pow are generated.  If exp is of
     the form f(var)/g(var) and g(var) has no terms up to degree pow
     then TAYLOR will try to expand g(var) up to degree 2*pow.  If
     there are still no non-zero terms TAYLOR will keep doubling the
     degree of the expansion of g(var) until reaching pow*2**n where n
     is the value of the variable TAYLORDEPTH[3].  If
     MAXTAYORDER[FALSE] is set to TRUE, then during algebraic
     manipulation of (truncated) Taylor series, TAYLOR will try to
     retain as many terms as are certain to be correct.  Do
     EXAMPLE(TAYLOR); for examples.
     TAYLOR(exp,[var1,pt1,ord1],[var2,pt2,ord2],...)  returns a
     truncated power series in the variables vari about the points pti,
     truncated at ordi.  PSEXPAND[FALSE] if TRUE will cause extended
     rational function expressions to display fully expanded.
     (RATEXPAND will also cause this.) If FALSE, multivariate
     expressions will be displayed just as in the rational function
     package.  If PSEXPAND:MULTI, then terms with the same total degree
     in the variables are grouped together.  TAYLOR(exp, [var1, var2, .
     . .], pt, ord) where each of pt and ord may be replaced by a list
     which will correspond to the list of variables.  that is, the nth
     items on each of the lists will be associated together.
     TAYLOR(exp, [x,pt,ord,ASYMP]) will give an expansion of exp in
     negative powers of (x-pt).  The highest order term will be
     (x-pt)^(-ord).  The ASYMP is a syntactic device and not to be
     assigned to.  See also the TAYLOR_LOGEXPAND switch for controlling
     expansion.


 - Variable: TAYLORDEPTH
     default: [3] - If there are still no non-zero terms TAYLOR will
     keep doubling the degree of the expansion of g(var) until reaching
     pow*2**n where n is the value of the variable TAYLORDEPTH[3].


 - Function: TAYLORINFO (exp)
     returns FALSE if exp is not a Taylor series.  Otherwise, a list of
     lists is returned describing the particulars of the Taylor
     expansion.  For example,
          (C3) TAYLOR((1-Y^2)/(1-X),X,0,3,[Y,A,INF]);
                       2                        2
          (D3)/R/ 1 - A  - 2 A (Y - A) - (Y - A)
                              2                        2
                      + (1 - A  - 2 A (Y - A) - (Y - A) ) X
                   2                        2   2
           + (1 - A  - 2 A (Y - A) - (Y - A) ) X
                              2                        2   3
                      + (1 - A  - 2 A (Y - A) - (Y - A) ) X
               + . . .
          (C4) TAYLORINFO(D3);
          (D4)                       [[Y, A, INF], [X, 0, 3]]

 - Function: TAYLORP (exp)
     a predicate function which returns TRUE if and only if the
     expression 'exp' is in Taylor series representation.


 - Variable: TAYLOR_LOGEXPAND
     default: [TRUE] controls expansions of logarithms in TAYLOR
     series.  When TRUE all log's are expanded fully so that
     zero-recognition problems involving logarithmic identities do not
     disturb the expansion process.  However, this scheme is not always
     mathematically correct since it ignores branch information.  If
     TAYLOR_LOGEXPAND is set to FALSE, then the only expansion of log's
     that will occur is that necessary to obtain a formal power series.


 - Variable: TAYLOR_ORDER_COEFFICIENTS
     default: [TRUE] controls the ordering of coefficients in the
     expression.  The default (TRUE) is that coefficients of taylor
     series will be ordered canonically.


 - Function: TAYLOR_SIMPLIFIER
     - A function of one argument which TAYLOR uses to simplify
     coefficients of power series.


 - Variable: TAYLOR_TRUNCATE_POLYNOMIALS
     default: [TRUE] When FALSE polynomials input to TAYLOR are
     considered to have infinite precison; otherwise (the default) they
     are truncated based upon the input truncation levels.


 - Function: TAYTORAT (exp)
     converts exp from TAYLOR form to CRE form, i.e. it is like
     RAT(RATDISREP(exp)) although much faster.


 - Function: TRUNC (exp)
     causes exp which is in general representation to be displayed as
     if its sums were truncated Taylor series.  E.g. compare
     EXP1:X^2+X+1; with EXP2:TRUNC(X^2+X+1); .  Note that IS(EXP1=EXP2);
     gives TRUE.


 - Function: UNSUM (fun,n)
     is the first backward difference fun(n) - fun(n-1).
          (C1) G(P):=P*4^N/BINOMIAL(2*N,N);
                                                      N
                                                   P 4
          (D1)                       G(P) := ----------------
                                             BINOMIAL(2 N, N)
          (C2) G(N^4);
                                               4  N
                                              N  4
          (D2)                           ----------------
                                         BINOMIAL(2 N, N)
          (C3) NUSUM(D2,N,0,N);
                                   4        3       2              N
                    2 (N + 1) (63 N  + 112 N  + 18 N  - 22 N + 3) 4      2
          (D3)      ------------------------------------------------ - ------
                                  693 BINOMIAL(2 N, N)                 3 11 7
          (C4) UNSUM(%,N);
                                               4  N
                                              N  4
          (D4)                           ----------------
                                         BINOMIAL(2 N, N)

 - Variable: VERBOSE
     default: [FALSE] - if TRUE will cause comments about the progress
     of POWERSERIES to be printed as the execution of it proceeds.



File: maxima.info,  Node: Number Theory,  Next: Symmetries,  Prev: Series,  Up: Top

Number Theory
*************

* Menu:

* Definitions for Number Theory::


File: maxima.info,  Node: Definitions for Number Theory,  Prev: Number Theory,  Up: Number Theory

Definitions for Number Theory
=============================

 - Function: BERN (x)
     gives the Xth Bernoulli number for integer X.  ZEROBERN[TRUE] if
     set to FALSE excludes the zero BERNOULLI numbers.  (See also BURN).


 - Function: BERNPOLY (v, n)
     generates the nth Bernoulli polynomial in the variable v.


 - Function: BFZETA (exp,n)
     BFLOAT version of the Riemann Zeta function.  The 2nd argument is
     how many digits to retain and return, it's a good idea to request
     a couple of extra.  This function is available by doing
     LOAD(BFFAC); .


 - Function: BGZETA (S, FPPREC)
     BGZETA is like BZETA, but avoids arithmetic overflow errors on
     large arguments, is faster on medium size arguments (say S=55,
     FPPREC=69), and is slightly slower on small arguments.  It may
     eventually replace BZETA.  BGZETA is available by doing
     LOAD(BFAC);.


 - Function: BHZETA (S,H,FPPREC)
     gives FPPREC digits of
          SUM((K+H)^-S,K,0,INF)
     This is available by doing LOAD(BFFAC);.


 - Function: BINOMIAL (X, Y)
     the binomial coefficient X*(X-1)*...*(X-Y+1)/Y!. If X and Y are
     integers, then the numerical value of the binomial coefficient is
     computed.  If Y, or the value X-Y, is an integer, the binomial
     coefficient is expressed as a polynomial.


 - Function: BURN (N)
     is like BERN(N), but without computing all of the uncomputed
     Bernoullis of smaller index.  So BURN works efficiently for large,
     isolated N.  (BERN(402) takes about 645 secs vs 13.5 secs for
     BURN(402).  BERN's time growth seems to be exponential, while
     BURN's is about cubic.  But if next you do BERN(404), it only
     takes 12 secs, since BERN remembers all in an array, whereas
     BURN(404) will take maybe 14 secs or maybe 25, depending on
     whether MACSYMA needs to BFLOAT a better value of %PI.)  BURN is
     available by doing LOAD(BFFAC);.  BURN uses an observation of WGD
     that (rational) Bernoulli numbers can be approximated by
     (transcendental) zetas with tolerable efficiency.


 - Function: BZETA
     - This function is obsolete, see BFZETA.


 - Function: CF (exp)
     converts exp into a continued fraction.  exp is an expression
     composed of arithmetic operators and lists which represent
     continued fractions.  A continued fraction a+1/(b+1/(c+...)) is
     represented by the list [a,b,c,...]. a,b,c,.. must be integers.
     Exp may also involve SQRT(n) where n is an integer.  In this case
     CF will give as many terms of the continued fraction as the value
     of the variable CFLENGTH[1] times the period.  Thus the default is
     to give one period.  (CF binds LISTARITH to FALSE so that it may
     carry out its function.)


 - Function: CFDISREP (list)
     converts the continued fraction represented by list into general
     representation.
          (C1) CF([1,2,-3]+[1,-2,1]);
          (D1)                 [1, 1, 1, 2]
          (C2) CFDISREP(%);
                                      1
          (D2)                1 + ---------
                                        1
                                  1 + -----
                                          1
                                      1 + -
                                          2

 - Function: CFEXPAND (x)
     gives a matrix of the numerators and denominators of the
     next-to-last and last convergents of the continued fraction x.
          (C1) CF(SQRT(3));
          (D1)                 [1, 1, 2, 1, 2, 1, 2, 1]
          (C2) CFEXPAND(%);
                                       [71  97]
          (D2)                         [      ]
                                       [41  56]
          (C3) D2[1,2]/D2[2,2],NUMER;
          (D3)                        1.7321429

 - Variable: CFLENGTH
     default: [1] controls the number of terms of the continued
     fraction the function CF will give, as the value CFLENGTH[1] times
     the period.  Thus the default is to give one period.


 - Function: CGAMMA
     - The Gamma function in the complex plane.  Do LOAD(CGAMMA) to use
     these functions.  Functions Cgamma, Cgamma2, and LogCgamma2.
     These functions evaluate the Gamma function over the complex plane
     using the algorithm of Kuki, CACM algorithm 421.  Calculations are
     performed in single precision and the relative error is typically
     around 1.0E-7; evaluation at one point costs less than 1 msec.  The
     algorithm provides for an error estimate, but the Macsyma
     implementation currently does not use it.  Cgamma is the general
     function and may be called with a symbolic or numeric argument.
     With symbolic arguments, it returns as is; with real floating or
     rational arguments, it uses the Macsyma Gamma function; and for
     complex numeric arguments, it uses the Kuki algorithm.  Cgamma2 of
     two arguments, real and imaginary, is for numeric arguments only;
     LogCgamma2 is the same, but the log-gamma function is calculated.
     These two functions are somewhat more efficient.


 - Function: CGAMMA2
     - See CGAMMA.


 - Function: DIVSUM (n,k)
     adds up all the factors of n raised to the kth power.  If only one
     argument is given then k is assumed to be 1.


 - Function: EULER (X)
     gives the Xth Euler number for integer X.  For the
     Euler-Mascheroni constant, see %GAMMA.


 - Function: FACTORIAL (X)
     The factorial function.  FACTORIAL(X) = X! .  See also
     MINFACTORIAL and FACTCOMB.  The factorial operator is !, and the
     double factorial operator is !!.


 - Function: FIB (X)
     the Xth Fibonacci number with FIB(0)=0, FIB(1)=1, and
     FIB(-N)=(-1)^(N+1) *FIB(N).  PREVFIB is FIB(X-1), the Fibonacci
     number preceding the last one computed.


 - Function: FIBTOPHI (exp)
     converts FIB(n) to its closed form definition.  This involves the
     constant %PHI (= (SQRT(5)+1)/2 = 1.618033989).  If you want the
     Rational Function Package to know About %PHI do
     TELLRAT(%PHI^2-%PHI-1)$  ALGEBRAIC:TRUE$ .


 - Function: INRT (X,n)
     takes two integer arguments, X and n, and returns the integer nth
     root of the absolute value of X.


 - Function: JACOBI (p,q)
     is the Jacobi symbol of p and q.


 - Function: LCM (exp1,exp2,...)
     returns the Least Common Multiple of its arguments.  Do
     LOAD(FUNCTS); to access this function.


 - Variable: MAXPRIME
     default: [489318] - the largest number which may be given to the
     PRIME(n) command, which returns the nth prime.


 - Function: MINFACTORIAL (exp)
     examines exp for occurrences of two factorials which differ by an
     integer.  It then turns one into a polynomial times the other.  If
     exp involves binomial coefficients then they will be converted
     into ratios of factorials.
          (C1) N!/(N+1)!;
                                              N!
          (D1)                             --------
                                           (N + 1)!
          (C2) MINFACTORIAL(%);
                                               1
          (D2)                               -----
                                             N + 1

 - Function: PARTFRAC (exp, var)
     expands the expression exp in partial fractions with respect to
     the main variable, var.  PARTFRAC does a complete partial fraction
     decomposition.  The algorithm employed is based on the fact that
     the denominators of the partial fraction expansion (the factors of
     the original denominator) are relatively prime.  The numerators
     can be written as linear combinations of denominators, and the
     expansion falls out.  See EXAMPLE(PARTFRAC); for examples.


 - Function: PRIME (n)
     gives the nth prime. MAXPRIME[489318] is the largest number
     accepted as argument.  Note:  The PRIME command does not work in
     maxima, since it required a large file of primes, which most users
     do not want.    PRIMEP does work however.


 - Function: PRIMEP (n)
     returns TRUE if n is a prime, FALSE if not.


 - Function: QUNIT (n)
     gives the principal unit of the real quadratic number field
     SQRT(n) where n is an integer, i.e.  the element whose norm is
     unity.  This amounts to solving Pell's equation A**2- n*B**2=1.
          (C1) QUNIT(17);
          (D1)              SQRT(17)+4
          (C2)  EXPAND(%*(SQRT(17)-4));
          (D2)               1

 - Function: TOTIENT (n)
     is the number of integers less than or equal to n which are
     relatively prime to n.


 - Variable: ZEROBERN
     default: [TRUE] - if set to FALSE excludes the zero BERNOULLI
     numbers.  (See the BERN function.)


 - Function: ZETA (X)
     gives the Riemann zeta function for certain integer values of X.


 - Variable: ZETA%PI
     default: [TRUE] - if FALSE, suppresses ZETA(n) giving coeff*%PI^n
     for n even.



File: maxima.info,  Node: Symmetries,  Next: Groups,  Prev: Number Theory,  Up: Top

Symmetries
**********

* Menu:

* Definitions for Symmetries::


File: maxima.info,  Node: Definitions for Symmetries,  Prev: Symmetries,  Up: Symmetries

Definitions for Symmetries
==========================

 - Function: COMP2PUI (n, l)
     re'alise le passage des fonctions syme'triques comple`tes,
     donnee's dans la liste l, aux fonctions syme'triques
     e'le'mentaires de 0 a` n. Si la liste l contient moins de n+1
     e'le'ments les valeurs formelles viennent la completer. Le premier
     e'le'ment de la liste l donne le cardinal de l'alphabet si il
     existe, sinon on le met e'gal a n.

          COMP2PUI(3,[4,g]);
                               2          3
                     [4, g, - g  + 2 h2, g  - 3 h2 g + 3 h3]


 - Function: CONT2PART (pc,lvar)
     rend le polyno^me partitionne' associe' a` la forme  contracte'e
     pc dont les variables sont dans lvar.

          pc : 2*a^3*b*x^4*y + x^5$
          CONT2PART(pc,[x,y]);
                                   3
                              [[2 a  b, 4, 1], [1, 5]]

     Autres fonctions de changements de repre'sentations :

     CONTRACT, EXPLOSE, PART2CONT, PARTPOL, TCONTRACT, TPARTPOL.


 - Function: CONTRACT (psym,lvar)
     rend une forme contracte'e (i.e. un mono^me par orbite sous
     l'action du groupe syme'trique) du polyno^me psym en les variables
     contenues dans la liste lvar. La fonction EXPLOSE re'alise
     l'ope'ration inverse. La fonction TCONTRACT teste en plus la
     syme'trie du polyno^me.

          psym : EXPLOSE(2*a^3*b*x^4*y,[x,y,z]);
          
                  3      4      3      4      3    4
               2 a  b y z  + 2 a  b x z  + 2 a  b y  z
                          3    4        3      4      3    4
                     + 2 a  b x  z + 2 a  b x y  + 2 a  b x  y
          
          CONTRACT(psym,[x,y,z]);
          
                                  3    4
                               2 a  b x  y

     Autres fonctions de changements de repre'sentations :

     CONT2PART, EXPLOSE, PART2CONT, PARTPOL, TCONTRACT, TPARTPOL.


 - Function: DIRECT ([P1,...,Pn],y,f,[lvar1,...,lvarn])
     calcul l'image directe (voir M. GIUSTI,D. LAZARD et A. VALIBOUZE,
     ISSAC 1988, Rome) associe'e a` la fonction f, en les listes de
     variables lvar1,...,lvarn, et aux polyno^mes P1,...,Pn d'une
     variable y. l'arite' de la fonction f est importante pour le
     calcul. Ainsi, si l'expression de f ne depend pas d'une variable,
     non seulement il est inutile de donner cette variable mais cela
     diminue conside'rablement lees calculs si on ne le fait pas.

          DIRECT([z^2  - e1* z + e2, z^2  - f1* z + f2], z, b*v + a*u,
                        [[u, v], [a, b]]);
          
                              2                         2           2
                             z  - e1 f1 z - 4 e2 f2 + e1  f2 + e2 f1
          
          DIRECT([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2], z, b*v + a*u,
                        [[u, v], [a, b]]);
          
           6            5            4       2     4          2  4
          Y  - 2 E1 F1 Y  - 6 E2 F2 Y  + 2 E1  F2 Y  + 2 E2 F1  Y
          
              2   2  4
          + E1  F1  Y
          
                        3                  3       3        3          3  3
          + 9 E3 F1 F2 Y  + 5 E1 E2 F1 F2 Y  - 2 E1  F1 F2 Y  - 2 E3 F1  Y
          
          	    3  3       2   2  2       2      2  2     4   2  2
          - 2 E1 E2 F1  Y  + 9 E2  F2  Y  - 6 E1  E2 F2  Y  + E1  F2  Y
          
          	    2     2       2   2     2       2      2     2
          - 9 E1 E3 F1  F2 Y  - 6 E2  F1  F2 Y  + 3 E1  E2 F1  F2 Y
          
                      4  2
          + 2 E1 E3 F1  Y
          
              2   4  2                 2         2         2
          + E2  F1  Y  - 27 E2 E3 F1 F2  Y + 9 E1  E3 F1 F2  Y
          
                   2      2
          + 3 E1 E2  F1 F2  Y
          
              3         2                3            2      3
          - E1  E2 F1 F2  Y + 15 E2 E3 F1  F2 Y - 2 E1  E3 F1  F2 Y
          
                 2   3
          - E1 E2  F1  F2 Y
          
          	    5          2   3                 3       3      3
          - 2 E2 E3 F1  Y - 27 E3  F2  + 18 E1 E2 E3 F2  - 4 E1  E3 F2
          
                 3   3
           - 4 E2  F2
          
              2   2   3        2   2   2                2   2     3      2   2
          + E1  E2  F2  + 27 E3  F1  F2  - 9 E1 E2 E3 F1  F2  + E1  E3 F1  F2
          
              3   2   2       2   4                 4        2   6
          + E2  F1  F2  - 9 E3  F1  F2 + E1 E2 E3 F1  F2 + E3  F1

     Recherche du polyno^me dont les racines sont les somme a+u ou a est
     racine de z^2  - e1* z + e2 et u est racine de z^2  - f1* z + f2

          DIRECT([z^2  - e1* z + e2,z^2  - f1* z + f2], z,a+u,[[u],[a]]);
          
           4         3         3         2     2  2            2         2
          Y  - 2 F1 Y  - 2 E1 Y  + 2 F2 Y  + F1  Y  + 3 E1 F1 Y  + 2 E2 Y
          
              2  2
          + E1  Y
                                         2                   2
          - 2 F1 F2 Y - 2 E1 F2 Y - E1 F1  Y - 2 E2 F1 Y - E1  F1 Y
          
                          2
          - 2 E1 E2 Y + F2
          
                                   2           2                2
          + E1 F1 F2 - 2 E2 F2 + E1  F2 + E2 F1  + E1 E2 F1 + E2

     DIRECT peut prendre deux drapeaux possibles : ELEMENTAIRES et
     PUISSANCES (valeur par de'faut) qui permettent de de'composer les
     polyno^mes syme'triques apparaissant dans ce calcul par les
     fonctions syme'triques e'le'mentaires ou les fonctions puissances
     respectivement.

     fonctions de SYM utilis'ees dans cette fonction :


          MULTI_ORBIT (donc ORBIT), PUI_DIRECT, MULTI_ELEM
          (donc ELEM), MULTI_PUI (donc PUI), PUI2ELE, ELE2PUI
          (si le drapeau DIRECT est a` PUISSANCES).


 - Function: ELE2COMP (m , l)
     passe des fonctions syme'triques e'le'mentaires aux fonctions
     comple`tes. Similaire a` COMP2ELE et COMP2PUI.

     autres fonctions de changements de bases :

          COMP2ELE, COMP2PUI, ELE2PUI, ELEM, MON2SCHUR, MULTI_ELEM,
          MULTI_PUI, PUI, PUI2COMP, PUI2ELE, PUIREDUC, SCHUR2COMP.


 - Function: ELE2POLYNOME (l,z)
     donne le polyno^me en z dont les fonctions syme'triques
     e'le'mentaires des racines sont dans la liste l.  l=[n,e1,...,en]
     ou` n est le degre' du polyno^me et ei la i-ie`me fonction
     syme'trique e'le'mentaire.

           ele2polynome([2,e1,e2],z);
          
                                            2
                                           Z  - E1 Z + E2
          
           polynome2ele(x^7-14*x^5  + 56*x^3  - 56*X + 22,x);
          
                        [7, 0, - 14, 0, 56, 0, - 56, - 22]
           ele2polynome( [7, 0, - 14, 0, 56, 0, - 56, - 22],x);
          
                                    7       5       3
                                   X  - 14 X  + 56 X  - 56 X + 22

     la re'ciproque : POLYNOME2ELE(p,z)

     autres fonctions a` voir :

     POLYNOME2ELE, PUI2POLYNOME.


 - Function: ELE2PUI (m, l)
     passe des fonctions syme'triques e'le'mentaires aux fonctions
     comple`tes. Similaire a` COMP2ELE et COMP2PUI.

     autres fonctions de changements de bases :

          COMP2ELE, COMP2PUI, ELE2COMP, ELEM, MON2SCHUR, MULTI_ELEM,
          MULTI_PUI, PUI, PUI2COMP, PUI2ELE, PUIREDUC, SCHUR2COMP.


 - Function: ELEM (ele,sym,lvar)
     de'compose le polyno^me syme'trique sym, en les variables
     contenues de la liste lvar, par les fonctions syme'triques
     e'le'mentaires contenues dans la liste ele. Si le premier
     e'le'ment de ele est donne' ce sera le cardinal de l'alphabet
     sinon on prendra le degre' du polyno^me sym. Si il manque des
     valeurs a` la liste ele des valeurs formelles du type "ei" sont
     rajoute'es. Le polyno^me sym peut etre donne' sous 3 formes
     diffe'rentes : contracte'e (ELEM doit alors valoir 1 sa valeur par
     de'faut), partitionne'e (ELEM doit alors valoir 3) ou e'tendue
     (i.e. le polyno^me en entier) (ELEM doit alors valoir 2).
     L'utilsation de la fonction PUI se re'alise sur le me^me mode`le.

     Sur un alphabet de cardinal 3 avec e1, la premie`re fonction
     syme'trique e'le'mentaire, valant 7, le polyno^me syme'trique en 3
     variables dont la forme contracte'e (ne de'pendant ici que de deux
     de ses variables) est x^4-2*x*y se de'compose ainsi en les
     fonctions syme'triques e'le'mentaires :

          ELEM([3,7],x^4-2*x*y,[x,y]);
          
                                         2
                             28 e3 + 2 e2  - 198 e2 + 2401

     autres fonctions de changements de bases :

     COMP2ELE, COMP2PUI, ELE2COMP, ELE2PUI, MON2SCHUR, MULTI_ELEM,
     MULTI_PUI, PUI, PUI2COMP, PUI2ELE, PUIREDUC, SCHUR2COMP.


 - Function: EXPLOSE (pc,lvar)
     rend le polyno^me syme'trique associe' a` la forme contracte'e pc.
     La liste lvar contient les variables.

          EXPLOSE(a*x +1,[x,y,z]);
          
                               (x + y + z) a + 1

     Autres fonctions de changements de repre'sentations :

     CONTRACT, CONT2PART, PART2CONT, PARTPOL, TCONTRACT, TPARTPOL.


 - Function: KOSTKA (part1,part2)
     e'crite par P. ESPERET) calcule le nombre de kostka associe' aux
     partition part1 et part2

          kostka([3,3,3],[2,2,2,1,1,1]);
                                            6


 - Function: LGTREILLIS (n,m)
     rend la liste des partitions de poids n et de longueur m.

     LGTREILLIS(4,2);

     			       [[3, 1], [2, 2]]

     Voir e'galement : LTREILLIS, TREILLIS et TREINAT.


 - Function: LTREILLIS (n,m)
     rend la liste des partitions de poids n et de longueur infe'rieure
     ou e'gale a` m.

           ltreillis(4,2);
          
                                   [[4, 0], [3, 1], [2, 2]]

     Voir e'galement : LGTREILLIS, TREILLIS et TREINAT.


 - Function: MON2SCHUR (l)
     la liste l repre'sente la fonction de Schur S_l :  On a
     l=[i1,i2,...,iq] avec i1 <= i2 <= ... <= iq . La fonction de Schur
     est S_[i1,i2...,iq] est le mineur de la matrice infinie (h_{i-j})
     i>=1, j>=1 compose' des q premie`res lignes et des colonnes
     i1+1,i2+2,...,iq+q.

     On e'crit cette fonction de Schur en fonction des formes
     monomiales en utilisant les fonctions TREINAT et KOSTKA. La forme
     rendue est un polyno^me syme'trique dans une de ses
     repre'sentations contracte'es avec les variables x1, x2, ...

           mon2schur([1,1,1]);
          
                                         X1 X2 X3
          
           mon2schur([3]);
          
                                                   2        3
                                      X1 X2 X3 + X1  X2 + X1
           MON2SCHUR([1,2]);
          					     2
           			      2 x1 x2 x3 + x1  x2

     ce qui veut dire que pour 3 variables cela donne :
             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2

     autres fonctions de changements de bases :

          COMP2ELE, COMP2PUI, ELE2COMP, ELE2PUI, ELEM, MULTI_ELEM,
          MULTI_PUI, PUI, PUI2COMP, PUI2ELE, PUIREDUC, SCHUR2COMP.


 - Function: MULTI_ELEM (l_elem,multi_pc,l_var)
     de'compose un polyno^me multi-syme'trique sous la forme
     multi-contracte'e multi_pc en les groupes de variables contenue
     dans la liste de listes l_var sur les groupes de fonctions
     syme'triques e'le'mentaires contenues dans l_elem.

     MULTI_ELEM([[2,e1,e2],[2,f1,f2]],a*x+a^2+x^3,[[x,y],[a,b]]);

     				2		        3  		     - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     autres fonctions de changements de bases :

          COMP2ELE, COMP2PUI, ELE2COMP, ELE2PUI, ELEM,
          MON2SCHUR, MULTI_PUI, PUI, PUI2COMP, PUI2ELE,
          PUIREDUC, SCHUR2COMP.


 - Function: MULTI_ORBIT (P,[lvar1, lvar2,...,lvarp])
     P est un polyno^me en l'ensemble des variables contenues dans les
     listes lvar1, lvar2 ... lvarp.  Cette fonction rame`ne l'orbite du
     polyno^me P sous l'action du produit des groupes syme'triques des
     ensembles de variables repre'sente's par ces p LISTES.

           MULTI_ORBIT(a*x+b*y,[[x,y],[a,b]]);
          
                    [b y + a x, a y + b x]
          
           multi_orbit(x+y+2*a,[[x,y],[a,b,c]]);
          
                        [Y + X + 2 C, Y + X + 2 B, Y + X + 2 A]

     voir e'galement : ORBIT pour l'action d'un seul groupe syme'trique


 - Function: MULTI_PUI
     est a` la fonction PUI ce que la fonction MULTI_ELEM est a` la
     fonction ELEM.

          MULTI_PUI([[2,p1,p2],[2,t1,t2]],a*x+a^2+x^3,[[x,y],[a,b]]);
          
                                                        3
                                                 3 P1 P2   P1
                                    T2 + P1 T1 + ------- - ---
                                                    2       2


 - Function: MULTINOMIAL (r,part)
     ou` r est le poids de la partition part. Cette fonction rame`ne le
     coefficient multinomial associe' : si les parts de la partitions
     part sont i1, i2, ..., ik, le re'sultat de MULTINOMIAL est
     r!/(i1!i2!...ik!).


 - Function: MULTSYM (ppart1, ppart2,N)
     re'alise le produit de deux polyno^mes syme'triques de N variables
     en ne travaillant que modulo l'action du groupe syme'trique
     d'ordre N. Les polyno^mes sont dans leur repre'sentation
     partitionne'e.

     Soient les 2 polyno^mes syme'triques en x, y : 3*(x+y) + 2*x*y et
     5*(x^2+y^2) dont les formes partitionne'es sont respectivement
     [[3,1],[2,1,1]] et [[5,2]], alors leur produit sera donne' par :

           MULTSYM([[3,1],[2,1,1]],[[5,2]],2);
          
                      [[10, 3, 1], [15, 2, 1], [15, 3, 0]]

     soit 10*(x^3*y+y^3*x)+15*(x^2*y +y^2*x) +15(x^3+y^3)

     Fonctions de changements de repre'sentations d'un polyno^me
     syme'trique :

     CONTRACT, CONT2PART, EXPLOSE, PART2CONT, PARTPOL, TCONTRACT,
     TPARTPOL.


 - Function: ORBIT (P,lvar)
     calcul l'orbite du polyno^me P en les variables de la liste lvar
     sous l'action du groupe syme'trique de l'ensemble des variables
     contenues dans la liste lvar.

           orbit(a*x+b*y,[x,y]);
          
                                  [A Y + B X, B Y + A X]
           orbit(2*x+x^2,[x,y]);
                                          2         2
                                        [Y  + 2 Y, X  + 2 X]

     voir e'galement : MULTI_ORBIT pour l'action d'un produit de groupes
     syme'triques sur un polyno^me.


 - Function: PART2CONT (ppart,lvar)
     passe de la forme partitionne'e a` la forme contracte'e d'un
     polyno^me syme'trique. La forme contracte'e est rendue avec les
     variables contenues dans lvar.

          PART2CONT([[2*a^3*b,4,1]],[x,y]);
          
                                  3    4
                               2 a  b x  y

     Autres fonctions de changements de repre'sentations :

     CONTRACT, CONT2PART, EXPLOSE, PARTPOL, TCONTRACT, TPARTPOL.


 - Function: PARTPOL (psym, lvar)
     psym est un polyno^me syme'trique en les variables de lvar. Cette
     fonction rame`ne sa repre'sentation partitionne'e.

          PARTPOL(-a*(x+y)+3*x*y,[x,y]);
          
                             [[3, 1, 1], [- a, 1, 0]]

     Autres fonctions de changements de repre'sentations :

     CONTRACT, CONT2PART, EXPLOSE, PART2CONT, TCONTRACT, TPARTPOL.


 - Function: PERMUT (l)
     rame`ne la liste des permutations de la liste l.


 - Function: POLYNOME2ELE (p,x)
     donne la liste l=[n,e1,...,en] ou` n est le degre' du polyno^me p
     en la variable x et ei la i-ieme fonction syme'trique
     e'le'mentaire des racines de p.

           POLYNOME2ELE(x^7-14*x^5  + 56*x^3  - 56*X + 22,x);
          
                        [7, 0, - 14, 0, 56, 0, - 56, - 22]
          
           ELE2POLYNOME( [7, 0, - 14, 0, 56, 0, - 56, - 22],x);
          
                                    7       5       3
                                   X  - 14 X  + 56 X  - 56 X + 22

     la re'ciproque : ELE2POLYNOME(l,x)


 - Function: PRODRAC (L,K)
     L est une liste contenant les fonctions syme'triques
     e'le'mentaires sur un ensemble A. PRODRAC rend le polyno^me dont
     les racines sont les produits K a` K des e'le'ments de A.


 - Function: PUI (pui,sym,lvar)
     de'compose le polyno^me syme'trique sym, en les variables
     contenues de la liste lvar, par les fonctions puissances contenues
     dans la liste pui. Si le premier e'le'ment de pui est donne' ce
     sera le cardinal de l'alphabet sinon on prendra le degre' du
     polyno^me sym. Si il manque des valeurs a` la liste pui, des
     valeurs formelles du type "pi" sont rajoute'es. Le polyno^me sym
     peut etre donne' sous 3 formes diffe'rentes : contracte'e (PUI
     doit alors valoir 1 sa valeur par de'faut), partitionne'e (PUI
     doit alors valoir 3) ou e'tendue (i.e. le polyno^me en entier)
     (PUI doit alors valoir 2). La fonction ELEM s'utilise de la me^me
     manie`re.

          PUI;
          
          		       1
          PUI([3,a,b],u*x*y*z,[x,y,z]);
          
          			       3
          			     (a  - 3 b a + 2 p3) u
                   		     ---------------------
          				      6

     autres fonctions de changements de bases :

          COMP2ELE, COMP2PUI, ELE2COMP, ELE2PUI, ELEM, MON2SCHUR,
          MULTI_ELEM, MULTI_PUI, PUI2COMP, PUI2ELE, PUIREDUC,
          SCHUR2COMP.


 - Function: PUI2COMP (N,LPUI)
     rend la liste des N premie`res fonctions comple`tes (avec en te^te
     le cardinal) en fonction des fonctions puissance donne'es dans la
     liste LPUI. Si la liste LPUI est vide le cardinal est N sinon
     c'est son premier e'le'ment similaire a` COMP2ELE et COMP2PUI.

           PUI2COMP(2,[]);
          
          					 2
          				       p1  + p2
                  		       [2, p1, --------]
          					  2
          
           PUI2COMP(3,[2,a1]);
          
          			      2	        3
          			    a1  + p2  a1  + 3 p2 a1 + 2 p3
                    	    [2, a1, --------, --------------------]
          			       2	       6

     Autres fonctions de changements de bases :


          COMP2ELE, COMP2PUI, ELE2COMP, ELE2PUI, ELEM,
          MON2SCHUR, MULTI_ELEM, MULTI_PUI, PUI, PUI2ELE,
          PUIREDUC, SCHUR2COMP.


 - Function: PUI2ELE (N,LPUI)
     re'alise le passage des fonctions puissances aux fonctions
     syme'triques e'le'mentaires.  Si le drapeau PUI2ELE est GIRARD, on
     re'cupe`re la liste des fonctions syme'triques e'le'mentaires de 1
     a` N, et s'il est e'gal a`  CLOSE, la Nie`me fonction syme'trique
     e'le'mentaire.

     Autres fonctions de changements de bases :


          COMP2ELE, COMP2PUI, ELE2COMP, ELE2PUI, ELEM,
          MON2SCHUR, MULTI_ELEM, MULTI_PUI, PUI, PUI2COMP,
          PUIREDUC, SCHUR2COMP.


 - Function: PUI2POLYNOME (X,LPUI)
     calcul le polyno^me en X dont les fonctions puissances des racines
     sont donne'es dans la liste LPUI.

          (C6) polynome2ele(x^3-4*x^2+5*x-1,x);
          (D6)                             [3, 4, 5, 1]
          (C7) ele2pui(3,%);
          (D7)                             [3, 4, 6, 7]
          (C8) pui2polynome(x,%);
                                         3      2
          (D8)                          X  - 4 X  + 5 X - 1

     Autres fonctions a` voir :

     POLYNOME2ELE, ELE2POLYNOME.


 - Function: PUI_DIRECT (ORBITE,[lvar1,...,lvarn],[d1,d2,...,dn])
     Soit f un polynome en n blocs de variables lvar1,...,lvarn.  Soit
     ci le nombre de variables dans lvari . Et SC le produit des n
     groupes syme'triques de degre' c1,...,cn. Ce groupe agit
     naturellement sur f La liste ORBITE est l'orbite, note'e SC(f), de
     la fonction f sous l'action de SC. (Cette liste peut e^tre obtenue
     avec la fonction : MULTI_ORBIT).  Les di sont des entiers tels que
     c1<=d1, c2<=d2,...,cn<=dn.  Soit SD le produit des groupes
     syme'triques S_d1 x S_d2 x...x S_dn.

     la fonction pui_direct rame`ne les N premie`res fonctions
     puissances de SD(f) de'duites des fonctions puissances de SC(f)
     ou` N est le cardinal de SD(f).

     Le re'sultat est rendue sous forme multi-contracte'e par rapport a
     SD.  i.e. on ne conserve qu'un e'le'ment par orbite sous l'action
     de SD).

          L:[[x,y],[a,b]]$
          
          PUI_DIRECT(MULTI_ORBIT(a*x+b*y, L), L,[2,2]);
          
                                              2  2
                           [a x, 4 a b x y + a  x ]
          
          PUI_DIRECT(MULTI_ORBIT(a*x+b*y, L), L,[3,2]);
          
                                   2  2     2    2        3  3
            [2 A X, 4 A B X Y + 2 A  X , 3 A  B X  Y + 2 A  X ,
          
              2  2  2  2      3    3        4  4
          12 A  B  X  Y  + 4 A  B X  Y + 2 A  X ,
          
              3  2  3  2      4    4        5  5
          10 A  B  X  Y  + 5 A  B X  Y + 2 A  X ,
          
              3  3  3  3       4  2  4  2      5    5        6  6
          40 A  B  X  Y  + 15 A  B  X  Y  + 6 A  B X  Y + 2 A  X ]
          
           PUI_DIRECT([y+x+2*c, y+x+2*b, y+x+2*a],[[x,y],[a,b,c]],[2,3]);
          
                                       2              2
                [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,
          
                        2                   3        2       2        3
                     9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]
          
          
          PUI_DIRECT([y+x+2*c, y+x+2*b, y+x+2*a],[[x,y],[a,b,c]],[3,4]);


 - Function: PUIREDUC (N,LPUI)
     LPUI est une liste dont le premier e'le'ment est un entier M.
     PUIREDUC donne les N premie`res fonctions puissances en fonction
     des M premie`res.

          PUIREDUC(3,[2]);
          
          						  3
          				      3 p1 p2 - p1
                   		  [2, p1, p2, -------------]
          
          					    2


 - Function: RESOLVANTE (p,x,f,[x1,...,xd])
     calcule la re'solvante du polyno^me p de la variable x et de
     degre' n >= d par la fonction f exprime'e en les variables
     x1,...,xd. Il est important pour l'efficacite' des calculs de ne
     pas mettre dans la liste [x1,...,xd] les variables n'intervenant
     pas dans la fonction de transformation f.

     Afin de rendre plus efficaces les calculs on peut mettre des
     drapeaux a` la variable RESOLVANTE afin que des algorithmes
     ade'quates soient utilise's :

     Si la fonction f est    unitaire :
        * un polyno^me d'une variable,

        *   line'aire ,

        *   alterne'e,

        *   une somme de variables,

        *   syme'trique en les variables qui apparaissent dans son
          expression,

        *   un produit de variables,

        * la fonction de la re'solvante de Cayley (utilisable qu'en
          degre' 5)

               (x1*x2+x2*x3+x3*x4+x4*x5+x5*x1 -
                    (x1*x3+x3*x5+x5*x2+x2*x4+x4*x1))^2

          generale,
     le drapeau de RESOLVANTE pourra e^tre respectivement :
        *   unitaire,

        *   lineaire,

        *   alternee,

        *   somme,

        *   produit,

        *   cayley,

        *   generale.


           resolvante:unitaire;
          resolvante(x^7-14*x^5  + 56*x^3  - 56*X + 22,x,x^3-1,[x]);
          
            7      6        5         4          3           2
          Y  + 7 Y  - 539 Y  - 1841 Y  + 51443 Y  + 315133 Y  + 376999 Y
          
           + 125253
          
          resolvante : lineaire;
          resolvante(x^4-1,x,x1+2*x2+3*x3,[x1,x2,x3]);
          
           24       20         16            12             8              4
          Y   + 80 Y   + 7520 Y   + 1107200 Y   + 49475840 Y  + 344489984 Y
          							 + 655360000
          	       Meme solution pour :
          resolvante : general;
          resolvante(x^4-1,x,x1+2*x2+3*x3,[x1,x2,x3]);
          resolvante(x^4-1,x,x1+2*x2+3*x3,[x1,x2,x3,x4])
          direct([x^4-1],x,x1+2*x2+3*x3,[[x1,x2,x3]]);
          
          resolvante:lineaire$
          resolvante(x^4-1,x,x1+x2+x3,[x1,x2,x3);
          
          			       4
          			      Y  - 1
          
          resolvante:symetrique$
          
          resolvante(x^4-1,x,x1+x2+x3,[x1,x2,x3]);
          
          			       4
          			      Y  - 1
          resolvante(x^4+x+1,x,x1-x2,[x1,x2]);
          	  12      8       6        4        2
          	 Y   + 8 Y  + 26 Y  - 112 Y  + 216 Y  + 229
          
          resolvante:alternee$
          resolvante(x^4+x+1,x,x1-x2,[x1,x2]);
          
          	  12      8       6        4        2
          	 Y   + 8 Y  + 26 Y  - 112 Y  + 216 Y  + 229
          
          
          resolvante:produit;
          resolvante(x^7-7*x+3,x,x1*x2*x3,[x1,x2,x3]);
          
             35      33         29        28         27        26         24
            Y   - 7 Y   - 1029 Y   + 135 Y   + 7203 Y   - 756 Y   + 1323 Y
          
                    23          22            21           20          19
          + 352947 Y   - 46305 Y   - 2463339 Y   + 324135 Y   - 30618 Y
          
          	  18
          - 453789 Y
          
          	    17              15             14              12
          - 40246444 Y   + 282225202 Y   - 44274492 Y   + 155098503 Y
          
                      11
          + 12252303 Y
          
          	   10              9            8            7             6
          + 2893401 Y   - 171532242 Y  + 6751269 Y  + 2657205 Y  - 94517766 Y
          
          	   5             3
          - 3720087 Y  + 26040609 Y  + 14348907
          
             resolvante:symetrique$
            resolvante(x^7-7*x+3,x,x1*x2*x3,[x1,x2,x3]);
          
            35      33         29        28         27        26         24
           Y   - 7 Y   - 1029 Y   + 135 Y   + 7203 Y   - 756 Y   + 1323 Y
          
                    23          22            21           20          19
          + 352947 Y   - 46305 Y   - 2463339 Y   + 324135 Y   - 30618 Y
          
                     18
           - 453789 Y
          
                      17              15             14              12
          - 40246444 Y   + 282225202 Y   - 44274492 Y   + 155098503 Y
          
                       11
           + 12252303 Y
          
                     10              9            8            7             6
          + 2893401 Y   - 171532242 Y  + 6751269 Y  + 2657205 Y  - 94517766 Y
          
                     5             3
          - 3720087 Y  + 26040609 Y  + 14348907
          
          resolvante:cayley$
          resolvante(x^5-4*x^2+x+1,x,a,[]);
          
          " resolvante de Cayley "
          
           6       5         4          3            2
          X  - 40 X  + 4080 X  - 92928 X  + 3772160 X  + 37880832 X + 93392896
     Pour la re'solvante de Cayley, les 2 derniers arguments sont
     neutres et le polyno^me donne' en entre'e doit ne'cessairement
     e^tre de degre' 5.

     Voir e'galement :

          RESOLVANTE_BIPARTITE, RESOLVANTE_PRODUIT_SYM,
          RESOLVANTE_UNITAIRE, RESOLVANTE_ALTERNEE1, RESOLVANTE_KLEIN,
          RESOLVANTE_KLEIN3, RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE.


 - Function: RESOLVANTE_ALTERNEE1 (p,x)
     calcule la transformation de p(x) de degre n par la fonction
     $\prod_{1\leq i<j\leq n-1} (x_i-x_j)$.

     Voir e'galement :

          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE , RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE, RESOLVANTE_BIPARTITE.


 - Function: RESOLVANTE_BIPARTITE (p,x)
     calcule la transformation de p(x) de degre n (n pair) par la
     fonction          $x_1x_2\ldots x_{n/2}+x_{n/2+1}\ldotsx_n$

     Voir e'galement :

          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE , RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE,RESOLVANTE_ALTERNEE1

           RESOLVANTE_BIPARTITE(x^6+108,x);
          
                           10        8           6             4
                          Y   - 972 Y  + 314928 Y  - 34012224 Y
     Voir e'galement :

          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE, RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE,
          RESOLVANTE_ALTERNEE1.


 - Function: RESOLVANTE_DIEDRALE (p,x)
     calcule la transformation de p(x) par la fonction x_1x_2+x_3x_4.

          resolvante_diedrale(x^5-3*x^4+1,x);
          
           15       12       11       10        9         8         7        6
          X   - 21 X   - 81 X   - 21 X   + 207 X  + 1134 X  + 2331 X  - 945 X
          
                     5          4          3          2
             - 4970 X  - 18333 X  - 29079 X  - 20745 X  - 25326 X - 697
     Voir e'galement :

          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE_ALTERNEE1, RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE.


 - Function: RESOLVANTE_KLEIN (p,x)
     calcule la transformation de p(x) par la fonction x_1x_2x_4+x_4.

     Voir e'galement :

          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE_ALTERNEE1, RESOLVANTE, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE.


 - Function: RESOLVANTE_KLEIN3 (p,x)
     calcule la transformation de p(x) par la fonction x_1x_2x_4+x_4.

     Voir e'galement :

          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE_ALTERNEE1, RESOLVANTE_KLEIN, RESOLVANTE,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE.


 - Function: RESOLVANTE_PRODUIT_SYM (p,x)
     calcule la liste toutes les r\'esolvantes produit du polyn\^ome
     p(x).

            resolvante_produit_sym(x^5+3*x^4+2*x-1,x);
          
            5      4             10      8       7       6       5    4
          [Y  + 3 Y  + 2 Y - 1, Y   - 2 Y  - 21 Y  - 31 Y  - 14 Y  - Y
          
                3
          + 14 Y
          
                2       10      8       7    6       5       4       3      2
          + 3 Y  + 1, Y   + 3 Y  + 14 Y  - Y  - 14 Y  - 31 Y  - 21 Y  - 2 Y
          
                5      4
          + 1, Y  - 2 Y  - 3 Y - 1, Y - 1]
          
          
          resolvante:produit$
          esolvante(x^5+3*x^4+2*x-1,x,a*b*c,[a,b,c]);
          
           10      8       7    6       5       4       3      2
          Y   + 3 Y  + 14 Y  - Y  - 14 Y  - 31 Y  - 21 Y  - 2 Y  + 1
     Voir e'galement :
          RESOLVANTE, RESOLVANTE_UNITAIRE,
          RESOLVANTE_ALTERNEE1, RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE.


 - Function: RESOLVANTE_UNITAIRE (p,q,x)
     calcule la r\'esolvante du polyn\^ome p(x) par le polyn\^ome q(x).

     Voir e'galement :
          RESOLVANTE_PRODUIT_SYM, RESOLVANTE,
          RESOLVANTE_ALTERNEE1, RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE_VIERER, RESOLVANTE_DIEDRALE.


 - Function: RESOLVANTE_VIERER (p,x)
     calcule la transformation de p(x) par la fonction x_1x_2-x_3x_4.

     Voir e'galement :
          RESOLVANTE_PRODUIT_SYM, RESOLVANTE_UNITAIRE,
          RESOLVANTE_ALTERNEE1, RESOLVANTE_KLEIN, RESOLVANTE_KLEIN3,
          RESOLVANTE, RESOLVANTE_DIEDRALE.


 - Function: SCHUR2COMP (P,l_var)
     : P est un polyno^mes en les variables contenues dans la liste
     l_var. Chacune des variables de l_var repre'sente une fonction
     syme'trique comple`te. On repre'sente dans l_var la ie`me fonction
     syme'trique comple`te comme la concate'nation de la lettre h avec
     l'entier i : hi.  Cette fonction donne l'expression de P en
     fonction des fonctions de Schur.

            SCHUR2COMP(h1*h2-h3,[h1,h2,h3]);
          
          
           				    s
          				     1, 2
          
           SCHUR2COMP(a*h3,[h3]);
          
           				      s  a
          				       3


 - Function: SOMRAC (liste,K)
     la liste contient les fonctions syme'triques e'le'mentaires d'un
     polyno^me P . On calcul le polyno^mes dont les racines sont les
     sommes K a` K distinctes des racines de P.

     Voir e'galement PRODRAC.


 - Function: TCONTRACT (pol,lvar)
     teste si le polyno^me pol est syme'trique en les variables
     contenues dans la liste lvar. Si oui il rend une forme contracte'e
     comme la fonction CONTRACT.

     Autres fonctions de changements de repre'sentations :

     CONTRACT, CONT2PART, EXPLOSE, PART2CONT, PARTPOL, TPARTPOL.


 - Function: TPARTPOL (pol,lvar)
     teste si le polyno^me pol est syme'trique en les variables
     contenues dans la liste lvar. Si oui il rend sa forme partionne'e
     comme la fonction PARTPOL.

     Autres fonctions de changements de repre'sentations :

     CONTRACT, CONT2PART, EXPLOSE, PART2CONT, PARTPOL, TCONTRACT.


 - Function: TREILLIS (n)
     rame`ne toutes les partitions de poids n.

           treillis(4);
          
                      [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     Voir e'galement : LGTREILLIS, LTREILLIS et TREINAT.


 - Function: TREINAT
     TREINAT(part)  rame`ne la liste des partitions infe'rieures a` la
     partition   part pour l'ordre naturel.

             treinat([5]);
          
                                         [[5]]
             treinat([1,1,1,1,1]);
          
              [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],
          
               [1, 1, 1, 1, 1]]
          
             treinat([3,2]);
          
                                  [[5], [4, 1], [3, 2]]
     Voir e'galement : LGTREILLIS, LTREILLIS et TREILLIS.


File: maxima.info,  Node: Groups,  Next: Runtime Environment,  Prev: Symmetries,  Up: Top

Groups
******

* Menu:

* Definitions for Groups::


File: maxima.info,  Node: Definitions for Groups,  Prev: Groups,  Up: Groups

Definitions for Groups
======================

 - Function: TODD_COXETER (relations,subgroup)
     Find the order of G/H where G is the Free Group modulo RELATIONS,
     and H is the subgroup of G generated by SUBGROUP.  SUBGROUP is an
     optional argument, defaulting to [].  In doing this it produces a
     multiplication table for the right action of G on G/H, where the
     cosets are enumerated [H,Hg2,Hg3,...]  This can be seen internally
     in the $todd_coxeter_state.  The multiplication tables for the
     variables are in table:todd_coxeter_state[2] Then table[i] gives
     the table for the ith variable.  mulcoset(coset,i) :=
     table[varnum][coset];

     Example:

          (C1) symet(n):=create_list(if (j - i) = 1 then (p(i,j))^^3 else
               if (not i = j) then (p(i,j))^^2 else p(i,i) , j,1,n-1,i,1,j);
          						      <3>
          (D1) SYMET(N) := CREATE_LIST(IF J - I = 1 THEN P(I, J)
          
          			       <2>
           ELSE (IF NOT I = J THEN P(I, J)
           ELSE P(I, I)), J, 1, N - 1, I, 1, J)
          (C2) p(i,j) :=concat(x,i).concat(x,j);
          (D2)                P(I, J) := CONCAT(X, I) . CONCAT(X, J)
          (C3) symet(5);
                                  <3>                    <2>           <3>
          (D3) [X1 . X1, (X1 . X2)   , X2 . X2, (X1 . X3)   , (X2 . X3)   ,
          
                                <2>                <2>           <3>
          X3 . X3,     (X1 . X4)	 , (X2 . X4)   , (X3 . X4)   , X4 . X4]
          (C4) todd_coxeter(d3);
          
          Rows tried 426
          (D4) 				      120
          (C5) todd_coxeter(d3,[x1]);
          
          Rows tried 213
          (D5) 				      60
          (C6) todd_coxeter(d3,[x1,x2]);
          
          Rows tried 71
          (D6) 				      20
          (C7) table:todd_coxeter_state[2]$
          (C8) table:todd_coxeter_state[2]$
          (C9) table[1];
          (D9) {Array: FIXNUM #(0 2 1 3 7 6 5 4 8 11 17 9 12 14 13 20
                     16 10 18 19 15 0 0 0 0 0 0 0 0  0 0 0 0 0 0 0)}

     Note only the elements 1 thru 20 of this array d9  are meaningful.
     table[1][4] = 7 indicates coset4.var1 = coset7



File: maxima.info,  Node: Runtime Environment,  Next: Miscellaneous Options,  Prev: Groups,  Up: Top

Runtime Environment
*******************

* Menu:

* Introduction for Runtime Environment::
* INTERRUPTS::
* Definitions for Runtime Environment::


File: maxima.info,  Node: Introduction for Runtime Environment,  Next: INTERRUPTS,  Prev: Runtime Environment,  Up: Runtime Environment

Introduction for Runtime Environment
====================================

- A file which is loaded automatically for you when you start up a
MACSYMA, to customize MACSYMA for you.  It is possible to have an init
file written as a BATCH file of macsyma commands.  We hope this makes
it easier for users to customize their macsyma environment.  Here is an
example init file
             /*-*-macsyma-*-*/
             setup_autoload("share\;bessel",j0,j1,jn);
             showtime:all; comgrind:true;
   The strange looking comment at the top of the file
"/*-*-macsyma-*-*/" tells that it is a macsyma-language file.  Also:
"SETUP_AUTOLOAD" can be used to make functions in BATCH files
autoloading, meaning that you can then use (for instance, here) the
functions J0, J1 and Jn from the BESSEL package directly because when
you use the function the BESSEL package will be loaded in for you
automatically.  If the second file name in the argument to
SETUP_AUTOLOAD is not specified (the preferred usage) then the standard
search for second file names of "FASL", "TRLISP", and ">" is done.


File: maxima.info,  Node: INTERRUPTS,  Next: Definitions for Runtime Environment,  Prev: Introduction for Runtime Environment,  Up: Runtime Environment

INTERRUPTS
==========

- There are several ways the user can interrupt a MACSYMA computation,
usually with a control character.  Do DESCRIBE(CHARACTERS); for details.
MACSYMA will also be interrupted if ^Z (control-Z) is typed, as this
will exit back to Unix shell level Usually Control-C interrupts the
computation putting you in a break loop.  Typing :t should give you top
level maxima back again.


File: maxima.info,  Node: Definitions for Runtime Environment,  Prev: INTERRUPTS,  Up: Runtime Environment

Definitions for Runtime Environment
===================================

 - Function: ALARMCLOCK (arg1, arg2, arg3)
     will execute the function of no arguments whose name is arg3 when
     the time specified by arg1 and arg2 elapses.  If arg1 is the atom
     "TIME" then arg3 will be executed after arg2 seconds of real-time
     has elapsed while if arg1 is the atom "RUNTIME" then arg3 will be
     executed after arg2 milliseconds of cpu time. If arg2 is negative
     then the arg1 timer is shut off.


 - Function: ALLOC
     takes any number of arguments which are the same as the replies to
     the "run out of space" question.  It increases allocations
     accordingly.  E.g. If the user knows initially that his problem
     will require much space, he can say ALLOC(4); to allocate the
     maximum amount initially.  See also the DYNAMALLOC switch.


 - Function: BUG ("message")
     similar to mail, sends a message to MACSYMA Mail.  This may be
     used for reporting bugs or suspected bugs in MACSYMA.  Expressions
     may be included by referring to them, outside double quotes, e.g.
     BUG("I am trying to integrate",D3,"but it asks for more list space.
     What should I do?");


 - Function: CLEARSCREEN ()
     Clears the screen.  The same as typing control-L.


 - Function: CONTINUE
     - Control-^ typed while in MACSYMA causes LISP to be entered.  The
     user can now type any LISP S-expression and have it evaluated.
     Typing (CONTINUE) or ^G (control-G) causes MACSYMA to be
     re-entered.


 - Function: DDT ()
     Exits from MACSYMA to the operating system level.  (The same as
     control-Z on ITS, or control-C on Tops-20.)


 - Function: DELFILE (file-specification)
     will delete the file given by the file-specification (i.e.
     firstname, secondname, device, user) from the given device.


 - Function: DISKFREE ()
     With no args or an arg of TRUE, will return the total number of
     free blocks of disk space in the system.  With an arg of 0, 1, or
     13, it will return the number of free blocks of diskspace on the
     respective disk pack.  With an arg of SECONDARY or PRIMARY, it will
     return the total number of free blocks of disk space on the
     secondary or primary disk pack respectively.


 - declaration: FEATURE
     - A nice adjunct to the system.  STATUS(FEATURE) gives you a list
     of system features. At present the list for MC is: MACSYMA,
     NOLDMSG, MACLISP, PDP10, BIGNUM, FASLOAD, HUNK, FUNARG, ROMAN,
     NEWIO, SFA, PAGING, MC, and ITS.  Any of these "features" may be
     given as a second argument to STATUS(FEATURE,...); If the
     specified feature exists, TRUE will be returned, else FALSE.
     Note: these are system features, and not really "user related".
     See also DESCRIBE(features); for more user-oriented features.


 - Function: FEATUREP (a,f)
     attempts to determine whether the object a has the feature f on
     the basis of the facts in the current data base.  If so, it
     returns TRUE, else FALSE.  See DESCRIBE(FEATURES); .
          (C1) DECLARE(J,EVEN)$
          (C2) FEATUREP(J,INTEGER);
          (D2)                                TRUE

 - Function: ROOM ()
     types out a verbose description of the state of storage and stack
     management in the Macsyma.  This simply utilizes the Lisp ROOM
     function.  ROOM(FALSE) - types out a very terse description,
     containing most of the same information.


 - Function: STATUS (arg)
     will return miscellaneous status information about the user's
     MACSYMA depending upon the arg given.  Permissible arguments and
     results are as follows:
        * TIME - the time used so far in the computation.

        * DAY - the day of the week.

        * DATE - a list of the year, month, and day.

        * DAYTIME - a list of the hour, minute, and second.

        * RUNTIME - accumulated cpu time times the atom "MILLISECONDS"
          in the current    MACSYMA.

        * REALTIME - the real time (in sec) elapsed since the user
          started up    his MACSYMA.

        * GCTIME - the garbage collection time used so far in the
          current    computation.

        * TOTALGCTIME - gives the total garbage collection time used in
          MACSYMA    so far.

        * FREECORE - the number of blocks of core your MACSYMA can
          expand    before it runs out of address space.  (A block is
          1024 words.)     Subtracting that value from 250*BLOCKS (the
          maximum you can get on MC)    tells you how many blocks of
          core your MACSYMA is using up.  (A    MACSYMA with no "fix"
          file starts at approx. 191 blocks.)

        * FEATURE - gives you a list of system features. At present the
          list for    MC is: MACSYMA, NOLDMSG, MACLISP, PDP10, BIGNUM,
          FASLOAD, HUNK,    FUNARG, ROMAN, NEWIO, SFA, PAGING, MC, and
          ITS.  Any of these    "features" may be given as a second
          argument to STATUS(FEATURE,...);    If the specified feature
          exists, TRUE will be returned, else FALSE.     Note: these
          are system features, and not really "user related".
     For information about your files, see the FILEDEFAULTS(); command.


 - Function: TIME (Di1, Di2, ...)
     gives a list of the times in milliseconds taken to compute the Di.
     (Note: the Variable SHOWTIME, default: [FALSE], may be set to
     TRUE to have computation times printed out with each D-line.)



File: maxima.info,  Node: Miscellaneous Options,  Next: Rules and Patterns,  Prev: Runtime Environment,  Up: Top

Miscellaneous Options
*********************

* Menu:

* Introduction to Miscellaneous Options::
* SHARE::
* Definitions for Miscellaneous Options::


File: maxima.info,  Node: Introduction to Miscellaneous Options,  Next: SHARE,  Prev: Miscellaneous Options,  Up: Miscellaneous Options

Introduction to Miscellaneous Options
=====================================

In this section various options are discussed which have a global effect
on the operation of maxima.   Also various lists such as the list of all
user defined functions, are discussed.


File: maxima.info,  Node: SHARE,  Next: Definitions for Miscellaneous Options,  Prev: Introduction to Miscellaneous Options,  Up: Miscellaneous Options

SHARE
=====

- The SHARE directory on MC or on a DEC20 version of MACSYMA contains
programs, information files, etc.  which are considered to be of
interest to the MACSYMA community.  Most files on SHARE; are not part
of the MACSYMA system per se and must be loaded individually by the
user, e.g.  LOADFILE("array");. Many files on SHARE; were contributed
by MACSYMA users.  Do PRINTFILE(SHARE,USAGE,SHARE); for more details
and the conventions for contributing to the SHARE directory.  For an
annotated "table of contents" of the directory, do:
PRINTFILE(SHARE,>,SHARE);


File: maxima.info,  Node: Definitions for Miscellaneous Options,  Prev: SHARE,  Up: Miscellaneous Options

Definitions for Miscellaneous Options
=====================================

 - Variable: ALIASES
     default: [] atoms which have a user defined alias (set up by the
     ALIAS, ORDERGREAT, ORDERLESS functions or by DECLAREing the atom a
     NOUN).

 - Variable: ALLSYM
     default: [TRUE] - If TRUE then all indexed objects are assumed
     symmetric in all of their covariant and contravariant indices. If
     FALSE then no symmetries of any kind are assumed in these indices.
     Derivative indices are always taken to be symmetric.

 - declaration: ALPHABETIC
     Adds to MACSYMA's alphabet which initially contains the letters
     A-Z, % and _.  Thus, DECLARE("~",ALPHABETIC) enables NEW~VALUE to
     be used as a name.


 - Function: APROPOS (string)
     takes a character string as argument and looks at all the MACSYMA
     names for ones with that string appearing anywhere within them.
     Thus, APROPOS(EXP); will return a long list of all the flags and
     functions which have EXP as part of their names, such as EXPAND,
     EXP, EXPONENTIALIZE.  Thus if you can only remember part of the
     name of something you can use this command to find the rest of the
     name.  Similarily, you could say APROPOS(TR_); to find a list of
     many of the switches relating to the TRANSLATOR (most of which
     begin with TR_).


 - Function: ARGS (exp)
     returns a list of the args of exp.  I.e. it is essentially
     equivalent to
          SUBSTPART("[",exp,0)
     Both ARGS and SUBSTPART depend on the setting of INFLAG.


 - Function: DUMMY (i1,i2,...)
     will set each index i1,i2,... to name of the form !n where n is a
     positive integer.  This guarantees that dummy indices which are
     needed in forming expressions will not conflict with indices
     already in use.  COUNTER[default 1] determines the numerical
     suffix to be used in generating the next dummy index.  The prefix
     is determined by the option DUMMYX[!].


 - Variable: GENINDEX
     default: [I] is the alphabetic prefix used to generate the next
     variable of summation when necessary.


 - Variable: GENSUMNUM
     [0] is the numeric suffix used to generate the next variable of
     summation.  If it is set to FALSE then the index will consist only
     of GENINDEX with no numeric suffix.


 - Variable: INF
     - real positive infinity.


 - Variable: INFINITY
     - complex infinity, an infinite magnitude of arbitrary phase
     angle.  (See also INF and MINF.)


 - Variable: INFOLISTS
     default: [] a list of the names of all of the information lists in
     MACSYMA. These are: LABELS - all bound C,D, and E labels.  VALUES
     - all bound atoms, i.e. user variables, not MACSYMA Options or
     Switches, (set up by : , :: , or functional binding).  FUNCTIONS -
     all user defined functions (set up by f(x):=...).  ARRAYS -
     declared and undeclared arrays (set up by : , :: , or :=...)
     MACROS - any Macros defined by the user.  MYOPTIONS - all options
     ever reset by the user (whether or not they get reset to their
     default value).  RULES - user defined pattern matching and
     simplification rules (set up by TELLSIMP, TELLSIMPAFTER, DEFMATCH,
     or, DEFRULE.)  ALIASES - atoms which have a user defined alias
     (set up by the ALIAS, ORDERGREAT, ORDERLESS functions or by
     DECLAREing the atom a NOUN).  DEPENDENCIES - atoms which have
     functional dependencies (set up by the DEPENDS or GRADEF
     functions).  GRADEFS - functions which have user defined
     derivatives (set up by the GRADEF function).  PROPS - atoms which
     have any property other than those mentioned above, such as
     atvalues, matchdeclares, etc.  as well as properties specified in
     the DECLARE function.  LET_RULE_PACKAGES - a list of all the
     user-defined let rule packages plus the special package
     DEFAULT_LET_RULE_PACKAGE.  (DEFAULT_LET_RULE_PACKAGE is the name
     of the rule package used when one is not explicitly set by the
     user.)


 - Function: INTEGERP (exp)
     is TRUE if exp is an integer else FALSE.


 - Variable: M1PBRANCH
     default: [FALSE] - "principal branch for -1 to a power".
     Quantities such as (-1)^(1/3) [i.e. "odd" rational exponent] and
     (-1)^(1/4) [i.e. "even" rational exponent] are now handled as
     indicated in the following chart:
                       DOMAIN:REAL(default)
          
          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)
          
                          DOMAIN:COMPLEX
          M1PBRANCH:FALSE(default)   M1PBRANCH:TRUE
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

 - Function: NUMBERP (exp)
     is TRUE if exp is an integer, a rational number, a floating point
     number or a bigfloat else FALSE.


 - Function: PROPERTIES (a)
     will yield a list showing the names of all the properties
     associated with the atom a.


 - special symbol: PROPS
     - atoms which have any property other than those explicitly
     mentioned in INFOLISTS, such as atvalues, matchdeclares, etc. as
     well as properties specified in the DECLARE function.


 - Function: PROPVARS (prop)
     yields a list of those atoms on the PROPS list which have the
     property indicated by prop.  Thus PROPVARS(ATVALUE) will yield a
     list of atoms which have atvalues.


 - Function: PUT (a, p, i)
     associates with the atom a the property p with the indicator i.
     This enables the user to give an atom any arbitrary property.


 - Function: QPUT (a, p, i)
     is similar to PUT but it doesn't have its arguments evaluated.


 - Function: REM (a, i)
     removes the property indicated by i from the atom a.


 - Function: REMOVE (args)
     will remove some or all of the properties associated with
     variables or functions.  REMOVE(a1, p1, a2, p2, ...)  removes the
     property pi from the atom ai.  Ai and pi may also be lists as with
     DECLARE.  Pi may be any property e.g.  FUNCTION, MODE_DECLARE,
     etc.  It may also be TRANSFUN implying that the translated LISP
     version of the function is to be removed.  This is useful if one
     wishes to have the MACSYMA version of the function executed rather
     than the translated version. Pi may also be OP or OPERATOR to
     remove a syntax extension given to ai (see Appendix II).  If ai is
     "ALL" then the property indicated by pi is removed from all atoms
     which have it.  Unlike the more specific remove functions
     (REMVALUE, REMARRAY, REMFUNCTION, and REMRULE) REMOVE does not
     indicate when a given property is non-existent; it always returns
     "DONE".


 - Function: REMVALUE (name1, name2, ...)
     removes the values of user variables (which can be subscripted)
     from the system.  If name is ALL then the values of all user
     variables are removed.  Values are those items given names by the
     user as opposed to those which are automatically labeled by
     MACSYMA as Ci, Di, or Ei.


 - Function: RENAME (exp)
     returns an expression equivalent to exp but with the dummy indices
     in each term chosen from the set [!1,!2,...].  Each dummy index in
     a product will be different; for a sum RENAME will try to make
     each dummy index in a sum the same.  In addition, the indices will
     be sorted alphanumerically.


 - Function: RNCOMBINE (exp)
     transforms exp by combining all terms of exp that have identical
     denominators or denominators that differ from each other by
     numerical factors only.  This is slightly different from the
     behavior of COMBINE, which collects terms that have identical
     denominators.  Setting PFEFORMAT:TRUE and using COMBINE will
     achieve results similar to those that can be obtained with
     RNCOMBINE, but RNCOMBINE takes the additional step of
     cross-multiplying numerical denominator factors.  This results in
     neater forms, and the possiblity of recognizing some
     cancellations.  Bugs to ASB.


 - Function: SCALARP (exp)
     is TRUE if exp is a number, constant, or variable DECLAREd SCALAR,
     or composed entirely of numbers, constants, and such variables,
     but not containing matrices or lists.


 - Function: SCALEFACTORS (coordinatetransform)
     Here coordinatetransform evaluates to the form [[expression1,
     expression2, ...], indeterminate1, indeterminat2, ...], where
     indeterminate1, indeterminate2, etc. are the curvilinear
     coordinate variables and where a set of rectangular Cartesian
     components is given in terms of the curvilinear coordinates by
     [expression1, expression2, ...].  COORDINATES is set to the vector
     [indeterminate1, indeterminate2,...], and DIMENSION is set to the
     length of this vector.  SF[1], SF[2], ..., SF[DIMENSION] are set
     to the coordinate scale factors, and SFPROD is set to the product
     of these scale factors.  Initially, COORDINATES is [X, Y, Z],
     DIMENSION is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1, corresponding to
     3-dimensional rectangular Cartesian coordinates.  To expand an
     expression into physical components in the current coordinate
     system, there is a function with usage of the form


 - Function: SETUP_AUTOLOAD (file,func1,...,funcN)
     which takes two or more arguments: a file specification, and one
     or more function names, "funcI", and which indicates that if a
     call to "funcI" is made and "funcI" is not defined, that the file
     specified by "file" is to be automatically loaded in via LOAD,
     which file should contain a definition for "funcI".  (This is the
     process by which calling e.g.  INTEGRATE in a fresh MACSYMA causes
     various files to be loaded in.)  As with the other file-handling
     commands in MACSYMA, the arguments to SETUP_AUTOLOAD are not
     evaluated.  Example: SETUP_AUTOLOAD("bessel")$ J1(0.0); .  Note:
     SETUP_AUTOLOAD does not work for array functions.



File: maxima.info,  Node: Rules and Patterns,  Next: Lists,  Prev: Miscellaneous Options,  Up: Top

Rules and Patterns
******************

* Menu:

* Introduction to Rules and Patterns::
* Definitions for Rules and Patterns::


File: maxima.info,  Node: Introduction to Rules and Patterns,  Next: Definitions for Rules and Patterns,  Prev: Rules and Patterns,  Up: Rules and Patterns

Introduction to Rules and Patterns
==================================

This section discusses user defined pattern matching and simplification
rules (set up by TELLSIMP, TELLSIMPAFTER, DEFMATCH, or, DEFRULE.)  You
may affect the main simplification procedures, or else have your rules
applied explicityly using APPLY1 and APPLY2.     There are additional
mechanisms for polynomials rules under TELLRAT, and for commutative and
non commutative algebra in chapter on AFFINE.


File: maxima.info,  Node: Definitions for Rules and Patterns,  Prev: Introduction to Rules and Patterns,  Up: Rules and Patterns

Definitions for Rules and Patterns
==================================

 - Function: APPLY1 (exp, rule1, ..., rulen)
     repeatedly applies the first rule to exp until it fails, then
     repeatedly applies the same rule to all subexpressions of exp,
     left-to-right, until the first rule has failed on all
     subexpressions.  Call the result of transforming exp in this
     manner exp'.  Then the second rule is applied in the same fashion
     starting at the top of exp'.  When the final rule fails on the
     final subexpression, the application is finished.


 - Function: APPLY2 (exp, rule1, ..., rulen)
     differs from APPLY1 in that if the first rule fails on a given
     subexpression, then the second rule is repeatedly applied, etc.
     Only if they all fail on a given subexpression is the whole set of
     rules repeatedly applied to the next subexpression.  If one of the
     rules succeeds, then the same subexpression is reprocessed,
     starting with the first rule.  MAXAPPLYDEPTH[10000] is the maximum
     depth to which APPLY1 and APPLY2 will delve.


 - Function: APPLYB1 (exp, rule1, ..., rulen)
     is similar to APPLY1 but works from the "bottom up" instead of
     from the "top down".  That is, it processes the smallest
     subexpression of exp, then the next smallest, etc.
     MAXAPPLYHEIGHT[10000] - is the maximum height to which APPLYB1 will
     reach before giving up.


 - Variable: CURRENT_LET_RULE_PACKAGE
     default:[DEFAULT_LET_RULE_PACKAGE] - the name of the rule package
     that is presently being used.  The user may reset this variable to
     the name of any rule package previously defined via the LET
     command.  Whenever any of the functions comprising the let package
     are called with no package name the value of
          CURRENT_LET_RULE_PACKAGE
     is used.  If a call such as LETSIMP(expr,rule_pkg_name); is made,
     the rule package rule_pkg_name is used for that LETSIMP command
     only, i.e.  the value of CURRENT_LET_RULE_PACKAGE is not changed.


 - Variable: DEFAULT_LET_RULE_PACKAGE
     - the name of the rule package used when one is not explicitly set
     by the user with LET or by changing the value of
     CURRENT_LET_RULE_PACKAGE.


 - Function: DEFMATCH (progname, pattern, parm1, ..., parmn)
     creates a function of n+1 arguments with the name progname which
     tests an expression to see if it can match a particular pattern.
     The pattern is some expression containing pattern variables and
     parameters.  The parms are given explicitly as arguments to
     DEFMATCH while the pattern variables (if supplied) were given
     implicitly in a previous MATCHDECLARE function.  The first
     argument to the created function progname, is an expression to be
     matched against the "pattern" and the other n arguments are the
     actual variables occurring in the expression which are to take the
     place of dummy variables occurring in the "pattern".  Thus the
     parms in the DEFMATCH are like the dummy arguments to the
     SUBROUTINE statement in FORTRAN.  When the function is "called"
     the actual arguments are substituted.  For example:
          (C1)  NONZEROANDFREEOF(X,E):=  IF E#0 AND FREEOF(X,E)
                      THEN TRUE ELSE FALSE$
          (IS(E#0 AND FREEOF(X,E)) is an  equivalent function
          definition)
          (C2)  MATCHDECLARE(A,NONZEROANDFREEOF(X),B,FREEOF(X))$
          (C3)  DEFMATCH(LINEAR,A*X+B,X)$
              This has caused the function LINEAR(exp,var1) to be defined.  It

     tests exp to see if it is of the form A*var1+B where A and B do not
     contain var1 and A is not zero.  DEFMATCHed functions return (if
     the match is successful) a list of equations whose left sides are
     the pattern variables and parms and whose right sides are the
     expressions which the pattern variables and parameters matched.
     The pattern variables, but not the parameters, are set to the
     matched expressions.  If the match fails, the function returns
     FALSE.  Thus LINEAR(3*Z+(Y+1)*Z+Y**2,Z) would return [B=Y**2,
     A=Y+4, X=Z].  Any variables not declared as pattern variables in
     MATCHDECLARE or as parameters in DEFMATCH which occur in pattern
     will match only themselves so that if the third argument to the
     DEFMATCH in (C4) had been omitted, then LINEAR would only match
     expressions linear in X, not in any other variable.      A pattern
     which contains no parameters or pattern variables returns TRUE if
     the match succeeds.  Do EXAMPLE(DEFMATCH); for more examples.


 - Function: DEFRULE (rulename, pattern, replacement)
     defines and names a replacement rule for the given pattern.  If
     the rule named rulename is applied to an expression (by one of the
     APPLY functions below), every subexpression matching the pattern
     will be replaced by the replacement.  All variables in the
     replacement which have been assigned values by the pattern match
     are assigned those values in the replacement which is then
     simplified.  The rules themselves can be treated as functions
     which will transform an expression by one operation of the pattern
     match and replacement.  If the pattern fails, the original
     expression is returned.


 - Function: DISPRULE (rulename1, rulename2, ...)
     will display rules with the names rulename1, rulename2, as were
     given by DEFRULE, TELLSIMP, or TELLSIMPAFTER or a pattern defined
     by DEFMATCH.  For example, the first rule modifying SIN will be
     called SINRULE1.  DISPRULE(ALL); will display all rules.


 - Function: LET (prod, repl, predname, arg1, arg2, ..., argn)
     defines a substitution rule for LETSIMP such that prod gets
     replaced by repl.  prod is a product of positive or negative
     powers of the following types of terms:
        *     (1) Atoms which LETSIMP will search for literally unless
          previous to calling LETSIMP the MATCHDECLARE function is used
          to associate a predicate with the atom.  In this case LETSIMP
          will match the atom to any term of a product satisfying the
          predicate.

        *     (2) Kernels such as SIN(X), N!, F(X,Y), etc.  As with
          atoms above LETSIMP will look for a literal match unless
          MATCHDECLARE is used to associate a predicate with the
          argument of the kernel.  A term to a positive power will only
          match a term having at least that power in the expression
          being LETSIMPed.  A term to a negative power on the other
          hand will only match a term with a power at least as
          negative.  In the case of negative powers in "product" the
          switch LETRAT must be set to TRUE (see below).  If a
          predicate is included in the LET function followed by a list
          of arguments, a tentative match (i.e. one that would be
          accepted if the predicate were omitted) will be accepted only
          if predname(arg1',...,argn') evaluates to TRUE where argi' is
          the value matched to argi.  The argi may be the name of any
          atom or the argument of any kernel appearing in prod.  repl
          may be any rational expression.  If any of the atoms or
          arguments from prod appear in repl the appropriate
          substitutions will be made.
         LETRAT[FALSE] when FALSE, LETSIMP will simplify the numerator
     and denominator of expr independently and return the result.
     Substitutions such as N!/N goes to (N-1)!  will fail.  To handle
     such situations LETRAT should be set to TRUE, then the numerator,
     denominator, and their quotient will be simplified in that order.
        These substitution functions allow you to work with several
     rulepackages at once. Each rulepackage can contain any number of
     LETed rules and is referred to by a user supplied name.  To insert
     a rule into the rulepackage name, do
     LET([prod,repl,pred,arg1,...],name).  To apply the rules in
     rulepackage name, do LETSIMP(expr, name).  The function
     LETSIMP(expr,name1,name2,...)  is equivalent to doing
     LETSIMP(expr,name1) followed by LETSIMP(%,name2) etc.
     CURRENT_LET_RULE_PACKAGE is the name of the rule package that is
     presently being used.  The user may reset this variable to the
     name of any rule package previously defined via the LET command.
     Whenever any of the functions comprising the let package are
     called with no package name the value of CURRENT_LET_RULE_PACKAGE
     is used.  If a call such as LETSIMP(expr,rule_pkg_name); is made,
     the rule package rule_pkg_name is used for that LETSIMP command
     only, i.e.  the value of CURRENT_LET_RULE_PACKAGE is not changed.
     There is a DEFAULT_LET_RULE_PACKAGE which is assumed when no other
     name is supplied to any of the functions.  Whenever a LET includes
     a rulepackage name that is used as the CURRENT_LET_RULE_PACKAGE.


 - Variable: LETRAT
     default: [FALSE] - when FALSE, LETSIMP will simplify the numerator
     and denominator of expr independently and return the result.
     Substitutions such as N!/N goes to (N-1)! will fail.  To handle
     such situations LETRAT should be set to TRUE, then the numerator,
     denominator, and their quotient will be simplified in that order.


 - Function: LETRULES ()
     displays the rules in the current rulepackage.  LETRULES(name)
     displays the rules in the named rulepackage.  The current
     rulepackage is the value of
          CURRENT_LET_RULE_PACKAGE
     The initial value of the rules is
          DEFAULT_LET_RULE_PACKAGE


 - Function: LETSIMP (exp)
     will continually apply the substitution rules previously defined
     by the function LET until no further change is made to exp.
     LETSIMP(expr,rule_pkg_name); will cause the rule package
     rule_pkg_name to be used for that LETSIMP command only, i.e.  the
     value of CURRENT_LET_RULE_PACKAGE is not changed.


 - Variable: LET_RULE_PACKAGES
     default:[DEFAULT_LET_RULE_PACKAGE] - The value of
     LET_RULE_PACKAGES is a list of all the user-defined let rule
     packages plus the special package
          DEFAULT_LET_RULE_PACKAGE
     This is the name of the rule package used when one is not
     explicitly set by the user.


 - Function: MATCHDECLARE (patternvar, predicate, ...)
     associates a predicate with a pattern variable so that the
     variable will only match expressions for which the predicate is
     not FALSE.  (The matching is accomplished by one of the functions
     described below).  For example after
          MATCHDECLARE(Q,FREEOF(X,%E))
     is executed, Q will match any expression not containing X or %E.
     If the match succeeds then the variable is set to the matched
     expression.  The predicate (in this case FREEOF) is written
     without the last argument which should be the one against which
     the pattern variable is to be tested.  Note that the patternvar
     and the arguments to the predicate are evaluated at the time the
     match is performed.  The odd numbered argument may also be a list
     of pattern variables all of which are to have the associated
     predicate.  Any even number of arguments may be given.  For
     pattern matching, predicates refer to functions which are either
     FALSE or not FALSE (any non FALSE value acts like TRUE).
     MATCHDECLARE(var,TRUE) will permit var to match any expression.


 - Function: MATCHFIX
     - MATCHFIX operators are used to denote functions of any number of
     arguments which are passed to the function as a list.  The
     arguments occur between the main operator and its "matching"
     delimiter.  The MATCHFIX("x",...) function is a syntax extension
     function which declares x to be a MATCHFIX operator.   The default
     binding power is 180, and the ARGS inside may be anything.


          (C1) matchfix("|","|");
          
          (D1) 				      "|"
          (C2) |a|+b;
          
          (D2) 				   b + (|a|)
          (C3) |(a,b)|;
          
          (D3) 				      |b|
          (C4) |[a,b]|;
          
          (D4) 				   |[a, b]|
          
          (C9) |x|:=IF NUMBERP(x) THEN ABS(x)
                  ELSE (IF LISTP(x) AND APPLY("and",MAP(NUMBERP,x))
          		  THEN SUM(x[i]^2,i,1,LENGTH(x))^0.5 ELSE BUILDQ([u:x],|u|))$
          
          (C10) |[1,2,3]|;
          
          (D10) 			       3.741657386773941
          
          (C18) |-7|;
          
          (D18) 				       7
          (C19) |[a,b]|;
          
          (D19) 				   |[a, b]|


 - Function: REMLET (prod, name)
     deletes the substitution rule, prod -> repl, most recently defined
     by the LET function.  If name is supplied the rule is deleted from
     the rule package name.  REMLET() and REMLET(ALL) delete all
     substitution rules from the current rulepackage. If the name of a
     rulepackage is supplied, e.g. REMLET(ALL,name), the rulepackage,
     name, is also deleted.  If a substitution is to be changed using
     the same product, REMLET need not be called, just redefine the
     substitution using the same product (literally) with the LET
     function and the new replacement and/or predicate name.  Should
     REMLET(product) now be called the original substitution rule will
     be revived.


 - Function: REMRULE (function, rulename)
     will remove a rule with the name rulename from the function which
     was placed there by DEFRULE, DEFMATCH, TELLSIMP, or TELLSIMPAFTER.
     If rule-name is ALL, then all rules will be removed.


 - Function: TELLSIMP (pattern, replacement)
     is similar to TELLSIMPAFTER but places new information before old
     so that it is applied before the built-in simplification rules.
     TELLSIMP is used when it is important to modify the expression
     before the simplifier works on it, for instance if the simplifier
     "knows" something about the expression, but what it returns is not
     to your liking.  If the simplifier "knows" something about the
     main operator of the expression, but is simply not doing enough for
     you, you probably want to use TELLSIMPAFTER.  The pattern may not
     be a sum, product, single variable, or number.  RULES is a list of
     names having simplification rules added to them by DEFRULE,
     DEFMATCH, TELLSIMP, or TELLSIMPAFTER.  Do EXAMPLE(TELLSIMP); for
     examples.


 - Function: TELLSIMPAFTER (pattern, replacement)
     defines a replacement for pattern which the MACSYMA simplifier
     uses after it applies the built-in simplification rules.  The
     pattern may be anything but a single variable or a number.



File: maxima.info,  Node: Lists,  Next: Function Definition,  Prev: Rules and Patterns,  Up: Top

Lists
*****

* Menu:

* Introduction to Lists::
* Definitions for Lists::


File: maxima.info,  Node: Introduction to Lists,  Next: Definitions for Lists,  Prev: Lists,  Up: Lists

Introduction to Lists
=====================

Lists are the basic building block for maxima and lisp.   All data types
other than arrays, hash tables, numbers are represented as lisp lists,
These lisp lists have the form
     ((mplus) $A 2)

to indicate an expression `A+2'.   At maxima level one would see the
infix notation `A+2'.   Maxima also has lists which are printed as
     [1, 2, 7, x+y]

for a list with 4 elements.   Internally this corresponds to a lisp list
of the form
     ((mlist) 1  2  7  ((mplus)  $X $Y ))

The flag which denotes the type field of the maxima expression is a list
itself, since after it has been through the simplifier the list would
become
     ((mlist simp) 1 2 7 ((mplus simp) $X $Y))


File: maxima.info,  Node: Definitions for Lists,  Prev: Introduction to Lists,  Up: Lists

Definitions for Lists
=====================

 - Function: APPEND (list1, list2, ...)
     returns a single list of the elements of list1 followed by the
     elements of list2,...  APPEND also works on general expressions,
     e.g. APPEND(F(A,B), F(C,D,E)); -> F(A,B,C,D,E).  Do
     EXAMPLE(APPEND); for an example.


 - Function: ASSOC (exp)
     This function searches for the key in the left hand side of the
     input list of the form [x,y,z...] where each of the list elements
     is a expression of a binary operand and 2 elements.  For example
     x=1, 2^3, [a,b] etc.  The key checked againts the first operand
     and and returns the second operand if the key is found.  If the
     key is not found it either returns the default value if supplied or
     false.

 - Function: ATOM (exp)
     is TRUE if exp is atomic (i.e. a number or name) else FALSE.  Thus
     ATOM(5) is TRUE while ATOM(A[1]) and ATOM(SIN(X)) are FALSE.
     (Assuming A[1] and X are unbound.)


 - Function: CONS (exp, list)
     returns a new list constructed of the element exp as its first
     element, followed by the elements of list.  CONS also works on
     other expressions, e.g. CONS(X, F(A,B,C));  ->  F(X,A,B,C).


 - Function: COPYLIST (L)
     creates a copy of the list L.


 - Function: DELETE (exp1, exp2)
     removes all occurrences of exp1 from exp2.  Exp1 may be a term of
     exp2 (if it is a sum) or a factor of exp2 (if it is a product).
          (C1)  DELETE(SIN(X),X+SIN(X)+Y);
          (D1)               Y + X
     DELETE(exp1, exp2, integer) removes the first integer occurrences
     of exp1 from exp2.  Of course, if there are fewer than integer
     occurrences of exp1 in exp2 then all occurrences will be deleted.


 - Function: ENDCONS (exp, list)
     returns a new list consisting of the elements of list followed by
     exp.  ENDCONS also works on general expressions, e.g.  ENDCONS(X,
     F(A,B,C));  ->  F(A,B,C,X).


 - Function: EVERY (exp)
     This function takes a list, or a positive number of arguments and
     returns true if all its arguments are not false.


 - Function: FIRST (exp) SECOND (exp) .. TENTH (exp)
     yields the first part of exp which may result in the first element
     of a list, the first row of a matrix, the first term of a sum,
     etc.  Note that FIRST and its related functions, REST and LAST,
     work on the form of exp which is displayed not the form which is
     typed on input.  If the variable INFLAG [FALSE] is set to TRUE
     however, these functions will look at the internal form of exp.
     Note that the simplifier re-orders expressions.  Thus FIRST(X+Y)
     will be X if INFLAG is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X)
     gives the same results).  The functions SECOND .. TENTH yield the
     second through the tenth part of their input argument.


 - Function: FLATTEN(exp)
     Takes a list of the form [[1,2],[3,4]] and returns [1,2,3,4].


 - Function: GET (a, i)
     retrieves the user property indicated by i associated with atom a
     or returns FALSE if a doesn't have property i.
          (C1) PUT(%E,'TRANSCENDENTAL,'TYPE);
          (D1) 			        TRANSCENDENTAL
          (C2) PUT(%PI,'TRANSCENDENTAL,'TYPE)$
          (C3) PUT(%I,'ALGEBRAIC,'TYPE)$
          (C4) TYPEOF(EXP) := BLOCK([Q],
                                  IF NUMBERP(EXP)
                                  THEN RETURN('ALGEBRAIC),
                                  IF NOT ATOM(EXP)
                                  THEN RETURN(MAPLIST('TYPEOF, EXP)),
                                  Q : GET(EXP, 'TYPE),
                                  IF Q=FALSE
          			THEN ERRCATCH(ERROR(EXP,"is not numeric.")) ELSE Q)$
          (C5) TYPEOF(2*%E+X*%PI);
          X is not numeric.
          (D5) 	     [[TRANSCENDENTAL, []], [ALGEBRAIC, TRANSCENDENTAL]]
          (C6) TYPEOF(2*%E+%PI);
          (D6) 	        [TRANSCENDENTAL, [ALGEBRAIC, TRANSCENDENTAL]]

 - Function: LAST (exp)
     yields the last part (term, row, element, etc.) of the exp.


 - Function: LENGTH (exp)
     gives (by default) the number of parts in the external (displayed)
     form of exp.  For lists this is the number of elements, for
     matrices it is the number of rows, and for sums it is the number
     of terms. (See DISPFORM).  The LENGTH command is affected by the
     INFLAG switch [default FALSE].  So, e.g. LENGTH(A/(B*C)); gives 2
     if INFLAG is FALSE (Assuming EXPTDISPFLAG is TRUE), but 3 if
     INFLAG is TRUE (the internal representation is essentially
     A*B^-1*C^-1).


 - Variable: LISTARITH
     default: [TRUE] - if FALSE causes any arithmetic operations with
     lists to be suppressed; when TRUE, list-matrix operations are
     contagious causing lists to be converted to matrices yielding a
     result which is always a matrix.  However, list-list operations
     should return lists.


 - Function: LISTP (exp)
     is TRUE if exp is a list else FALSE.


 - Function: MAKELIST (exp,var,lo,hi)
     returns a list as value.  MAKELIST may be called as
     MAKELIST(exp,var,lo,hi) ["lo" and "hi" must be integers], or as
     MAKELIST(exp,var,list).  In the first case MAKELIST is analogous to
     SUM, whereas in the second case MAKELIST is similar to MAP.
     Examples:
             MAKELIST(CONCAT(X,I),I,1,6) yields [X1,X2,X3,X4,X5,X6]
             MAKELIST(X=Y,Y,[A,B,C]) yields [X=A,X=B,X=C]


 - Function: MEMBER (exp, list)
     returns TRUE if exp occurs as a member of list (not within a
     member).  Otherwise FALSE is returned.  Member also works on
     non-list expressions, e.g. MEMBER(B, F(A,B,C));  ->  TRUE.


 - Function: REST (exp, n)
     yields exp with its first n elements removed if n is positive and
     its last -n elements removed if n is negative.  If n is 1 it may
     be omitted.  Exp may be a list, matrix, or other expression.


 - Function: REVERSE (list)
     reverses the order of the members of the list (not the members
     themselves).  REVERSE also works on general expressions, e.g.
     REVERSE(A=B); gives B=A.  REVERSE default: [FALSE] - in the
     Plotting functions, if TRUE cause a left-handed coordinate system
     to be assumed.



File: maxima.info,  Node: Function Definition,  Next: Program Flow,  Prev: Lists,  Up: Top

Function Definition
*******************

* Menu:

* Introduction to Function Definition::
* FUNCTION::
* MACROS::
* OPTIMIZATION::
* Definitions for Function Definition::


File: maxima.info,  Node: Introduction to Function Definition,  Next: FUNCTION,  Prev: Function Definition,  Up: Function Definition

Introduction to Function Definition
===================================


File: maxima.info,  Node: FUNCTION,  Next: MACROS,  Prev: Introduction to Function Definition,  Up: Function Definition

FUNCTION
========

- To define a function in MACSYMA you use the := operator.  E.g.
     F(X):=SIN(X)

defines a function F.  Anonmyous functions may also be created using
LAMBDA.  For example
     lambda([i,j], ... )

can be used instead of F where
     F(I,J):=BLOCK([], ... );
     MAP(LAMBDA([I],I+1),L)

would return a list with 1 added to each term.

   You may also define a function with a variable number of arguments,
by having a final argument which is assigned to a list of the extra
arguments:

     (C8) f([u]):=u;
     (C9) f(1,2,3,4);
     (D9) 				 [1, 2, 3, 4]
     (C11) f(a,b,[u]):=[a,b,u];
     (C12) f(1,2,3,4,5,6);
     (D12) 			     [1, 2, [3, 4, 5, 6]]

   The right hand side of a function is an expression.  Thus if you
want a sequence of expressions, you do

     f(x):=(expr1,expr2,....,exprn);
   and the value of exprn is what is returned by the function.

   If you wish to make a `return' from some expression inside the
function then you must use `block' and `return'.

     block([],expr1,...,if(a>10) then return(a),...exprn)
   is itelf an expression, and so could take the place of the right
hand side of a function definition.  Here it may happen that the return
happens earlier than the last expression.

   The first `[]' in the block, may contain a list of variables and
variable assignments, such as `[a:3,b,c:[]]', which would cause the
three variables `a',`b',and `c' to not refer to their global values,
but rather have these special values for as long as the code executes
inside the `block', or inside functions called from inside the `block'.
This is called dynamic binding, since the variables last from the
start of the block to the time it exits.  Once you return from the
`block', or throw out of it, the old values (if any) of the variables
will be restored.   It is certainly a good idea to protect your
variables in this way.   Note that the assignments in the block
variables, are done in parallel.   This means, that if you had used
`c:a' in the above, the value of `c' would have been the value of `a'
at the time you just entered the block, but before `a' was bound.
Thus doing something like

     block([a:a],expr1,... a:a+3,...exprn)
   will protect the external value of `a' from being altered, but would
let you access what that value was.   Thus the right hand side of the
assignments, is evaluated in the entering context, before any binding
occurs.  Using just `block([x],..' would cause the x to have itself as
value, just as if it would have if you entered a fresh MAXIMA session.

   The actual arguments to a function are treated in exactly same way as
the variables in a block.  Thus in

     f(x):=(expr1,...exprn);
     and
     f(1);
   we would have a similar context for evaluation of the expressions as
if we had done
     block([x:1],expr1,...exprn)

   Inside functions, when the right hand side of a definition, may be
computed at runtime, it is useful to use `define' and possibly `buildq'.


File: maxima.info,  Node: MACROS,  Next: OPTIMIZATION,  Prev: FUNCTION,  Up: Function Definition

MACROS
======

 - Function: BUILDQ ([varlist],expression);
     EXPRESSION is any single MAXIMA expression and  VARLIST is a list
     of elements of the form `<atom>' or `<atom>:<value>'

Semantics
---------

The <value>s in the <varlist> are evaluated left to right (the syntax
<atom> is equivalent to <atom>:<atom>).  then these values are
substituted into <expression> in parallel.  If any <atom> appears as a
single argument to the special form SPLICE (i.e. SPLICE(<atom>) ) inside
<expression>, then the value associated with that <atom> must be a
macsyma list, and it is spliced into <expression> instead of
substituted.

SIMPLIFICATION
--------------

The arguments to BUILDQ need to be protected from simplification until
the substitutions have been carried out.  This code should affect that
by using `''.

   `buildq' can be useful for building functions on the fly.  One of
the powerful things about MAXIMA is that you can have your functions
define other functions to help solve the problem.  Further below we
discuss building a recursive function, for a series solution.   This
defining of functions inside functions usually uses `define', which
evaluates its arguments.  A number of examples are included under
`splice'.

 - Function: SPLICE (atom)
     This is used with buildq to construct a list. This is handy for
     making argument lists, in conjunction with BUILDQ

          MPRINT([X]) ::= BUILDQ([U : x],
            if (debuglevel > 3) print(splice(u)));

     Including a call like
          MPRINT("matrix is ",MAT,"with length",LENGTH(MAT))
     is equivalent to putting in the line

          IF DEBUGLEVEL > 3
            THEN PRINT("matrix is ",MAT,"with length",
                        LENGTH(MAT))

     A more non trivial example would try to display the variable values
     AND their names.
          MSHOW(A,B,C)

     should become

          PRINT('A,"=",A,",",'B,"=",B,", and",'C,"=",C)

     so that if it occurs as a line in a program we can print values.

          (C101) foo(x,y,z):=mshow(x,y,z);
          (C102) foo(1,2,3);
          X = 1 , Y = 2 , and Z = 3

     The actual definition of mshow is the following.   Note how buildq
     lets you build 'QUOTED' structure, so that the  `'u' lets you get
     the variable name.  Note that in macros, the RESULT is a piece of
     code which will then be substituted for the macro and evaluated.

          MSHOW([lis])::=BLOCK([ans:[],N:LENGTH(lis)],
          	   FOR i THRU N DO
          	       (ans:APPEND(ans,
          			   BUILDQ([u:lis[i]],
          				  ['u,"=",u])),
          		IF i < N
          		    THEN ans
          		    :APPEND(ans,
          			    IF i < N-1 THEN [","]
          			        ELSE [", and"])),
          	   BUILDQ([U:ans],PRINT(SPLICE(u))))

     The splice also works to put arguments into algebraic operations:

          (C108) BUILDQ([A:'[B,C,D]],+SPLICE(A));
          (D108) D+C+B
     Note how the simplification only occurs AFTER the substitution,
     The operation applying to the splice in the first cae is the `+'
     while in the second it is the `*', yet logically you might thing
     `splice(a)+splice(A)' could be replaced by `2*splice(A)'.   No
     simplification takes place with the buildq To understand what
     SPLICE is doing with the algebra you must understand that for
     MAXIMA, a formula an operation like `A+B+C' is really internally
     similar to `+(A,B,C)', and similarly for multiplication.  Thus
     `*(2,B,C,D)' is `2*B*C*D'

          (C114) BUILDQ([A:'[B,C,D]],+SPLICE(A));
          (D114) D+C+B
          
          (C111) BUILDQ([A:'[B,C,D]],SPLICE(A)+SPLICE(A));
          (D111) 2*D+2*C+2*B
            but
          (C112) BUILDQ([A:'[B,C,D]],2*SPLICE(A));
          (D112) 2*B*C*D

     Finally the buildq can be invaluable for building recursive
     functions.  Suppose your program is solving a differential
     equation using the series method, and has determined that it needs
     to build a recursion relation
          F[N]:=(-((N^2-2*N+1)*F[N-1]+F[N-2]+F[N-3])/(N^2-N))
     and it must do this on the fly inside your function.  Now you
     would really like to add `expand'.
          F[N]:=EXPAND((-((N^2-2*N+1)*F[N-1]+F[N-2]+F[N-3])
            /(N^2-N)));
     but how do you build this code.  You want the `expand' to happen
     each time the function runs, NOT before it.
          kill(f),
          val:(-((N^2-2*N+1)*F[N-1]+F[N-2]+F[N-3])/(N^2-N)),
          define(f[n],buildq([u:val],expand(u))),
     does the job.   This might be useful, since when you do
          With the Expand
          (C28) f[6];
          (D28) -AA1/8-13*AA0/180
     where as without it is kept unsimplified, and even after 6 terms
     it becomes:
          (C25) f[6];
          (D25) (5*(-4*(-3*(-2*(AA1+AA0)+AA1+AA0)/2
          	    -(AA1+AA0)/2+AA1)
          	/3
          	-(-2*(AA1+AA0)+AA1+AA0)/6+(-AA1-AA0)/2)
                /4
                +(-3*(-2*(AA1+AA0)+AA1+AA0)/2
                 -(AA1+AA0)/2+AA1)
                 /12-(2*(AA1+AA0)-AA1-AA0)/6)
                /30
     The expression quickly becomes complicated if not simplified at
     each stage, so the simplification must be part of the definition.
     Hence the `buildq' is useful for building the form.


File: maxima.info,  Node: OPTIMIZATION,  Next: Definitions for Function Definition,  Prev: MACROS,  Up: Function Definition

OPTIMIZATION
============

The optimu files no longer exist in Maxima.  The documentation is left
here for historical purposes.

   When using TRANSLATE and generating code with MACSYMA, there are a
number of techniques which can save time and be helpful.  Do
DEMO("optimu.dem") for a demonstration.  In particular, the function
FLOATDEFUNK from TRANSL;OPTIMU FASL, creates a function definition from
a math-like expression, but it optimizes it (with OPTIMIZE) and puts in
the MODE_DECLAREations needed to COMPILE correctly. (This can be done
by hand, of course).  The demo will only run in a fresh macsyma.


File: maxima.info,  Node: Definitions for Function Definition,  Prev: OPTIMIZATION,  Up: Function Definition

Definitions for Function Definition
===================================

 - Function: APPLY (function, list)
     gives the result of applying the function to the list of its
     arguments.  This is useful when it is desired to compute the
     arguments to a function before applying that function.  For
     example, if L is the list [1, 5, -10.2, 4, 3], then APPLY(MIN,L)
     gives -10.2.  APPLY is also useful when calling functions which do
     not have their arguments evaluated if it is desired to cause
     evaluation of them.  For example, if FILESPEC is a variable bound
     to the list [TEST, CASE] then APPLY(CLOSEFILE,FILESPEC) is
     equivalent to CLOSEFILE(TEST,CASE).  In general the first argument
     to APPLY should be preceded by a ' to make it evaluate to itself.
     Since some atomic variables have the same name as certain
     functions the values of the variable would be used rather than the
     function because APPLY has its first argument evaluated as well as
     its second.


 - Function: BINDTEST (ai)
     causes ai to signal an error if it ever is used in a computation
     unbound.


 - Function: BLOCK ([v1,...,vk], statement1,...,statementj)
     Blocks in MACSYMA are somewhat analogous to subroutines in FORTRAN
     or procedures in ALGOL or PL/I.  Blocks are like compound
     statements but also enable the user to label statements within the
     block and to assign "dummy" variables to values which are local to
     the block.  The vi are variables which are local to the BLOCK and
     the stmti are any MACSYMA expressions.  If no variables are to be
     made local then the list may be omitted.  A block uses these local
     variables to avoid conflict with variables having the same names
     used outside of the block (i.e. global to the block).  In this
     case, upon entry to the block, the global values are saved onto a
     stack and are inaccessible while the block is being executed.  The
     local variables then are unbound so that they evaluate to
     themselves.  They may be bound to arbitrary values within the
     block but when the block is exited the saved values are restored
     to these variables.  The values created in the block for these
     local variables are lost.  Where a variable is used within a block
     and is not in the list of local variables for that block it will
     be the same as the variable used outside of the block.      If it
     is desired to save and restore other local properties besides
     VALUE, for example ARRAY (except for complete arrays), FUNCTION,
     DEPENDENCIES, ATVALUE, MATCHDECLARE, ATOMGRAD, CONSTANT, and
     NONSCALAR then the function LOCAL should be used inside of the
     block with arguments being the names of the variables.      The
     value of the block is the value of the last statement or the value
     of the argument to the function RETURN which may be used to exit
     explicitly from the block. The function GO may be used to transfer
     control to the statement of the block that is tagged with the
     argument to GO.  To tag a statement, precede it by an atomic
     argument as another statement in the BLOCK.  For example:
     BLOCK([X],X:1,LOOP,X:X+1,...,GO(LOOP),...).  The argument to GO
     must be the name of a tag appearing within the BLOCK.  One cannot
     use GO to transfer to a tag in a BLOCK other than the one
     containing the GO.      Blocks typically appear on the right side
     of a function definition but can be used in other places as well.


 - Function: BREAK (arg1, ...)
     will evaluate and print its arguments and will then cause a
     (MACSYMA-BREAK) at which point the user can examine and change his
     environment.  Upon typing EXIT; the computation resumes.
     Control-A (^A) will enter a MACSYMA-BREAK from any point
     interactively.  EXIT; will continue the computation.  Control-X
     may be used inside the MACSYMA-BREAK to quit locally, without
     quitting the main computation.


 - Macro: BUILDQ
     - See DESCRIBE(MACROS); .


 - Function: CATCH (exp1,...,expn)
     evaluates its arguments one by one; if the structure of the expi
     leads to the evaluation of an expression of the form THROW(arg),
     then the value of the CATCH is the value of THROW(arg).  This
     "non-local return" thus goes through any depth of nesting to the
     nearest enclosing CATCH.  There must be a CATCH corresponding to a
     THROW, else an error is generated.  If the evaluation of the expi
     does not lead to the evaluation of any THROW then the value of the
     CATCH is the value of expn.
          (C1) G(L):=CATCH(MAP(LAMBDA([X],
                 IF X<0 THEN THROW(X) ELSE F(X)),L));
          (C2) G([1,2,3,7]);
          (D2)                     [F(1), F(2), F(3), F(7)]
          (C3) G([1,2,-3,7]);
          (D3)                                - 3

     The function G returns a list of F of each element of L if L
     consists only of non-negative numbers; otherwise, G "catches" the
     first negative element of L and "throws" it up.


 - Function: COMPFILE ([filespec], f1, f2, ..., fn)
     Compiles functions fi into the file "filespec".  For convenience,
     see the COMPILE function.


 - Variable: COMPGRIND
     default: [FALSE] when TRUE function definitions output by COMPFILE
     are pretty-printed.


 - Function: COMPILE (f)
     The COMPILE command is a convenience feature in macsyma. It
     handles the calling of the function COMPFILE, which translates
     macsyma functions into lisp, the calling of the lisp compiler on
     the file produced by COMPFILE, and the loading of the output of
     the compiler, know as a FASL file, into the macsyma. It also
     checks the compiler comment listing output file for certain common
     errors.  Do PRINTFILE(MCOMPI,DOC,MAXDOC); for more details.
     COMPILE(); causes macsyma to prompt for arguments.
     COMPILE(function1,function2,...); compiles the functions, it uses
     the name of function1 as the first name of the file to put the
     lisp output.  COMPILE(ALL); or COMPILE(FUNCTIONS); will compile
     all functions.  COMPILE([file-name],function1,function2,...); N.B.
     all arguments are evaluated, just like a normal function (it is a
     normal function!).  Therefore, if you have variables with the same
     name as part of the file you can not ignore that fact.


 - Function: COMPILE_LISP_FILE ("input filename")
     which takes an optional second argument of "output filename," can
     be used in conjunction with

          TRANSLATE_FILE("filename").
     For convenience you might define

          Compile_and_load(FILENAME):=
              LOAD(COMPILE_LISP_FILE(TRANSLATE_FILE(FILENAME)[2]))[2]);

     These file-oriented commands are to be preferred over the use of
     COMPILE, COMPFILE, and the TRANSLATE SAVE combination.


 - Function: DEFINE (f(x1, ...), body)
     is equivalent to f(x1,...):="body but when used inside functions
     it happens at execution time rather than at the time of definition
     of the function which contains it.


 - Function: DEFINE_VARIABLE
          (name,default-binding,mode,optional-documentation)
     introduces a global variable into the MACSYMA environment.  This is
     for user-written packages, which are often translated or compiled.
     Thus
          DEFINE_VARIABLE(FOO,TRUE,BOOLEAN);
     does the following:

     (1) MODE_DECLARE(FOO,BOOLEAN); sets it up for the translator.

     (2) If the variable is unbound, it sets it:  FOO:TRUE.

     (3) DECLARE(FOO,SPECIAL); declares it special.

     (4) Sets up an assign property for it to make sure that it never
      gets set to a value of the wrong mode.      E.g.  FOO:44 would
     be an error once FOO is defined BOOLEAN.

     See DESCRIBE(MODE_DECLARE); for a list of the possible "modes".
     The optional 4th argument is a documentation string.  When
     TRANSLATE_FILE is used on a package which includes documentation
     strings, a second file is output in addition to the LISP file which
     will contain the documentation strings, formatted suitably for use
     in manuals, usage files, or (for instance) DESCRIBE.  With any
     variable which has been DEFINE_VARIABLE'd with mode other than
     ANY, you can give a VALUE_CHECK property, which is a function of
     one argument called on the value the user is trying to set the
     variable to.

          PUT('G5,LAMBDA([U],IF U#'G5 THEN ERROR("Don't set G5")),
                 'VALUE_CHECK);

     Use DEFINE_VARIABLE(G5,'G5,ANY_CHECK, "this ain't supposed to be
     set by anyone but me.")  ANY_CHECK is a mode which means the same
     as ANY, but which keeps DEFINE_VARIABLE from optimizing away the
     assign property.


 - Function: DISPFUN (f1, f2, ...)
     displays the definition of the user defined functions f1, f2, ...
     which may also be the names of array associated functions,
     subscripted functions, or functions with constant subscripts which
     are the same as those used when the functions were defined.
     DISPFUN(ALL) will display all user defined functions as given on
     the FUNCTIONS and ARRAYS lists except subscripted functions with
     constant subscripts.  E.g. if the user has defined a function
     F(x), DISPFUN(F); will display the definition.


 - Variable: FUNCTIONS
     default: [] - all user defined functions (set up by f(x):=...).


 - Function: FUNDEF (functionname)
     returns the function definition associated with "functionname".
     FUNDEF(fnname); is similar to DISPFUN(fnname); except that FUNDEF
     does not invoke display.


 - Function: FUNMAKE (name,[arg1,...,argn])
     returns name(arg1,...,argn) without calling the function name.


 - Function: LOCAL (v1, v2, ...)
     causes the variables v1,v2,... to be local with respect to all the
     properties in the statement in which this function is used.  LOCAL
     may only be used in BLOCKs, in the body of function definitions or
     LAMBDA expressions, or in the EV function and only one occurrence
     is permitted in each.  LOCAL is independent of CONTEXT.


 - Variable: MACROEXPANSION
     default:[FALSE] - Controls advanced features which affect the
     efficiency of macros. Possible settings:  FALSE - Macros expand
     normally each time they are called.   EXPAND - The first time a
     particular call is evaluated, the expansion is "remembered"
     internally, so that it doesn't have to be recomputed on subsequent
     calls making subsequent calls faster.  The macro call still GRINDs
     and DISPLAYs normally, however extra memory is required to
     remember all of the expansions.   DISPLACE - The first time a
     particular call is evaluated, the expansion is substituted for the
     call.  This requires slightly less storage than when
     MACROEXPANSION is set to EXPAND and is just as fast, but has the
     disadvantage that the original macro call is no longer remembered
     and hence the expansion will be seen if DISPLAY or GRIND is
     called.  See documentation for TRANSLATE and MACROS for more
     details.


 - Variable: MODE_CHECKP
     default: [TRUE] - If TRUE, MODE_DECLARE checks the modes of bound
     variables.


 - Variable: MODE_CHECK_ERRORP
     default: [FALSE] - If TRUE, MODE_DECLARE calls error.


 - Variable: MODE_CHECK_WARNP
     default: [TRUE] - If TRUE, mode errors are described.


 - Function: MODE_DECLARE (y1, mode1, y2, mode2, ...)
     MODEDECLARE is a synonym for this.  MODE_DECLARE is used to
     declare the modes of variables and functions for subsequent
     translation or compilation of functions. Its arguments are pairs
     consisting of a variable yi, and a mode which is one of BOOLEAN,
     FIXNUM, NUMBER, RATIONAL, or FLOAT.  Each yi may also be a list of
     variables all of which are declared to have modei.  If yi is an
     array, and if every element of the array which is referenced has a
     value then ARRAY(yi, COMPLETE, dim1, dim2, ...)  rather than
          ARRAY(yi, dim1, dim2, ...)
     should be used when first declaring the bounds of the array.  If
     all the elements of the array are of mode FIXNUM (FLOAT), use
     FIXNUM (FLOAT) instead of COMPLETE.  Also if every element of the
     array is of the same mode, say m, then

          MODE_DECLARE(COMPLETEARRAY(yi),m))
     should be used for efficient translation.  Also numeric code using
     arrays can be made to run faster by declaring the expected size of
     the array, as in:

          MODE_DECLARE(COMPLETEARRAY(A[10,10]),FLOAT)

     for a floating point number array which is 10 x 10.  Additionally
     one may declare the mode of the result of a function by using
     FUNCTION(F1,F2,...) as an argument; here F1,F2,... are the names
     of functions.  For example the expression,

          MODE_DECLARE([FUNCTION(F1,F2,...),X],FIXNUM,Q,
                                          COMPLETEARRAY(Q),FLOAT)

     declares that X and the values returned by F1,F2,... are
     single-word integers and that Q is an array of floating point
     numbers.  MODE_DECLARE is used either immediately inside of a
     function definition or at top-level for global variables.  Do
     PRINTFILE(MCOMPI,DOC,MAXDOC); for some examples of the use of
     MODE_DECLARE in translation and compilation.


 - Function: MODE_IDENTITY (arg1,arg2)
     A special form used with MODE_DECLARE and MACROS to delcare, e.g.,
     a list of lists of flonums, or other compound data object.  The
     first argument to MODE_IDENTITY is a primitive value mode name as
     given to MODE_DECLARE (i.e. [FLOAT,FIXNUM,NUMBER, LIST,ANY]), and
     the second argument is an expression which is evaluated and
     returned as the value of MODE_IDENTITY.  However, if the return
     value is not allowed by the mode declared in the first argument,
     an error or warning is signalled.  The important thing is that the
     MODE of the expression as determined by the MACSYMA to Lisp
     translator, will be that given as the first argument, independent
     of anything that goes on in the second argument.  E.g. X:3.3;
     MODE_IDENTITY(FIXNUM,X); is an error.  MODE_IDENTITY(FLONUM,X)
     returns 3.3 .  This has a number of uses, e.g., if you knew that
     FIRST(L) returned a number then you might write
     MODE_IDENTITY(NUMBER,FIRST(L)).  However, a more efficient way to
     do it would be to define a new primitive,

          FIRSTNUMB(X)::=BUILDQ([X],MODE_IDENTITY(NUMBER,X));
     and use FIRSTNUMB every time you take the first of a list of
     numbers.


 - Variable: TRANSBIND
     default: [FALSE] - if TRUE removes global declarations in the
     local context.  This applies to variables which are formal
     parameters to functions which one is TRANSLATE-ing from MACSYMA
     code to LISP.


 - Variable: TRANSCOMPILE
     default:[FALSE] - if true, TRANSLATE will generate the
     declarations necessary for possible compilation.  The COMPFILE
     command uses TRANSCOMPILE:TRUE;.


 - Function: TRANSLATE (f1, f2, ...)
     translates the user defined functions f1,f2,... from the MACSYMA
     language to LISP (i.e. it makes them EXPRs).  This results in a
     gain in speed when they are called.  There is now a version of
     macsyma with the macsyma to lisp translator pre-loaded into it.
     It is available by typing :TM (for TranslateMacsyma) at DDT level.
     When given a file name, E.g. :TM GJC;TMTEST > , it gives that
     file to the function TRANSLATE_FILE, and proceeds without further
     user interaction.  If no file name is given, :TM gives a regular
     macsyma "(C1)" line.  P.s. A user init file with second name "TM"
     will be loaded if it exists.  You may just want to link this to
     your macsyma init file.  Functions to be translated should include
     a call to MODE_DECLARE at the beginning when possible in order to
     produce more efficient code.  For example:

          F(X1,X2,...):=BLOCK([v1,v2,...],
                  MODE_DECLARE(v1,mode1,v2,mode2,...),...)

     where the X1,X2,...  are the parameters to the function and the
     v1,v2,... are the local variables.  The names of translated
     functions are removed from the FUNCTIONS list if SAVEDEF is FALSE
     (see below) and are added to the PROPS lists.  Functions should
     not be translated unless they are fully debugged.  Also,
     expressions are assumed simplified; if they are not, correct but
     non- optimal code gets generated.  Thus, the user should not set
     the SIMP switch to FALSE which inhibits simplification of the
     expressions to be translated.  The switch TRANSLATE, default:
     [FALSE], If TRUE, causes automatic translation of a user's
     function to LISP.  Note that translated functions may not run
     identically to the way they did before translation as certain
     incompatabilities may exist between the LISP and MACSYMA versions.
     Principally, the RAT function with more than one argument and the
     RATVARS function should not be used if any variables are
     MODE_DECLAREd CRE.  Also the PREDERROR:FALSE setting will not
     translate.  SAVEDEF[TRUE] - if TRUE will cause the MACSYMA version
     of a user function to remain when the function is TRANSLATEd.
     This permits the definition to be displayed by DISPFUN and allows
     the function to be edited.  TRANSRUN[TRUE] - if FALSE will cause
     the interpreted version of all functions to be run (provided they
     are still around) rather than the translated version.  One can
     translate functions stored in a file by giving TRANSLATE an
     argument which is a file specification.  This is a list of the form
     [fn1,fn2,DSK,dir] where fn1 fn2 is the name of the file of MACSYMA
     functions, and dir is the name of a file directory.  The result
     returned by TRANSLATE is a list of the names of the functions
     TRANSLATEd.  In the case of a file translation the corresponding
     element of the list is a list of the first and second new file
     names containing the LISP code resulting from the translation.
     This will be fn1 LISP on the disk directory dir.  The file of LISP
     code may be read into MACSYMA by using the LOADFILE function.


 - Function: TRANSLATE_FILE (file)
     translates a file of MACSYMA code into a file of LISP code.  It
     takes one or two arguments.  The first argument is the name of the
     MACSYMA file, and the optional second argument is the name of the
     LISP file to produce.  The second argument defaults to the first
     argument with second file name the value of TR_OUTPUT_FILE_DEFAULT
     which defaults to TRLISP.  For example:
     TRANSLATE_FILE("test.mc")); will translate "test.mc" to
     "test.LISP".  Also produced is a file of translator warning
     messages of various degrees of severity.  The second file name is
     always UNLISP.  This file contains valuable (albeit obsure for
     some) information for tracking down bugs in translated code.  Do
     APROPOS(TR_) to get a list of TR (for TRANSLATE) switches.  In
     summary, TRANSLATE_FILE("foo.mc"), LOADFILE("foo.LISP") is "=" to
     BATCH("foo.mc") modulo certain restrictions (the use of " and % for
     example).


 - Variable: TRANSRUN
     default: [TRUE] - if FALSE will cause the interpreted version of
     all functions to be run (provided they are still around) rather
     than the translated version.


 - Variable: TR_ARRAY_AS_REF
     default: [TRUE] - If TRUE runtime code uses the value of the
     variable as the array.


 - Variable: TR_BOUND_FUNCTION_APPLYP
     default: [TRUE] - Gives a warning if a bound variable is found
     being used as a function.


 - Variable: TR_FILE_TTY_MESSAGESP
     default: [FALSE] - Determines whether messages generated by
     TRANSLATE_FILE during translation of a file will be sent to the
     TTY.  If FALSE (the default), messages about translation of the
     file are only inserted into the UNLISP file.  If TRUE, the messages
     are sent to the TTY and are also inserted into the UNLISP file.


 - Variable: TR_FLOAT_CAN_BRANCH_COMPLEX
     default: [TRUE] - States whether the arc functions might return
     complex results.  The arc functions are SQRT, LOG, ACOS, etc.
     e.g. When it is TRUE then ACOS(X) will be of mode ANY even if X is
     of mode FLOAT. When FALSE then ACOS(X) will be of mode FLOAT if
     and only if X is of mode FLOAT.


 - Variable: TR_FUNCTION_CALL_DEFAULT
     default: [GENERAL] - FALSE means give up and call MEVAL, EXPR
     means assume Lisp fixed arg function.  GENERAL, the default gives
     code good for MEXPRS and MLEXPRS but not MACROS.  GENERAL assures
     variable bindings are correct in compiled code.  In GENERAL mode,
     when translating F(X), if F is a bound variable, then it assumes
     that APPLY(F,[X]) is meant, and translates a such, with apropriate
     warning. There is no need to turn this off.  With the default
     settings, no warning messages implies full compatibility of
     translated and compiled code with the macsyma interpreter.


 - Variable: TR_GEN_TAGS
     default: [FALSE] - If TRUE, TRANSLATE_FILE generates a TAGS file
     for use by the text editor.


 - Variable: TR_NUMER
     default: [FALSE] - If TRUE numer properties are used for atoms
     which have them, e.g. %PI.


 - Variable: TR_OPTIMIZE_MAX_LOOP
     default: [100] - The maximum number of times the macro-expansion
     and optimization pass of the translator will loop in considering a
     form.  This is to catch MACRO expansion errors, and
     non-terminating optimization properties.


 - Variable: TR_OUTPUT_FILE_DEFAULT
     default: [TRLISP] - This is the second file name to be used for
     translated lisp output.


 - Variable: TR_PREDICATE_BRAIN_DAMAGE
     default: [FALSE] - If TRUE, output possible multiple evaluations
     in an attempt to interface to the COMPARE package.


 - Variable: TR_SEMICOMPILE
     default: [FALSE] - If TRUE TRANSLATE_FILE and COMPFILE output
     forms which will be macroexpanded but not compiled into machine
     code by the lisp compiler.


 - Variable: TR_STATE_VARS
     default:
          [TRANSCOMPILE, TR_SEMICOMPILE,
          TR_WARN_UNDECLARED, TR_WARN_MEVAL, TR_WARN_FEXPR, TR_WARN_MODE,
          TR_WARN_UNDEFINED_VARIABLE, TR_FUNCTION_CALL_DEFAULT,
           TR_ARRAY_AS_REF,TR_NUMER]
     The list of the switches that affect the form of the translated
     output.  This information is useful to system people when trying
     to debug the translator.  By comparing the translated product to
     what should have been produced for a given state, it is possible to
     track down bugs.


 - Variable: TR_TRUE_NAME_OF_FILE_BEING_TRANSLATED
     default: [FALSE] is bound to the quoted string form of the true
     name of the file most recently translated by TRANSLATE_FILE.


 - Variable: TR_VERSION
     - The version number of the translator.


 - Function: TR_WARNINGS_GET ()
     Prints a list of warnings which have been given by the translator
     during the current translation.


 - Variable: TR_WARN_BAD_FUNCTION_CALLS
     default: [TRUE] - Gives a warning when when function calls are
     being made which may not be correct due to improper declarations
     that were made at translate time.


 - Variable: TR_WARN_FEXPR
     default: [COMPFILE] - Gives a warning if any FEXPRs are
     encountered.  FEXPRs should not normally be output in translated
     code, all legitimate special program forms are translated.


 - Variable: TR_WARN_MEVAL
     default: [COMPFILE] - Gives a warning if the function MEVAL gets
     called.  If MEVAL is called that indicates problems in the
     translation.


 - Variable: TR_WARN_MODE
     default: [ALL] - Gives a warning when variables are assigned
     values inappropriate for their mode.


 - Variable: TR_WARN_UNDECLARED
     default: [COMPILE] - Determines when to send warnings about
     undeclared variables to the TTY.


 - Variable: TR_WARN_UNDEFINED_VARIABLE
     default: [ALL] - Gives a warning when undefined global variables
     are seen.


 - Variable: TR_WINDY
     default: [TRUE] - Generate "helpfull" comments and programming
     hints.


 - Variable: UNDECLAREDWARN
     default: [COMPFILE] - A switch in the Translator.  There are four
     relevant settings: SETTING     | ACTION
     ----------------------------------------------------------- FALSE
         | never print warning messages.  COMPFILE    | warn when in
     COMPFILE TRANSLATE   | warn when in TRANSLATE and when
     TRANSLATE:TRUE ALL         | warn in COMPFILE and TRANSLATE
     ----------------------------------------------------------- Do
     MODE_DECLARE(<variable>,ANY) to declare a variable to be a general
     macsyma variable (i.e. not limited to being FLOAT or FIXNUM).  The
     extra work in declaring all your variables in code  to be compiled
     should pay off.


 - Function: COMPILE_FILE (filename,&optional-outfile)
     It takes filename which contains macsyma code, and translates this
     to lisp and then compiles the result.  It returns a list of four
     files (the original file,translation, notes on translation and the
     compiled code).


 - Function: DECLARE_TRANSLATED (FN1,FN2..)
     When translating a file of macsyma code to lisp, it is important
     for the translator to know which functions it sees in the file are
     to be called as translated or compiled functions, and which ones
     are just macsyma functions or undefined.  Putting this declaration
     at the top of the file, lets it know that although a symbol does
     which does not yet have a lisp function value, will have one at
     call time.  (MFUNCTION-CALL fn arg1 arg2.. ) is generated when the
     translator does not know fn is going to be a lisp function.



File: maxima.info,  Node: Program Flow,  Next: Debugging,  Prev: Function Definition,  Up: Top

Program Flow
************

* Menu:

* Introduction to Program Flow::
* Definitions for Program Flow::


File: maxima.info,  Node: Introduction to Program Flow,  Next: Definitions for Program Flow,  Prev: Program Flow,  Up: Program Flow

Introduction to Program Flow
============================

MACSYMA provides a DO loop for iteration, as well as more primitive
constructs such as GO.


File: maxima.info,  Node: Definitions for Program Flow,  Prev: Introduction to Program Flow,  Up: Program Flow

Definitions for Program Flow
============================

 - Variable: BACKTRACE
     default: [] (when DEBUGMODE:ALL has been done) has as value a list
     of all functions currently entered.


 - special operator: DO
     - The DO statement is used for performing iteration.  Due to its
     great generality the DO statement will be described in two parts.
     First the usual form will be given which is analogous to that used
     in several other programming languages (FORTRAN, ALGOL, PL/I,
     etc.); then the other features will be mentioned.  1.  There are
     three variants of this form that differ only in their terminating
     conditions.  They are:
        * (a)  FOR variable : initial-value STEP increment       THRU
          limit DO body

        * (b)  FOR variable : initial-value STEP increment       WHILE
          condition DO body

        * (c)  FOR variable : initial-value STEP increment       UNLESS
          condition DO body
     (Alternatively, the STEP may be given after the termination
     condition or limit.)      The initial-value, increment, limit, and
     body can be any expressions.  If the increment is 1 then "STEP 1"
     may be omitted.      The execution of the DO statement proceeds by
     first assigning the initial-value to the variable (henceforth
     called the control-variable). Then: (1) If the control-variable
     has exceeded the limit of a THRU specification, or if the
     condition of the UNLESS is TRUE, or if the condition of the WHILE
     is FALSE then the DO terminates. (2) The body is evaluated.  (3)
     The increment is added to the control-variable.  The process from
     (1) to (3) is performed repeatedly until the termination condition
     is satisfied.  One may also give several termination conditions in
     which case the DO terminates when any of them is satisfied.
     In general the THRU test is satisfied when the control-variable is
     greater than the limit if the increment was non-negative, or when
     the control-variable is less than the limit if the increment was
     negative.  The increment and limit may be non-numeric expressions
     as long as this inequality can be determined.  However, unless the
     increment is syntactically negative (e.g. is a negative number) at
     the time the DO statement is input, MACSYMA assumes it will be
     positive when the DO is executed.  If it is not positive, then the
     DO may not terminate properly.      Note that the limit,
     increment, and termination condition are evaluated each time
     through the loop.  Thus if any of these involve much computation,
     and yield a result that does not change during all the executions
     of the body, then it is more efficient to set a variable to their
     value prior to the DO and use this variable in the DO form.
     The value normally returned by a DO statement is the atom DONE, as
     every statement in MACSYMA returns a value.  However, the function
     RETURN may be used inside the body to exit the DO prematurely and
     give it any desired value.  Note however that a RETURN within a DO
     that occurs in a BLOCK will exit only the DO and not the BLOCK.
     Note also that the GO function may not be used to exit from a DO
     into a surrounding BLOCK.      The control-variable is always
     local to the DO and thus any variable may be used without
     affecting the value of a variable with the same name outside of
     the DO.  The control-variable is unbound after the DO terminates.
          (C1)   FOR A:-3 THRU 26 STEP 7 DO LDISPLAY(A)$
          (E1)          A = -3
          (E2)          A =  4
          (E3)          A = 11
          (E4)          A = 18
          (E5)          A = 25
     The function LDISPLAY generates intermediate labels; DISPLAY does
     not.
          (C6)   S:0$
          (C7)   FOR I:1 WHILE I<=10 DO S:S+I;
          (D7)          DONE
          (C8)   S;
          (D8)          55
     Note that the condition in C7 is equivalent to UNLESS I > 10 and
     also THRU 10
          (C9)   SERIES:1$
          (C10)  TERM:EXP(SIN(X))$
          (C11)  FOR P:1 UNLESS P>7 DO
                    (TERM:DIFF(TERM,X)/P,
                    SERIES:SERIES+SUBST(X=0,TERM)*X^P)$
          (C12)   SERIES;
                          7    6     5    4    2
          (D12)          X    X     X    X    X
                         -- - --- - -- - -- + -- + X + 1
                         96   240   15   8    2
          which gives 8 terms of the Taylor series for e^sin(x).
          (C13) POLY:0$
          (C14) FOR I:1 THRU 5 DO
                  FOR J:I STEP -1 THRU 1 DO
                     POLY:POLY+I*X^J$
          (C15) POLY;
                        5      4       3       2
          (D15)      5 X  + 9 X  + 12 X  + 14 X  + 15 X
          (C16) GUESS:-3.0$
          (C17) FOR I:1 THRU 10 DO (GUESS:SUBST(GUESS,X,.5*(X+10/X)),
                   IF ABS(GUESS^2-10)<.00005 THEN RETURN(GUESS));
          (D17)                  - 3.1622807

     This example computes the negative square root of 10 using the
     Newton- Raphson iteration a maximum of 10 times.  Had the
     convergence criterion not been met the value returned would have
     been "DONE".  Additional Forms of the DO Statement     Instead of
     always adding a quantity to the control-variable one may sometimes
     wish to change it in some other way for each iteration.  In this
     case one may use "NEXT expression" instead of "STEP increment".
     This will cause the control-variable to be set to the result of
     evaluating expression each time through the loop.

          (C1)  FOR COUNT:2 NEXT 3*COUNT THRU 20
                   DO DISPLAY(COUNT)$
                              COUNT = 2
                              COUNT = 6
                              COUNT = 18

     As an alternative to FOR variable:value ...DO... the syntax FOR
     variable FROM value ...DO...  may be used.  This permits the "FROM
     value" to be placed after the step or next value or after the
     termination condition.  If "FROM value" is omitted then 1 is used
     as the initial value.      Sometimes one may be interested in
     performing an iteration where the control-variable is never
     actually used.  It is thus permissible to give only the
     termination conditions omitting the initialization and updating
     information as in the following example to compute the square-root
     of 5 using a poor initial guess.
          (C1) X:1000;
          (C2)  THRU 10 WHILE X#0.0 DO X:.5*(X+5.0/X)$
          (C3) X;
          (D3)               2.236068
         If it is desired one may even omit the termination conditions
     entirely and just give "DO body" which will continue to evaluate
     the body indefinitely.  In this case the function RETURN should be
     used to terminate execution of the DO.
          (C1) NEWTON(F,GUESS):=
            BLOCK([NUMER,Y],
                  LOCAL(DF),
                  NUMER:TRUE,
                  DEFINE(DF(X),DIFF(F(X),X)),
                  DO (Y:DF(GUESS),
                      IF Y=0.0 THEN ERROR("Derivative at:",GUESS," is zero."),
                      GUESS:GUESS-F(GUESS)/Y,
                      IF ABS(F(GUESS))<5.0E-6 THEN RETURN(GUESS)))$
          (C2) SQR(X):=X^2-5.0$
          (C3) NEWTON(SQR,1000);
          (D3)                    2.236068
         (Note that RETURN, when executed, causes the current value of
     GUESS to be returned as the value of the DO.  The BLOCK is exited
     and this value of the DO is returned as the value of the BLOCK
     because the DO is the last statement in the block.)      One other
     form of the DO is available in MACSYMA.  The syntax is:

          FOR variable IN list [end-tests] DO body
         The members of the list are any expressions which will
     successively be assigned to the variable on each iteration of the
     body.  The optional end-tests can be used to terminate execution of
     the DO; otherwise it will terminate when the list is exhausted or
     when a RETURN is executed in the body.  (In fact, list may be any
     non-atomic expression, and successive parts are taken.)

          (C1)  FOR F IN [LOG, RHO, ATAN] DO LDISP(F(1))$
          (E1)                                  0
          (E2)                                RHO(1)
                                               %PI
          (E3)                                 ---
                                                4
          (C4) EV(E3,NUMER);
          (D4)                             0.78539816

 - Function: ERRCATCH (exp1, exp2, ...)
     evaluates its arguments one by one and returns a list of the value
     of the last one if no error occurs.  If an error occurs in the
     evaluation of any arguments, ERRCATCH "catches" the error and
     immediately returns [] (the empty list).  This function is useful
     in BATCH files where one suspects an error might occur which would
     otherwise have terminated the BATCH if the error weren't caught.


 - Variable: ERREXP
     default: [ERREXP] When an error occurs in the course of a
     computation, MACSYMA prints out an error message and terminates the
     computation.  ERREXP is set to the offending expression and the
     message "ERREXP contains the offending expression" is printed.  The
     user can then type ERREXP; to see this and hopefully find the
     problem.


 - Function: ERROR (arg1, arg2, ...)
     will evaluate and print its arguments and then will cause an error
     return to top level MACSYMA or to the nearest enclosing ERRCATCH.
     This is useful for breaking out of nested functions if an error
     condition is detected, or wherever one can't type control-^.  The
     variable ERROR is set to a list describing the error, the first of
     it being a string of text, and the rest the objects in question.
     ERRORMSG(); is the preferred way to see the last error message.
     ERRORFUN default: [FALSE] - if set to the name of a function of no
     arguments will cause that function to be executed whenever an error
     occurs.  This is useful in BATCH files where the user may want his
     MACSYMA killed or his terminal logged out if an error occurs.  In
     these cases ERRORFUN would be set to QUIT or LOGOUT.


 - Variable: ERRORFUN
     default: [FALSE] - if set to the name of a function of no
     arguments will cause that function to be executed whenever an error
     occurs.  This is useful in BATCH files where the user may want his
     MACSYMA killed or his terminal logged out if an error occurs.  In
     these cases ERRORFUN would be set to QUIT or LOGOUT.


 - Function: ERRORMSG ()
     reprints the last error message.  This is very helpful if you are
     using a display console and the message has gone off the screen.
     The variable ERROR is set to a list describing the error, the
     first of it being a string of text, and the rest the objects in
     question.  TTYINTFUN:LAMBDA([],ERRORMSG(),PRINT(""))$ will set up
     the user-interrupt character (^U) to reprint the message.


 - special operator: FOR
     - Used in iterations, do DESCRIBE("DO"); for a description of
     MACSYMA's iteration facilities.


 - Function: GO (tag)
     is used within a BLOCK to transfer control to the statement of the
     block which is tagged with the argument to GO.  To tag a
     statement, precede it by an atomic argument as another statement in
     the BLOCK.  For example:
          BLOCK([X],X:1,LOOP,X+1,...,GO(LOOP),...)
     .  The argument to GO must be the name of a tag appearing in the
     same BLOCK.  One cannot use GO to transfer to tag in a BLOCK other
     than the one containing the GO.


 - special operator: IF
     - The IF statement is used for conditional execution.  The syntax
     is:
              IF condition THEN expression1 ELSE expression2.
     The result of an IF statement is expression1 if condition is true
     and expression2 if it is false.  expression1 and expression2 are
     any MACSYMA expressions (including nested IF statements), and
     condition is an expression which evaluates to TRUE or FALSE and is
     composed of relational and logical operators which are as follows:

          Operator name       Symbol      Type
          greater than        >           relational infix
          equal to            = , EQUAL   "  "
          not equal to        #           "  "
          less than           <           "  "
          greater than        >=
            or equal to                   "  "
          less than           <=
            or equal to                   "  "
          and                 AND         logical infix
          or                  OR          "  "
          not                 NOT         logical prefix

 - Function: LISPDEBUGMODE ()
     LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG(); make available to
     the user debugging features used by systems programmers.  These
     tools are powerful, and although some conventions are different
     from the usual macsyma level it is felt their use is very
     intuitive.  [Some printout may be verbose for slow terminals,
     there are switches for controlling this.]  These commands were
     designed for the user who must debug translated macsyma code, as
     such they are a boon.  See MACDOC;TRDEBG USAGE for more
     information.


 - Function: MAP (fn, exp1, exp2, ...)
     returns an expression whose leading operator is the same as that
     of the expi but whose subparts are the results of applying fn to
     the corresponding subparts of the expi.  Fn is either the name of
     a function of n arguments (where n is the number of expi) or is a
     LAMBDA form of n arguments.  MAPERROR[TRUE] - if FALSE will cause
     all of the mapping functions to (1) stop when they finish going
     down the shortest expi if not all of the expi are of the same
     length and (2) apply fn to [exp1, exp2,...]  if the expi are not
     all the same type of object. If MAPERROR is TRUE then an error
     message will be given in the above two instances.  One of the uses
     of this function is to MAP a function (e.g. PARTFRAC) onto each
     term of a very large expression where it ordinarily wouldn't be
     possible to use the function on the entire expression due to an
     exhaustion of list storage space in the course of the computation.
          (C1) MAP(F,X+A*Y+B*Z);
          (D1)                        F(B Z) + F(A Y) + F(X)
          (C2) MAP(LAMBDA([U],PARTFRAC(U,X)),X+1/(X^3+4*X^2+5*X+2));
                                     1       1        1
          (D2)                     ----- - ----- + -------- + X
                                   X + 2   X + 1          2
                                                   (X + 1)
          (C3) MAP(RATSIMP, X/(X^2+X)+(Y^2+Y)/Y);
                                                1
          (D3)                            Y + ----- + 1
                                              X + 1
          (C4) MAP("=",[A,B],[-0.5,3]);
          (D4)                          [A = - 0.5, B = 3]

 - Function: MAPATOM (expr)
     is TRUE if and only if expr is treated by the MAPping routines as
     an "atom", a unit.  "Mapatoms" are atoms, numbers (including
     rational numbers), and subscripted variables.


 - Variable: MAPERROR
     default: [TRUE] - if FALSE will cause all of the mapping
     functions, for example
          MAP(fn,exp1,exp2,...))
     to (1) stop when they finish going down the shortest expi if not
     all of the expi are of the same length and (2) apply fn to [exp1,
     exp2,...] if the expi are not all the same type of object.  If
     MAPERROR is TRUE then an error message will be given in the above
     two instances.


 - Function: MAPLIST (fn, exp1, exp2, ...)
     yields a list of the applications of fn to the parts of the expi.
     This differs from MAP(fn,exp1,exp2,...)  which returns an
     expression with the same main operator as expi has (except for
     simplifications and the case where MAP does an APPLY).  Fn is of
     the same form as in MAP.


 - Variable: PREDERROR
     default: [TRUE] - If TRUE, an error message is signalled whenever
     the predicate of an IF statement or an IS function fails to
     evaluate to either TRUE or FALSE.  If FALSE, UNKNOWN is returned
     instead in this case.  The PREDERROR:FALSE mode is not supported in
     translated code.


 - Function: RETURN (value)
     may be used to exit explicitly from a BLOCK, bringing its
     argument.  Do DESCRIBE(BLOCK); for more information.


 - Function: SCANMAP (function,exp)
     recursively applies function to exp, in a "top down" manner.  This
     is most useful when "complete" factorization is desired, for
     example:
          (C1) EXP:(A^2+2*A+1)*Y + X^2$
          (C2) SCANMAP(FACTOR,EXP);
                                              2      2
          (D2)                         (A + 1)  Y + X

     Note the way in which SCANMAP applies the given function FACTOR to
     the constituent subexpressions of exp; if another form of exp is
     presented to SCANMAP then the result may be different.  Thus, D2
     is not recovered when SCANMAP is applied to the expanded form of
     exp:
          (C3) SCANMAP(FACTOR,EXPAND(EXP));
                                     2                  2
          (D3)                      A  Y + 2 A Y + Y + X

     Here is another example of the way in which SCANMAP recursively
     applies a given function to all subexpressions, including
     exponents:
          (C4) EXPR : U*V^(A*X+B) + C$
          (C5) SCANMAP('F, EXPR);
                              F(F(F(A) F(X)) + F(B))
          (D5) F(F(F(U) F(F(V)                      )) + F(C))
     SCANMAP(function,expression,BOTTOMUP) applies function to exp in a
     "bottom-up" manner.  E.g., for undefined F,

          SCANMAP(F,A*X+B) ->
             F(A*X+B) -> F(F(A*X)+F(B)) -> F(F(F(A)*F(X))+F(B))
          SCANMAP(F,A*X+B,BOTTOMUP) -> F(A)*F(X)+F(B)
              -> F(F(A)*F(X))+F(B) ->
               F(F(F(A)*F(X))+F(B))

     In this case, you get the same answer both ways.


 - Function: THROW (exp)
     evaluates exp and throws the value back to the most recent CATCH.
     THROW is used with CATCH as a structured nonlocal exit mechanism.



File: maxima.info,  Node: Debugging,  Next: Function and Variable Index,  Prev: Program Flow,  Up: Top

Debugging
*********

* Menu:

* Source Level Debugging::
* Keyword Commands::
* Definitions for Debugging::


File: maxima.info,  Node: Source Level Debugging,  Next: Keyword Commands,  Up: Debugging

Source Level Debugging
======================

Maxima has source level capabilities.  A user can set a breakpoint at a
line in a file, and then step line by line from there.  The call stack
may be examined, together with the variables bound at that level.  If
the user is running the code under GNU emacs in a shell window (dbl
shell), or is running `xmaxima' the graphical interface version, then
if he stops at a break point, he will see his current position in the
source file which will be displayed in the other half of the window,
either highlighted in red, or with a little arrow pointing at the right
line.  He can advance single lines at a time by typing M-n (Alt-n) or
alternately by entering `:n'.  To see the names of the keyword commands
type :help (or :h).  In general commands may be abbreviated if the
abbreviation is unique.  If not unique the alternatives will be listed.

   Under Emacs you should run in a `dbl' shell, which requires the
dbl.el file in the elisp directory.  Make sure you install the elisp
files or add the maxima elisp directory to your path: eg add the
following to your `.emacs' file or the `site-init.el'

     (setq load-path (cons "/usr/local/maxima-5.5/elisp" load-path))
     (autoload 'dbl "dbl")
   then in emacs
     M-x dbl
   should start a shell window in which you can run programs, for
example maxima, gcl, gdb etc.   This shell window also knows about
source level debugging, and display of source code in the other window.

     maxima
     Maxima 5.5 Wed Apr 18 19:02:00 CDT 2001 (with enhancements by W. Schelter).
     Licensed under the GNU Public License (see file COPYING)
     (C1) batchload("/tmp/joe.mac");
     (D1) 				 /tmp/joe.mac
     (C2) :br joe
     Turning on debugging debugmode(true)
     Bkpt 0 for joe (in /tmp/joe.mac line 8)
     (C2) foo(2,3);
     Bkpt 0:(joe.mac 8)
     (dbm:1) :bt                        <-- :bt typed here gives a backtrace
     #0: joe(y=5)(joe.mac line 8)
     #1: foo(x=2,y=3)(joe.mac line 5)
     (joe.mac 9)                        <-- Here type M-n to advance line
     (joe.mac 10)                       <-- Here type M-n to advance line
                                        In the other buffer the source code
                                        appears with an arrow.
     (dbm:1) u;                         Investigate value of 'u
     28
     (dbm:1) u:33;                      Alter it to be 33
     (dbm:1) :r                         :r Resumes the computation
     (D3) 				     1094

   The actual file /tmp/joe.mac is the following:

     foo(x,y):=(
       x:x+2,
       y:y+2,
       x:joe(y),
       x+y);
     
     joe(y):=block([u:y^2],
       u:u+3,
       u:u^2,
        u);

   If you are running in Gnu Emacs then if you are looking at the file
joe.mac, you may set a break point at a certain line of that file by
typing `C-x space'.  This figures out which function your cursor is in,
and then it sees which line of that function you are on.   If you are
on say line 2 of joe, then it will insert in the other window `:br joe
2' the command to break joe at its second line.   To have this enabled
you must have maxima-mode.el on in the window in which the file joe.mac
is visiting.  There are additional commands available in that file
window, such as evaluating the function into the maxima, by typing
`Alt-Control-x'


File: maxima.info,  Node: Keyword Commands,  Next: Definitions for Debugging,  Prev: Source Level Debugging,  Up: Debugging

Keyword Commands
================

Break commands start with ':'.   Thus to evaluate a lisp form you may
type `:lisp ' followed by the argument which is the form to be
evaluated.
     (C3) :lisp (+ 2 3)
     5
   The number of arguments taken depends on the particular command.
Also you need not type the whole command, just enough to be unique among
the keyword commands.   Thus `:br' would suffice for `:break'.  The
current commands are:

`:break'
     Set a breakpoint in the specified FUNCTION at the specified LINE
     offset from the beginning of the function.  If FUNCTION is given
     as a string, then it is presumed to be a FILE and LINE is the
     offset from the beginning of the file.

`:bt'
     Undocumented

`:continue'
     Continue the computation.

`:delete'
     Delete all breakpoints, or if arguments are supplied delete the
     specified breakpoints

`:disable'
     Disable the specified breakpoints, or all if none are specified

`:enable'
     Enable the specified breakpoints, or all if none are specified

`:frame'
     With an argument print the selected stack frame.  Otherwise the
     current frame.

`:help'
     Print help on a break command or with no arguments on all break
     commands

`:info'
     Undocumented

`:lisp'
     Evaluate the lisp form following on the line

`:lisp-quiet'
     Evaluate its arg as a lisp form without printing a prompt.

`:next     Like :step, except that subroutine calls are stepped over'

`:quit'
     Quit this level

`:resume'
     Continue the computation.

`:step'
     Step program until it reaches a new source line

`:top'
     Throw to top level


File: maxima.info,  Node: Definitions for Debugging,  Prev: Keyword Commands,  Up: Debugging

Definitions for Debugging
=========================

 - Variable: REFCHECK
     default: [FALSE] - if TRUE causes a message to be printed each
     time a bound variable is used for the first time in a computation.


 - Function: REMTRACE ()
     This function is no longer used with the new TRACE package.


 - Variable: SETCHECK
     default: [FALSE] - if set to a list of variables (which can be
     subscripted) will cause a printout whenever the variables, or
     subscripted occurrences of them, are bound (with : or :: or
     function argument binding).  The printout consists of the variable
     and the value it is bound to.  SETCHECK may be set to ALL or TRUE
     thereby including all variables.  Note: No printout is generated
     when a SETCHECKed variable is set to itself, e.g. X:'X.


 - Variable: SETCHECKBREAK
     default: [FALSE] - if set to TRUE will cause a (MACSYMA-BREAK) to
     occur whenever the variables on the SETCHECK list are bound.  The
     break occurs before the binding is done.  At this point, SETVAL
     holds the value to which the variable is about to be set.  Hence,
     one may change this value by resetting SETVAL.


 - Variable: SETVAL
     - holds the value to which a variable is about to be set when a
     SETCHECKBREAK occurs.  Hence, one may change this value by
     resetting SETVAL.  (See SETCHECKBREAK).


 - Function: TIMER (F)
     will put a timer-wrapper on the function F, within the TRACE
     package, i.e. it will print out the time spent in computing F.


 - Variable: TIMER_DEVALUE
     default: [FALSE] - when set to TRUE then the time charged against
     a function is the time spent dynamically inside the function
     devalued by the time spent inside other TIMED functions.


 - Function: TIMER_INFO (F)
     will print the information on timing which is stored also as
     GET('F,'CALLS); GET('F,'RUNTIME); and GET('F,'GCTIME); .  This is
     a TRACE package function.


 - Function: TRACE (name1, name2, ...)
     gives a trace printout whenever the functions mentioned are
     called.  TRACE() prints a list of the functions currently under
     TRACE.  On MC see MACDOC;TRACE USAGE for more information.  Also,
     DEMO("trace.dem"); .  To remove tracing, see UNTRACE.


 - Function: TRACE_OPTIONS (F,option1,option2,...)
     gives the function F the options indicated.  An option is either a
     keyword or an expression.  The possible Keywords are:  Keyword
     Meaning of return value ---------------------------------------
     NOPRINT     If TRUE do no printing.   BREAK       If TRUE give a
     breakpoint.   LISP_PRINT  If TRUE use lisp printing.   INFO
     Extra info to print.   ERRORCATCH  If TRUE errors are caught.  A
     keyword means that the option is in effect.  Using a keyword as an
     expression, e.g. NOPRINT(predicate_function) means to apply the
     predicate_function (which is user-defined) to some arguments to
     determine if the option is in effect. The argument list to this
     predicate_function is always [LEVEL, DIRECTION, FUNCTION, ITEM]
     where LEVEL is the recursion level for the function.  DIRECTION is
     either ENTER or EXIT.  FUNCTION is the name of the function.  ITEM
     is either the argument list or the return value.  On MC see
     DEMO("trace.dem"); for more details.


 - Function: UNTRACE (name1, ...)
     removes tracing invoked by the TRACE function.  UNTRACE() removes
     tracing from all functions.


