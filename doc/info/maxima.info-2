This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Functions and Variables for Input and Output,  Prev: Files,  Up: Input and Output

9.3 Functions and Variables for Input and Output
================================================

 -- System variable: __
     `__' is the input expression currently being evaluated.  That is,
     while an input expression <expr> is being evaluated, `__' is
     <expr>.

     `__' is assigned the input expression before the input is
     simplified or evaluated.  However, the value of `__' is simplified
     (but not evaluated) when it is displayed.

     `__' is recognized by `batch' and `load'.  In a file processed by
     `batch', `__' has the same meaning as at the interactive prompt.
     In a file processed by `load', `__' is bound to the input
     expression most recently entered at the interactive prompt or in a
     batch file; `__' is not bound to the input expressions in the file
     being processed.  In particular, when `load (<filename>)' is
     called from the interactive prompt, `__' is bound to `load
     (<filename>)' while the file is being processed.

     See also `_' and `%'.

     Examples:

          (%i1) print ("I was called as", __);
          I was called as print(I was called as, __)
          (%o1)              print(I was called as, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Current input expression =", __), 0);
          (%o3) g(x) := (print("Current input expression =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd


 -- System variable: _
     `_' is the most recent input expression (e.g., `%i1', `%i2',
     `%i3', ...).

     `_' is assigned the input expression before the input is
     simplified or evaluated.  However, the value of `_' is simplified
     (but not evaluated) when it is displayed.

     `_' is recognized by `batch' and `load'.  In a file processed by
     `batch', `_' has the same meaning as at the interactive prompt.
     In a file processed by `load', `_' is bound to the input
     expression most recently evaluated at the interactive prompt or in
     a batch file; `_' is not bound to the input expressions in the
     file being processed.

     See also `__' and `%'.

     Examples:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42


 -- System variable: %
     `%' is the output expression (e.g., `%o1', `%o2', `%o3', ...)
     most recently computed by Maxima, whether or not it was displayed.

     `%' is recognized by `batch' and `load'.  In a file processed by
     `batch', `%' has the same meaning as at the interactive prompt.
     In a file processed by `load', `%' is bound to the output
     expression most recently computed at the interactive prompt or in
     a batch file; `%' is not bound to output expressions in the file
     being processed.

     See also `_', `%%', and `%th'.


 -- System variable: %%
     In compound statements, namely `block', `lambda', or `(<s_1>, ...,
     <s_n>)', `%%' is the value of the previous statement.  For example,

          block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
          block ([prev], prev: integrate (x^5, x),
                         ev (prev, x=2) - ev (prev, x=1));

     yield the same result, namely `21/2'.

     A compound statement may comprise other compound statements.
     Whether a statement be simple or compound, `%%' is the value of
     the previous statement.  For example,

          block (block (a^n, %%*42), %%/6)

     yields `7*a^n'.

     Within a compound statement, the value of `%%' may be inspected at
     a break prompt, which is opened by executing the `break' function.
     For example, at the break prompt opened by

          block (a: 42, break ())$

     entering `%%;' yields `42'.

     At the first statement in a compound statement, or outside of a
     compound statement, `%%' is undefined.

     `%%' is recognized by `batch' and `load', and it has the same
     meaning as at the interactive prompt.

     See also `%'.


 -- Option variable: %edispflag
     Default value: `false'

     When `%edispflag' is `true', Maxima displays `%e' to a negative
     exponent as a quotient.  For example, `%e^-x' is displayed as
     `1/%e^x'.


 -- Function: %th (<i>)
     The value of the <i>'th previous output expression.  That is, if
     the next expression to be computed is the <n>'th output, `%th
     (<m>)' is the (<n> - <m>)'th output.

     `%th' is useful in `batch' files or for referring to a group of
     output expressions.  For example,

          block (s: 0, for i:1 thru 10 do s: s + %th (i))$

     sets `s' to the sum of the last ten output expressions.

     `%th' is recognized by `batch' and `load'.  In a file processed by
     `batch', `%th' has the same meaning as at the interactive prompt.
     In a file processed by `load', `%th' refers to output expressions
     most recently computed at the interactive prompt or in a batch
     file; `%th' does not refer to output expressions in the file being
     processed.

     See also `%'.


 -- Special symbol: ?
     As prefix to a function or variable name, `?' signifies that the
     name is a Lisp name, not a Maxima name.  For example, `?round'
     signifies the Lisp function `ROUND'.  See *Note Lisp and Maxima::
     for more on this point.

     The notation `? word' (a question mark followed a word, separated
     by whitespace) is equivalent to `describe("word")'.  The question
     mark must occur at the beginning of an input line; otherwise it is
     not recognized as a request for documentation.


 -- Special symbol: ??
     The notation `?? word' (`??' followed a word, separated by
     whitespace) is equivalent to `describe("word", inexact)'.  The
     question mark must occur at the beginning of an input line;
     otherwise it is not recognized as a request for documentation.


 -- Option variable: absboxchar
     Default value: `!'

     `absboxchar' is the character used to draw absolute value signs
     around expressions which are more than one line tall.


 -- Option variable: file_output_append
     Default value: `false'

     `file_output_append' governs whether file output functions append
     or truncate their output file.  When `file_output_append' is
     `true', such functions append to their output file.  Otherwise,
     the output file is truncated.

     `save', `stringout', and `with_stdout' respect
     `file_output_append'.  Other functions which write output files do
     not respect `file_output_append'.  In particular, plotting and
     translation functions always truncate their output file, and `tex'
     and `appendfile' always append.


 -- Function: appendfile (<filename>)
     Appends a console transcript to <filename>.  `appendfile' is the
     same as `writefile', except that the transcript file, if it
     exists, is always appended.

     `closefile' closes the transcript file opened by `appendfile' or
     `writefile'.


 -- Function: batch (<filename>)
     Reads Maxima expressions from <filename> and evaluates them.
     `batch' searches for <filename> in the list `file_search_maxima'.
     See `file_search'.

     <filename> comprises a sequence of Maxima expressions, each
     terminated with `;' or `$'.  The special variable `%' and the
     function `%th' refer to previous results within the file.  The
     file may include `:lisp' constructs.  Spaces, tabs, and newlines
     in the file are ignored.  A suitable input file may be created by
     a text editor or by the `stringout' function.

     `batch' reads each input expression from <filename>, displays the
     input to the console, computes the corresponding output expression,
     and displays the output expression.  Input labels are assigned to
     the input expressions and output labels are assigned to the output
     expressions.  `batch' evaluates every input expression in the file
     unless there is an error.  If user input is requested (by
     `asksign' or `askinteger', for example) `batch' pauses to collect
     the requisite input and then continue.

     It may be possible to halt `batch' by typing `control-C' at the
     console.  The effect of `control-C' depends on the underlying Lisp
     implementation.

     `batch' has several uses, such as to provide a reservoir for
     working command lines, to give error-free demonstrations, or to
     help organize one's thinking in solving complex problems.

     `batch' evaluates its argument.  `batch' has no return value.

     See also `load', `batchload', and `demo'.


 -- Function: batchload (<filename>)
     Reads Maxima expressions from <filename> and evaluates them,
     without displaying the input or output expressions and without
     assigning labels to output expressions.  Printed output (such as
     produced by `print' or `describe') is displayed, however.

     The special variable `%' and the function `%th' refer to previous
     results from the interactive interpreter, not results within the
     file.  The file cannot include `:lisp' constructs.

     `batchload' returns the path of <filename>, as a string.
     `batchload' evaluates its argument.

     See also `batch' and `load'.


 -- Function: closefile ()
     Closes the transcript file opened by `writefile' or `appendfile'.


 -- Function: collapse (<expr>)
     Collapses <expr> by causing all of its common (i.e., equal)
     subexpressions to share (i.e., use the same cells), thereby saving
     space.  (`collapse' is a subroutine used by the `optimize'
     command.)  Thus, calling `collapse' may be useful after loading in
     a `save' file.  You can collapse several expressions together by
     using `collapse ([<expr_1>, ..., <expr_n>])'.  Similarly, you can
     collapse the elements of the array `A' by doing `collapse
     (listarray ('A))'.


 -- Function: concat (<arg_1>, <arg_2>, ...)
     Concatenates its arguments.  The arguments must evaluate to atoms.
     The return value is a symbol if the first argument is a symbol and
     a Maxima string otherwise.

     `concat' evaluates its arguments.  The single quote `'' prevents
     evaluation.

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     A symbol constructed by `concat' may be assigned a value and
     appear in expressions.  The `::' (double colon) assignment
     operator evaluates its left-hand side.

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     Note that although `concat (1, 2)' looks like a number, it is a
     Maxima string.

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3


 -- Function: sconcat (<arg_1>, <arg_2>, ...)
     Concatenates its arguments into a string.  Unlike `concat', the
     arguments do not need to be atoms.

     The result is a Lisp string.

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3


 -- Function: disp (<expr_1>, <expr_2>, ...)
     is like `display' but only the value of the arguments are
     displayed rather than equations.  This is useful for complicated
     arguments which don't have names or where only the value of the
     argument is of interest and not the name.


 -- Function: dispcon (<tensor_1>, <tensor_2>, ...)
 -- Function: dispcon (all)
     Displays the contraction properties of its arguments as were given
     to `defcon'.  `dispcon (all)' displays all the contraction
     properties which were defined.


 -- Function: display (<expr_1>, <expr_2>, ...)
     Displays equations whose left side is <expr_i> unevaluated, and
     whose right side is the value of the expression centered on the
     line.  This function is useful in blocks and `for' statements in
     order to have intermediate results displayed.  The arguments to
     `display' are usually atoms, subscripted variables, or function
     calls.  See also `disp'.

          (%i1) display(B[1,2]);
                                                2
                                   B     = X - X
                                    1, 2
          (%o1)                            done


 -- Option variable: display2d
     Default value: `true'

     When `display2d' is `false', the console display is a string
     (1-dimensional) form rather than a display (2-dimensional) form.


 -- Option variable: display_format_internal
     Default value: `false'

     When `display_format_internal' is `true', expressions are
     displayed without being transformed in ways that hide the internal
     mathematical representation.  The display then corresponds to what
     `inpart' returns rather than `part'.

     Examples:

          User     part       inpart
          a-b;      A - B     A + (- 1) B

                     A            - 1
          a/b;       -         A B
                     B
                                 1/2
          sqrt(x);   sqrt(X)    X

                    4 X        4
          X*4/3;    ---        - X
                     3         3


 -- Function: dispterms (<expr>)
     Displays <expr> in parts one below the other.  That is, first the
     operator of <expr> is displayed, then each term in a sum, or
     factor in a product, or part of a more general expression is
     displayed separately.  This is useful if <expr> is too large to be
     otherwise displayed.  For example if `P1', `P2', ...  are very
     large expressions then the display program may run out of storage
     space in trying to display `P1 + P2 + ...'  all at once.  However,
     `dispterms (P1 + P2 + ...)' displays `P1', then below it `P2',
     etc.  When not using `dispterms', if an exponential expression is
     too wide to be displayed as `A^B' it appears as `expt (A, B)' (or
     as `ncexpt (A, B)' in the case of `A^^B').


 -- Option variable: error_size
     Default value: 10

     `error_size' modifies error messages according to the size of
     expressions which appear in them.  If the size of an expression
     (as determined by the Lisp function `ERROR-SIZE') is greater than
     `error_size', the expression is replaced in the message by a
     symbol, and the symbol is assigned the expression.  The symbols
     are taken from the list `error_syms'.

     Otherwise, the expression is smaller than `error_size', and the
     expression is displayed in the message.

     See also `error' and `error_syms'.

     Example:

     The size of `U', as determined by `ERROR-SIZE', is 24.

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);


 -- Option variable: error_syms
     Default value: `[errexp1, errexp2, errexp3]'

     In error messages, expressions larger than `error_size' are
     replaced by symbols, and the symbols are set to the expressions.
     The symbols are taken from the list `error_syms'.  The first
     too-large expression is replaced by `error_syms[1]', the second by
     `error_syms[2]', and so on.

     If there are more too-large expressions than there are elements of
     `error_syms', symbols are constructed automatically, with the
     <n>-th symbol equivalent to `concat ('errexp, <n>)'.

     See also `error' and `error_size'.


 -- Function: expt (<a>, <b>)
     If an exponential expression is too wide to be displayed as
     `<a>^<b>' it appears as `expt (<a>, <b>)' (or as `ncexpt (<a>,
     <b>)' in the case of `<a>^^<b>').

     `expt' and `ncexpt' are not recognized in input.


 -- Option variable: exptdispflag
     Default value: `true'

     When `exptdispflag' is `true', Maxima displays expressions with
     negative exponents using quotients, e.g., `X^(-1)' as `1/X'.


 -- Function: filename_merge (<path>, <filename>)
     Constructs a modified path from <path> and <filename>.  If the
     final component of <path> is of the form `###.<something>', the
     component is replaced with `<filename>.<something>'.  Otherwise,
     the final component is simply replaced by <filename>.


 -- Function: file_search (<filename>)
 -- Function: file_search (<filename>, <pathlist>)
     `file_search' searches for the file <filename> and returns the
     path to the file (as a string) if it can be found; otherwise
     `file_search' returns `false'.  `file_search (<filename>)'
     searches in the default search directories, which are specified by
     the `file_search_maxima', `file_search_lisp', and
     `file_search_demo' variables.

     `file_search' first checks if the actual name passed exists,
     before attempting to match it to "wildcard" file search patterns.
     See `file_search_maxima' concerning file search patterns.

     The argument <filename> can be a path and file name, or just a
     file name, or, if a file search directory includes a file search
     pattern, just the base of the file name (without an extension).
     For example,

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     all find the same file, assuming the file exists and
     `/home/wfs/special/###.mac' is in `file_search_maxima'.

     `file_search (<filename>, <pathlist>)' searches only in the
     directories specified by <pathlist>, which is a list of strings.
     The argument <pathlist> supersedes the default search directories,
     so if the path list is given, `file_search' searches only the ones
     specified, and not any of the default search directories.  Even if
     there is only one directory in <pathlist>, it must still be given
     as a one-element list.

     The user may modify the default search directories. See
     `file_search_maxima'.

     `file_search' is invoked by `load' with `file_search_maxima' and
     `file_search_lisp' as the search directories.


 -- Option variable: file_search_maxima
 -- Option variable: file_search_lisp
 -- Option variable: file_search_demo
     These variables specify lists of directories to be searched by
     `load', `demo', and some other Maxima functions.  The default
     values of these variables name various directories in the Maxima
     installation.

     The user can modify these variables, either to replace the default
     values or to append additional directories.  For example,

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     replaces the default value of `file_search_maxima', while

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     appends two additional directories.  It may be convenient to put
     such an expression in the file `maxima-init.mac' so that the file
     search path is assigned automatically when Maxima starts.

     Multiple filename extensions and multiple paths can be specified by
     special "wildcard" constructions.  The string `###' expands into
     the sought-after name, while a comma-separated list enclosed in
     curly braces `{foo,bar,baz}' expands into multiple strings.  For
     example, supposing the sought-after name is `neumann',

          "/home/{wfs,gcj}/###.{lisp,mac}"

     expands into `/home/wfs/neumann.lisp', `/home/gcj/neumann.lisp',
     `/home/wfs/neumann.mac', and `/home/gcj/neumann.mac'.


 -- Function: file_type (<filename>)
     Returns a guess about the content of <filename>, based on the
     filename extension.  <filename> need not refer to an actual file;
     no attempt is made to open the file and inspect the content.

     The return value is a symbol, either `object', `lisp', or `maxima'.
     If the extension starts with `m' or `d', `file_type' returns
     `maxima'.  If the extension starts with `l', `file_type' returns
     `lisp'.  If none of the above, `file_type' returns `object'.


 -- Function: grind (<expr>)
 -- Option variable: grind
     The function `grind' prints <expr> to the console in a form
     suitable for input to Maxima.  `grind' always returns `done'.

     When <expr> is the name of a function or macro, `grind' prints the
     function or macro definition instead of just the name.

     See also `string', which returns a string instead of printing its
     output.  `grind' attempts to print the expression in a manner
     which makes it slightly easier to read than the output of `string'.

     When the variable `grind' is `true', the output of `string' and
     `stringout' has the same format as that of `grind'; otherwise no
     attempt is made to specially format the output of those functions.
     The default value of the variable `grind' is `false'.

     `grind' can also be specified as an argument of `playback'.  When
     `grind' is present, `playback' prints input expressions in the
     same format as the `grind' function.  Otherwise, no attempt is
     made to specially format input expressions.

     `grind' evaluates its argument.

     Examples:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
            p : makelist (0, i, 1, length (A))], for i thru n do
            for j : i thru n do
            (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1),
            if i = j then p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]),
            for i thru n do L[i, i] : 1 / p[i],
            for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)


 -- Option variable: ibase
     Default value: 10

     Integers entered into Maxima are interpreted with respect to the
     base `ibase'.

     `ibase' may be assigned any integer between 2 and 35 (decimal),
     inclusive.  When `ibase' is greater than 10, the numerals comprise
     the decimal numerals 0 through 9 plus capital letters of the
     alphabet A, B, C, ..., as needed.  The numerals for base 35, the
     largest acceptable base, comprise 0 through 9 and A through Y.

     See also `obase'.


 -- Option variable: inchar
     Default value: `%i'

     `inchar' is the prefix of the labels of expressions entered by the
     user.  Maxima automatically constructs a label for each input
     expression by concatenating `inchar' and `linenum'.  `inchar' may
     be assigned any string or symbol, not necessarily a single
     character.

          (%i1) inchar: "input";
          (%o1)                                input
          (input1) expand ((a+b)^3);
                                      3        2      2      3
          (%o1)                      b  + 3 a b  + 3 a  b + a
          (input2)

     See also `labels'.


 -- Function: ldisp (<expr_1>, ..., <expr_n>)
     Displays expressions <expr_1>, ..., <expr_n> to the console as
     printed output.  `ldisp' assigns an intermediate expression label
     to each argument and returns the list of labels.

     See also `disp'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a


 -- Function: ldisplay (<expr_1>, ..., <expr_n>)
     Displays expressions <expr_1>, ..., <expr_n> to the console as
     printed output.  Each expression is printed as an equation of the
     form `lhs = rhs' in which `lhs' is one of the arguments of
     `ldisplay' and `rhs' is its value.  Typically each argument is a
     variable.  `ldisp' assigns an intermediate expression label to
     each equation and returns the list of labels.

     See also `display'.

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a


 -- Option variable: linechar
     Default value: `%t'

     `linechar' is the prefix of the labels of intermediate expressions
     generated by Maxima.  Maxima constructs a label for each
     intermediate expression (if displayed) by concatenating `linechar'
     and `linenum'.  `linechar' may be assigned any string or symbol,
     not necessarily a single character.

     Intermediate expressions might or might not be displayed.  See
     `programmode' and `labels'.


 -- Option variable: linel
     Default value: 79

     `linel' is the assumed width (in characters) of the console display
     for the purpose of displaying expressions.  `linel' may be
     assigned any value by the user, although very small or very large
     values may be impractical.  Text printed by built-in Maxima
     functions, such as error messages and the output of `describe', is
     not affected by `linel'.


 -- Option variable: lispdisp
     Default value: `false'

     When `lispdisp' is `true', Lisp symbols are displayed with a
     leading question mark `?'.  Otherwise, Lisp symbols are displayed
     with no leading mark.

     Examples:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar


 -- Function: load (<filename>)
     Evaluates expressions in <filename>, thus bringing variables,
     functions, and other objects into Maxima.  The binding of any
     existing object is clobbered by the binding recovered from
     <filename>.  To find the file, `load' calls `file_search' with
     `file_search_maxima' and `file_search_lisp' as the search
     directories.  If `load' succeeds, it returns the name of the file.
     Otherwise `load' prints an error message.

     `load' works equally well for Lisp code and Maxima code.  Files
     created by `save', `translate_file', and `compile_file', which
     create Lisp code, and `stringout', which creates Maxima code, can
     all be processed by `load'.  `load' calls `loadfile' to load Lisp
     files and `batchload' to load Maxima files.

     `load' does not recognize `:lisp' constructs in Maxima files, and
     while processing <filename>, the global variables `_', `__', `%',
     and `%th' have whatever bindings they had when `load' was called.

     See also `loadfile', `batch', `batchload', and `demo'.  `loadfile'
     processes Lisp files; `batch', `batchload', and `demo' process
     Maxima files.

     See `file_search' for more detail about the file search mechanism.

     `load' evaluates its argument.


 -- Function: loadfile (<filename>)
     Evaluates Lisp expressions in <filename>.  `loadfile' does not
     invoke `file_search', so `filename' must include the file
     extension and as much of the path as needed to find the file.

     `loadfile' can process files created by `save', `translate_file',
     and `compile_file'.  The user may find it more convenient to use
     `load' instead of `loadfile'.


 -- Option variable: loadprint
     Default value: `true'

     `loadprint' tells whether to print a message when a file is loaded.

        * When `loadprint' is `true', always print a message.

        * When `loadprint' is `'loadfile', print a message only if a
          file is loaded by the function `loadfile'.

        * When `loadprint' is `'autoload', print a message only if a
          file is automatically loaded.  See `setup_autoload'.

        * When `loadprint' is `false', never print a message.


 -- Option variable: obase
     Default value: 10

     `obase' is the base for integers displayed by Maxima.

     `obase' may be assigned any integer between 2 and 35 (decimal),
     inclusive.  When `obase' is greater than 10, the numerals comprise
     the decimal numerals 0 through 9 plus capital letters of the
     alphabet A, B, C, ..., as needed.  The numerals for base 35, the
     largest acceptable base, comprise 0 through 9, and A through Y.

     See also `ibase'.


 -- Option variable: outchar
     Default value: `%o'

     `outchar' is the prefix of the labels of expressions computed by
     Maxima.  Maxima automatically constructs a label for each computed
     expression by concatenating `outchar' and `linenum'.  `outchar'
     may be assigned any string or symbol, not necessarily a single
     character.

          (%i1) outchar: "output";
          (output1)                           output
          (%i2) expand ((a+b)^3);
                                      3        2      2      3
          (output2)                  b  + 3 a b  + 3 a  b + a
          (%i3)

     See also `labels'.


 -- Option variable: packagefile
     Default value: `false'

     Package designers who use `save' or `translate' to create packages
     (files) for others to use may want to set `packagefile: true' to
     prevent information from being added to Maxima's information-lists
     (e.g. `values', `functions') except where necessary when the file
     is loaded in.  In this way, the contents of the package will not
     get in the user's way when he adds his own data.  Note that this
     will not solve the problem of possible name conflicts.  Also note
     that the flag simply affects what is output to the package file.
     Setting the flag to `true' is also useful for creating Maxima init
     files.


 -- Option variable: pfeformat
     Default value: `false'

     When `pfeformat' is `true', a ratio of integers is displayed with
     the solidus (forward slash) character, and an integer denominator
     `n' is displayed as a leading multiplicative term `1/n'.

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)


 -- Function: print (<expr_1>, ..., <expr_n>)
     Evaluates and displays <expr_1>, ..., <expr_n> one after another,
     from left to right, starting at the left edge of the console
     display.

     The value returned by `print' is the value of its last argument.
     `print' does not generate intermediate expression labels.

     See also `display', `disp', `ldisplay', and `ldisp'.  Those
     functions display one expression per line, while `print' attempts
     to display two or more expressions per line.

     To display the contents of a file, see `printfile'.

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)


 -- Function: tcl_output (<list>, <i0>, <skip>)
 -- Function: tcl_output (<list>, <i0>)
 -- Function: tcl_output ([<list_1>, ..., <list_n>], <i>)
     Prints elements of a list enclosed by curly braces `{ }', suitable
     as part of a program in the Tcl/Tk language.

     `tcl_output (<list>, <i0>, <skip>)' prints <list>, beginning with
     element <i0> and printing elements `<i0> + <skip>', `<i0> + 2
     <skip>', etc.

     `tcl_output (<list>, <i0>)' is equivalent to `tcl_output (<list>,
     <i0>, 2)'.

     `tcl_output ([<list_1>, ..., <list_n>], <i>)' prints the <i>'th
     elements of <list_1>, ..., <list_n>.

     Examples:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }


 -- Function: read (<expr_1>, ..., <expr_n>)
     Prints <expr_1>, ..., <expr_n>, then reads one expression from the
     console and returns the evaluated expression.  The expression is
     terminated with a semicolon `;' or dollar sign `$'.

     See also `readonly'.

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)


 -- Function: readonly (<expr_1>, ..., <expr_n>)
     Prints <expr_1>, ..., <expr_n>, then reads one expression from the
     console and returns the expression (without evaluation).  The
     expression is terminated with a `;' (semicolon) or `$' (dollar
     sign).

          (%i1) aa: 7$
          (%i2) foo: readonly ("Enter an expression:");
          Enter an expression:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Enter an expression:");
          Enter an expression:
          2^aa;
          (%o3)                            128

     See also `read'.


 -- Function: reveal (<expr>, <depth>)
     Replaces parts of <expr> at the specified integer <depth> with
     descriptive summaries.

        * Sums and differences are replaced by `sum(<n>)' where <n> is
          the number of operands of the sum.

        * Products are replaced by `product(<n>)' where <n> is the
          number of operands of the product.

        * Exponentials are replaced by `expt'.

        * Quotients are replaced by `quotient'.

        * Unary negation is replaced by `negterm'.

     When <depth> is greater than or equal to the maximum depth of
     <expr>, `reveal (<expr>, <depth>)' returns <expr> unmodified.

     `reveal' evaluates its arguments.  `reveal' returns the summarized
     expression.

     Example:

          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       quotient
          (%i3) reveal (e, 2);
                                       sum(3)
          (%o3)                        ------
                                       sum(3)
          (%i4) reveal (e, 3);
                               expt + negterm + expt
          (%o4)               ------------------------
                              product(2) + expt + expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - product(3) + a
          (%o5)         ------------------------------------
                                   product(2)     product(2)
                        2 expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e


 -- Option variable: rmxchar
     Default value: `]'

     `rmxchar' is the character drawn on the right-hand side of a
     matrix.

     See also `lmxchar'.


 -- Function: save (<filename>, <name_1>, <name_2>, <name_3>, ...)
 -- Function: save (<filename>, values, functions, labels, ...)
 -- Function: save (<filename>, [<m>, <n>])
 -- Function: save (<filename>, <name_1>=<expr_1>, ...)
 -- Function: save (<filename>, all)
 -- Function: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
          ...)
     Stores the current values of <name_1>, <name_2>, <name_3>, ..., in
     <filename>.  The arguments are the names of variables, functions,
     or other objects.  If a name has no value or function associated
     with it, it is ignored.  `save' returns <filename>.

     `save' stores data in the form of Lisp expressions.  The data
     stored by `save' may be recovered by `load (<filename>)'.

     The global flag `file_output_append' governs whether `save'
     appends or truncates the output file.  When `file_output_append'
     is `true', `save' appends to the output file.  Otherwise, `save'
     truncates the output file.  In either case, `save' creates the
     file if it does not yet exist.

     The special form `save (<filename>, values, functions, labels,
     ...)'  stores the items named by `values', `functions', `labels',
     etc.  The names may be any specified by the variable `infolists'.
     `values' comprises all user-defined variables.

     The special form `save (<filename>, [<m>, <n>])' stores the values
     of input and output labels <m> through <n>.  Note that <m> and <n>
     must be literal integers.  Input and output labels may also be
     stored one by one, e.g., `save ("foo.1", %i42, %o42)'.  `save
     (<filename>, labels)' stores all input and output labels.  When
     the stored labels are recovered, they clobber existing labels.

     The special form `save (<filename>, <name_1>=<expr_1>,
     <name_2>=<expr_2>, ...)' stores the values of <expr_1>, <expr_2>,
     ..., with names <name_1>, <name_2>, ....  It is useful to apply
     this form to input and output labels, e.g., `save ("foo.1",
     aa=%o88)'.  The right-hand side of the equality in this form may
     be any expression, which is evaluated.  This form does not
     introduce the new names into the current Maxima environment, but
     only stores them in <filename>.

     These special forms and the general form of `save' may be mixed at
     will.  For example, `save (<filename>, aa, bb, cc=42, functions,
     [11, 17])'.

     The special form `save (<filename>, all)' stores the current state
     of Maxima.  This includes all user-defined variables, functions,
     arrays, etc., as well as some automatically defined items.  The
     saved items include system variables, such as `file_search_maxima'
     or `showtime', if they have been assigned new values by the user;
     see `myoptions'.

     `save' evaluates <filename> and quotes all other arguments.


 -- Option variable: savedef
     Default value: `true'

     When `savedef' is `true', the Maxima version of a user function is
     preserved when the function is translated.  This permits the
     definition to be displayed by `dispfun' and allows the function to
     be edited.

     When `savedef' is `false', the names of translated functions are
     removed from the `functions' list.


 -- Function: show (<expr>)
     Displays `expr' with the indexed objects in it shown having
     covariant indices as subscripts, contravariant indices as
     superscripts.  The derivative indices are displayed as subscripts,
     separated from the covariant indices by a comma.


 -- Function: showratvars (<expr>)
     Returns a list of the canonical rational expression (CRE)
     variables in expression `expr'.

     See also `ratvars'.


 -- Option variable: stardisp
     Default value: `false'

     When `stardisp' is `true', multiplication is displayed with an
     asterisk `*' between operands.


 -- Function: string (<expr>)
     Converts `expr' to Maxima's linear notation just as if it had been
     typed in.

     The return value of `string' is a string, and thus it cannot be
     used in a computation.


 -- Option variable: stringdisp
     Default value: `false'

     When `stringdisp' is `true', strings are displayed enclosed in
     double quote marks.  Otherwise, quote marks are not displayed.

     `stringdisp' is always `true' when displaying a function
     definition.

     Examples:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () :=
                print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


 -- Function: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Function: stringout (<filename>, [<m>, <n>])
 -- Function: stringout (<filename>, input)
 -- Function: stringout (<filename>, functions)
 -- Function: stringout (<filename>, values)
     `stringout' writes expressions to a file in the same form the
     expressions would be typed for input. The file can then be used as
     input for the `batch' or `demo' commands, and it may be edited for
     any purpose. `stringout' can be executed while `writefile' is in
     progress.

     The global flag `file_output_append' governs whether `stringout'
     appends or truncates the output file.  When `file_output_append'
     is `true', `stringout' appends to the output file.  Otherwise,
     `stringout' truncates the output file.  In either case,
     `stringout' creates the file if it does not yet exist.

     The general form of `stringout' writes the values of one or more
     expressions to the output file. Note that if an expression is a
     variable, only the value of the variable is written and not the
     name of the variable. As a useful special case, the expressions
     may be input labels (`%i1', `%i2', `%i3', ...) or output labels
     (`%o1', `%o2', `%o3', ...).

     If `grind' is `true', `stringout' formats the output using the
     `grind' format. Otherwise the `string' format is used. See `grind'
     and `string'.

     The special form `stringout (<filename>, [<m>, <n>])' writes the
     values of input labels m through n, inclusive.

     The special form `stringout (<filename>, input)' writes all input
     labels to the file.

     The special form `stringout (<filename>, functions)' writes all
     user-defined functions (named by the global list `functions') to
     the file.

     The special form `stringout (<filename>, values)' writes all
     user-assigned variables (named by the global list `values') to the
     file. Each variable is printed as an assignment statement, with
     the name of the variable, a colon, and its value. Note that the
     general form of `stringout' does not print variables as assignment
     statements.


 -- Function: tex (<expr>)
 -- Function: tex (<label>)
 -- Function: tex (<expr>, <filename>)
 -- Function: tex (<label>, <filename>)
     Prints a representation of an expression suitable for the TeX
     document preparation system.  The result is a fragment of a
     document, which can be copied into a larger document but not
     processed by itself.

     `tex (<expr>)' prints a TeX representation of <expr> on the
     console.

     `tex (<label>)' prints a TeX representation of the expression
     named by <label> and assigns it an equation label (to be displayed
     to the left of the expression).  The TeX equation label is the
     same as the Maxima label.

     `tex (<expr>, <filename>)' appends a TeX representation of <expr>
     to the file <filename>.

     `tex (<label>, <filename>)' appends a TeX representation of the
     expression named by <label>, with an equation label, to the file
     <filename>.

     `tex' evaluates its first argument after testing it to see if it
     is a label.  Quote-quote `''' forces evaluation of the argument,
     thereby defeating the test and preventing the label.

     See also `texput'.

     Examples:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)


 -- Function: texput (<a>, <s>)
 -- Function: texput (<a>, <s>, <operator_type>)
 -- Function: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- Function: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)
     Assign the TeX output for the atom <a>, which can be a symbol or
     the name of an operator.

     `texput (<a>, <s>)' causes the `tex' function to interpolate the
     string <s> into the TeX output in place of <a>.

     `texput (<a>, <s>, <operator_type>)', where <operator_type> is
     `prefix', `infix', `postfix', `nary', or `nofix', causes the `tex'
     function to interpolate <s> into the TeX output in place of <a>,
     and to place the interpolated text in the appropriate position.

     `texput (<a>, [<s_1>, <s_2>], matchfix)' causes the `tex' function
     to interpolate <s_1> and <s_2> into the TeX output on either side
     of the arguments of <a>.  The arguments (if more than one) are
     separated by commas.

     `texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)' causes the `tex'
     function to interpolate <s_1> and <s_2> into the TeX output on
     either side of the arguments of <a>, with <s_3> separating the
     arguments.

     Examples:

     Assign TeX output for a variable.

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     Assign TeX output for an ordinary function (not an operator).

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     Assign TeX output for a prefix operator.

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     Assign TeX output for an infix operator.

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     Assign TeX output for a postfix operator.

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     Assign TeX output for a nary operator.

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     Assign TeX output for a nofix operator.

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     Assign TeX output for a matchfix operator.

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false


 -- Function: system (<command>)
     Executes <command> as a separate process.  The command is passed
     to the default shell for execution.  `system' is not supported by
     all operating systems, but generally exists in Unix and Unix-like
     environments.

     Supposing `_hist.out' is a list of frequencies which you wish to
     plot as a bar graph using `xgraph'.

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     In order to make the plot be done in the background (returning
     control to Maxima) and remove the temporary file after it is done
     do:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")


 -- Option variable: ttyoff
     Default value: `false'

     When `ttyoff' is `true', output expressions are not displayed.
     Output expressions are still computed and assigned labels. See
     `labels'.

     Text printed by built-in Maxima functions, such as error messages
     and the output of `describe', is not affected by `ttyoff'.


 -- Function: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, ...)
 -- Function: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, ...)
     Evaluates <expr_1>, <expr_2>, <expr_3>, ...  and writes any output
     thus generated to a file <f> or output stream <s>.  The evaluated
     expressions are not written to the output.  Output may be
     generated by `print', `display', `grind', among other functions.

     The global flag `file_output_append' governs whether `with_stdout'
     appends or truncates the output file <f>.  When
     `file_output_append' is `true', `with_stdout' appends to the
     output file.  Otherwise, `with_stdout' truncates the output file.
     In either case, `with_stdout' creates the file if it does not yet
     exist.

     `with_stdout' returns the value of its final argument.

     See also `writefile'.

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do
                print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800


 -- Function: writefile (<filename>)
     Begins writing a transcript of the Maxima session to <filename>.
     All interaction between the user and Maxima is then recorded in
     this file, just as it appears on the console.

     As the transcript is printed in the console output format, it
     cannot be reloaded into Maxima.  To make a file containing
     expressions which can be reloaded, see `save' and `stringout'.
     `save' stores expressions in Lisp form, while `stringout' stores
     expressions in Maxima form.

     The effect of executing `writefile' when <filename> already exists
     depends on the underlying Lisp implementation; the transcript file
     may be clobbered, or the file may be appended.  `appendfile'
     always appends to the transcript file.

     It may be convenient to execute `playback' after `writefile' to
     save the display of previous interactions.  As `playback' displays
     only the input and output variables (`%i1', `%o1', etc.), any
     output generated by a print statement in a function (as opposed to
     a return value) is not displayed by `playback'.

     `closefile' closes the transcript file opened by `writefile' or
     `appendfile'.



File: maxima.info,  Node: Floating Point,  Next: Contexts,  Prev: Input and Output,  Up: Top

10 Floating Point
*****************

* Menu:

* Functions and Variables for Floating Point::


File: maxima.info,  Node: Functions and Variables for Floating Point,  Prev: Floating Point,  Up: Floating Point

10.1 Functions and Variables for Floating Point
===============================================

 -- Function: bffac (<expr>, <n>)
     Bigfloat version of the factorial (shifted gamma) function.  The
     second argument is how many digits to retain and return, it's a
     good idea to request a couple of extra.

     `load ("bffac")' loads this function.


 -- Option variable: algepsilon
     Default value: 10^8

     `algepsilon' is used by `algsys'.


 -- Function: bfloat (<expr>)
     Converts all numbers and functions of numbers in <expr> to
     bigfloat numbers.  The number of significant digits in the
     resulting bigfloats is specified by the global variable `fpprec'.

     When `float2bf' is `false' a warning message is printed when a
     floating point number is converted into a bigfloat number (since
     this may lead to loss of precision).


 -- Function: bfloatp (<expr>)
     Returns `true' if <expr> is a bigfloat number, otherwise `false'.


 -- Function: bfpsi (<n>, <z>, <fpprec>)
 -- Function: bfpsi0 (<z>, <fpprec>)
     `bfpsi' is the polygamma function of real argument <z> and integer
     order <n>.  `bfpsi0' is the digamma function.  `bfpsi0 (<z>,
     <fpprec>)' is equivalent to `bfpsi (0, <z>, <fpprec>)'.

     These functions return bigfloat values.  <fpprec> is the bigfloat
     precision of the return value.

     `load ("bffac")' loads these functions.


 -- Option variable: bftorat
     Default value: `false'

     `bftorat' controls the conversion of bfloats to rational numbers.
     When `bftorat' is `false', `ratepsilon' will be used to control
     the conversion (this results in relatively small rational numbers).
     When `bftorat' is `true', the rational number generated will
     accurately represent the bfloat.


 -- Option variable: bftrunc
     Default value: `true'

     `bftrunc' causes trailing zeroes in non-zero bigfloat numbers not
     to be displayed.  Thus, if `bftrunc' is `false', `bfloat (1)'
     displays as `1.000000000000000B0'. Otherwise, this is displayed as
     `1.0B0'.


 -- Function: cbffac (<z>, <fpprec>)
     Complex bigfloat factorial.

     `load ("bffac")' loads this function.


 -- Function: float (<expr>)
     Converts integers, rational numbers and bigfloats in <expr> to
     floating point numbers.  It is also an `evflag', `float' causes
     non-integral rational numbers and bigfloat numbers to be converted
     to floating point.


 -- Option variable: float2bf
     Default value: `false'

     When `float2bf' is `false', a warning message is printed when a
     floating point number is converted into a bigfloat number (since
     this may lead to loss of precision).


 -- Function: floatnump (<expr>)
     Returns `true' if <expr> is a floating point number, otherwise
     `false'.


 -- Option variable: fpprec
     Default value: 16

     `fpprec' is the number of significant digits for arithmetic on
     bigfloat numbers.  `fpprec' does not affect computations on
     ordinary floating point numbers.

     See also `bfloat' and `fpprintprec'.


 -- Option variable: fpprintprec
     Default value: 0

     `fpprintprec' is the number of digits to print when printing an
     ordinary float or bigfloat number.

     For ordinary floating point numbers, when `fpprintprec' has a
     value between 2 and 16 (inclusive), the number of digits printed
     is equal to `fpprintprec'.  Otherwise, `fpprintprec' is 0, or
     greater than 16, and the number of digits printed is 16.

     For bigfloat numbers, when `fpprintprec' has a value between 2 and
     `fpprec' (inclusive), the number of digits printed is equal to
     `fpprintprec'.  Otherwise, `fpprintprec' is 0, or greater than
     `fpprec', and the number of digits printed is equal to `fpprec'.

     `fpprintprec' cannot be 1.



File: maxima.info,  Node: Contexts,  Next: Polynomials,  Prev: Floating Point,  Up: Top

11 Contexts
***********

* Menu:

* Functions and Variables for Contexts::


File: maxima.info,  Node: Functions and Variables for Contexts,  Prev: Contexts,  Up: Contexts

11.1 Functions and Variables for Contexts
=========================================

 -- Function: activate (<context_1>, ..., <context_n>)
     Activates the contexts <context_1>, ..., <context_n>.  The facts
     in these contexts are then available to make deductions and
     retrieve information.  The facts in these contexts are not listed
     by `facts ()'.

     The variable `activecontexts' is the list of contexts which are
     active by way of the `activate' function.


 -- System variable: activecontexts
     Default value: `[]'

     `activecontexts' is a list of the contexts which are active by way
     of the `activate' function, as opposed to being active because
     they are subcontexts of the current context.


 -- Function: assume (<pred_1>, ..., <pred_n>)
     Adds predicates <pred_1>, ..., <pred_n> to the current context.
     If a predicate is inconsistent or redundant with the predicates in
     the current context, it is not added to the context.  The context
     accumulates predicates from each call to `assume'.

     `assume' returns a list whose elements are the predicates added to
     the context or the atoms `redundant' or `inconsistent' where
     applicable.

     The predicates <pred_1>, ..., <pred_n> can only be expressions
     with the relational operators `< <= equal notequal >=' and `>'.
     Predicates cannot be literal equality `=' or literal inequality
     `#' expressions, nor can they be predicate functions such as
     `integerp'.

     Compound predicates of the form `<pred_1> and ... and <pred_n>'
     are recognized, but not `<pred_1> or ... or <pred_n>'.  `not
     <pred_k>' is recognized if <pred_k> is a relational predicate.
     Expressions of the form `not (<pred_1> and <pred_2>)' and `not
     (<pred_1> or <pred_2>)' are not recognized.

     Maxima's deduction mechanism is not very strong; there are many
     obvious consequences which cannot be determined by `is'.  This is
     a known weakness.

     `assume' evaluates its arguments.

     See also `is', `facts', `forget', `context', and `declare'.

     Examples:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Option variable: assumescalar
     Default value: `true'

     `assumescalar' helps govern whether expressions `expr' for which
     `nonscalarp (expr)' is `false' are assumed to behave like scalars
     for certain transformations.

     Let `expr' represent any expression other than a list or a matrix,
     and let `[1, 2, 3]' represent any list or matrix.  Then `expr .
     [1, 2, 3]' yields `[expr, 2 expr, 3 expr]' if `assumescalar' is
     `true', or `scalarp (expr)' is `true', or `constantp (expr)' is
     `true'.

     If `assumescalar' is `true', such expressions will behave like
     scalars only for commutative operators, but not for noncommutative
     multiplication `.'.

     When `assumescalar' is `false', such expressions will behave like
     non-scalars.

     When `assumescalar' is `all', such expressions will behave like
     scalars for all the operators listed above.


 -- Option variable: assume_pos
     Default value: `false'

     When `assume_pos' is `true' and the sign of a parameter <x> cannot
     be determined from the current context or other considerations,
     `sign' and `asksign (<x>)' return `true'.  This may forestall some
     automatically-generated `asksign' queries, such as may arise from
     `integrate' or other computations.

     By default, a parameter is <x> such that `symbolp (<x>)' or
     `subvarp (<x>)'.  The class of expressions considered parameters
     can be modified to some extent via the variable `assume_pos_pred'.

     `sign' and `asksign' attempt to deduce the sign of expressions
     from the sign of operands within the expression.  For example, if
     `a' and `b' are both positive, then `a + b' is also positive.

     However, there is no way to bypass all `asksign' queries.  In
     particular, when the `asksign' argument is a difference `<x> -
     <y>' or a logarithm `log(<x>)', `asksign' always requests an input
     from the user, even when `assume_pos' is `true' and
     `assume_pos_pred' is a function which returns `true' for all
     arguments.


 -- Option variable: assume_pos_pred
     Default value: `false'

     When `assume_pos_pred' is assigned the name of a function or a
     lambda expression of one argument <x>, that function is called to
     determine whether <x> is considered a parameter for the purpose of
     `assume_pos'.  `assume_pos_pred' is ignored when `assume_pos' is
     `false'.

     The `assume_pos_pred' function is called by `sign' and `asksign'
     with an argument <x> which is either an atom, a subscripted
     variable, or a function call expression.  If the `assume_pos_pred'
     function returns `true', <x> is considered a parameter for the
     purpose of `assume_pos'.

     By default, a parameter is <x> such that `symbolp (<x>)' or
     `subvarp (<x>)'.

     See also `assume' and `assume_pos'.

     Examples:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Option variable: context
     Default value: `initial'

     `context' names the collection of facts maintained by `assume' and
     `forget'.  `assume' adds facts to the collection named by
     `context', while `forget' removes facts.

     Binding `context' to a name <foo> changes the current context to
     <foo>.  If the specified context <foo> does not yet exist, it is
     created automatically by a call to `newcontext'.  The specified
     context is activated automatically.

     See `contexts' for a general description of the context mechanism.


 -- Option variable: contexts
     Default value: `[initial, global]'

     `contexts' is a list of the contexts which currently exist,
     including the currently active context.

     The context mechanism makes it possible for a user to bind together
     and name a collection of facts, called a context.  Once this is
     done, the user can have Maxima assume or forget large numbers of
     facts merely by activating or deactivating their context.

     Any symbolic atom can be a context, and the facts contained in that
     context will be retained in storage until destroyed one by one by
     calling `forget' or destroyed as a whole by calling `kill' to
     destroy the context to which they belong.

     Contexts exist in a hierarchy, with the root always being the
     context `global', which contains information about Maxima that some
     functions need.  When in a given context, all the facts in that
     context are "active" (meaning that they are used in deductions and
     retrievals) as are all the facts in any context which is a
     subcontext of the active context.

     When a fresh Maxima is started up, the user is in a context called
     `initial', which has `global' as a subcontext.

     See also `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume', and `forget'.


 -- Function: deactivate (<context_1>, ..., <context_n>)
     Deactivates the specified contexts <context_1>, ..., <context_n>.


 -- Function: facts (<item>)
 -- Function: facts ()
     If <item> is the name of a context, `facts (<item>)' returns a list
     of the facts in the specified context.

     If <item> is not the name of a context, `facts (<item>)' returns a
     list of the facts known about <item> in the current context.
     Facts that are active, but in a different context, are not listed.

     `facts ()' (i.e., without an argument) lists the current context.


 -- Declaration: features
     Maxima recognizes certain mathematical properties of functions and
     variables.  These are called "features".

     `declare (<x>, <foo>)' gives the property <foo> to the function or
     variable <x>.

     `declare (<foo>, feature)' declares a new feature <foo>.  For
     example, `declare ([red, green, blue], feature)' declares three
     new features, `red', `green', and `blue'.

     The predicate `featurep (<x>, <foo>)' returns `true' if <x> has
     the <foo> property, and `false' otherwise.

     The infolist `features' is a list of known features.  These are
     `integer', `noninteger', `even', `odd', `rational', `irrational',
     `real', `imaginary', `complex', `analytic', `increasing',
     `decreasing', `oddfun', `evenfun', `posfun', `commutative',
     `lassociative', `rassociative', `symmetric', and `antisymmetric',
     plus any user-defined features.

     `features' is a list of mathematical features.  There is also a
     list of non-mathematical, system-dependent features. See `status'.


 -- Function: forget (<pred_1>, ..., <pred_n>)
 -- Function: forget (<L>)
     Removes predicates established by `assume'.  The predicates may be
     expressions equivalent to (but not necessarily identical to) those
     previously assumed.

     `forget (<L>)', where <L> is a list of predicates, forgets each
     item on the list.


 -- Function: killcontext (<context_1>, ..., <context_n>)
     Kills the contexts <context_1>, ..., <context_n>.

     If one of the contexts is the current context, the new current
     context will become the first available subcontext of the current
     context which has not been killed.  If the first available unkilled
     context is `global' then `initial' is used instead.  If the
     `initial' context is killed, a new, empty `initial' context is
     created.

     `killcontext' refuses to kill a context which is currently active,
     either because it is a subcontext of the current context, or by
     use of the function `activate'.

     `killcontext' evaluates its arguments.  `killcontext' returns
     `done'.


 -- Function: newcontext (<name>)
     Creates a new, empty context, called <name>, which has `global' as
     its only subcontext.  The newly-created context becomes the
     currently active context.

     `newcontext' evaluates its argument.  `newcontext' returns <name>.


 -- Function: supcontext (<name>, <context>)
 -- Function: supcontext (<name>)
     Creates a new context, called <name>, which has <context> as a
     subcontext.  <context> must exist.

     If <context> is not specified, the current context is assumed.



File: maxima.info,  Node: Polynomials,  Next: Constants,  Prev: Contexts,  Up: Top

12 Polynomials
**************

* Menu:

* Introduction to Polynomials::
* Functions and Variables for Polynomials::


File: maxima.info,  Node: Introduction to Polynomials,  Next: Functions and Variables for Polynomials,  Prev: Polynomials,  Up: Polynomials

12.1 Introduction to Polynomials
================================

Polynomials are stored in Maxima either in General Form or as
Cannonical Rational Expressions (CRE) form.  The latter is a standard
form, and is used internally by operations such as factor, ratsimp, and
so on.

   Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC is set to `true').  In this CRE form an ordering
of variables (from most to least main) is assumed for each expression.
Polynomials are represented recursively by a list consisting of the
main variable followed by a series of pairs of expressions, one for
each term of the polynomial.  The first member of each pair is the
exponent of the main variable in that term and the second member is the
coefficient of that term which could be a number or a polynomial in
another variable again represented in this form.  Thus the principal
part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and that of 2*X*Y+X-3
is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the main variable, and is
(X 1 (Y 1 2 0 1) 0 -3) assuming X is the main variable. "Main"-ness is
usually determined by reverse alphabetical order.  The "variables" of a
CRE expression needn't be atomic.  In fact any subexpression whose main
operator is not + - * / or ^ with integer power will be considered a
"variable" of the expression (in CRE form) in which it occurs.  For
example the CRE variables of the expression X+SIN(X+1)+2*SQRT(X)+1 are
X, SQRT(X), and SIN(X+1).  If the user does not specify an ordering of
variables by using the RATVARS function Maxima will choose an
alphabetic one.  In general, CRE's represent rational expressions, that
is, ratios of polynomials, where the numerator and denominator have no
common factors, and the denominator is positive.  The internal form is
essentially a pair of polynomials (the numerator and denominator)
preceded by the variable ordering list.  If an expression to be
displayed is in CRE form or if it contains any subexpressions in CRE
form, the symbol /R/ will follow the line label.  See the RAT function
for converting an expression to CRE form.  An extended CRE form is used
for the representation of Taylor series.  The notion of a rational
expression is extended so that the exponents of the variables can be
positive or negative rational numbers rather than just positive
integers and the coefficients can themselves be rational expressions as
described above rather than just polynomials.  These are represented
internally by a recursive polynomial form which is similar to and is a
generalization of CRE form, but carries additional information such as
the degree of truncation.  As with CRE form, the symbol /T/ follows the
line label of such expressions.


File: maxima.info,  Node: Functions and Variables for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynomials

12.2 Functions and Variables for Polynomials
============================================

 -- Option variable: algebraic
     Default value: `false'

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.


 -- Option variable: berlefact
     Default value: `true'

     When `berlefact' is `false' then the Kronecker factoring algorithm
     will be used otherwise the Berlekamp algorithm, which is the
     default, will be used.


 -- Function: bezout (<p1>, <p2>, <x>)
     an alternative to the `resultant' command.  It returns a matrix.
     `determinant' of this matrix is the desired resultant.


 -- Function: bothcoef (<expr>, <x>)
     Returns a list whose first member is the coefficient of <x> in
     <expr> (as found by `ratcoef' if <expr> is in CRE form otherwise
     by `coeff') and whose second member is the remaining part of
     <expr>.  That is, `[A, B]' where `<expr> = A*<x> + B'.

     Example:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Function: coeff (<expr>, <x>, <n>)
     Returns the coefficient of `<x>^<n>' in <expr>.  <n> may be
     omitted if it is 1.  <x> may be an atom, or complete subexpression
     of <expr> e.g., `sin(x)', `a[i+1]', `x + y', etc. (In the last
     case the expression `(x + y)' should occur in <expr>).  Sometimes
     it may be necessary to expand or factor <expr> in order to make
     `<x>^<n>' explicit.  This is not done automatically by `coeff'.

     Examples:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1


 -- Function: combine (<expr>)
     Simplifies the sum <expr> by combining terms with the same
     denominator into a single term.


 -- Function: content (<p_1>, <x_1>, ..., <x_n>)
     Returns a list whose first element is the greatest common divisor
     of the coefficients of the terms of the polynomial <p_1> in the
     variable <x_n> (this is the content) and whose second element is
     the polynomial <p_1> divided by the content.

     Examples:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Function: denom (<expr>)
     Returns the denominator of the rational expression <expr>.


 -- Function: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     computes the quotient and remainder of the polynomial <p_1>
     divided by the polynomial <p_2>, in a main polynomial variable,
     <x_n>.  The other variables are as in the `ratvars' function.  The
     result is a list whose first element is the quotient and whose
     second element is the remainder.

     Examples:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note that `y' is the main variable in the second example.


 -- Function: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Eliminates variables from equations (or expressions assumed equal
     to zero) by taking successive resultants. This returns a list of
     `<n> - <k>' expressions with the <k> variables <x_1>, ..., <x_k>
     eliminated.  First <x_1> is eliminated yielding `<n> - 1'
     expressions, then `x_2' is eliminated, etc.  If `<k> = <n>' then a
     single expression in a list is returned free of the variables
     <x_1>, ..., <x_k>.  In this case `solve' is called to solve the
     last resultant for the last variable.

     Example:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Function: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Returns a list whose first element is the g.c.d of the polynomials
     <p_1>, <p_2>, <p_3>, ...  and whose remaining elements are the
     polynomials divided by the g.c.d.  This always uses the `ezgcd'
     algorithm.


 -- Option variable: facexpand
     Default value: `true'

     `facexpand' controls whether the irreducible factors returned by
     `factor' are in expanded (the default) or recursive (normal CRE)
     form.


 -- Function: factcomb (<expr>)
     Tries to combine the coefficients of factorials in <expr> with the
     factorials themselves by converting, for example, `(n + 1)*n!'
     into `(n + 1)!'.

     `sumsplitfact' if set to `false' will cause `minfactorial' to be
     applied after a `factcomb'.


 -- Function: factor (<expr>)
     Factors the expression <expr>, containing any number of variables
     or functions, into factors irreducible over the integers.  `factor
     (<expr>, p)' factors <expr> over the field of integers with an
     element adjoined whose minimum polynomial is p.

     `factor' uses `ifactors' function for factoring integers.

     `factorflag' if `false' suppresses the factoring of integer factors
     of rational expressions.

     `dontfactor' may be set to a list of variables with respect to
     which factoring is not to occur.  (It is initially empty).
     Factoring also will not take place with respect to any variables
     which are less important (using the variable ordering assumed for
     CRE form) than those on the `dontfactor' list.

     `savefactors' if `true' causes the factors of an expression which
     is a product of factors to be saved by certain functions in order
     to speed up later factorizations of expressions containing some of
     the same factors.

     `berlefact' if `false' then the Kronecker factoring algorithm will
     be used otherwise the Berlekamp algorithm, which is the default,
     will be used.

     `intfaclim' if `true' maxima will give up factorization of
     integers if no factor is found after trial divisions and Pollard's
     rho method.  If set to `false' (this is the case when the user
     calls `factor' explicitly), complete factorization of the integer
     will be attempted.  The user's setting of `intfaclim' is used for
     internal calls to `factor'. Thus, `intfaclim' may be reset to
     prevent Maxima from taking an inordinately long time factoring
     large integers.

     Examples:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Option variable: factorflag
     Default value: `false'

     When `factorflag' is `false', suppresses the factoring of integer
     factors of rational expressions.


 -- Function: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranges the sum <expr> into a sum of terms of the form `f
     (<x_1>, <x_2>, ...)*g' where `g' is a product of expressions not
     containing any <x_i> and `f' is factored.


 -- Function: factorsum (<expr>)
     Tries to group terms in factors of <expr> which are sums into
     groups of terms such that their sum is factorable.  `factorsum' can
     recover the result of `expand ((x + y)^2 + (z + w)^2)' but it
     can't recover `expand ((x + 1)^2 + (x + y)^2)' because the terms
     have variables in common.

     Example:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Function: fasttimes (<p_1>, <p_2>)
     Returns the product of the polynomials <p_1> and <p_2> by using a
     special algorithm for multiplication of polynomials.  `p_1' and
     `p_2' should be multivariate, dense, and nearly the same size.
     Classical multiplication is of order `n_1 n_2' where `n_1' is the
     degree of `p_1' and `n_2' is the degree of `p_2'.  `fasttimes' is
     of order `max (n_1, n_2)^1.585'.


 -- Function: fullratsimp (<expr>)
     `fullratsimp' repeatedly applies `ratsimp' followed by
     non-rational simplification to an expression until no further
     change occurs, and returns the result.

     When non-rational expressions are involved, one call to `ratsimp'
     followed as is usual by non-rational ("general") simplification
     may not be sufficient to return a simplified result.  Sometimes,
     more than one such call may be necessary.  `fullratsimp' makes
     this process convenient.

     `fullratsimp (<expr>, <x_1>, ..., <x_n>)' takes one or more
     arguments similar to `ratsimp' and `rat'.

     Example:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Function: fullratsubst (<a>, <b>, <c>)
     is the same as `ratsubst' except that it calls itself recursively
     on its result until that result stops changing.  This function is
     useful when the replacement expression and the replaced expression
     have one or more variables in common.

     `fullratsubst' will also accept its arguments in the format of
     `lratsubst'.  That is, the first argument may be a single
     substitution equation or a list of such equations, while the
     second argument is the expression being processed.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' is equivalent to `ratsubst' except that it
          recurses until its result stops changing.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' also accepts a list of equations or a single
          equation as first argument.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' may cause an indefinite recursion.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Function: gcd (<p_1>, <p_2>, <x_1>, ...)
     Returns the greatest common divisor of <p_1> and <p_2>.  The flag
     `gcd' determines which algorithm is employed.  Setting `gcd' to
     `ez', `subres', `red', or `spmod' selects the `ezgcd',
     subresultant `prs', reduced, or modular algorithm, respectively.
     If `gcd' `false' then `gcd (<p_1>, <p_2>, <x>)' always returns 1
     for all <x>.  Many functions (e.g.  `ratsimp', `factor', etc.)
     cause gcd's to be taken implicitly.  For homogeneous polynomials
     it is recommended that `gcd' equal to `subres' be used.  To take
     the gcd when an algebraic is present, e.g., `gcd (<x>^2 -
     2*sqrt(2)*<x> + 2, <x> - sqrt(2))', `algebraic' must be `true' and
     `gcd' must not be `ez'.  `subres' is a new algorithm, and people
     who have been using the `red' setting should probably change it to
     `subres'.

     The `gcd' flag, default: `subres', if `false' will also prevent
     the greatest common divisor from being taken when expressions are
     converted to canonical rational expression (CRE) form.  This will
     sometimes speed the calculation if gcds are not required.


 -- Function: gcdex (<f>, <g>)
 -- Function: gcdex (<f>, <g>, <x>)
     Returns a list `[<a>, <b>, <u>]' where <u> is the greatest common
     divisor (gcd) of <f> and <g>, and <u> is equal to `<a> <f> + <b>
     <g>'.  The arguments <f> and <g> should be univariate polynomials,
     or else polynomials in <x> a supplied main variable since we need
     to be in a principal ideal domain for this to work.  The gcd means
     the gcd regarding <f> and <g> as univariate polynomials with
     coefficients being rational functions in the other variables.

     `gcdex' implements the Euclidean algorithm, where we have a
     sequence of `L[i]: [a[i], b[i], r[i]]' which are all perpendicular
     to `[f, g, -1]' and the next one is built as if `q =
     quotient(r[i]/r[i+1])' then `L[i+2]: L[i] - q L[i+1]', and it
     terminates at `L[i+1]' when the remainder `r[i+2]' is zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note that the gcd in the following is `1' since we work in
     `k(y)[x]', not the  `y+1' we would expect in `k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1


 -- Function: gcfactor (<n>)
     Factors the Gaussian integer <n> over the Gaussian integers, i.e.,
     numbers of the form `<a> + <b> `%i'' where <a> and <b> are
     rational integers (i.e.,  ordinary integers).  Factors are
     normalized by making <a> and <b> non-negative.


 -- Function: gfactor (<expr>)
     Factors the polynomial <expr> over the Gaussian integers (that is,
     the integers with the imaginary unit `%i' adjoined).  This is like
     `factor (<expr>, <a>^2+1)' where <a> is `%i'.

     Example:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Function: gfactorsum (<expr>)
     is similar to `factorsum' but applies `gfactor' instead of
     `factor'.


 -- Function: hipow (<expr>, <x>)
     Returns the highest explicit exponent of <x> in <expr>.  <x> may
     be a variable or a general expression.  If <x> does not appear in
     <expr>, `hipow' returns `0'.

     `hipow' does not consider expressions equivalent to `expr'.  In
     particular, `hipow' does not expand `expr', so `hipow (<expr>,
     <x>)' and `hipow (expand (<expr>, <x>))' may yield different
     results.

     Examples:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Option variable: intfaclim
     Default value: true

     If `true', maxima will give up factorization of integers if no
     factor is found after trial divisions and Pollard's rho method and
     factorization will not be complete.

     When `intfaclim' is `false' (this is the case when the user calls
     `factor' explicitly), complete factorization will be attempted.
     `intfaclim' is set to `false' when factors are computed in
     `divisors', `divsum' and `totient'.

     Internal calls to `factor' respect the user-specified value of
     `intfaclim'.  Setting `intfaclim' to `true' may reduce the time
     spent factoring large integers.


 -- Option variable: keepfloat
     Default value: `false'

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.


 -- Function: lratsubst (<L>, <expr>)
     is analogous to `subst (<L>, <expr>)' except that it uses
     `ratsubst' instead of `subst'.

     The first argument of `lratsubst' is an equation or a list of
     equations identical in format to that accepted by `subst'.  The
     substitutions are made in the order given by the list of equations,
     that is, from left to right.

     `load ("lrats")' loads `fullratsubst' and `lratsubst'.

     Examples:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Option variable: modulus
     Default value: `false'

     When `modulus' is a positive number <p>, operations on rational
     numbers (as returned by `rat' and related functions) are carried
     out modulo <p>, using the so-called "balanced" modulus system in
     which `<n> modulo <p>' is defined as an integer <k> in
     `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' when <p> is odd, or
     `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' when <p> is even, such that
     `<a> <p> + <k>' equals <n> for some integer <a>.

     If <expr> is already in canonical rational expression (CRE) form
     when `modulus' is reset, then you may need to re-rat <expr>, e.g.,
     `expr: rat (ratdisrep (expr))', in order to get correct results.

     Typically `modulus' is set to a prime number.  If `modulus' is set
     to a positive non-prime integer, this setting is accepted, but a
     warning message is displayed.  Maxima will allow zero or a
     negative integer to be assigned to `modulus', although it is not
     clear if that has any useful consequences.


 -- Function: num (<expr>)
     Returns the numerator of <expr> if it is a ratio.  If <expr> is
     not a ratio, <expr> is returned.

     `num' evaluates its argument.


 -- Function: polydecomp (<p>, <x>)
     Decomposes the polynomial <p> in the variable <x> into the
     functional composition of polynomials in <x>.  `polydecomp'
     returns a list `[<p_1>, ..., <p_n>]' such that

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
            ...))

     is equal to <p>.  The degree of <p_i> is greater than 1 for <i>
     less than <n>.

     Such a decomposition is not unique.

     Examples:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     The following function composes `L = [e_1, ..., e_n]' as functions
     in `x'; it is the inverse of polydecomp:

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-express above example using `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note that though `compose (polydecomp (<p>, <x>), <x>)' always
     returns <p> (unexpanded), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' does not necessarily return `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Function: quotient (<p_1>, <p_2>)
 -- Function: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Returns the polynomial <p_1> divided by the polynomial <p_2>.  The
     arguments <x_1>, ..., <x_n> are interpreted as in `ratvars'.

     `quotient' returns the first element of the two-element list
     returned by `divide'.


 -- Function: rat (<expr>)
 -- Function: rat (<expr>, <x_1>, ..., <x_n>)
     Converts <expr> to canonical rational expression (CRE) form by
     expanding and combining all terms over a common denominator and
     cancelling out the greatest common divisor of the numerator and
     denominator, as well as converting floating point numbers to
     rational numbers within a tolerance of `ratepsilon'.  The
     variables are ordered according to the <x_1>, ..., <x_n>, if
     specified, as in `ratvars'.

     `rat' does not generally simplify functions other than addition
     `+', subtraction `-', multiplication `*', division `/', and
     exponentiation to an integer power, whereas `ratsimp' does handle
     those cases.  Note that atoms (numbers and variables) in CRE form
     are not the same as they are in the general form.  For example,
     `rat(x)- x' yields `rat(0)' which has a different internal
     representation than 0.

     When `ratfac' is `true', `rat' yields a partially factored form
     for CRE.  During rational operations the expression is maintained
     as fully factored as possible without an actual call to the factor
     package.  This should always save space and may save some time in
     some computations.  The numerator and denominator are still made
     relatively prime (e.g.  `rat ((x^2 - 1)^4/(x + 1)^2)' yields `(x -
     1)^4 (x + 1)^2)', but the factors within each part may not be
     relatively prime.

     `ratprint' if `false' suppresses the printout of the message
     informing the user of the conversion of floating point numbers to
     rational numbers.

     `keepfloat' if `true' prevents floating point numbers from being
     converted to rational numbers.

     See also `ratexpand' and  `ratsimp'.

     Examples:
          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
                (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Option variable: ratalgdenom
     Default value: `true'

     When `ratalgdenom' is `true', allows rationalization of
     denominators with respect to radicals to take effect.
     `ratalgdenom' has an effect only when canonical rational
     expressions (CRE) are used in algebraic mode.


 -- Function: ratcoef (<expr>, <x>, <n>)
 -- Function: ratcoef (<expr>, <x>)
     Returns the coefficient of the expression `<x>^<n>' in the
     expression <expr>.  If omitted, <n> is assumed to be 1.

     The return value is free (except possibly in a non-rational sense)
     of the variables in <x>.  If no coefficient of this type exists, 0
     is returned.

     `ratcoef' expands and rationally simplifies its first argument and
     thus it may produce answers different from those of `coeff' which
     is purely syntactic.  Thus `ratcoef ((x + 1)/y + x, x)' returns
     `(y + 1)/y' whereas `coeff' returns 1.

     `ratcoef (<expr>, <x>, 0)', viewing <expr> as a sum, returns a sum
     of those terms which do not contain <x>.  Therefore if <x> occurs
     to any negative powers, `ratcoef' should not be used.

     Since <expr> is rationally simplified before it is examined,
     coefficients may not appear quite the way they were envisioned.

     Example:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Function: ratdenom (<expr>)
     Returns the denominator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `denom' is similar, but returns an ordinary expression instead of
     a CRE.  Also, `denom' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratdenom' are not considered ratios by `denom'.


 -- Option variable: ratdenomdivide
     Default value: `true'

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     Examples:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Function: ratdiff (<expr>, <x>)
     Differentiates the rational expression <expr> with respect to <x>.
     <expr> must be a ratio of polynomials or a polynomial in <x>.  The
     argument <x> may be a variable or a subexpression of <expr>.

     The result is equivalent to `diff', although perhaps in a
     different form.  `ratdiff' may be faster than `diff', for rational
     expressions.

     `ratdiff' returns a canonical rational expression (CRE) if `expr'
     is a CRE.  Otherwise, `ratdiff' returns a general expression.

     `ratdiff' considers only the dependence of <expr> on <x>, and
     ignores any dependencies established by `depends'.

     Example:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Function: ratdisrep (<expr>)
     Returns its argument as a general expression.  If <expr> is a
     general expression, it is returned unchanged.

     Typically `ratdisrep' is called to convert a canonical rational
     expression (CRE) into a general expression.  This is sometimes
     convenient if one wishes to stop the "contagion", or use rational
     functions in non-rational contexts.

     See also `totaldisrep'.


 -- Option variable: ratepsilon
     Default value: 2.0e-8

     `ratepsilon' is the tolerance used in the conversion of floating
     point numbers to rational numbers.


 -- Function: ratexpand (<expr>)
 -- Option variable: ratexpand
     Expands <expr> by multiplying out products of sums and
     exponentiated sums, combining fractions over a common denominator,
     cancelling the greatest common divisor of the numerator and
     denominator, then splitting the numerator (if a sum) into its
     respective terms divided by the denominator.

     The return value of `ratexpand' is a general expression, even if
     <expr> is a canonical rational expression (CRE).

     The switch `ratexpand' if `true' will cause CRE expressions to be
     fully expanded when they are converted back to general form or
     displayed, while if it is `false' then they will be put into a
     recursive form.  See also `ratsimp'.

     When `ratdenomdivide' is `true', `ratexpand' expands a ratio in
     which the numerator is a sum into a sum of ratios, all having a
     common denominator.  Otherwise, `ratexpand' collapses a sum of
     ratios into a single ratio, the numerator of which is the sum of
     the numerators of each ratio.

     When `keepfloat' is `true', prevents floating point numbers from
     being rationalized when expressions which contain them are
     converted to canonical rational expression (CRE) form.

     Examples:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Option variable: ratfac
     Default value: `false'

     When `ratfac' is `true', canonical rational expressions (CRE) are
     manipulated in a partially factored form.

     During rational operations the expression is maintained as fully
     factored as possible without calling `factor'.  This should always
     save space and may save time in some computations.  The numerator
     and denominator are made relatively prime, for example `rat ((x^2
     - 1)^4/(x + 1)^2)' yields `(x - 1)^4 (x + 1)^2)', but the factors
     within each part may not be relatively prime.

     In the `ctensr' (Component Tensor Manipulation) package, Ricci,
     Einstein, Riemann, and Weyl tensors and the scalar curvature are
     factored automatically when `ratfac' is `true'.  `ratfac' should
     only be set for cases where the tensorial components are known to
     consist of few terms.

     The `ratfac' and `ratweight' schemes are incompatible and may not
     both be used at the same time.


 -- Function: ratnumer (<expr>)
     Returns the numerator of <expr>, after coercing <expr> to a
     canonical rational expression (CRE).  The return value is a CRE.

     <expr> is coerced to a CRE by `rat' if it is not already a CRE.
     This conversion may change the form of <expr> by putting all terms
     over a common denominator.

     `num' is similar, but returns an ordinary expression instead of a
     CRE.  Also, `num' does not attempt to place all terms over a
     common denominator, and thus some expressions which are considered
     ratios by `ratnumer' are not considered ratios by `num'.


 -- Function: ratnump (<expr>)
     Returns `true' if <expr> is a literal integer or ratio of literal
     integers, otherwise `false'.


 -- Function: ratp (<expr>)
     Returns `true' if <expr> is a canonical rational expression (CRE)
     or extended CRE, otherwise `false'.

     CRE are created by `rat' and related functions.  Extended CRE are
     created by `taylor' and related functions.


 -- Option variable: ratprint
     Default value: `true'

     When `ratprint' is `true', a message informing the user of the
     conversion of floating point numbers to rational numbers is
     displayed.


 -- Function: ratsimp (<expr>)
 -- Function: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifies the expression <expr> and all of its subexpressions,
     including the arguments to non-rational functions.  The result is
     returned as the quotient of two polynomials in a recursive form,
     that is, the coefficients of the main variable are polynomials in
     the other variables.  Variables may include non-rational functions
     (e.g., `sin (x^2 + 1)') and the arguments to any such functions
     are also rationally simplified.

     `ratsimp (<expr>, <x_1>, ..., <x_n>)' enables rational
     simplification with the specification of variable ordering as in
     `ratvars'.

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.

     See also `ratexpand'.  Note that `ratsimp' is affected by some of
     the flags which affect `ratexpand'.

     Examples:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Option variable: ratsimpexpons
     Default value: `false'

     When `ratsimpexpons' is `true', `ratsimp' is applied to the
     exponents of expressions during simplification.


 -- Function: ratsubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c> and returns the resulting
     expression.  <b> may be a sum, product, power, etc.

     `ratsubst' knows something of the meaning of expressions whereas
     `subst' does a purely syntactic substitution.  Thus `subst (a, x +
     y, x + y + z)' returns `x + y + z' whereas `ratsubst' returns `z +
     a'.

     When `radsubstflag' is `true', `ratsubst' makes substitutions for
     radicals in expressions which don't explicitly contain them.

     Examples:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Function: ratvars (<x_1>, ..., <x_n>)
 -- Function: ratvars ()
 -- System variable: ratvars
     Declares main variables <x_1>, ..., <x_n> for rational expressions.
     <x_n>, if present in a rational expression, is considered the main
     variable.  Otherwise, <x_[n-1]> is considered the main variable if
     present, and so on through the preceding variables to <x_1>, which
     is considered the main variable only if none of the succeeding
     variables are present.

     If a variable in a rational expression is not present in the
     `ratvars' list, it is given a lower priority than <x_1>.

     The arguments to `ratvars' can be either variables or non-rational
     functions such as `sin(x)'.

     The variable `ratvars' is a list of the arguments of the function
     `ratvars' when it was called most recently.  Each call to the
     function `ratvars' resets the list.  `ratvars ()' clears the list.


 -- Function: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Function: ratweight ()
     Assigns a weight <w_i> to the variable <x_i>.  This causes a term
     to be replaced by 0 if its weight exceeds the value of the
     variable `ratwtlvl' (default yields no truncation).  The weight of
     a term is the sum of the products of the weight of a variable in
     the term times its power.  For example, the weight of `3 x_1^2
     x_2' is `2 w_1 + w_2'.  Truncation according to `ratwtlvl' is
     carried out only when multiplying or exponentiating canonical
     rational expressions (CRE).

     `ratweight ()' returns the cumulative list of weight assignments.

     Note: The `ratfac' and `ratweight' schemes are incompatible and
     may not both be used at the same time.

     Examples:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- System variable: ratweights
     Default value: `[]'

     `ratweights' is the list of weights assigned by `ratweight'.  The
     list is cumulative: each call to `ratweight' places additional
     items in the list.

     `kill (ratweights)' and `save (ratweights)' both work as expected.


 -- Option variable: ratwtlvl
     Default value: `false'

     `ratwtlvl' is used in combination with the `ratweight' function to
     control the truncation of canonical rational expressions (CRE).
     For the default value of `false', no truncation occurs.


 -- Function: remainder (<p_1>, <p_2>)
 -- Function: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Returns the remainder of the polynomial <p_1> divided by the
     polynomial <p_2>.  The arguments <x_1>, ..., <x_n> are interpreted
     as in `ratvars'.

     `remainder' returns the second element of the two-element list
     returned by `divide'.


 -- Function: resultant (<p_1>, <p_2>, <x>)
 -- Variable: resultant
     Computes the resultant of the two polynomials <p_1> and <p_2>,
     eliminating the variable <x>.  The resultant is a determinant of
     the coefficients of <x> in <p_1> and <p_2>, which equals zero if
     and only if <p_1> and <p_2> have a non-constant factor in common.

     If <p_1> or <p_2> can be factored, it may be desirable to call
     `factor' before calling `resultant'.

     The variable `resultant' controls which algorithm will be used to
     compute the resultant.  `subres' for subresultant prs, `mod' for
     modular resultant algorithm, and `red' for reduced prs.  On most
     problems `subres' should be best.  On some large degree univariate
     or bivariate problems `mod' may be better.

     The function `bezout' takes the same arguments as `resultant' and
     returns a matrix.  The determinant of the return value is the
     desired resultant.


 -- Option variable: savefactors
     Default value: `false'

     When `savefactors' is `true', causes the factors of an expression
     which is a product of factors to be saved by certain functions in
     order to speed up later factorizations of expressions containing
     some of the same factors.


 -- Function: sqfr (<expr>)
     is similar to `factor' except that the polynomial factors are
     "square-free."  That is, they have factors only of degree one.
     This algorithm, which is also used by the first stage of `factor',
     utilizes the fact that a polynomial has in common with its n'th
     derivative all its factors of degree greater than n.  Thus by
     taking greatest common divisors with the polynomial of the
     derivatives with respect to each variable in the polynomial, all
     factors of degree greater than 1 can be found.

     Example:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)


 -- Function: tellrat (<p_1>, ..., <p_n>)
 -- Function: tellrat ()
     Adds to the ring of algebraic integers known to Maxima the
     elements which are the solutions of the polynomials <p_1>, ...,
     <p_n>.  Each argument <p_i> is a polynomial with integer
     coefficients.

     `tellrat (<x>)' effectively means substitute 0 for <x> in rational
     functions.

     `tellrat ()' returns a list of the current substitutions.

     `algebraic' must be set to `true' in order for the simplification
     of algebraic integers to take effect.

     Maxima initially knows about the imaginary unit `%i' and all roots
     of integers.

     There is a command `untellrat' which takes kernels and removes
     `tellrat' properties.

     When `tellrat''ing a multivariate polynomial, e.g., `tellrat (x^2
     - y^2)', there would be an ambiguity as to whether to substitute
     `<y>^2' for `<x>^2' or vice versa.  Maxima picks a particular
     ordering, but if the user wants to specify which, e.g.  `tellrat
     (y^2 = x^2)' provides a syntax which says replace `<y>^2' by
     `<x>^2'.

     Examples:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Function: totaldisrep (<expr>)
     Converts every subexpression of <expr> from canonical rational
     expressions (CRE) to general form and returns the result.  If
     <expr> is itself in CRE form then `totaldisrep' is identical to
     `ratdisrep'.

     `totaldisrep' may be useful for ratdisrepping expressions such as
     equations, lists, matrices, etc., which have some subexpressions
     in CRE form.


 -- Function: untellrat (<x_1>, ..., <x_n>)
     Removes `tellrat' properties from <x_1>, ..., <x_n>.



File: maxima.info,  Node: Constants,  Next: Logarithms,  Prev: Polynomials,  Up: Top

13 Constants
************

* Menu:

* Functions and Variables for Constants::


File: maxima.info,  Node: Functions and Variables for Constants,  Prev: Constants,  Up: Constants

13.1 Functions and Variables for Constants
==========================================

 -- Constant: %e
     `%e' represents the base of the natural logarithm, also known as
     Euler's number.  The numeric value of `%e' is the double-precision
     floating-point value 2.718281828459045d0.


 -- Constant: %i
     `%i' represents the imaginary unit, sqrt(- 1).


 -- Constant: false
     `false' represents the Boolean constant of the same name.  Maxima
     implements `false' by the value `NIL' in Lisp.


 -- Constant: inf
     `inf' represents real positive infinity.


 -- Constant: infinity
     `infinity' represents complex infinity.


 -- Constant: minf
     `minf' represents real minus (i.e., negative) infinity.


 -- Constant: %phi
     `%phi' represents the so-called golden mean, (1 + sqrt(5))/2.  The
     numeric value of `%phi' is the double-precision floating-point
     value 1.618033988749895d0.

     `fibtophi' expresses Fibonacci numbers `fib(n)' in terms of `%phi'.

     By default, Maxima does not know the algebraic properties of
     `%phi'.  After evaluating `tellrat(%phi^2 - %phi - 1)' and
     `algebraic: true', `ratsimp' can simplify some expressions
     containing `%phi'.

     Examples:

     `fibtophi' expresses Fibonacci numbers `fib(n)' in terms of `%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     By default, Maxima does not know the algebraic properties of
     `%phi'.  After evaluating `tellrat (%phi^2 - %phi - 1)' and
     `algebraic: true', `ratsimp' can simplify some expressions
     containing `%phi'.

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0


 -- Constant: %pi
     `%pi' represents the ratio of the perimeter of a circle to its
     diameter.  The numeric value of `%pi' is the double-precision
     floating-point value 3.141592653589793d0.


 -- Constant: true
     `true' represents the Boolean constant of the same name.  Maxima
     implements `true' by the value `T' in Lisp.



File: maxima.info,  Node: Logarithms,  Next: Trigonometric,  Prev: Constants,  Up: Top

14 Logarithms
*************

* Menu:

* Functions and Variables for Logarithms::


File: maxima.info,  Node: Functions and Variables for Logarithms,  Prev: Logarithms,  Up: Logarithms

14.1 Functions and Variables for Logarithms
===========================================

 -- Option variable: %e_to_numlog
     Default value: `false'

     When `true', `r' some rational number, and `x' some expression,
     `%e^(r*log(x))' will be simplified into `x^r' .  It should be
     noted that the `radcan' command also does this transformation, and
     more complicated transformations of this ilk as well.  The
     `logcontract' command "contracts" expressions containing `log'.


 -- Function: li [<s>] (<z>)
     Represents the polylogarithm function of order <s> and argument
     <z>, defined by the infinite series

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' is `- log (1 - z)'.  `li [2]' and `li [3]' are the
     dilogarithm and trilogarithm functions, respectively.

     When the order is 1, the polylogarithm simplifies to `- log (1 -
     z)', which in turn simplifies to a numerical value if <z> is a
     real or complex floating point number or the `numer' evaluation
     flag is present.

     When the order is 2 or 3, the polylogarithm simplifies to a
     numerical value if <z> is a real floating point number or the
     `numer' evaluation flag is present.

     Examples:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Function: log (<x>)
     Represents the natural (base e) logarithm of <x>.

     Maxima does not have a built-in function for the base 10 logarithm
     or other bases.  `log10(x) := log(x) / log(10)' is a useful
     definition.

     Simplification and evaluation of logarithms is governed by several
     global flags:

     `logexpand' - causes `log(a^b)' to become `b*log(a)'.  If it is
     set to `all', `log(a*b)' will also simplify to `log(a)+log(b)'.
     If it is set to `super', then `log(a/b)' will also simplify to
     `log(a)-log(b)' for rational numbers `a/b', `a#1'.  (`log(1/b)',
     for `b' integer, always simplifies.)  If it is set to `false', all
     of these simplifications will be turned off.

     `logsimp' - if `false' then no simplification of `%e' to a power
     containing `log''s is done.

     `lognumer' - if `true' then negative floating point arguments to
     `log' will always be converted to their absolute value before the
     `log' is taken.  If `numer' is also `true', then negative integer
     arguments to `log' will also be converted to their absolute value.

     `lognegint' - if `true' implements the rule `log(-n)' ->
     `log(n)+%i*%pi' for `n' a positive integer.

     `%e_to_numlog' - when `true', `r' some rational number, and `x'
     some expression, `%e^(r*log(x))' will be simplified into `x^r' .
     It should be noted that the `radcan' command also does this
     transformation, and more complicated transformations of this ilk
     as well.  The `logcontract' command "contracts" expressions
     containing `log'.


 -- Option variable: logabs
     Default value: `false'

     When doing indefinite integration where logs are generated, e.g.
     `integrate(1/x,x)', the answer is given in terms of
     `log(abs(...))' if `logabs' is `true', but in terms of `log(...)'
     if `logabs' is `false'.  For definite integration, the
     `logabs:true' setting is used, because here "evaluation" of the
     indefinite integral at the endpoints is often needed.


 -- Option variable: logarc
 -- Function: logarc (<expr>)
     When the global variable `logarc' is `true', inverse circular and
     hyperbolic functions are replaced by equivalent logarithmic
     functions.  The default value of `logarc' is `false'.

     The function `logarc(<expr>)' carries out that replacement for an
     expression <expr> without setting the global variable `logarc'.


 -- Option variable: logconcoeffp
     Default value: `false'

     Controls which coefficients are contracted when using
     `logcontract'.  It may be set to the name of a predicate function
     of one argument.  E.g. if you like to generate SQRTs, you can do
     `logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or
     ratnump(m)$' .  Then `logcontract(1/2*log(x));' will give
     `log(sqrt(x))'.


 -- Function: logcontract (<expr>)
     Recursively scans the expression <expr>, transforming
     subexpressions of the form `a1*log(b1) + a2*log(b2) + c' into
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     If you do `declare(n,integer);' then `logcontract(2*a*n*log(x));'
     gives `a*log(x^(2*n))'.  The coefficients that "contract" in this
     manner are those such as the 2 and the `n' here which satisfy
     `featurep(coeff,integer)'.  The user can control which
     coefficients are contracted by setting the option `logconcoeffp'
     to the name of a predicate function of one argument.  E.g. if you
     like to generate SQRTs, you can do `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Then
     `logcontract(1/2*log(x));' will give `log(sqrt(x))'.


 -- Option variable: logexpand
     Default value: `true'

     Causes `log(a^b)' to become `b*log(a)'.  If it is set to `all',
     `log(a*b)' will also simplify to `log(a)+log(b)'.  If it is set to
     `super', then `log(a/b)' will also simplify to `log(a)-log(b)' for
     rational numbers `a/b', `a#1'.  (`log(1/b)', for integer `b',
     always simplifies.)  If it is set to `false', all of these
     simplifications will be turned off.


 -- Option variable: lognegint
     Default value: `false'

     If `true' implements the rule `log(-n)' -> `log(n)+%i*%pi' for `n'
     a positive integer.


 -- Option variable: lognumer
     Default value: `false'

     If `true' then negative floating point arguments to `log' will
     always be converted to their absolute value before the `log' is
     taken.  If `numer' is also `true', then negative integer arguments
     to `log' will also be converted to their absolute value.


 -- Option variable: logsimp
     Default value: `true'

     If `false' then no simplification of `%e' to a power containing
     `log''s is done.


 -- Function: plog (<x>)
     Represents the principal branch of the complex-valued natural
     logarithm with `-%pi' < `carg(<x>)' <= `+%pi' .



File: maxima.info,  Node: Trigonometric,  Next: Special Functions,  Prev: Logarithms,  Up: Top

15 Trigonometric
****************

* Menu:

* Introduction to Trigonometric::
* Functions and Variables for Trigonometric::


File: maxima.info,  Node: Introduction to Trigonometric,  Next: Functions and Variables for Trigonometric,  Prev: Trigonometric,  Up: Trigonometric

15.1 Introduction to Trigonometric
==================================

Maxima has many trigonometric functions defined.  Not all trigonometric
identities are programmed, but it is possible for the user to add many
of them using the pattern matching capabilities of the system.  The
trigonometric functions defined in Maxima are: `acos', `acosh', `acot',
`acoth', `acsc', `acsch', `asec', `asech', `asin', `asinh', `atan',
`atanh', `cos', `cosh', `cot', `coth', `csc', `csch', `sec', `sech',
`sin', `sinh', `tan', and `tanh'.  There are a number of commands
especially for handling trigonometric functions, see `trigexpand',
`trigreduce', and the switch `trigsign'.  Two share packages extend the
simplification rules built into Maxima, `ntrig' and `atrig1'.  Do
`describe(<command>)' for details.


File: maxima.info,  Node: Functions and Variables for Trigonometric,  Prev: Introduction to Trigonometric,  Up: Trigonometric

15.2 Functions and Variables for Trigonometric
==============================================

 -- Option variable: %piargs
     Default value: `true'

     When `%piargs' is `true', trigonometric functions are simplified
     to algebraic constants when the argument is an integer multiple of
     %pi, %pi/2, %pi/3, %pi/4, or %pi/6

     Maxima knows some identities which can be applied when %pi, etc.,
     are multiplied by an integer variable (that is, a symbol declared
     to be integer).

     Examples:

          (%i1) %piargs : false;
          (%o1)                         false
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true;
          (%o4)                         true
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3), cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     Some identities are applied when %pi and %pi/2 are multiplied by
     an integer variable.

          (%i1) declare (n, integer, m, even);
          (%o1)                         done
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m), cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]


 -- Option variable: %iargs
     Default value: `true'

     When `%iargs' is `true', trigonometric functions are simplified to
     hyperbolic functions when the argument is apparently a multiple of
     the imaginary unit %i.

     Even when the argument is demonstrably real, the simplification is
     applied; Maxima considers only whether the argument is a literal
     multiple of %i.

     Examples:

          (%i1) %iargs : false;
          (%o1)                         false
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true;
          (%o3)                         true
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     Even when the argument is demonstrably real, the simplification is
     applied.

          (%i1) declare (x, imaginary);
          (%o1)                         done
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)


 -- Function: acos (<x>)
     - Arc Cosine.


 -- Function: acosh (<x>)
     - Hyperbolic Arc Cosine.


 -- Function: acot (<x>)
     - Arc Cotangent.


 -- Function: acoth (<x>)
     - Hyperbolic Arc Cotangent.


 -- Function: acsc (<x>)
     - Arc Cosecant.


 -- Function: acsch (<x>)
     - Hyperbolic Arc Cosecant.


 -- Function: asec (<x>)
     - Arc Secant.


 -- Function: asech (<x>)
     - Hyperbolic Arc Secant.


 -- Function: asin (<x>)
     - Arc Sine.


 -- Function: asinh (<x>)
     - Hyperbolic Arc Sine.


 -- Function: atan (<x>)
     - Arc Tangent.


 -- Function: atan2 (<y>, <x>)
     - yields the value of `atan(<y>/<x>)' in the interval `-%pi' to
     `%pi'.


 -- Function: atanh (<x>)
     - Hyperbolic Arc Tangent.


 -- Package: atrig1
     The `atrig1' package contains several additional simplification
     rules for inverse trigonometric functions.  Together with rules
     already known to Maxima, the following angles are fully
     implemented: `0', `%pi/6', `%pi/4', `%pi/3', and `%pi/2'.
     Corresponding angles in the other three quadrants are also
     available.  Do `load(atrig1);' to use them.


 -- Function: cos (<x>)
     - Cosine.


 -- Function: cosh (<x>)
     - Hyperbolic Cosine.


 -- Function: cot (<x>)
     - Cotangent.


 -- Function: coth (<x>)
     - Hyperbolic Cotangent.


 -- Function: csc (<x>)
     - Cosecant.


 -- Function: csch (<x>)
     - Hyperbolic Cosecant.


 -- Option variable: halfangles
     Default value: `false'

     When `halfangles' is `true', half-angles are simplified away.


 -- Package: ntrig
     The `ntrig' package contains a set of simplification rules that are
     used to simplify trigonometric function whose arguments are of the
     form `<f>(<n> %pi/10)' where <f> is any of the functions `sin',
     `cos', `tan', `csc', `sec' and `cot'.


 -- Function: sec (<x>)
     - Secant.


 -- Function: sech (<x>)
     - Hyperbolic Secant.


 -- Function: sin (<x>)
     - Sine.


 -- Function: sinh (<x>)
     - Hyperbolic Sine.


 -- Function: tan (<x>)
     - Tangent.


 -- Function: tanh (<x>)
     - Hyperbolic Tangent.


 -- Function: trigexpand (<expr>)
     Expands trigonometric and hyperbolic functions of sums of angles
     and of multiple angles occurring in <expr>.  For best results,
     <expr> should be expanded.  To enhance user control of
     simplification, this function expands only one level at a time,
     expanding sums of angles or multiple angles.  To obtain full
     expansion into sines and cosines immediately, set the switch
     `trigexpand: true'.

     `trigexpand' is governed by the following global flags:

    `trigexpand'
          If `true' causes expansion of all expressions containing
          sin's and cos's occurring subsequently.

    `halfangles'
          If `true' causes half-angles to be simplified away.

    `trigexpandplus'
          Controls the "sum" rule for `trigexpand', expansion of sums
          (e.g. `sin(x + y)') will take place only if `trigexpandplus'
          is `true'.

    `trigexpandtimes'
          Controls the "product" rule for `trigexpand', expansion of
          products (e.g. `sin(2 x)') will take place only if
          `trigexpandtimes' is `true'.

     Examples:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Option variable: trigexpandplus
     Default value: `true'

     `trigexpandplus' controls the "sum" rule for `trigexpand'.  Thus,
     when the `trigexpand' command is used or the `trigexpand' switch
     set to `true', expansion of sums (e.g. `sin(x+y))' will take place
     only if `trigexpandplus' is `true'.


 -- Option variable: trigexpandtimes
     Default value: `true'

     `trigexpandtimes' controls the "product" rule for `trigexpand'.
     Thus, when the `trigexpand' command is used or the `trigexpand'
     switch set to `true', expansion of products (e.g. `sin(2*x)') will
     take place only if `trigexpandtimes' is `true'.


 -- Option variable: triginverses
     Default value: `all'

     `triginverses' controls the simplification of the composition of
     trigonometric and hyperbolic functions with their inverse
     functions.

     If `all', both e.g. `atan(tan(<x>))' and `tan(atan(<x>))' simplify
     to <x>.

     If `true', the `<arcfun>(<fun>(<x>))' simplification is turned off.

     If `false', both the `<arcfun>(<fun>(<x>))' and
     `<fun>(<arcfun>(<x>))' simplifications are turned off.


 -- Function: trigreduce (<expr>, <x>)
 -- Function: trigreduce (<expr>)
     Combines products and powers of trigonometric and hyperbolic sin's
     and cos's of <x> into those of multiples of <x>.  It also tries to
     eliminate these functions when they occur in denominators.  If <x>
     is omitted then all variables in <expr> are used.

     See also `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     The trigonometric simplification routines will use declared
     information in some simple cases.  Declarations about variables are
     used as follows, e.g.

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Option variable: trigsign
     Default value: `true'

     When `trigsign' is `true', it permits simplification of negative
     arguments to trigonometric functions. E.g., `sin(-x)' will become
     `-sin(x)' only if `trigsign' is `true'.


 -- Function: trigsimp (<expr>)
     Employs the identities sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 to simplify expressions containing `tan', `sec',
     etc., to `sin', `cos', `sinh', `cosh'.

     `trigreduce', `ratsimp', and `radcan' may be able to further
     simplify the result.

     `demo ("trgsmp.dem")' displays some examples of `trigsimp'.


 -- Function: trigrat (<expr>)
     Gives a canonical simplifyed quasilinear form of a trigonometrical
     expression; <expr> is a rational fraction of several `sin', `cos'
     or `tan', the arguments of them are linear forms in some variables
     (or kernels) and `%pi/<n>' (<n> integer) with integer
     coefficients. The result is a simplified fraction with numerator
     and denominator linear in `sin' and `cos'.  Thus `trigrat'
     linearize always when it is possible.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     The following example is taken from Davenport, Siret, and
     Tournier, Calcul Formel, Masson (or in English, Addison-Wesley),
     section 1.5.5, Morley theorem.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4



File: maxima.info,  Node: Special Functions,  Next: Elliptic Functions,  Prev: Trigonometric,  Up: Top

16 Special Functions
********************

* Menu:

* Introduction to Special Functions::
* Functions and Variables for Special Functions::


File: maxima.info,  Node: Introduction to Special Functions,  Next: Functions and Variables for Special Functions,  Prev: Special Functions,  Up: Special Functions

16.1 Introduction to Special Functions
======================================

Special function notation follows:

     bessel_j (index, expr)         Bessel function, 1st kind
     bessel_y (index, expr)         Bessel function, 2nd kind
     bessel_i (index, expr)         Modified Bessel function, 1st kind
     bessel_k (index, expr)         Modified Bessel function, 2nd kind
     %he[n] (z)                     Hermite polynomial (Nota bene: `he',
                                    not `h'. See A&S 22.5.18)
     %p[u,v] (z)                    Legendre function
     %q[u,v] (z)                    Legendre function, 2nd kind
     hstruve[n] (z)                 Struve H function
     lstruve[n] (z)                 Struve L function
     %f[p,q] ([], [], expr)         Generalized Hypergeometric function
     gamma()                        Gamma function
     gammagreek(a,z)                Incomplete gamma function
     gammaincomplete(a,z)           Tail of incomplete gamma function
     slommel
     %m[u,k] (z)                    Whittaker function, 1st kind
     %w[u,k] (z)                    Whittaker function, 2nd kind
     erfc (z)                       Complement of the erf function
     ei (z)                         Exponential integral (?)
     kelliptic (z)                  Complete elliptic integral of the first
                                    kind (K)
     %d [n] (z)                     Parabolic cylinder function


File: maxima.info,  Node: Functions and Variables for Special Functions,  Prev: Introduction to Special Functions,  Up: Special Functions

16.2 Functions and Variables for Special Functions
==================================================

 -- Function: airy_ai (<x>)
     The Airy function Ai, as defined in Abramowitz and Stegun,
     Handbook of Mathematical Functions, Section 10.4.

     The Airy equation `diff (y(x), x, 2) - x y(x) = 0' has two
     linearly independent solutions, `y = Ai(x)' and `y = Bi(x)'.  The
     derivative `diff (airy_ai(x), x)' is `airy_dai(x)'.

     If the argument `x' is a real or complex floating point number,
     the numerical value of `airy_ai' is returned when possible.

     See also `airy_bi', `airy_dai', `airy_dbi'.

 -- Function: airy_dai (<x>)
     The derivative of the Airy function Ai `airy_ai(x)'.

     See `airy_ai'.

 -- Function: airy_bi (<x>)
     The Airy function Bi, as defined in Abramowitz and Stegun,
     Handbook of Mathematical Functions, Section 10.4, is the second
     solution of the Airy equation `diff (y(x), x, 2) - x y(x) = 0'.

     If the argument `x' is a real or complex floating point number,
     the numerical value of `airy_bi' is returned when possible.  In
     other cases the unevaluated expression is returned.

     The derivative `diff (airy_bi(x), x)' is `airy_dbi(x)'.

     See `airy_ai', `airy_dbi'.

 -- Function: airy_dbi (<x>)
     The derivative of the Airy Bi function `airy_bi(x)'.

     See `airy_ai' and `airy_bi'.

 -- Function: asympa
     `asympa' is a package for asymptotic analysis. The package contains
     simplification functions for asymptotic analysis, including the
     "big O" and "little o" functions that are widely used in
     complexity analysis and numerical analysis.

     `load ("asympa")' loads this package.


 -- Function: bessel (<z>, <a>)
     The Bessel function of the first kind.

     This function is deprecated.  Write `bessel_j (<z>, <a>)' instead.


 -- Function: bessel_j (<v>, <z>)
     The Bessel function of the first kind of order v and argument z.

     `bessel_j' computes the array `besselarray' such that `besselarray
     [i] = bessel_j [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_j' is defined as
                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     although the infinite series is not used for computations.


 -- Function: bessel_y (<v>, <z>)
     The Bessel function of the second kind of order v and argument z.

     `bessel_y' computes the array `besselarray' such that `besselarray
     [i] = bessel_y [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_y' is defined as
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     when v is not an integer.  When v is an integer n, the limit as v
     approaches n is taken.


 -- Function: bessel_i (<v>, <z>)
     The modified Bessel function of the first kind of order v and
     argument z.

     `bessel_i' computes the array `besselarray' such that `besselarray
     [i] = bessel_i [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_i' is defined as
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     although the infinite series is not used for computations.


 -- Function: bessel_k (<v>, <z>)
     The modified Bessel function of the second kind of order v and
     argument z.

     `bessel_k' computes the array `besselarray' such that `besselarray
     [i] = bessel_k [i + v - int(v)] (z)' for `i' from zero to `int(v)'.

     `bessel_k' is defined as
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     when v is not an integer.  If v is an integer n, then the limit as
     v approaches n is taken.


 -- Option variable: besselexpand
     Default value: `false'

     Controls expansion of the Bessel functions when the order is half
     of an odd integer.  In this case, the Bessel functions can be
     expanded in terms of other elementary functions.  When
     `besselexpand' is `true', the Bessel function is expanded.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Function: scaled_bessel_i (<v>, <z>)
     The scaled modified Bessel function of the first kind of order v
     and argument z.  That is, scaled_bessel_i(v,z) =
     exp(-abs(z))*bessel_i(v, z).  This function is particularly useful
     for calculating bessel_i for large z, which is large.  However,
     maxima does not otherwise know much about this function.  For
     symbolic work, it is probably preferable to work with the
     expression `exp(-abs(z))*bessel_i(v, z)'.


 -- Function: scaled_bessel_i0 (<z>)
     Identical to `scaled_bessel_i(0,z)'.


 -- Function: scaled_bessel_i1 (<z>)
     Identical to `scaled_bessel_i(1,z)'.


 -- Function: beta (<x>, <y>)
     The beta function, defined as `gamma(x) gamma(y)/gamma(x + y)'.


 -- Function: gamma (<x>)
     The gamma function.

     See also `makegamma'.

     The variable `gammalim' controls simplification of the gamma
     function.

     The Euler-Mascheroni constant is `%gamma'.


 -- Option variable: gammalim
     Default value: 1000000

     `gammalim' controls simplification of the gamma function for
     integral and rational number arguments.  If the absolute value of
     the argument is not greater than `gammalim', then simplification
     will occur.  Note that the `factlim' switch controls
     simplification of the result of `gamma' of an integer argument as
     well.


 -- Function: intopois (<a>)
     Converts <a> into a Poisson encoding.


 -- Function: makefact (<expr>)
     Transforms instances of binomial, gamma, and beta functions in
     <expr> into factorials.

     See also `makegamma'.


 -- Function: makegamma (<expr>)
     Transforms instances of binomial, factorial, and beta functions in
     <expr> into gamma functions.

     See also `makefact'.


 -- Function: numfactor (<expr>)
     Returns the numerical factor multiplying the expression <expr>,
     which should be a single term.

     `content' returns the greatest common divisor (gcd) of all terms
     in a sum.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8


 -- Function: outofpois (<a>)
     Converts <a> from Poisson encoding to general representation.  If
     <a> is not in Poisson form, `outofpois' carries out the conversion,
     i.e., the return value is `outofpois (intopois (<a>))'.  This
     function is thus a canonical simplifier for sums of powers of sine
     and cosine terms of a particular type.


 -- Function: poisdiff (<a>, <b>)
     Differentiates <a> with respect to <b>. <b> must occur only in the
     trig arguments or only in the coefficients.


 -- Function: poisexpt (<a>, <b>)
     Functionally identical to `intopois (<a>^<b>)'.  <b> must be a
     positive integer.


 -- Function: poisint (<a>, <b>)
     Integrates in a similarly restricted sense (to `poisdiff').
     Non-periodic terms in <b> are dropped if <b> is in the trig
     arguments.


 -- Option variable: poislim
     Default value: 5

     `poislim' determines the domain of the coefficients in the
     arguments of the trig functions.  The initial value of 5
     corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but
     it can be set to [-2^(n-1)+1, 2^(n-1)].


 -- Function: poismap (<series>, <sinfn>, <cosfn>)
     will map the functions <sinfn> on the sine terms and <cosfn> on
     the cosine terms of the Poisson series given.  <sinfn> and <cosfn>
     are functions of two arguments which are a coefficient and a
     trigonometric part of a term in series respectively.


 -- Function: poisplus (<a>, <b>)
     Is functionally identical to `intopois (a + b)'.


 -- Function: poissimp (<a>)
     Converts <a> into a Poisson series for <a> in general
     representation.


 -- Special symbol: poisson
     The symbol `/P/' follows the line label of Poisson series
     expressions.


 -- Function: poissubst (<a>, <b>, <c>)
     Substitutes <a> for <b> in <c>.  <c> is a Poisson series.

     (1) Where <B> is a variable <u>, <v>, <w>, <x>, <y>, or <z>, then
     <a> must be an expression linear in those variables (e.g., `6*u +
     4*v').

     (2) Where <b> is other than those variables, then <a> must also be
     free of those variables, and furthermore, free of sines or cosines.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' is a special type of
     substitution which operates on <a> and <b> as in type (1) above,
     but where <d> is a Poisson series, expands `cos(<d>)' and
     `sin(<d>)' to order <n> so as to provide the result of
     substituting `<a> + <d>' for <b> in <c>.  The idea is that <d> is
     an expansion in terms of a small parameter.  For example,
     `poissubst (u, v, cos(v), %e, 3)' yields `cos(u)*(1 - %e^2/2) -
     sin(u)*(%e - %e^3/6)'.


 -- Function: poistimes (<a>, <b>)
     Is functionally identical to `intopois (<a>*<b>)'.


 -- Function: poistrim ()
     is a reserved function name which (if the user has defined it)
     gets applied during Poisson multiplication.  It is a predicate
     function of 6 arguments which are the coefficients of the <u>,
     <v>, ..., <z> in a term.  Terms for which `poistrim' is `true'
     (for the coefficients of that term) are eliminated during
     multiplication.


 -- Function: printpois (<a>)
     Prints a Poisson series in a readable format.  In common with
     `outofpois', it will convert <a> into a Poisson encoding first, if
     necessary.


 -- Function: psi [<n>](<x>)
     The derivative of `log (gamma (<x>))' of order `<n>+1'.  Thus,
     `psi[0](<x>)' is the first derivative, `psi[1](<x>)' is the second
     derivative, etc.

     Maxima does not know how, in general, to compute a numerical value
     of `psi', but it can compute some exact values for rational args.
     Several variables control what range of rational args `psi' will
     return an exact value, if possible.  See `maxpsiposint',
     `maxpsinegint', `maxpsifracnum', and `maxpsifracnum'.  That is,
     <x> must lie between `maxpsinegint' and `maxpsiposint'.  If the
     absolute value of the fractional part of <x> is rational and has a
     numerator less than `maxpsifracnum' and has a denominator less
     than `maxpsifracdenom', `psi' will return an exact value.

     The function `bfpsi' in the `bffac' package can compute numerical
     values.


 -- Option variable: maxpsiposint
     Default value: 20

     `maxpsiposint' is the largest positive value for which `psi[n](x)'
     will try to compute an exact value.


 -- Option variable: maxpsinegint
     Default value: -10

     `maxpsinegint' is the most negative value for which `psi[n](x)'
     will try to compute an exact value.  That is if <x> is less than
     `maxnegint', `psi[n](<x>)' will not return simplified answer, even
     if it could.


 -- Option variable: maxpsifracnum
     Default value: 6

     Let <x> be a rational number less than one of the form `p/q'.  If
     `p' is greater than `maxpsifracnum', then `psi[<n>](<x>)' will not
     try to return a simplified value.


 -- Option variable: maxpsifracdenom
     Default value: 6

     Let <x> be a rational number less than one of the form `p/q'.  If
     `q' is greater than `maxpsifracdenom', then `psi[<n>](<x>)' will
     not try to return a simplified value.


 -- Function: specint (exp(- s*<t>) * <expr>, <t>)
     Compute the Laplace transform of <expr> with respect to the
     variable <t>.  The integrand <expr> may contain special functions.

     If `specint' cannot compute the integral, the return value may
     contain various Lisp symbols, including
     `other-defint-to-follow-negtest', `other-lt-exponential-to-follow',
     `product-of-y-with-nofract-indices', etc.; this is a bug.

     `demo(hypgeo)' displays several examples of Laplace transforms
     computed by `specint'.

     Examples:

          (%i1) assume (p > 0, a > 0);
          (%o1)                    [p > 0, a > 0]
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p



File: maxima.info,  Node: Elliptic Functions,  Next: Limits,  Prev: Special Functions,  Up: Top

17 Elliptic Functions
*********************

* Menu:

* Introduction to Elliptic Functions and Integrals::
* Functions and Variables for Elliptic Functions::
* Functions and Variables for Elliptic Integrals::


File: maxima.info,  Node: Introduction to Elliptic Functions and Integrals,  Next: Functions and Variables for Elliptic Functions,  Up: Top

17.1 Introduction to Elliptic Functions and Integrals
=====================================================

Maxima includes support for Jacobian elliptic functions and for
complete and incomplete elliptic integrals.  This includes symbolic
manipulation of these functions and numerical evaluation as well.
Definitions of these functions and many of their properties can by
found in Abramowitz and Stegun, Chapter 16-17.  As much as possible, we
use the definitions and relationships given there.

   In particular, all elliptic functions and integrals use the parameter
m instead of the modulus k or the modular angle \alpha.  This is one
area where we differ from Abramowitz and Stegun who use the modular
angle for the elliptic functions.  The following relationships are true:
m = k^2 and k = \sin(\alpha)

   The elliptic functions and integrals are primarily intended to
support symbolic computation.  Therefore, most of derivatives of the
functions and integrals are known.  However, if floating-point values
are given, a floating-point result is returned.

   Support for most of the other properties of elliptic functions and
integrals other than derivatives has not yet been written.

   Some examples of elliptic functions:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Some examples of elliptic integrals:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Support for elliptic functions and integrals was written by Raymond
Toy.  It is placed under the terms of the General Public License (GPL)
that governs the distribution of Maxima.


File: maxima.info,  Node: Functions and Variables for Elliptic Functions,  Next: Functions and Variables for Elliptic Integrals,  Prev: Introduction to Elliptic Functions and Integrals,  Up: Top

17.2 Functions and Variables for Elliptic Functions
===================================================

 -- Function: jacobi_sn (<u>, <m>)
     The Jacobian elliptic function sn(u,m).

 -- Function: jacobi_cn (<u>, <m>)
     The Jacobian elliptic function cn(u,m).

 -- Function: jacobi_dn (<u>, <m>)
     The Jacobian elliptic function dn(u,m).

 -- Function: jacobi_ns (<u>, <m>)
     The Jacobian elliptic function ns(u,m) = 1/sn(u,m).

 -- Function: jacobi_sc (<u>, <m>)
     The Jacobian elliptic function sc(u,m) = sn(u,m)/cn(u,m).

 -- Function: jacobi_sd (<u>, <m>)
     The Jacobian elliptic function sd(u,m) = sn(u,m)/dn(u,m).

 -- Function: jacobi_nc (<u>, <m>)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 -- Function: jacobi_cs (<u>, <m>)
     The Jacobian elliptic function cs(u,m) = cn(u,m)/sn(u,m).

 -- Function: jacobi_cd (<u>, <m>)
     The Jacobian elliptic function cd(u,m) = cn(u,m)/dn(u,m).

 -- Function: jacobi_nd (<u>, <m>)
     The Jacobian elliptic function nc(u,m) = 1/cn(u,m).

 -- Function: jacobi_ds (<u>, <m>)
     The Jacobian elliptic function ds(u,m) = dn(u,m)/sn(u,m).

 -- Function: jacobi_dc (<u>, <m>)
     The Jacobian elliptic function dc(u,m) = dn(u,m)/cn(u,m).

 -- Function: inverse_jacobi_sn (<u>, <m>)
     The inverse of the Jacobian elliptic function sn(u,m).

 -- Function: inverse_jacobi_cn (<u>, <m>)
     The inverse of the Jacobian elliptic function cn(u,m).

 -- Function: inverse_jacobi_dn (<u>, <m>)
     The inverse of the Jacobian elliptic function dn(u,m).

 -- Function: inverse_jacobi_ns (<u>, <m>)
     The inverse of the Jacobian elliptic function ns(u,m).

 -- Function: inverse_jacobi_sc (<u>, <m>)
     The inverse of the Jacobian elliptic function sc(u,m).

 -- Function: inverse_jacobi_sd (<u>, <m>)
     The inverse of the Jacobian elliptic function sd(u,m).

 -- Function: inverse_jacobi_nc (<u>, <m>)
     The inverse of the Jacobian elliptic function nc(u,m).

 -- Function: inverse_jacobi_cs (<u>, <m>)
     The inverse of the Jacobian elliptic function cs(u,m).

 -- Function: inverse_jacobi_cd (<u>, <m>)
     The inverse of the Jacobian elliptic function cd(u,m).

 -- Function: inverse_jacobi_nd (<u>, <m>)
     The inverse of the Jacobian elliptic function nc(u,m).

 -- Function: inverse_jacobi_ds (<u>, <m>)
     The inverse of the Jacobian elliptic function ds(u,m).

 -- Function: inverse_jacobi_dc (<u>, <m>)
     The inverse of the Jacobian elliptic function dc(u,m).


File: maxima.info,  Node: Functions and Variables for Elliptic Integrals,  Prev: Functions and Variables for Elliptic Functions,  Up: Top

17.3 Functions and Variables for Elliptic Integrals
===================================================

 -- Function: elliptic_f (<phi>, <m>)
     The incomplete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *Note elliptic_e:: and *Note elliptic_kc::.


 -- Function: elliptic_e (<phi>, <m>)
     The incomplete elliptic integral of the second kind, defined as

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     See also *Note elliptic_e:: and *Note elliptic_ec::.


 -- Function: elliptic_eu (<u>, <m>)
     The incomplete elliptic integral of the second kind, defined as

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     where tau = sn(u,m)

     This is related to elliptic_e by elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) See also *Note elliptic_e::.

 -- Function: elliptic_pi (<n>, <phi>, <m>)
     The incomplete elliptic integral of the third kind, defined as

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Only the derivative with respect to phi is known by Maxima.

 -- Function: elliptic_kc (<m>)
     The complete elliptic integral of the first kind, defined as

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use `makegamma' to evaluate them.

 -- Function: elliptic_ec (<m>)
     The complete elliptic integral of the second kind, defined as

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     For certain values of m, the value of the integral is known in
     terms of Gamma functions.  Use `makegamma' to evaluate them.


File: maxima.info,  Node: Limits,  Next: Differentiation,  Prev: Elliptic Functions,  Up: Top

18 Limits
*********

* Menu:

* Functions and Variables for Limits::


File: maxima.info,  Node: Functions and Variables for Limits,  Prev: Limits,  Up: Limits

18.1 Functions and Variables for Limits
=======================================

 -- Option variable: lhospitallim
     Default: 4

     `lhospitallim' is the maximum number of times L'Hospital's rule is
     used in `limit'.  This prevents infinite looping in cases like
     `limit (cot(x)/csc(x), x, 0)'.


 -- Function: limit (<expr>, <x>, <val>, <dir>)
 -- Function: limit (<expr>, <x>, <val>)
 -- Function: limit (<expr>)
     Computes the limit of <expr> as the real variable <x> approaches
     the value <val> from the direction <dir>.  <dir> may have the
     value `plus' for a limit from above, `minus' for a limit from
     below, or may be omitted (implying a two-sided limit is to be
     computed).

     `limit' uses the following special symbols: `inf' (positive
     infinity) and `minf' (negative infinity).  On output it may also
     use `und' (undefined), `ind' (indefinite but bounded) and
     `infinity' (complex infinity).

     `lhospitallim' is the maximum number of times L'Hospital's rule is
     used in `limit'.  This prevents infinite looping in cases like
     `limit (cot(x)/csc(x), x, 0)'.

     `tlimswitch' when true will cause the limit package to use Taylor
     series when possible.

     `limsubst' prevents `limit' from attempting substitutions on
     unknown forms.  This is to avoid bugs like `limit (f(n)/f(n+1), n,
     inf)' giving 1.  Setting `limsubst' to `true' will allow such
     substitutions.

     `limit' with one argument is often called upon to simplify
     constant expressions, for example, `limit (inf-1)'.

     `example (limit)' displays some examples.

     For the method see Wang, P., "Evaluation of Definite Integrals by
     Symbolic Manipulation", Ph.D. thesis, MAC TR-92, October 1971.


 -- Option variable: limsubst
     default value: `false' - prevents `limit' from attempting
     substitutions on unknown forms.  This is to avoid bugs like `limit
     (f(n)/f(n+1), n, inf)' giving 1.  Setting `limsubst' to `true'
     will allow such substitutions.


 -- Function: tlimit (<expr>, <x>, <val>, <dir>)
 -- Function: tlimit (<expr>, <x>, <val>)
 -- Function: tlimit (<expr>)
     Returns `limit' with `tlimswitch' set to `true'.


 -- Option variable: tlimswitch
     Default value: `false'

     When `tlimswitch' is `true', it causes the limit package to use
     Taylor series when possible.



File: maxima.info,  Node: Differentiation,  Next: Integration,  Prev: Limits,  Up: Top

19 Differentiation
******************

* Menu:

* Functions and Variables for Differentiation::


File: maxima.info,  Node: Functions and Variables for Differentiation,  Prev: Differentiation,  Up: Differentiation

19.1 Functions and Variables for Differentiation
================================================

 -- Function: antid (<expr>, <x>, <u(x)>)
     Returns a two-element list, such that an antiderivative of <expr>
     with respect to <x> can be constructed from the list.  The
     expression <expr> may contain an unknown function <u> and its
     derivatives.

     Let <L>, a list of two elements, be the return value of `antid'.
     Then `<L>[1] + 'integrate (<L>[2], <x>)' is an antiderivative of
     <expr> with respect to <x>.

     When `antid' succeeds entirely, the second element of the return
     value is zero.  Otherwise, the second element is nonzero, and the
     first element is nonzero or zero.  If `antid' cannot make any
     progress, the first element is zero and the second nonzero.

     `load ("antid")' loads this function.  The `antid' package also
     defines the functions `nonzeroandfreeof' and `linear'.

     `antid' is related to `antidiff' as follows.  Let <L>, a list of
     two elements, be the return value of `antid'.  Then the return
     value of `antidiff' is equal to `<L>[1] + 'integrate (<L>[2], <x>)'
     where <x> is the variable of integration.

     Examples:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Function: antidiff (<expr>, <x>, <u>(<x>))
     Returns an antiderivative of <expr> with respect to <x>.  The
     expression <expr> may contain an unknown function <u> and its
     derivatives.

     When `antidiff' succeeds entirely, the resulting expression is
     free of integral signs (that is, free of the `integrate' noun).
     Otherwise, `antidiff' returns an expression which is partly or
     entirely within an integral sign.  If `antidiff' cannot make any
     progress, the return value is entirely within an integral sign.

     `load ("antid")' loads this function.  The `antid' package also
     defines the functions `nonzeroandfreeof' and `linear'.

     `antidiff' is related to `antid' as follows.  Let <L>, a list of
     two elements, be the return value of `antid'.  Then the return
     value of `antidiff' is equal to `<L>[1] + 'integrate (<L>[2], <x>)'
     where <x> is the variable of integration.

     Examples:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Property: atomgrad
     `atomgrad' is the atomic gradient property of an expression.  This
     property is assigned by `gradef'.


 -- Function: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Function: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Assigns the value <c> to <expr> at the point `<x> = <a>'.
     Typically boundary values are established by this mechanism.

     <expr> is a function evaluation, `<f>(<x_1>, ..., <x_m>)', or a
     derivative, `diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ...,
     <x_n>, <n_m>)' in which the function arguments explicitly appear.
     <n_i> is the order of differentiation with respect to <x_i>.

     The point at which the atvalue is established is given by the list
     of equations `[<x_1> = <a_1>, ..., <x_m> = <a_m>]'.  If there is a
     single variable <x_1>, the sole equation may be given without
     enclosing it in a list.

     `printprops ([<f_1>, <f_2>, ...], atvalue)' displays the atvalues
     of the functions `<f_1>, <f_2>, ...' as specified by calls to
     `atvalue'.  `printprops (<f>, atvalue)' displays the atvalues of
     one function <f>.  `printprops (all, atvalue)' displays the
     atvalues of all functions for which atvalues are defined.

     The symbols `@1', `@2', ... represent the variables <x_1>, <x_2>,
     ... when atvalues are displayed.

     `atvalue' evaluates its arguments.  `atvalue' returns <c>, the
     atvalue.

     Examples:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Function: cartan -
     The exterior calculus of differential forms is a basic tool of
     differential geometry developed by Elie Cartan and has important
     applications in the theory of partial differential equations.  The
     `cartan' package implements the functions `ext_diff' and
     `lie_diff', along with the operators `~' (wedge product) and `|'
     (contraction of a form with a vector.)  Type `demo (tensor)' to
     see a brief description of these commands along with examples.

     `cartan' was implemented by F.B. Estabrook and H.D. Wahlquist.


 -- Function: del (<x>)
     `del (<x>)' represents the differential of the variable x.

     `diff' returns an expression containing `del' if an independent
     variable is not specified.  In this case, the return value is the
     so-called "total differential".

     Examples:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Function: delta (<t>)
     The Dirac Delta function.

     Currently only `laplace' knows about the `delta' function.

     Example:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- System variable: dependencies
     Default value: `[]'

     `dependencies' is the list of atoms which have functional
     dependencies, assigned by `depends' or `gradef'.  The
     `dependencies' list is cumulative: each call to `depends' or
     `gradef' appends additional items.

     See `depends' and `gradef'.


 -- Function: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declares functional dependencies among variables for the purpose
     of computing derivatives.  In the absence of declared dependence,
     `diff (f, x)' yields zero.  If `depends (f, x)' is declared, `diff
     (f, x)' yields a symbolic derivative (that is, a `diff' noun).

     Each argument <f_1>, <x_1>, etc., can be the name of a variable or
     array, or a list of names.  Every element of <f_i> (perhaps just a
     single element) is declared to depend on every element of <x_i>
     (perhaps just a single element).  If some <f_i> is the name of an
     array or contains the name of an array, all elements of the array
     depend on <x_i>.

     `diff' recognizes indirect dependencies established by `depends'
     and applies the chain rule in these cases.

     `remove (<f>, dependency)' removes all dependencies declared for
     <f>.

     `depends' returns a list of the dependencies established.  The
     dependencies are appended to the global variable `dependencies'.
     `depends' evaluates its arguments.

     `diff' is the only Maxima command which recognizes dependencies
     established by `depends'.  Other functions (`integrate',
     `laplace', etc.)  only recognize dependencies explicitly
     represented by their arguments.  For example, `integrate' does not
     recognize the dependence of `f' on `x' unless explicitly
     represented as `integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Option variable: derivabbrev
     Default value: `false'

     When `derivabbrev' is `true', symbolic derivatives (that is,
     `diff' nouns) are displayed as subscripts.  Otherwise, derivatives
     are displayed in the Leibniz notation `dy/dx'.


 -- Function: derivdegree (<expr>, <y>, <x>)
     Returns the highest degree of the derivative of the dependent
     variable <y> with respect to the independent variable <x> occuring
     in <expr>.

     Example:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Function: derivlist (<var_1>, ..., <var_k>)
     Causes only differentiations with respect to the indicated
     variables, within the `ev' command.


 -- Option variable: derivsubst
     Default value: `false'

     When `derivsubst' is `true', a non-syntactic substitution such as
     `subst (x, 'diff (y, t), 'diff (y, t, 2))' yields `'diff (x, t)'.


 -- Function: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Function: diff (<expr>, <x>, <n>)
 -- Function: diff (<expr>, <x>)
 -- Function: diff (<expr>)
     Returns the derivative or differential of <expr> with respect to
     some or all variables in <expr>.

     `diff (<expr>, <x>, <n>)' returns the <n>'th derivative of <expr>
     with respect to <x>.

     `diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' returns the mixed
     partial derivative of <expr> with respect to <x_1>, ..., <x_m>.
     It is equivalent to `diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)'.

     `diff (<expr>, <x>)' returns the first derivative of <expr> with
     respect to the variable <x>.

     `diff (<expr>)' returns the total differential of <expr>, that is,
     the sum of the derivatives of <expr> with respect to each its
     variables times the differential `del' of each variable.  No
     further simplification of `del' is offered.

     The noun form of `diff' is required in some contexts, such as
     stating a differential equation.  In these cases, `diff' may be
     quoted (as `'diff') to yield the noun form instead of carrying out
     the differentiation.

     When `derivabbrev' is `true', derivatives are displayed as
     subscripts.  Otherwise, derivatives are displayed in the Leibniz
     notation, `dy/dx'.

     Examples:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     For the tensor package, the following modifications have been
     incorporated:

     (1) The derivatives of any indexed objects in <expr> will have the
     variables <x_i> appended as additional arguments.  Then all the
     derivative indices will be sorted.

     (2) The <x_i> may be integers from 1 up to the value of the
     variable `dimension' [default value: 4].  This will cause the
     differentiation to be carried out with respect to the <x_i>'th
     member of the list `coordinates' which should be set to a list of
     the names of the coordinates, e.g., `[x, y, z, t]'. If
     `coordinates' is bound to an atomic variable, then that variable
     subscripted by <x_i> will be used for the variable of
     differentiation.  This permits an array of coordinate names or
     subscripted names like `X[1]', `X[2]', ... to be used.  If
     `coordinates' has not been assigned a value, then the variables
     will be treated as in (1) above.


 -- Special symbol: diff
     When `diff' is present as an `evflag' in call to `ev', all
     differentiations indicated in `expr' are carried out.


 -- Function: dscalar (<f>)
     Applies the scalar d'Alembertian to the scalar function <f>.

     `load ("ctensor")' loads this function.


 -- Function: express (<expr>)
     Expands differential operator nouns into expressions in terms of
     partial derivatives.  `express' recognizes the operators `grad',
     `div', `curl', `laplacian'.  `express' also expands the cross
     product `~'.

     Symbolic derivatives (that is, `diff' nouns) in the return value
     of express may be evaluated by including `diff' in the `ev'
     function call or command line.  In this context, `diff' acts as an
     `evfun'.

     `load ("vect")' loads this function.

     Examples:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Function: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Function: gradef (<a>, <x>, <expr>)
     Defines the partial derivatives (i.e., the components of the
     gradient) of the function <f> or variable <a>.

     `gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' defines
     `d<f>/d<x_i>' as <g_i>, where <g_i> is an expression; <g_i> may be
     a function call, but not the name of a function.  The number of
     partial derivatives <m> may be less than the number of arguments
     <n>, in which case derivatives are defined with respect to <x_1>
     through <x_m> only.

     `gradef (<a>, <x>, <expr>)' defines the derivative of variable <a>
     with respect to <x> as <expr>.  This also establishes the
     dependence of <a> on <x> (via `depends (<a>, <x>)').

     The first argument `<f>(<x_1>, ..., <x_n>)' or <a> is quoted, but
     the remaining arguments <g_1>, ..., <g_m> are evaluated.  `gradef'
     returns the function or variable for which the partial derivatives
     are defined.

     `gradef' can redefine the derivatives of Maxima's built-in
     functions.  For example, `gradef (sin(x), sqrt (1 - sin(x)^2))'
     redefines the derivative of `sin'.

     `gradef' cannot define partial derivatives for a subscripted
     function.

     `printprops ([<f_1>, ..., <f_n>], gradef)' displays the partial
     derivatives of the functions <f_1>, ..., <f_n>, as defined by
     `gradef'.

     `printprops ([<a_n>, ..., <a_n>], atomgrad)' displays the partial
     derivatives of the variables <a_n>, ..., <a_n>, as defined by
     `gradef'.

     `gradefs' is the list of the functions for which partial
     derivatives have been defined by `gradef'.  `gradefs' does not
     include any variables for which partial derivatives have been
     defined by `gradef'.

     Gradients are needed when, for example, a function is not known
     explicitly but its first derivatives are and it is desired to
     obtain higher order derivatives.


 -- System variable: gradefs
     Default value: `[]'

     `gradefs' is the list of the functions for which partial
     derivatives have been defined by `gradef'.  `gradefs' does not
     include any variables for which partial derivatives have been
     defined by `gradef'.


 -- Function: laplace (<expr>, <t>, <s>)
     Attempts to compute the Laplace transform of <expr> with respect
     to the variable <t> and transform parameter <s>.  If `laplace'
     cannot find a solution, a noun `'laplace' is returned.

     `laplace' recognizes in <expr> the functions `delta', `exp',
     `log', `sin', `cos', `sinh', `cosh', and `erf', as well as
     `derivative', `integrate', `sum', and `ilt'.  If some other
     functions are present, `laplace' may not be able to compute the
     transform.

     <expr> may also be a linear, constant coefficient differential
     equation in which case `atvalue' of the dependent variable is used.
     The required atvalue may be supplied either before or after the
     transform is computed.  Since the initial conditions must be
     specified at zero, if one has boundary conditions imposed
     elsewhere he can impose these on the general solution and
     eliminate the constants by solving the general solution for them
     and substituting their values back.

     `laplace' recognizes convolution integrals of the form `integrate
     (f(x) * g(t - x), x, 0, t)'; other kinds of convolutions are not
     recognized.

     Functional relations must be explicitly represented in <expr>;
     implicit relations, established by `depends', are not recognized.
     That is, if <f> depends on <x> and <y>, `f (x, y)' must appear in
     <expr>.

     See also `ilt', the inverse Laplace transform.

     Examples:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0



File: maxima.info,  Node: Integration,  Next: Equations,  Prev: Differentiation,  Up: Top

20 Integration
**************

* Menu:

* Introduction to Integration::
* Functions and Variables for Integration::
* Introduction to QUADPACK::
* Functions and Variables for QUADPACK::


File: maxima.info,  Node: Introduction to Integration,  Next: Functions and Variables for Integration,  Prev: Integration,  Up: Integration

20.1 Introduction to Integration
================================

Maxima has several routines for handling integration.  The `integrate'
function makes use of most of them.  There is also the `antid' package,
which handles an unspecified function (and its derivatives, of course).
For numerical uses, there is a set of adaptive integrators from
QUADPACK, named `quad_qag', `quad_qags', etc., which are described
under the heading `QUADPACK'.  Hypergeometric functions are being
worked on, see `specint' for details.  Generally speaking, Maxima only
handles integrals which are integrable in terms of the "elementary
functions" (rational functions, trigonometrics, logs, exponentials,
radicals, etc.) and a few extensions (error function, dilogarithm).  It
does not handle integrals in terms of unknown functions such as `g(x)'
and `h(x)'.


File: maxima.info,  Node: Functions and Variables for Integration,  Next: Introduction to QUADPACK,  Prev: Introduction to Integration,  Up: Integration

20.2 Functions and Variables for Integration
============================================

 -- Function: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Makes the change of variable given by `<f(x,y)> = 0' in all
     integrals occurring in <expr> with integration with respect to <x>.
     The new variable is <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     An expression containing a noun form, such as the instances of
     `'integrate' above, may be evaluated by `ev' with the `nouns' flag.
     For example, the expression returned by `changevar' above may be
     evaluated by `ev (%o3, nouns)'.

     `changevar' may also be used to changes in the indices of a sum or
     product.  However, it must be realized that when a change is made
     in a sum or product, this change must be a shift, i.e., `i = j+
     ...', not a higher degree function.  E.g.,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Function: dblint (<f>, <r>, <s>, <a>, <b>)
     A double-integral routine which was written in top-level Maxima
     and then translated and compiled to machine code.  Use `load
     (dblint)' to access this package.  It uses the Simpson's rule
     method in both the x and y directions to calculate

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     The function <f> must be a translated or compiled function of two
     variables, and <r> and <s> must each be a translated or compiled
     function of one variable, while <a> and <b> must be floating point
     numbers. The routine has two global variables which determine the
     number of divisions of the x and y intervals: `dblint_x' and
     `dblint_y', both of which are initially 10, and can be changed
     independently to other integer values (there are `2*dblint_x+1'
     points computed in the x direction, and `2*dblint_y+1' in the y
     direction).  The routine subdivides the X axis and then for each
     value of X it first computes `<r>(x)' and `<s>(x)'; then the Y
     axis between `<r>(x)' and `<s>(x)' is subdivided and the integral
     along the Y axis is performed using Simpson's rule; then the
     integral along the X axis is done using Simpson's rule with the
     function values being the Y-integrals. This procedure may be
     numerically unstable for a great variety of reasons, but is
     reasonably fast: avoid using it on highly oscillatory functions
     and functions with singularities (poles or branch points in the
     region).  The Y integrals depend on how far apart `<r>(x)' and
     `<s>(x)' are, so if the distance `<s>(x) - <r>(x)' varies rapidly
     with X, there may be substantial errors arising from truncation
     with different step-sizes in the various Y integrals. One can
     increase `dblint_x' and `dblint_y' in an effort to improve the
     coverage of the region, at the expense of computation time. The
     function values are not saved, so if the function is very
     time-consuming, you will have to wait for re-computation if you
     change anything (sorry).  It is required that the functions <f>,
     <r>, and <s> be either translated or compiled prior to calling
     `dblint'. This will result in orders of magnitude speed
     improvement over interpreted code in many cases!

     `demo (dblint)' executes a demonstration of `dblint' applied to an
     example problem.


 -- Function: defint (<expr>, <x>, <a>, <b>)
     Attempts to compute a definite integral.  `defint' is called by
     `integrate' when limits of integration are specified, i.e., when
     `integrate' is called as `integrate (<expr>, <x>, <a>, <b>)'.
     Thus from the user's point of view, it is sufficient to call
     `integrate'.

     `defint' returns a symbolic expression, either the computed
     integral or the noun form of the integral.  See `quad_qag' and
     related functions for numerical approximation of definite
     integrals.


 -- Function: erf (<x>)
     Represents the error function, whose derivative is:
     `2*exp(-x^2)/sqrt(%pi)'.


 -- Option variable: erfflag
     Default value: `true'

     When `erfflag' is `false', prevents `risch' from introducing the
     `erf' function in the answer if there were none in the integrand to
     begin with.


 -- Function: ilt (<expr>, <t>, <s>)
     Computes the inverse Laplace transform of <expr> with respect to
     <t> and parameter <s>.  <expr> must be a ratio of polynomials
     whose denominator has only linear and quadratic factors.  By using
     the functions `laplace' and `ilt' together with the `solve' or
     `linsolve' functions the user can solve a single differential or
     convolution integral equation or a set of them.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Function: integrate (<expr>, <x>)
 -- Function: integrate (<expr>, <x>, <a>, <b>)
     Attempts to symbolically compute the integral of <expr> with
     respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
     integral, while `integrate (<expr>, <x>, <a>, <b>)' is a definite
     integral, with limits of integration <a> and <b>.  The limits
     should not contain <x>, although `integrate' does not enforce this
     restriction.  <a> need not be less than <b>.  If <b> is equal to
     <a>, `integrate' returns zero.

     See `quad_qag' and related functions for numerical approximation
     of definite integrals.  See `residue' for computation of residues
     (complex integration).  See `antid' for an alternative means of
     computing indefinite integrals.

     The integral (an expression free of `integrate') is returned if
     `integrate' succeeds.  Otherwise the return value is the noun form
     of the integral (the quoted operator `'integrate') or an
     expression containing one or more noun forms.  The noun form of
     `integrate' is displayed with an integral sign.

     In some circumstances it is useful to construct a noun form by
     hand, by quoting `integrate' with a single quote, e.g.,
     `'integrate (<expr>, <x>)'.  For example, the integral may depend
     on some parameters which are not yet computed.  The noun may be
     applied to its arguments by `ev (<i>, nouns)' where <i> is the
     noun form of interest.

     `integrate' handles definite integrals separately from indefinite,
     and employs a range of heuristics to handle each case.  Special
     cases of definite integrals include limits of integration equal to
     zero or infinity (`inf' or `minf'), trigonometric functions with
     limits of integration equal to zero and `%pi' or `2 %pi', rational
     functions, integrals related to the definitions of the `beta' and
     `psi' functions, and some logarithmic and trigonometric integrals.
     Processing rational functions may include computation of residues.
     If an applicable special case is not found, an attempt will be
     made to compute the indefinite integral and evaluate it at the
     limits of integration.  This may include taking a limit as a limit
     of integration goes to infinity or negative infinity; see also
     `ldefint'.

     Special cases of indefinite integrals include trigonometric
     functions, exponential and logarithmic functions, and rational
     functions.  `integrate' may also make use of a short table of
     elementary integrals.

     `integrate' may carry out a change of variable if the integrand
     has the form `f(g(x)) * diff(g(x), x)'.  `integrate' attempts to
     find a subexpression `g(x)' such that the derivative of `g(x)'
     divides the integrand.  This search may make use of derivatives
     defined by the `gradef' function.  See also `changevar' and
     `antid'.

     If none of the preceding heuristics find the indefinite integral,
     the Risch algorithm is executed.  The flag `risch' may be set as
     an `evflag', in a call to `ev' or on the command line, e.g., `ev
     (integrate (<expr>, <x>), risch)' or `integrate (<expr>, <x>),
     risch'.  If `risch' is present, `integrate' calls the `risch'
     function without attempting heuristics first. See also `risch'.

     `integrate' works only with functional relations represented
     explicitly with the `f(x)' notation.  `integrate' does not respect
     implicit dependencies established by the `depends' function.

     `integrate' may need to know some property of a parameter in the
     integrand.  `integrate' will first consult the `assume' database,
     and, if the variable of interest is not there, `integrate' will
     ask the user.  Depending on the question, suitable responses are
     `yes;' or `no;', or `pos;', `zero;', or `neg;'.

     `integrate' is not, by default, declared to be linear. See
     `declare' and `linear'.

     `integrate' attempts integration by parts only in a few special
     cases.

     Examples:

        * Elementary indefinite and definite integrals.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Use of `assume' and interactive query.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Change of variable. There are two changes of variable in this
          example: one using a derivative established by `gradef', and
          one using the derivation `diff(r(x))' of an unspecified
          function `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * Return value contains the `'integrate' noun form.  In this
          example, Maxima can extract one factor of the denominator of
          a rational function, but cannot factor the remainder or
          otherwise find its integral.  `grind' shows the noun form
          `'integrate' in the result.  See also `integrate_use_rootsof'
          for more on integrals of rational functions.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Defining a function in terms of an integral.  The body of a
          function is not evaluated when the function is defined.  Thus
          the body of `f_1' in this example contains the noun form of
          `integrate'.  The quote-quote operator `''' causes the
          integral to be evaluated, and the result becomes the body of
          `f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- System variable: integration_constant_counter
     Default value: 0

     `integration_constant_counter' is a counter which is updated each
     time a constant of integration (named by Maxima, e.g.,
     `integrationconstant1') is introduced into an expression by
     indefinite integration of an equation.


 -- Option variable: integrate_use_rootsof
     Default value: `false'

     When `integrate_use_rootsof' is `true' and the denominator of a
     rational function cannot be factored, `integrate' returns the
     integral in a form which is a sum over the roots (not yet known)
     of the denominator.

     For example, with `integrate_use_rootsof' set to `false',
     `integrate' returns an unsolved integral of a rational function in
     noun form:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Now we set the flag to be true and the unsolved part of the
     integral will be expressed as a summation over the roots of the
     denominator of the rational function:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     Alternatively the user may compute the roots of the denominator
     separately, and then express the integrand in terms of these roots,
     e.g., `1/((x - a)*(x - b)*(x - c))' or `1/((x^2 - (a+b)*x +
     a*b)*(x - c))' if the denominator is a cubic polynomial.
     Sometimes this will help Maxima obtain a more useful result.


 -- Function: ldefint (<expr>, <x>, <a>, <b>)
     Attempts to compute the definite integral of <expr> by using
     `limit' to evaluate the indefinite integral of <expr> with respect
     to <x> at the upper limit <b> and at the lower limit <a>.  If it
     fails to compute the definite integral, `ldefint' returns an
     expression containing limits as noun forms.

     `ldefint' is not called from `integrate', so executing `ldefint
     (<expr>, <x>, <a>, <b>)' may yield a different result than
     `integrate (<expr>, <x>, <a>, <b>)'.  `ldefint' always uses the
     same method to evaluate the definite integral, while `integrate'
     may employ various heuristics and may recognize some special cases.


 -- Function: potential (<givengradient>)
     The calculation makes use of the global variable
     `potentialzeroloc[0]' which must be `nonlist' or of the form

          [indeterminatej=expressionj, indeterminatek=expressionk, ...]

     the former being equivalent to the nonlist expression for all
     right-hand sides in the latter.  The indicated right-hand sides
     are used as the lower limit of integration.  The success of the
     integrations may depend upon their values and order.
     `potentialzeroloc' is initially set to 0.


 -- Function: residue (<expr>, <z>, <z_0>)
     Computes the residue in the complex plane of the expression <expr>
     when the variable <z> assumes the value <z_0>.  The residue is the
     coefficient of `(<z> - <z_0>)^(-1)' in the Laurent series for
     <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Function: risch (<expr>, <x>)
     Integrates <expr> with respect to <x> using the transcendental
     case of the Risch algorithm.  (The algebraic case of the Risch
     algorithm has not been implemented.)  This currently handles the
     cases of nested exponentials and logarithms which the main part of
     `integrate' can't do.  `integrate' will automatically apply `risch'
     if given these cases.

     `erfflag', if `false', prevents `risch' from introducing the `erf'
     function in the answer if there were none in the integrand to begin
     with.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Function: tldefint (<expr>, <x>, <a>, <b>)
     Equivalent to `ldefint' with `tlimswitch' set to `true'.



File: maxima.info,  Node: Introduction to QUADPACK,  Next: Functions and Variables for QUADPACK,  Prev: Functions and Variables for Integration,  Up: Integration

20.3 Introduction to QUADPACK
=============================

QUADPACK is a collection of functions for the numerical computation of
one-dimensional definite integrals.  It originated from a joint project
of R. Piessens (1), E. de Doncker (2), C. Ueberhuber (3), and D.
Kahaner (4).

   The QUADPACK library included in Maxima is an automatic translation
(via the program `f2cl') of the Fortran source code of QUADPACK as it
appears in the SLATEC Common Mathematical Library, Version 4.1 (5).
The SLATEC library is dated July 1993, but the QUADPACK functions were
written some years before.  There is another version of QUADPACK at
Netlib (6); it is not clear how that version differs from the SLATEC
version.

   The QUADPACK functions included in Maxima are all automatic, in the
sense that these functions attempt to compute a result to a specified
accuracy, requiring an unspecified number of function evaluations.
Maxima's Lisp translation of QUADPACK also includes some non-automatic
functions, but they are not exposed at the Maxima level.

   Further information about QUADPACK can be found in the QUADPACK book
(7).

20.3.1 Overview
---------------

`quad_qag'
     Integration of a general function over a finite interval.
     `quad_qag' implements a simple globally adaptive integrator using
     the strategy of Aind (Piessens, 1973).  The caller may choose
     among 6 pairs of Gauss-Kronrod quadrature formulae for the rule
     evaluation component.  The high-degree rules are suitable for
     strongly oscillating integrands.

`quad_qags'
     Integration of a general function over a finite interval.
     `quad_qags' implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

`quad_qagi'
     Integration of a general function over an infinite or
     semi-infinite interval.  The interval is mapped onto a finite
     interval and then the same strategy as in `quad_qags' is applied.

`quad_qawo'
     Integration of cos(omega x) f(x) or sin(omega x) f(x) over a
     finite interval, where omega is a constant.  The rule evaluation
     component is based on the modified Clenshaw-Curtis technique.
     `quad_qawo' applies adaptive subdivision with extrapolation,
     similar to `quad_qags'.

`quad_qawf'
     Calculates a Fourier cosine or Fourier sine transform on a
     semi-infinite interval.  The same approach as in `quad_qawo' is
     applied on successive finite intervals, and convergence
     acceleration by means of the Epsilon algorithm (Wynn, 1956) is
     applied to the series of the integral contributions.

`quad_qaws'
     Integration of w(x) f(x) over a finite interval [a, b], where w is
     a function of the form (x - a)^alpha (b - x)^beta v(x) and v(x) is
     1 or log(x - a) or log(b - x) or log(x - a) log(b - x), and alpha
     > -1 and beta > -1.  A globally adaptive subdivision strategy is
     applied, with modified Clenshaw-Curtis integration on the
     subintervals which contain a or b.

`quad_qawc'
     Computes the Cauchy principal value of f(x)/(x - c) over a finite
     interval (a, b) and specified c.  The strategy is globally
     adaptive, and modified Clenshaw-Curtis integration is used on the
     subranges which contain the point x = c.

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut fu"r Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) `http://www.netlib.org/slatec'

   (6) `http://www.netlib.org/quadpack'

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Functions and Variables for QUADPACK,  Prev: Introduction to QUADPACK,  Up: Integration

20.4 Functions and Variables for QUADPACK
=========================================

 -- Function: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, <epsrel>, <limit>)
 -- Function: quad_qag (<f>, <x>, <a>, <b>, <key>, <epsrel>, <limit>)
     Integration of a general function over a finite interval.
     `quad_qag' implements a simple globally adaptive integrator using
     the strategy of Aind (Piessens, 1973).  The caller may choose
     among 6 pairs of Gauss-Kronrod quadrature formulae for the rule
     evaluation component.  The high-degree rules are suitable for
     strongly oscillating integrands.

     `quad_qag' computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.  <key> is the integrator to be used and should be an
     integer between 1 and 6, inclusive.  The value of <key> selects
     the order of the Gauss-Kronrod integration rule.  High-order rules
     are suitable for strongly oscillating integrands.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The numerical integration is done adaptively by subdividing the
     integration region into sub-intervals until the desired accuracy is
     achieved.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qag' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          if no problems were encountered;

    `1'
          if too many sub-intervals were done;

    `2'
          if excessive roundoff error is detected;

    `3'
          if extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Function: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limit>)
 -- Function: quad_qags (<f>, <x>, <a>, <b>, <epsrel>, <limit>)
     Integration of a general function over a finite interval.
     `quad_qags' implements globally adaptive interval subdivision with
     extrapolation (de Doncker, 1978) by the Epsilon algorithm (Wynn,
     1956).

     `quad_qags' computes the integral

     integrate (f(x), x, a, b)

     The function to be integrated is <f(x)>, with dependent variable
     <x>, and the function is to be integrated between the limits <a>
     and <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qags' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.

     Examples:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note that `quad_qags' is more accurate and efficient than
     `quad_qag' for this integrand.


 -- Function: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limit>)
 -- Function: quad_qagi (<f>, <x>, <a>, <inftype>, <epsrel>, <limit>)
     Integration of a general function over an infinite or
     semi-infinite interval.  The interval is mapped onto a finite
     interval and then the same strategy as in `quad_qags' is applied.

     `quad_qagi' evaluates one of the following integrals

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, minf, inf)

     using the Quadpack QAGI routine.  The function to be integrated is
     <f(x)>, with dependent variable <x>, and the function is to be
     integrated over an infinite range.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The parameter <inftype> determines the integration interval as
     follows:

    `inf'
          The interval is from <a> to positive infinity.

    `minf'
          The interval is from negative infinity to <a>.

    `both'
          The interval is the entire real line.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qagi' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `4'
          failed to converge

    `5'
          integral is probably divergent or slowly convergent

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Function: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limit>)
 -- Function: quad_qawc (<f>, <x>, <c>, <a>, <b>, <epsrel>, <limit>)
     Computes the Cauchy principal value of f(x)/(x - c) over a finite
     interval.  The strategy is globally adaptive, and modified
     Clenshaw-Curtis integration is used on the subranges which contain
     the point x = c.

     `quad_qawc' computes the Cauchy principal value of

     integrate (f(x)/(x - c), x, a, b)

     using the Quadpack QAWC routine.  The function to be integrated is
     `<f(x)>/(<x> - <c>)', with dependent variable <x>, and the function
     is to be integrated over the interval <a> to <b>.

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The optional arguments <epsrel> and <limit> are the desired
     relative error and the maximum number of subintervals,
     respectively.  <epsrel> defaults to 1e-8 and <limit> is 200.

     `quad_qawc' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Function: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
 -- Function: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
     Calculates a Fourier cosine or Fourier sine transform on a
     semi-infinite interval using the Quadpack QAWF function.  The same
     approach as in `quad_qawo' is applied on successive finite
     intervals, and convergence acceleration by means of the Epsilon
     algorithm (Wynn, 1956) is applied to the series of the integral
     contributions.

     `quad_qawf' computes the integral

     integrate (f(x)*w(x), x, a, inf)

     The weight function w is selected by <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The optional arguments are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

    <maxp1>
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.

    <limlst>
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     <epsabs> and <limit> are the desired relative error and the
     maximum number of subintervals, respectively.  <epsrel> defaults
     to 1e-8 and <limit> is 200.

     `quad_qawf' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Function: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          <epsabs>, <limit>, <maxp1>, <limlst>)
 -- Function: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
     Integration of cos(omega x) f(x) or sin(omega x) f(x) over a
     finite interval, where omega is a constant.  The rule evaluation
     component is based on the modified Clenshaw-Curtis technique.
     `quad_qawo' applies adaptive subdivision with extrapolation,
     similar to `quad_qags'.

     `quad_qawo' computes the integral using the Quadpack QAWO routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The optional arguments are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

    <maxp1>
          Maximum number of Chebyshev moments.  Must be greater than 0.
          Default is 100.

    <limlst>
          Upper bound on the number of cycles.  Must be greater than or
          equal to 3.  Default is 10.

     <epsabs> and <limit> are the desired relative error and the
     maximum number of subintervals, respectively.  <epsrel> defaults
     to 1e-8 and <limit> is 200.

     `quad_qawo' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Function: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>,
          <wfun>, <epsabs>, <limit>)
 -- Function: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          <epsabs>, <limit>)
     Integration of w(x) f(x) over a finite interval, where w(x) is a
     certain algebraic or logarithmic function.  A globally adaptive
     subdivision strategy is applied, with modified Clenshaw-Curtis
     integration on the subintervals which contain the endpoints of the
     interval of integration.

     `quad_qaws' computes the integral using the Quadpack QAWS routine:

     integrate (f(x)*w(x), x, a, b)

     The weight function w is selected by <wfun>:

    `1'
          w(x) = (x - a)^alpha (b - x)^beta

    `2'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)

    `4'
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     The integrand may be specified as the name of a Maxima or Lisp
     function or operator, a Maxima lambda expression, or a general
     Maxima expression.

     The optional arguments are:

    <epsabs>
          Desired absolute error of approximation.  Default is 1d-10.

    <limit>
          Size of internal work array.  (<limit> - <limlst>)/2 is the
          maximum number of subintervals to use.  Default is 200.

     <epsabs> and <limit> are the desired relative error and the
     maximum number of subintervals, respectively.  <epsrel> defaults
     to 1e-8 and <limit> is 200.

     `quad_qaws' returns a list of four elements:

        * an approximation to the integral,

        * the estimated absolute error of the approximation,

        * the number integrand evaluations,

        * an error code.

     The error code (fourth element of the return value) can have the
     values:

    `0'
          no problems were encountered;

    `1'
          too many sub-intervals were done;

    `2'
          excessive roundoff error is detected;

    `3'
          extremely bad integrand behavior occurs;

    `6'
          if the input is invalid.


     Examples:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Equations,  Next: Differential Equations,  Prev: Integration,  Up: Top

21 Equations
************

* Menu:

* Functions and Variables for Equations::


File: maxima.info,  Node: Functions and Variables for Equations,  Prev: Equations,  Up: Equations

21.1 Functions and Variables for Equations
==========================================

 -- System variable: %rnum_list
     Default value: `[]'

     `%rnum_list' is the list of variables introduced in solutions by
     `algsys'.  `%r' variables are added to `%rnum_list' in the order
     they are created.  This is convenient for doing substitutions into
     the solution later on.  It's recommended to use this list rather
     than doing `concat ('%r, j)'.


 -- Option variable: algexact
     Default value: `false'

     `algexact' affects the behavior of `algsys' as follows:

     If `algexact' is `true', `algsys' always calls `solve' and then
     uses `realroots' on `solve''s failures.

     If `algexact' is `false', `solve' is called only if the eliminant
     was not univariate, or if it was a quadratic or biquadratic.

     Thus `algexact: true' doesn't guarantee only exact solutions, just
     that `algsys' will first try as hard as it can to give exact
     solutions, and only yield approximations when all else fails.


 -- Function: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Function: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Solves the simultaneous polynomials <expr_1>, ..., <expr_m> or
     polynomial equations <eqn_1>, ..., <eqn_m> for the variables
     <x_1>, ..., <x_n>.  An expression <expr> is equivalent to an
     equation `<expr> = 0'.  There may be more equations than variables
     or vice versa.

     `algsys' returns a list of solutions, with each solution given as
     a list of equations stating values of the variables <x_1>, ...,
     <x_n> which satisfy the system of equations.  If `algsys' cannot
     find a solution, an empty list `[]' is returned.

     The symbols `%r1', `%r2', ..., are introduced as needed to
     represent arbitrary parameters in the solution; these variables
     are also appended to the list `%rnum_list'.

     The method is as follows:

     (1) First the equations are factored and split into subsystems.

     (2) For each subsystem <S_i>, an equation <E> and a variable <x>
     are selected.  The variable is chosen to have lowest nonzero
     degree.  Then the resultant of <E> and <E_j> with respect to <x>
     is computed for each of the remaining equations <E_j> in the
     subsystem <S_i>.  This yields a new subsystem <S_i'> in one fewer
     variables, as <x> has been eliminated.  The process now returns to
     (1).

     (3) Eventually, a subsystem consisting of a single equation is
     obtained.  If the equation is multivariate and no approximations in
     the form of floating point numbers have been introduced, then
     `solve' is called to find an exact solution.

     In some cases, `solve' is not be able to find a solution, or if it
     does the solution may be a very large expression.

     If the equation is univariate and is either linear, quadratic, or
     biquadratic, then again `solve' is called if no approximations have
     been introduced.  If approximations have been introduced or the
     equation is not univariate and neither linear, quadratic, or
     biquadratic, then if the switch `realonly' is `true', the function
     `realroots' is called to find the real-valued solutions.  If
     `realonly' is `false', then `allroots' is called which looks for
     real and complex-valued solutions.

     If `algsys' produces a solution which has fewer significant digits
     than required, the user can change the value of `algepsilon' to a
     higher value.

     If `algexact' is set to `true', `solve' will always be called.

     (4) Finally, the solutions obtained in step (3) are substituted
     into previous levels and the solution process returns to (1).

     When `algsys' encounters a multivariate equation which contains
     floating point approximations (usually due to its failing to find
     exact solutions at an earlier stage), then it does not attempt to
     apply exact methods to such equations and instead prints the
     message: "`algsys' cannot solve - system too complicated."

     Interactions with `radcan' can produce large or complicated
     expressions.  In that case, it may be possible to isolate parts of
     the result with `pickapart' or `reveal'.

     Occasionally, `radcan' may introduce an imaginary unit `%i' into a
     solution which is actually real-valued.

     Examples:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Function: allroots (<expr>)
 -- Function: allroots (<eqn>)
     Computes numerical approximations of the real and complex roots of
     the polynomial <expr> or polynomial equation <eqn> of one variable.

     The flag `polyfactor' when `true' causes `allroots' to factor the
     polynomial over the real numbers if the polynomial is real, or
     over the complex numbers, if the polynomial is complex.

     `allroots' may give inaccurate results in case of multiple roots.
     If the polynomial is real, `allroots (%i*<p>)') may yield more
     accurate approximations than `allroots (<p>)', as `allroots'
     invokes a different algorithm in that case.

     `allroots' rejects non-polynomials.  It requires that the numerator
     after `rat''ing should be a polynomial, and it requires that the
     denominator be at most a complex number.  As a result of this
     `allroots' will always return an equivalent (but factored)
     expression, if `polyfactor' is `true'.

     For complex polynomials an algorithm by Jenkins and Traub is used
     (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  For real
     polynomials the algorithm used is due to Jenkins (Algorithm 493,
     ACM TOMS, vol. 1, (1975), p.178).

     Examples:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Option variable: backsubst
     Default value: `true'

     When `backsubst' is `false', prevents back substitution after the
     equations have been triangularized.  This may be helpful in very
     big problems where back substitution would cause the generation of
     extremely large expressions.


 -- Option variable: breakup
     Default value: `true'

     When `breakup' is `true', `solve' expresses solutions of cubic and
     quartic equations in terms of common subexpressions, which are
     assigned to intermediate expression labels (`%t1', `%t2', etc.).
     Otherwise, common subexpressions are not identified.

     `breakup: true' has an effect only when `programmode' is `false'.

     Examples:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Function: dimension (<eqn>)
 -- Function: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' is a package for dimensional analysis.  `load ("dimen")'
     loads this package.  `demo ("dimen")' displays a short
     demonstration.


 -- Option variable: dispflag
     Default value: `true'

     If set to `false' within a `block' will inhibit the display of
     output generated by the solve functions called from within  the
     `block'.  Termination of the `block' with a dollar sign, $, sets
     `dispflag' to `false'.


 -- Function: funcsolve (<eqn>, <g>(<t>))
     Returns `[<g>(<t>) = ...]'  or `[]', depending on whether or not
     there exists a rational function `<g>(<t>)' satisfying <eqn>,
     which must be a first order, linear polynomial in (for this case)
     `<g>(<t>)' and `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
                (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Warning: this is a very rudimentary implementation - many safety
     checks and obvious generalizations are missing.


 -- Option variable: globalsolve
     Default value: `false'

     When `globalsolve' is `true', solved-for variables are assigned
     the solution values found by `linsolve', and by `solve' when
     solving two or more linear equations.

     When `globalsolve' is `false', solutions found by `linsolve' and
     by `solve' when solving two or more linear equations are expressed
     as equations, and the solved-for variables are not assigned.

     When solving anything other than two or more linear equations,
     `solve' ignores `globalsolve'.  Other functions which solve
     equations (e.g., `algsys') always ignore `globalsolve'.

     Examples:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Function: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' is a package for solving integral equations.  `load
     ("inteqn")' loads this package.

     <ie> is the integral equation; <unk> is the unknown function;
     <tech> is the technique to be tried from those given above (<tech>
     = `first' means: try the first technique which finds a solution;
     <tech> = `all' means: try all applicable techniques); <n> is the
     maximum number of terms to take for `taylor', `neumann',
     `firstkindseries', or `fredseries' (it is also the maximum depth
     of recursion for the differentiation method); <guess> is the
     initial guess for `neumann' or `firstkindseries'.

     Default values for the 2nd thru 5th parameters are:

     <unk>: `<p>(<x>)', where <p> is the first function encountered in
     an integrand which is unknown to Maxima and <x> is the variable
     which occurs as an argument to the first occurrence of <p> found
     outside of an integral in the case of `secondkind' equations, or
     is the only other variable besides the variable of integration in
     `firstkind' equations.  If the attempt to search for <x> fails,
     the user will be asked to supply the independent variable.

     tech: `first'

     n: 1

     guess: `none' which will cause `neumann' and `firstkindseries' to
     use `<f>(<x>)' as an initial guess.


 -- Option variable: ieqnprint
     Default value: `true'

     `ieqnprint' governs the behavior of the result returned by the
     `ieqn' command. When `ieqnprint' is `false', the lists returned by
     the `ieqn' function are of the form

     [<solution>, <technique used>, <nterms>, <flag>]

     where <flag> is absent if the solution is exact.

     Otherwise, it is the word `approximate' or `incomplete'
     corresponding to an inexact or non-closed form solution,
     respectively. If a series method was used, <nterms> gives the
     number of terms taken (which could be less than the n given to
     `ieqn' if an error prevented generation of further terms).


 -- Function: lhs (<expr>)
     Returns the left-hand side (that is, the first argument) of the
     expression <expr>, when the operator of <expr> is one of the
     relational operators `< <= = # equal notequal >= >', one of the
     assignment operators `:= ::= : ::', or a user-defined binary infix
     operator, as declared by `infix'.

     When <expr> is an atom or its operator is something other than the
     ones listed above, `lhs' returns <expr>.

     See also `rhs'.

     Examples:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
                 lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Function: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Solves the list of simultaneous linear equations for the list of
     variables.  The expressions must each be polynomials in the
     variables and may be equations.

     When `globalsolve' is `true', each solved-for variable is bound to
     its value in the solution of the equations.

     When `backsubst' is `false', `linsolve' does not carry out back
     substitution after the equations have been triangularized.  This
     may be necessary in very big problems where back substitution
     would cause the generation of extremely large expressions.

     When `linsolve_params' is `true', `linsolve' also generates the
     `%r' symbols used to represent arbitrary parameters described in
     the manual under `algsys'.  Otherwise, `linsolve' solves an
     under-determined system of equations with some variables expressed
     in terms of others.

     When `programmode' is `false', `linsolve' displays the solution
     with intermediate expression (`%t') labels, and returns the list
     of labels.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Option variable: linsolvewarn
     Default value: `true'

     When `linsolvewarn' is `true', `linsolve' prints a message
     "Dependent equations eliminated".


 -- Option variable: linsolve_params
     Default value: `true'

     When `linsolve_params' is `true', `linsolve' also generates the
     `%r' symbols used to represent arbitrary parameters described in
     the manual under `algsys'.  Otherwise, `linsolve' solves an
     under-determined system of equations with some variables expressed
     in terms of others.


 -- System variable: multiplicities
     Default value: `not_set_yet'

     `multiplicities' is set to a list of the multiplicities of the
     individual solutions returned by `solve' or `realroots'.


 -- Function: nroots (<p>, <low>, <high>)
     Returns the number of real roots of the real univariate polynomial
     <p> in the half-open interval `(<low>, <high>]'.  The endpoints of
     the interval may be `minf' or `inf'.  infinity and plus infinity.

     `nroots' uses the method of Sturm sequences.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Function: nthroot (<p>, <n>)
     where p is a polynomial with integer coefficients and n is a
     positive integer returns q, a polynomial over the integers, such
     that q^n=p or prints an error message indicating that p is not a
     perfect nth power. This routine is much faster than `factor' or
     even `sqfr'.


 -- Option variable: programmode
     Default value: `true'

     When `programmode' is `true', `solve', `realroots', `allroots',
     and `linsolve' return solutions as elements in a list.  (Except
     when `backsubst' is set to `false', in which case `programmode:
     false' is assumed.)

     When `programmode' is `false', `solve', etc.  create intermediate
     expression labels `%t1', `t2', etc., and assign the solutions to
     them.


 -- Option variable: realonly
     Default value: `false'

     When `realonly' is `true', `algsys' returns only those solutions
     which are free of `%i'.


 -- Function: realroots (<expr>, <bound>)
 -- Function: realroots (<eqn>, <bound>)
 -- Function: realroots (<expr>)
 -- Function: realroots (<eqn>)
     Computes rational approximations of the real roots of the
     polynomial <expr> or polynomial equation <eqn> of one variable, to
     within a tolerance of <bound>.  Coefficients of <expr> or <eqn>
     must be literal numbers; symbol constants such as `%pi' are
     rejected.

     `realroots' assigns the multiplicities of the roots it finds to
     the global variable `multiplicities'.

     `realroots' constructs a Sturm sequence to bracket each root, and
     then applies bisection to refine the approximations.  All
     coefficients are converted to rational equivalents before
     searching for roots, and computations are carried out by exact
     rational arithmetic.  Even if some coefficients are floating-point
     numbers, the results are rational (unless coerced to floats by the
     `float' or `numer' flags).

     When <bound> is less than 1, all integer roots are found exactly.
     When <bound> is unspecified, it is assumed equal to the global
     variable `rootsepsilon'.

     When the global variable `programmode' is `true', `realroots'
     returns a list of the form `[x = <x_1>, x = <x_2>, ...]'.  When
     `programmode' is `false', `realroots' creates intermediate
     expression labels `%t1', `%t2', ..., assigns the results to them,
     and returns the list of labels.

     Examples:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]


 -- Function: rhs (<expr>)
     Returns the right-hand side (that is, the second argument) of the
     expression <expr>, when the operator of <expr> is one of the
     relational operators `< <= = # equal notequal >= >', one of the
     assignment operators `:= ::= : ::', or a user-defined binary infix
     operator, as declared by `infix'.

     When <expr> is an atom or its operator is something other than the
     ones listed above, `rhs' returns 0.

     See also `lhs'.

     Examples:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
                 rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Option variable: rootsconmode
     Default value: `true'

     `rootsconmode' governs the behavior of the `rootscontract'
     command.  See `rootscontract' for details.


 -- Function: rootscontract (<expr>)
     Converts products of roots into roots of products.  For example,
     `rootscontract (sqrt(x)*y^(3/2))' yields `sqrt(x*y^3)'.

     When `radexpand' is `true' and `domain' is `real', `rootscontract'
     converts `abs' into `sqrt', e.g., `rootscontract (abs(x)*sqrt(y))'
     yields `sqrt(x^2*y)'.

     There is an option `rootsconmode' affecting `rootscontract' as
     follows:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     When `rootsconmode' is `false', `rootscontract' contracts only
     with respect to rational number exponents whose denominators are
     the same.  The key to the `rootsconmode: true' examples is simply
     that 2 divides into 4 but not into 3.  `rootsconmode: all'
     involves taking the least common multiple of the denominators of
     the exponents.

     `rootscontract' uses `ratsimp' in a manner similar to
     `logcontract'.

     Examples:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
          (%o13)                          0


 -- Option variable: rootsepsilon
     Default value: 1.0e-7

     `rootsepsilon' is the tolerance which establishes the confidence
     interval for the roots found by the `realroots' function.


 -- Function: solve (<expr>, <x>)
 -- Function: solve (<expr>)
 -- Function: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Solves the algebraic equation <expr> for the variable <x> and
     returns a list of solution equations in <x>.  If <expr> is not an
     equation, the equation `<expr> = 0' is assumed in its place.  <x>
     may be a function (e.g. `f(x)'), or other non-atomic expression
     except a sum or product. <x> may be omitted if <expr> contains
     only one variable.  <expr> may be a rational expression, and may
     contain trigonometric functions, exponentials, etc.

     The following method is used:

     Let <E> be the expression and <X> be the variable.  If <E> is
     linear in <X> then it is trivially solved for <X>.  Otherwise if
     <E> is of the form `A*X^N + B' then the result is `(-B/A)^1/N)'
     times the `N''th roots of unity.

     If <E> is not linear in <X> then the gcd of the exponents of <X>
     in <E> (say <N>) is divided into the exponents and the
     multiplicity of the roots is multiplied by <N>.  Then `solve' is
     called again on the result.  If <E> factors then `solve' is called
     on each of the factors.  Finally `solve' will use the quadratic,
     cubic, or quartic formulas where necessary.

     In the case where <E> is a polynomial in some function of the
     variable to be solved for, say `F(X)', then it is first solved for
     `F(X)' (call the result <C>), then the equation `F(X)=C' can be
     solved for <X> provided the inverse of the function <F> is known.

     `breakup' if `false' will cause `solve' to express the solutions of
     cubic or quartic equations as single expressions rather than as
     made up of several common subexpressions which is the default.

     `multiplicities' - will be set to a list of the multiplicities of
     the individual solutions returned by `solve', `realroots', or
     `allroots'.  Try `apropos (solve)' for the switches which affect
     `solve'.  `describe' may then by used on the individual switch
     names if their purpose is not clear.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' solves a
     system of simultaneous (linear or non-linear) polynomial equations
     by calling `linsolve' or `algsys' and returns a list of the
     solution lists in the variables.  In the case of `linsolve' this
     list would contain a single list of solutions.  It takes two lists
     as arguments.  The first list represents the equations to be
     solved; the second list is a list of the unknowns to be
     determined.  If the total number of variables in the equations is
     equal to the number of equations, the second argument-list may be
     omitted.  For linear systems if the given equations are not
     compatible, the message `inconsistent' will be displayed (see the
     `solve_inconsistent_error' switch); if no unique solution exists,
     then `singular' will be displayed.

     When `programmode' is `false', `solve' displays solutions with
     intermediate expression (`%t') labels, and returns the list of
     labels.

     When `globalsolve' is `true' and the problem is to solve two or
     more linear equations, each solved-for variable is bound to its
     value in the solution of the equations.

     Examples:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Option variable: solvedecomposes
     Default value: `true'

     When `solvedecomposes' is `true', `solve' calls `polydecomp' if
     asked to solve polynomials.


 -- Option variable: solveexplicit
     Default value: `false'

     When `solveexplicit' is `true', inhibits `solve' from returning
     implicit solutions, that is, solutions of the form `F(x) = 0'
     where `F' is some function.


 -- Option variable: solvefactors
     Default value: `true'

     When `solvefactors' is `false', `solve' does not try to factor the
     expression.  The `false' setting may be desired in some cases
     where factoring is not necessary.


 -- Option variable: solvenullwarn
     Default value: `true'

     When `solvenullwarn' is `true', `solve' prints a warning message
     if called with either a null equation list or a null variable list.
     For example, `solve ([], [])' would print two warning messages and
     return `[]'.


 -- Option variable: solveradcan
     Default value: `false'

     When `solveradcan' is `true', `solve' calls `radcan' which makes
     `solve' slower but will allow certain problems containing
     exponentials and logarithms to be solved.


 -- Option variable: solvetrigwarn
     Default value: `true'

     When `solvetrigwarn' is `true', `solve' may print a message saying
     that it is using inverse trigonometric functions to solve the
     equation, and thereby losing solutions.


 -- Option variable: solve_inconsistent_error
     Default value: `true'

     When `solve_inconsistent_error' is `true', `solve' and `linsolve'
     give an error if the equations to be solved are inconsistent.

     If `false', `solve' and `linsolve' return an empty list `[]' if
     the equations are inconsistent.

     Example:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equations:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Differential Equations,  Next: Numerical,  Prev: Equations,  Up: Top

22 Differential Equations
*************************

* Menu:

* Introduction to Differential Equations::
* Functions and Variables for Differential Equations::


File: maxima.info,  Node: Introduction to Differential Equations,  Next: Functions and Variables for Differential Equations,  Prev: Differential Equations,  Up: Differential Equations

22.1 Introduction to Differential Equations
===========================================

This section describes the functions available in Maxima to obtain
analytic solutions for some specific types of first and second-order
equations. To obtain a numerical solution for a system of differential
equations, see the additional package `dynamics'. For graphical
representations in phase space, see the additional package `plotdf'.

