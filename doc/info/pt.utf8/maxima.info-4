This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para Regras e Modelos,  Prev: Introdução a Regras e Modelos,  Up: Regras e Modelos

38.2 Definições para Regras e Modelos
=====================================

 -- Função: apply1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> a <expr> até que isso falhe, então
     repetidamente aplica a mesma regra a todas as subexpressões de
     <expr>, da esquerda para a direita, até que <rule_1> tenha falhado
     sobre todas as subexpressões.  Chama o resultado da transformação
     de <expr> dessa maneira de <expr_2>.  Então <rule_2> é aplicada no
     mesmo estilo iniciando no topo de <expr_2>.  Quando <rule_n>
     falhar na subexpressão final, o resultado é retornado.

     `maxapplydepth' é a intensidade de nível mais distante de
     subexpressões processadas por `apply1' e `apply2'.

     Veja também `applyb1', `apply2', e `let'.


 -- Função: apply2 (<expr>, <rule_1>, ..., <rule_n>)
     Se <rule_1> falhar sobre uma dada subexpressão, então <rule_2> é
     repetidamente aplicada, etc.  Somente se todas as regras falharem
     sobre uma dada subexpressão é que o conjunto completo de regras é
     repetidamente aplicada à próxima subexpressão.  Se uma das regras
     obtém sucesso, então a mesma subexpressão é reprocessada,
     iniciando com a primeira regra.

     `maxapplydepth' é a intensidade do nível mais distante de
     subexpressões processadas através de `apply1' e `apply2'.

     Veja também `apply1' e `let'.


 -- Função: applyb1 (<expr>, <rule_1>, ..., <rule_n>)
     Repetidamente aplica <rule_1> para a subexpressão mais distante de
     <expr> até falhar, então repetidamente aplica a mesma regra um
     nível mais acima (i.e., subexpressãos mais larga), até que
     <rule_1> tenha falhado sobre a expressão de nível mais alto.
     Então <rule_2> é aplicada com o mesmo estilo para o resultado de
     <rule_1>.  após <rule_n> ter sido aplicada à expressão de nível
     mais elevado, o resultado é retornado.

     `applyb1' é similar a `apply1' mas trabalha da base para cima em
     lugar de do topo para baixo.

     `maxapplyheight' é o ápice que `applyb1' encontra antes de
     interromper.

     Veja também `apply1', `apply2', e `let'.


 -- Variável de opção: current_let_rule_package
     Valor padrão: `default_let_rule_package'

     `current_let_rule_package' é o nome do pacote de regras que está
     sendo usado por funções no pacote `let' (`letsimp', etc.) se
     nenhum outro pacote de regras for especificado.  A essa variável
     pode ser atribuído o nome de qualquer pacote de regras definido
     via comando `let'.

     Se uma chamada tal como `letsimp (expr, nome_pct_regras)' for
     feita, o pacote de regras `nome_pct_regras' é usado para aquela
     chamada de função somente, e o valor de `current_let_rule_package'
     não é alterado.


 -- Variável de opção: default_let_rule_package
     Valor padrão: `default_let_rule_package'

     `default_let_rule_package' é o nome do pacote de regras usado
     quando um não for explicitamente escolhido pelo usuário com `let'
     ou através de alteração do valor de `current_let_rule_package'.


 -- Função: defmatch (<prognome>, <modelo>, <x_1>, ..., <x_n>)
     Cria uma função `<prognome> (<expr>, <y_1>, ..., <y_n>)' que testa
     <expr> para ver se essa expressão coincide com <modelo>.

     <modelo> é uma expresão contendo as variáveis de modelo <x_1>,
     ..., <x_n> e parâmetros de modelo, se quaisquer.  As variáveis de
     modelo são dadas explicitamente como argumentos para `defmatch'
     enquanto os parâmetros de modelo são declarados através da função
     `matchdeclare'.

     O primeiro argumento para a função criada <prognome> é uma
     expressão a ser comparada contra o modelo e os outros argumentos
     são as variáveis atuais <y_1>, ..., <y_n> ne expressão que
     corresponde às variáveis correspondentes <x_1>, ..., <x_n> no
     modelo.

     Se a tentativa de coincidência obtiver sucesso, <progname> retorna
     uma lista de equações cujos lados esquerdos são as variáveis de
     modelo e os parâmetros de modelo, e cujos lados direitos são
     expressões cujas variáveis de modelo e modelos coincidirão.  Os
     parâmetros de modelo, mas não as variáveis de modelo, são
     atribuídos às subexpressões que elas coincidem.  Se a coincidência
     falhar, <prognome> retorna `false'.

     Quaisquer variáveis não declaradas como parâmetros de modelo em
     `matchdeclare' ou como variáveis em `defmatch' coincidem somente
     consigo mesmas.

     Um modelo que não contiver nenhuma variável de modelo ou parâmetros
     retorna `true' se a coincidência ocorre.

     Veja também `matchdeclare', `defrule', `tellsimp', e
     `tellsimpafter'.

     Exemplos:

     Esse `defmatch' define a função `linearp (expr, y)', que testa
     `expr' para ver se essa expressão é da forma `a*y + b' tal que `a'
     e `b' não contenham `y'.

          (%i1) matchdeclare (a, freeof(x), b, freeof(x))$
          (%i2) defmatch (linearp, a*x + b, x)$
          (%i3) linearp (3*z + (y+1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y

     Se o terceiro argumento para `defmatch' na linha (%i2) tiver sido
     omitido, então `linear' pode somente coincidir com expressões
     lineares em <x>, não em qualquer outra variável.

          (%i1) matchdeclare ([a, f], true)$
          (%i2) constinterval (l, h) := constantp (h - l)$
          (%i3) matchdeclare (b, constinterval (a))$
          (%i4) matchdeclare (x, atom)$
          (%i5) (remove (integrate, outative),
                    defmatch (checklimits, 'integrate (f, x, a, b)),
                    declare (integrate, outative))$
          (%i6) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o6)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i7) checklimits (%);
          (%o7)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]
          (%i8) a;
          (%o8)                        x + %pi
          (%i9) b;
          (%o9)                       x + 2 %pi
          (%i10) f;
          (%o10)                       sin(t)
          (%i11) x;
          (%o11)                          t


 -- Função: defrule (<nomeregra>, <modelo>, <substituição>)
     Define e nomeia uma regra de substituição para o modelo dado.  Se
     a regra nomeada <nomeregra> for aplicada a uma expressão (através
     de `apply1', `applyb1', ou `apply2'), toda subexpressão
     coincidindo com o modelo irá ser substituída por `substituição'.
     Todas as variáveis em `substituição' que tiverem sido atribuidos
     valores pela coincidência com o modelo são atribuidas esses
     valores na `substituição' que é então simplificado.

     As regras por si mesmas podem ser tratadas como funções que
     transforma uma expressão através de uma operação de coincidência
     de modelo e substituição.  Se a coincidência falhar, a expressão
     original é retornada.


 -- Função: disprule (<nomeregra_1>, ..., <nomeregra_2>)
 -- Função: disprule (all)
     Mostra regras com os nomes <nomeregra_1>, ..., <nomeregra_n>, como
     retornado por `defrule', `tellsimp', ou `tellsimpafter', ou um
     modelo definido por meio de `defmatch'.

     Cada regra é mostrada com um rótulo de expressão intermediária
     (`%t').

     `disprule (all)' mostra todas as regras.

     `disprule' não avalia seus argumentos.

     `disprule' retorna a lista de rótulos de expressões intermedáirias
     correspondendo às regras mostradas.

     Veja também `letrules', que mostra regras definidas através de
     `let'.

     Examples:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
          +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]


 -- Função: let (<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>)
 -- Função: let ([<prod>, <repl>, <prednome>, <arg_1>, ..., <arg_n>],
          <nome_pacote>)
     Define uma regra de substituição para `letsimp' tal que <prod> é
     substituído por <repl>.  <prod> é um produto de expoentes
     positivos ou negativos dos seguintes termos:

        * Atomos que `letsimp' irá procurar literalmente a menos que
          previamente chamando `letsimp' a função `matchdeclare' é
          usada para associar um predicado com o átomo.  Nesse caso
          `letsimp' irá coincidir com o átomo para qualquer termo de um
          produto satisfazendo o predicado.

        * Núcleos tais como `sin(x)', `n!', `f(x,y)', etc.  Como com
          átomos acima `letsimp' irá olhar um literal coincidente a
          menos que `matchdeclare' seja usada para associar um
          predicado com o argumento do núcleo.

     Um termo para um expoente positivo irá somente coincidir com um
     termo tendo ao menos aquele expoente.  Um termo para um expoente
     negativo por outro lado irá somente coincidir com um termo com um
     expoente ao menos já negativo.  o caso de expentes negativos em
     <prod> o comutador `letrat' deve ser escolhido para `true'.  Veja
     também `letrat'.

     Se um predicado for incluído na função `let' seguido por uma lista
     de argumentos, uma tentativa de coincidência (i.e. uma que pode
     ser aceita se o predicado fosse omitido) é aceita somente se
     `prednome (arg_1', ..., arg_n')' avaliar para `true' onde <arg_i'>
     é o valor coincidente com <arg_i>.  O <arg_i> pode ser o nome de
     qualquer átomo ou o argumento de qualquer núcleo aparecendo em
     <prod>.  <repl> pode ser qualquer expressão racional. Se quaisquer
     dos átomos ou argumentos de <prod> aparecer em <repl> a
     substituição é feita.  O sinalizador global `letrat' controla a
     simplificação dos quocientes através de `letsimp'.  Quando
     `letrat' for `false', `letsimp' simplifica o numerador e o
     denominador de <expr> separadamente, e não simplifica o quociente.
     Substituições tais como `n!/n' vão para `(n-1)!' então falham
     quando `letrat' for `false'.  Quando `letrat' for `true', então o
     numerador, o denominador, e o quociente são simplificados nessa
     ordem.

     Essas funções de substituição permitem a você trabalhar com muitos
     pacotes de regras.  Cada pacote de regras pode conter qualquer
     número de regras `let' e é referenciado através de um nome
     definido pelo usuário.  `let ([<prod>, <repl>, <prednome>,
     <arg_1>, ..., <arg_n>], <nome_pacote>)' adiciona a regra
     <prednome> ao pacote de regras <nome_pacote>.  `letsimp (<expr>,
     <nome_pacote>)' aplica as regras em <nome_pacote>.  `letsimp
     (<expr>, <nome_pacote1>, <nome_pacote2>, ...)' é equivalente a
     `letsimp (<expr>, <nome_pacote1>)' seguido por `letsimp (%,
     <nome_pacote2>)', ....

     `current_let_rule_package' é o nome do pacote de regras que está
     atualmente sendo usando.  Essa variável pode receber o nome de
     qualquer pacote de regras definidos via o comando `let'.  Quando
     qualquer das funções compreendidas no pacote `let' são chamadas
     sem o nome do pacote, o pacote nomeado por
     `current_let_rule_package' é usado.  Se uma chamada tal como
     `letsimp (<expr>, <nome_pct_regras>)' é feita, o pacote de regras
     <nome_pct_regras> é usado somente para aquele comando `letsimp', e
     `current_let_rule_package' não é alterada.  Se não especificado de
     outra forma, `current_let_rule_package' avalia de forma
     padronizada para `default_let_rule_package'.

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1


 -- Variável de opção: letrat
     Valor padrão: `false'

     Quando `letrat' for `false', `letsimp' simplifica o numerador e o
     denominador de uma razão separadamente, e não simplifica o
     quociente.

     Quando `letrat' for `true', o numerador, o denominador, e seu
     quocienten são simplificados nessa ordem.

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!


 -- Função: letrules ()
 -- Função: letrules (<nome_pacote>)
     Mostra as regras em um pacote de regras.  `letrules ()' mostra as
     regras no pacote de regras corrente.  `letrules (<nome_pacote>)'
     mostra as regras em `nome_pacote'.

     O pacote de regras corrente é nomeado por
     `current_let_rule_package'.  Se não especificado de outra forma,
     `current_let_rule_package' avalia de forma padrão para
     `default_let_rule_package'.

     Veja também `disprule', que mostra regras defindas por `tellsimp'
     e `tellsimpafter'.


 -- Função: letsimp (<expr>)
 -- Função: letsimp (<expr>, <nome_pacote>)
 -- Função: letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)
     Repetidamente aplica a substituição definida por `let' até que
     nenhuma mudança adicional seja feita para <expr>.

     `letsimp (<expr>)' usa as regras de `current_let_rule_package'.

     `letsimp (<expr>, <nome_pacote>)' usa as regras de <nome_pacote>
     sem alterar `current_let_rule_package'.

     `letsimp (<expr>, <nome_pacote_1>, ..., <nome_pacote_n>)' é
     equivalente a `letsimp (<expr>, <nome_pacote_1>', seguido por
     `letsimp (%, <nome_pacote_2>)', e assim sucessivamente.


 -- Variável de opção: let_rule_packages
     Valor padrão: `[default_let_rule_package]'

     `let_rule_packages' é uma lista de todos os pacotes de regras
     `let' definidos pelo usuário mais o pacote padrão
     `default_let_rule_package'.


 -- Função: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)
     Associa um predicado <pred_k> com uma variável ou lista de
     variáveis <a_k> de forma que <a_k> coincida com expressões para as
     quais o predicado retorne qualquer coisa que não `false'.

     O predicado é o nome de uma função, uma chamada de função omitindo
     o último argumento, ou `true' ou `all'.  Qualquer expressão
     coincide com `true' ou `all'.  Se o predicado for especificado
     como uma chamada de função, a expressão a ser testada é anexada ao
     final da lista de argumentos; os argumentos são avaliados ao mesmo
     tempo que a coincidência é avaliada.  De outra forma, o predicado
     é especificado como um nome de função, e a expressão a ser testada
     é o argumento sozinho.  Uma função predicado não precisa ser
     definida quando `matchdeclare' for chamada; o predicado não é
     avaliado até que uma coincidência seja tentada.

     Um predicado `matchdeclare' não pode ser qualquer tipo de
     expressão outra que não um nome de função ou chamada de função.
     Em particular, um predicado não pode ser um `lambda' ou `block'.

     Se uma expressão satisfaz uma coincidência de predicado, a
     variável de coincidência é atribuída à expressão, exceto para
     variáveis de coincidência que são operandos de adição `+' ou
     multiplicação `*'.  Somente adição e multiplicação são manuseadas
     de forma especial; outros operadores enários (ambos os definidos
     internamente e os definidos pelo usuário) são tratados como
     funções comuns.

     No caso de adição e multiplicação, a variável de coincidência pode
     ser atribuida a uma expressão simples que satisfaz o predicado de
     coincidência, ou uma adição ou um produto (respectivamente) de
     tais expressões.  Tal coincidência de termo multiplo é gulosa:
     predicados são avaliados na ordem em que suas variáveis associadas
     aparecem no modelo de coincidência, e o termo que satisfizer mais
     que um predicado é tomado pelo primeiro predicado que satisfizer.
     Cada predicado é testado contra todos os operandos de adição ou
     produto antes que o próximo predicado seja avaliado.
     Adicionalmente, se 0 ou 1 (respectivamente) satisfazem um
     predicado de coincidência, e não existe outros termos que
     satisfaçam o predicado, 0 ou 1 é atribuído para a variável de
     coincidência associada com o predicado.

     O algorítmo para processar modelos contendo adição e multiplicação
     faz alguns resultados de coincidência (por exemplo, um modelo no
     qual uma variável "coincida com qualquer coisa" aparecer)
     dependerem da ordem dos termos no modelo de coincidência e na
     expressão a ser testada a coincidência.  Todavia, se todos os
     predicados de coincidência são mutuamente exclusivos, o resultado
     de coincidência é insensível a ordenação, como um predicado de
     coincidência não pode aceitar termos de coincidência de outro.

     Chamado `matchdeclare' com uma variável <a> como um argumento muda
     a propriedade `matchdeclare' para <a>, se a variável <a> tiver
     sido declarada anteriormente; somente o `matchdeclare' mais
     recente está em efeito quando uma regra é definida, mudanças
     posteriores para a propriedade `matchdeclare' (via `matchdeclare'
     ou `remove') não afetam regras existentes.

     `propvars (matchdeclare)' retorna a lista de todas as variáveis
     para as quais exista uma propriedade `matchdeclare'.  `printprops
     (<a>, matchdeclare)' retorna o predicado para a variável `a'.
     `printprops (all, matchdeclare)' retorna a lista de predicados
     para todas as variáveis `matchdeclare'.  `remove (<a>,
     matchdeclare)' remove a propriedade `matchdeclare' da variável <a>.

     As funções `defmatch', `defrule', `tellsimp', `tellsimpafter', e
     `let' constroem regras que testam expressões contra modelos.

     `matchdeclare' coloca apóstrofo em seus argumentos.
     `matchdeclare' sempre retorna `done'.

     Exemplos:

        * `q' coincide com uma expressão que não contém `x' ou `%e'.

          (%i1) matchdeclare (q, freeof (x, %e))$


 -- Função: matchfix (<delimitador_e>, <delimitador_d>)
 -- Função: matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>,
          <pos>)
     Declara um operador `matchfix' com delimitadores esquerdo e
     direito <delimitador_e> and <delimitador_d>.  Os delimitadores são
     especificados como seqüêcias de caracteres.

     Um operador "matchfix" é uma função que aceita qualquer número de
     argumentos, tal que os argumentos ocorram entre os delimitadores
     correspondentes esquerdo e direito.  Os delimitadores podem ser
     quaisquer seqüêcias de caracteres, contanto que o analisador de
     expressões do Maxima possa distingüir os delimitadores dos
     operandos e de outras expressões e operadores.  Na prática essas
     regras excluem delimitadores não analisáveis tais como `%', `,',
     `$' e `;', e pode ser necessário isolar os delimitadores com
     espaços em branco.  O delimitador da direita pode ser o mesmo ou
     diferente do delimitador da esquerda.

     Um delimitador esquerdo pode ser associado com somente um
     delimitador direito; dois diferentes operadores `matchfix' não
     podem ter o mesmo delimitador esquerdo.

     Um operador existente pode ser redeclarado com um operador
     `matchfix' sem alterar suas outras propriedades.  Particularmente,
     operadores internos tais como adição `+' podem ser declarados
     `matchfix', mas funções operadores não podem ser definidas para
     operadores internos.

     `matchfix (<delimitador_e>, <delimitador_d>, <arg_pos>, <pos>)'
     declara o argumento <arg_pos> como sendo um entre: expressão
     lógica, expressão comum do Maxima mas que não seja do tipo
     anterior, e qualquer outro tipo de expressão que não esteja
     incluída nos dois primeiros tipos.  Essa declaração resulta em
     <pos> sendo um entre: expressão lógica, expressão comum do Maxima
     mas que não seja do tipo anterior, e qualquer outro tipo de
     expressão que não esteja incluída nos dois primeiros tipos e os
     delimitadores <delimitador_e> e <delimitador_d>.

     A função para realizar uma operação `matchfix' é uma função comum
     definida pelo usuário.  A função operador é definida da forma usual
     com o operador de definição de função `:=' ou `define'.  Os
     argumentos podem ser escritos entre os delimitadores, ou com o
     delimitador esquerdo com uma seqüência de caracteres com apóstrofo
     e os argumentos seguindo entre parêntesis.  `dispfun
     (<delimitador_e>)' mostra a definição da função operador.

     O único operador interno `matchfix' é o construtor de listas `[ ]'.
     Parêntesis `( )' e aspas duplas `" "' atuam como operadores
     `matchfix', mas não são tratados como tal pelo analisador do
     Maxima.

     `matchfix' avalia seus argumentos.  `matchfix' retorna seu
     primeiro argumento, <delimitador_e>.

     Exemplos:

        * Delimitadores podem ser quase quaisquer seqüência de
          caracteres.

          (%i1) matchfix ("@", "~");
          (%o1)                          "@"
          (%i2) @ a, b, c ~;
          (%o2)                       @a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                         ">>"
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                         "foo"
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                       @p, q~

        * Operadores `matchfix' são funções comuns definidas pelo
          usuário.

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15


 -- Função: remlet (<prod>, <nome>)
 -- Função: remlet ()
 -- Função: remlet (all)
 -- Função: remlet (all, <nome>)
     Apaga a regra de substituiçao, prod -> repl, mais recentemente
     definida através dea função `let'.  Se `nome' for fornecido a
     regra é apagada do pacote de regras chamado `nome'.

     `remlet()' e `remlet(all)' apagam todas as regras de substituição
     do pacote de regras corrente.  Se o nome de um pacote de regras
     for fornecido, e.g. `remlet (all, <nome>)', o pacote de regras
     <nome> é também apagado.

     Se uma substituição é para ser mudada usando o mesmo produto,
     `remlet' não precisa ser chamada, apenas redefina a substituição
     usando o mesmo produto (literalmente) com a função `let' e a nova
     substituição e/ou nome de predicado.  Pode agora `remlet (<prod>)'
     ser chamada e a regra de substituição original é ressuscitada.

     Veja também `remrule', que remove uma regra definida através de
     `tellsimp' ou de `tellsimpafter'.


 -- Função: remrule (<op>, <nomeregra>)
 -- Função: remrule (<op>, all)
     Remove regras definidas por `tellsimp', ou `tellsimpafter'.

     `remrule (<op>, <nomeregra>)' remove a regra com o nome
     `nomeregra' do operador <op>.  Quando <op> for um operador interno
     ou um operador definido pelo usuário (como definido por `infix',
     `prefix', etc.), <op> e <rulename> devem ser colocados entre aspas
     duplas.

     `remrule (<op>, all)' remove todas as regras para o operador <op>.

     Veja também `remlet', que remove uma regra definida através de
     `let'.

     Examples:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@");
          (%o3)                          @
          (%i4) tellsimp (aa @ bb, bb/aa);
          (%o4)                   [@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @ bb, quux (%pi, %e), quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", "+rule1");
          (%o9)                           +
          (%i10) remrule ("@", "@rule1");
          (%o10)                         @
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @ bb, quux (%pi, %e), quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @ bb, quux(%pi, %e),
                                                             quux(%e, %pi)]


 -- Função: tellsimp (<pattern>, <replacement>)
     é similar a `tellsimpafter' mas coloca nova informação antes da
     antiga de forma que essa nova regra seja aplicada antes das regras
     de simplificação internas.

     `tellsimp' é usada quando for importante modificar a expressão
     antes que o simplificador trabalhe sobre ela, por exemplo se o
     simplificador "sabe" alguma coisa sobre a expressão, mas o que ele
     retorna não é para sua apreciação.  Se o simplificador "sabe"
     alguma coisa sobre o principal operador da expressão, mas está
     simplesmente escondendo de você, você provavelmente quer usar
     `tellsimpafter'.

     O modelo pode não ser uma adição, um produto, variável simples, ou
     número.

     `rules' é a lista de regras definidas por `defrule', `defmatch',
     `tellsimp', e `tellsimpafter'.

     Exemplos:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)


 -- Função: tellsimpafter (<modelo>, <substituição>)
     Define a uma regra de simplificação que o simplificador do Maxima
     aplica após as regras de simplificação internas.  <modelo> é uma
     expressão, compreendendo variáveis de modelo (declaradas através
     de `matchdeclare') e outros átomos e operaçòes, considerados
     literais para o propósito de coincidência de modelos.
     <substituição> é substituída para uma expressão atual que coincide
     com <modelo>; variáveis de modelo em <substituição> são atribuidas
     a valores coincidentes na expressão atual.

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo; a regra de
     simplificação está associada com o operador principal.  Os nomes
     de funções (com uma excessão, descrita abaixo), listas, e arrays
     podem aparecer em <modelo> como o principal operador somente como
     literais (não variáveis de modelo); essas regras fornecem
     expressões tais como `aa(x)' e `bb[y]' como modelos, se `aa' e
     `bb' forem variáveis de modelo.  Nomes de funções, listas, e
     arrays que são variáveis de modelo podem aparecer como operadores
     outros que não o operador principal em <modelo>.

     Existe uma excessão para o que foi dito acima com relação a regras
     e nomes de funções.  O nome de uma função subscrita em uma
     expressão tal como `aa[x](y)' pode ser uma variável de modelo,
     porque o operador principal não é `aa' mas ao contrário o átomo
     Lisp `mqapply'.  Isso é uma conseqüência da representação de
     expressões envolvendo funções subscritas.

     Regras de simplificação são aplicadas após avaliação (se não
     suprimida através de colocação de apóstrofo ou do sinalizador
     `noeval').  Regras estabelecidas por `tellsimpafter' são aplicadas
     na ordem em que forem definidas, e após quaisquer regras internas.
     Regras são aplicadas de baixo para cima, isto é, aplicadas
     primeiro a subexpressões antes de ser aplicada à expressão
     completa.  Isso pode ser necessário para repetidamente simplificar
     um resultado (por exemplo, via o operador apóstrofo-apóstrofo `'''
     ou o sinalizador `infeval') para garantir que todas as regras são
     aplicadas.

     Variáveis de modelo são tratadas como variáveis locais em regras
     de simplificação.  Assim que uma regra é definida, o valor de uma
     variável de modelo não afeta a regra, e não é afetado pela regra.
     Uma atribuição para uma variável de modelo que resulta em uma
     coincidência de regra com sucesso não afeta a atribuição corrente
     (ou necessita disso) da variável de modelo.  Todavia, como com
     todos os átomos no Maxima, as propriedades de variáveis de modelo
     (como declarado por `put' e funções relacionadas) são globais.

     A regra construída por `tellsimpafter' é nomeada após o operador
     principal de `modelo'.  Regras para operadores internos, e
     operadores definidos pelo usuário definidos por meio de `infix',
     `prefix', `postfix', `matchfix', e `nofix', possuem nomes que são
     seqüências de caracteres do Maxima.  Regras para outras funções
     possuem nomes que são identificadores comuns do Maxima.

     O tratamento de substantivos e formas verbais é desprezívelmente
     confuso. Se uma regra é definida para uma forma substantiva (ou
     verbal) e uma regra para o verbo correspondente (ou substantivo)
     já existe, então a nova regra definida aplica-se a ambas as formas
     (substantiva e verbal).  Se uma regra para a correspondente forma
     verbal (ou substantiva) não existe, a nova regra definida
     aplicar-se-á somente para a forma substantiva (ou verbal).

     A regra construída através de `tellsimpafter' é uma função Lisp
     comum.  Se o nome da regra for `$foorule1', a construção `:lisp
     (trace $foorule1)' rastreia a função, e `:lisp (symbol-function
     '$foorule1' mostra sua definição.

     `tellsimpafter' não avalia seus argumentos.  `tellsimpafter'
     retorna a lista de regras para o operador principal de <modelo>,
     incluindo a mais recente regra estabelecia.

     Veja também `matchdeclare', `defmatch', `defrule', `tellsimp',
     `let', `kill', `remrule', e `clear_rules'.

     Exemplos:

     <modelo> pode ser qualquer expressão não atômica na qual o
     principal operador não é uma variável de modelo.

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     Regras são aplicadas na ordem em que forem definidas.  Se duas
     regras podem coincidir com uma expressão, a regra que foi primeiro
     definida é a que será aplicada.

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     variáveis de modelo são tratadas como variáveis locais em regras
     de simplificação.  (Compare a `defmatch', que trata variáveis de
     modelo como variáveis globais.)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     Como com todos os átomos, propriedades de variáveis de modelo são
     globais embora valores sejam locais.  Nesse exemplo, uma
     propriedade de atribuição é declarada via `define_variable'.  Essa
     é a propriedade do átomo `bb' através de todo o Maxima.

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     Regras são nomeadas após operadores principais.  Nomes de regras
     para operadores internos e operadores definidos pelo usuário são
     seqüências de caracteres, enquanto nomes para outras funções são
     identificadores comuns.

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [trigrule0, trigrule1, trigrule2, trigrule3, trigrule4,
          htrigrule1, htrigrule2, htrigrule3, htrigrule4, foorule1,
          foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) [?mstringp (foorule_name), symbolp (foorule_name)];
          (%o10)                    [false, true]
          (%i11) [?mstringp (plusrule_name), symbolp (plusrule_name)];
          (%o11)                    [true, true]
          (%i12) remrule (foo, foorule1);
          (%o12)                         foo
          (%i13) remrule ("^", "^rule1");
          (%o13)                          ^


 -- Função: clear_rules ()
     Executa `kill (rules)' e então re-escolhe o próximo número de
     regra para 1 para adição `+', multiplicação `*', e exponenciação
     `^'.



File: maxima.info,  Node: Listas,  Next: Conjuntos,  Prev: Regras e Modelos,  Up: Top

39 Listas
*********

* Menu:

* Introdução a Listas::
* Definições para Listas::


File: maxima.info,  Node: Introdução a Listas,  Next: Definições para Listas,  Prev: Listas,  Up: Listas

39.1 Introdução a Listas
========================

Listas são o bloco básico de construção para Maxima e Lisp.**Todos os
outros tipos de dado como arrays, tabelas desordenadas, números são
representados como listas Lisp.  Essas listas Lisp possuem a forma

     ((MPLUS) $A 2)

para indicar a expressão `a+2'.**No nível um do Maxima poderemos ver a
notação infixa `a+2'.**Maxima também tem listas que foram impressas como

     [1, 2, 7, x+y]

para uma lista com 4 elementos.**Internamente isso corresponde a uma
lista Lisp da forma

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

O sinalizador que denota o tipo campo de uma expressão Maxima é uma
lista em si mesmo, após ter sido adicionado o simplificador a lista
poderá transforma-se

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Definições para Listas,  Prev: Introdução a Listas,  Up: Listas

39.2 Definições para Listas
===========================

 -- Função: append (<list_1>, ..., <list_n>)
     Retorna uma lista simples dos elementos de <list_1> seguidos pelos
     elementos de <list_2>, ....  `append' também trabalha sobre
     expressões gerais, e.g. `append (f(a,b), f(c,d,e));' retorna
     `f(a,b,c,d,e)'.

     Faça `example(append);' para um exemplo.


 -- Função: assoc (<key>, <list>, <default>)
 -- Função: assoc (<key>, <list>)
     Essa função procura pela chave <key> do lado esquerdo da entrada
     <list> que é da forma `[x,y,z,...]' onde cada elemento de <list> é
     uma expressão de um operando binário e 2 elementos.  Por exemplo
     `x=1', `2^3', `[a,b]' etc.  A chave <key> é verificada contra o
     primeiro operando.  `assoc' retorna o segundo operando se `key'
     for achada.  Se a chave `key' não for achada isso retorna o valor
     padrão <default>.  <default> é opcional e o padrão é `false'.


 -- Função: atom (<expr>)
     Retorna `true' se <expr> for atomica (i.e. um número, nome ou
     seqüência de caracteres) de outra forma retorna `false'.  Desse
     modo `atom(5)' é `true' enquanto `atom(a[1])' e `atom(sin(x))' São
     `false' (assumindo `a[1]' e `x' não estão associados).


 -- Função: cons (<expr>, <list>)
     Retorna uma nova lista construída do elemento <expr> como seu
     primeiro elemento, seguido por elementos de <list>.  `cons' também
     trabalha sobre outras expressões, e.g. `cons(x, f(a,b,c));'  ->
     `f(x,a,b,c)'.


 -- Função: copylist (<list>)
     Retorna uma cópia da lista <list>.


 -- Função: create_list (<form>, <x_1>, <list_1>, ..., <x_n>, <list_n>)
     Cria uma lista por avaliação de <form> com <x_1> associando a cada
     elemento <list_1>, e para cada tal associação anexa <x_2> para
     cada elemento de <list_2>, ....  O número de elementos no
     resultado será o produto do número de elementos de cada lista.
     Cada variável <x_i> pode atualmente ser um síbolo -o qual não pode
     ser avaliado.  A lista de argumentos será avaliada uma única vez
     no início do bloco de repetição.

          (%i82) create_list1(x^i,i,[1,3,7]);
          (%o82) [x,x^3,x^7]

     Com um bloco de repetição duplo:

          (%i79) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o79) [[a,e],[a,f],[a,h],[b,e],[b,f],[b,h]]

     Em lugar de <list_i> dois argumentos podem ser fornecidos cada um
     dos quais será avaliado como um número.   Esses podem vir a ser
     inclusive o limite inferior e superior do bloco de repetição.

          (%i81) create_list([i,j],i,[1,2,3],j,1,i);
          (%o81) [[1,1],[2,1],[2,2],[3,1],[3,2],[3,3]]

     Note que os limites ou lista para a variável <j> podem depender do
     valor corrente de <i>.


 -- Função: delete (<expr_1>, <expr_2>)
 -- Função: delete (<expr_1>, <expr_2>, <n>)
     Remove todas as ocorrências de <expr_1> em <expr_2>. <expr_1> pode
     ser uma parcela de <expr_2> (se isso for uma adição) ou um fator
     de <expr_2> (se isso for um produto).

          (%i1) delete(sin(x), x+sin(x)+y);
          (%o1)                         y + x

     `delete(<expr_1>, <expr_2>, <n>)' remove as primeiras <n>
     ocorrências de <expr_1> em <expr_2>.  Se houver menos que <n>
     ocorrências de <expr_1> em <expr_2> então todas as corrências
     seram excluídas.

          (%i1) delete(a, f(a,b,c,d,a));
          (%o1)                      f(b, c, d)
          (%i2) delete(a, f(a,b,a,c,d,a), 2);
          (%o2)                     f(b, c, d, a)


 -- Função: eighth (<expr>)
     Retorna o oitavo item de uma expressão ou lista <expr>.  Veja
     `first' para maiores detalhes.


 -- Função: endcons (<expr>, <list>)
     Retorna uma nova lista consistindo de elementos de `list' seguidos
     por <expr>.  `endcons' também trabalha  sobre expressões gerais,
     e.g.  `endcons(x, f(a,b,c));'  ->  `f(a,b,c,x)'.


 -- Função: fifth (<expr>)
     Retorna o quinto item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: first (<expr>)
     Retorna a primeira parte de <expr> que pode resultar no primeiro
     elemento de uma lista, a primeira linha de uma matriz, a primeira
     parcela de uma adição, etc.  Note que `first' e suas funções
     relacionadas, `rest' e `last', trabalham sobre a forma de <expr>
     que é mostrada não da forma que é digitada na entrada.  Se a
     variável `inflag' é escolhida para `true' todavia, essa funções
     olharão  na forma interna de <expr>.  Note que o simplificador
     re-ordena expressões.  Desse modo `first(x+y)' será `x' se `inflag'
     for `true' e `y' se `inflag' for `false' (`first(y+x)' fornece os
     mesmos resultados).  As funções `second' .. `tenth' retornam da
     segunda até a décima parte do seu argumento.


 -- Função: fourth (<expr>)
     Retorna o quarto item da expressõ ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: get (<a>, <i>)
     Recupera a propriedade de usuário indicada por <i> associada com o
     átomo <a> ou retorna `false' se "a" não tem a propriedade <i>.

     `get' avalia seus argumentos.

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]


 -- Função: join (<l>, <m>)
     Cria uma nova lista contendo os elementos das lista <l> and <m>,
     intercaladas.  O resultado tem os elementos `[<l>[1], <m>[1],
     <l>[2], <m>[2], ...]'.  As listas <l> e <m> podem conter qualquer
     tipo de elementos.

     Se as listas forem de diferentes comprimentos, `join' ignora
     elementos da lista mais longa.

     Maxima reclama se <L_1> ou <L_2> não for uma lista.

     Exemplos:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]


 -- Função: last (<expr>)
     Retorna a última parte (parcela, linha, elemento, etc.) de <expr>.


 -- Função: length (<expr>)
     Retorna (por padrão) o número de partes na forma externa
     (mostrada) de <expr>.  Para listas isso é o número de elementos,
     para matrizes isso é o número de linhas, e para adições isso é o
     número de parcelas (veja `dispform').

     O comando `length' é afetado pelo comutador `inflag'.  Então, e.g.
     `length(a/(b*c));' retorna 2 se `inflag' for `false' (Assumindo
     `exptdispflag' sendo `true'), mas 3 se `inflag' for `true' (A
     representação interna é essencialmente `a*b^-1*c^-1').


 -- Variável de opção: listarith
     Valor padrão: `true' - se `false' faz com que quaisquer operações
     aritméticas com listas sejam suprimidas; quando `true', operações
     lista-matriz são contagiosas fazendo com que listas sejam
     convertidas para matrizes retornando um resultado que é sempre uma
     matriz.  Todavia, operações lista-lista podem retornar listas.


 -- Função: listp (<expr>)
     Retorna `true' se <expr> for uma lista de outra forma retorna
     `false'.


 -- Função: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- Função: makelist (<expr>, <x>, <list>)
     Constrói e retorna uma lista, cada elemento dessa lista é gerado
     usando <expr>.

     `makelist (<expr>, <i>, <i_0>, <i_1>)' retorna uma lista, o
     `j''ésimo elemento dessa lista é igual a `ev (<expr>, <i>=j)' para
     `j' variando de <i_0> até <i_1>.

     `makelist (<expr>, <x>, <list>)' retorna uma lista, o `j''ésimo
     elemento é igual a `ev (<expr>, <x>=<list>[j])' para `j' variando
     de 1 até `length (<list>)'.

     Exemplos:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]


 -- Função: member (<expr>, <list>)
     Retorna `true' se <expr> ocorre como um membro de <list> (não
     dentro de um membro).  De outra forma `false' é retornado.
     `member' também trabalha sobre expressões não-lista, e.g.
     `member(b,f(a,b,c));'  ->  `true'.


 -- Função: ninth (<expr>)
     Retorna o nono item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: rest (<expr>, <n>)
 -- Função: rest (<expr>)
     Retorna <expr> com seus primeiros <n> elementos removidos se <n>
     for positivo e seus últimos `- <n>' elementos removidos se <n> for
     negativo.  Se <n> for 1 isso pode ser omitido.  <expr> pode ser
     uma lista, matriz, ou outra expressão.


 -- Função: reverse (<list>)
     Ordem reversa para os membros de <list> (não os membros em si
     mesmos).  `reverse' também trabalha sobre expressões gerais, e.g.
     `reverse(a=b);' fornece `b=a'.


 -- Função: second (<expr>)
     Retorna o segundo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: seventh (<expr>)
     Retorna o sétimo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: sixth (<expr>)
     Retorna o sexto item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: tenth (<expr>)
     Retorna o décimo item da expressão ou lista <expr>.  Veja `first'
     para maiores detalhes.


 -- Função: third (<expr>)
     Retorna o terceiro item da expressão ou lista <expr>.  Veja
     `first' para maiores detalhes.



File: maxima.info,  Node: Conjuntos,  Next: Definição de Função,  Prev: Listas,  Up: Top

40 Conjuntos
************

* Menu:

* Introdução a Conjuntos::
* Definições para Conjuntos::


File: maxima.info,  Node: Introdução a Conjuntos,  Next: Definições para Conjuntos,  Prev: Conjuntos,  Up: Conjuntos

40.1 Introdução a Conjuntos
===========================

Maxima fornece funções de conjunto, tais como intersecção e união ,
para conjuntos finitos que são definidos através de enumeração
explícita.  Maxima trata listas e conjuntos como objetos distintos.
Esse recurso torna possível trabalhar com conjuntos que possuem
elementos que são ou listas ou conjuntos.

   Adicionalmente a funções para conjuntos finitos, Maxima fornece
algumas funções relacionadas à combinatória; essas incluem números de
Stirling, números de Bell, e muitas outras.

40.1.1 Uso
----------

Para construir um conjunto como elementos `a_1, ..., a_n', use o
comando `set(a_1, ..., a_n)'; para construir o conjunto vazio, use
`set()'.  Se um elemento for listado mais que uma vez, o processo de
simplificação elimina o número redundante.

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}

   Dois elementos <x> e <y> podem ser redundantes (i.e., considerados
iguais para propósito de construção de conjunto) se e somente se `is
(<x> = <y>)' retornar `true'.  Note que `is (equal (<x>, <y>))' pode
retornar `true' enquanto `is (<x> = <y>)' retorna `false'; se `is (<x>
= <y>)' retornar `true' os elementos <x> e <y> são considerados
distintos.

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) set (x, y, z);
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   Conjuntos são sempre mostrados na saída como uma lista delimitada
por chaves; Se você quiser que seja possível inserir um conjunto usando
chaves, veja *Note Definindo conjuntos com chaves::.

   Para construir um conjunto a partir dos elementos de uma lista, use
`setify'.

     (%i1) setify([b, a]);
     (%o1)                        {a, b}

   Membros de conjuntos `x' e `y' são iguais fazendo com que `is(x = y)'
avalie para `true'. Dessa forma `rat(x)' e `x' são iguais com conjuntos
membros; conseqüentemente,

     (%i1) set(x, rat(x));
     (%o1)                          {x}

   Adicionalmente, uma vez que `is((x-1)*(x+1) = x^2 - 1)' avalia para
`false', `(x-1)*(x+1)' e `x^2-1' são distintos membros de conjuntos;
dessa forma

     (%i1) set((x - 1)*(x + 1), x^2 - 1);
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   Para reduzir esses conjuntos a um único conjunto, aplique `rat' a
cada membro do conjunto:

     (%i1) set((x - 1)*(x + 1), x^2 - 1);
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map(rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   Para remover redundâncias de outros conjuntos, você pode precisar
usar outras funções de simplificação.  Aqui está um exemplo que usa
`trigsimp':

     (%i1) set(1, cos(x)^2 + sin(x)^2);
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map(trigsimp, %);
     (%o2)                          {1}

   Um conjunto é simplificado quando seus elementos não são redundantes
e ordenados. a versão atual das funções de conjunto usam a função Maxima
`orderlessp' para ordenar conjuntos; todavia, versões futuras das
funções de conjunto podem usar uma diferente função de ordenação.

   Algumas operações sobre conjuntos, tais como substituição de
elementos, forçam automaticamente uma re-simplificação; por exemplo,

     (%i1) s: set (a, b, c)$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maxima trata listas e conjuntos como objetos distintos; funções tais
como `union' e `intersection' sinalizarão um erro se qualquer argumento
for uma lista.  Se você precisar aplicar uma função de conjunto a uma
lista, use a função `setify' para coverter a lista para um conjunto.
Dessa forma

     (%i1) union ([1, 2], set (a, b));
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), set (a, b));
     (%o2)                     {1, 2, a, b}

   Para extrair todos os elementos de um conjunto `s' que atendem a uma
condição `f', use `subset(s,f)'. (Uma condição é uma função booleana
que avalia para verdadeiro ou falso.) Por exemplo, para achar as
equações em um dado conjunto que não depende de uma variável `z', use

     (%i1) subset (set (x + y + z, x - y + 4, x + y - 5), lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   A seção *Note Definições para Conjuntos:: tem uma lista completa das
funções de conjunto no Maxima.

40.1.2 Iteração entre Membros de Conjuntos
------------------------------------------

Existem dois caminhos para interagir sobre membros de conjuntos.  Um
caminho é usar `map'; por exemplo:

     (%i1) map (f, set (a, b, c));
     (%o1)                  {f(a), f(b), f(c)}

   O outro caminho é usar `for <x> in <s> do'

     (%i1) s: set (a, b, c);
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   As funções Maxima `first' e `rest' trabalham corretamente sobre
conjuntos.  Aplicada a um conjunto, `first' retorna o primeiro elemento
mostrado de um conjunto; elemento esse que pode ser dependente da
implementação. Se `s' for um conjunto, então `rest(s)' é equivalente a
`disjoin (first(s), s)'.  Atualmente, existe outras funções Maxima que
trabalham corretamente sobre conjuntos.  Em futuras versões de funções
de conjunto, `first' e `rest' podem funcionar diferentemente ou não
funcionar em algumas situações.

40.1.3 Falhas
-------------

As funções de conjunto usam a função Maxima `orderlessp' para ordenar
membros de conjuntos e a função ( a nível de Lisp) `like' para testar a
igualdade entre membros de conjuntos.  Ambas (`orderlessp' e `like')
possuem falhas conhecidas (versões 5.9.2 e seguintes) que podem se
manifestar se você tentar usar conjuntos com membros que são listas ou
matrizes que contenham expressões na forma CRE (expressão racional
canônica). Um exemplo é

     (%i1) set ([x], [rat (x)]);
     Maxima encountered a Lisp error:

      CAR: #:X13129 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Esse comando faz com que Maxima feche com um erro (a mensagem de erro
depende de qual versão de Lisp seu Maxima estiver utilizando). Outro
exemplo é

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

      CAR: #:A13129 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   Essas falhas são causadas por erros em `orderlessp' e `like'; elas
não são causadas através de falhas em funções de conjunto. Para
ilustrar, tente os comandos

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

      CAR: #:B13130 is not a LIST

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   Até essas falhas serem corrigidas, não construa conjuntos com
membros que sejam listas ou matrizes contendo expressões na forma de
expressão racional canônica; um conjunto com um membro na forma de
expressão racional canônica, todavia, pode não ser um problema:

     (%i1) set (x, rat (x));
     (%o1)                          {x}

   A função `orderlessp' do Maxima tem outra falha que pode trazer
problemas com funções de conjunto, a saber que o predicado de ordenação
`orderlessp' não é transitivo. O exemplo mais simples conhecido que
mostra isso é

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   Essa falha poderá causar problemas com todas as funções de conjunto
bem como com funções Maxima em geral. \'E possivel, mas não certoe, que
se todos membros de conjunto estiverem ou na forma de expressão
racional canônica ou tiverem sido simplificados usando `ratsimp', essa
falha não se manifeste.

   Os mecanismos `orderless' e `ordergreat' do Maxima são incompatíveis
com funções de conjuntos. Se você precisar usar ou `orderless' ou
`ordergreat', descarregue esses comandos antes de construir quaisquer
conjuntos e não use o comando `unorder'.

   Você pode encontrar duas outras falhas menores.  Na versão Maxima
5.5 e seguintes tinha uma falha na função `tex' que fazia o conjunto
vazio ser incorretamente traduzido para TeX; essa falha foi corrigida no
Maxima 5.9.0. Adicionalmente, a função `setup_autoload' no Maxima 5.9.0
não funciona adequadamente; uma correção está no arquivo
`nset-init.lisp' localizado no diretório `maxima/share/contrib/nset'.

   A função de sinal do Maxima tem uma falha que pode causar
comportamento inadequado na função de Kronecker; por exemplo:

     (%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
     (%o1)                           0

   O valor correto é 1; a falha é relatada para `sign'

     (%i1) sign (1/sqrt(2) - sqrt(2)/2);
     (%o1)                          pos

   Se você encontrar alguma coisa que você pense ser uma falha de
função de conjunto, por favor emita um relatório para a base de dados
de falhas do Maxima. Veja `bug_report'.

40.1.4 Definindo conjuntos com chaves
-------------------------------------

Se você quiser entrar conjuntos usando chaves, você pode fazer então
através de declaração para que a chave esquerda seja um operador
`matchfix'; isso é feito usando os comandos

     (%i1) matchfix("{","}")$
     (%i2) "{" ([a]) := apply (set, a)$

   Agora podemos definir conjuntos usando chaves; dessa forma

     (%i1) matchfix("{","}")$
     (%i2) "{" ([a]) := apply (set, a)$
     (%i3) {};
     (%o3)                          {}
     (%i4) {a, {a, b}};
     (%o4)                      {a, {a, b}}

   Para sempre permitir essa forma de entrada de conjunto, coloque os
dois comandos nas linhas (%i1) e (%i2) em seu arquivo `maxima-init.mac'.

40.1.5 Combinatória e Funções diversas
--------------------------------------

Adicionalmente para funções de conjuntos finitos, Maxima fornece algumas
funções relacionada a combinatória; essas incluem números de Stirling
de primeiro e de segundo tipo, os número de Bell, coeficientes
multinomiais, particionamento de inteiros não negativos, e umas poucas
outras.  Maxima também define uma função delta de Kronecker.

40.1.6 Autores
--------------

Stavros Macrakis de Cambridge, Massachusetts e Barton Willis da
Universidade de Nebraska e Kearney (UNK) escreveram as funções de
conjunto do Maxima e sua documentação.


File: maxima.info,  Node: Definições para Conjuntos,  Prev: Introdução a Conjuntos,  Up: Conjuntos

40.2 Definições para Conjuntos
==============================

 -- Função: adjoin (<x>, <a>)
     Anexa <x> ao conjunto <a> e retorna um conjunto. Dessa forma
     `adjoin(<x>, <a>)' e `union(set(x),a)' são equivalentes; todavia,
     usando `adjoin' pode ser algo mais rápido que usando `union'. Se
     <a> não for um conjunto, sinaliza um erro.

          (%i1) adjoin (c, set (a, b));
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, set (a, b));
          (%o2)                        {a, b}

     See also `disjoin'.

 -- Função: belln (<n>)
     Para inteiros não negativos <n>, retorna o n-ésimo número de Bell.
     Se `s' for um conjunto com `n' membros,  `belln(n)' é o número de
     partições de `s'.  Por exemplo:

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions (set ())) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions (set (1, 2, 3, 4, 5, 6))) = belln (6));
          (%o3)                         true

     Quando <n> não for um inteiro não negativo, `belln(n)' não
     simplifica.

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

     A função `belln' trabalha sobre igualdades, listas, matrizes, e
     conjuntos.

 -- Função: cardinality (<a>)
     Retorna o números de elementos distintos do conjunto <a>.

          (%i1) cardinality (set ());
          (%o1)                           0
          (%i2) cardinality (set (a, a, b, c));
          (%o2)                           3
          (%i3) cardinality (set (a, a, b, c)), simp: false;
          (%o3)                           3

     Na linha (%o3), vemos que `cardinality' trabalha correetamente
     mesmo quandoa simplificação tiver sido desabilitada.

 -- Função: cartesian_product (<b_1>, ... , <b_n>)
     Retorna um conjunto de listas da forma `[<x_1>, ..., <x_n>]', onde
     `<x_1> está em <b_1>', ..., `<x_n> in <b_n>'.  Sinaliza um erro
     quando qualquer <b_k> não for um conjunto.

          (%i1) cartesian_product (set (0, 1));
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product (set (0, 1), set (0, 1));
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product (set (x), set (y), set (z));
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product (set (x), set (-1, 0, 1));
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- Função: disjoin (<x>, <a>)
     Remove <x> do conjunto <a> e retorna um conjunto.  Se <x> não for
     um membro de <a>, retorna <a>. Cada um dos seguintes faz a mesma
     coisa: `disjoin(<x>, <a>)', `delete(<x>, <a>)', e
     `setdifference(<a>,set(<x>))'; todavia, `disjoin' é geralmente o
     caminho mais rápido para remover um membro de um conjunto.
     Sinaliza um erro se <a> não for um conjunto.

 -- Função: disjointp (<a>, <b>)
     Retorna `true' se os conjuntos <a> e <b> forem disjuntos. sinaliza
     um erro se ou <a> ou <b> não for um conjunto.

 -- Função: divisors (<n>)
     Quando <n> for um inteiro não nulo, retorna o conjunto de seus
     divisores.  O conjunto de divisores inclue os membros 1 e <n>.  Os
     divisores de um inteiro negativo são os divisores de seus valores
     absolutos.

     Podemos verificar que 28 é um número perfeito.

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     A função `divisors' trabalha através de simplificação; você pode
     não precisar re-avaliar manualmente apóes uma substituição. Por
     exemplo:

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     A função `divisors' trabalha sobre igualdades, listas, matrizes, e
     conjuntos. Aqui está um exemplo de trabalho sobre uma lista e uma
     igualdade.

          (%i1) divisors ([a, b, c=d]);
          (%o1) [divisors(a), divisors(b), divisors(c) = divisors(d)]

 -- Função: elementp (<x>, <a>)
     Retorna `true' se e somente se <x> for um membro do conjunto <a>.
     Sinaliza um erro se <a> não for um conjunto.

 -- Função: emptyp (<a>)
     Retorna `true' se e somente se <a> for um conjunto vazio ou a
     lista vazia.

          (%i1) map (emptyp, [set (), []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, set (set ()), %pi]);
          (%o2)                 [false, false, false]

 -- Função: equiv_classes (<s>, <f>)
     Retorna um conjunto de classes de equivalência de <s> com relação
     à relação de equivalência <f>. A função <f> pode ser uma função de
     valor booleano definida sobre o produto cartesiano de <s> com <s>.
     Adicionalmente, a função <f> pode ser uma relação de equivalência;
     `equiv_classes', todavia, não verifica se <f> é uma relação de
     equivalência.

          (%i1) equiv_classes (set (a, b, c), lambda ([x, y], is (x=y)));
          (%o1)                    {{a}, {b}, {c}}

     Atualmente, `equiv_classes (<s>, <f>)' aplica automaticamente a
     função do Maxima `is' após aplicar a função <f>; portanto, podemos
     reescrever o exemplo anterior mais resumidamente.

          (%i1) equiv_classes (set (a, b, c), "=");
          (%o1)                    {{a}, {b}, {c}}

     Aqui está outro exemplo.

          (%i1) equiv_classes (set (1, 2, 3, 4, 5, 6, 7), lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- Função: every (<f>, <a>)
 -- Função: every (<f>, <L_1>, ..., <L_n>)
     O primeiro argumento <f> pode ser um predicado (uma função que
     avalia para verdadeiro, falso, ou indeterminado).

     Fornecendo um conjunto como segundo argumento, `every (<f>, <a>)'
     retorna `true' se `<f>(<a_i>)' retornar `true' para todos <a_i> em
     <a>.  Uma vez que conjuntos são desordenados, `every' está livre
     para avaliar `<f>(<a_i>)' em qualquer ordem. `every' pode ou não
     avaliar <f> para todo <a_i> em <a>. Porque a ordem de avaliação
     não é especificada, o predicado <f> pode não ter efeito de lado ou
     erro de sinal para qualquer entrada.

     Fornecendo uma ou mais listas como argumentos, `every (<f>, <L_1>,
     ..., <L_n>)' retorna `true' se `<f>(<x_1>, ..., <x_n>)' retornar
     `true' para todos <x_1>, ..., <x_n> em <L_1>, ..., <L_n>,
     respectivamente.  `every' pode ou não avaliar <f> para toda
     conbinação <x_1>, ..., <x_n>.  Uma vez que listas são ordenadas,
     `every' avalia na ordem de incremento do índice.

     Para usar `every' sobre multiplos conjuntos argumentos, os
     conjuntos devem primeiro serem convertidos para uma seqüência
     ordenada de forma que seu alinhamento relativo comece bem definido.

     Se o sinalizador global `maperror' for `true' (o padrão), todas as
     listas <L_1>, ..., <L_n> devem ter comprimentos iguais - de outra
     forma, `every' sinalizará um erro.  Quando `maperror' for `false',
     os argumentos lista são efetivamente truncados para o comprimento
     da lista mais curta.

     A função Maxima `is' é automaticamente aplicada após a avaliação do
     predicado <f>.

          (%i1) every ("=", [a, b], [a, b]);
          (%o1)                         true
          (%i2) every ("#", [a, b], [a, b]);
          (%o2)                         false

 -- Função: extremal_subset (<s>, <f>, max)
 -- Função: extremal_subset (<s>, <f>, min)
     Quando o terceiro argumento for `max', retorna o subconjunto do
     conjunto ou a lista <s> para a qual a função real avaliada <f> toma
     sobre seu maior valor; quando o terceiro argumento for `min',
     retorna o subconjunto para o qual <f> toma sobre seu menor valor.

          (%i1) extremal_subset (set (-2, -1, 0, 1, 2), abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset (set (sqrt(2), 1.57, %pi/2), sin, min);
          (%o2)                       {sqrt(2)}

 -- Função: flatten (<e>)
     `flatten' essencialmente avalia uma expressão como se seu
     principal operador tivesse sido declarado n-ário; existe, todavia,
     uma diferença - `flatten' não não age recursivamente dentro de
     outros argumentos de função.  Por exemplo:

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     Aplicada a um conjunto, `flatten' reune todos os membros de
     elementos de conjuntos que são conjuntos; por exemplo:

          (%i1) flatten (set (a, set (b), set (set (c))));
          (%o1)                       {a, b, c}
          (%i2) flatten (set (a, set ([a], set (a))));
          (%o2)                       {a, [a]}

     `flatten' trabalha corretamente quando o operador principal for
     uma função subscrita

          (%i1) flatten (f[5] (f[5] (x)));
          (%o1)                         f (x)
                                         5

     Para aplicar `flatten' a uma expressão, o principal operador deve
     ser definido para zero ou mais argumentos;  se esse não for o
     caso, Maxima sairá com um erro.  Expressões com representações
     especiais, por exemplo expressões racionais canônicas, não podem
     ser tratadas por `flatten'; nesse caso, `flatten' retorna seu
     argumento inalterado.

 -- Função: full_listify (<a>)
     Se <a> for um conjunto, converte <a> para uma lista e aplica
     `full_listify' para cada elemento lista.

     Para converter apenas o operador de nível mais alto de um conjunto
     para uma lista, veja *Note listify::.

 -- Função: fullsetify (<a>)
     Se <a> for uma lista, converte <a> para um conjunto e aplica
     `fullsetify' para cada membro do conjunto.

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

     Na linha (%o2), o argumento de `f' não é convertido para um
     conjunto porque o principal operador de `f([b])' não é uma lista.

     Para converter apenas o operador de nível mais alto para um
     conjunto, veja *Note setify::.

 -- Função: identity (<x>)
     A função identidade avalia para seu argumento em todas as
     entradas.  Para determinar se todo membro de um conjunto é `true',
     você pode usar

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- Função: integer_partitions (<n>)
 -- Função: integer_partitions (<n>, <len>)
     Se o segundo argumento opcional <len> não for especificado,
     retorna o conjunto de todas as partições do inteiro <n>.  Quando
     <len> for especificado, retorna todas as partições de comprimento
     <len> ou menor; nesse caso, zeros são anexados a cada partição de
     comprimento menor que <len> termos para fazer com que cada
     partição tenha exatamente <len> termos.  No outro caso, cada
     partição é uma lista ordenada do maior para o menor.

     Dizemos que uma lista [a_1, ..., a_m] é uma partição de um inteiro
     não negativo n fazendo com que (1) cada a_i é um inteiro não nulo
     e (2) a_1 + ... + a_m  = n.  Dessa forma 0 não tem partições.

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     Para achar todas as partições que satisfazem uma condição, use a
     função `subset'; aqui está um exemplo que encontra todas as
     partições de 10 que consistem em números primos.

          (%i1) s: integer_partitions (10)$
          (%i2) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i3) subset (s, lambda ([x], every (xprimep, x)));
          (%o3) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

     (Note que `primep(1)' é verdadeiro em Maxima. Isso discorda de
     muitas definições de número primo.)

 -- Função: intersect (<a_1>, ..., <a_n>)
     Retorna um conjunto contendo os elementos que são comuns aos
     conjuntos de <a_1> até <a_n>. A função `intersect' deve receber um
     ou mais argumentos. Sinaliza um erro se qualquer dos <a_1> até
     <a_n> não for um conjunto.  Veja também *Note intersection::.

 -- Função: intersection (<a_1>, ..., <a_n>)
     Retorna um conjunto contendo os elementos que são comuns aos
     conjuntos de <a_1> até <a_n>. A função `intersection' must receive
     one or more arguments. Sinaliza um erro se quaisquer dos <a_1> até
     <a_n> não for um conjunto.  Veja também *Note intersect::.

 -- Função: kron_delta (<x>, <y>)
     A função delta de Kronecker; `kron_delta (<x>, <y>)' simplifica
     para 1 quando `is(x = y)' for verdadeiro e para zero quando `sign
     (|<x> - <y>|)' for `pos'.  Quando `sign (|<x> - <y>|)' for zero e
     `<x> - <y>' não for um número em ponto flutuante (nem do tipo
     `double' e nem do tipo `bfloat'), retorna 0. De outra forma,
     retorna uma forma substantiva.

     A função, `kron_delta' é declarada para ser simétrica; dessa
     forma, por exemplo, `kron_delta(x, y) - kron_delta(y, x)'
     simplifica para zero.

     Aqui alguns exemplos.

          (%i1) [kron_delta (a, a), kron_delta (a + 1, a)];
          (%o1)                        [1, 0]
          (%i2) kron_delta (a, b);
          (%o2)                   kron_delta(a, b)

     Assumindo que `a > b' faz `sign (|a - b|)' avaliar para `pos';
     dessa forma

          (%i1) assume (a > b)$
          (%i2) kron_delta (a, b);
          (%o2)                           0

     Se de outra maneira assumirmos que `x >= y', então `sign (|x -
     y|)' avalia para `pz'; nesse caso, `kron_delta (x, y)' não
     simplifica

          (%i1) assume(x >= y)$
          (%i2) kron_delta (x, y);
          (%o2)                   kron_delta(x, y)

     Finalmente, uma vez que `1/10 - 0.1' avalia para um número em ponto
     flutuante, teremos

          (%i1) kron_delta (1/10, 0.1);
                                            1
          (%o1)                  kron_delta(--, 0.1)
                                            10

     Se você quiser que `kron_delta (1/10, 0.1)' avalie para 1, aplique
     `float'.

          (%i1) float (kron_delta (1/10, 0.1));
          (%o1)                           1

 -- Função: listify (<a>)
     Se <a> for um conjunto, retorna uma lista contendo os membros de
     <a>; quando <a> não for um conjunto, retorna <a>.  Para converter
     um conjunto e todos os seus membros para listas, veja *Note
     full_listify::.


 -- Função: lreduce (<f>, <s>)
 -- Função: lreduce (<f>, <s>, <init>)
     A função `lreduce' (reduzir à esquerda) extende a função 2-aridade
     para uma n-aridade através de composição; um exemplo pode tornar
     isso mais claro. Quando o argumento opcional não for definido,
     teremos

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     Note que a função <f> é primeiro aplicada aos `leftmost' (mais à
     esquerda) elementos da lista (dessa forma o nome lreduce).  Quando
     <init> for definido, o segundo argumento para a avaliação de
     função mais interna é <init>; por exemplo:

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     A função `lreduce' torna isso fácil para encontrar o produto ou
     adição dos elementos de uma lista.

          (%i1) lreduce ("+", args (set (a, b)));
          (%o1)                         b + a
          (%i2) lreduce ("*", args (set (1, 2, 3, 4, 5)));
          (%o2)                          120

     Veja também *Note rreduce::, *Note xreduce::, e *Note
     tree_reduce::.

 -- Função: makeset (<e>, <v>, <s>)
     Essa função é similar a `makelist', mas `makeset' permite
     substituições multiplas. o primeiro argumento <e> é uma espressão;
     o segundo argumento <v> é uma lista de variáveis; e <s> é uma
     lista ou conjunto de valores para as variáveis <v>. Cada membro de
     <s> deve ter o mesmo comprimento que <v>. Temos `makeset (<e>,
     <v>, <s>)' é o conjunto `{z | z = substitute(v -> s_i) e s_i em
     s}'.

          (%i1) makeset (i/j, [i, j], [[a, b], [c, d]]);
                                        a  c
          (%o1)                        {-, -}
                                        b  d
          (%i2) ind: set (0, 1, 2, 3)$
          (%i3) makeset (i^2 + j^2 + k^2, [i, j, k], cartesian_product (ind, ind, ind));
          (%o3) {0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 17, 18,
                                                                19, 22, 27}

 -- Função: moebius (<n>)
     A função de Moebius; quando <n> for produto de k primos distintos,
     `moebius(<n>)' avalia para (-1)^k; isso avalia para 1 quando <n> =
     1; e isso avalia para 0 para todos os outros inteiros positivos.
     A função de Moebius trabalha sobre igualdades, listas, matrizes, e
     conjuntos.

 -- Função: multinomial_coeff (<a_1>, ..., <a_n>)
 -- Função: multinomial_coeff ()
     Retorna o coeficiente multinomial.  Quando cada <a_k> for um
     inteiro não negativo, o coeficiente multinomial fornece o número
     de caminhos de substituição `<a_1> + ... + <a_n>' objetos
     distintos dentro de n caixas com <a_k> elementos na k'ésima caixa.
     Em geral, `multinomial (<a_1>, ..., <a_n>)' avalia para `(<a_1> +
     ... + <a_n>)!/(<a_1>! ... <a_n>!)'. Sem nenhum argumento,
     `multinomial()' avalia para 1. É possível usar `minfactorial' para
     simplificar o valor retornado por `multinomial_coeff'; por exemplo:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- Função: num_distinct_partitions (<n>)
 -- Função: num_distinct_partitions (<n>, <a>)
     Quando <n> for um inteiro não negativo, retorna o número de
     partições inteiras distintas de <n>.

     Se o parâmetro opcional <a> tiver o valor `list', retorna uma
     lista do número de partições distintas de 1,2,3, ... , n.  Se <n>
     não for um inteiro não negativo, retorna uma forma substantiva.

     Definição: Se <n> = k_1 + ... + k_m, onde k_1 até k_m são
     distintos inteiros positivos, chamamos k_1 + ... + k_m uma
     partição distinta de <n>.

 -- Função: num_partitions (<n>)
 -- Função: num_partitions (<n>, <a>)
     Quando <n> for um intero não negativo, retorna o número de
     partições de <n>. Se o parâmetro opcional <a> tem o valor `list',
     retorna uma lista do número de partições de 1,2,3, ... , n.  Se <n>
     não for um inteiro não negativo, retorna uma forma substantiva.

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

     Para um inteiro não negativo <n>, `num_partitions (<n>)' é igual a
     `cardinality (integer_partitions (<n>))'; todavia, chamando
     `num_partitions' torna-se mais rápido.

 -- Função: partition_set (<a>, <f>)
     Retorna uma lista de dois conjuntos; o primeiro conjunto é o
     subconjunto de <a> para o qual o predicado <f> avalia pra falso e
     o segundo é o subconjunto de <a> <a> para o qual <f> avalia para
     verdadeiro.  Se <a> não for um conjunto, sinaliza um erro.  Veja
     também *Note subset::.

          (%i1) partition_set (set (2, 7, 1, 8, 2, 8), evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set (set (x, rat(y), rat(y) + z, 1), lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- Função: permutations (<a>)
     Retorna um conjunto de todas as permutações distintas distintas
     dos membros da lista ou conjunto <a>. (Cada permutacão é uma
     lista, não um conjunto.)  Quando <a> for uma lista, membros
     duplicados de <a> não são apagados antes de encontradas todas as
     pemutações. Dessa forma

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

     Se <a> não for uma lista ou conjunto, sinaliza um erro.

 -- Função: powerset (<a>)
 -- Função: powerset (<a>, <n>)
     Quando o segundo argumento opcional <n> não for definido, retorna
     o conjunto de todos os subconjuntos de conjunto <a>.
     `powerset(<a>)' tem `2^cardinality(<a>)' membros.  Fornecido um
     segundo argumento, `powerset(<a>,<n>)' retorna o conjunto de todos
     os subconjunto de <a> que possuem cardinalidade <n>. Sinaliza um
     erro se <a> não for um conjunto; adicionalmente sinaliza um erro
     se <n> não for um inteiro positivo.

 -- Função: rreduce (<f>, <s>)
 -- Função: rreduce (<f>, <s>, <init>)
     A função `rreduce' (right reduce) extende a 2-aridade da função
     pra uma n-aridade por composição; um exemplo pode tornar isso
     claro. Quando o argumento opcional <init> não for definido, temos

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     Note que a função <f> é primeiro aplicada aos elementos da lista
     mais à direita (dessa forma o nome rreduce). Quando <init> for
     definido, o segundo argumento para a avaliação da função mais
     interna é <init>; por exemplo:

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     A função `rreduce' torna isso fácil para encontrar o produto ou
     adição de elementos de uma lista.

          (%i1) rreduce ("+", args (set (a, b)));
          (%o1)                         b + a
          (%i2) rreduce ("*", args (set (1, 2, 3, 4, 5)));
          (%o2)                          120

     Veja também *Note lreduce::, *Note tree_reduce::, e *Note
     xreduce::.

 -- Função: setdifference (<a>, <b>)
     Retorna um conjunto contendo os elementos no conjunto <a> que não
     estão no conjunto <b>.  Sinaliza um erro se <a> ou <b> não for um
     conjunto.

 -- Função: setify (<a>)
     Constrói um conjunto a partir dos elementos da lista <a>.
     Elementos duplicados da lista <a> são apagados e os elementos são
     organizados conforme o predicado `orderlessp'.  Sinaliza um erro
     se `a' não for uma lista.

 -- Função: setp (<a>)
     Retorna verdadeiro se e somente se <a> for um conjunto Maxima.  A
     função `setp' verifica se o operador de seu argumento é conjunto;
     a função `setp' não verifica se seu argumento é um conjunto
     simplificado. Dessa forma

          (%i1) setp (set (a, a)), simp: false;
          (%o1)                         true

     A função `setp' pode ser codificada no Maxima como `setp(a) := is
     (inpart (a, 0) = set)'.


 -- Função: set_partitions (<a>)
 -- Função: set_partitions (<a>, <n>)
     Quando o argumento opcional <n> for definido, retorna um conjunto
     de todas as decomposições de <a> dentro de <n> não vazios
     subconjuntos disjuntos. Quando <n> não for definido, retorna o
     conjunto de todas as partições.

     Dizemos que um conjunto P é uma partição de um conjunto S dado
     quando

       1. each member of P is a nonempty set,

       2. distinct members of P are disjoint,

       3. the union of the members of P equals S.

     O conjunto vazio é uma partição de si mesmo (as condições 1 e 2
     sendo vacuosamente verdadeiras); dessa forma

          (%i1) set_partitions (set ());
          (%o1)                         {{}}

     A cardinalidade do conjunto de partições de um conjunto pode ser
     encontrada usando `stirling2'; dessa forma

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                        90 = 90
          (%i4) cardinality(p) = stirling2 (6, 3);

     Cada membro de `p' pode ter 3 membros; Vamos verificar.

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                          {3}
          (%i4) map (cardinality, p);

     Finalmente, para cada membro de `p', a união de seus membros será
     igual a `s'; novamente vamos verificar.

          (%i1) s: set (0, 1, 2, 3, 4, 5)$
          (%i2) p: set_partitions (s, 3)$
          (%o3)                 {{0, 1, 2, 3, 4, 5}}
          (%i4) map (lambda ([x], apply (union, listify (x))), p);

 -- Função: some (<f>, <a>)
 -- Função: some (<f>, <L_1>, ..., <L_n>)
     O primeiro argumento de <f> pode ser um predicado (uma função que
     avalia para verdadeiro, falso ou indetermindo).

     Fornecendo um conjunto como o segundo argumento, `some (<f>, <a>)'
     retorna `true' se `<f>(<a_i>)' retornar `true' para ao menos um
     <a_i> em <a>.  Uma vez que conjuntos são não ordenados, `some'
     está livre para avaliar `<f>(<a_i>)' em qualquer ordem. `some'
     pode ou não avaliar <f> para todos <a_i> em <a>. Porque a ordem de
     avaliação não é especificada, o predicado <f> poderá não ter
     efeitos de lado ou erros de sinal para qualquer entrada.  Para
     usar `some' sobre multiplos argumentos de conjunto, eles devem
     primeiro ser convertidos para uma seqüência ordenada de forma que
     seu alinhamento relativo torne-se bem definido.

     Fornecendo uma ou mais listas como argumentos, `some (<f>, <L_1>,
     ..., <L_n>)' retorna `true' se `<f>(<x_1>, ..., <x_n>)' retornar
     `true' para ao menos um <x_1>, ..., <x_n> in <L_1>, ..., <L_n>,
     respectivamente.  `some' pode ou não avaliar <f> para toda
     combinação <x_1>, ..., <x_n>.  Uma vez que listar são ordenadas,
     `some' avalia na ordem de incremento dos índices.

     Se o sinalizador global `maperror' for `true' (o padrão), todas as
     listas <L_1>, ..., <L_n> devem ter igual comprimento - de outra
     forma, `some' sinaliza um erro.  Quando `maperror' for falso, os
     argumentos lista são efetivamente truncados cada um para ter o
     comprimento da menor lista.

     A função Maxima `is' é automaticamente aplicada após o predicado
     <f>.

          (%i1) some ("<", [a, b, 5], [1, 2, 8]);
          (%o1)                         true
          (%i2) some ("=", [2, 3], [2, 7]);
          (%o2)                         true

 -- Função: stirling1 (<n>, <m>)
     O número de Stirling de primeiro tipo.  Quando <n> e <m> forem
     inteiros não negativos, a magnitude (módulo) de `stirling1 (<n>,
     <m>)' é o número de permutações de um conjunto com <n> membros que
     possuem <m> ciclos.  Para detalhes, veja Graham, Knuth e Patashnik
     Concrete Mathematics.  Usamos uma relação recursiva para definir
     `stirling1 (<n>, <m>)' para <m> menor que 0; nós não extendemos
     isso para <n> menor que 0 ou para argumentos não inteiros.

     A função `stirling1' trabalha através de simplificação; A função
     `stirling1' conhece os valores especiais básicos (veja Donald
     Knuth, The Art of Computer Programming, terceira edição, Volume 1,
     Seção 1.2.6, Equações 48, 49, e 50).  Para Maxima aplicar essas
     regras, os argumentos devem ser declarados para serem inteiros e o
     primeiro argumento deve ser não negativo. Por exemplo:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     `stirling1' não simplifica para argumentos não inteiros.

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maxima conhece uns poucos outros valores especiais; por exemplo:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- Função: stirling2 (<n>, <m>)
     O número de Stirling de segundo tipo. Quando <n> e <m> são
     inteiros não negativos, `stirling2 (<n>, <m>)' é o número de
     possibilidades que um conjunto com cardinalidade <n> pode ser
     particionado em <m> subconjuntos disjuntos.  Usamos uma relação
     recursiva para definir `stirling2 (<n>, <m>)' para <m> menor que
     0; não extendemos isso para <n> menor que 0 ou para argumentos não
     inteiros.

     A função `stirling2' trabalha através de simplificação; A função
     `stirling2' conhece os valores especiais básicos (veja Donald
     Knuth, The Art of Computer Programming, terceira edição, Volume 1,
     Seção 1.2.6, Equações 48, 49, e 50).  Para Maxima aplicar essas
     regras, os argumentos devem ser declarados para serem inteiros e o
     primeiro argumento deve ser não negativo. Por exemplo:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     `stirling2' não simplifica para argumentos não inteiros.

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maxima conhece uns poucos outros valores especiais.

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- Função: subset (<a>, <f>)
     Retorna um subconjunto do conjunto <a> que satisfaz o predicado
     <f>.  Por exemplo:

          (%i1) subset (set (1, 2, x, x + y, z, x + y + z), atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset (set (1, 2, 7, 8, 9, 14), evenp);
          (%o2)                      {2, 8, 14}

     O segundo argumento para `subset' deve ser um predicado (uma
     função que avalia para valores booleanos  de um argumento) se o
     primeiro argumento para `subset' não for um conjunto, sinaliza com
     um erro. Veja também *Note partition_set::.

 -- Função: subsetp (<a>, <b>)
     Retorna verdadeiro se e somente se o conjunto <a> for um
     subconjunto de <b>.  Sinaliza um erro se <a> ou <b> não for um
     conjunto.

 -- Função: symmdifference (<a_1>, ..., <a_n>)
     Retorna o conjunto dos membros que ocorrem em exatamente um
     conjunto <a_k>. Sinaliza um erro se qualquer argumento <a_k> não
     for um conjunto. Fornecidos dois argumentos, `symmdifference (<a>,
     <b>)' é o mesmo que `union (setdifference (<a>, <b>),
     setdifference (<b>, <a>))'.

 -- Função: tree_reduce (<f>, <s>)
 -- Função: tree_reduce (<f>, <s>, <init>)
     A função `tree_reduce' extende um operador binário associativo f :
     S x S -> S de dois argumentos para qualquer número de argumentos
     usando uma árvore de comprimento mínimo.  Um exemplo pode tornar
     isso claro.

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     Fornecido um número ímpar de argumentos, `tree_reduce' favorece o
     lado esquerdo da árvore; por exemplo:

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

     Para adição de número em ponto flutuantes, usando `tree_reduce'
     pode fornecer uma adição que tem a menor perda de algarismos
     significativos que usando ou `rreduce' ou `lreduce'.

 -- Função: union (<a_1>, ..., <a_n>)
     Retorna a união dos conjuntos <a_1> até <a_n>.  Quando `union' não
     recebe argumentos, retorna o conjunto vazio. Sinaliza um erro
     quando um ou mais argumentos para `union' não for um conjunto.

 -- Função: xreduce (<f>, <s>)
 -- Função: xreduce (<f>, <s>, <init>)
     Essa função é similar a ambas `lreduce' e `rreduce' exceto que
     `xreduce' está livre para usar ou a associatividade à esquerda ou
     a associatividade à direita; em particular quando <f> for uma
     função associativa e Maxima tem um avaliador interno para isso,
     `xreduce' pode usar a função n-ária; essas funções n-árias incluem
     adição `+', multiplicação `*', `and', `or', `max', `min', e
     `append'. Para esses operadores, nós geralmente esperamos usar
     `xreduce' para ser mais rápida que usando ou `rreduce' ou
     `lreduce'.  Quando <f> não for n-ária, `xreduce' usa
     associatividade à esquerda.  Adição em ponto flutuante não é
     associativa; todavia, `xreduce' usa a adição n-ária do Maxima
     quando o conjunto ou lista <s> contiver números em ponto flutuante.



File: maxima.info,  Node: Definição de Função,  Next: Fluxo de Programa,  Prev: Conjuntos,  Up: Top

41 Definição de Função
**********************

* Menu:

* Introdução a Definição de Função::
* Função::
* Macros::
* Definições para Definição de Função::


File: maxima.info,  Node: Introdução a Definição de Função,  Next: Função,  Prev: Definição de Função,  Up: Definição de Função

41.1 Introdução a Definição de Função
=====================================


File: maxima.info,  Node: Função,  Next: Macros,  Prev: Introdução a Definição de Função,  Up: Definição de Função

41.2 Função
===========

Para definir uma função no Maxima você usa o operador :=.  E.g.

     f(x) := sin(x)

define uma função `f'.  Funções anônimas podem também serem criadas
usando `lambda'.  Por exemplo

     lambda ([i, j], ...)

pode ser usada em lugar de `f' onde

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

retornará uma lista com 1 adicionado a cada termo.

   Você pode também definir uma função com um número variável de
argumentos, teno um argumento final que é atribuído para uma lista de
argumentos extras:

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   O lado direito de uma função é uma expressão.  Desse modo Se você
quer uma seqüência de expressões, você faz

     f(x) := (expr1, expr2, ...., exprn);

   e o valor de <exprn> é que é retornado pela função.

   Se você deseja fazer um `return' de alguma expressão dentro da
função então você deve usar `block' e `return'.

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   é em si mesma uma expressão, e então poderá ocupar o lugar do lado
direito de uma definição de função.  Aqui pode acontecer que o retorno
aconteça mais facilmente que no exemplo anterior a essa última
expressão.

   O primeiro `[]' no bloco, pode conter uma lista de variáveis e
atribuições de variáveis, tais como `[a: 3, b, c: []]', que farão com
que as três variáveis `a',`b',e `c' não se refiram a seus valores
globais, mas ao contrário tenham esses valores especiais enquanto o
código estiver executando a parte dentro do bloco `block', ou dentro da
funções chamadas de dentro do bloco `block'.  Isso é chamado associação
dynamic, uma vez que as variáveis permanecem do início do bloco pelo
tempo que ele existir.  Uma vez que você retorna do `block', ou
descarta-o, os valores antigos (quaisquer que sejam) das variáveis
serão restaurados.   É certamente uma boa idéia para proteger suas
variáveis nesse caminho.   Note que as atribuições em variáveis do
bloco, são concluídas em paralelo.   Isso significa, que se tiver usado
`c: a' acima, o valor de `c' será o valor de `a' a partir do momento em
que vocêntrou no bloco, mas antes `a' foi associado.   Dessa forma
fazendo alguma coisa como

     block ([a: a], expr1, ...  a: a+3, ..., exprn)

   protegerá o valor externo de `a' de ser alterado, mas impedirá você
acessar o valor antigo.   Dessa forma o lado direito de atribuições, é
avaliado no contexto inserido, antes que qualquer avaliação ocorra.
Usando apenas `block ([x], ...' faremos com que o `x' ter a si mesmo
como valor, apenas como tivesse você entrar numa breve sessão Maxima.

   Os atuais argumentos para uma função são tratados exatamente da
mesma que as variáveis em um bloco.  Dessa forma em

     f(x) := (expr1, ..., exprn);

   e

     f(1);

   teremos um contexto similar para avaliação de expressões como se
tivéssemos concluído

     block ([x: 1], expr1, ..., exprn)

   Dentro de funções, quando o lado direito de uma definição, pode ser
calculado em tempo de execução, isso é úti para usar `define' e
possivelmente `buildq'.


File: maxima.info,  Node: Macros,  Next: Definições para Definição de Função,  Prev: Função,  Up: Definição de Função

41.3 Macros
===========

 -- Função: buildq (<L>, <expr>)
     Substitue variáveis nomeadas pela lista <L> dentro da expressão
     <expr>, paralelamente, sem avaliar <expr>.  A expressão resultante
     é simplificada, mas não avaliada, após `buildq' realizar a
     substituição.

     Os elementos de <L> são símbolos ou expressões de atribuição
     `<símbolo>: <valor>', avaliadas paralelamente.  Isto é, a
     associação de uma variável sobre o lado direito de uma atribuição
     é a associação daquela variável no contexto do qual `buildq' for
     chamada, não a associação daquela variável na lista <L> de
     variáveis.  Se alguma variável em <L> não dada como uma atribuição
     explícita, sua associação em `buildq' é a mesma que no contexto no
     qual `buildq' for chamada.

     Então as variáveis nomeadas em <L> são substituidas em <expr>
     paralelamente.  Isto é, a substituição para cada variável é
     determinada antes que qualquer substituição seja feita, então a
     substituição para uma variável não tem efeito sobre qualquer outra.

     Se qualquer variável <x> aparecer como `splice (<x>)' em <expr>,
     então <x> deve estar associada para uma lista, e a lista recebe
     uma aplicação da função `splice' (é interpolada) na <expr> em
     lugar de substituída.

     Quaisquer variáveis em <expr> não aparecendo em <L> são levados no
     resultado tal como foram escritos, mesmo se elas tiverem
     associações no contexto do qual `buildq' tiver sido chamada.

     Exemplos

     `a' é explicitamente associada a `x', enquanto `b' tem a mesma
     associação (nomeadamente 29) como no contexto chamado, e `c' é
     levada do começo ao fim da forma como foi escrita.  A expressão
     resultante não é avaliada até a avaliação explícita ( com duplo
     apóstrofo - não com aspas - `''%'.

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     `e' está associado a uma lista, a qual aparece também como tal nos
     argumentos de `foo', e interpolada nos argumentos de `bar'.

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     O resultado é simplificado após substituição.  Se a simplificação
     for aplicada antes da substituição, esses dois resultados podem
     ser iguais.
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     As variáveis em <L> são associadas em paralelo; se associadas
     seqüêncialmente, o primeiro resultado pode ser `foo (b, b)'.
     Substituições são realizadas em paralelo; compare o segundo
     resultado com o resultado de `subst', que realiza substituições
     seqüêncialmente.

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     Constrói uma lista de euqções com algumas variáveis ou expressões
     sobre o lado esquerdo e seus valores sobre o lado direito.
     `macroexpand' mostra a expressão retornada por `show_values'.

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)              [a = 17, b = 29, c = 1729]


 -- Função: macroexpand (<expr>)
     Retorna a expansão da macro de <expr> sem avaliar a expressão,
     quando `expr' for uma chamada de função de macro.  De outra forma,
     `macroexpand' retorna <expr>.

     Se a expansão de <expr> retorna outra chamada de função de macro,
     aquela chamada de função de macro é também expandida.

     `macroexpand' coloca apóstrofo em seus argumentos, isto é, não os
     avalia.  Todavia, se a expansão de uma chamada de função de macro
     tiver algum efeito, esse efeito colateral é executado.

     Veja também `::=', `macros', e `macroexpand1'.

     Exemplos

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Função: macroexpand1 (<expr>)
     Retorna a expansão de macro de <expr> sem avaliar a expressão,
     quando `expr' for uma chamada de função de macro.  De outra forma,
     `macroexpand1' retorna <expr>.

     `macroexpand1' não avalia seus argumentos.  Todavia, se a expansão
     de uma chamada de função de macro tiver algum efeito, esse efeito
     colateral é executado.

     Se a expansão de <expr> retornar outra chamada de função de macro,
     aquela chamada de função de macro não é expandida.

     Veja também `::=', `macros', e `macroexpand'.

     Examples

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99


 -- Global variable: macros
     Default value: `[]'

     `macros' é a lista de funções de macro definidas pelo usuário.  O
     operador de definição de função de macro `::=' coloca uma nova
     função de macro nessa lista, e `kill', `remove', e `remfunction'
     removem funções de macro da lista.

     Veja também `infolists'.


 -- Função: splice (<a>)
     Une como se fosse um elo de ligação (interpola) a lista nomeada
     através do átomo <a> em uma expressão, mas somente se `splice'
     aparecer dentro de `buildq'; de outra forma, `splice' é tratada
     como uma função indefinida.  Se aparecer dentro de `buildq' com
     <a> sozinho (sem `splice'), <a> é substituido (não interpolado)
     como uma lista no resultado.  O argumento de `splice' pode somente
     ser um átomo; não pode ser uma lista lateral ou uma expressão que
     retorna uma lista.

     Tipicamente `splice' fornece os argumentos para uma função ou
     operador.  Para uma função `f', a expressão `f (splice (<a>))'
     dentro de `buildq' expande para `f (<a>[1], <a>[2], <a>[3], ...)'.
     Para um operador `o', a expressão `"o" (splice (<a>)' dentro de
     `buildq' expande para `"o" (<a>[1], <a>[2], <a>[3], ...)', onde
     `o' pode ser qualquer tipo de operador (tipicamente um que toma
     multiplos argumentos).  Note que o operador deve ser contido
     dentro de aspas duplas `"'.

     Exemplos

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>



File: maxima.info,  Node: Definições para Definição de Função,  Prev: Macros,  Up: Definição de Função

41.4 Definições para Definição de Função
========================================

 -- Função: apply (<f>, [<x_1>, ..., <x_n>])
     Retorna o resultado da aplicação da função <f> para a lista de
     argumentos <x_1>, ..., <x_n>.  <f> é o nome de uma função ou uma
     expressão lambda.

     Isso é útil quando é desejado calcular os argumentos para uma
     função antes de aplicar aquela função.  Por exemplo, se `l' é a
     lista `[1, 5, -10.2, 4, 3]', então `apply (min, l)' resulta -10.2.
     `apply' é também útil quando chama funções que não possuem seus
     argumentos avaliados e é desejável fazer a avaliação deles.  Por
     exemplo, se `filespec' é uma variável associada à lista `[test,
     case]' então `apply (closefile, filespec)' é equivalente a
     `closefile (test, case)'.  Em geral o primeiro argumento para
     `apply' será processado por um ' (apóstrofo) para fazer isso
     avaliar para si mesmo.  Uma vez que algumas variáveis atômicas
     possuem o mesmo nome que certas funções os valores da variável
     poderão ser usados em lugar da função porque `apply' teve seu
     primeiro argumento avaliado assim como seu segundo.


 -- Função: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- Função: block (<expr_1>, ..., <expr_n>)
     `block' avalia <expr_1>, ..., <expr_n> em seqüência e retorna o
     valor da última expressão avaliada.  A seqüência pode ser
     modificada pelas funções `go', `throw', e `return'.  A última
     expressão é <expr_n> a menos que `return' ou uma expressão
     contendo `throw' seja avaliada.  Algumas variáveis <v_1>, ...,
     <v_m> podem ser declaradas locais para o bloco; essas são
     distinguidas das variáveis globais dos mesmos nomes.  Se variáveis
     não forem declaradas locais então a lista pode ser omitida.
     Dentro do bloco, qualquer variável que não <v_1>, ..., <v_m> é uma
     variável global.

     `block' salva os valores correntes das variáveis <v_1>, ..., <v_m>
     (quaisquer valores) na hora da entrada para o bloco, então libera
     as variáveis dessa forma eles avaliam para si mesmos.  As
     variáveis locais podem ser associadas a valores arbitrários dentro
     do bloco mas quando o bloco é encerrado o valores salvos são
     restaurados, e os valores atribuídos dentro do bloco são perdidos.

     `block' pode aparecer dentro de outro `block'.  Variáveis locais
     são estabelecidas cada vez que um novo `block' é avaliado.
     Variáveis locais parecem ser globais para quaisquer blocos
     fechados.  Se uma variável é não local em um bloco, seu valor é o
     valor mais recentemente atribuído por um bloco fechado, quaisquer
     que sejam, de outra forma, seu valor é o valor da variável no
     ambiente global.  Essa política pode coincidir com o entendimento
     usual de "escopo dinâmico".

     Se isso for desejado para salvar e restaurar outras propriedades
     locais ao lado de `value', por exemplo `array' (exceto para arrays
     completos), `function', `dependencies', `atvalue', `matchdeclare',
     `atomgrad', `constant', e `nonscalar' então a função `local' pode
     ser usada dentro do bloco com argumentos sendo o nome das
     variáveis.

     O valor do bloco é o valor da última declaração ou o valor do
     argumento para a função `return' que pode ser usada para sair
     explicitamente do bloco.  A função `go' pode ser usada para
     transferir o controle para a declaração do bloco que é
     identificada com o argumento para `go'.  Para identificar uma
     declaração, coloca-se antes dela um argumento atômico como outra
     declaração no bloco.  Por exemplo: `block ([x], x:1, loop, x: x+1,
     ..., go(loop), ...)'.  O argumento para `go' deve ser o nome de um
     identificador que aparece dentro do bloco.  Não se deve usar `go'
     para transferir para um identificador em um outro bloco a não ser
     esse que contém o `go'.

     Blocos tipicamente aparecem do lado direito de uma definição de
     função mas podem ser usados em outros lugares também.


 -- Função: break (<expr_1>, ..., <expr_n>)
     Avalia e imprime <expr_1>, ..., <expr_n> e então causa uma parada
     do Maxima nesse ponto e o usuário pode examinar e alterar seu
     ambiente.  Nessa situação digite `exit;' para que o cálculo seja
     retomado.


 -- Função: catch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma; se qualquer avaliação
     levar a uma avaliação de uma expressão da forma `throw (arg)',
     então o valor de `catch' é o valor de `throw (arg)', e expressões
     adicionais não são avaliadas.  Esse "retorno não local" atravessa
     assim qualquer profundidade de aninhar para o mais próximo
     contendo `catch'.  Se não existe nenhum `catch' contendo um
     `throw', uma mensagem de erro é impressa.

     Se a avaliação de argumentos não leva para a avaliação de qualquer
     `throw' então o valor de `catch' é o valor de <expr_n>.

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     A função `g' retorna uma lista de `f' de cada elemento de `l' se
     `l' consiste somente de números não negativos; de outra forma, `g'
     "captura" o primeiro elemento negativo de `l' e "arremessa-o".


 -- Função: compfile (<filename>, <f_1>, ..., <f_n>)
     Traduz funções Maxima <f_1>, ..., <f_n> para Lisp e escreve o
     código traduzido no arquivo <filename>.

     As traduções Lisp não são avaliadas, nem é o arquivo de saída
     processado pelo compilador Lisp.  `translate' cria e avalia
     traduções Lisp.  `compile_file' traduz Maxima para Lisp, e então
     executa o compilador Lisp.

     Veja também `translate', `translate_file', e `compile_file'.


 -- Função: compile (<f_1>, ..., <f_n>)
 -- Função: compile (functions)
 -- Função: compile (all)
     Traduz funções Maxima <f_1>, ..., <f_n> para Lisp, avalia a
     tradução Lisp, e chama a função Lisp `COMPILE' sobre cada função
     traduzida.  `compile' retorna uma lista de nomes de funções
     compiladas.

     `compile (all)' ou `compile (functions)' compila todas as funções
     definidas pelo usuário.

     `compile' não avalia seus argumentos; o operador aspas simples
     `''' faz com que ocorra avaliação.


 -- Função: define (<f>(<x_1>, ..., <x_n>), <expr>)
     Define uma função chamada <f> com argumentos <x_1>, ..., <x_n> e
     corpo da função <expr>.

     `define' não avalia seu primeiro argumento na maioria dos casos, e
     avalia seu segundo argumento a menos que explicitamente seja
     pedido o contrário.  Todavia, se o primeiro argumento for uma
     expressão da forma `ev (<expr>)', `funmake (<expr>)', ou
     `arraymake (<expr>)', o primeiro argumento será avaliado; isso
     permite para o nome da função seja calculado, também como o corpo.

     `define' é similar ao operador de definição de função `:=', mas
     quando `define' aparece dentro da função, a definição é criada
     usando o valor de `expr' em tempo de execução em lugar de em tempo
     de definição da função que a contém.

     Todas as definições de função aparecem no mesmo nível de escopo e
     visibilidade; definindo uma função `f' dentro de outra função `g'
     não limita o escopo de `f' a `g'.

     Exemplos:

          (%i1) foo: 2^bar;
                                         bar
          (%o1)                         2
          (%i2) g(x) := (f_1 (y) :=   foo*x*y,
                         f_2 (y) := ''foo*x*y,
                 define (f_3 (y),     foo*x*y),
                 define (f_4 (y),   ''foo*x*y));
                                                       bar
          (%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y,
                                                                  bar
                         define(f_3(y), foo x y), define(f_4(y), 2    x y))
          (%i3) functions;
          (%o3)                        [g(x)]
          (%i4) g(a);
                                              bar
          (%o4)                  f_4(y) := a 2    y
          (%i5) functions;
          (%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
          (%i6) dispfun (f_1, f_2, f_3, f_4);
          (%t6)                   f_1(y) := foo x y

                                            bar
          (%t7)                  f_2(y) := 2    x y

                                              bar
          (%t8)                  f_3(y) := a 2    y

                                              bar
          (%t9)                  f_4(y) := a 2    y

          (%o9)                         done

 -- Função: define_variable (<name>, <default_value>, <mode>)
     Introduz uma variável global dentro do ambiente Maxima.
     `define_variable' é útil em pacotes escritos pelo usuário, que são
     muitas vezes traduzidos ou compilados.

     `define_variable' realiza os seguintes passos:

       1. `mode_declare (<name>, <mode>)' declara o modo de <name> para
          o tradutor.  Veja `mode_declare' para uma lista dos modos
          possíveis.

       2. Se a variável é não associada, <default_value> é atribuído
          para <name>.

       3. `declare (<name>, special)' declara essa variável especial.

       4. Associa <name> com uma função de teste para garantir que a
          <name> seja somente atribuído valores do modo declarado.

     A propriedade `value_check' pode ser atribuída a qualquer variável
     que tenha sido definida via `define_variable' com um outro modo
     que não `any'.  A propriedade `value_check' é uma expressão lambda
     ou o nome de uma função de uma variável, que é chamada quando uma
     tentativa é feita para atribuir um valor a uma variável.  O
     argumento da  função `value_check' é o valor que será atribuído.

     `define_variable' avalia `default_value', e não avalia `name' e
     `mode'.  `define_variable' retorna o valor corrente de `name', que
     é `default_value' se `name' não tiver sido associada antes, e de
     outra forma isso é o valor prévio de `name'.

     Exemplos:

     `foo' é uma variável Booleana, com o valor inicial `true'.

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     `bar' é uma variável inteira, que deve ser um número primo.

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 é not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     `baz_quux' é uma variável que não pode receber a atribuição de um
     valor.  O modo `any_check' é como `any', mas `any_check' habilita
     o mecanismo `value_check', e `any' não habilita.

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux


 -- Função: dispfun (<f_1>, ..., <f_n>)
 -- Função: dispfun (all)
     Mostra a definição de funções definidas pelo usuário <f_1>, ...,
     <f_n>.  Cada argumento pode ser o nome de uma macro (definida com
     `::='), uma função comum (definida com `:=' ou `define'), uma
     função array (definida com `:=' ou com `define', mas contendo
     argumentos entre colchêtes `[ ]'), uma função subscrita, (definida
     com `:=' ou `define', mas contendo alguns argumentos entre
     colchêtes e outros entre parêntesis `( )') uma da família de
     funções subscritas selecionadas por um valor subscrito particular,
     ou uma função subscrita definida com uma constante subscrita.

     `dispfun (all)' mostra todas as funções definidas pelo usuário como
     dadas pelas `functions', `arrays', e listas de `macros', omitindo
     funções subscritas definidas com constantes subscritas.

     `dispfun' cria um Rótulo de expressão intermediária (`%t1', `%t2',
     etc.)  para cada função mostrada, e atribui a definição de função
     para o rótulo.  Em contraste, `fundef' retorna a definição de
     função.

     `dispfun' não avalia seus argumentos; O operador aspas simples
     `''' faz com que ocorra avaliação.

     `dispfun' retorna a lista de rótulos de expressões intermediárias
     correspondendo às funções mostradas.

     Exemplos:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x

                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10


 -- Variável de sistema: functions
     Valor padrão: `[]'

     `functions' é uma lista de todas as funções Maxima definidas pelo
     usuário na sessão corrente.  Um função definida pelo usuário é uma
     função construída por `define' or `:='.  Uma função pode ser
     definida pela linha de comando do Maxima de forma interativa com o
     usuário ou em um arquivo Maxima chamado por `load' ou `batch'.
     Funções Lisp, todavia, não são adicinadas à lista `functions'.


 -- Função: fundef (<f>)
     Retorna a definição da função <f>.

     O argumento pode ser o nome de uma macro (definida com `::='), uma
     função comum (definida com `:=' ou `define'), uma função array
     (definida com `:=' ou `define', mas contendo argumentos entre
     colchêtes `[ ]'), Uma função subscrita, (definida com `:=' ou
     `define', mas contendo alguns argumentos entre colchêtes e
     parêntesis `( )') uma da família de funções subscritas selecionada
     por um valor particular subscrito, ou uma função subscrita
     definida com uma constante subscrita.

     `fundef' não avalia seu argumento; o operador aspas simples `'''
     faz com que ocorra avaliação.

     `fundef (<f>)' retorna a definição de <f>.  Em contraste, `dispfun
     (<f>)' cria um rótulo de expressão intermediária e atribui a
     definição para o rótulo.


 -- Função: funmake (<name>, [<arg_1>, ..., <arg_n>])
     Retorna uma expressão `<name> (<arg_1>, ..., <arg_n>)'.  O valor
     de retorno é simplificado, mas não avaliado, então a função não é
     chamada.

     `funmake' avalia seus argumentos.

     Exemplos:

        * `funmake' avalia seus argumentos, mas não o valor de retorno.
               (%i1) det(a,b,c) := b^2 -4*a*c$
               (%i2) x: 8$
               (%i3) y: 10$
               (%i4) z: 12$
               (%i5) f: det$
               (%i6) funmake (f, [x, y, z]);
               (%o6)                    det(8, 10, 12)
               (%i7) ''%;
               (%o7)                         - 284

        * Maxima simplifica o valor de retorno de `funmake'.
               (%i1) funmake (sin, [%pi/2]);
               (%o1)                           1


 -- Função: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- Função: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ..., <expr_n>)
     Define e retorna uma expressão lambda (que é, uma função anônima)
     A função pode ter argumentos que sejam necessários <x_1>, ...,
     <x_m> e/ou argumentos opcionais <L>, os quais aparecem dentro do
     corpo da função como uma lista.  O valor de retorno da função é
     <expr_n>.  Uma expressão lambda pode ser atribuída para uma
     variável e avaliada como uma função comum.  Uma expressão lambda
     pode aparecer em alguns contextos nos quais um nome de função é
     esperado.

     Quando a função é avaliada, variáveis locais não associadas <x_1>,
     ..., <x_m> são criadas.  `lambda' pode aparecer dentro de `block'
     ou outra função `lambda'; variáveis locais são estabelecidas cada
     vez que outro `block' ou função `lambda' é avaliada.  Variáveis
     locais parecem ser globais para qualquer coisa contendo `block' ou
     `lambda'.  Se uma variável é não local, seu valor é o valor mais
     recentemente atribuído em alguma coisa contendo `block' ou
     `lambda', qualquer que seja, de outra forma, seu valor é o valor
     da variável no ambiente global.  Essa política pode coincidir com
     o entendimento usual de "escopo dinâmico".

     Após variáveis locais serem estabelecidas, <expr_1> até <expr_n>
     são avaliadas novamente.  a variável especial `%%', representando
     o valor da expressão precedente, é reconhecida.  `throw' e `catch'
     pode também aparecer na lista de expressões.

     `return' não pode aparecer em uma expressão lambda a menos que
     contendo `block', nesse caso `return' define o valor de retorno do
     bloco e não da expressão lambda, a menos que o bloco seja
     <expr_n>.  Da mesma forma, `go' não pode aparecer em uma expressão
     lambda a menos que contendo `block'.

     `lambda' não avalia seus argumentos; o operador aspas simples `'''
     faz com que ocorra avaliação.

     Exemplos:

        * A expressão lambda pode ser atribuída para uma variável e
          avaliada como uma função comum.

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a

        * Uma expressão lambda pode aparecer em contextos nos quais uma
          avaliação de função é esperada como resposta.

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]

        * Variáveis argumento são variáveis locais.  Outras variáveis
          aparecem para serem variáveis globais.  Variáveis globais são
          avaliadas ao mesmo tempo em que a expressão lambda é avaliada,
          a menos que alguma avaliação especial seja forçada por alguns
          meios, tais como `'''.

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2

        * Expressões lambda podem ser aninhadas.  Variáveis locais
          dentro de outra expressão lambda parece ser global para a
          expressão interna a menos que mascarada por variáveis locais
          de mesmos nomes.

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2

        * Uma vez que `lambda' não avalia seus argumentos, a expressão
          lambda `i' abaixo não define uma função "multiplicação por
          `a'".  Tanto uma função pode ser definida via `buildq', como
          na expressão lambda `i2' abaixo.

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2

        * Uma expressão lambda pode receber um número variável de
          argumentos, os quais são indicados por meio de `[<L>]' como o
          argumento único ou argumento final.  Os argumentos aparecem
          dentro do corpo da função como uma lista.

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- Função: local (<v_1>, ..., <v_n>)
     Declara as variáveis <v_1>, ..., <v_n> para serem locais com
     relação a todas as propriedades na declaração na qual essa função
     é usada.

     `local' não avalia seus argumentos.  `local' retorna `done'.

     `local' pode somente ser usada em `block', no corpo de definições
     de função ou expressões `lambda', ou na função `ev', e somente uma
     ocorrêcia é permitida em cada.

     `local' é independente de `context'.


 -- Variável de opção: macroexpansion
     Valor padrão: `false'

     `macroexpansion' controla recursos avançados que afetam a
     eficiência de macros.  Escolhas possíveis:

        * `false' - Macros expandem normalmente cada vez que são
          chamadas.

        * `expand' - A primeira vez de uma chamada particular é
          avaliada, a expansão é lembrada internamente, dessa forma não
          tem como ser recalculada em chamadas subseqüênte rapidamente.
          A macro chama ainda chamadas `grind' e `display'
          normalmente.  Todavia, memória extra é requerida para lembrar
          todas as expansões.

        * `displace' - A primeira vez de uma chamada particular é
          avaliada, a expansão é substituída pela chamada.  Isso requer
          levemente menos armazenagem que quando `macroexpansion' é
          escolhida para `expand' e é razoávelmente rápido, mas tem a
          desvantagem de a macro original ser lentamente lembrada e daí
          a expansão será vista se `display' ou `grind' for chamada.
          Veja a documentação para `translate' e `macros' para maiores
          detalhes.


 -- Variável de opção: mode_checkp
     Valor padrão: `true'

     Quando `mode_checkp' é `true', `mode_declare' verifica os modos de
     associação de variáveis.


 -- Variável de opção: mode_check_errorp
     Valor padrão: `false'

     Quando `mode_check_errorp' é `true', `mode_declare' chama a função
     "error".


 -- Variável de opção: mode_check_warnp
     Valor padrão: `true'

     Quando `mode_check_warnp' é `true', modo "errors" são descritos.


 -- Função: mode_declare (<y_1>, <mode_1>, ..., <y_n>, <mode_n>)
     `mode_declare' é usado para declarar os modos de variáveis e
     funções para subseqüênte tradução ou compilação das funções.
     `mode_declare' é tipicamente colocada no início de uma definição de
     função, no início de um script Maxima, ou executado através da
     linha de comando de forma interativa.

     Os argumentos de `mode_declare' são pares consistindo de  uma
     variável e o modo que é um de `boolean', `fixnum', `number',
     `rational', ou `float'.  Cada variável pode também ser uma lista
     de variáveis todas as quais são declaradas para ter o mesmo modo.

     Se uma variável é um array, e se todo elemento do array que é
     referenciado tiver um valor então `array (yi, complete, dim1,
     dim2, ...)' em lugar de
          array(yi, dim1, dim2, ...)
     deverá ser usado primeiro declarando as associações do array.  Se
     todos os elementos do array estão no modo `fixnum' (`float'), use
     `fixnum' (`float') em lugar de `complete'.  Também se todo
     elemento do array está no mesmo modo, digamos `m', então

          mode_declare (completearray (yi), m))

     deverá ser usado para uma tradução eficiente.

     Código numéricos usando arrays podem rodar mais rápidamente se for
     decladado o tamanho esperado do array, como em:

          mode_declare (completearray (a [10, 10]), float)

     para um array numérico em ponto flutuante que é 10 x 10.

     Pode-se declarar o modo do resultado de uma função usando
     `function (f_1, f_2, ...)' como um argumento; aqui `f_1', `f_2',
     ...  são nomes de funções.  Por exemplo a expressão,

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     declara que os valores retornados por `f_1', `f_2', ...  são
     inteiros palavra simples.

     `modedeclare' é um sinônimo para `mode_declare'.


 -- Função: mode_identity (<arg_1>, <arg_2>)
     Uma forma especial usada com `mode_declare' e `macros' para
     declarar, e.g., uma lista de listas de números em ponto flutuante
     ou outros objetos de dados.  O primeiro argumento para
     `mode_identity' é um valor primitivo nome de modo como dado para
     `mode_declare' (i.e., um de `float', `fixnum', `number', `list',
     ou `any'), e o segundo argumento é uma expressão que é avaliada e
     retornada com o valor de `mode_identity'.  Todavia, se o valor de
     retorno não é permitido pelo modo declarado no primeiro argumento,
     um erro ou alerta é sinalizado.  Um ponto importante é que o modo
     da expressão como determinado pelo Maxima para o tradutor Lisp,
     será aquele dado como o primeiro argumento, independente de
     qualquer coisa que vá no segundo argumento.  E.g., `x: 3.3;
     mode_identity (fixnum, x);' retorna um erro.  `mode_identity
     (flonum, x)' returns 3.3 .  Isso tem númerosas utilidades, e.g.,
     se você soube que `first (l)' retornou um número então você pode
     escrever `mode_identity (number, first (l))'.  Todavia, um mais
     eficiente caminho para fazer isso é definir uma nova primitiva,

          firstnumb (x) ::= buildq ([x], mode_identity (number, x));

     e usar `firstnumb' toda vez que você pegar o primeiro de uma lista
     de números.


 -- Variável de opção: transcompile
     Valor padrão: `true'

     Quando `transcompile' é `true', `translate' e `translate_file'
     geram declarações para fazer o código traduzido mais adequado para
     compilação.

     `compfile' escolhe `transcompile: true' para a duração.


 -- Função: translate (<f_1>, ..., <f_n>)
 -- Função: translate (functions)
 -- Função: translate (all)
     Traduz funções definidas pelo usuário <f_1>, ..., <f_n> da
     linguagem de Maxima para Lisp e avalia a tradução Lisp.
     Tipicamente as funções traduzidas executam mais rápido que as
     originais.

     `translate (all)' ou `translate (functions)' traduz todas as
     funções definidas pelo usuário.

     Funções a serem traduzidas incluir~ao uma chamada para
     `mode_declare' no início quando possível com o objetivo de
     produzir um código mais eficiente.  Por exemplo:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     quando <x_1>, <x_2>, ...  são parâmetros para a função e <v_1>,
     <v_2>, ...  são variáveis locais.

     Os nomes de funções traduzidas são removidos da lista `functions'
     se `savedef' é `false' (veja abaixo) e são adicionados nas listas
     `props'.

     Funções não poderão ser traduzidas a menos que elas sejam
     totalmente depuradas.

     Expressões são assumidas simplificadas; se não forem, um código
     correto será gerado mas não será um código ótimo.  Dessa forma, o
     usuário não poderá escolher o comutador `simp' para `false' o qual
     inibe simplificação de expressões a serem traduzidas.

     O comutador `translate', se `true', causa tradução automatica de
     uma função de usuário para Lisp.

     Note que funções traduzidas podem não executar identicamente para
     o caminho que elas faziam antes da tradução como certas
     incompatabilidades podem existir entre o Lisp e versões do Maxima.
     Principalmente, a função  `rat' com mais de um argumento e a
     função `ratvars' não poderá ser usada se quaisquer variáveis são
     declaradas com `mode_declare' como sendo expressões rotacionais
     canônicas(CRE).  Também a escolha `prederror: false' não traduzirá.

     `savedef' - se `true' fará com que a versão Maxima de uma função
     usuário permaneça quando a função é traduzida com `translate'.
     Isso permite a que definição seja mostrada por `dispfun' e
     autoriza a função a ser editada.

     `transrun' - se `false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar da versão traduzida.

     O resultado retornado por `translate' é uma lista de nomes de
     funções traduzidas.


 -- Função: translate_file (<maxima_filename>)
 -- Função: translate_file (<maxima_filename>, <lisp_filename>)
     Traduz um arquivo com código Maxima para um arquivo com código
     Lisp.  `translate_file' retorna uma lista de três nomes de arquivo:
     O nome do arquivo Maxima, o nome do arquivo Lisp, e o nome do
     arquivo contendo informações adicionais sobre a tradução.
     `translate_file' avalia seus argumentos.

     `translate_file ("foo.mac"); load("foo.LISP")' é o mesmo que
     `batch ("foo.mac")' exceto por certas restrições, o uso de `''' e
     `%', por exemplo.

     `translate_file (<maxima_filename>)' traduz um arquivo Maxima
     <maxima_filename> para um similarmente chamado arquivo Lisp.  Por
     exemplo, `foo.mac' é traduzido em `foo.LISP'.  O nome de arquivo
     Maxima pod incluir nome ou nomes de diretório(s), nesse caso o
     arquivo de saída Lisp é escrito para o mesmo diretório que a
     entrada Maxima.

     `translate_file (<maxima_filename>, <lisp_filename>)' traduz um
     arquivo Maxima <maxima_filename> em um arquivo Lisp
     <lisp_filename>.  `translate_file' ignora a extensão do nome do
     arquivo, se qualquer, de `lisp_filename'; a extensão do arquivo de
     saída Lisp é sempre `LISP'.  O nome de arquivo Lisp pode incluir
     um nome ou nomes de diretórios), nesse caso o arquivo de saída
     Lisp é escrito para o diretório especificado.

     `translate_file' também escreve um arquivo de mensagens de alerta
     do tradutor em vários graus de severidade.  A extensão do nome de
     arquivo desse arquivo é `UNLISP'.  Esse arquivo pode conter
     informação valiosa, apesar de possivelmente obscura, para rastrear
     erros no código traduzido.  O arquivo `UNLISP' é sempre escrito
     para o mesmo diretório que a entrada Maxima.

     `translate_file' emite código Lisp o qual faz com que algumas
     definições tenham efeito tão logo o código Lisp é compilado.  Veja
     `compile_file' para mais sobre esse tópico.

     Veja também `tr_array_as_ref', `tr_bound_function_applyp',
     `tr_exponent', `tr_file_tty_messagesp',
     `tr_float_can_branch_complex', `tr_function_call_default',
     `tr_numer', `tr_optimize_max_loop', `tr_semicompile',
     `tr_state_vars', `tr_warnings_get', `tr_warn_bad_function_calls',
     `tr_warn_fexpr', `tr_warn_meval', `tr_warn_mode',
     `tr_warn_undeclared', `tr_warn_undefined_variable', and `tr_windy'.


 -- Variável de opção: transrun
     Valor padrão: `true'

     Quando `transrun' é `false' fará com que a versão interpretada de
     todas as funções sejam executadas (desde que estejam ainda
     disponíveis) em lugar de versão traduzidas.


 -- Variável de opção: tr_array_as_ref
     Valor padrão: `true'

     Se `translate_fast_arrays' for `false', referências a arrays no
     Código Lisp emitidas por `translate_file' são afetadas por
     `tr_array_as_ref'.  Quando `tr_array_as_ref' é `true', nomes de
     arrays são avaliados, de outra forma nomes de arrays aparecem como
     símbolos literais no código traduzido.

     `tr_array_as_ref' não terão efeito se `translate_fast_arrays' for
     `true'.


 -- Variável de opção: tr_bound_function_applyp
     Valor padrão: `true'

     Quando `tr_bound_function_applyp' for `true', Maxima emite um
     alerta se uma associação de variável (tal como um argumento de
     função) é achada sendo usada como uma função.
     `tr_bound_function_applyp' não afeta o código gerado em tais casos.

     Por exemplo, uma expressão tal como `g (f, x) := f (x+1)' irá
     disparar a mensagem de alerta.


 -- Variável de opção: tr_file_tty_messagesp
     Valor padrão: `false'

     Quando `tr_file_tty_messagesp' é `true', messagens geradas por
     `translate_file' durante a tradução de um arquivo são mostradas
     sobre o console e inseridas dentro do arquivo UNLISP.  Quando
     `false', messagens sobre traduções de arquivos são somente
     inseridas dentro do arquivo UNLISP.


 -- Variável de opção: tr_float_can_branch_complex
     Valor padrão: `true'

     Diz ao tradutor Maxima-para-Lisp assumir que as funções `acos',
     `asin', `asec', e `acsc' podem retornar resultados complexos.

     O efeito ostensivo de `tr_float_can_branch_complex' é mostrado
     adiante.  Todavia, parece que esse sinalizador não tem efeito
     sobre a saída do tradutor.

     Quando isso for `true' então `acos(x)' será do modo `any' sempre
     que `x' for do modo `float' (como escolhido por `mode_declare').
     Quando `false' então `acos(x)' será do modo `float' se e somente
     se `x' for do modo `float'.


 -- Variável de opção: tr_function_call_default
     Valor padrão: `general'

     `false' significa abandonando e chamando `meval', `expr' significa
     que Lisp assume função de argumento fixado.  `general', o código
     padrão dado como sendo bom para `mexprs' e `mlexprs' mas não
     `macros'.  `general' garante que associações de variável são
     corretas em códigos compilados.  No modo `general', quando
     traduzindo F(X), se F for uma variável associada, então isso
     assumirá que `apply (f, [x])' é significativo, e traduz como tal,
     com o alerta apropriado.  Não é necessário desabilitar isso.  Com
     as escolhas padrão, sem mensagens de alerta implica
     compatibilidade total do código traduzido e compilado com o
     interpretador Maxima.


 -- Variável de opção: tr_numer
     Valor padrão: `false'

     Quando `tr_numer' for `true' propriedades `numer' são usadas para
     átomos que possuem essa propriedade, e.g. `%pi'.


 -- Variável de opção: tr_optimize_max_loop
     Valor padrão: 100

     `tr_optimize_max_loop' é número máximo de vezes do passo de
     macro-expansão e otimização que o tradutor irá executar
     considerando uma forma.  Isso é para capturar erros de expansão de
     macro, e propriedades de otimização não terminadas.


 -- Variável de opção: tr_semicompile
     Valor padrão: `false'

     Quando `tr_semicompile' for `true', as formas de saída de
     `translate_file' e `compfile' serão macroexpandidas mas não
     compiladas em código de máquina pelo compilador Lisp.


 -- Variável de sistema: tr_state_vars
     Valor padrão:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     A lista de comutadores que afetam a forma de saída da tradução.
     Essa informação é útil para sistemas populares quando tentam
     depurar o tradutor.  Comparando o produto traduzido para o qual
     pode ter sido produzido por um dado estado, isso é possível para
     rastrear erros.


 -- Função: tr_warnings_get ()
     Imprime uma lista de alertas que podem ter sido dadas pelo
     tradutor durante a tradução corrente.


 -- Variável de opção: tr_warn_bad_function_calls
     Valor padrão: `true'

     - Emite um alerta quando chamadas de função estão sendo feitas por
     um caminho que pode não ser correto devido a declarações
     impróprias que foram feitas em tempo de tradução.


 -- Variável de opção: tr_warn_fexpr
     Valor padrão: `compfile'

     - Emite um alerta se quaisquer FEXPRs forem encontradas.  FEXPRs
     não poderão normalmente ser saída em código traduzido, todas as
     formas de programa especial legítimo são traduzidas.


 -- Variável: tr_warn_meval
     Valor padrão: `compfile'

     - Emite um alerta se a função `meval' recebe chamadas.  Se `meval'
     é chamada isso indica problemas na tradução.


 -- Variável: tr_warn_mode
     Valor padrão: `all'

     - Emite um alerta quando a variáveis forem atribuídos valores
     inapropriados para seu modo.


 -- Variável de opção: tr_warn_undeclared
     Valor padrão: `compile'

     - Determina quando enviar alertas sobre variáveis não declaradas
     para o TTY.


 -- Variável de opção: tr_warn_undefined_variable
     Valor padrão: `all'

     - Emite um alerta quando variáveis globais indefinidas forem
     vistas.


 -- Variável de opção: tr_windy
     Valor padrão: `true'

     - Gera comentários "de grande ajuda" e dicas de programação.


 -- Função: compile_file (<filename>)
 -- Função: compile_file (<filename>, <compiled_filename>)
 -- Função: compile_file (<filename>, <compiled_filename>,
          <lisp_filename>)
     Traduz o arquivo Maxima <filename> para Lisp, executa o compilador
     Lisp, e, se a tradução e a compilação obtiverem sucesso, chama o
     código compilado dentro do Maxima.

     `compile_file' retorna uma lista dos nomes de quatro arquivos: o
     arquivo original do Maxima, o nome da tradução Lisp, uma arquivo
     de notas sobre a tradução, e o nome do arquivo que contém o código
     compilado.  Se a compilação falhar, o quarto item é `false'.

     Algumas declarações e definições passam a ter efeito tão logo o
     código Lisp seja compilado (sem que seja necessário chamar o
     código compilado).  Isso inclui funções definidas com o operador
     `:=', macros definidas com o operador `::=', `alias', `declare',
     `define_variable',  `mode_declare', e `infix', `matchfix',
     `nofix', `postfix', `prefix', e `compfile'.

     Atribuições e chamadas de função não serão avaliadas até que o
     código compilado seja carregado.  Em particular, dentro do arquivo
     Maxima, atribuições para sinalizadores traduzidos (`tr_numer',
     etc.) não têm efeito sobre a tradução.

     <filename> pode não conter declarações `:lisp'.

     `compile_file' avalia seus argumentos.


 -- Função: declare_translated (<f_1>, <f_2>, ...)
     Quando traduzindo um arquivo do código Maxima para Lisp, é
     importante para o programa tradutor saber quais funções no arquivo
     são para serem chamadas como funções traduzidas ou compiladas, e
     quais outras são apenas funções Maxima ou indefinidas.  Colocando
     essa declaração no topo do arquivo, faremos conhecido que embora
     um símbolo diga que não temos ainda um valor de função Lisp,
     teremos uma em tempo de chamada.  `(MFUNCTION-CALL fn arg1 arg2
     ...)' é gerado quando o tradutor n~ao sabe que `fn' está sendo
     compilada para ser uma função Lisp.



File: maxima.info,  Node: Fluxo de Programa,  Next: Depurando,  Prev: Definição de Função,  Up: Top

42 Fluxo de Programa
********************

* Menu:

* Introdução a Fluxo de Programa::
* Definições para Fluxo de Programa::


File: maxima.info,  Node: Introdução a Fluxo de Programa,  Next: Definições para Fluxo de Programa,  Prev: Fluxo de Programa,  Up: Fluxo de Programa

42.1 Introdução a Fluxo de Programa
===================================

Maxima fornece um `do' para ciclos iterativos, também contruções mais
primitivas tais como `go'.


File: maxima.info,  Node: Definições para Fluxo de Programa,  Prev: Introdução a Fluxo de Programa,  Up: Fluxo de Programa

42.2 Definições para Fluxo de Programa
======================================

 -- Função: backtrace ()
 -- Função: backtrace (<n>)
     Imprime a pilha de chamadas, que é, a lista de funções que foram
     chamadas pela função correntemente ativa.

     `backtrace()' imprime toda a pilha de chamadas.

     `backtrace (<n>)' imprime as <n> mais recentes chamadas a funções,
     incluindo a função correntemente ativa.

     `backtrace' pode ser chamada por um script, uma função, ou a
     partir da linha de comando interativa (não somente em um contexto
     de depuração).

     Exemplos:

        * `backtrace()' imprime toda a pilha de chamadas.

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        * `backtrace (<n>)' imprime as <n> mais recentes chamadas a
          funções, incluindo a função correntemente ativa.

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49


 -- Operador especial: do
     A declaração `do' é usada para executar iteração.  Devido à sua
     grande generalidade a declaração `do' será  descrita em duas
     partes.  Primeiro a forma usual será dada que é análoga à forma
     que é usada em muitas outras linguagens de programação (Fortran,
     Algol, PL/I, etc.); em segundo lugar os outros recursos serão
     mencionados.

     Existem três variantes do operador especial `do' que diferem
     somente por suas condições de encerramento.  São elas:

        * `for <Variável>: <valor_inicial> step <incremento>       thru
          <limite> do <corpo>'

        * `for <Variável>: <valor_inicial> step <incremento>
          while <condition> do <corpo>'

        * `for <Variável>: <valor_inicial> step <incremento>
          unless <condition> do <corpo>'

     (Alternativamente, o `step' pode ser dado após a condição de
     encerramento ou limite.)

     <valor_inicial>, <incremento>, <limite>, e <corpo> podem ser
     quaisquer expressões.  Se o incremento for 1 então "`step 1'" pode
     ser omitido.

     A execução da declaração `do' processa-se primeiro atribuindo o
     valor_inicial para a variável (daqui em diante chamada a variável
     de controle).  Então: (1) Se a variável de controle excede o
     limite de uma especificação `thru', ou se a condição de `unless'
     for `true', ou se a condição de `while' for `false' então o `do'
     será encerrado.  (2) O corpo é avaliado.  (3) O incremento é
     adicionado à variável de controle.  O processo de (1) a (3) é
     executado repetidamente até que a condição de encerramento seja
     satisfeita.  Pode-se também dar muitas condições de encerramento e
     nesse caso o `do' termina quando qualquer delas for satisfeita.

     Em geral o teste `thru' é satisfeito quando a variável de controle
     for maior que o limite se o incremento for não negativo, ou quando
     a variável de controle for menor que o limite se o incremento for
     negativo.  O incremento e o limite podem ser expressões não
     numéricas enquanto essa desigualdade puder ser determinada.
     Todavia, a menos que o incremento seja sintaticamente negativo
     (e.g. for um número negativo) na hora em que a declaração `do' for
     iniciada, Maxima assume que o incremento e o limite serão
     positivos quando o `do' for executado.  Se o limite e o incremento
     não forem positivos, então o `do' pode não terminar propriamente.

     Note que o limite, incremento, e condição de encerramento são
     avaliados cada vez que ocorre um ciclo.  Dessa forma se qualquer
     desses for responsável por muitos cálculos, e retornar um
     resultado que não muda durante todas as execuções do corpo, então
     é mais eficiente escolher uma variável para seu valor anterior
     para o `do' e usar essa variável na forma `do'.

     O valor normalmente retornado por uma declaração `do' é o átomo
     `done'.  Todavia, a função `return' pode ser usada dentro do corpo
     para sair da delcaração `do' prematuramente e dar a isso qualquer
     valor desejado.  Note todavia que um `return' dentro de um `do' que
     ocorre em um `block' encerrará somente o `do' e não o `block'.
     Note também que a função `go' não pode ser usada para sair de
     dentro de um `do' dentro de um `block' que o envolve.

     A variável de controle é sempre local para o `do' e dessa forma
     qualquer variável pode ser usada sem afetar o valor de uma
     variável com o mesmo nome fora da declaração `do'.  A variável de
     controle é liberada após o encerramento da declaração `do'.

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     Note que a condição `while i <= 10' é equivalente a `unless i >
     10' e também `thru 10'.

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     que fornece 8 termos da série de Taylor para `e^sin(x)'.

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     Esse exemplo calcula a raíz quadrada negativa de 10 usando a
     iteração de Newton- Raphson um maximum de 10 vezes.  Caso o
     critério de convergêcia não tenha sido encontrado o valor
     retornado pode ser `done'.  Em lugar de sempre adicionar uma
     quantidade à variável de controle pode-se algumas vezes desejar
     alterar isso de alguma outra forma para cada iteração.  Nesse caso
     pode-se usar `next <expressão>' em lugar de `step <incremento>'.
     Isso fará com que a variável de controle seja escolhida para o
     resultado da expressão de avaliação cada vez que o ciclo de
     repetição for executado.

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     Como uma alternativa para `for <Variável>: <valor> ...do...' a
     sintaxe `for <Variável> from <valor> ...do...'  pode ser usada.
     Isso permite o `from <valor>' ser colocado após o `step' ou
     proximo valor ou após a condição de encerramento.  Se `from
     <valor>' for omitido então 1 é usado como o valor inicial.

     Algumas vezes se pode estar interessado em executar uma iteração
     onde a variável de controle nunca seja usada.  Isso é permissível
     para dar somente as condições de encerramento omitindo a
     inicialização e a informação de atualização como no exemplo
     seguinte para para calcular a raíz quadrada de 5 usando uma fraca
     suposição inicial.

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     Se isso for desejado pode-se sempre omitir as condições de
     encerramento inteiramente e apenas dar o corpo `do <corpo>' que
     continuará a ser avaliado indefinidamente.  Nesse caso a função
     `return' será usada para encerrar a execução da declaração `do'.

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (Note que `return', quando executado, faz com que o valor corrente
     de `x' seja retornado como o valor da declaração `do'.  O `block'
     é encerrado e esse valor da declaração `do' é retornado como o
     valor do `block' porque o `do' é a última declaração do `block'.)

     Uma outra forma de `do' é disponível no Maxima.  A sintaxe é:

          for <Variável> in <list> <end_tests> do <corpo>

     Os elementos de <list> são quaisquer expressões que irão
     sucessivamente ser atribuídas para a variável a cada iteração do
     corpo.  O teste opcional <end_tests> pode ser usado para encerrar
     a execução da declaração `do'; de outra forma o `do' terminará
     quando a lista for exaurida ou quando um `return' for executado no
     corpo.  (De fato, a lista pode ser qualquer expressão não atômica,
     e partes sucessivas são usadas.)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816


 -- Função: errcatch (<expr_1>, ..., <expr_n>)
     Avalia <expr_1>, ..., <expr_n> uma por uma e retorna `[<expr_n>]'
     (uma lista) se nenhum erro ocorrer.  Se um erro ocorrer na
     avaliação de qualquer argumento, `errcatch' evita que o erro se
     propague e retorna a lista vazia `[]' sem avaliar quaisquer mais
     argumentos.

     `errcatch' é útil em arquivos `batch' onde se suspeita que um erro
     possa estar ocorrendo o `errcatch' terminará o `batch' se o erro
     não for detectado.


 -- Função: error (<expr_1>, ..., <expr_n>)
 -- Variável de sistema: error
     Avalia e imprime <expr_1>, ..., <expr_n>, e então causa um retorno
     de erro para o nível mais alto do Maxima ou para o mais próximo
     contendo `errcatch'.

     A variável `error' é escolhida para uma lista descrevendo o erro.
     O primeiro elemento de `error' é uma seqüência de caracteres de
     formato, que junta todas as seqüências de caracteres entre os
     argumentos <expr_1>, ..., <expr_n>, e os elementos restantes são
     os valores de quaisquer argumentos que não são seqüências de
     caracteres.

     `errormsg()' formata e imprime `error'.  Isso efetivamente
     reimprime a mais recente mensagem de erro.


 -- Função: errormsg ()
     Reimprime a mais recente mensagem de erro.  A variável `error'
     recebe a mensagem, e `errormsg' formata e imprime essa mensagem.


 -- Operador especial: for
     Usado em iterações.  Veja `do' para uma descrição das facilidades
     de iteração do Maxima.


 -- Função: go (<tag>)
     é usada dentro de um `block' para transferir o controle para a
     declaração do bloco que for identificada com o argumento para
     `go'.  Para identificar uma declaração, coloque antes dessa
     declaração um argumento atômico como outra declaração no `block'.
     Por exemplo:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     O argumento para `go' deve ser o nome de um identificardor
     aparecendo no mesmo `block'.  Não se pode usar `go' para
     transferir para um identificador em um outro `block' que não seja
     o próprio contendo o `go'.


 -- Operador especial: if
     A declaração `if' é usada para execução condicional.  A sintaxe é:

          if <condição> then <expr_1> else <expr_2>

     O resultado de uma declaração `if' será <expr_1> se condição for
     `true' e <expr_2> de outra forma.  <expr_1> e <expr_2> são
     quaisquer expressões Maxima (incluindo declarações `if'
     aninhadas), e <condição> é uma expressão que avalia para `true' ou
     `false' e é composto de operadores relacionais e lógicos que são
     os seguintes:

          Operação             Símbolo      Tipo

          menor que            <           infixo relacional
          menor que            <=
            ou igual a                     infixo relacional
          igualdade            =
            (sintática)                    infixo relacional
          negação de =         #           infixo relacional
          igualdade (valor)    equal       função relacional
          negação de           notequal
            igualdade                      função relacional
          maior que            >=
            ou igual a                     infixo relacional
          maior que            >           infixo relacional
          e                    and         infixo lógico
          ou                   or          infixo lógico
          não                  not         prefixo lógico


 -- Função: map (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma expressão cujo operador principal é o mesmo que o das
     expressões <expr_1>, ..., <expr_n> mas cujas subpartes são os
     resultados da aplicação de <f> nas correspondentes subpartes das
     expressões.  <f> é ainda o nome de uma função de n argumentos ou é
     uma forma `lambda' de n argumentos.

     `maperror' - se `false' fará com que todas as funções mapeadas (1)
     parem quando elas terminarem retornando a menor expi se não forem
     todas as expi do mesmo comprimento e (2) aplique fn a [exp1,
     exp2,...]  se expi não forem todas do mesmo tipo de objeto.  Se
     `maperror' for `true' então uma mensagem de erro será dada nas
     duas instâncias acima.

     Um dos usos dessa função é para mapear (`map') uma função (e.g.
     `partfrac') sobre cada termo de uma expressão muito larga onde
     isso comumente não poderia ser possível usar a função sobre a
     expressão inteira devido a uma exaustão de espaço da lista de
     armazenamento no decorrer da computação.

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]

 -- Função: mapatom (<expr>)
     Retorna `true' se e somente se <expr> for tratada pelas rotinas de
     mapeamento como um átomo.  "Mapatoms" são átomos, números
     (incluíndo números racioanais), e variáveis subscritas.


 -- Variável de opção: maperror
     Valor padrão: `true'

     Quando `maperror' é `false', faz com que todas as funções
     mapeadas, por exemplo

          map (f, expr_1, expr_2, ...))

     (1) parem quando elas terminarem retornando a menor expi se não
     forem todas as expi do mesmo comprimento e (2) aplique `f' a
     `[expr_1, expr_2, ...]' se `expr_i' não forem todas do mesmo tipo
     de objeto.

     Se `maperror' for `true' então uma ,mensagem de erro é mostrada
     nas duas instâncias acima.


 -- Função: maplist (<f>, <expr_1>, ..., <expr_n>)
     Retorna uma lista de aplicações de <f> em todas as partes das
     expressões <expr_1>, ..., <expr_n>.  <f> é o nome de uma função,
     ou uma expressão lambda.

     `maplist' difere de `map (<f>, <expr_1>, ..., <expr_n>)' que
     retorna uma expressão com o mesmo operador principal que <expr_i>
     tem (exceto para simplificações  e o caso onde `map' faz um
     `apply').


 -- Variável de opção: prederror
     Valor padrão: `true'

     Quando `prederror' for `true', uma mensagem de erro é mostrada
     sempre que o predicado de uma declaração `if' ou uma função `is'
     falha em avaliar ou para `true' ou para  `false'.

     Se `false', `unknown' é retornado no lugar nesse caso.  O modo
     `prederror: false' não é suportado no código traduzido; todavia,
     `maybe' é suportado no código traduzido.

     Veja também `is' e `maybe'.


 -- Função: return (valor)
     Pode ser usada para sair explicitamente de um bloco, levando seu
     argumento.  Veja `block' para mais informação.


 -- Função: scanmap (<f>, <expr>)
 -- Função: scanmap (<f>, <expr>, bottomup)
     Recursivamente aplica <f> a <expr>, de cima para baixo.  Isso é
     muito útil quando uma fatoração completa é desejada, por exemplo:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note o caminho através do qual `scanmap' aplica a dada função
     `factor' para as subexpressões constituintes de <expr>; se outra
     forma de <expr> é apresentada para `scanmap' então o resultado
     pode ser diferente.  Dessa forma, `%o2' não é recuperada quando
     `scanmap' é aplicada para a forma expandida de exp:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     Aqui está um outro exemplo do caminho no qual `scanmap' aplica
     recursivamente uma função dada para todas as subexpressões,
     incluindo expoentes:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     `scanmap (<f>, <expr>, bottomup)' aplica <f> a <expr> de baixo
     para cima.  E.g., para `f' indefinida,

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     Nesse caso, você pega a mesma resposta em ambos os caminhos.


 -- Função: throw (<expr>)
     Avalia <expr> e descarta o valor retornado para o mais recente
     `catch'.  `throw' é usada com `catch' como um mecanismo de retorno
     não local.


 -- Função: outermap (<f>, <a_1>, ..., <a_n>)
     Aplica a função <f> para cada um dos elementos do produto externo
     <a_1> vezes <a_2> ... vezes <a_n>.

     <f> é para ser o nome de uma função de n argumentos ou uma
     expressão lambda de n argumentos.  Os argumentos <a_1>, ..., <a_n>
     podem ser listas ou não listas.  Argumentos listas podem ter
     diferentes comprimentos.  Argumentos outros que não listas são
     tratados como listas de comprimento 1 para o propósito de
     construção do produto externo.

     O resultado da aplicação de <f> para o produto externo é
     organizado como uma lista aninhada.  A intensidade do aninhamento
     é igual ao número de argumentos listas (argumentos outros que não
     listas não contribuem com um nível de aninhamento).  Uma lista de
     intensidade de aninhamento k tem o mesmo comprimento que o k'ésimo
     argumento da lista.

     `outermap' avalia seus argumentos.

     Veja também `map', `maplist', e `apply'.

     Exemplos:

          (%i1) f (x, y) := x - y$
          (%i2) outermap (f, [2, 3, 5], [a, b, c, d]);
          (%o2) [[2 - a, 2 - b, 2 - c, 2 - d],
                [3 - a, 3 - b, 3 - c, 3 - d], [5 - a, 5 - b, 5 - c, 5 - d]]
          (%i3) outermap (lambda ([x, y], y/x), [55, 99], [Z, W]);
                                  Z   W     Z   W
          (%o3)                 [[--, --], [--, --]]
                                  55  55    99  99
          (%i4) g: lambda ([x, y, z], x + y*z)$
          (%i5) outermap (g, [a, b, c], %pi, [11, 17]);
          (%o5) [[a + 11 %pi, a + 17 %pi], [b + 11 %pi, b + 17 %pi],
                                                  [c + 11 %pi, c + 17 %pi]]
          (%i6) flatten (%);
          (%o6) [a + 11 %pi, a + 17 %pi, b + 11 %pi, b + 17 %pi,
                                                    c + 11 %pi, c + 17 %pi]



File: maxima.info,  Node: Depurando,  Next: Índice de Função e Variável,  Prev: Fluxo de Programa,  Up: Top

43 Depurando
************

* Menu:

* Depurando o Código Fonte::
* Comandos Palavra Chave::
* Definições para Depuração::


File: maxima.info,  Node: Depurando o Código Fonte,  Next: Comandos Palavra Chave,  Up: Depurando

43.1 Depurando o Código Fonte
=============================

Maxima tem um depurador interno de código fonte.  O usuário pode
escolher um ponto de parada em uma função, e então caminhar linha por
linha a partir daí.  A pilha de chamadas po ser examinada, juntamente
com as variáveis associadas àquele nível.

   O comando `:help' ou `:h' mostra a lista de comando de depuração.
(Em geral, comandos podem ser abreviados se a abreviação for única.  Se
não for única, as alternativas podem ser listadas.)  Dentro do
depurador, o usuário pode também usar qualquer funções comuns do Maxima
para examinar, definir, e manipular variáveis e expressões.

   Um ponto de parada é escolhido através do comando `:br' na linha de
comando do Maxima.  Dentro do depurador, o usuário pode avançar uma
linha de cada vez usando o comando `:n' ("next").  o comando `:bt'
("backtrace") mostra uma lista da pilha de frames.  O comando `:r'
("resume") sai do depurador e continua com a execução.  Esses comandos
são demostrados no exemplo abaixo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt digitado aqui lista os frames
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Aqui digite :n para avançar linha
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investiga o valor de u
     28

     (dbm:1) u: 33;                     <-- Altera u para ser 33
     33

     (dbm:1) :r                         <-- Digite :r para retomar a computação

     (%o2)                                1094

   O arquivo `/tmp/foobar.mac' é o seguinte:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USO DO DEPURADOR ATRAVÉS DO EMACS

   Se o usuário estiver rodando o código sob o GNU emacs em uma janela
shell (shel dbl), ou está rodando a versão de interface gráfica,
`xmaxima', então se ele para em um ponto de parada, ele verá sua
posição corrente no arquivo fonte a qua será mostrada na outra metade
da janela, ou em vermelho brilhante, ou com um pequeno seta apontando
na direita da linha.  Ele pode avançar uma linha por vez digitando M-n
(Alt-n).

   Sob Emacs você pode executar em um shell `dbl', o qual requer o
arquivo `dbl.el' no diretório elisp.  Tenha certeza que instalou os
arquivos elisp ou adicionou o diretório elisp do Macima ao seu caminho:
e.g., adicione o seguinte ao seu arquivo `.emacs' ou ao seu arquivo
`site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   então no emacs

     M-x dbl

   pode iniciar uma janela shell na qual você pode executar programas,
por exemplo Maxima, gcl, gdb etc.   Essa janela de shell também
reconhece informações sobre depuração de código fonte, e mostra o
código fonte em outra janela.

   O usuário pode escolher um ponto de parada em certa linha do arquivo
digitando `C-x space'.  Isso encontra qual a função que o cursor está
posicionado, e então mostra qual a linha daquela função que o cursor
está habilitado.   Se o cursor estiver habilitado, digamos, na linha 2
de `foo', então isso irá inserir na outra janela o comando, "`:br foo
2'", para parar `foo' nessa segunda linha.   Para ter isso habilitado,
o usuário deve ter maxima-mode.el habilitado na janela na qual o
arquivo `foobar.mac' estiver interagindo.  Existe comandos adicional
disponíveis naquela janela de arquivo, tais como avaliando a função
dentro do Maxima, através da digitação de `Alt-Control-x'.


File: maxima.info,  Node: Comandos Palavra Chave,  Next: Definições para Depuração,  Prev: Depurando o Código Fonte,  Up: Depurando

43.2 Comandos Palavra Chave
===========================

Comandos palavra chave são palavras chaves especiais que não são
interpretadas como expressões do Maxima.  Um comando palavra chave pode
ser inserido na linha de comando do Maxima ou na linha de comando do
depurador, embora não possa ser inserido na linha de comando de parada.
Comandos palavra chave iniciam com um dois pontos Keyword commands
start with a colon, ':'.  Por exemplo, para avaliar uma forma Lisp você
pode digitar `:lisp' seguido pela forma a ser avaliada.

     (%i1) :lisp (+ 2 3)
     5

   O número de argumentos tomados depende do comando em particular.
Também, você não precisa digitar o comando completo, apenas o
suficiente para ser único no meio das palavras chave de parada.   Dessa
forma `:br' será suficiente para `:break'.

   Os comandos de palavra chave são listados abaixo.

`:break F n'
     Escolhe um ponto de parada em uma função `F' na linha `n' a partir
     do início da função.  Se `F' for dado como uma seqüência de
     caracteres, então essa seqüência de caracteres é assumida
     referir-se a um arquivo, e `n' é o deslocamente a partir do início
     do arquivo.  O deslocamento é opcional. Se for omitido, é assumido
     ser zero (primeira linha da função ou do arquivo).

`:bt'
     Imprime na tela uma lista da pilha de frames

`:continue'
     Continua a computação

`:delete'
     Remove o ponto de parada selecionado, ou todos se nenum for
     especificado

`:disable'
     Desabilita os pontos de parada selecionados, ou todos se nenhum
     for especificado

`:enable'
     Habilita os pontos de de parada especificados, ou todos se nenhum
     for especificado

`:frame n'
     Imprime na tela a pilha de frame `n', ou o corrente frame se
     nenhum for especificado

`:help'
     Imprime na tela a ajuda sobre um comando do depurador, ou todos os
     comandos se nenhum for especificado

`:info'
     Imprime na tela informações sobre um item

`:lisp alguma-forma'
     Avalia `alguma-forma' como uma forma Lisp

`:lisp-quiet alguma-forma'
     Avalia a forma Lisp `alguma-forma' sem qualquer saída

`:next'
     Como `:step', exceto `:next' passos sobre chamadas de fução

`:quit'
     Sai do nível corrente do depurador sem concluir a computação

`:resume'
     Continua a computação

`:step'
     Continua a computação até encontraruma nova linha de códico

`:top'
     Retorne para a linha de comando do Maxima (saindo de qualquer
     nível do depurador) sem completar a computação


File: maxima.info,  Node: Definições para Depuração,  Prev: Comandos Palavra Chave,  Up: Depurando

43.3 Definições para Depuração
==============================

 -- Variável de opção: refcheck
     Valor padrão: `false'

     Quando `refcheck' for `true', Maxima imprime uma mensagem cada vez
     que uma variável associada for usada pela primeira vez em uma
     computação.


 -- Variável de opção: setcheck
     Valor padrão: `false'

     Se `setcheck' for escolhido para uma lista de variáveis (as quais
     podem ser subscritas), Maxima mostra uma mensagem quando as
     variáveis, ou ocorrências subscritas delas, forem associadas com o
     operador comum de atribuição `:', o operador `::' de atribuição,
     ou associando argumentos de função, mas não com o operador de
     atribuição de função `:=' nem o operador de atribuição `::=' de
     macro.  A mensagem compreende o nome das variáveis e o valor
     associado a ela.

     `setcheck' pode ser escolhida para `all' ou `true' incluindo desse
     modo todas as variáveis.

     Cada nova atribuição de `setcheck' estabelece uma nova lista de
     variáveis para verificar, e quaisquer variáveis previamente
     atribuídas a `setcheck' são esquecidas.

     Os nomes atribuídos a `setcheck' devem ter um apóstrofo no início
     se eles forem de outra forma avaliam para alguma outra coisa que
     não eles mesmo.  Por exemplo, se `x', `y', e `z' estiverem
     atualmente associados, então digite

          setcheck: ['x, 'y, 'z]$

     para colocá-los na lista de variáveis monitoradas.

     Nenhuma saída é gerada quando uma variável na lista `setcheck' for
     atribuída a sí mesma, e.g., `X: 'X'.


 -- Variável de opção: setcheckbreak
     Valor padrão: `false'

     Quando `setcheckbreak' for `true', Maxima mostrará um ponto de
     parada quando uma variável sob a lista `setcheck' for atribuída a
     um novo valor.  A parada ocorre antes que a atribuíção seja
     concluída.  Nesse ponto, `setval' retém o valor para o qual a
     variável está para ser atribuída.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setval'.


 -- Variável de sistema: setval
     Mantém o valor para o qual a variável está para ser escolhida
     quando um `setcheckbreak' ocorrer.  Conseqüentemente, se pode
     atribuir um valor diferente através da atribuição a `setval'.

     Veja também `setcheck' e `setcheckbreak'.


 -- Função: timer (<f_1>, ..., <f_n>)
 -- Função: timer ()
     Dadas as funções <f_1>, ..., <f_n>, `timer' coloca cada uma na
     lista de funções para as quais cronometragens estatísticas são
     coletadas.  `timer(f)$ timer(g)$' coloca `f' e então `g' sobre a
     lista; a lista acumula de uma chamada para a chamada seguinte.

     Sem argumentos, `timer' retorna a lista das funções tempo
     estatisticamente monitoradas.

     Maxima armazena quanto tempo é empregado executando cada função na
     lista de funções tempo estatisticamente monitoradas.  `timer_info'
     retorna a coronometragem estatística, incluindo o tempo médio
     decorrido por chamada de função, o número de chamadas, e o tempo
     total decorrido.  `untimer' remove funções da lista de funções
     tempo estatisticamente monitoradas.

     `timer' não avalia seus argumentos.  `f(x) := x^2$ g:f$ timer(g)$'
     não coloca `f' na lista de funções estatisticamente monitoradas.

     Se `trace(f)' está vigorando, então `timer(f)' não tem efeito;
     `trace' e `timer' não podem ambas atuarem ao mesmo tempo.

     Veja também `timer_devalue'.


 -- Função: untimer (<f_1>, ..., <f_n>)
 -- Função: untimer ()
     Dadas as funções <f_1>, ..., <f_n>, `untimer' remove cada uma das
     funções listadas da lista de funções estatisticamente monitoradas.

     Sem argumentos, `untimer' remove todas as funções atualmente na
     lista de funções estatisticamente monitoradas.

     Após `untimer (f)' ser executada, `timer_info (f)' ainda retorna
     estatisticas de tempo previamente coletadas, embora `timer_info()'
     (sem argumentos) não retorna informações sobre qualquer função que
     não estiver atualmente na lista de funções tempo estatisticamente
     monitoradas.  `timer (f)' reposiciona todas as estatisticas de
     tempo para zero e coloca `f' na lista de funções estatisticamente
     monitoradas novamente.


 -- Variável de opção: timer_devalue
     Valor Padrão: `false'

     Quando `timer_devalue' for `true', Maxima subtrai de cada função
     estatisticamente monitorada o tempo empregado em ou funções
     estatisticamente monitoradas. De outra forma, o tempo reportado
     para cada função inclui o tempo empregado em outras funções.  Note
     que tempo empregado em funções não estatisticamente monitoradas
     não é subtraído do tempo total.

     Veja também `timer' e `timer_info'.


 -- Função: timer_info (<f_1>, ..., <f_n>)
 -- Função: timer_info ()
     Dadas as funções <f_1>, ..., <f_n>, `timer_info' retorna uma
     matriz contendo informações de cronometragem para cada função.
     Sem argumentos, `timer_info' retorna informações de cronometragem
     para todas as funções atualmente na lista de funções
     estatisticamente monitoradas.

     A matriz retornada através de `timer_info' contém o nome da função,
     tempo por chamda de função, número de chamadas a funções,tempo
     total, e `gctime', cujja forma "tempo de descarte" no Macsyma
     original mas agora é sempre zero.

     Os dados sobre os quais `timer_info' constrói seu valor de retorno
     podem também serem obtidos através da função `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Veja também `timer'.


 -- Função: trace (<f_1>, ..., <f_n>)
 -- Função: trace ()
     Dadas as funções <f_1>, ..., <f_n>, `trace' instrui Maxima para
     mostrar informações de depuração quando essas funções forem
     chamadas.  `trace(f)$ trace(g)$' coloca `f' e então `g' na lista
     de funções para serem colocadas sob a ação de `trace'; a lista
     acumula de uma chamada para a seguinte.

     Sem argumentos, `trace' retorna uma lista de todas as funções
     atualmente sob a ação de `trace'.

     A função `untrace' desabilita a ação de `trace'.  Veja também
     `trace_options'.

     `trace' não avalia seus argumentos. Dessa forma, `f(x) := x^2$
     g:f$ trace(g)$' não coloca `f' sobre a lista de funções
     monitoradas por `trace'.

     Quando uma função for redefinida, ela é removida da lista de
     `timer'.  Dessa forma após `timer(f)$ f(x) := x^2$', a função `f'
     não mais está na lista de `timer'.

     Se `timer (f)' estiver em efeito, então `trace (f)' não está
     agindo; `trace' e `timer' não podem ambas estar agindo para a
     mesma função.


 -- Função: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Função: trace_options (<f>)
     Escolhe as opções de `trace' para a função <f>.  Quaisquer opções
     anteriores são substituídas.  `trace_options (<f>, ...)' não tem
     efeito a menos que `trace (<f>)' tenha sido também chamada (ou
     antes ou após `trace_options').

     `trace_options (<f>)' reposiciona todas as opções para seus
     valores padrão.

     As opções de palavra chave são:

        * `noprint' Não mostre uma mensagem na entrada da função e saia.

        * `break' Coloque um ponto de parada antes da função ser
          inserida, e após a funçãos er retirada. Veja `break'.

        * `lisp_print' Mostre argumentos e valores de retorno com
          objetos Lisp.

        * `info' Mostre `-> true' na entrada da funçào e saia.

        * `errorcatch' Capture os erros, fornecendo a opção para
          sinalizar um erro, tentar novamente a chamada de função, ou
          especificar um valor de retorno.

     Opções para `trace' são especificadas em duas formas. A presença
     da palavra chave de opção sozinha coloca a opção para ter efeito
     incondicionalmente.  (Note que opção <foo> não coloca para ter
     efeito especificando `<foo>: true' ou uma forma similar; note
     também que palavras chave não precisam estar com apóstrofo.)
     Especificando a opção palavra chave com uma função predicado torna
     a opção condicional sobre o predicado.

     A lista de argumentos para a função predicado é sempre `[level,
     direction, function, item]' onde `level' é o nível rerecursão para
     a função,  `direction' é ou `enter' ou `exit', `function' é o nome
     da função, e `item' é a lista de argumentos (sobre entrada) ou o
     valor de retorno (sobre a saída).

     Aqui está um exemplo de opções incondicionais de `trace':

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Aqui está a mesma função, com a opção `break' condicional sobre um
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Função: untrace (<f_1>, ..., <f_n>)
 -- Função: untrace ()
     Dadas as funções <f_1>, ..., <f_n>, `untrace' desabilita a a
     monitoração habilitada pela função `trace'.  Sem argumentos,
     `untrace' desabilita a atuação da função `trade' para todas as
     funções.

     `untrace' retorne uma lista das funções para as quais `untrace'
     desabilita a atuação de `trace'.




Local Variables:
coding: iso-8859-1
End:
