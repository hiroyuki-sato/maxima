This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para Contextos,  Prev: Contextos,  Up: Contextos

11.1 Definições para Contextos
==============================

 -- Função: activate (<context_1>, ..., <context_n>)
     Ativa os contextos <context_1>, ..., <context_n>.  Os fatos nesses
     contextos estão então disponíveis para fazer deduções e recuperar
     informação.  Os fatos nesses contextos não são listadas através de
     `facts ()'.

     A variável `activecontexts' é a lista de contextos que estão
     ativos pelo caminho da função `activate'.


 -- variável de sistema: activecontexts
     Valor padrão: `[]'

     `activecontexts' é a lista de contextos que estão ativos pelo
     caminho da função `activate', em oposição a sendo ativo porque
     eles são subcontextos do contexto corrente.


 -- Função: assume (<pred_1>, ..., <pred_n>)
     Adiciona predicados <pred_1>, ..., <pred_n> ao contexto corrente.
     Se um predicado for incossistente ou redundante com os predicados
     no contexto corrente, esses predicados não são adicionados ao
     contexto.  O contexto acumula predicados de cada chamada a
     `assume'.

     `assume' retorna uma lista cujos elementos são os predicados
     adicionados ao contexto ou os átomos `redundant' ou `inconsistent'
     onde for aplicável.

     Os predicados <pred_1>, ..., <pred_n> podem somente ser expressões
     com os operadores relacionais `< <= equal notequal >=' e `>'.
     Predicados não podem ser expressões de igualdades literais `=' ou
     expressões de desigualdades literais `#', nem podem elas serem
     funções de predicado tais como `integerp'.

     Predicados combinados da forma `<pred_1> and ... and <pred_n>' são
     reconhecidos, mas não `<pred_1> or ... or <pred_n>'.  `not
     <pred_k>' é reconhecidos se <pred_k> for um predicado relacional.
     Expressões da forma `not (<pred_1> and <pred_2>)' and `not
     (<pred_1> or <pred_2>)' não são reconhecidas.

     O mecanismo de dedução do Maxima não é muito forte; exitem
     conseqüências muito óbvias as quais não podem ser determinadas por
     meio de `is'.  Isso é uma fraqueza conhecida.

     `assume' avalia seus argumentos.

     Veja também `is', `facts', `forget', `context', e `declare'.

     Exemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Variável de opção: assumescalar
     Valor padrão: `true'

     `assumescalar' ajuda a governar se expressões `expr' para as quais
     `nonscalarp (expr)' for `false' são assumidas comportar-se como
     escalares para certas transformações.

     Tomemos `expr' representando qualquer expressão outra que não uma
     lista ou uma matriz, e tomemos `[1, 2, 3]' representando qualquer
     lista ou matriz.  Então `expr . [1, 2, 3]' retorna `[expr, 2 expr,
     3 expr]' se `assumescalar' for `true', ou `scalarp (expr)' for
     `true', ou `constantp (expr)' for `true'.

     Se `assumescalar' for `true', tais expressões irão comportar-se
     como escalares somente para operadores comutativos, mas não para
     multiplicação não comutativa `.'.

     Quando `assumescalar' for `false', tais expressões irão
     comportar-se como não escalares.

     Quando `assumescalar' for `all', tais expressões irão comportar-se
     como escalares para todos os operadores listados acima.


 -- Variável de opção: assume_pos
     Valor padrão: `false'

     Quando `assume_pos' for `true' e o sinal de um parâmetro <x> não
     pode ser determinado a partir do contexto corrente ou outras
     considerações, `sign' e `asksign (<x>)' retornam `true'.  Isso
     pode impedir algum questionamento de `asksign' gerado
     automaticamente, tal como pode surgir de `integrate' ou de outros
     cálculos.

     Por padrão, um parâmetro é <x> tal como `symbolp (<x>)' or
     `subvarp (<x>)'.  A classe de expressões consideradas parâmetros
     pode ser modificada para alguma abrangência através da variável
     `assume_pos_pred'.

     `sign' e `asksign' tentam deduzir o sinal de expressões a partir
     de sinais de operandos dentro da expressão.  Por exemplo, se `a' e
     `b' são ambos positivos, então `a + b' é também positivo.

     Todavia, não existe caminho para desviar todos os questionamentos
     de `asksign'.  Particularmente, quando o argumento de `asksign'
     for uma diferença `<x> - <y>' ou um logarítmo `log(<x>)',
     `asksign' sempre solicita uma entrada ao usuário, mesmo quando
     `assume_pos' for `true' e `assume_pos_pred' for uma função que
     retorna `true' para todos os argumentos.


 -- Variável de opção: assume_pos_pred
     Valor padrão: `false'

     Quando `assume_pos_pred' for atribuído o nome de uma função ou uma
     expressão lambda de um argumento <x>, aquela função é chamada para
     determinar se <x> é considerado um parâmetro para o propósito de
     `assume_pos'.  `assume_pos_pred' é ignorado quando `assume_pos'
     for `false'.

     A função `assume_pos_pred' é chamada através de `sign' e de
     `asksign' com um argumento <x> que é ou um átomo, uma variável
     subscrita, ou uma expressão de chamada de função.  Se a função
     `assume_pos_pred' retorna `true', <x> é considerado um parâmetro
     para o propósito de `assume_pos'.

     Por padrão, um parâmetro é <x> tal que `symbolp (x)' ou `subvarp
     (x)'.

     Veja também `assume' e `assume_pos'.

     Exemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Variável de opção: context
     Valor padrão: `initial'

     `context' nomeia a coleção de fatos mantida através de `assume' e
     `forget'.  `assume' adiciona fatos à coleção nomeada através de
     `context', enquanto `forget' remove fatos.

     Associando `context' para um nome <foo> altera o contexto corrente
     para <foo>.  Se o contexto especificado <foo> não existe ainda,
     ele é criado automaticamente através de uma chamada a `newcontext'.
     O contexto especificado é ativado automaticamente.

     Veja `contexts' para uma descrição geral do mecanismo de contexto.


 -- Variável de opção: contexts
     Valor padrão: `[initial, global]'

     `contexts' é uma lista dos contextos que existem atualmente,
     incluindo o contexto ativo atualmente.

     O mecanismo de contexto torna possível para um usuário associar e
     nomear uma porção selecionada de fatos, chamada um contexto.
     Assim que isso for concluído, o usuário pode ter o Maxima
     assumindo ou esquecendo grande quantidade de fatos meramente
     através da ativação ou desativação seu contexto.

     Qualquer átomo simbólico pode ser um contexto, e os fatos contidos
     naquele contexto irão ser retidos em armazenamento até que sejam
     destruídos um por um através de chamadas a `forget' ou destruídos
     com um conjunto através de uma chamada a `kill' para destruir o
     contexto que eles pertencem.

     Contextos existem em uma hierarquía, com o raíz sempre sendo o
     contexto `global', que contém informações sobre Maxima que alguma
     função precisa.  Quando em um contexto dado, todos os fatos naquele
     contexto estão "ativos" (significando que eles são usados em
     deduções e recuperados) como estão também todos os fatos em
     qualquer contexto que for um subcontexto do contexto ativo.

     Quando um novo Maxima for iniciado, o usuário está em um contexto
     chamado `initial', que tem `global' como um subcontexto.

     Veja também `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume', e `forget'.


 -- Função: deactivate (<context_1>, ..., <context_n>)
     Desativa os contextos especificados <context_1>, ..., <context_n>.


 -- Função: facts (<item>)
 -- Função: facts ()
     Se <item> for o nome de um contexto, `facts (<item>)' retorna uma
     lista de fatos no contexto especificado.

     Se <item> não for o nome de um contexto, `facts (<item>)' retorna
     uma lista de fatos conhecidos sobre <item> no contexto atual.
     Fatos que estão atuvos, mas em um diferente contexto, não são
     listados.

     `facts ()' (i.e., sem argumento) lista o contexto atual.


 -- Declaração: features
     Maxima recnhece ceertas propriedades matemáticas de funções e
     variáveis.  Essas são chamadas "recursos".

     `declare (<x>, <foo>)' fornece a propriedade <foo> para a função
     ou variável <x>.

     `declare (<foo>, recurso)' declara um novo recurso <foo>.  Por
     exemplo, `declare ([red, green, blue], feature)' declara três
     novos recursos, `red', `green', e `blue'.

     O predicado `featurep (<x>, <foo>)' retorna `true' se <x> possui a
     propriedade <foo>, e `false' de outra forma.

     A infolista `features' é uma lista de recursos conhecidos.  São
     esses `integer', `noninteger', `even', `odd', `rational',
     `irrational', `real', `imaginary', `complex', `analytic',
     `increasing', `decreasing', `oddfun', `evenfun', `posfun',
     `commutative', `lassociative', `rassociative', `symmetric', e
     `antisymmetric', mais quaisquer recursos definidos pelo usuário.

     `features' é uma lista de recursos matemáticos.  Existe também uma
     lista de recursos não matemáticos, recursos dependentes do
     sistema. Veja `status'.


 -- Função: forget (<pred_1>, ..., <pred_n>)
 -- Função: forget (<L>)
     Remove predicados estabelecidos através de `assume'.  Os
     predicados podem ser expressões equivalentes a (mas não
     necessáriamente idênticas a) esses prevamentes assumidos.

     `forget (<L>)', onde <L> é uma lista de predicados, esquece cada
     item da lista.


 -- Função: killcontext (<context_1>, ..., <context_n>)
     Mata os contextos <context_1>, ..., <context_n>.

     Se um dos contextos estiver for o contexto atual, o novo contexto
     atual irá tornar-se o primeiro subcontexto disponível do contexto
     atual que não tiver sido morto.  Se o primeiro contexto disponível
     não morto for `global' então `initial' é usado em seu lugar.  Se o
     contexto `initial' for morto, um novo, porém vazio contexto
     `initial' é criado.

     `killcontext' recusa-se a matar um contexto que estiver ativo
     atualmente, ou porque ele é um subcontexto do contexto atual, ou
     através do uso da função `activate'.

     `killcontext' avalia seus argumentos.  `killcontext' retorna
     `done'.


 -- Função: newcontext (<nome>)
     Cria um novo contexto, porém vazio, chamado <nome>, que tem
     `global' como seu único subcontexto.  O contexto recentemente
     criado torna-se o contexto ativo atualmente.

     `newcontext' avalia seu argumento.  `newcontext' retorna <nome>.


 -- Função: supcontext (<nome>, <context>)
 -- Função: supcontext (<nome>)
     Cria um novo contexto, chamado <nome>, que tem <context> como um
     subcontexto.  <context> deve existir.

     Se <context> não for especificado, o contexto atual é assumido.



File: maxima.info,  Node: Polinômios,  Next: Constantes,  Prev: Contextos,  Up: Top

12 Polinômios
*************

* Menu:

* Introdução a Polinômios::
* Definições para Polinômios::


File: maxima.info,  Node: Introdução a Polinômios,  Next: Definições para Polinômios,  Prev: Polinômios,  Up: Polinômios

12.1 Introdução a Polinômios
============================

Polinômios são armazenados no Maxima ou na forma geral ou na forma de
Expressões Racionais Canônicas (CRE).  Essa última é uma forma padrão,
e é usada internamente por operações tais como `factor', `ratsimp', e
assim por diante.

   Expressões Racionais Canônicas constituem um tipo de representação
que é especialmente adequado para polinômios expandidos e funções
racionais (também para polinômios parcialmente fatorados e funções
racionais quando RATFAC for escolhida para `true').  Nessa forma CRE uma
ordenação de variáveis (da mais para a menos importante) é assumida
para cada expressão.  Polinômios são representados recursivamente por
uma lista consistindo da variável principal seguida por uma série de
pares de expressões, uma para cada termo do polinômio.  O primeiro
membro de cada par é o expoente da variável principal naquele termo e o
segundo membro é o coeficiente daquele termo que pode ser um número ou
um polinômio em outra variável novamente respresentado nessa forma.
Sendo assim a parte principal da forma CRE de 3*X^2-1 é (X 2 3 0 -1) e
que a parte principal da forma CRE de 2*X*Y+X-3 é (Y 1 (X 1 2) 0 (X 1 1
0 -3)) assumindo Y como sendo a variável principal, e é (X 1 (Y 1 2 0
1) 0 -3) assumindo X como sendo a variável principal. A variável
principal é usualmente determineda pela ordem alfabética reversa.  As
"variáveis" de uma expressão CRE não necessariamente devem ser
atômicas.  De fato qualquer subexpressão cujo principal operador não
for + - * / or ^ com expoente inteiro será considerado uma "variável"
da expressão (na forma CRE) na qual essa ocorrer.  Por exemplo as
variáveis CRE da expressão X+SIN(X+1)+2*SQRT(X)+1 são X, SQRT(X), e
SIN(X+1).  Se o usuário não especifica uma ordem de variáveis pelo uso
da função RATVARS Maxima escolherá a alfabética por conta própria.  Em
geral, CREs representam expressões racionais, isto é, razões de
polinômios, onde o numerador e o denominador não possuem fatores
comuns, e o denominador for positivo.  A forma interna é essencialmente
um par de polinômios (o numerador e o denominador) precedidos pela
lista de ordenação de variável.  Se uma expressão a ser mostrada
estiver na forma CRE ou se contiver quaisquer subexpressões na forma
CRE, o símbolo /R/ seguirá o rótulo da linha.  Veja a função RAT para
saber como converter uma expressão para a forma CRE.  Uma forma CRE
extendida é usada para a representação de séries de Taylor.  A noção de
uma expressão racional é extendida de modo que os expoentes das
variáveis podem ser números racionais positivos ou negativos em lugar
de apenas inteiros positivos e os coeficientes podem eles mesmos serem
expressões racionais como descrito acima em lugar de apenas polinômios.
Estes são representados internamente por uma forma polinomial
recursiva que é similar à forma CRE e é a generalização dessa mesma
forma CRE, mas carrega informação adicional tal com o grau de
truncação.  Do mesmo modo que na forma CRE, o símbolo /T/ segue o
rótulo de linha que contém as tais expressões.


File: maxima.info,  Node: Definições para Polinômios,  Prev: Introdução a Polinômios,  Up: Polinômios

12.2 Definições para Polinômios
===============================

 -- Variável de opção: algebraic
     Valor Padrão: `false'

     `algebraic' deve ser escolhida para `true' com o objetivo de que a
     simplificação de inteiros algébricos tenha efeito.


 -- Variável de opção: berlefact
     Valor Padrão: `true'

     Quando `berlefact' for `false' então o algorítmo de fatoração de
     Kronecker será usado.  De outra forma o algorítmo de Berlekamp,
     que é o padrão, será usado.


 -- Função: bezout (<p1>, <p2>, <x>)
     uma alternativa para o comando `resultant'.  Isso retorna uma
     matriz.  `determinant' dessa matriz é o resultante desejado.


 -- Função: bothcoef (<expr>, <x>)
     Retorna uma lista da qual o primeiro membro é o coeficiente de <x>
     em <expr> (como achado por `ratcoef' se <expr> está na forma CRE
     de outro modo por `coeff') e cujo segundo membro é a parte
     restante de <expr>.  Isto é, `[A, B]' onde `<expr> = A*<x> + B'.

     Exemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  é (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Função: coeff (<expr>, <x>, <n>)
     Retorna o coeficiente de `<x>^<n>' em <expr>.  <n> pode ser
     omitido se for 1.  <x> pode ser um átomo, ou subexpressão completa
     de <expr> e.g., `sin(x)', `a[i+1]', `x + y', etc. (No último caso a
     expressão `(x + y)' pode ocorrer em <expr>).  Algumas vezes isso
     pode ser necessário para expandir ou fatorar <expr> com o objetivo
     de fazer `<x>^<n>' explicito.  Isso não é realizado por `coeff'.

     Exemplos:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1


 -- Função: combine (<expr>)
     Simplifica a adição <expr> por termos combinados com o mesmo
     denominador dentro de um termo simples.


 -- Função: content (<p_1>, <x_1>, ..., <x_n>)
     Retorna uma lista cujo primeiro elemento é o máximo divisor comum
     dos coeficientes dos termos do polinômio <p_1> na variável <x_n>
     (isso é o conteúdo) e cujo segundo elemento é o polinômio <p_1>
     dividido pelo conteúdo.

     Exemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Função: denom (<expr>)
     Retorna o denominador da expressão racional <expr>.


 -- Função: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     calcula o quocietne e o resto do polinômio <p_1> dividido pelo
     polinômio <p_2>, na variável principal do polinômio, <x_n>.  As
     outras variáveis são como na função `ratvars'.  O resultado é uma
     lista cujo primeiro elemento é o quociente e cujo segundo elemento
     é o resto.

     Exemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Note que `y' é a variável principal no segundo exemplo.


 -- Função: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variáveis de equações (ou expressões assumidas iguais a
     zero) pegando resultantes sucessivos. Isso retorna uma lista de
     `<n> - <k>' expressões com <k> variáveis <x_1>, ..., <x_k>
     eliminadas.  Primeiro <x_1> é eliminado retornando `<n> - 1'
     expressões, então `x_2' é eliminado, etc.  Se `<k> = <n>' então
     uma expressão simples em uma lista é retornada livre das variáveis
     <x_1>, ..., <x_k>.  Nesse caso `solve' é chamado para resolver a
     última resultante para a última variável.

     Exemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Função: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Retorna uma lista cujo primeiro elemento é o m.d.c. dos polinômios
     <p_1>, <p_2>, <p_3>, ...  e cujos restantes elementos são os
     polinômios divididos pelo mdc.  Isso sempre usa o algorítmo
     `ezgcd'.


 -- Variável de opção: facexpand
     Valor Padrão: `true'

     `facexpand' controla se os fatores irredutíveis retornados por
     `factor' estão na forma expandida (o padrão) ou na forma recursiva
     (CRE normal).


 -- Função: factcomb (<expr>)
     Tenta combinar os coeficientes de fatoriais em <expr> com os
     próprios fatoriais convertendo, por exemplo, `(n + 1)*n!' em `(n +
     1)!'.

     `sumsplitfact' se escolhida para `false' fará com que
     `minfactorial' seja aplicado após um `factcomb'.


 -- Função: factor (<expr>)
     Fatora a expressão <expr>, contendo qualquer número de variáveis
     ou funções, em fatores irredutíveis sobre os inteiros.  `factor
     (<expr>, p)' fatora <expr> sobre o campo dos inteiros com um
     elemento adjunto cujo menor polinômio é p.

     `factorflag' se `false' suprime a fatoração de fatores inteiros de
     expressões racionais.

     `dontfactor' pode ser escolhida para uma lista de variáveis com
     relação à qual fatoração não é para ocorrer.  (Essa é inicialmente
     vazia).  Fatoração também não acontece com relação a quaisquer
     variáveis que são menos importantes (usando a ordenação de
     variável assumida pela forma CRE) como essas na lista `dontfactor'.

     `savefactors' se `true' faz com que os fatores de uma expressão que
     é um produto de fatores seja guardada por certas funções com o
     objetivo de aumentar a velocidade de futuras fatorações de
     expressões contendo alguns dos mesmos fatores.

     `berlefact' se `false' então o algorítmo de fatoração de Kronecker
     será usado de outra forma o algorítmo de Berlekamp, que é o
     padrão, será usado.

     `intfaclim' é o maior divisor que será tentado quando fatorando um
     grande número inteiro.  Se escolhida para `false' (esse é o caso
     quando o usuário chama explicitamente `factor'), ou se o inteiro
     for um `fixnum' (i.e.  ajustado à paravra da máquina), a fatoração
     completa do inteiro será tentada.  A escolha do usuário para
     `intfaclim' é usada para chamadas internas para `factor'. Dessa
     forma, `intfaclim' pode ser colocado em zero para prevenir Maxima
     de gastar um tempo excessivamente fatorando grandes inteiros.

     Exemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Variável de opção: factorflag
     Valor Padrão: `false'

     Quando `factorflag' for `false', suprime a fatoração de fatores
     inteiros em expressões racionais.


 -- Função: factorout (<expr>, <x_1>, <x_2>, ...)
     Rearranja a adição <expr> em uma adição de parcelas da forma `f
     (<x_1>, <x_2>, ...)*g' onde `g' é um produto de expressões que não
     possuem qualquer <x_i> e `f' é fatorado.


 -- Função: factorsum (<expr>)
     Tenta agrupar parcelas em fatores de <expr> que são adições em
     grupos de parcelas tais que sua adição é fatorável.  `factorsum'
     pode recuperar o resultado de `expand ((x + y)^2 + (z + w)^2)' mas
     não pode recuperar `expand ((x + 1)^2 + (x + y)^2)' porque os
     termos possuem variáveis em comum.

     Exemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Função: fasttimes (<p_1>, <p_2>)
     Retorna o produto dos polinômios <p_1> e <p_2> usando um algorítmo
     especial para a multiplicação de polinômios.  `p_1' e `p_2' podem
     ser de várias variáveis, densos, e aproximadamente do mesmo
     tamanho.  A multiplicação clássica é de ordem `n_1 n_2' onde `n_1'
     é o grau de `p_1' and `n_2' é o grau de `p_2'.  `fasttimes' é da
     ordem `max (n_1, n_2)^1.585'.


 -- Função: fullratsimp (<expr>)
     `fullratsimp' aplica repetidamente `ratsimp' seguido por
     simplificação não racional a uma expressão até que nenhuma mudança
     adicional ocorra, e retorna o resultado.

     Quando expressões não racionais estão envolvidas, uma chamada a
     `ratsimp' seguida como é usual por uma simplificação não racional
     ("geral") pode não ser suficiente para retornar um resultado
     simplificado.  Algumas vezes, mais que uma tal chamada pode ser
     necessária.  `fullratsimp' faz esse processo convenientemente.

     `fullratsimp (<expr>, <x_1>, ..., <x_n>)' pega um ou mais
     argumentos similar a `ratsimp' e `rat'.

     Exemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Função: fullratsubst (<a>, <b>, <c>)
     é o mesmo que `ratsubst' exceto que essa chama a si mesma
     recursivamente sobre esse resultado até que o resultado para de
     mudar.  Essa função é útil quando a expressão de substituição e a
     expressão substituída tenham uma ou mais variáveis em comum.

     `fullratsubst' irá também aceitar seus argumentos no formato de
     `lratsubst'.  Isto é, o primeiro argumento pode ser uma
     substituição simples de equação ou uma lista de tais equações,
     enquanto o segundo argumento é a expressão sendo processada.

     `load ("lrats")' chama `fullratsubst' e `lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$

        * `subst' pode realizar multiplas substituições.  `lratsubst' é
          analogo a `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * Se somente uma substituição é desejada, então uma equação
          simples pode ser dada como primeiro argumento.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' é equivalente a `ratsubst' exceto que essa
          executa recursivamente até que seu resultado para de mudar.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' também aceita uma lista de equações ou uma
          equação simples como primeiro argumento.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' pode causar uma recursão infinita.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Função: gcd (<p_1>, <p_2>, <x_1>, ...)
     Retorna o máximo divisor comum entre <p_1> e <p_2>.  O sinalizador
     `gcd' determina qual algorítmo é empregado.  Escolhendo `gcd' para
     `ez', `eez', `subres', `red', ou `spmod' seleciona o algorítmo
     `ezgcd', Novo `eez' `gcd', `prs' subresultante, reduzido, ou
     modular, respectivamente.  Se `gcd' for `false' então
     GCD(p1,p2,var) irá sempre retornar 1 para todas as `var'iáveis.
     Muitas funções (e.g.  `ratsimp', `factor', etc.) fazem com que
     mdc's sejam feitos implicitamente.  Para polinômios homogêneos é
     recomendado que `gcd' igual a `subres' seja usado.  Para pegar o
     mdc quando uma expressão algébrica está presente, e.g.
     GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , `algebraic' deve ser `true' e
     `gcd' deve não ser `ez'.  `subres' é um novo algorítmo, e pessoas
     que tenham estado usando a opção `red' podem provavelmente alterar
     isso para `subres'.

     O sinalizador `gcd', padrão: `subres', se `false' irá também
     evitar o máximo divisor comum de ser usado quando expressões são
     convertidas para a forma de expressão racional canônica (CRE).
     Isso irá algumas vezes aumentar a velocidade dos cálculos se mdc's
     não são requeridos.


 -- Função: gcdex (<f>, <g>)
 -- Função: gcdex (<f>, <g>, <x>)
     Retornam uma lista `[<a>, <b>, <u>]' onde <u> é o máximo divisor
     comum (mdc) entre <f> e <g>, e <u> é igual a `<a> <f> + <b> <g>'.
     Os argumentos <f> e <g> podem ser polinômios de uma variável, ou
     de outra forma polinômios em <x> uma main(principal) variável
     suprida desde que nós precisamos estar em um domínio de ideal
     principal para isso trabalhar.  O mdc significa o mdc considerando
     <f> e <g> como polinômios de uma única variável com coeficientes
     sendo funções racionais em outras variáveis.

     `gcdex' implementa o algorítmo Euclideano, onde temos a seqüência
     of `L[i]: [a[i], b[i], r[i]]' que são todos perpendiculares a `[f,
     g, -1]' e o próximo se é construído como se `q =
     quotient(r[i]/r[i+1])' então `L[i+2]: L[i] - q L[i+1]', e isso
     encerra em `L[i+1]' quando o resto `r[i+2]' for zero.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     Note que o mdc adiante é `1' uma vez que trabalhamos em `k(y)[x]',
     o `y+1' não pode ser esperado em `k[y, x]'.

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1


 -- Função: gcfactor (<n>)
     Fatora o inteiro Gaussiano <n> sobre os inteiros Gaussianos, i.e.,
     números da forma `<a> + <b> `%i'' onde <a> e <b> são inteiros
     raconais (i.e.,  inteiros comuns).  Fatorações são normalizadas
     fazendo <a> e <b> não negativos.


 -- Função: gfactor (<expr>)
     Fatora o polinômio <expr> sobre os inteiros de Gauss (isto é, os
     inteiros com a unidade imaginária `%i' adjunta).  Isso é como
     `factor (<expr>, <a>^2+1)' trocando <a> por `%i'.

     Exemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Função: gfactorsum (<expr>)
     é similar a `factorsum' mas aplica `gfactor' em lugar de `factor'.


 -- Função: hipow (<expr>, <x>)
     Retorna o maior expoente explícito de <x> em <expr>.  <x> pode ser
     uma variável ou uma expressão geral.  Se <x> não aparece em <expr>,
     `hipow' retorna `0'.

     `hipow' não considera expressões equivalentes a `expr'.  Em
     particular, `hipow' não expande `expr', então `hipow (<expr>,
     <x>)' e `hipow (expand (<expr>, <x>))' podem retornar diferentes
     resultados.

     Exemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Variável de opção: intfaclim
     Valor Padrão: 1000

     `intfaclim' é o maior divisor que será tentado quando fatorando um
     grande número inteiro.

     Quando `intfaclim' for `false' (esse é o caso quando o usuáro
     chama `factor' explicitamente), ou se o inteiro é um `fixnum'
     (i.e., ajustado em uma palavra de máquina), fatores de qualquer
     tamanho são considerados.  `intfaclim' é escolhida para `false'
     fatores são calculados em `divsum', `totient', e `primep'.

     Chamadas internas a `factor' respeitam o valor especificado pelo
     usuário para `intfaclim'.  Escolhendo `intfaclim' para um pequeno
     valor podemos reduzir o tempo gasto fatorando grandes inteiros.


 -- Variável de opção: keepfloat
     Valor Padrão: `false'

     Quando `keepfloat' for `true', evitamos que números em ponto
     flutuante sejam racionalizados quando expressões que os possuem
     são então convertidas para a forma de expressão racional canônica
     (CRE).


 -- Função: lratsubst (<L>, <expr>)
     é análogo a `subst (<L>, <expr>)' exceto que esse usa `ratsubst'
     em lugar de `subst'.

     O primeiro argumento de `lratsubst' é uma equação ou uma lista de
     equações idênticas em formato para que sejam aceitas por `subst'.
     As substituições são feitas na ordem dada pela lista de equações,
     isto é, da esquerda para a direita.

     `load ("lrats")' chama `fullratsubst' e `lratsubst'.

     Exemplos:

          (%i1) load ("lrats")$

        * `subst' pode realizar multiplas substituições.  `lratsubst' é
          analoga a `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * Se somente uma substituição for desejada, então uma equação
          simples pode ser dada como primeiro argumento.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Variável de opção: modulus
     Valor Padrão: `false'

     Quando `modulus' for um número positivo <p>, operações sobre os
     números racionais (como retornado por `rat' e funções relacionadas)
     são realizadas módulo <p>, usando o então chamado sistema de
     módulo "balanceado" no qual `<n> módulo <p>' é definido como um
     inteiro <k> em `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' quando <p>
     for ímpar, ou `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' quando <p> for
     par, tal que `<a> <p> + <k>' seja igual a <n> para algum inteiro
     <a>.

     Se <expr> já estiver na forma de expressão racional canônica (CRE)
     quando `modulus' for colocado em seu valor original, então você
     pode precisar repetir o rat <expr>, e.g., `expr: rat (ratdisrep
     (expr))', com o objetivo de pegar resultados corretos.

     Tipicamente `modulus' é escolhido para um número primo.  Se
     `modulus' for escolhido para um inteiro não primo positivo, essa
     escolha é aceita, mas uma mensagem de alerta é mostrada.  Maxima
     permitirá que zero ou um inteiro negativo seja atribuído a
     `modulus', embora isso não seja limpo se aquele tiver quaisquer
     conseqüências úteis.


 -- Função: num (<expr>)
     Retorna o numerador de <expr> se isso for uma razão.  Se <expr>
     não for uma razão, <expr> é retornado.

     `num' avalia seu argumento.


 -- Função: polydecomp (<p>, <x>)
     Decompões o polinômio <p> na variável  <x> em uma composição
     funcional de polinômios em <x>.  `polydecomp' retorna uma lista
     `[<p_1>, ..., <p_n>]' tal que

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))

     seja igual a <p>.  O grau de <p_i> é maior que 1 para <i> menor
     que <n>.

     Tal decomposição não é única.

     Exemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     As seguintes funções compõem `L = [e_1, ..., e_n]' como funções em
     `x'; essa funçào é a inversa de `polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Re-exprimindo o exemplo acima usando `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Note que apesar de `compose (polydecomp (<p>, <x>), <x>)' sempre
     retornar <p> (não expandido), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)' não necessáriamente retorna `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Função: quotient (<p_1>, <p_2>)
 -- Função: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o polinômio <p_1> dividido pelo polinômio <p_2>.  Os
     argumentos <x_1>, ..., <x_n> são interpretados como em `ratvars'.

     `quotient' retorna o primeiro elemento de uma lista de dois
     elementos retornada por `divide'.


 -- Função: rat (<expr>)
 -- Função: rat (<expr>, <x_1>, ..., <x_n>)
     Converte <expr> para a forma de expressão racional canônica (CRE)
     expandindo e combinando todos os termos sobre um denominador comum
     e cancelando para fora o máximo divisor comum entre o numerador e
     o denominador, também convertendo números em ponto flutuante para
     números racionais dentro da tolerância de `ratepsilon'.  As
     variáveis são ordenadas de acordo com <x_1>, ..., <x_n>, se
     especificado, como em `ratvars'.

     `rat' geralmente não simplifica funções outras que não sejam
     adição `+', subtração `-', multiplicação `*', divisão `/', e
     exponenciação com expoente inteiro, uma vez que `ratsimp' não
     manuseia esses casos.  Note que átomos (números e variáveis) na
     forma CRE não são os mesmos que eles são na forma geral.  Por
     exemplo, `rat(x)- x' retorna `rat(0)' que tem uma representação
     interna diferente de 0.

     Quando `ratfac' for `true', `rat' retorna uma forma parcialmente
     fatorada para CRE.  Durante operações racionais a expressão é
     mantida como totalmente fatorada como possível sem uma chamada ao
     pacote de fatoração (`factor').  Isso pode sempre economizar
     espaço de memória e algum tempo em algumas computações.  O
     numerador e o denominador são ainda tidos como relativamente primos
     (e.g.  `rat ((x^2 - 1)^4/(x + 1)^2)' retorna `(x - 1)^4 (x +
     1)^2)', mas os fatores dentro de cada parte podem não ser
     relativamente primos.

     `ratprint' se `false' suprime a impressão de mensagens informando
     o usuário de conversões de números em ponto flutuante para números
     racionais.

     `keepfloat' se `true' evita que números em ponto flutuante sejam
     convertidos para números racionais.

     Veja também `ratexpand' e  `ratsimp'.

     Exemplos:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Variável de opção: ratalgdenom
     Valor Padrão: `true'

     Quando `ratalgdenom' for `true', permite racionalização de
     denominadores com respeito a radicais tenham efeito.
     `ratalgdenom' tem efeito somente quando expressões racionais
     canônicas (CRE) forem usadas no modo algébrico.


 -- Função: ratcoef (<expr>, <x>, <n>)
 -- Função: ratcoef (<expr>, <x>)
     Retorna o coeficiente da expressão `<x>^<n>' dentro da expressão
     <expr>.  Se omitido, <n> é assumido ser 1.

     O valor de retorno está livre (exceto possivelmente em um senso
     não racional) das variáveis em <x>.  Se nenhum coeficiente desse
     tipo existe, 0 é retornado.

     `ratcoef' expande e simplifica racionalmente seu primeiro
     argumento e dessa forma pode produzir respostas diferentes das de
     `coeff' que é puramente sintática.  Dessa forma
     RATCOEF((X+1)/Y+X,X) retorna (Y+1)/Y ao passo que `coeff' retorna
     1.

     `ratcoef (<expr>, <x>, 0)', visualiza <expr> como uma adição,
     retornando uma soma desses termos que não possuem <x>.  portanto
     se <x> ocorre para quaisquer expoentes negativos, `ratcoef' pode
     não ser usado.

     Uma vez que <expr> é racionalmente simplificada antes de ser
     examinada, coeficientes podem não aparecer inteiramente no caminho
     que eles foram pensados.

     Exemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Função: ratdenom (<expr>)
     Retorna o denominador de <expr>, após forçar a conversão de <expr>
     para expressão racional canônica (CRE).  O valor de retorno é a
     CRE.

     <expr> é forçada para uma CRE por `rat' se não for já uma CRE.
     Essa conversão pode mudar a forma de <expr> colocando todos os
     termos sobre um denominador comum.

     `denom' é similar, mas retorna uma expressão comum em lugar de uma
     CRE.  Também, `denom' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por `ratdenom' não são consideradas razões por
     `denom'.


 -- Variável de opção: ratdenomdivide
     Valor Padrão: `true'

     Quando `ratdenomdivide' for `true', `ratexpand' expande uma razão
     cujo o numerador for uma adição dentro de uma soma de razões,
     tendo todos um denominador comum.  De outra forma, `ratexpand'
     colapsa uma adição de razões dentro de uma razão simples, cujo
     numerador seja a adição dos numeradores de cada razão.

     Exemplos:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Função: ratdiff (<expr>, <x>)
     Realiza a derivação da expressão racional <expr> com relação a <x>.
     <expr> deve ser uma razão de polinômios ou um polinômio em <x>.  O
     argumento <x> pode ser uma variável ou uma subexpressão de <expr>.

     O resultado é equivalente a `diff', embora talvez em uma forma
     diferente.  `ratdiff' pode ser mais rápida que `diff', para
     expressões racionais.

     `ratdiff' retorna uma expressão racional canônica (CRE) se `expr'
     for uma CRE.  De outra forma, `ratdiff' retorna uma expressão
     geral.

     `ratdiff' considera somente as dependências de <expr> sobre <x>, e
     ignora quaisquer dependências estabelecidas por `depends'.

     Exemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Função: ratdisrep (<expr>)
     Retorna seu argumento como uma expressão geral.  Se <expr> for uma
     expressão geral, é retornada inalterada.

     Tipicamente `ratdisrep' é chamada para converter uma expressão
     racional canônica (CRE) em uma expressão geral.  Isso é algumas
     vezes conveniente se deseja-se parar o "contágio", ou caso se
     esteja usando funções racionais em contextos não racionais.

     Veja também `totaldisrep'.


 -- Variável de opção: ratepsilon
     Valor Padrão: 2.0e-8

     `ratepsilon' é a tolerância usada em conversões de números em
     ponto flutuante para números racionais.


 -- Função: ratexpand (<expr>)
 -- Variável de opção: ratexpand
     Expande <expr> multiplicando para fora produtos de somas e somas
     exponenciadas, combinando frações sobre um denominador comum,
     cancelando o máximo divisor comum entre entre o numerador e o
     denominador, então quebrando o numerador (se for uma soma) dentro
     de suas respectivas parcelas divididas pelo denominador.

     O valor de retorno de `ratexpand' é uma expressão geral, mesmo se
     <expr> for uma expressão racional canônica (CRE).

     O comutador `ratexpand' se `true' fará com que expressões CRE
     sejam completamente expandidas quando forem convertidas de volta
     para a forma geral ou mostradas, enquanto se for `false' então
     elas serão colocadas na forma recursiva.  Veja também `ratsimp'.

     Quando `ratdenomdivide' for `true', `ratexpand' expande uma razão
     na qual o numerador é uma adição dentro de uma adição de razões,
     todas tendo um denominador comum.  De outra forma, `ratexpand'
     contrai uma soma de razões em uma razão simples, cujo numerador é
     a soma dos numeradores de cada razão.

     Quando `keepfloat' for `true', evita que números em ponto
     flutuante sejam racionalizados quando expressões que contenham
     números em ponto flutuante forem convertidas para a forma de
     expressão racional canônica (CRE).

     Exemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Variável de opção: ratfac
     Valor Padrão: `false'

     Quando `ratfac' for `true', expressões racionais canônicas (CRE)
     são manipuladas na forma parcialmente fatorada.

     Durante operações racionais a expressão é mantida como
     completamente fatorada como foi possível sem chamadas a `factor'.
     Isso pode sempre economizar espaço e pode economizar tempo em
     algumas computações.  O numerador e o denominador são feitos
     relativamente primos, por exemplo `rat ((x^2 - 1)^4/(x + 1)^2)'
     retorna `(x - 1)^4 (x + 1)^2)', mas o fator dentro de cada parte
     pode não ser relativamente primo.

     No pacote `ctensor' (Manipulação de componentes de tensores),
     tensores de Ricci, Einstein, Riemann, e de Weyl e a curvatura
     escalar são fatorados automaticamente quando `ratfac' for `true'.
     `ratfac' pode somente ser escolhido para casos onde as componentes
     tensoriais sejam sabidametne consistidas de poucos termos.

     Os esquemas de `ratfac' e de `ratweight' são incompatíveis e não
     podem ambos serem usados ao mesmo tempo.


 -- Função: ratnumer (<expr>)
     Retorna o numerador de <expr>, após forçar <expr> para uma
     expressão racional canônica (CRE).  O valor de retorno é uma CRE.

     <expr> é forçada para uma CRE por `rat' se isso não for já uma CRE.
     Essa conversão pode alterar a forma de <expr> pela colocação de
     todos os termos sobre um denominador comum.

     `num' é similar, mas retorna uma expressão comum em lugar de uma
     CRE.  Também, `num' não tenta colocar todos os termos sobre um
     denominador comum, e dessa forma algumas expressões que são
     consideradas razões por `ratnumer' não são consideradas razões por
     `num'.


 -- Função: ratnump (<expr>)
     Retorna `true' se <expr> for um inteiro literal ou razão de
     inteiros literais, de outra forma retorna `false'.


 -- Função: ratp (<expr>)
     Retorna `true' se <expr> for uma expressão racional canônica (CRE)
     ou CRE extendida, de outra forma retorna `false'.

     CRE são criadas por `rat' e funções relacionadas.  CRE extendidas
     são criadas por `taylor' e funções relacionadas.


 -- Variável de opção: ratprint
     Valor Padrão: `true'

     Quando `ratprint' for `true', uma mensagem informando ao usuário
     da conversão de números em ponto flutuante para números racionais
     é mostrada.


 -- Função: ratsimp (<expr>)
 -- Função: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica a expressão <expr> e todas as suas subexpressões,
     incluindo os argumentos para funções não racionais.  O resultado é
     retornado como o quociente de dois polinômios na forma recursiva,
     isto é, os coeficientes de variável principal são polinômios em
     outras variáveis.  Variáveis podem incluir funções não racionais
     (e.g., `sin (x^2 + 1)') e os argumentos para quaisquer tais
     funções são também simplificados racionalmente.

     `ratsimp (<expr>, <x_1>, ..., <x_n>)' habilita simplificação
     racional com a especiicação de variável ordenando como em
     `ratvars'.

     Quando `ratsimpexpons' for `true', `ratsimp' é aplicado para os
     expoentes de expressões durante a simplificação.

     Veja também `ratexpand'.  Note que `ratsimp' é afetado por algum
     dos sinalizadores que afetam `ratexpand'.

     Exemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Variável de opção: ratsimpexpons
     Valor Padrão: `false'

     Quando `ratsimpexpons' for `true', `ratsimp' é aplicado para os
     expoentes de expressões durante uma simplificação.


 -- Função: ratsubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c> e retorna a expressão resultante.
     <b> pode também ser uma adição, produto, expoente, etc.

     `ratsubst' sabe alguma coisa do significado de expressões uma vez
     que `subst' não é uma substituição puramente sintática.  Dessa
     forma `subst (a, x + y, x + y + z)' retorna `x + y + z' ao passo
     que `ratsubst' retorna `z + a'.

     Quando `radsubstflag' for `true', `ratsubst' faz substituição de
     radicais em expressões que explicitamente não possuem esses
     radicais.

     Exemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Função: ratvars (<x_1>, ..., <x_n>)
 -- Função: ratvars ()
 -- Variável de sistema: ratvars
     Declara variáveis principais <x_1>, ..., <x_n> para expressões
     racionais.  <x_n>, se presente em uma expressão racional, é
     considerada a variável principal.  De outra forma, <x_[n-1]> é
     considerada a variável principal se presente, e assim por diante
     até as variáveis precedentes para <x_1>, que é considerada a
     variável principal somente se nenhuma das variáveis que a sucedem
     estiver presente.

     Se uma variável em uma expressão racional não está presente na
     lista `ratvars', a ela é dada uma prioridade menor que <x_1>.

     Os argumentos para `ratvars' podem ser ou variáveis ou funções não
     racionais tais como `sin(x)'.

     A variável `ratvars' é uma lista de argumentos da função `ratvars'
     quando ela foi chamada mais recentemente.  Cada chamada para a
     função `ratvars' sobre-grava a lista apagando seu conteúdo
     anterior.  `ratvars ()' limpa a lista.


 -- Função: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Função: ratweight ()
     Atribui um peso <w_i> para a variável <x_i>.  Isso faz com que um
     termo seja substituído por 0 se seu peso exceder o valor da
     variável `ratwtlvl' (o padrão retorna sem truncação).  O peso de
     um termo é a soma dos produtos dos pesos de uma variável no termo
     vezes seu expoente.  Por exemplo, o peso de `3 x_1^2 x_2' é `2 w_1
     + w_2'.  A truncação de acordo com `ratwtlvl' é realizada somente
     quando multiplicando ou exponencializando expressões racionais
     canônicas (CRE).

     `ratweight ()' retorna a lista cumulativa de atribuições de pesos.

     Nota: Os esquemas de `ratfac' e `ratweight' são incompatíveis e
     não podem ambo serem usados ao mesmo tempo.

     Exemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- Variável de sistema: ratweights
     Valor Padrão: `[]'

     `ratweights' é a lista de pesos atribuídos por `ratweight'.  A
     lista é cumulativa: cada chamada a `ratweight' coloca ítens
     adicionais na lista.

     `kill (ratweights)' e `save (ratweights)' ambos trabalham como
     esperado.


 -- Variável de opção: ratwtlvl
     Valor Padrão: `false'

     `ratwtlvl' é usada em combinação com a função `ratweight' para
     controlar a truncação de expressão racionais canônicas (CRE).
     Para o valor padrão `false', nenhuma truncação ocorre.


 -- Função: remainder (<p_1>, <p_2>)
 -- Função: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Retorna o resto do polinômio <p_1> dividido pelo polinômio <p_2>.
     Os argumentos <x_1>, ..., <x_n> são interpretados como em
     `ratvars'.

     `remainder' retorna o segundo elemento de uma lista de dois
     elementos retornada por `divide'.


 -- Função: resultant (<p_1>, <p_2>, <x>)
 -- Variável: resultant
     Calcula o resultante de dois polinômios <p_1> e <p_2>, eliminando
     a variável <x>.  O resultante é um determinante dos coeficientes
     de <x> em <p_1> e <p_2>, que é igual a zero se e somente se <p_1>
     e <p_2> tiverem um fator em comum não constante.

     Se <p_1> ou <p_2> puderem ser fatorados, pode ser desejável chamar
     `factor' antes de chamar `resultant'.

     A variável `resultant' controla que algorítmo será usado para
     calcular o resultante.  `subres' para o prs subresultante, `mod'
     para o algorítmo resultante modular, e `red' para prs reduzido.
     Para muitos problemas `subres' pode ser melhor.  Para alguns
     problemas com valores grandes de grau de uma única variável ou de
     duas variáveis `mod' pode ser melhor.

     A função `bezout' pega os mesmos argumentos que `resultant' e
     retorna uma matriz.  O determinante do valor de retorno é o
     resultante desejado.


 -- Variável de opção: savefactors
     Valor Padrão: `false'

     Quando `savefactors' for `true', faz com que os fatores de uma
     expressão que é um produto de fatores sejam gravados por certas
     funções com o objetivo de aumentar a velocidade em posteriores
     fatorações de expressões contendo algum desses mesmos fatores.


 -- Função: sqfr (<expr>)
     é similar a `factor' exceto que os fatores do polinômio são
     "livres de raízes".  Isto é, eles possuem fatores somente de grau
     um.  Esse algorítmo, que é também usado no primeiro estágio de
     `factor', utiliza o fato que um polinômio tem em comum com sua
     n'ésima derivada todos os seus fatores de grau maior que n.  Dessa
     forma pegando o maior divisor comum com o polinômio das derivadas
     com relação a cada variável no polinômio, todos os fatores de grau
     maior que 1 podem ser achados.

     Exemplo:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)


 -- Função: tellrat (<p_1>, ..., <p_n>)
 -- Função: tellrat ()
     Adiciona ao anel dos inteiros algébricos conhecidos do Maxima os
     elementos que são as soluções dos polinômios <p_1>, ..., <p_n>.
     Cada argumento <p_i> é um polinômio concoeficientes inteiros.

     `tellrat (<x>)' efetivamente significa substituir 0 por <x> em
     funções racionais.

     `tellrat ()' retorna uma lista das substituições correntes.

     `algebraic' deve ser escolhida para `true' com o objetivo de que a
     simplificação de inteiros algébricos tenha efeito.

     Maxima inicialmente sabe sobre a unidade imaginária `%i' e todas
     as raízes de inteiros.

     Existe um comando `untellrat' que pega kernels (núcleos) e remove
     propriedades `tellrat'.

     Quando fazemos `tellrat' em um polinômio de várias variáveis,
     e.g., `tellrat (x^2 - y^2)', pode existir uma ambigüidade como para
     ou substituir `<y>^2' por `<x>^2' ou vice-versa.  Maxima seleciona
     uma ordenação particular, mas se o usuário desejar especificar
     qual e.g.  `tellrat (y^2 = x^2)' forneçe uma sintaxe que diga para
     substituir `<y>^2' por `<x>^2'.

     Exemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Função: totaldisrep (<expr>)
     Converte toda subexpressão de <expr> da forma de expressão
     racionais canônicas (CRE) para a forma geral e retorna o resultado.
     Se <expr> é em sí mesma na forma CRE então `totaldisrep' é
     identica a `ratdisrep'.

     `totaldisrep' pode ser usada para fazer um `ratdisrep' em
     expressões tais como equações, listas, matrizes, etc., que tiverem
     algumas subexpressões na forma CRE.


 -- Função: untellrat (<x_1>, ..., <x_n>)
     Remove propriedades `tellrat' de <x_1>, ..., <x_n>.



File: maxima.info,  Node: Constantes,  Next: Logarítmos,  Prev: Polinômios,  Up: Top

13 Constantes
*************

* Menu:

* Definições para Constantes::


File: maxima.info,  Node: Definições para Constantes,  Prev: Constantes,  Up: Constantes

13.1 Definições para Constantes
===============================

 -- Constante: %e
     - A base dos logarítmos naturais, e, é representada no Maxima como
     `%e'.


 -- Constante: false
     - a contante Booleana, falso.  (NIL em Lisp)


 -- Constante: inf
     - infinito positivo real.


 -- Constante: infinity
     - infinito complexo.


 -- Constante: minf
     - menos infinito real.


 -- Constante: %pi
     - "pi" é representado no Maxima como `%pi'.


 -- Constante: true
     - a constante Booleana, verdadeiro.  (T em Lisp)



File: maxima.info,  Node: Logarítmos,  Next: Trigonometria,  Prev: Constantes,  Up: Top

14 Logarítmos
*************

* Menu:

* Definições para Logarítmos::


File: maxima.info,  Node: Definições para Logarítmos,  Prev: Logarítmos,  Up: Logarítmos

14.1 Definições para Logarítmos
===============================

 -- Variável de opção: %e_to_numlog
     Valor padrão: `false'

     Quando `true', sendo `r' algum número racional, e `x' alguma
     expressão, `%e^(r*log(x))' irá ser simplificado em `x^r' .
     Note-se que o comando `radcan' também faz essa transformação, e
     transformações mais complicadas desse tipo também.  O comando
     `logcontract' "contrai" expressões contendo `log'.


 -- Função: li [<s>] (<z>)
     Representa a função polilogarítmo de ordem <s> e argumento <z>,
     definida por meio de séries infinitas

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' é `- log (1 - z)'.  `li [2]' e `li [3]' são as funções
     dilogarítmo e trilogarítmo, respectivamente.

     Quando a ordem for 1, o polilogarítmo simplifica para `- log (1 -
     z)', o qual por sua vez simplifica para um valor numérico se <z>
     for um número em ponto flutuante real ou complexo ou o sinalizador
     de avaliação `numer' estiver presente.

     Quando a ordem for 2 ou 3, o polilogarítmo simplifica para um
     valor numérico se <z> for um número real em ponto flutuante ou o
     sinalizador de avaliação `numer' estiver presente.

     Exemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Função: log (<x>)
     Representa o logarítmo natural (base e) de <x>.

     Maxima não possui uma função interna para logarítmo de base 10 ou
     de outras bases. `log10(x) := log(x) / log(10)' é uma definição
     útil.

     Simplificação e avaliação de logarítmos são governadas por muitos
     sinalizadores globais:

     `logexpand' - faz com que `log(a^b)' torne-se `b*log(a)'.  Se
     `logexpand' for escolhida para `all', `log(a*b)' irá também
     simplificar para `log(a)+log(b)'.  Se `logexpand' for escolhida
     para `super', então `log(a/b)' irá também simplificar para
     `log(a)-log(b)' para números racionais `a/b', `a#1'.  (`log(1/b)',
     para `b' inteiro, sempre simplifica).  Se `logexpand' for
     escolhida para `false', todas essas simplificações irão ser
     desabilitadas.

     `logsimp' - se `false' então nenhuma simplificação de `%e' para um
     expoente contendo `log''s é concluída.

     `lognumer' - se `true' então argumentos negativos em ponto
     flutuante para `log' irá sempre ser convertido para seu valor
     absoluto antes que `log' seja tomado.  Se `numer' for também
     `true', então argumentos negativos inteiros para `log' irão também
     ser convertidos para seu valor absoluto.

     `lognegint' - se `true' implementa a regra `log(-n)' ->
     `log(n)+%i*%pi' para `n' um inteiro positivo.

     `%e_to_numlog' - quando `true', `r' sendo algum número racional, e
     `x' alguma expressão, `%e^(r*log(x))' irá ser simplificado em
     `x^r' .  Note-se que o comando `radcan' também faz essa
     transformação, e transformações mais complicadas desse tipo também.
     O comando `logcontract' "contrai" expressões contendo `log'.


 -- Variável de opção: logabs
     Valor padrão: `false'

     Quando fazendo integração indefinida onde logs são gerados, e.g.
     `integrate(1/x,x)', a resposta é dada em termos de `log(abs(...))'
     se `logabs' for `true', mas em termos de `log(...)' se `logabs'
     for `false'.  Para integração definida, a escolha `logabs:true' é
     usada, porque aqui "avaliação" de integral indefinida nos extremos
     é muitas vezes necessária.


 -- Variável de opção: logarc
     Valor padrão: `false'

     Se `true' irá fazer com que as funções circularee inversas e
     hiperbólicas sejam convertidas em formas logarítimicas.
     `logarc(<exp>)' irá fazer com que essa conversão para uma expressão
     particular <exp> sem escolher o comutador ou tendo que re-avaliar
     a expressão com `ev'.


 -- Variável de opção: logconcoeffp
     Valor padrão: `false'

     Controla quais coeficientes são contraídos quando usando
     `logcontract'.  Pode ser escolhida para o nome de uma função
     predicado de um argumento.  E.g. se você gosta de gerar raízes
     quadradas, você pode fazer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) ou ratnump(m)$' .  Então
     `logcontract(1/2*log(x));' irá fornecer `log(sqrt(x))'.


 -- Função: logcontract (<expr>)
     Recursivamente examina a expressão <expr>, transformando
     subexpressões da forma `a1*log(b1) + a2*log(b2) + c' em
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Se você faz `declare(n,integer);' então
     `logcontract(2*a*n*log(x));' fornece `a*log(x^(2*n))'.  Os
     coeficientes que "contraem" dessa maneira são aqueles tais que 2 e
     `n' que satisfazem `featurep(coeff,integer)'.  O usuário pode
     controlar quais coeficientes são contraídos escolhendo a opção
     `logconcoeffp' para o nome de uma função predicado de um
     argumento.  E.g. se você gosta de gerara raízes quadradas, você
     pode fazer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) ou ratnump(m)$' .  então
     `logcontract(1/2*log(x));' irá fornecer `log(sqrt(x))'.


 -- Variável de opção: logexpand
     Valor padrão: `true'

     Faz com que `log(a^b)' torne-se `b*log(a)'.  Se for escolhida para
     `all', `log(a*b)' irá também simplificar para `log(a)+log(b)'.  Se
     for escolhida para `super', então `log(a/b)' irá também
     simplificar para `log(a)-log(b)' para números racionais `a/b',
     `a#1'.  (`log(1/b)', para `b' inteiro, sempre simplifica).  Se for
     escolhida para `false', todas essas simplificações irão ser
     desabilitadas.


 -- Variável de opção: lognegint
     Valor padrão: `false'

     Se `true' implementa a regra `log(-n)' -> `log(n)+%i*%pi' para `n'
     um inteiro positivo.


 -- Variável de opção: lognumer
     Valor padrão: `false'

     Se `true' então argumentos negativos em ponto flutuante para `log'
     irão sempre ser convertidos para seus valores absolutos antes que
     o `log' seja tomado.  Se `numer' for também `true', então
     argumentos inteiros negativos para `log' irão também ser
     convertidos para seus valores absolutos.


 -- Variável de opção: logsimp
     Valor padrão: `true'

     Se `false' então nenhuma simplificação de `%e' para um expoente
     contendo `log''s é concluída.


 -- Função: plog (<x>)
     Representa o principal ramo logarítmos naturais avaliados para
     complexos com `-%pi' < `carg(<x>)' <= `+%pi' .



File: maxima.info,  Node: Trigonometria,  Next: Funções Especiais,  Prev: Logarítmos,  Up: Top

15 Trigonometria
****************

* Menu:

* Introdução ao Pacote Trigonométrico::
* Definições para Trigonometria::


File: maxima.info,  Node: Introdução ao Pacote Trigonométrico,  Next: Definições para Trigonometria,  Prev: Trigonometria,  Up: Trigonometria

15.1 Introdução ao Pacote Trigonométrico
========================================

Maxima tem muitas funções trigonométricas definidas.  Não todas as
identidades trigonometricas estão programadas, mas isso é possível para
o usuário adicionar muitas delas usando a compatibilidade de
correspondência de modelos do sistema.  As funções trigonométricas
definidas no Maxima são: `acos', `acosh', `acot', `acoth', `acsc',
`acsch', `asec', `asech', `asin', `asinh', `atan', `atanh', `cos',
`cosh', `cot', `coth', `csc', `csch', `sec', `sech', `sin', `sinh',
`tan', e `tanh'.  Existe uma coleção de comandos especialmente para
manusear funções trigonométricas, veja `trigexpand', `trigreduce', e o
comutador `trigsign'.  Dois pacotes compartilhados extendem as regras
de simplificação construídas no Maxima, `ntrig' e `atrig1'.  Faça
`describe(<comando>)' para detalhes.


File: maxima.info,  Node: Definições para Trigonometria,  Prev: Introdução ao Pacote Trigonométrico,  Up: Trigonometria

15.2 Definições para Trigonometria
==================================

 -- Função: acos (<x>)
     - Arco Cosseno.


 -- Função: acosh (<x>)
     - Arco Cosseno Hiperbólico.


 -- Função: acot (<x>)
     - Arco Cotangente.


 -- Função: acoth (<x>)
     - Arco Cotangente Hiperbólico.


 -- Função: acsc (<x>)
     - Arco Cossecante.


 -- Função: acsch (<x>)
     - Arco Cossecante Hiperbólico.


 -- Função: asec (<x>)
     - Arco Secante.


 -- Função: asech (<x>)
     - Arco Secante Hiperbólico.


 -- Função: asin (<x>)
     - Arco Seno.


 -- Função: asinh (<x>)
     - Arco Seno Hiperbólico.


 -- Função: atan (<x>)
     - Arco Tangente.


 -- Função: atan2 (<y>, <x>)
     - retorna o valor de `atan(<y>/<x>)' no intervalo de `-%pi' a
     `%pi'.


 -- Função: atanh (<x>)
     - Arco tangente Hiperbólico.


 -- Pacote: atrig1
     O pacote `atrig1' contém muitas regras adicionais de simplificação
     para funções trigonométricas inversas.  Junto com regras já
     conhecidas para Maxima, os seguintes ângulos estão completamente
     implementados: `0', `%pi/6', `%pi/4', `%pi/3', and `%pi/2'.  Os
     ângulos correspondentes nos outros três quadrantes estão também
     disponíveis.  Faça `load(atrig1);' para usá-lo.


 -- Função: cos (<x>)
     - Cosseno.


 -- Função: cosh (<x>)
     - Cosseno hiperbólico.


 -- Função: cot (<x>)
     - Cotangente.


 -- Função: coth (<x>)
     - Cotangente Hyperbólica.


 -- Função: csc (<x>)
     - Cossecante.


 -- Função: csch (<x>)
     - Cossecante Hyperbólica.


 -- Variável de opção: halfangles
     Default value: `false'

     Quando `halfangles' for `true', meios-ângulos são simplificados
     imediatamente.


 -- Pacote: ntrig
     O pacote `ntrig' contém um conjunto de regras de simplificação que
     são usadas para simplificar função trigonométrica cujos argumentos
     estão na forma `<f>(<n> %pi/10)' onde <f> é qualquer das funções
     `sin', `cos', `tan', `csc', `sec' e `cot'.


 -- Função: sec (<x>)
     - Secante.


 -- Função: sech (<x>)
     - Secante Hyperbólica.


 -- Função: sin (<x>)
     - Seno.


 -- Função: sinh (<x>)
     - Seno Hyperbólico.


 -- Função: tan (<x>)
     - Tangente.


 -- Função: tanh (<x>)
     - Tangente Hyperbólica.


 -- Função: trigexpand (<expr>)
     Expande funções trigonometricas e hyperbólicas de adições de
     ângulos e de ângulos multiplos que ocorram em <expr>.  Para
     melhores resultados, <expr> deve ser expandida.  Para intensificar
     o controle do usuário na simplificação, essa função expande
     somente um nível de cada vez, expandindo adições de ângulos ou
     ângulos multiplos.  Para obter expansão completa dentro de senos e
     cossenos imediatamente, escolha o comutador `trigexpand: true'.

     `trigexpand' é governada pelos seguintes sinalizadores globais:

    `trigexpand'
          Se `true' causa expansão de todas as expressões contendo
          senos e cossenos ocorrendo subseqüêntemente.

    `halfangles'
          Se `true' faz com que meios-ângulos sejam simplificados
          imediatamente.

    `trigexpandplus'
          Controla a regra "soma" para `trigexpand', expansão de
          adições (e.g. `sin(x + y)') terão lugar somente se
          `trigexpandplus' for `true'.

    `trigexpandtimes'
          Controla a regra "produto" para `trigexpand', expansão de
          produtos (e.g. `sin(2 x)') terão lugar somente se
          `trigexpandtimes' for `true'.

     Exemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Variável de opção: trigexpandplus
     Valor padrão: `true'

     `trigexpandplus' controla a regra da "soma" para `trigexpand'.
     Dessa forma, quando o comando `trigexpand' for usado ou o
     comutador `trigexpand' escolhido para `true', expansão de adições
     (e.g. `sin(x+y))' terão lugar somente se `trigexpandplus' for
     `true'.


 -- Variável de opção: trigexpandtimes
     Valor padrão: `true'

     `trigexpandtimes' controla a regra "produto" para `trigexpand'.
     Dessa forma, quando o comando `trigexpand' for usado ou o
     comutador `trigexpand' escolhido para `true', expansão de produtos
     (e.g. `sin(2*x)') terão lugar somente se `trigexpandtimes' for
     `true'.


 -- Variável de opção: triginverses
     Valor padrão: `all'

     `triginverses' controla a simplificação de composições de funções
     trigonométricas e hiperbólicas com suas funções inversas.

     Se `all', ambas e.g. `atan(tan(<x>))' e `tan(atan(<x>))'
     simplificarão para <x>.

     Se `true', a simplificação  de `<arcfun>(<fun>(<x>))' é
     desabilitada.

     Se `false', ambas as simplificações `<arcfun>(<fun>(<x>))' e
     `<fun>(<arcfun>(<x>))' são desabilitadas.


 -- Função: trigreduce (<expr>, <x>)
 -- Função: trigreduce (<expr>)
     Combina produtos e expoentes de senos e cossenso trigonométricos e
     hiperbólicos de <x> dentro daqueles de múltiplos de <x>.  Também
     tenta eliminar essas funções quando elas ocorrerem em
     denominadores.  Se <x> for omitido então todas as variáveis em
     <expr> são usadas.

     Veja também `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     As rotinas de simplificação trigonométrica irão usar informações
     declaradas em alguns casos simples.  Declarações sobre variáveis
     são usadas como segue, e.g.

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Variável de opção: trigsign
     Valor padrão: `true'

     Quando `trigsign' for `true', permite simplificação de argumentos
     negativos para funções trigonométricas. E.g., `sin(-x)'
     transformar-se-á em `-sin(x)' somente se `trigsign' for `true'.


 -- Função: trigsimp (<expr>)
     Utiliza as identidades sin(x)^2 + cos(x)^2 = 1 and cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expressões contendo `tan', `sec',
     etc., para `sin', `cos', `sinh', `cosh'.

     `trigreduce', `ratsimp', e `radcan' podem estar habilitadas a
     adicionar simplificações ao resultado.

     `demo ("trgsmp.dem")' mostra alguns exemplos de `trigsimp'.


 -- Função: trigrat (<expr>)
     Fornece uma forma quase-linear simplificada canônica de uma
     expressão trigonométrica; <expr> é uma fração racional de muitos
     `sin', `cos' ou `tan', os argumentos delas são formas lineares em
     algumas variáveis (ou kernels-núcleos) e `%pi/<n>' (<n> inteiro)
     com coeficientes inteiros. O resultado é uma fração simplificada
     com numerador e denominador ambos lineares em `sin' e `cos'.
     Dessa forma `trigrat' lineariza sempre quando isso for passível.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     O seguinte exemplo encontra-se em Davenport, Siret, and Tournier,
     Calcul Formel, Masson (ou em inglês, Addison-Wesley), seção 1.5.5,
     teorema de Morley.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4



File: maxima.info,  Node: Funções Especiais,  Next: Polinômios Ortogonais,  Prev: Trigonometria,  Up: Top

16 Funções Especiais
********************

* Menu:

* Introdução a Funções Especiais::
* specint::
* Definições para Funções Especiais::


File: maxima.info,  Node: Introdução a Funções Especiais,  Next: specint,  Prev: Funções Especiais,  Up: Funções Especiais

16.1 Introdução a Funções Especiais
===================================


File: maxima.info,  Node: specint,  Next: Definições para Funções Especiais,  Prev: Introdução a Funções Especiais,  Up: Funções Especiais

16.2 specint
============

`hypgeo' é um pacote para manusear transformações de Laplace de
funções especiais.  `hyp' é um pacote para manusear funções
Hipergeométricas generalizadas.

   `specint' tenta calcular a integral definida (sobre o intervalo de
zero a infinito) de uma expressão contendo funções especiais.  Quando o
integrando contém um fator `exp (-s t)', o resultado é uma
transformação de Laplace.

   A sintaxe é como segue:

     specint (exp (-s*<t>) * <expr>, <t>);

   onde <t> é a variável de integração e <expr> é uma expressão
contendo funções especiais.

   Se `specint' não puder calcular a integral, o valor de retorno pode
conter vários símbolos Lisp, incluindo `other-defint-to-follow-negtest',
`other-lt-exponential-to-follow', `product-of-y-with-nofract-indices',
etc.; isso é um bug.

   A notação de função especial segue adiante:

     bessel_j (index, expr)         Função de Bessel, primeiro tipo
     bessel_y (index, expr)         Função de Bessel, segundo tipo
     bessel_i (index, expr)         Função de Bessel modificada, primeiro tipo
     bessel_k (index, expr)         Função de Bessel modificada, segundo tipo
     %he[n] (z)                     Polinômio de Hermite (Note bem: `he', não `h'. Veja A&S 22.5.18)
     %p[u,v] (z)                    Função de Legendre
     %q[u,v] (z)                    Função de Legendre, segundo tipo
     hstruve[n] (z)                 Função H de Struve H
     lstruve[n] (z)                 Função de L Struve
     %f[p,q] ([], [], expr)         Função Hipergeométrica Generalizada
     gamma()                        Função Gamma
     gammagreek(a,z)                Função gama incompleta
     gammaincomplete(a,z)           Final da função gama incompleta
     slommel
     %m[u,k] (z)                    Função de Whittaker, primeiro tipo
     %w[u,k] (z)                    Função de Whittaker, segundo tipo
     erfc (z)                       Complemento da função erf (função de erros - integral da distribuição normal)
     ei (z)                         Integral de exponencial (?)
     kelliptic (z)                  integral eliptica completa de primeiro tipo (K)
     %d [n] (z)                     Função cilíndrica parabólica

   `demo ("hypgeo")' mostra muitos exemplos de transformações de
Laplace calculadas através de `specint'.

   Esse é um trabalho em andamento.  Alguns nomes de funções podem
mudar.


File: maxima.info,  Node: Definições para Funções Especiais,  Prev: specint,  Up: Funções Especiais

16.3 Definições para Funções Especiais
======================================

 -- Função: airy (<x>)
     A função de Airy Ai.  Se o argumento <x> for um número, o valor
     numérico de `airy (<x>)' é retornado.  de outra forma, uma
     expressão não avaliada `airy (<x>)' é retornada.

     A equação de Airy `diff (y(x), x, 2) - x y(x) = 0' tem duas
     soluções linearmente independentes, chamadas `ai' e `bi'. Essa
     equação é muito popular como uma aproximação para problemas mais
     complicados em muitos ambientes de física matemática.

     `load ("airy")' chama as funções `ai', `bi', `dai', e `dbi'.

     O pacote `airy' contém rotinas para calcular `ai' e `bi' e suas
     derivadas `dai' e `dbi'. O resultado é um número em ponto
     flutuante se o argumento for um número, e uma expressão não
     avaliada de outra forma.

     Um erro ocorre se o argumento for maior que o esperado causando um
     estouro nas exponenciais, ou uma perda de precisão no `sin' ou no
     `cos'. Isso faz o intervalo de validade sobre -2800 a 10^38 para
     `ai' e `dai', e de -2800 a 25 para `bi' e `dbi'.

     Essas regras de derivação são conhecidas para Maxima:
        * `diff (ai(x), x)' retorna `dai(x)',

        * `diff (dai(x), x)' retorna `x ai(x)',

        * `diff (bi(x), x)' retorna `dbi(x)',

        * `diff (dbi(x), x)' retorna `x bi(x)'.

     Valores de função são calculados a partir das séries de Taylor
     convergentes para `abs(<x>) < 3', e a partir de expansões
     assintóticas para `<x> < -3' ou `<x> > 3' como necessário.  Esses
     resultados somente apresentam discrepâncias numéricas muito
     pequenas em `<x> = 3' e `<x> = -3'.  Para detalhes, veja
     Abramowitz e Stegun, Handbook of Mathematical Functions, Sessão
     10.4 e Tabela 10.11.

     `ev (taylor (ai(x), x, 0, 9), infeval)' retorna uma expansão de
     Taylor em ponto flutuante da função `ai'.  Uma expressão similar
     pode ser construída para `bi'.


 -- Função: airy_ai (<x>)
     A função de Airy Ai, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Sessão 10.4.

     A equação de Airy `diff (y(x), x, 2) - x y(x) = 0' tem duas
     soluções linearmente independentes, `y = Ai(x)' e `y = Bi(x)'.  A
     derivada de `diff (airy_ai(x), x)' é `airy_dai(x)'.

     Se o argumento `x' for um número real ou um número complexo
     qualquer deles em ponto flutuante , o valor numérico de `airy_ai'
     é retornado quando possível.

     Veja também `airy_bi', `airy_dai', `airy_dbi'.

 -- Função: airy_dai (<x>)
     A derivada da função de Airy Ai `airy_ai(x)'.

     Veja `airy_ai'.

 -- Função: airy_bi (<x>)
     A função de Airy Bi, como definida em Abramowitz e Stegun,
     Handbook of Mathematical Functions, Sessão 10.4, é a segunda
     solução da equação de Airy `diff (y(x), x, 2) - x y(x) = 0'.

     Se o argumento `x' for um número real ou um número complexo
     qualquer deles em ponto flutuante, o valor numérico de `airy_bi' é
     retornado quando possível.  Em outros casos a expressão não
     avaliada é retornada.

     A derivada de `diff (airy_bi(x), x)' é `airy_dbi(x)'.

     Veja `airy_ai', `airy_dbi'.

 -- Função: airy_dbi (<x>)
     A derivada de função de Airy Bi `airy_bi(x)'.

     Veja `airy_ai' e `airy_bi'.

 -- Função: asympa
     `asympa' é um pacote para análise assintótica. O pacote contém
     funções de simplificação para análise assintótica, incluindo as
     funções "grande O" e "pequeno o" que são largamente usadas em
     análises de complexidade e análise numérica.

     `load ("asympa")' chama esse pacote.


 -- Função: bessel (<z>, <a>)
     A função de Bessel de primeiro tipo.

     Essa função está desatualizada.  Escreva `bessel_j (<z>, <a>)' em
     lugar dessa.


 -- Função: bessel_j (<v>, <z>)
     A função de Bessel do primeiro tipo de ordem v e argumento z.

     `bessel_j' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_j [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_j' é definida como
                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     todavia séries infinitas não são usadas nos cálculos.


 -- Função: bessel_y (<v>, <z>)
     A função de Bessel do segundo tipo de ordem v e argumento z.

     `bessel_y' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_y [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_y' é definida como
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     quando v não for um inteiro.  Quando v for um inteiro n, o limite
     com v aprocimando-se de n é tomado.


 -- Função: bessel_i (<v>, <z>)
     A função de Bessel modificada de primeiro tipo de ordem v e
     argumento z.

     `bessel_i' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_i [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_i' é definida como
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     todavia séries infinitas não são usadas nos cálculos.


 -- Função: bessel_k (<v>, <z>)
     A função de Bessel modificada de segundo tipo de ordem v e
     argumento z.

     `bessel_k' calcula o array `besselarray' tal que `besselarray [i]
     = bessel_k [i + v - int(v)] (z)' para `i' de zero a `int(v)'.

     `bessel_k' é definida como
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     quando v não for inteiro.  Se v for um inteiro n, então o limite
     com v aproximando-se de n é tomado.


 -- Variável de opção: besselexpand
     Valor padrão: `false'

     Expansões de controle de funções de Bessel quando a ordem for a
     metade de um inteiro ímpar.  Nesse caso, as funções de Bessel
     podem ser expandidas em termos de outras funções elementares.
     Quando `besselexpand' for `true', a função de Bessel é expandida.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Função: j0 (<x>)
     A função de Bessel de primeiro tipo de ordem 0.

     Essa função está desatualizada.  Escreva `bessel_j (0, <x>)' em
     lugar dessa função.


 -- Função: j1 (<x>)
     A função de Bessel de primeiro tipo de ordem 1.

     Essa função está desatualizada.  Escreva `bessel_j (1, <x>)' em
     lugar dessa função.


 -- Função: jn (<x>, <n>)
     A função de Bessel de primeiro tipo de ordem <n>.

     Essa função éstá desatualizada.  Escreva `bessel_j (<n>, <x>)' em
     lugar dessa função.


 -- Função: i0 (<x>)
     A função de Bessel modificada de primeiro tipo de ordem 0.

     Essa função éstá desatualizada.  Escreva `bessel_i (0, <x>)' em
     lugar dessa função.


 -- Função: i1 (<x>)
     A função de Bessel modificada de primeiro tipo de ordem 1.

     Essa função está desatualizada.  Escreva `bessel_i (1, `x')' em
     lugar dessa função.


 -- Função: beta (<x>, <y>)
     A função beta, definida como `gamma(x) gamma(y)/gamma(x + y)'.


 -- Função: gamma (<x>)
     A função gama.

     Veja também `makegamma'.

     A variável `gammalim' controla a simplificação da função gama.

     A constante de Euler-Mascheroni é `%gamma'.


 -- Variável de opção: gammalim
     Valor padrão: 1000000

     `gammalim' controla a simplificação da função gama para integral e
     argumentos na forma de números racionais.  Se o valor absoluto do
     argumento não for maior que `gammalim', então a simplificação
     ocorrerá.  Note que `factlim' comuta controle de simplificaçcão do
     resultado de `gamma' de um argumento inteiro também.


 -- Função: intopois (<a>)
     Converte <a> em um código de Poisson.


 -- Função: makefact (<expr>)
     Transforma instâncias de funções binomiais, gama, e beta em <expr>
     para fatoriais.

     Veja também `makegamma'.


 -- Função: makegamma (<expr>)
     Transforma instâncias de funções binomiais, fatorial, e beta em
     <expr> para funções gama.

     Veja também `makefact'.


 -- Função: numfactor (<expr>)
     Retorna o fator numérico multiplicando a expressão <expr>, que
     pode ser um termo simples.

     `content' retorna o máximo divisor comum (mdc) de todos os termos
     em uma adição.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8


 -- Função: outofpois (<a>)
     Converte <a> de um código de Poisson para uma representação geral.
     Se <a> não for uma forma de Poisson, `outofpois' realiza a
     conversão, i.e., o valor de retorno é `outofpois (intopois (<a>))'.
     Essa função é desse modo um simplificador canônico para adições e
     potências de termos de seno e cosseno de um tipo particular.


 -- Função: poisdiff (<a>, <b>)
     Deriva <a> com relação a <b>.  <b> deve ocorrer somente nos
     argumentos trigonométricos ou somente nos coeficientes.


 -- Função: poisexpt (<a>, <b>)
     Funcionalmente identica a `intopois (<a>^<b>)'.  <b> deve ser um
     inteiro positico.


 -- Função: poisint (<a>, <b>)
     Integra em um senso restrito similarmente (para `poisdiff').
     Termos não periódicos em <b> são diminuídos se <b> estiver em
     argumentos trigonométricos.


 -- Variável de opção: poislim
     Valor padrão: 5

     `poislim' determina o domínio dos coeficientes nos argumentos de
     funções trigonométricas.  O valor inicial de 5 corresponde ao
     intervalo [-2^(5-1)+1,2^(5-1)], ou [-15,16], mas isso pode ser
     alterado para [-2^(n-1)+1, 2^(n-1)].


 -- Função: poismap (<series>, <sinfn>, <cosfn>)
     mapeará as funções <sinfn> sobre os termos de seno e <cosfn>
     ssobre os termos de cosseno das séries de Poisson dadas.  <sinfn>
     e <cosfn> são funções de dois argumentos que são um coeficiente e
     uma parte trigonométrica de um termo em séries respectivamente.


 -- Função: poisplus (<a>, <b>)
     É funcionalmente identica a `intopois (a + b)'.


 -- Função: poissimp (<a>)
     Converte <a> em séries de Poisson para <a> em representação geral.


 -- Símbolo especial: poisson
     O símbolo `/P/' segue o rótulo de linha de uma expressão contendo
     séries de Poisson.


 -- Função: poissubst (<a>, <b>, <c>)
     Substitue <a> por <b> em <c>.  <c> é uma série de Poisson.

     (1) Quando <B> é uma variável <u>, <v>, <w>, <x>, <y>, ou <z>,
     então <a> deve ser uma expressão linear nessas variáveis (e.g.,
     `6*u + 4*v').

     (2) Quando <b> for outra que não essas variáveis, então <a> deve
     também ser livre dessas variáveis, e alé disso, livre de senos ou
     cossenos.

     `poissubst (<a>, <b>, <c>, <d>, <n>)' é um tipo especial d
     substituição que opera sobre <a> e <b> como no tipo (1) acima, mas
     onde <d> é uma série de Poisson, expande `cos(<d>)' e `sin(<d>)'
     para a ordem <n> como provendo o resultado da substituição `<a> +
     <d>' por <b> em <c>.  A idéia é que <d> é uma expansão em termos
     de um pequeno parâmetro.  Por exemplo, `poissubst (u, v, cos(v),
     %e, 3)' retorna `cos(u)*(1 - %e^2/2) - sin(u)*(%e - %e^3/6)'.


 -- Função: poistimes (<a>, <b>)
     É funcionalmente idêntica a `intopois (<a>*<b>)'.


 -- Função: poistrim ()
     é um nome de função reservado que (se o usuário tiver definido uma
     função com esse nome) é aplicada durante multiplicação de Poisson.
     Isso é uma função predicada de 6 argumentos que são os
     coeficientes de <u>, <v>, ..., <z> em um termo.  Termos para os
     quais `poistrim' for `true' (para os coeficientes daquele termo)
     são eliminados durante a multiplicação.


 -- Função: printpois (<a>)
     Mostra uma série de Poisson em um formato legível.  Em comum com
     `outofpois', essa função converterá <a> em um código de Poisson
     primeiro, se necessário.


 -- Função: psi (<x>)
 -- Função: psi [<n>](<x>)
     A derivada de `log (gamma (x))'.

     Maxima não sabe como calcular um valor numérico de `psi'.
     Todavia, a função `bfpsi' no pacote `bffac' pode calcular valores
     numéricos.



File: maxima.info,  Node: Polinômios Ortogonais,  Next: Funções Elípticas,  Prev: Funções Especiais,  Up: Top

17 Polinômios Ortogonais
************************

* Menu:

* Introdução a Polinômios Ortogonais::
* Definições para Polinômios Ortogonais::


File: maxima.info,  Node: Introdução a Polinômios Ortogonais,  Next: Definições para Polinômios Ortogonais,  Up: Polinômios Ortogonais

17.1 Introdução a Polinômios Ortogonais
=======================================

O pacote `specfun' contém Código Maxima para a avaliação de todos os
polinômios ortogonais listados no Capítulo 22 de Abramowitz e Stegun.
Esses incluem polinômios de Chebyshev, Laguerre, Hermite, Jacobi,
Legendre, e ultraesférico (Gegenbauer).  Adicionalmente, `specfun'
contém códigos para funções de Bessel esféricas, funções de Hankel
esféricas, e funções harmônicas esféricas.  O pacote `specfun' não é
parte do Maxima propriamente; ele é chamado por meio de requisição de
usuário via `load' ou automaticamente via o sistema `autoload'.

   A seguinte tabela lista cada função em `specfun'.  `specfun' é um
nome Maxima, restrições sobre seus argumentos, e uma referência para o
algorítmo que `specfun' usa para avaliar isso.  Com poucas excessões,
`specfun' segue as convenções de Abramowitz e Stegun.  Em todos os
casos, m e n devem ser inteiros.

   A&S refere-se a Abramowitz e Stegun, _Handbook of Mathematical
Functions_ (10th edição, Dezembro de 1972), G&R refere-se a Gradshteyn
e Ryzhik, _Table of Integrals, Series, and Products_ (1980 edição
corrigida e ampliada), e Merzbacher refere-se a _Quantum Mechanics_
(segunda edição, 1970).

_Função_           _Nome Maxima_      _Restrições_       _Referência(s)_
Chebyshev T        chebyshev_t(n, x)  n > -1             A&S 22.5.31
Chebyshev U        chebyshev_u(n, x)  n > -1             A&S 22.5.32
generalized        gen_laguerre(n,a,x)n > -1             A&S página 789
Laguerre                                                 
Laguerre           laguerre(n,x)      n > -1             A&S 22.5.67
Hermite            hermite(n,x)        n > -1            A&S 22.4.40,
                                                         22.5.41
Jacobi             jacobi_p(n,a,b,x)   n > -1, a, b >    A&S página 789
                                      -1                 
associated         assoc_legendre_p(n,m,x)n > -1             A&S 22.5.37,
Legendre P                                               8.6.6, 8.2.5
associated         assoc_legendre_q(n,m,x)n > -1, m > -1     G & R 8.706
Legendre Q                                               
Legendre P         legendre_p(n,m,x)  n > -1             A&S 22.5.35
Legendre Q         legendre_q(n,m,x)  n > -1             A&S 8.6.19
spherical Hankel   spherical_hankel1(n,n > -1             A&S 10.1.36
1st                x)                                    
spherical Hankel   spherical_hankel2(n,n > -1             A&S 10.1.17
2nd                x)                                    
spherical Bessel   spherical_bessel_j(n,x)n > -1             A&S 10.1.8,
J                                                        10.1.15
spherical Bessel   spherical_bessel_y(n,x)n > -1             A&S 10.1.9,
Y                                                        10.1.15
spherical          spherical_harmonic(n,m,x,y)n > -1, |m| <= n   Merzbacher 9.64
harmonic                                                 
ultraspherical     ultraspherical(n,a,x) n > -1            A&S 22.5.27
(Gegenbauer)                                             

   O pacote `specfun' é primáriamente planejado para computação
simbólica. A computação simbólica espera que `specfun' forneça
resultados acurados em ponto flutuante também; todavia, nenhuma
reinvidicação foi feita para que os algorítmos sejam também adequados
para avaliação numérica.  Algum esforço, todavia, tem sido feito para
fornecer boa performace numérica.  Quando todos os argumentos, exceto
pela ordem, forem números em ponto flutuante (mas não grandes números
em ponto flutuante), muitas funções em `specfun' chamam uma versão
mododeclarada da função de Jacobi.  Isso aumenta grandemente a
velocidade de avaliação de números em ponto flutuante de polinômios
ortogonais.

   `specfun' manuseia muitos domínios de erro através do retorno de uma
função não avaliada.  Nenhuma regra de simplificação (baseada em
relações recursivas) é definida para funções não avaliadas.  Isso é
possível para uma expressão envolvendo adições de funções especiais não
avaliadas para tender para zero, ainda Maxima é incapaz de reduzir
essas funções a zero.

   `load ("specfun")' chama o pacote `specfun'.  Alternativamente,
`setup_autoload' faz com que o pacote seja chamado quando uma das
funções `specfun' aparecer em uma expressão.  `setup_autoload' pode
aparecer na linha de comando ou no arquivo `maxima-init.mac'.  Veja
`setup_autoload'.

   Um exemplo de uso de `specfun' é

     (%i1) load ("specfun")$
     (%i2) [hermite (0, x), hermite (1, x), hermite (2, x)];
                                              2
     (%o2)               [1, 2 x, - 2 (1 - 2 x )]
     (%i3) diff (hermite (n, x), x);
     (%o3)                 2 n hermite(n - 1, x)

   Geralmente, código compilado executa mais rápidamente que o código
traduzido; todavia, código traduzido pode ser melhor para
desenvolvimento de programas.

   Algumas funções (a saber `jacobi_p', `ultraspherical', `chebyshev_t',
`chebyshev_u' e `legendre_p'), retornam um representação de série
quando a ordem for um inteiro simbólico.  A representação de série não é
usada por `specfun' para qualquer computação, mas essa representação de
série pode ser simplificada pelo Maxima automaticamente, ou a
simplificação pode ser possível para usar as séries para avaliar a
função através de manipulações adicionais.  Por exemplo:

     (%i1) load ("specfun")$
     (%i2) legendre_p (n, x);
     (%o2)                   legendre_p(n, x)
     (%i3) ultraspherical (n, 3/2, 2);
                  genfact(3, n, - 1) jacobi_p(n, 1, 1, 2)
     (%o3)        ---------------------------------------
                            genfact(2, n, - 1)
     (%i4) declare (n, integer)$
     (%i5) legendre_p (n, x);
            n - 1
            ====
            \                                                 n - i%
     (%o5) ( >     binomial(n, i%) binomial(n, n - i%) (x - 1)
            /
            ====
            i% = 1

                                         i%          n          n   n
                                  (x + 1)   + (x + 1)  + (x - 1) )/2
     (%i6) ultraspherical (n, 3/2, 2);
                               n - 1
                               ====
                               \       i%
     (%o6) genfact(3, n, - 1) ( >     3   binomial(n + 1, i%)
                               /
                               ====
                               i% = 1

                                         n
      binomial(n + 1, n - i%) + (n + 1) 3  + n + 1)

                           n
     /(genfact(2, n, - 1) 2 )

   O primeiro e o último termos da adição são adicionados fora do
somatório.  Removendo esses dois termos evita-se erros do Maxima
associados com termos 0^0 em uma adição que pode avaliar para 1, mas
avaliada para 0 em um somatório no Maxima. Porque a soma de índices vai
de 1 a n - 1, o menor índice de soma excederá o maior índice de soma
quando n = 0; escolhendo `sumhack' para `true' temos uma correção. Por
exemplo:

     (%i1) load ("specfun")$
     (%i2) declare (n, integer)$
     (%i3) e: legendre_p(n,x)$
     (%i4) ev (e, sum, n=0);
     Lower bound to sum: 1
     is greater than the upper bound: - 1
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i5) ev (e, sum, n=0, sumhack=true);
     (%o5)                           1

   Muitas funções em `specfun' possuem uma propriedade `gradef';
derivadas com relação a ordem ou outros parâmetros de funções são
indefinidas, e uma tentativa de calcular tal uma derivada retorna como
resiltado uma mensagem de erro.

   O pacote `specfun' e sua documentação foram escritos por Barton
Willis da Universidade de Nebraska em Kearney. Foi liberado sob os
termos da Licença Pública Geral (GPL).  Envie relatórios de erro e
comentários sobre esse pacote para willisb@unk.edu.  Em seu relatório,
por favor inclua a versão do Maxima, como reportado por `build_info()',
e a versão de `specfun', como reportado por `get ('specfun, 'version)'.


File: maxima.info,  Node: Definições para Polinômios Ortogonais,  Prev: Introdução a Polinômios Ortogonais,  Up: Polinômios Ortogonais

17.2 Definições para Polinômios Ortogonais
==========================================

 -- Função: assoc_legendre_p (<n>, <m>, <x>)
     Retorna a função associada de Legendre de primeiro tipo para
     inteiros  n > -1  e  m > -1.  Quando  | m | > n  e  n >= 0,
     teremos   assoc_legendre_p (n, m, x) = 0.  Referência: A&S 22.5.37
     página 779,  A&S 8.6.6 (segunda equação) página 334, e A&S 8.2.5
     página 333.

     `load ("specfun")' chama essa função.

     Veja *Note assoc_legendre_q::, *Note legendre_p::, e *Note
     legendre_q::.

 -- Função: assoc_legendre_q (<n>, <m>, <x>)
     Retorna a função associada de Legendre de segundo tipo para
     inteiros  n > -1  e  m > -1.

     Referência: Gradshteyn e Ryzhik  8.706 página 1000.

     `load ("specfun")' chama essa função.

     Veja também *Note assoc_legendre_p::, *Note legendre_p::, e *Note
     legendre_q::.

 -- Função: chebyshev_t (<n>, <x>)
     Retorna a função de Chebyshev de primeiro tipo para inteiros  n >
     -1.

     Referência: A&S 22.5.31 página 778 e A&S 6.1.22 página 256.

     `load ("specfun")' chama essa função.

     Veja também *Note chebyshev_u::.


 -- Função: chebyshev_u (<n>, <x>)
     Retorna a função de Chebyshev de segundo tipo para inteiros  n >
     -1.

     Referência A&S, 22.8.3 página 783 e A&S 6.1.22 página 256.

     `load ("specfun")' chama essa função.

     Veja também *Note chebyshev_t::.


 -- Função: gen_laguerre (<n>, <a>, <x>)
     Retorna o polinômio generalizado de Laguerre para inteiros  n > -1.

     `load ("specfun")' chama essa função.

     Referência tabela na página 789 em A&S.

 -- Função: hermite (<n>, <x>)
     Retorna o polinômio de Hermite para inteiros  n > -1.

     `load ("specfun")' chama essa função.

     Referência  A&S 22.5.40 e 22.5.41, página 779.


 -- Função: jacobi_p (<n>, <a>, <b>, <x>)
     Retorna o polinômio de Jacobi para inteiros  n > -1  e  a  e  b
     simbólicos ou  a > -1  e b > -1.  (Os polinômios de  Jacobi são
     atualmente definidos para todos  a  e  b ; todavia, o polinômio de
     Jacobi peso  (1-x)^a(1+x)^b não é integrável para  a <= -1 ou para
     b <= -1.)

     Quando a, b, e  x  forem números em ponto flutuante (mas não
     grandes números em ponto flutuante) `specfun' chama uma versão
     especial modo declarada de jacobi_p.  Para valore numéricos, a
     versão modo declarada é mais rápida que a outra versão. Muitas
     funções em `specfun' são calculados como um caso especial dos
     polinômios de Jacobi; Eles também desfrutam do impulso de
     velocidade da versão modo declarada de  jacobi.

     Se  n  tiver sido declarado para ser um inteiro, jacobi_p (n, a,
     b, x) retorna uma representação de somatório para a função de
     Jacobi. Porque Maxima simplifica 0^0  para  0  em uma adição, dois
     termos da adição são adicionados fora do somatório.

     `load ("specfun")' chama essa função.

     Referência  tabela na página 789 em A&S.


 -- Função: laguerre (<n>, <x>)
     Retorna o polinômio de Laguerre para inteiros  n > -1.

     Referência A&S 22.5.16, página 778 e A&S página 789.

     `load ("specfun")' chama essa função.

     Veja também *Note gen_laguerre::.


 -- Função: legendre_p (<n>, <x>)
     Retorna o polinômio de Legendre de primeiro tipo para inteiros  n
     > -1.

     Referência A&S 22.5.35 página 779.

     `load ("specfun")' chama essa função.

     Veja *Note legendre_q::.


 -- Função: legendre_q (<n>, <x>)
     Retorna o polinômio de Legendre de primeiro tipo para inteiros  n
     > -1.

     Referência A&S 8.6.19 página 334.

     `load ("specfun")' chama essa função.

     Veja também *Note legendre_p::.


 -- Função: spherical_bessel_j (<n>, <x>)
     Retorna a função de Bessel esférica do primeiro tipo para inteiros
     n > -1.

     Referência A&S 10.1.8 página 437 e A&S 10.1.15 página 439.

     `load ("specfun")' chama essa função.

     Veja também *Note spherical_hankel1::, *Note spherical_hankel2::,
     e *Note spherical_bessel_y::.


 -- Função: spherical_bessel_y (<n>, <x>)
     Retorna a função de Bessel esférica do segundo tipo para inteiros
     n > -1.

     Referência A&S 10.1.9 página 437 e 10.1.15 página 439.

     `load ("specfun")' chama essa função.

     Veja também *Note spherical_hankel1::, *Note spherical_hankel2::,
     e *Note spherical_bessel_y::.


 -- Função: spherical_hankel1 (<n>, <x>)
     Retorna a função de Hankel esférica do primeiro tipo para inteiros
     n > -1.

     Referência A&S 10.1.36 página 439.

     `load ("specfun")' chama essa função.

     Veja também *Note spherical_hankel2::, *Note spherical_bessel_j::,
     e *Note spherical_bessel_y::.


 -- Função: spherical_hankel2 (<n>, <x>)
     Retorna a função de Hankel esférica do segundo tipo para inteiros
     n > -1.

     Referência  A&S 10.1.17 página 439.

     `load ("specfun")' chama essa função.

     Veja também *Note spherical_hankel1::, *Note spherical_bessel_j::,
     e *Note spherical_bessel_y::.


 -- Função: spherical_harmonic (<n>, <m>, <x>, <y>)
     Retorna a função harmônica esférica para inteiros  n > -1 e  | m |
     <= n .

     Referência  Merzbacher 9.64.

     `load ("specfun")' chama essa função.

     Veja também *Note assoc_legendre_p::.


 -- Função: ultraspherical (<n>, <a>, <x>)
     Retorna os polinômios ultraesféricos para inteiros  n > -1.  Os
     polinômios ultraesféricos são também conhecidos com polinômios de
     Gegenbauer.

     Referência A&S 22.5.27

     `load ("specfun")' chama essa função.

     Veja também *Note jacobi_p::.



File: maxima.info,  Node: Funções Elípticas,  Next: Limites,  Prev: Polinômios Ortogonais,  Up: Top

18 Funções Elípticas
********************

* Menu:

* Introdução a Funções Elípticas e Integrais::
* Definições para Funções Elípticas::
* Definições para Integrais Elípticas::


File: maxima.info,  Node: Introdução a Funções Elípticas e Integrais,  Next: Definições para Funções Elípticas,  Up: Top

18.1 Introdução a Funções Elípticas e Integrais
===============================================

Maxima inclui suporte a funções elípticas Jacobianas e a integrais
elípticas completas e incompletas.  Isso inclui manipulação simbólica
dessas funções e avaliação numérica também.  Definições dessas
funções e muitas de suas propriedades podem ser encontradas em
Abramowitz e Stegun, Capítulos 16-17.  Tanto quanto possível, usamos as
definições e relações dadas aí.

   Em particular, todas as funções elípticas e integrais elípticas usam
o parâmetro m em lugar de módulo k ou o ângulo modular \alpha.  Isso é
uma área onde discordamos de Abramowitz e Stegun que usam o ângulo
modular para as funções elípticas.  As seguintes relações são
verdadeiras: m = k^2 e k = \sin(\alpha)

   As funções elípticas e integrais elípticas estão primariamente
tencionando suportar computação simbólica.  Portanto, a maiora das
derivadas de funções e integrais são conhecidas.  Todavia, se valores
em ponto flutuante forem dados, um resultado em ponto flutuante é
retornado.

   Suporte para a maioria de outras propriedades das funções elípticas e
integrais elípticas além das derivadas não foram ainda escritas.

   Alguns exemplos de funções elípticas:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Alguns exemplos de integrais elípticas:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   Suporte a funções elípticas e integrais elípticas foi escrito por
Raymond Toy.  Foi colocado sob os termos da Licençã Pública Geral (GPL)
que governa a distribuição do Maxima.


File: maxima.info,  Node: Definições para Funções Elípticas,  Next: Definições para Integrais Elípticas,  Prev: Introdução a Funções Elípticas e Integrais,  Up: Top

18.2 Definições para Funções Elípticas
======================================

 -- Função: jacobi_sn (<u>, <m>)
     A Função elíptica Jacobiana sn(u,m).

 -- Função: jacobi_cn (<u>, <m>)
     A função elíptica Jacobiana cn(u,m).

 -- Função: jacobi_dn (<u>, <m>)
     A função elíptica Jacobiana dn(u,m).

 -- Função: jacobi_ns (<u>, <m>)
     A função elíptica Jacobiana ns(u,m) = 1/sn(u,m).

 -- Função: jacobi_sc (<u>, <m>)
     A função elíptica Jacobiana sc(u,m) = sn(u,m)/cn(u,m).

 -- Função: jacobi_sd (<u>, <m>)
     A função elíptica Jacobiana sd(u,m) = sn(u,m)/dn(u,m).

 -- Função: jacobi_nc (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_cs (<u>, <m>)
     A função elíptica Jacobiana cs(u,m) = cn(u,m)/sn(u,m).

 -- Função: jacobi_cd (<u>, <m>)
     A função elíptica Jacobiana cd(u,m) = cn(u,m)/dn(u,m).

 -- Função: jacobi_nd (<u>, <m>)
     A função elíptica Jacobiana nc(u,m) = 1/cn(u,m).

 -- Função: jacobi_ds (<u>, <m>)
     A função elíptica Jacobiana ds(u,m) = dn(u,m)/sn(u,m).

 -- Função: jacobi_dc (<u>, <m>)
     A função elíptica Jacobiana dc(u,m) = dn(u,m)/cn(u,m).

 -- Função: inverse_jacobi_sn (<u>, <m>)
     A inversa da função elíptica Jacobiana sn(u,m).

 -- Função: inverse_jacobi_cn (<u>, <m>)
     A inversa da função elíptica Jacobiana cn(u,m).

 -- Função: inverse_jacobi_dn (<u>, <m>)
     A inversa da função elíptica Jacobiana dn(u,m).

 -- Função: inverse_jacobi_ns (<u>, <m>)
     A inversa da função elíptica Jacobiana ns(u,m).

 -- Função: inverse_jacobi_sc (<u>, <m>)
     A inversa da função elíptica Jacobiana sc(u,m).

 -- Função: inverse_jacobi_sd (<u>, <m>)
     A inversa da função elíptica Jacobiana sd(u,m).

 -- Função: inverse_jacobi_nc (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_cs (<u>, <m>)
     A inversa da função elíptica Jacobiana cs(u,m).

 -- Função: inverse_jacobi_cd (<u>, <m>)
     A inversa da função elíptica Jacobiana cd(u,m).

 -- Função: inverse_jacobi_nd (<u>, <m>)
     A inversa da função elíptica Jacobiana nc(u,m).

 -- Função: inverse_jacobi_ds (<u>, <m>)
     A inversa da função elíptica Jacobiana ds(u,m).

 -- Função: inverse_jacobi_dc (<u>, <m>)
     A inversa da função elíptica Jacobiana dc(u,m).


File: maxima.info,  Node: Definições para Integrais Elípticas,  Prev: Definições para Funções Elípticas,  Up: Top

18.3 Definições para Integrais Elípticas
========================================

 -- Função: elliptic_f (<phi>, <m>)
     A integral elíptica incompleta de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Veja também *Note elliptic_e:: e *Note elliptic_kc::.


 -- Função: elliptic_e (<phi>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como

     elliptic_e(u, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi) Veja
     também *Note elliptic_e:: and *Note elliptic_ec::.


 -- Função: elliptic_eu (<u>, <m>)
     A integral elíptica incompleta de segundo tipo, definida como
     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     onde tau = sn(u,m)

     Isso é relacionado a elliptic_e através de elliptic_eu(u, m) =
     elliptic_e(asin(sn(u,m)),m) Veja também *Note elliptic_e::.

 -- Função: elliptic_pi (<n>, <phi>, <m>)
     A integral elíptica incompleta de terceiro tipo, definida como

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Somente a derivada em relação a phi é conhecida pelo Maxima.

 -- Função: elliptic_kc (<m>)
     A integral elíptica completa de primeiro tipo, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em
     termos de funções Gamma.  Use `makegamma' para avaliar esse valor.

 -- Função: elliptic_ec (<m>)
     A integral elíptica completa de sgundo tipo, definida como

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para certos valores de m, o valor da integral é conhecido em
     termos de funçõesvGamma.  Use `makegamma' para avaliar esse valor.


File: maxima.info,  Node: Limites,  Next: Diferenciação,  Prev: Funções Elípticas,  Up: Top

19 Limites
**********

* Menu:

* Definições para Limites::


File: maxima.info,  Node: Definições para Limites,  Prev: Limites,  Up: Limites

19.1 Definições para Limites
============================

 -- Variável de Opção: lhospitallim
     Valor padrão: 4

     `lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em `limit'.  Isso evita ciclos infinitos em casos como
     `limit (cot(x)/csc(x), x, 0)'.


 -- Função: limit (<expr>, <x>, <val>, <dir>)
 -- Função: limit (<expr>, <x>, <val>)
 -- Função: limit (<expr>)
     Calcula o limite de <expr> com a variável real <x> aproximando-se
     do valor <val> pela direção <dir>.  <dir> pode ter o valor `plus'
     para um limite pela direita, `minus' para um limite pela esquerda,
     ou pode ser omitido (implicando em um limite em ambos os lados é
     para ser computado).

     `limit' usa os seguintes símbolos especiais: `inf' (infinito
     positivo) e `minf' (infinito negativo).  Em saídas essa função
     pode também usar `und' (undefined - não definido), `ind'
     (indefinido mas associado) e `infinity' (infinito complexo).

     `lhospitallim' é o máximo número de vezes que a regra L'Hospital é
     usada em `limit'.  Isso evita ciclos infinitos em casos como
     `limit (cot(x)/csc(x), x, 0)'.

     `tlimswitch' quando `true' fará o pacote `limit' usar série de
     Taylor quando possível.

     `limsubst' evita que `limit' tente substituições sobre formas
     desconhecidas.  Isso é para evitar erros como `limit (f(n)/f(n+1),
     n, inf)' dando igual a 1.  Escolhendo `limsubst' para `true'
     permitirá tais substituições.

     `limit' com um argumento é muitas vezes chamado em ocasiões para
     simplificar expressões de constantes, por exemplo, `limit (inf-1)'.

     `example (limit)' mostra alguns exemplos.

     Para saber sobre o método utilizado veja Wang, P., "Evaluation of
     Definite Integrals by Symbolic Manipulation", tese de Ph.D., MAC
     TR-92, Outubro de 1971.


 -- Variável de Opção: limsubst
     valor padrão: `false' - evita que `limit' tente substituições sobre
     formas desconhecidas.  Isso é para evitar erros como `limit
     (f(n)/f(n+1), n, inf)' dando igual a 1.  Escolhendo `limsubst'
     para `true' permitirá tais substituições.


 -- Função: tlimit (<expr>, <x>, <val>, <dir>)
 -- Função: tlimit (<expr>, <x>, <val>)
 -- Função: tlimit (<expr>)
     Retorna `limit' com `tlimswitch' escolhido para `true'.


 -- Variável de Opção: tlimswitch
     Valor padrão: `false'

     Quando `tlimswitch' for `true', fará o pacote `limit' usar série
     de Taylor quando possível.



File: maxima.info,  Node: Diferenciação,  Next: Integração,  Prev: Limites,  Up: Top

20 Diferenciação
****************

* Menu:

* Definições para Diferenciação::


File: maxima.info,  Node: Definições para Diferenciação,  Prev: Diferenciação,  Up: Diferenciação

20.1 Definições para Diferenciação
==================================

 -- Função: antid (<expr>, <x>, <u(x)>)
     Retorna uma lista de dois elementos, tais que uma antiderivada de
     <expr> com relação a <x> pode ser constuída a partir da lista.  A
     expressão <expr> pode conter uma função desconhecida <u> e suas
     derivadas.

     Tome <L>, uma lista de dois elementos, como sendo o valor de
     retorno de `antid'.  Então `<L>[1] + 'integrate (<L>[2], <x>)' é
     uma antiderivada de <expr> com relação a <x>.

     Quando `antid' obtém sucesso inteiramente, o segundo elemento do
     valor de retorno é zero.  De outra forma, o segundo elemento é não
     zero, e o primeiro elemento não zero ou zero.  Se `antid' não pode
     fazer nenhum progresso, o primeiro elemento é zero e o segundo não
     zero.

     `load ("antid")' chama essa função.  O pacote `antid' também
     define as funções `nonzeroandfreeof' e `linear'.

     `antid' está relacionada a `antidiff' como segue.  Tome <L>, uma
     lista de dois elementos, que é o valor de retorno de `antid'.
     Então o valor de retorno de `antidiff' é igual a `<L>[1] +
     'integrate (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Função: antidiff (<expr>, <x>, <u>(<x>))
     Retorna uma antiderivada de <expr> com relação a <x>.  A expressão
     <expr> pode conter uma função desconhecida <u> e suas derivadas.

     Quando `antidiff' obtém sucesso inteiramente, a expressão
     resultante é livre do sinal de integral (isto é, livre do
     substantivo `integrate').  De outra forma, `antidiff' retorna uma
     expressão que é parcialmente ou inteiramente dentro de um sinal de
     um sinal de integral.  Se `antidiff' não pode fazer qualquer
     progresso, o valor de retorno é inteiramente dentro de um sinal de
     integral.

     `load ("antid")' chama essa função.  O pacote `antid' também
     define as funções `nonzeroandfreeof' e `linear'.

     `antidiff' é relacionada a `antid' como segue.  Tome <L>, uma
     lista de dois elementos, como sendo o valor de retorno de `antid'.
     Então o valor de retorno de `antidiff' é igual a `<L>[1] +
     'integrate (<L>[2], <x>)' onde <x> é a variável de integração.

     Exemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- propriedade: atomgrad
     `atomgrad' é a propriedade do gradiente atômico de uma expressão.
     Essa propriedade é atribuída por `gradef'.


 -- Função: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Função: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Atribui o valor <c> a <expr> no ponto `<x> = <a>'.  Tipicamente
     valores de extremidade são estabelecidos por esse mecanismo.

     <expr> é a função de avaliação, `<f>(<x_1>, ..., <x_m>)', ou uma
     derivada, `diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ..., <x_n>,
     <n_m>)' na qual os argumentos da função explicitamente aparecem.
     <n_i> é a ordem de diferenciação com relação a <x_i>.

     O ponto no qual o `atvalue' é estabelecido é dado pela lista de
     equações `[<x_1> = <a_1>, ..., <x_m> = <a_m>]'.  Se existe uma
     variável simples <x_1>, uma única equação pode ser dada sem ser
     contida em uma lista.

     `printprops ([<f_1>, <f_2>, ...], atvalue)' mostra os `atvalues'
     das funções `<f_1>, <f_2>, ...' como especificado por chamadas a
     `atvalue'.  `printprops (<f>, atvalue)' mostra os `atvalues' de
     uma função <f>.  `printprops (all, atvalue)' mostra os `atvalue's
     de todas as funções para as quais `atvalue's são definidos.

     Os simbolos `@1', `@2', ... representam as variáveis <x_1>, <x_2>,
     ... quando `atvalue's são mostrados.

     `atvalue' avalia seus argumentos.  `atvalue' retorna <c>, o
     `atvalue'.

     Exemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Função: cartan -
     O cálculo exterior de formas diferenciais é uma ferramenta básica
     de geometria diferencial desenvolvida por Elie Cartan e tem
     importantes aplicações na teoria das equações diferenciais
     parciais.  O pacote `cartan' implementa as funções `ext_diff' e
     `lie_diff', juntamente com os operadores `~' (produto da cunha) e
     `|' (contração de uma forma com um vetor.)  Digite `demo (tensor)'
     para ver uma breve descrição desses comandos juntamente com
     exemplos.

     `cartan' foi implementado por F.B. Estabrook e H.D. Wahlquist.


 -- Função: del (<x>)
     `del (<x>)' representa a diferencial da variável x.

     `diff' retorna uma expressão contendo `del' se uma variável
     independente não for especificada.  Nesse caso, o valor de retorno
     é a então chamada "diferencial total".

     Exemplos:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Função: delta (<t>)
     A função Delta de Dirac.

     Correntemente somente `laplace' sabe sobre a função `delta'.

     Exemplo:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- Variável: dependencies
     Valor padrão: `[]'

     `dependencies' é a lista de átomos que possuem dependências
     funcionais, atribuídas por `depends' ou `gradef'.  A lista
     `dependencies' é cumulativa: cada chamada a `depends' ou a
     `gradef' anexa ítens adicionais.

     Veja `depends' e `gradef'.


 -- Função: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declara dependêcias funcionais entre variáveis para o propósito de
     calcular derivadas.  Na ausência de dependêcias declaradas, `diff
     (f, x)' retorna zero.  Se `depends (f, x)' for declarada, `diff
     (f, x)' retorna uma derivada simbólica (isto é, um substantivo
     `diff').

     Cada argumento <f_1>, <x_1>, etc., pode ser o nome de uma variável
     ou array, ou uma lista de nomes.  Todo elemento de <f_i> (talvez
     apenas um elemento simples) é declarado para depender de todo
     elemento de <x_i> (talvez apenas um elemento simples).  Se algum
     <f_i> for o nome de um array ou contém o nome de um array, todos
     os elementos do array dependem de <x_i>.

     `diff' reconhece dependências indiretas estabelecidas por `depends'
     e aplica a regra da cadeia nesses casos.

     `remove (<f>, dependency)' remove todas as dependências declaradas
     para <f>.

     `depends' retorna uma lista de dependências estabelecidas.  As
     dependências são anexadas à variável global `dependencies'.
     `depends' avalia seus argumentos.

     `diff' é o único comando Maxima que reconhece dependências
     estabelecidas por `depends'.  Outras funções (`integrate',
     `laplace', etc.)  somente reconhecem dependências explicitamente
     representadas por seus argumentos.  Por exemplo, `integrate' não
     reconhece a dependência de `f' sobre `x' a menos que
     explicitamente representada como `integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Variável de opção: derivabbrev
     Valor padrão: `false'

     Quando `derivabbrev' for `true', derivadas simbólicas (isto é,
     substantivos `diff') são mostradas como subscritos.  De outra
     forma, derivadas são mostradas na notação de Leibniz `dy/dx'.


 -- Função: derivdegree (<expr>, <y>, <x>)
     Retorna o maior grau de uma derivada da variável dependente <y>
     com relação à variável independente <x> ocorrendo em <expr>.

     Exemplo:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Função: derivlist (<var_1>, ..., <var_k>)
     Causa somente diferenciações com relação às variáveis indicadas,
     dentro do comando `ev'.


 -- Variável de opção: derivsubst
     Valor padrão: `false'

     Quando `derivsubst' for `true', uma substiruíção não sintática
     tais como `subst (x, 'diff (y, t), 'diff (y, t, 2))' retorna
     `'diff (x, t)'.


 -- Função: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Função: diff (<expr>, <x>, <n>)
 -- Função: diff (<expr>, <x>)
 -- Função: diff (<expr>)
     Retorna uma derivada ou diferencial de <expr> com relação a alguma
     ou todas as variáveis em <expr>.

     `diff (<expr>, <x>, <n>)' retorna a <n>'ésima derivada de <expr>
     com relação a <x>.

     `diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)' retorna a
     derivada parcial mista de <expr> com relação a <x_1>, ..., <x_m>.
     Isso é equivalente a `diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)'.

     `diff (<expr>, <x>)' retorna a primeira derivada de <expr> com
     relação a uma variável <x>.

     `diff (<expr>)' retorna a diferencial total de <expr>, isto é, a
     soma das derivadas de <expr> com relação a cada uma de suas
     variáveis vezes a diferencial `del' de cada variável.  Nenhuma
     simplificação adicional de `del' é oferecida.

     A forma substantiva de `diff' é requerida em alguns contextos, tal
     como declarando uma equação diferencial.  Nesses casos, `diff'
     pode ser colocado apóstrofo (com `'diff') para retornar a forma
     substantiva em lugar da realização da diferenciação.

     Quando `derivabbrev' for `true', derivadas são mostradas como
     subscritos.  De outra forma, derivadas são mostradas na notação de
     Leibniz, `dy/dx'.

     Exemplos:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     Para o pacote tensor, as seguintes modificações foram incorporadas:

     (1) As derivadas de quaisquer objetos indexados em <expr> terão as
     variáveis <x_i> anexadas como argumentos adicionais.  Então todos
     os índices de derivada serão ordenados.

     (2) As variáveis <x_i> podem ser inteiros de 1 até o valor de uma
     variável `dimension' [valor padrão: 4].  Isso fará com que a
     diferenciação seja concluída com relação aos <x_i>'ésimos membros
     da lista `coordinates' que pode ser escolhida para uma lista de
     nomes de coordenadas, e.g., `[x, y, z, t]'. Se `coordinates' for
     associada a uma variável atômica, então aquela variável subscrita
     por <x_i> será usada para uma variável de diferenciação.  Isso
     permite um array de nomes de coordenadas ou nomes subscritos como
     `X[1]', `X[2]', ... sejam usados.  Se `coordinates' não foram
     atribuídas um valor, então as variáveis seram tratadas como em (1)
     acima.


 -- Símbolo especial: diff
     Quando `diff' está presente como um `evflag' em chamadas para `ev',
     Todas as diferenciações indicadas em `expr' são realizdas.


 -- Função: dscalar (<f>)
     Aplica o d'Alembertiano escalar para a função escalar <f>.

     `load ("ctensor")' chama essa função.


 -- Função: express (<expr>)
     Expande o substantivo do operador diferencial em expressões em
     termos de derivadas parciais.  `express' reconhece os operadores
     `grad', `div', `curl', `laplacian'.  `express' também expande o
     produto do X `~'.

     Derivadas simbólicas (isto é, substantivos `diff') no valor de
     retorno de `express' podem ser avaliadas incluíndo `diff' na
     chamada à função `ev' ou na linha de comando.  Nesse contexto,
     `diff' age como uma `evfun'.

     `load ("vect")' chama essa função.

     Exemplos:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Função: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Função: gradef (<a>, <x>, <expr>)
     Define as derivadas parciais (i.e., os componentes do gradiente)
     da função <f> ou variável <a>.

     `gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)' define
     `d<f>/d<x_i>' como <g_i>, onde <g_i> é uma expressão; <g_i> pode
     ser uma chamada de função, mas não o nome de uma função.  O número
     de derivadas parciais <m> pode ser menor que o número de
     argumentos <n>, nesses casos derivadas são definidas com relação a
     <x_1> até <x_m> somente.

     `gradef (<a>, <x>, <expr>)' define uma derivada de variável <a>
     com relação a <x> como <expr>.  Isso também estabelece a
     dependência de <a> sobre <x> (via `depends (<a>, <x>)').

     O primeiro argumento `<f>(<x_1>, ..., <x_n>)' ou <a> é acompanhado
     de apóstrofo, mas os argumentos restantes <g_1>, ..., <g_m> são
     avaliados.  `gradef' retorna a função ou variável para as quais as
     derivadas parciais são definidas.

     `gradef' pode redefinir as derivadas de funções internas do Maxima.
     Por exemplo, `gradef (sin(x), sqrt (1 - sin(x)^2))' redefine uma
     derivada de `sin'.

     `gradef' não pode definir derivadas parciais para um função
     subscrita.

     `printprops ([<f_1>, ..., <f_n>], gradef)' mostra as derivadas
     parciais das funções <f_1>, ..., <f_n>, como definidas por
     `gradef'.

     `printprops ([<a_n>, ..., <a_n>], atomgrad)' mostra as derivadas
     parciais das variáveis <a_n>, ..., <a_n>, como definidas por
     `gradef'.

     `gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por `gradef'.  `gradefs' não inclui quaisquer
     variáveis para quais derivadas parciais foram definidas por
     `gradef'.

     Gradientes são necessários quando, por exemplo, uma função não é
     conhecida explicitamente mas suas derivadas primeiras são e isso é
     desejado para obter derivadas de ordem superior.


 -- Variável de sistema: gradefs
     Valor padrão: `[]'

     `gradefs' é a lista de funções para as quais derivadas parciais
     foram definidas por `gradef'.  `gradefs' não inclui quaisquer
     variáveis para as quais derivadas parciais foram deinidas por
     `gradef'.


 -- Função: laplace (<expr>, <t>, <s>)
     Tenta calcular a transformada de Laplace de <expr> com relação a
     uma variável <t> e parâmetro de transformação <s>.  Se `laplace'
     não pode achar uma solução, um substantivo `'laplace' é retornado.

     `laplace' reconhece em <expr> as funções `delta', `exp', `log',
     `sin', `cos', `sinh', `cosh', e `erf', também `derivative',
     `integrate', `sum', e `ilt'.  Se algumas outras funções estiverem
     presente, `laplace' pode não ser habilitada a calcular a
     tranformada.

     <expr> pode também ser uma equação linear, diferencial de
     coeficiente contante no qual caso o `atvalue' da variável
     dependente é usado.  O requerido `atvalue' pode ser fornecido ou
     antes ou depois da transformada ser calculada.  Uma vez que as
     condições iniciais devem ser especificadas em zero, se um teve
     condições de limite impostas em qualquer outro lugar ele pode
     impor essas sobre a solução geral e eliminar as constantes
     resolvendo a solução geral para essas e substituindo seus valores
     de volta.

     `laplace' reconhece integrais de convolução da forma `integrate
     (f(x) * g(t - x), x, 0, t)'; outros tipos de convoluções não são
     reconhecidos.

     Relações funcionais devem ser explicitamente representadas em
     <expr>; relações implícitas, estabelecidas por `depends', não são
     reconhecidas.  Isto é, se <f> depende de <x> e <y>, `f (x, y)'
     deve aparecer em <expr>.

     Veja também `ilt', a transformada inversa de Laplace.

     Exemplos:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0



File: maxima.info,  Node: Integração,  Next: Equações,  Prev: Diferenciação,  Up: Top

21 Integração
*************

* Menu:

* Introdução a Integração::
* Definições para Integração::


File: maxima.info,  Node: Introdução a Integração,  Next: Definições para Integração,  Prev: Integração,  Up: Integração

21.1 Introdução a Integração
============================

Maxima tem muitas rotinas para manusear integração.  A função
`integrate' faz uso de muitas dessas.  Exite também o pacote `antid',
que manuseia uma função não especificada (e suas derivadas,
certamente).  Para usos numéricos, existe a função `romberg'; um
integrador adaptativo que usa a regra da quadratura dos currais de
Newton, chamada `quanc8'; e uma escolha de integradores adaptativos de
Quadpack, a saber `quad_qag', `quad_qags', etc.  Funções
hipergeométricas estão sendo trabalhadas, veja `specint' for details.
Geralmente falando, Maxima somente manuseia integrais que são
integráveis em termos de "funções elementares" (funções racionais,
trigonometricas, logarítmicas, exponenciais, radicais, etc.) e umas
poucas extensões (função de erro, dilogarithm).  Isso não manuseia
integrais em termos de funções desconhecidas tais como `g(x)' e `h(x)'.


File: maxima.info,  Node: Definições para Integração,  Prev: Introdução a Integração,  Up: Integração

21.2 Definições para Integração
===============================

 -- Função: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Faz a mudança de variável dada por `<f(x,y)> = 0' em todas as
     integrais que ocorrem em <expr> com integração em relação a <x>.
     A nova variável é <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Uma expressão contendo uma forma substantiva, tais como as
     instâncias de `'integrate' acima, pode ser avaliada por `ev' com o
     sinalizador `nouns'.  Por exemplo, a expressão retornada por
     `changevar' acima pode ser avaliada por `ev (%o3, nouns)'.

     `changevar' pode também ser usada para alterações nos índices de
     uma soma ou de um produto.  Todavia, isso deve obrigatóriamente
     ser realizado de forma que quando uma alteração é feita em uma
     soma ou produto, essa mudança deve ser um artifício, i.e., `i = j+
     ...', não uma função de grau mais alto.  E.g.,

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Função: dblint (<f>, <r>, <s>, <a>, <b>)
     Uma rotina de integral dupla que foi escrita no alto-nível do
     Maxima e então traduzida e compilada para linguagem de máquina.
     Use `load (dblint)' para acessar esse pacote.  Isso usa o método
     da regra de Simpson em ambas as direções x e y para calcular

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     A função <f> deve ser uma função traduzida ou compilada de duas
     variáveis, e <r> e <s> devem cada uma ser uma função traduzida ou
     compilada de uma variável, enquanto <a> e <b> devem ser números em
     ponto flutuante.  A rotina tem duas variáveis globais que
     determinam o número de divisões dos intervalos x e y: `dblint_x' e
     `dblint_y', ambas as quais são inicialmente 10, e podem ser
     alteradas independentemente para outros valores inteiros (existem
     `2*dblint_x+1' pontos calculados na direção x , e `2*dblint_y+1'
     na direção y).  A rotina subdivide o eixo X e então para cada
     valor de X isso primeiro calcula `<r>(x)' e `<s>(x)'; então o eixo
     Y entre `<r>(x)' e `<s>(x)' é subdividido e a integral ao longo do
     eixo Y é executada usando a regra de Simpson; então a integral ao
     longo do eixo X é concluída usando a regra de Simpson com os
     valores da função sendo as integrais-Y.  Esse procedimento pode
     ser numericamente instável por uma grande variedade razões, mas
     razoávelmente rápido: evite usar isso sobre funções altamente
     oscilatórias e funções com singularidades (postes ou pontos de
     ramificação na região).  As integrais Y dependem de quanto
     fragmentados `<r>(x)' e `<s>(x)' são, então se a ditância `<s>(x)
     - <r>(x)' varia rapidamente com X, nesse ponto pode ter erros
     substanciais provenientes de truncação com diferentes
     saltos-tamanhos nas várias integrais Y.  Um pode incrementar
     `dblint_x' e `dblint_y' em uma tentativa para melhorar a
     convergência da reião, com sacrifício do tempo de computação.  Os
     valores da função não são salvos, então se a função é muito
     desperdiçadora de tempo,você terá de esperar por re-computação se
     você mudar qualquer coisa (desculpe).  Isso é requerido que as
     funções <f>, <r>, e <s> sejam ainda traduzidas ou compiladas
     previamente chamando `dblint'.  Isso resultará em ordens de
     magnitude de melhoramentos de velocidade sobre o código
     interpretado em muitos casos!

     `demo (dblint)' executa uma demonstração de `dblint' aplicado a um
     problema exemplo.


 -- Função: defint (<expr>, <x>, <a>, <b>)
     Tenta calcular uma integral definida.  `defint' é chamada por
     `integrate' quando limites de integração são especificados, i.e.,
     quando `integrate' é chamado como `integrate (<expr>, <x>, <a>,
     <b>)'.  Dessa forma do ponto de vista do usuário, isso é
     suficiente para chamar `integrate'.

     `defint' retorna uma expressão simbólica, e executa um dos dois:
     ou calcula a integral ou a forma substantiva da integral.  Veja
     `quad_qag' e funções rellacionadas para aproximação numérica de
     integrais definidas.


 -- Função: erf (<x>)
     Representa a função de erro, cuja derivada é:
     `2*exp(-x^2)/sqrt(%pi)'.


 -- Variável de opção: erfflag
     Valor padrão: `true'

     Quando `erfflag' é `false', previne `risch' da introdução da
     função `erf' na resposta se não houver nenhum no integrando para
     começar.


 -- Função: ilt (<expr>, <t>, <s>)
     Calcula a transformação inversa de Laplace de <expr> em relação a
     <t> e parâmetro <s>.  <expr> deve ser uma razão de polinômios cujo
     denominador tem somente fatores lineares e quadráticos.  Usando a
     funções `laplace' e `ilt' juntas com as funções `solve' ou
     `linsolve' o usuário pode resolver uma diferencial simples ou uma
     equação integral de convolução ou um conjunto delas.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Função: integrate (<expr>, <x>)
 -- Função: integrate (<expr>, <x>, <a>, <b>)
     Tenta símbolicamente calcular a integral de <expr> em relação a
     <x>.  `integrate (<expr>, <x>)' é uma integral indefinida,
     enquanto `integrate (<expr>, <x>, <a>, <b>)' é uma integral
     definida, com limites de integração <a> e <b>.  Os limites não
     poderam conter <x>, embora `integrate' não imponha essa restrição.
     <a> não precisa ser menor que <b>.  Se <b> é igual a <a>,
     `integrate' retorna zero.

     Veja `quad_qag' e funções relacionadas para aproximação numérica
     de integrais definidas.  Veja `residue' para computação de
     resíduos (integração complexa).  Veja `antid' para uma forma
     alternativa de calcular integrais indefinidas.

     A integral (uma expressão livre de `integrate') é retornada se
     `integrate' obtém sucesso.  De outra forma o valor de retorno é a
     forma substantiva da integral (o operador com apóstrofo
     `'integrate') ou uma expressão contendo uma ou mais formas
     substantivas.  A forma substantiva de `integrate' é mostrada com
     um sinal de integral.

     Em algumas circunstâncias isso é útil para construir uma forma
     substantiva manualmente, colocando em `integrate' um apóstrofo,
     e.g., `'integrate (<expr>, <x>)'.  Por exemplo, a integral pode
     depender de alguns parâmetos que não estão ainda calculados.  A
     forma substantiva pode ser aplicada a seus argumentos por `ev
     (<i>, nouns)' onde <i> é a forma substantiva de interesse.

     `integrate' manuseia integrais definidas separadamente das
     indefinidas, e utiliza uma gama de heurísticas para manusear cada
     caso.  Casos especiais de integrais definidas incluem limites de
     integração iguais a zero ou infinito (`inf' ou `minf'), funções
     trigonométricas com limites de integração iguais a zero e `%pi' ou
     `2 %pi', funções racionais, integrais relacionadas para as
     definições de funções `beta' e `psi', e algumas integrais
     logarítmicas e trigonométricas.  Processando funções racionais
     pode incluir computação de resíduo.  Se um caso especial aplicável
     não é encontrado, tentativa será feita para calcular a integra
     indefinida e avaliar isso nos limites de integração.  Isso pode
     incluir pegar um limite como um limite de integração tendendo ao
     infinito ou a menos infinito; veja também `ldefint'.

     Casos especiais de integrais indefinidas incluem funções
     trigonométricas, exponenciais e funções logarítmicas, e funções
     racionais.  `integrate' pode também fazer uso de uma curta tabela
     de integais elementares.

     `integrate' pode realizar uma mudança de variável se o integrando
     tem a forma `f(g(x)) * diff(g(x), x)'.  `integrate' tenta achar
     uma subexpressão `g(x)' de forma que a derivada de `g(x)' divida o
     integrando.  Essa busca pode fazer uso de derivadas definidas pela
     função `gradef'.  Veja também `changevar' e `antid'.

     Se nenhum dos procedimentos heurísticos acha uma integral
     indefinida, o algorítmo de Risch é executado.  O sinalizador
     `risch' pode ser escolhido como um `evflag', na chamada para `ev'
     ou na linha de comando, e.g., `ev (integrate (<expr>, <x>),
     risch)' ou `integrate (<expr>, <x>), risch'.  Se `risch' está
     presente, `integrate' chama a função `risch' sem tentar
     heurísticas primeiro.  Veja também `risch'.

     `integrate' trabalha somente com relações funcionais representadas
     explicitamente com a notação `f(x)'.  `integrate' não respeita
     dependências implicitas estabelecidas pela função `depends'.
     `integrate' pode necessitar conhecer alguma propriedade de um
     parâmetro no integrando.  `integrate' irá primeiro consultar a
     base de dados do `assume', e , se a variável de interesse não está
     lá, `integrate' perguntará ao usuário.  Dependendo da pergunta,
     respostas adequadas são `yes;' ou `no;', ou `pos;', `zero;', ou
     `neg;'.

     `integrate' não é, por padrão, declarada ser linear.  Veja
     `declare' e `linear'.

     `integrate' tenta integração por partes somente em uns poucos
     casos especiais.

     Exemplos:

        * Integrais definidas e indefinidas elementares.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Uso de `assume' e dúvida interativa.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Mudança de variável.  Existem duas mudanças de variável nesse
          exemplo: uma usando a derivada estabelecida por `gradef', e
          uma usando a derivação `diff(r(x))' de uma função não
          especificada `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * O valor de retorno contém a forma substantiva `'integrate'.
          Nesse exemplo, Maxima pode extrair um fator do denominador de
          uma função racional, mas não pode fatorar o restante ou de
          outra forma achar sua integral.  `grind' mostra a forma
          substantiva `'integrate' no resultado.  Veja também
          `integrate_use_rootsof' para mais sobre integrais de funções
          racionais.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definindo uma função em termos de uma integral.  O corpo de
          uma função não é avaliado quando a função é definida.  Dessa
          forma o corpo de `f_1' nesse exemplo contém a forma
          substantiva de `integrate'.  O operador aspas simples `'''
          faz com que a integral seja avaliada, e o resultado
          transforme-se no corpo de `f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- Variável de sistema: integration_constant_counter
     Valor padrão: 0

     `integração_constant_counter' é um contador que é atualizado a
     cada vez que uma constante de integração (nomeada pelo Maxima,
     e.g., `integrationconstant1') é introduzida em uma expressão pela
     integração indefinida de uma equação.


 -- Variável de opção: integrate_use_rootsof
     Valor padrão: `false'

     Quando `integrate_use_rootsof' é `true' e o denominador de uma
     função racional não pode ser fatorado, `integrate' retorna a
     integral em uma forma que é uma soma sobre as raízes (não
     conhecidas ainda) do denominador.

     Por exemplo, com `integrate_use_rootsof' escolhido para `false',
     `integrate' retorna uma integral não resolvida de uma função
     racional na forma substantiva:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Agora vamos escolher o sinalizador para ser true e a parte não
     resolvida da integral será expressa como um somatório sobre as
     raízes do denominador da função racional:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                       2 x + 1
                                                   2            5 atan(-------)
                                              log(x  + x + 1)          sqrt(3)
                                            - --------------- + ---------------
                                                    14             7 sqrt(3)

     Alternativamente o usuário pode calcular as raízes do denominador
     separadamente, e então expressar o integrando em termos dessas
     raízes, e.g., `1/((x - a)*(x - b)*(x - c))' ou `1/((x^2 - (a+b)*x
     + a*b)*(x - c))' se o denominador for um polinômio cúbico.
     Algumas vezes isso ajudará Maxima a obter resultados mais úteis.


 -- Função: ldefint (<expr>, <x>, <a>, <b>)
     Tenta calcular a integral definida de <expr> pelo uso de `limit'
     para avaliar a integral indefinida <expr> em relação a <x> no
     limite superior <b> e no limite inferior <a>.  Se isso falha para
     calcular a integral definida, `ldefint' retorna uma expressão
     contendo limites como formas substantivas.

     `ldefint' não é chamada por `integrate', então executando `ldefint
     (<expr>, <x>, <a>, <b>)' pode retornar um resultado diferente de
     `integrate (<expr>, <x>, <a>, <b>)'.  `ldefint' sempre usa o mesmo
     método para avaliar a integral definida, enquanto `integrate' pode
     utilizar várias heurísticas e pode reconhecer alguns casos
     especiais.


 -- Função: potential (<givengradient>)
     O cálculo faz uso da variável global `potentialzeroloc[0]' que
     deve ser `nonlist' ou da forma

          [indeterminatej=expressãoj, indeterminatek=expressãok, ...]

     O formador sendo equivalente para a expressão nonlist para todos
     os lados direitos-manuseados mais tarde.  Os lados direitos
     indicados são usados como o limite inferior de integração.  O
     sucesso das integrações pode depender de seus valores e de sua
     ordem.  `potentialzeroloc' é inicialmente escolhido para 0.


 -- Função: qq
     O pacote `qq' (que pode ser carregado com `load ("qq")') contém
     uma função `quanc8' que pode pegar ou 3 ou 4 arguments.  A versão
     de 3 argumentos calcula a integral da função especificada como
     primeiro argumento sobre o intervalo de lo a hi como em `quanc8
     ('função, lo, hi)'.  o nome da função pode receber apóstrofo.  A
     versão de 4 argumentos calculará a integral da função ou expressão
     (primeiro argumento) em relação à variável (segundo argumento) no
     intervalo de `lo' a `hi' como em `quanc8(<f(x) or expressão in x>,
     x, lo, hi)'.  O método usado é o da quadratura dos currais de
     Newton, e a rotina é adaptativa.  Isso irá dessa forma gastar
     tempo dividindo o intervalo somente quando necessário para
     completar as condições de erro especificadas pelas variáveis
     `quanc8_relerr' (valor padrão=1.0e-4) e `quanc8_abserr' (valor
     padrão=1.0e-8) que dão o teste de erro relativo:

          |integral(função) - valor calculado| < quanc8_relerr*|integral(função)|

     e o teste de erro absoluto:

          |integral(função) - valor calculado| < quanc8_abserr

     `printfile ("qq.usg")' yields additional informação.


 -- Função: quanc8 (<expr>, <a>, <b>)
     Um integrador adaptativo.  Demonstração e arquivos de utilização
     são fornecidos.  O método é para usar a regra da quadratura dos
     currais de Newton, daí o nome da função `quanc8', disponível em
     versões de 3 ou 4 argumentos.  Verificação de erro absoluto e erro
     relativo são usadas.  Para usar isso faça `load ("qq")'.  Veja
     também `qq'.


 -- Função: residue (<expr>, <z>, <z_0>)
     Calcula o resíduo no plano complexo da expressão <expr> quando a
     variável <z> assumes o valor <z_0>.  O resíduo é o coeficiente de
     `(<z> - <z_0>)^(-1)' nas séries de Laurent para <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Função: risch (<expr>, <x>)
     Integra <expr> em relação a <x> usando um caso transcendental do
     algorítmo de Risch.  (O caso algébrico do algorítmo de Risch foi
     implementado.)  Isso atualmente manuseia os casos de exponenciais
     aninhadas e logarítmos que a parte principal de `integrate' não
     pode fazer.  `integrate' irá aplicar automaticamente `risch' se
     dados esses casos.

     `erfflag', se `false', previne `risch' da introdução da função
     `erf' na resposta se não for achado nenhum no integrando para
     começar.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Função: romberg (<expr>, <x>, <a>, <b>)
 -- Função: romberg (<expr>, <a>, <b>)
     Integração de Romberg.  Existem dois caminhos para usar essa
     função.  O primeiro é um caminho ineficiente como a versão de
     integral definida de `integrate': `romberg (<integrando>,
     <variável of integração>, <lower limit>, <upper limit>)'.

     Exemplos:

          (%i1) showtime: true$
          (%i2) romberg (sin(y), y, 0, %pi);
          Evaluação took 0.00 seconds (0.01 elapsed) using 25.293 KB.
          (%o2)                   2.000000016288042
          (%i3) 1/((x-1)^2+1/100) + 1/((x-2)^2+1/1000) + 1/((x-3)^2+1/200)$
          (%i4) f(x) := ''%$
          (%i5) rombergtol: 1e-6$
          (%i6) rombergit: 15$
          (%i7) romberg (f(x), x, -5, 5);
          Evaluação took 11.97 seconds (12.21 elapsed) using 12.423 MB.
          (%o7)                   173.6730736617464

     O segundo é um caminho eficiente que é usado como segue:

          romberg (<função name>, <lower limit>, <upper limit>);

     Continuando o exemplo acima, temos:
          (%i8) f(x) := (mode_declare ([função(f), x], float), ''(%th(5)))$
          (%i9) translate(f);
          (%o9)                          [f]
          (%i10) romberg (f, -5, 5);
          Evaluação took 3.51 seconds (3.86 elapsed) using 6.641 MB.
          (%o10)                  173.6730736617464

     O primeiro argumento deve ser uma função trauzida ou compilada.
     (Se for compilada isso deve ser declarado para retorno a
     `flonum'.)  Se o primeiro argumento não for já traduzido,
     `romberg' não tentará traduzí-lo mas resultará um erro.

     A precisão da integração é governada pelas variáveis globais
     `rombergtol' (valor padrão 1.E-4) e `rombergit' (valor padrão 11).
     `romberg' retornará um resultado se a diferença relativa em
     sucessivas aproximações for menor que `rombergtol'.  Isso tentará
     dividir ao meio o tamanho do passo `rombergit' vezes antes que
     isso seja abandonado.  O número de iterações e avaliações da
     função que `romberg' fará é governado por `rombergabs' e
     `rombergmin'.

     `romberg' pode ser chamada recursivamente e dessa forma pode fazer
     integrais duplas e triplas.

     Exemplo:
          (%i1) assume (x > 0)$
          (%i2) integrate (integrate (x*y/(x+y), y, 0, x/2), x, 1, 3)$
          (%i3) radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o3)             - --------------------------
                                          3
          (%i4) %,numer;
          (%o4)                   .8193023963959073
          (%i5) define_variable (x, 0.0, float, "Global variável in função F")$
          (%i6) f(y) := (mode_declare (y, float), x*y/(x+y))$
          (%i7) g(x) := romberg ('f, 0, x/2)$
          (%i8) romberg (g, 1, 3);
          (%o8)                   .8193022864324522

     A vantagem com esse caminho é que a função `f' pode ser usada para
     outros propósitos, como imprimir gráficos.  A desvantagem é que
     você tem que inventar um nome para ambas a função `f' e sua
     variável independente `x'.  Ou, sem a variável global:

          (%i1) g_1(x) := (mode_declare (x, float), romberg (x*y/(x+y), y, 0, x/2))$
          (%i2) romberg (g_1, 1, 3);
          (%o2)                   .8193022864324522

     A vantagem aqui é que o código é menor.

          (%i3) q (a, b) := romberg (romberg (x*y/(x+y), y, 0, x/2), x, a, b)$
          (%i4) q (1, 3);
          (%o4)                   .8193022864324522

     Isso é sempre o caminho mais curto, e as variáveis não precisam
     ser declaradas porque elas estão no contexto de `romberg'.  O uso
     de `romberg' para integrais multiplas pode ter grandes
     desvantagens, apesar disso.  O amontoado de cálculos extras
     necessários por causa da informação geométrica descartada durante
     o processo pela expressão de integrais multiplas por esse caminho
     pode ser incrível.  O usuário deverá ter certeza de entender e
     usar os comutadores `rombergtol' e `rombergit'.


 -- Variável de opção: rombergabs
     Valor padrão: 0.0

     Assumindo que estimativas sucessivas produzidas por `romberg' são
     `y[0]', `y[1]', `y[2]', etc., então `romberg' retornará após `n'
     iterações se (grasseiramente falando)

           (abs(y[n]-y[n-1]) <= rombergabs ou
           abs(y[n]-y[n-1])/(if y[n]=0.0 then 1.0 else y[n]) <= rombergtol)

     for `true'.  (A condição sobre o número de iterações dadas por
     `rombergmin' deve também ser satisfeita.)  Dessa forma se
     `rombergabs' é 0.0 (o padrão) você apenas pega o teste de erro
     relativo.  A utilidade de uma variável adicional vem quando você
     executar uma integral, quando a contribuição dominante vem de uma
     pequena região.  Então você pode fazer a integral sobre uma pequena
     região dominante primeiro, usando a verificação relativa de
     precisão, seguida pela integral sobre o restante da região usando
     a verificação absoluta de erro.

     Exemplo:  Suponha que você quer calcular

          'integrate (exp(-x), x, 0, 50)

     (numericamente) com uma precisão relativa de 1 parte em 10000000.
     Defina a função.  `n' é o contador, então nós podemos ver quantas
     avaliações de função foram necessárias.  Primeiro de tudo tente
     fazer a integral completa de uma só vez.

          (%i1) f(x) := (mode_declare (n, integer, x, float), n:n+1, exp(-x))$
          (%i2) translate(f)$
          Warning-> n é an undefined global variable.
          (%i3) block ([rombergtol: 1.e-6, romberabs: 0.0], n:0, romberg (f, 0, 50));
          (%o3)                   1.000000000488271
          (%i4) n;
          (%o4)                          257

     Que aproximadamente precisou de 257 avaliações de função .   Agora
     faça a integral inteligentemente, primeiro fazendo
     `'integrate (exp(-x), x, 0, 10)' e então escolhendo `rombergabs'
     para 1.E-6 vezes (nessa      integral parcial).  Isso
     aproximdamente pega somente 130 avaliações de função.

          (%i5) block ([rombergtol: 1.e-6, rombergabs:0.0, sum:0.0],
            n: 0, sum: romberg (f, 0, 10), rombergabs: sum*rombergtol, rombergtol:0.0,
                sum + romberg (f, 10, 50));
          (%o5)                   1.000000001234793
          (%i6) n;
          (%o6)                          130

     Então se `f(x)' onde a função pegou um longo tempo de computação, o
     segundo método fez a mesma tarefa 2 vezes mais rápido.


 -- Variável de opção: rombergit
     Valor padrão: 11

     A precisão do comando `romberg' de integração é governada pelas
     variáveis globais `rombergtol' e `rombergit'.  `romberg' retornará
     um resultado se a diferença relativa em sucessivas approximações é
     menor que `rombergtol'.  Isso tentará dividir ao meio o tamanho do
     passoe `rombergit' vezes antes disso ser abandonado.


 -- Variável de opção: rombergmin
     Valor padrão: 0

     `rombergmin' governa o número mínimo de avaliações de função que
     `romberg' fará.  `romberg' avaliará seu primeiro argumento pelo
     menos `2^(rombergmin+2)+1' vezes.  Isso é útil para integrar
     funções oscilatórias, onde o teste normal de convergência pode
     lgumas vezes inadequadamente passar.


 -- Variável de opção: rombergtol
     Valor padrão: 1e-4

     A precisão do comando de integração de `romberg' é governada pelas
     variáveis globais `rombergtol' e `rombergit'.  `romberg' retornará
     um resultado se a difereça relativa em sucessivas aproximações é
     menor que `rombergtol'.  Isso tentará dividir ao meio o tamanho do
     passo `rombergit' vezes antes disso ser abandonado.


 -- Função: tldefint (<expr>, <x>, <a>, <b>)
     Equivalente a `ldefint' com `tlimswitch' escolhido para `true'.


 -- Função: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, <epsrel>, <limit>)
     Numericamente avalia a integral

     integrate (f(x), x, a, b)

     usando um integrador adaptativo simples.

     A função a ser integrada é <f(x)>, com variável dependente <x>, e
     a função é para ser integrada entre os limites <a> e <b>.  <key> é
     o integrador a ser usado e pode ser um inteiro entre 1 e 6,
     inclusive.  O valor de <key> seleciona a ordem da regra de
     integração de Gauss-Kronrod.

     A integração numérica é concluída adaptativamente pela subdivisão a
     região de integração até que a precisão desejada for completada.

     Os argumentos opcionais <epsrel> e <limit> são o erro relativo
     desejado e o número máximo de subintervalos respectivamente.
     <epsrel> padrão em 1e-8 e <limit> é 200.

     `quad_qag' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          se nenhum problema for encontrado;

    `1'
          se muitos subintervalos foram concluídos;

    `2'
          se erro excessivo é detectado;

    `3'
          se ocorre comportamento extremamente ruim do integrando;

    `6'
          se a entrada é inválida.


     Exemplos:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Função: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limit>)
     Integra numericamente a função dada usando quadratura adaptativa
     com extrapolação.  A função a ser integrated é <f(x)>, com
     variável dependente <x>, e a função é para ser integrada entre os
     limites <a> e <b>.

     Os argumentos opcionais <epsrel> e <limit> são o erro relativo
     desejado e o número máximo de subintervalos, respectivamente.
     <epsrel> padrão em 1e-8 e <limit> é 200.

     `quad_qags' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          muitos subintervalos foram concluídos;

    `2'
          erro excessivo é detectado;

    `3'
          ocorreu comportamento excessivamente ruim do integrando;

    `4'
          falhou para convergência

    `5'
          integral é provavelmente divergente ou lentamente convergente

    `6'
          se a entrada é inválida.

     Exemplos:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Note que `quad_qags' é mais preciso e eficiente que `quad_qag'
     para esse integrando.


 -- Função: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limit>)
     Avalia numericamente uma das seguintes integrais

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, a, minf, inf)

     usando a rotina Quadpack QAGI.  A função a ser integrada é <f(x)>,
     com variável dependente <x>, e a função é para ser integrada sobre
     um intervalo infinito.

     O parâmetro <inftype> determina o intervalo de integração como
     segue:

    `inf'
          O intervalo vai de <a> ao infinito positivo.

    `minf'
          O intervalo vai do infinito negativo até <a>.

    `both'
          O intervalo corresponde a toda reta real.

     Os argumentos opcionais <epsrel> e <limit> são o erro relativo
     desejado e o número maximo de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limit> é 200.

     `quad_qagi' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          muitos subintervalos foram concluídos;

    `2'
          erro excessivo é detectado;

    `3'
          ocorreu comportamento excessivamente ruim do integrando;

    `4'
          falhou para convergência;

    `5'
          integral é provavelmente divergente ou lentamente convergente;

    `6'
          se a entrada for inválida.


     Exemplos:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Função: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limit>)
     Calcula numericamente o valor principal de Cauchy de

     integrate (f(x)/(x - c), x, a, b)

     usando a rotina Quadpack QAWC.  A função a ser integrada é
     `<f(x)>/(<x> - <c>)', com variável dependente <x>, e a função é
     para ser integrada sobre o intervalo que vai de <a> até <b>.

     Os argumentos opcionais <epsrel> e <limit> são o erro relativo
     desejado e o máximo número de subintervalos, respectivamente.
     <epsrel> padrão para 1e-8 e <limit> é 200.

     `quad_qawc' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valoor de retorno) pode ter
     os valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          muitos subintervalos foram concluídos;

    `2'
          erro excessivo é detectado;

    `3'
          ocorreu comportamento excessivamente ruim do integrando;

    `6'
          se a entrada é inválida.


     Exemplos:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                   3 alpha                       3 alpha
                   -------                       -------
                      2            alpha/2          2          alpha/2
                2 4        atan(4 4       )   2 4        atan(4       )   alpha
              - --------------------------- - -------------------------)/2
                          alpha                        alpha
                       2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Função: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
     Calcula numericamente a integral tipo Fourier usando a rotina
     Quadpack QAWF.  A integral é

     integrate (f(x)*w(x), x, a, inf)

     A função peso w é selecionada por <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Os argumentos opcionais são:

    <epsabs>
          Erro absoluto de aproximação desejado.  Padrão é 1d-10.

    <limit>
          Tamanho de array interno de trabalho.  (<limit> - <limlst>)/2
          é o maximo número de subintervalos para usar.  O Padrão é 200.

    <maxp1>
          O número máximo dos momentos de Chebyshev.  Deve ser maior
          que 0.  O padrão é 100.

    <limlst>
          Limite superior sobre número de ciclos.  Deve ser maior ou
          igual a 3.  O padrão é 10.

     <epsabs> e <limit> são o erro relativo desejado e o número maximo
     de subintervalos, respectivamente.  <epsrel> padrão para 1e-8 e
     <limit> é 200.

     `quad_qawf' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          muitos subintervalos foram concluídos;

    `2'
          erro excessivo é detectado;

    `3'
          ocorreu um comportamento excessivamente ruim do integrando;

    `6'
          se a entrada é invalida.


     Exemplos:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Função: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          <epsabs>, <limit>, <maxp1>, <limlst>)
     Calcula numericamente a integral usando a rotina Quadpack QAWO:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é selecionada por <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Os argumentos opcionais são:

    <epsabs>
          Erro absoluto desejado de aproximação.  O Padrão é 1d-10.

    <limit>
          Tamanho do array interno de trabalho.  (<limit> - <limlst>)/2
          é o número máximo de subintervalos a serem usados.  Default é
          200.

    <maxp1>
          Número máximo dos momentos de Chebyshev.  Deve ser maior que
          0.  O padrão é 100.

    <limlst>
          Limite superior sobre o número de ciclos.  Deve ser maior que
          ou igual a 3.  O padrão é 10.

     <epsabs> e <limit> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limit> é 200.

     `quad_qawo' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          muitos subintervalos foram concluídos;

    `2'
          erro excessivo é detectado;

    `3'
          comportamento extremamente ruim do integrando;

    `6'
          se a entrada é inválida.


     Exemplos:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Função: quad_qaws (<f(x)>, <x>, <a>, <b>, <alfa>, <beta>, <wfun>,
          <epsabs>, <limit>)
     Numéricamente calcula a integral usando a rotina Quadpack QAWS:

     integrate (f(x)*w(x), x, a, b)

     A função peso w é selecionada por <wfun>:

    `1'
          w(x) = (x - a)^alfa (b - x)^beta

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alfa (b - x)^beta log(b - x)

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a) log(b - x)

     O argumentos opcionais são:

    <epsabs>
          Erro absoluto desejado de aproximação.  O padrão é 1d-10.

    <limit>
          Tamanho do array interno de trabalho.  (<limit> - <limlst>)/2
          é o número máximo de subintervalos para usar.  O padrão é 200.

     <epsabs> e <limit> são o erro relativo desejado e o número máximo
     de subintervalos, respectivamente.  <epsrel> o padrão é 1e-8 e
     <limit> é 200.

     `quad_qaws' retorna uma lista de quatro elementos:

        * uma aproximação para a integral,

        * o erro absoluto estimado da aproximação,

        * o número de avaliações do integrando,

        * um código de erro.

     O código de erro (quarto elemento do valor de retorno) pode ter os
     valores:

    `0'
          nenhum problema foi encontrado;

    `1'
          muitos subintervalos foram concluídos;

    `2'
          erro excessivo é detectado;

    `3'
          ocorreu um comportamento excessivamente ruim do integrando;

    `6'
          se a entrada é invalida.


     Exemplos:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Equações,  Next: Equações Diferenciais,  Prev: Integração,  Up: Top

22 Equações
***********

* Menu:

* Definições para Equações::


File: maxima.info,  Node: Definições para Equações,  Prev: Equações,  Up: Equações

22.1 Definições para Equações
=============================

 -- Variável: %rnum_list
     Valor padrão: `[]'

     `%rnum_list' é a lista de variáveis introduzidas em soluções por
     `algsys'.  `%r' variáveis São adicionadas a `%rnum_list' na ordem
     em que forem criadas.  Isso é conveniente para fazer substituições
     dentro da solução mais tarde.  É recomendado usar essa lista em
     lugar de fazer `concat ('%r, j)'.


 -- Variável: algexact
     Valor padrão: `false'

     `algexact' afeta o comportamento de `algsys' como segue:

     Se `algexact' é `true', `algsys' sempre chama `solve' e então usa
     `realroots' sobre falhas de `solve'.

     Se `algexact' é `false', `solve' é chamada somente se o eliminante
     não for de uma variável, ou se for uma quadrática ou uma
     biquadrada.

     Dessa forma `algexact: true' não garante soluções exatas, apenas
     que `algsys' tentará primeiro pegar soluções exatas, e somente
     retorna aproximações quando tudo mais falha.


 -- Função: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Função: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resolve polinômios simultâneos <expr_1>, ..., <expr_m> ou equações
     polinômiais <eqn_1>, ..., <eqn_m> para as variáveis <x_1>, ...,
     <x_n>.  Uma expressão <expr> é equivalente a uma equação `<expr> =
     0'.  Pode existir mais equações que variáveis ou vice-versa.

     `algsys' retorna uma lista de soluções, com cada solução dada com
     uma lista de valores de estado das equações das variáveis <x_1>,
     ..., <x_n> que satisfazem o sistema de equações.  Se `algsys' não
     pode achar uma solução, uma lista vazia `[]' é retornada.

     Os símbolos `%r1', `%r2', ..., são introduzidos tantos quantos
     forem necessários para representar parâmetros arbitrários na
     solução; essas variáveis são também anexadas à lista `%rnum_list'.

     O método usado é o seguinte:

     (1) Primeiro as equações são fatoradas e quebradas em subsistemas.

     (2) Para cada subsistema <S_i>, uma equação <E> e uma variável <x>
     são selecionados.  A variável é escolhida para ter o menor grau
     não zero.  Então a resultante de <E> e <E_j> em relação a <x> é
     calculada para cada um das equações restantes <E_j> nos
     subsistemas <S_i>.  Isso retorna um novo subsistema <S_i'> em umas
     poucas variáveis, como <x> tenha sido eliminada.  O processo agora
     retorna ao passo (1).

     (3) Eventualmente, um subsistema consistindo de uma equação
     simples é obtido.  Se a equação é de várias variáveis e
     aproximações na forma de números em ponto flutuante nã tenham sido
     introduzidas, então `solve' é chamada para achar uma solução exata.

     Em alguns casos, `solve' não está habilitada a achar uma solução,
     ou se isso é feito a solução pode ser uma expressão expressão
     muito larga.

     Se a equação é de uma única variável e é ou linear, ou quadrática,
     ou biquadrada, então novamente `solve' é chamada se aproximações
     não tiverem sido introduzidas.  Se aproximações tiverem sido
     introduzidas ou a equação não é de uma única variável e nem tão
     pouco linear, quadratica, ou biquadrada, então o comutador
     `realonly' é `true', A função `realroots' é chamada para achar o
     valor real das soluções.  Se `realonly' é `false', então
     `allroots' é chamada a qual procura por soluções reais e complexas.

     Se `algsys' produz uma solução que tem poucos digitos
     significativos que o requerido, o usuário pode escolher o valor de
     `algepsilon' para um valor maior.

     Se `algexact' é escolhido para `true', `solve' será sempre chamada.

     (4) Finalmente, as soluções obtidas no passo (3) são substituídas
     dentro dos níveis prévios e o processo de solução retorna para (1).

     Quando `algsys' encontrar uma equação de várias variáveis que
     contém aproximações em ponto flutuante (usualmente devido a suas
     falhas em achar soluções exatas por um estágio mais fácil), então
     não tentará aplicar métodos exatos para tais equações e em lugar
     disso imprime a mensagem: "`algsys' cannot solve - system too
     complicated."

     Interações com `radcan' podem produzir expressões largas ou
     complicadas.  Naquele caso, pode ser possível isolar partes do
     resultado com `pickapart' ou `reveal'.

     Ocasionalmente, `radcan' pode introduzir uma unidade imaginária
     `%i' dentro de uma solução que é atualmente avaliada como real.

     Exemplos:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Função: allroots (<expr>)
 -- Função: allroots (<eqn>)
     Calcula aproximações numéricas de raízes reais e complexas do
     polinômio <expr> ou equação polinômial <eqn> de uma variável.

     O sinalizador `polyfactor' quando `true' faz com que `allroots'
     fatore o polinômio sobre os números reais se o polinômio for real,
     ou sobre os números complexos, se o polinômio for complexo.

     `allroots' pode retornar resultados imprecisos no caso de
     multiplas raízes.  Se o polinômio for real, `allroots (%i*<p>)')
     pode retornar aproximações mais precisas que `allroots (<p>)',
     como `allroots' invoca um algorítmo diferente naquele caso.

     `allroots' rejeita não-polinômios.  Isso requer que o numerador
     após a classificação (`rat''ing) poderá ser um polinômio, e isso
     requer que o denominador seja quando muito um número complexo.
     Com um resultado disso `allroots' irá sempre retornar uma
     expressão equivalente (mas fatorada), se `polyfactor' for `true'.

     Para polinômios complexos um algorítmo por Jenkins and Traub é
     usado (Algorithm 419, Comm.  ACM, vol.  15, (1972), p.  97).  Para
     polinômios reais o algorítmo usado é devido a Jenkins (Algorithm
     493, ACM TOMS, vol.  1, (1975), p.178).

     Exemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Variável: backsubst
     Valor padrão: `true'

     Quando `backsubst' é `false', evita substituições em expressões
     anteriores após as equações terem sido triangularizadas.  Isso pode
     ser de grande ajuda em problemas muito grandes onde substituição
     em expressões anteriores pode vir a causar a geração de expressões
     extremamente largas.


 -- Variável: breakup
     Valor padrão: `true'

     Quando `breakup' é `true', `solve' expressa soluções de equações
     cúbicas e quárticas em termos de subexpressões comuns, que são
     atribuídas a rótulos de expressões intermediárias (`%t1', `%t2',
     etc.).  De outra forma, subexpressões comuns não são identificadas.

     `breakup: true' tem efeito somente quando `programmode' é `false'.

     Exemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Função: dimension (<eqn>)
 -- Função: dimension (<eqn_1>, ..., <eqn_n>)
     `dimen' é um pacote de análise dimensional.  `load ("dimen")'
     chama esse pacote.  `demo ("dimen")' mostra uma cura demostração.


 -- Variável: dispflag
     Valor padrão: `true'

     Se escolhida para `false' dentro de um `block' inibirá a
     visualização da saída gerada pelas funções solve chamadas de
     dentro de `block'.  Terminando `block' com um sinal de dolar, $,
     escolhe `dispflag' para `false'.


 -- Função: funcsolve (<eqn>, <g>(<t>))
     Retorna `[<g>(<t>) = ...]'  ou `[]', dependendo de existir ou não
     uma função racional `<g>(<t>)' satisfazendo <eqn>, que deve ser de
     primeira ordem, polinômio linear em (para esse caso) `<g>(<t>)'
     and `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Equações dependentes eliminadas:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Atenção: essa é uma implementação muito rudimentar - muitas
     verificações de segurança e obviamente generalizações estão
     ausêntes.


 -- Variável: globalsolve
     Valor padrão: `false'

     When `globalsolve' for `true', variáveis para as quais as equações
     são resolvidas são atribuidas aos valores da solução encontrados
     por `linsolve', e por `solve' quando resolvendo duas ou mais
     equações lineares.  Quando `globalsolve' for `false', soluções
     encontradas por `linsolve' e por `solve' quando resolvendo duas ou
     mais equações lineares são espressas como equações, e as variáveis
     para as quais a equação foi resolvida não são atribuidas.

     Quando resolvendo qualquer coisa outra que não duas equações
     lineares ou mais, `solve' ignora `globalsolve'.  Outras funções
     que resolvem equações (e.g., `algsys') sempre ignoram
     `globalsolve'.

     Exemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Função: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     `inteqn' é um pacote para resolver equações integrais.  `load
     ("inteqn")' carrega esse pacote.

     <ie> é a equação integral; <unk> é a função desconhecida; <tech> é
     a técnica a ser tentada nesses dados acima (<tech> = `first'
     significa: tente a primeira técnica que achar uma solução; <tech>
     = `all' significa: tente todas a técnicas aplicáveis); <n> é o
     número máximo de termos a serem usados de `taylor', `neumann',
     `firstkindseries', ou `fredseries' (isso é também o número máximo
     de ciclos de recurssão para o método de diferenciação); <guess> é
     o inicial suposto para `neumann' ou `firstkindseries'.

     Valores padrão do segundo até o quinto parâmetro são:

     <unk>: `<p>(<x>)', onde <p> é a primeira função encontrada em um
     integrando que é desconhecida para Maxima e <x> é a variável que
     ocorre como um argumento para a primeira ocorrência de <p> achada
     fora de uma integral no caso de equações `secondkind' , ou é
     somente outra variável ao lado da variável de integração em
     equações `firstkind'.  Se uma tentativa de procurar por <x> falha,
     o usuário será perguntado para suprir a variável independente.

     tech: `first'

     n: 1

     guess: `none' o que fará com que `neumann' e `firstkindseries' use
     `<f>(<x>)' como uma suposição inicial.


 -- Variável de opção: ieqnprint
     Valor padrão: `true'

     `ieqnprint' governa o comportamento do resultado retornado pelo
     comando `ieqn'.  Quando `ieqnprint' é `false', as listas
     retornadas pela função `ieqn' são da forma

     [<solução>, <tecnica usada>, <nterms>, <sinalizador>]

     onde <sinalizador> é retirado se a solução for exata.

     De outra forma, isso é a palavra `approximate' ou `incomplete'
     correspondendo à forma inexata ou forma aberta de solução,
     respectivamente.  Se um método de série foi usado, <nterms>
     fornece o número de termos usados (que poderá ser menor que os n
     dados para `ieqn' se ocorrer um erro evita a geração de termos
     adicionais).


 -- Function: lhs (<expr>)
     Retorna o lado esquerdo (isto é, o primeiro argumento) da
     expressão <expr>, quando o operador de <expr> for um dos
     operadores relacionais `< <= = # equal notequal >= >', um dos
     operadores de atribuição `:= ::= : ::', ou um operadro infixo
     definido pelo usuário, como declarado por meio de `infix'.

     Quando <expr> for um átomo ou seu operador for alguma coisa que
     não esses listados acima, `lhs' retorna <expr>.

     Veja também `rhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Função: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resolve a lista de equações lineares simultâneas para a lista de
     variáveis.  As expressões devem ser cada uma polinômios nas
     variáveis e podem ser equações.

     Quando `globalsolve' é `true' então variáveis que foram resolvidas
     serão escolhidas para a solução do conjunto de equações
     simultâneas.

     Quando `backsubst' é `false', `linsolve' não realiza substituição
     em equações anteriores após as equações terem sido
     triangularizadas.  Isso pode ser necessário em problemas muito
     grandes onde substituição em equações anteriores poderá causar a
     geração de expressões extremamente largas.

     Quando `linsolve_params' é `true', `linsolve' também gera símbolos
     `%r' usados para representar parâmetros arbitrários descritos no
     manual sob `algsys'.  De outra forma, `linsolve' resolve um
     menor-determinado sistema de equações com algumas variáveis
     expressas em termos de outras.

          (%i1) e1: x + z = y$
          (%i2) e2: 2*a*x - y = 2*a^2$
          (%i3) e3: y - 2*z = 2$
          (%i4) linsolve ([e1, e2, e3], [x, y, z]);
          (%o4)            [x = a + 1, y = 2 a, z = a - 1]


 -- Variável: linsolvewarn
     Valor padrão: `true'

     Quando `linsolvewarn' é `true', `linsolve' imprime uma mensagem
     "Dependent equações eliminated".


 -- Variável: linsolve_params
     Valor padrão: `true'

     Quando `linsolve_params' é `true', `linsolve' também gera os
     símbolos `%r' usados para representar parâmetros arbitrários
     descritos no manual sob `algsys'.  De outra forma, `linsolve'
     resolve um menor-determinado sistema de equações com algumas
     variáveis expressas em termos e outras.


 -- Variável: multiplicities
     Valor padrão: `not_set_yet'

     `multiplicities' é escolhida para uma lista de multiplicidades das
     soluções individuais retornadas por `solve' ou `realroots'.


 -- Função: nroots (<p>, <low>, <high>)
     Retorna o número de raízes reais do polinômio real de uma única
     variável <p> no intervalo semi-aberto `(<low>, <high>]'.  Uma
     extremidade do intervalo podem ser `minf' ou `inf'.  infinito e
     mais infinito.

     `nroots' usa o método das sequüências de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Função: nthroot (<p>, <n>)
     Onde p é um polinômio com coeficientes inteiros e n é um inteiro
     positivo retorna q, um polinômio sobre os inteiros, tal que q^n=p
     ou imprime uma mensagem de erro indicando que p não é uma potência
     n-ésima perfeita.  Essa rotina é mais rápida que `factor' ou mesmo
     `sqfr'.


 -- Variável: programmode
     Valor padrão: `true'

     Quando `programmode' é `true', `solve', `realroots', `allroots', e
     `linsolve' retornam soluções como elementos em uma lista.  (Exceto
     quando `backsubst' é escolhido para `false', nesse caso
     `programmode: false' é assumido.)

     Quando `programmode' é `false', `solve', etc.  cria rótulos de
     expressões intermediárias `%t1', `t2', etc., e atribui as soluções
     para eles.


 -- Variável: realonly
     Valor padrão: `false'

     Quando `realonly' é `true', `algsys' retorna somente aquelas
     soluções que estão livres de `%i'.


 -- Função: realroots (<poly>, <bound>)
     Acha todas as raízes reais de um polinômio também real de uma
     única variável poly dentro de uma tolerância de limite que, se
     menor que 1, faz com que todas as raízes da integral sejam achadas
     exatamente.  O parâmetro limite pode ser arbitrariamente pequeno
     com o objetivo de encontrar qualquer precisão desejada.  O
     primeiro argumento pode também ser uma equação.  `realroots'
     escolhe `multiplicities', útil em caso de multiplas raízes.
     `realroots (<p>)' é equivalente a `realroots (<p>, rootsepsilon)'.
     `rootsepsilon' é um número real usado para estabelecer um
     intervalo de confidência para as ra@'izes.  Faça `example
     (realroots)' para um exemplo.


 -- Função: rhs (<expr>)
     Retorna o lado direito (isto é, o segundo argumento) da expressão
     <expr>, quando o operador de <expr> for um dos operadores
     relacionais `< <= = # equal notequal >= >', um dos operadores de
     atribuição `:= ::= : ::', ou um operador binário infixo definido
     pelo usuário, como declarado por meio de `infix'.

     Quando <expr> for um étomo ou seu operadro for alguma coisa que
     não esses listados acima, `rhs' retorna 0.

     Veja também `lhs'.

     Exemplos:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Variável de opção: rootsconmode
     Valor padrão: `true'

     `rootsconmode' governa o comportamento do comando `rootscontract'.
     Veja `rootscontract' para detalhes.


 -- Função: rootscontract (<expr>)
     Converte produtos de raízes em raízes de produtos.  Por exemplo,
     `rootscontract (sqrt(x)*y^(3/2))' retorna `sqrt(x*y^3)'.

     Quando `radexpand' é `true' e `domain' é `real', `rootscontract'
     converte `abs' em `sqrt', e.g., `rootscontract (abs(x)*sqrt(y))'
     retorna `sqrt(x^2*y)'.

     Existe uma opção `rootsconmode' afetando `rootscontract' como
     segue:

          Problem            Value of        Result of applying
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Quando `rootsconmode' é `false', `rootscontract' contrai somente
     como relação a expoentes de número racional cujos denominadores
     são os mesmos.  A chave para os exemplos `rootsconmode: true' é
     simplesmente que 2 divides 4 mas não divide 3.  `rootsconmode:
     all' envolve pegar o menor multiplo comum dos denominadores dos
     expoentes.

     `rootscontract' usa `ratsimp' em uma maneira similar a
     `logcontract'.

     Exemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Variável de opção: rootsepsilon
     Valor padrão: 1.0e-7

     `rootsepsilon' é a tolerância que estabelece o intervalo de
     conficência para as raízes achadas pela função `realroots'.


 -- Função: solve (<expr>, <x>)
 -- Função: solve (<expr>)
 -- Função: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resolve a equação algébrica <expr> para a variável <x> e retorna
     uma lista de equações solução em <x>.  Se <expr> não é uma
     equação, a equação `<expr> = 0' é assumida em seu lugar.  <x> pode
     ser uma função (e.g. `f(x)'), ou outra expressão não atômica
     exceto uma adição ou um produto.  <x> pode ser omitido se <expr>
     contém somente uma variável.  <expr> pode ser uma expressão
     racional, e pode conter funções trigonométricas, exponenciais, etc.

     O seguinte método é usado:

     Tome <E> sendo a expressão e <X> sendo a variável.  Se <E> é
     linear em <X> então isso é trivialmente resolvido para <X>.  De
     outra forma se <E> é da forma `A*X^N + B' então o resultado é
     `(-B/A)^1/N)' vezes as `N''ésimas raízes da unidade.

     Se <E> não é linear em <X> então o máximo divisor comum (mdc) dos
     expoentes de <X> em <E> (digamos <N>) é dividido dentro dos
     expoentes e a multiplicidade das raízes é multiplicada por <N>.
     Então `solve' é chamada novamente sobre o resultado.  Se <E> for
     dada em fatores então `solve' é chamada sobre cada um dos fatores.
     Finalmente `solve' usará as fórmulas quadráticas, cúbicas, ou
     quárticas onde necessário.

     No caso onde <E> for um polinômio em alguma função de variável a
     ser resolvida, digamos `F(X)', então isso é primeiro resolvida
     para `F(X)' (chama o resultado <C>), então a equação `F(X)=C' pode
     ser resolvida para <X> fornecendo o inverso da função <F> que é
     conhecida.

     `breakup' se `false' fará com que `solve' expresse as soluções de
     equações cúbicas ou quárticas como expressões simples ao invés de
     como feito em cima de várias subexpressões comuns que é o padrão.

     `multiplicities' - será escolhido para uma lista de
     multiplicidades de soluções individuais retornadas por `solve',
     `realroots', ou `allroots'.  Tente `apropos (solve)' para os
     comutadores que afetam `solve'.  `describe' pode então ser usada
     sobre o nome do comutador individual se seu proprósito não é claro.

     `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])' resolve um
     sistema de equações polinomiais (lineares ou não-lineares)
     simultâneas por chamada a `linsolve' ou `algsys' e retorna uma
     lista de listas solução nas variáveis.  No caso de `linsolve' essa
     lista conterá uma lista simples de soluções.  Isso pega duas
     listas como argumentos.  A primeira lista representa as equações a
     serem resolvidas; a segunda lista é a lista de desconhecidos a ser
     determinada.  Se o número total de variáveis nas equações é igual
     ao número de equações, a segunda lista-argumento pode ser omitida.
     Para sistemas lineares se as dadas equações não são compatíveis,
     a mensagem `inconsistent' será mostrada (veja o comutador
     `solve_inconsistent_error' ); se não existe solução única, então
     `singular' será mostrado.

     Exemplos:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some soluções will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Variável de opção: solvedecomposes
     Valor padrão: `true'

     Quando `solvedecomposes' é `true', `solve' chama `polydecomp' se
     perguntado para resolver polinômios.


 -- Variável de opção: solveexplicit
     Valor padrão: `false'

     Quando `solveexplicit' é `true', inibe `solve' de retornar
     soluções implícitas, isto é, soluções da forma `F(x) = 0' onde `F'
     é alguma função.


 -- Variável de opção: solvefactors
     Valor padrão: `true'

     Quando `solvefactors' é `false', `solve' não tenta fatorar a
     expressão.  O `false' escolhido pode ser desejado em alguns casos
     onde a fatoração não é necessária.


 -- Variável de opção: solvenullwarn
     Valor padrão: `true'

     Quando `solvenullwarn' é `true', `solve' imprime uma mensagem de
     alerta se chamada com ou uma lista equação ou uma variável lista
     nula.  Por exemplo, `solve ([], [])' imprimirá duas mensagens de
     alerta e retorna `[]'.


 -- Variável de opção: solveradcan
     Valor padrão: `false'

     Quando `solveradcan' é `true', `solve' chama `radcan' que faz
     `solve' lento mas permitirá certamente que problemas contendo
     exponeniais e logarítmos sejam resolvidos.


 -- Variável de opção: solvetrigwarn
     Valor padrão: `true'

     Quando `solvetrigwarn' é `true', `solve' pode imprimir uma
     mensagem dizendo que está usando funções trigonométricas inversas
     para resolver a equação, e desse modo perdendo soluções.


 -- Variável de opção: solve_inconsistent_error
     Valor padrão: `true'

     Quando `solve_inconsistent_error' é `true', `solve' e `linsolve'
     resultam em erro se as equações a serem resolvidas são
     inconsistentes.

     Se `false', `solve' e `linsolve' retornam uma lista vazia `[]' se
     as equações forem inconsistentes.

     Exemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equações:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Equações Diferenciais,  Next: Numérico,  Prev: Equações,  Up: Top

23 Equações Diferenciais
************************

* Menu:

* Definições para Equações Diferenciais::


File: maxima.info,  Node: Definições para Equações Diferenciais,  Prev: Equações Diferenciais,  Up: Equações Diferenciais

23.1 Definições para Equações Diferenciais
==========================================

 -- Função: bc2 (<solução>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resolve problema do valor limite para equações diferenciais de
     segunda ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval1> é uma equação para a
     variável independente na forma `<x> = <x0>', e <yval1> é uma
     equação para a variável dependente na forma `<y> = <y0>'.  A
     <xval2> e a <yval2> são equações para essas variáveis em outro
     ponto.  Veja `ode2' para exemplo de utilização.


 -- Função: desolve (<eqn>, <x>)
 -- Função: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     A função `dsolve' resolve sistemas de equações diferenciais
     ordinárias lineares usando transformada de Laplace.  Aqui as
     <eqn>'s são equações diferenciais nas variáveis dependentes <x_1>,
     ..., <x_n>.  A relação funcional deve ser explicitamente indicada
     em ambas as equações e as variáveis.  Por Exemplo

          'diff(f,x,2)=sin(x)+'diff(g,x);
          'diff(f,x)+x^2-f=2*'diff(g,x,2);

     não é o formato apropriado.  O caminho correto é:

          'diff(f(x),x,2)=sin(x)+'diff(g(x),x);
          'diff(f(x),x)+x^2-f=2*'diff(g(x),x,2);

     A chamada é então `desolve([%o3,%o4],[f(x),g(x)]);' .

     Se as condições iniciais em 0 são conhecidas, elas podem ser
     fornecidas antes chamando `desolve' através de `atvalue'.

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Se `desolve' não pode obter uma solução, retorna `false'.


 -- Função: ic1 (<solução>, <xval>, <yval>)
     Resolve o problema do valor inicial para equação diferencial de
     primeira ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval> é uma equação para a
     variável independente na forma `<x> = <x0>', e <yval> é uma
     equação para a variável dependente na forma `<y> = <y0>'. Veja
     `ode2' para exemplo de utilização.


 -- Função: ic2 (<solução>, <xval>, <yval>, <dval>)
     Resolve o problema do valor inicial para equação diferencial de
     segunda ordem.  Aqui: <solução> é uma solução geral para a
     equação, como encontrado por `ode2', <xval> é uma equação para a
     variável independente na forma `<x> = <x0>', <yval> é uma
     equação para a variável dependente na forma `<y> = <y0>', e <dval>
     é uma equação para a derivada da variável dependente com
     relação à variável independente avaliada no ponto <xval>.  Veja
     `ode2' para exemplo de utilização.


 -- Função: ode2 (<eqn>, <dvar>, <ivar>)
     A função `ode2' resolve equações diferenciais ordinária ou de
     primeira ou de segunda ordem.  Recebe três argumentos: uma EDO
     <eqn>, a variável dependente <dvar>, e a variável
     independente<ivar>.  Quando obtém sucesso, retorna ou uma
     solução (explícita ou implícita) para a variável dependente.  `%c'
     é usado para representar a constante no caso de equações de
     primeira ordem, e `%k1' e `%k2' as constantes para equações de
     segunda ordem.  Se `ode2' não pode obter a solução por alguma
     razão, retorna `false', após talvez mostra uma mensagem de erro.
     O método implementado para equações diferenciais de primeira ordem
     na seqüência na qual eles são testados são: linear, separável,
     exato - talvez requerendo um fator de integração, homogêneos,
     equação de Bernoulli, e um método homogêneo geral.  Para segunda
     ordem: coeficiente constante, exato, linear homogêneo com
     coeficientes não-constantes os quais podem ser transformados para
     coeficientes constates, o Euler ou equação equidimensional, o
     método de variação de parâmetros, e equações as quais são livres
     ou da variável independente ou da dependente de modo que elas
     possam ser reduzidas duas equações lineares de primeria ordem para
     serem resolvidas seqüêncialmente.  No curso de resolver EDOs,
     muitas variáveis são escolhidas puramente para propósitos
     informativos: `método' denota o método de solução usado e.g.
     `linear', `intfactor' denota qualquer fator de integração usado,
     `odeindex' denota o índice para o método de Bernoulli ou para o
     método homogêneo generalizado, e `yp' denota a solução particular
     para a técnica de variação de parâmetros.

     Com o objetivo de resolver os problemas dos valores iniciais
     (PVIs) e problemas dos valores limite (PVLs), a rotina `ic1' está
     disponível para equações de primeira ordem, e `ic2' e `bc2' para
     segunda ordem PVIs e PVLs, respectively.

     Example:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Numérico,  Next: Estatística,  Prev: Equações Diferenciais,  Up: Top

24 Numérico
***********

* Menu:

* Introdução a Numérico::
* Pacotes de Fourier::
* Definições para Numérico::
* Definições para Séries de Fourier::


File: maxima.info,  Node: Introdução a Numérico,  Next: Pacotes de Fourier,  Prev: Numérico,  Up: Numérico

24.1 Introdução a Numérico
==========================


File: maxima.info,  Node: Pacotes de Fourier,  Next: Definições para Numérico,  Prev: Introdução a Numérico,  Up: Numérico

24.2 Pacotes de Fourier
=======================

O pacote `fft' compreende funções para computação numérica (não
simbólica) das transformações rápidas de Fourier.  `load ("fft")' chama
esse pacote.  Veja `fft'.

   O pacote `fourie' compreende funções para computação simbólica de
séries de Fourier.  `load ("fourie")' chama esse pacote.  Existem
funções no pacote `fourie' para calcular coeficientes da integral de
Fourier e algumas funções para manipulação de expressões.  Veja
`Definições para Séries'.


File: maxima.info,  Node: Definições para Numérico,  Next: Definições para Séries de Fourier,  Prev: Pacotes de Fourier,  Up: Numérico

24.3 Definições para Numérico
=============================

 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Traduz valores complexos da forma `r %e^(%i t)' para a forma `a +
     b %i'.  `load ("fft")' chama essa função dentro do Maxima. Veja
     também `fft'.

     O módulo e a fase, `r' e `t', São tomados de <magnitude_array> e
     <phase_array>, respectivamente. Os valores originais de arrays de
     entrada são substituídos pelas partes real e emaginária, `a' e
     `b', no retorno. As saídas são calculadas como

          a: r cos (t)
          b: r sin (t)

     Os arrays de entrada devem ter o mesmo tamanho  e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `polartorect' é a função inversa de `recttopolar'.


 -- Função: recttopolar (<real_array>, <imaginary_array>)
     Traduz valores complexos da forma `a + b %i' para a forma `r
     %e^(%i t)'.  `load ("fft")' chama essa função dentro do Maxima.
     Veja também `fft'.

     As partes real e imaginária, `a' e `b', são tomadas de
     <real_array> e <imaginary_array>, respectivamente. Os valores
     originais dos arrays de entrada são substituídos pelo módulo e
     pelo ângulo, `r' e `t', no retorno. As saídas são calculadas como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     O ângulo calculado encontra-se no intervalo de `-%pi' a `%pi'.

     Os arrays de entrada devem ter o mesmo tamanho e ser
     unidimensionais.  O tamanho do array não deve ser uma potência de
     2.

     `recttopolar' é a função inversa de `polartorect'.


 -- Função: ift (<real_array>, <imaginary_array>)
     Transformação rápida inversa discreta de Fourier . `load ("fft")'
     chama essa função dentro do Maxima.

     `ift' realiza a transformação rápida complexa de Fourier sobre
     arrays em ponto flutuante unidimensionais. A transformação inversa
     é definida como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Veja `fft' para maiores detalhes.


 -- Função: fft (<real_array>, <imaginary_array>)
 -- Função: ift (<real_array>, <imaginary_array>)
 -- Função: recttopolar (<real_array>, <imaginary_array>)
 -- Função: polartorect (<magnitude_array>, <phase_array>)
     Transformação rápidada de Fourier e funções relacionadas. `load
     ("fft")' chama essas funções dentro do Maxima.

     `fft' e `ift' realiza transformação rápida complexa de Fourier e a
     transformação inversa, respectivamente, sobre arrays em ponto
     flutuante unidimensionais. O tamanho de <imaginary_array> deve ser
     igual ao tamanho de <real_array>.

     `fft' e `ift' operam in-loco. Isto é, sobre o retorno de `fft' ou
     de `ift', O conteúdo original dos arrays de entrada é substituído
     pela saída.  A função `fillarray' pode fazer uma cópia de um
     array, isso pode ser necessário.

     A transformação discreta de Fourier e sua transformação inversa
     são definidas como segue. Tome `x' sendo os dados originais, com

          x[i]: real_array[i] + %i imaginary_array[i]

     Tome `y' sendo os dados transformados. A transformação normal e
     sua transformação inversa são

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arrays adequadas podem ser alocadas pela função `array'. Por
     exemplo:

          array (my_array, float, n-1)$

     declara um array unidimensional com n elementos, indexado de 0 a
     n-1 inclusive. O número de elementos n deve ser igual a 2^m para
     algum m.

     `fft' pode ser aplicada a dados reais (todos os arrays imaginários
     são iguais a zero) para obter coeficientes seno e cosseno.  Após
     chamar `fft', os coeficientes seno e cosseno, digamos `a' e `b',
     podem ser calculados como

          a[0]: real_array[0]
          b[0]: 0

     e

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j variando de 1 a n/2-1, e

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     `recttopolar' traduz valores complexos da forma `a + b %i' para a
     forma `r %e^(%i t)'. Veja `recttopolar'.

     `polartorect' traduz valores complexos da forma `r %e^(%i t)' para
     a forma `a + b %i'. Veja `polartorect'.

     `demo ("fft")' exibe uma demonstração do pacote `fft'.


 -- Variável de opção: fortindent
     Valor padrão: 0

     `fortindent' controla a margem esquerda de indentação de
     expressões mostradas pelo comando `fortran'.  0 fornece indentação
     normal (i.e., 6 espaços), e valores positivos farão com que
     expressões sejam mostrados mais além para a direita.


 -- Função: fortran (<expr>)
     Mostra <expr> como uma declaração Fortran.  A linha de saída é
     indentada com espaços.  Se a linha for muito longa, `fortran'
     imprime linhas de continuação.  `fortran' mostra o operador de
     exponenciação `^' como `**', e mostra um número complexo `a + b
     %i' na forma `(a,b)'.

     <expr> pode ser uma equação. Nesse caso, `fortran' mostra uma
     declaração de atribuição, atribuindo o primeiro membro (esquerda)
     da equação ao segundo membro (direita).  Em particular, se o
     primeiro membro <expr> é um nome de uma matriz, então `fortran'
     mostra uma declaração de atribuição para cada elemento da matriz.

     Se <expr> não for alguma coisa reconhecida por `fortran', a
     expressão é mostrada no formato `grind' sem reclamação.  `fortran'
     não conhece listas, arrays ou funções.

     `fortindent' controla o margem esquerda das linhas mostradas.  0 é
     a margem normal (i.e., indentada 6 espaços). Incrementando
     `fortindent' faz com que expressões sejam mostradas adiante para a
     direita.

     quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.

     `fortran' avalia seus argumentos; colocando um apóstrofo em um
     argumento evita avaliação.  `fortran' sempre retorna `done'.

     Exemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Variável de opção: fortspaces
     Valor padrão: `false'

     Quando `fortspaces' for `true', `fortran' preenche cada linha
     mostrada com espaços em branco até completar 80 columas.


 -- Função: horner (<expr>, <x>)
 -- Função: horner (<expr>)
     Retorna uma representação rearranjada de <expr> como na regra de
     Horner, usando <x> como variável principal se isso for
     especificado.  `x' pode ser omitido e nesse caso a variável
     principal da forma de expressão racional canônica de <expr> é
     usada.

     `horner' algumas vezes melhora a estabilidade se `expr' for ser
     numericamente avaliada.  Isso também é útil se Maxima é usado para
     gerar programas para rodar em Fortran. Veja também `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Function: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Function: find_root (<f>, <a>, <b>)
     Encontra a raíz da função <f> com a variável <x> percorrendo o
     intervalo `[<a>, <b>]'.  A função deve ter um sinal diferente em
     cada ponto final.  Se essa condição não for alcançada, a action of
     the function is governed by `find_root_error'.  If
     `find_root_error' is `true' then an error occurs, otherwise the
     value of `find_root_error' is returned (thus for plotting
     `find_root_error' might be set to 0.0).  De outra forma (dado que
     Maxima pode avaliar o primeiro argumento no intervalo
     especificado, e que o intervalo é contínuo) `find_root' é
     garantido vir para cima com a raíz (ou um deles se existir mais
     que uma raíz).  A precisão de `find_root' é governada por
     `intpolabs' e `intpolrel' os quais devem ser números em ponto
     flutuante não negativos.  `find_root' encerrará quando o primeiro
     argumento avaliar para alguma coisa menor que ou igual a
     `intpolabs' ou se sucessivas aproximações da raíz diferirem por
     não mais que `intpolrel * <um dos aproximandos>'.  O valor padrão
     de `intpolabs' e `intpolrel' são 0.0 de forma que `find_root' pega
     como boa uma resposta como for possível com a precisão aritmética
     simples que tivermos.  O primeiro argumento pode ser uma equação.
     A ordem dos dois últimos argumentos é irrelevante.  Dessa forma

          find_root (sin(x) = x/2, x, %pi, 0.1);

     é equivalente a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     O método usado é uma busca binária no intervalo especificado pelos
     últimos dois argumentos.  Quando o resultado da busca for
     encontrado a função é fechada o suficiente para ser linear, isso
     inicia usando interpolação linear.

     Examples:
          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Variável de opção: find_root_abs
     Valor padrão: 0.0

     `find_root_abs' é a precisão do comando `find_root'. A precisão é
     governada por `find_root_abs' e `find_root_rel' que devem ser
     números não negativos em ponto flutuante.  `find_root' terminará
     quando o primeiro argumento avaliar para alguma coisa menor que ou
     igual a `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem por não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_abs' e `find_root_rel' são 0.0 de
     forma que `find_root' tome como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.


 -- Variável de opção: find_root_error
     Valor padrão: `true'

     `find_root_error' governa o comportamento de `find_root'.  Quando
     `find_root' for chamada, ela determina se a função a ser resolvida
     satisfaz ou não a condição que os valores da função nos pontos
     finais do intervalo de interpolação são opostos em sinal.  Se eles
     forem de sinais opostos, a interpolação prossegue.  Se eles forem
     de mesmo sinal, e `find_root_error' for `true', então um erro é
     sinalizado.  Se eles forem de mesmo sinal e `find_root_error' não
     for `true', o valor de `find_root_error' é retornado.  Dessa forma
     para montagem de gráfico, `find_root_error' pode ser escolhida
     para 0.0.


 -- Variável de opção: find_root_rel
     Valor padrão: 0.0

     `find_root_rel' é a precisão do comando `find_root' e é governada
     por `find_root_abs' e `find_root_rel' que devem ser números não
     negativos em ponto flutuante.  `find_root' terminará quando o
     primeiro argumento avaliar para alguma coisa menor que ou igual a
     `find_root_abs' ou se sucessivos aproximandos para a raíz
     diferirem de não mais que `find_root_rel * <um dos aproximandos>'.
     Os valores padrão de `find_root_labs' e `find_root_rel' é 0.0 de
     forma que `find_root' toma como boa uma resposta que for possível
     com a precisão aritmética simples que tivermos.



File: maxima.info,  Node: Definições para Séries de Fourier,  Prev: Definições para Numérico,  Up: Numérico

24.4 Definições para Séries de Fourier
======================================

 -- Função: equalp (<x>, <y>)
     Retorna `true' se `equal (<x>, <y>)' de outra forma `false' (não
     fornece uma mensagem de erro como `equal (x, y)' poderia fazer
     nesse caso).


 -- Função: remfun (<f>, <expr>)
 -- Função: remfun (<f>, <expr>, <x>)
     `remfun (<f>, <expr>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr>.

     `remfun (<f>, <expr>, <x>)' substitue todas as ocorrências de `<f>
     (<arg>)' por <arg> em <expr> somente se <arg> contiver a variável
     <x>.


 -- Função: funp (<f>, <expr>)
 -- Função: funp (<f>, <expr>, <x>)
     `funp (<f>, <expr>)' retorna `true' se <expr> contém a função <f>.

     `funp (<f>, <expr>, <x>)' retorna `true' se <expr> contém a
     função <f> e a variável <x> em algum lugar no argumento de uma das
     instâncias de <f>.


 -- Função: absint (<f>, <x>, <halfplane>)
 -- Função: absint (<f>, <x>)
 -- Função: absint (<f>, <x>, <a>, <b>)
     `absint (<f>, <x>, <halfplane>)' retorna a integral indefinida de
     <f> com relação a <x> no dado semi-plano (`pos', `neg', ou `both').
     <f> pode conter expressões da forma `abs (x)', `abs (sin (x))',
     `abs (a) * exp (-abs (b) * abs (x))'.

     `absint (<f>, <x>)' é equivalente a `absint (<f>, <x>, pos)'.

     `absint (<f>, <x>, <a>, <b>)' retorna a integral definida de <f>
     com relação a <x> de <a> até <b>.  <f> pode incluir valores
     absolutos.


 -- Função: fourier (<f>, <x>, <p>)
     Retorna uma lista de coeficientes de Fourier de `<f>(<x>)'
     definidos sobre o intervalo `[-%pi, %pi]'.


 -- Função: foursimp (<l>)
     Simplifica `sin (n %pi)' para 0 se `sinnpiflag' for `true' e `cos
     (n %pi)' para `(-1)^n' se `cosnpiflag' for `true'.


 -- Variável de opção: sinnpiflag
     Valor padrão: `true'

     Veja `foursimp'.


 -- Variável de opção: cosnpiflag
     Valor padrão: `true'

     Veja `foursimp'.


 -- Função: fourexpand (<l>, <x>, <p>, <limit>)
     Constrói e retorna a série de Fourier partindo da lista de
     coeficientes de Fourier <l> até (up through) <limit> termos
     (<limit> pode ser `inf'). <x> e <p> possuem o mesmo significado
     que em `fourier'.


 -- Função: fourcos (<f>, <x>, <p>)
     Retorna os coeficientes do cosseno de Fourier para `<f>(<x>)'
     definida sobre `[0, %pi]'.


 -- Função: foursin (<f>, <x>, <p>)
     Retorna os coeficientes do seno de Fourier para `<f>(<x>)'
     definida sobre `[0, %pi]'.


 -- Função: totalfourier (<f>, <x>, <p>)
     Retorna `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>,
     'inf)'.


 -- Função: fourint (<f>, <x>)
     Constrói e retorna uma lista de coeficientes de integral de
     Fourier de `<f>(<x>)' definida sobre `[minf, inf]'.


 -- Função: fourintcos (<f>, <x>)
     Retorna os coeficientes da integral do cosseno de Fourier para
     `<f>(<x>)' on `[0, inf]'.


 -- Função: fourintsin (<f>, <x>)
     Retorna os coeficientes da integral do seno de Fourier para
     `<f>(<x>)' on `[0, inf]'.



File: maxima.info,  Node: Estatística,  Next: Arrays e Tabelas,  Prev: Numérico,  Up: Top

25 Estatística
**************

* Menu:

* Definições para Estatística::


File: maxima.info,  Node: Definições para Estatística,  Prev: Estatística,  Up: Estatística

25.1 Definições para Estatística
================================

 -- Função: gauss (<mean>, <sd>)
     Retorna um número em ponto flutuante randômico de uma
     distribuição normal com usando <mean> e desvio padrão <sd>.



File: maxima.info,  Node: Arrays e Tabelas,  Next: Matrizes e Álgebra Linear,  Prev: Estatística,  Up: Top

26 Arrays e Tabelas
*******************

* Menu:

* Definições para Arrays e Tabelas::


File: maxima.info,  Node: Definições para Arrays e Tabelas,  Prev: Arrays e Tabelas,  Up: Arrays e Tabelas

26.1 Definições para Arrays e Tabelas
=====================================

 -- Função: array (<name>, <dim_1>, ..., <dim_n>)
 -- Função: array (<name>, <type>, <dim_1>, ..., <dim_n>)
 -- Função: array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)
     Cria um array n-dimensional.  n pode ser menor ou igual a 5.  Os
     subscritos para a i'ésima dimensão são inteiros no intervalo de 0
     a <dim_i>.

     `array (<name>, <dim_1>, ..., <dim_n>)' cria um array genérico.

     `array (<name>, <type>, <dim_1>, ..., <dim_n>)' cria um array, com
     elementos de um tipo especificado.  <type> pode ser `fixnum' para
     inteiros de tamanho limitado ou `flonum' para números em ponto
     flutuante.

     `array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)' cria m
     arrays, todos da mesma dimensão.

     Se o usuário atribui a uma variável subscrita antes de declarar o
     array correspondente, um array não declarado é criado.  Arrays não
     declarados, também conhecidos como array desordenado (porque o
     codigo desordenado termina nos subscritos), são mais gerais que
     arrays declarados.  O usuário não declara seu tamanho máximo, e
     ele cresce dinamicamente e desordenadamente à medida que são
     atribuídos valores a mais elementos.  Os subscritos de um array
     não declarado não precisam sempre ser números.  Todavia, exceto
     para um array um tanto quanto esparso, é provavelmente mais
     eficiente declarar isso quando possível que deixar não declarado.
     A função `array' pode ser usada para transformar um array não
     declarado em um array declarado.


 -- Função: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Avalia `<A> [<i_1>, ..., <i_n>]', quando <A> for um array e <i_1>,
     ..., <i_n> são inteiros.

     Ela é remanescente de `apply', exceto o primeiro argumento que é
     um array ao invés de uma função.


 -- Função: arrayinfo (<A>)
     Retorna uma lista de informações sobre o array <A>.  Para arrays
     desordenados ela retorna uma lista de `hashed', o números de
     subscritos, e os subscritos de cada elemento que tem um valor.
     Para arrays declarados ela retorna uma lista de `declared', o
     número de subscritos, e os limites que foram dados à função
     `array' quando ela foi chamada sobre <A>.  Fazer
     `example(arrayinfo);' por exemplo.


 -- Função: arraymake (<name>, [<i_1>, ..., <i_n>])
     Retorna a expressão `<name> [<i_1>, ..., <i_n>]'.

     Isso é um código remanescente de `funmake', exceto o valor
     retornado é um array de referência não avaliado ao invés de uma
     chamada de função não avaliada.


 -- Variável de sistema: arrays
     Valor padrão: `[]'

     `arrays' é uma lista de todas os arrays que foram alocadas, tanto
     declarados como não declarados.

     Veja também `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray', and `rearray'.


 -- Função: bashindices (<expr>)
     Transforma a expressão <expr> dando a cada somatório e a cada
     produto um único índice.  Isso dá a `changevar' grande precisão
     quando se está trabalhando com somatórios e produtos.  A forma do
     único índice é `j<number>'.  A quantidade <number> é determindad
     por referência a `gensumnum', que pode ser alterada pelo usuário.
     Por exemplo, `gensumnum:0$' reseta isso.


 -- Função: fillarray (<A>, <B>)
     Preenche o array <A> com <B>, que é uma lista ou um array.

     Se <A> for um array de ponto flutuante (inteiro) então <B> poderá
     ser ou uma lista de números (inteiros) em ponto flutuante ou outro
     array em ponto flutuante (inteiro).

     Se as dimensões do array forem diferentes <A> é preenchida na
     ordem da maior linha.  Se não existem elementos livres em <B> o
     último elemento é usado para preencher todo o resto de <A>.  Se
     existirem muitos os restantes serão descartados.

     `fillarray' retorna esse primeiro argumento.


 -- Função: listarray (<A>)
     Retorna uma lista dos elementos  de um array declarado ou
     desordenado <A>.  A ordem é da maior-linha.  Elementos que não
     estão ainda definidos são representados por `#####'.


 -- Função: make_array (<type>, <dim_1>, ..., <dim_n>)
     Cria e retorna um array de Lisp.  <type> pode ser `any', `flonum',
     `fixnum', `hashed' ou `functional'.  Existem n indices, e o
     i'enésimo indice está no intervalo de 0 a <dim_i> - 1.

     A vantagem de `make_array' sobre `array' é que o valor de retorno
     não tem um nome, e uma vez que um ponteiro a ele vai, ele irá
     também.  Por exemplo, se `y: make_array (...)' então `y' aponta
     para um objeto que ocupa espaço, mas depois de `y: false', `y' não
     mais aponta para aquele objeto, então o objeto pode ser descartado.

     `y: make_array ('functional, 'f, 'hashed, 1)' - o segundo
     argumento para `make_array' nesse caso é a função que chama o
     cálculo dos elementos do array, e os argumentos restantes são
     passados recursivamente a `make_array' para gerar a "memoria" para
     a função array objeto.


 -- Função: rearray (<A>, <dim_1>, ..., <dim_n>)
     Altera as dimenções de um array.  O novo array será preenchido com
     os elementos do antigo em ordem da maior linha.  Se o array antigo
     era muito pequeno, os elementos restantes serão preenchidos com
     `false', `0.0' ou `0', dependendo do tipo do array.  O tipo do
     array não pode ser alterado.


 -- Função: remarray (<A_1>, ..., <A_n>)
 -- Função: remarray (all)
     Remove arrays e funções associadas a arrays e libera o espaço
     ocupado.

     `remarray (all)' remove todos os ítens na lista global `arrays'.

     Isso pode ser necessário para usar essa função se isso é desejado
     para redefinir os valores em um array desordenado.

     `remarray' retorna a lista dos arrays removidos.


 -- Função: subvar (<x>, <i>)
     Avalia a expressão subscrita `<x>[<i>]'.

     `subvar' avalia seus argumentos.

     `arraymake (<x>, [<i>]' constrói a expressão `<x>[<i>]', mas não a
     avalia.

     Exemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3) foo
           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5) +(%i6) arraymake (x, [i]);
          (%o6) foo
           3
          (%i7) ''%;
          (%o7) +


 -- Variável de pção: use_fast_arrays
     - Se `true' somente dois tipos de arrays são reconhecidos.

     1) O array art-q (t no Lisp Comum) que pode ter muitas dimensões
     indexadas por inteiros, e pode aceitar qualquer objeto do Lisp ou
     do Maxima como uma entrada.  Para construir assim um array, insira
     `a:make_array(any,3,4);' então `a' terá como valor, um array com
     doze posições, e o índice é baseado em zero.

     2) O array Hash_table que é o tipo padrão de array criado se um
     faz `b[x+1]:y^2' (e `b' não é ainda um array, uma lista, ou uma
     matriz - se isso ou um desses ocorrer um erro pode ser causado
     desde `x+1' não poderá ser um subscrito válido para um array
     art-q, uma lista ou uma matriz).  Esses índices (também conhecidos
     como chaves) podem ser quaisquer objetos.  Isso somente pega uma
     chave por vez a cada vez (`b[x+1,u]:y' ignorará o `u').  A
     referência termina em `b[x+1] ==> y^2'.  Certamente a chave poe
     ser uma lista , e.g.  `b[[x+1,u]]:y' poderá ser válido.  Isso é
     incompatível com os arrays antigos do Maxima, mas poupa recursos.

     Uma vantagem de armazenar os arrays como valores de símbolos é que
     as convenções usuais sobre variáveis locais de uma função
     aplicam-se a arrays também.  O tipo Hash_table também usa menos
     recursos e é mais eficiente que o velho tipo hashar do Maxima.
     Para obter comportamento consistente em códigos traduzidos e
     compilados posicione `translate_fast_arrays' para ser `true'.



File: maxima.info,  Node: Matrizes e Álgebra Linear,  Next: Funções Afins,  Prev: Arrays e Tabelas,  Up: Top

27 Matrizes e Álgebra Linear
****************************

* Menu:

* Introdução a Matrizes e Álgebra Linear::
* Definições para Matrizes e Álgebra Linear::


File: maxima.info,  Node: Introdução a Matrizes e Álgebra Linear,  Next: Definições para Matrizes e Álgebra Linear,  Prev: Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

27.1 Introdução a Matrizes e Álgebra Linear
===========================================

* Menu:

* Ponto::
* Vetores::
* auto::


File: maxima.info,  Node: Ponto,  Next: Vetores,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Introdução a Matrizes e Álgebra Linear

27.1.1 Ponto
------------

O operador `.' representa multiplicação não comutativa e produto
escalar.  Quando os operandos são matrizes 1-coluna ou 1-linha `a' e
`b', a expresão `a.b' é equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Se `a' e `b' não são complexos, isso é o produto escalar,
também chamado produto interno ou produto do ponto, de `a' e `b'.  O
produto escalar é definido como `conjugate(a).b' quando `a' e `b' são
complexos; `innerproduct' no pacote `eigen' fornece o produto escalar
complexo.

   Quando os operandos são matrizes mais gerais, o produto é a matriz
produto `a' e `b'.  O número de linhas de `b' deve ser igual ao número
de colunas de `a', e o resultado tem número de linhas igual ao número
de linhas de `a' e número de colunas igual ao número de colunas de `b'.

   Para distingüir `.' como um operador aritmético do ponto decimal em
um número em ponto flutuante, pode ser necessário deixar espaços em
cada lado.  Por exemplo, `5.e3' é `5000.0' mas `5 . e3' é `5' vezes
`e3'.

   Existem muitos sinalizadores que governam a simplificação de
expresões envolvendo `.', a saber `dot', `dot0nscsimp', `dot0simp',
`dot1simp', `dotassoc', `dotconstrules', `dotdistrib', `dotexptsimp',
`dotident', e `dotscrules'.


File: maxima.info,  Node: Vetores,  Next: auto,  Prev: Ponto,  Up: Introdução a Matrizes e Álgebra Linear

27.1.2 Vetores
--------------

`vect' é um pacote de funções para análise vetorial.  `load ("vect")'
chama esse pacote, e `demo ("vect")' permite visualizar uma
demonstração.

   O pacote de análise vetorial pode combinar e simplificar expresões
simbólicas incluindo produtos dos pontos e productos dos x, juntamente
com o gradiente, divergencia, torção, e operadores Laplacianos.  A
distribuição desses operadores sobre adições ou produtos é governada
por muitos sinalizadores, como são várias outras expansões, incluindo
expansão dentro de componentes em qualquer sistema de coordenadas
ortogonais.  Existem também funções para derivar o escalar ou vetor
potencial de um campo.

   O pacote `vect' contém essas funções: `vectorsimp', `scalefactors',
`express', `potential', e `vectorpotential'.

   Atenção: o pacote `vect' declara o operador ponto `.' como sendo um
operador comutativo.


File: maxima.info,  Node: auto,  Prev: Vetores,  Up: Introdução a Matrizes e Álgebra Linear

27.1.3 auto
-----------

O pacote `eigen' contém muitas funções devotadas para a computação
simbólica de autovalores e autovetores.  Maxima chama o pacote
automaticamente se uma das funções `eigenvalues' ou `eigenvectors' é
invocada.  O pacote pode ser chamado explicitamente com `load
("eigen")'.

   `demo ("eigen")' mostra uma demonstração das compatibilidades desse
pacote.  `batch ("eigen")' executa a mesma demonstração, mas sem
lembretes de usuário entre sucessivas computações.

   As funções no pacote `eigen' são `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors', e `similaritytransform'.



Local Variables:
coding: iso-8859-1
End:
