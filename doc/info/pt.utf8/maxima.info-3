This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Esse é um Manual do Maxima no formato Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).     Um sistema de álgebra computacional.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definições para Matrizes e Álgebra Linear,  Prev: Introdução a Matrizes e Álgebra Linear,  Up: Matrizes e Álgebra Linear

27.2 Definições para Matrizes e Álgebra Linear
==============================================

 -- Função: addcol (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) coluna(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: addrow (<M>, <list_1>, ..., <list_n>)
     Anexa a(s) linha(s) dadas por uma ou mais listas (ou matrizes)
     sobre a matriz <M>.


 -- Função: adjoint (<M>)
     Retorna a matriz adjunta da matriz <M>.  A matriz adjunta é a
     transposta da matriz dos cofatores de <M>.


 -- Função: augcoefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes aumentada para as variáveis
     <x_1>, ..., <x_n> do sistema de equações lineares <eqn_1>, ...,
     <eqn_m>.  Essa é a matriz dos coeficientes com uma coluna anexada
     para os termos independentes em cada equação (i.e., esses termos
     não dependem de <x_1>, ..., <x_n>).

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]


 -- Função: charpoly (<M>, <x>)
     Retorna um polinômio característico para a matriz <M> em relação à
     variável <x>.  Que é, `determinant (<M> - diagmatrix (length
     (<M>), <x>))'.

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)


 -- Função: coefmatrix ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Retorna a matriz dos coeficientes para as variáveis <x_1>, ...,
     <x_n> do sistema de equações lineares <eqn_1>, ..., <eqn_m>.

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]


 -- Função: col (<M>, <i>)
     Reorna a <i>'ésima coluna da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Função: columnvector (<L>)
 -- Função: covect (<L>)
     Retorna uma matriz de uma coluna e `length (<L>)' linhas, contendo
     os elementos da lista <L>.

     `covect' é um sinônimo para `columnvector'.

     `load ("eigen")' chama essa função.

     Isso é útil se você quer usar partes das saídas das funções nesse
     pacote em cálculos matriciais.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovetores
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]


 -- Função: conjugate (<x>)
     Retorna o conjugado complexo de <x>.

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)


 -- Função: copymatrix (<M>)
     Retorna uma cópia da matriz <M>.  Esse é o único para fazer uma
     copia separada copiando <M> elemento a elemento.

     Note que uma atribuição de uma matriz para outra, como em `m2: m1',
     não copia `m1'.  Uma atribuição `m2 [i,j]: x' ou `setelmx (x, i,
     j, m2' também modifica `m1 [i,j]'.  criando uma cópia com
     `copymatrix' e então usando atribução cria uma separada e
     modificada cópia.


 -- Função: determinant (<M>)
     Calcula o determinante de <M> por um método similar à eliminação
     de Gauss.

     A forma do resultado depende da escolha do comutador `ratmx'.

     Existe uma rotina especial para calcular determinantes esparsos
     que é chamada quando os comutadores `ratmx' e `sparse' são ambos
     `true'.


 -- Variável: detout
     Valor padrão: `false'

     Quando `detout' é `true', o determinante de uma matriz cuja
     inversa é calculada é fatorado fora da inversa.

     Para esse comutador ter efeito `doallmxops' e `doscmxops' deveram
     ambos serem `false' (veja suas transcrições).  Alternativamente
     esses comutadores podem ser dados para `ev' o que faz com que os
     outros dois sejam escolhidos corretamente.

     Exemplo:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c


 -- Função: diagmatrix (<n>, <x>)
     Retorna uma matriz diagonal de tamanho <n> por <n> com os
     elementos da diagonal todos iguais a <x>.  `diagmatrix (<n>, 1)'
     retorna uma matriz identidade (o mesmo que `ident (<n>)').

     <n> deve avaliar para um inteiro, de outra forma `diagmatrix'
     reclama com uma mensagem de erro.

     <x> pode ser qualquer tipo de expresão, incluindo outra matriz.
     Se <x> é uma matriz, isso não é copiado; todos os elementos da
     diagonal referem-se à mesma instância, <x>.


 -- Variável: doallmxops
     Valor padrão: `true'

     Quando `doallmxops' é `true', todas as operações relacionadas a
     matrizes são realizadas.  Quando isso é `false' então a escolha de
     comutadores individuais `dot' governam quais operações são
     executadas.


 -- Variável: domxexpt
     Valor padrão: `true'

     Quando `domxexpt' é `true', uma matriz exponencial, `exp (<M>)'
     onde <M> é a matriz, é interpretada como uma matriz com elementos
     `[i,j' iguais a `exp (m[i,j])'.  de outra forma `exp (<M>)' avalia
     para `exp (<ev(M)>'.

     `domxexpt' afeta todas as expresões da forma `<base>^<expoente>'
     onde <base> é uma expresão assumida escalar ou constante, e
     <expoente> é uma lista ou matriz.

     Exemplo:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]


 -- Variável de opção: domxmxops
     Valor padrão: `true'

     Quando `domxmxops' é `true', todas as operações matriz-matriz ou
     matriz-lista são realizadas (mas não operações escalar-matriz); se
     esse comutador é `false' tais operações não são.


 -- Variável de opção: domxnctimes
     Valor padrão: `false'

     Quando `domxnctimes' é `true', produtos não comutativos de
     matrizes são realizados.


 -- Variável de opção: dontfactor
     Valor padrão: `[]'

     `dontfactor' pode ser escolhido para uma lista de variáveis em
     relação a qual fatoração não é para ocorrer.  (A lista é
     inicialmente vazia.)  Fatoração também não pegará lugares com
     relação a quaisquer variáveis que são menos importantes, conforme
     a hierarquía de variável assumida para a forma expresão racional
     canônica (CRE), que essas na lista `dontfactor'.


 -- Variável de opção: doscmxops
     Valor padrão: `false'

     Quando `doscmxops' é `true', operações escalar-matriz são
     realizadas.


 -- Variável de opção: doscmxplus
     Valor padrão: `false'

     Quando `doscmxplus' é `true', operações escalar-matriz retornam
     uma matriz resultado.  Esse comutador não é subsomado sob
     `doallmxops'.


 -- Variável de opção: dot0nscsimp
     Valor padrão: `true'

     Quando `dot0nscsimp' é `true', um produto não comutativo de zero e
     um termo não escalar é simplificado para um produto comutativo.


 -- Variável de opção: dot0simp
     Valor padrão: `true'

     Quando `dot0simp' é `true', um produto não comutativo de zero e um
     termo escalar é simplificado para um produto não comutativo.


 -- Variável de opção: dot1simp
     Valor padrão: `true'

     Quando `dot1simp' é `true', um produto não comutativo de um e
     outro termo é simplificado para um produto comutativo.


 -- Variável de opção: dotassoc
     Valor padrão: `true'

     Quando `dotassoc' é `true', uma expresão `(A.B).C' simplifica para
     `A.(B.C)'.


 -- Variável de opção: dotconstrules
     Valor padrão: `true'

     Quando `dotconstrules' é `true', um produto não comutativo de uma
     constante e outro termo é simplificado para um produto comutativo.
     Ativando esse sinalizador efetivamente ativamos `dot0simp',
     `dot0nscsimp', e `dot1simp' também.


 -- Variável de opção: dotdistrib
     Valor padrão: `false'

     Quando `dotdistrib' é `true', uma expresão `A.(B + C)' simplifica
     para `A.B + A.C'.


 -- Variável de opção: dotexptsimp
     Valor padrão: `true'

     Quando `dotexptsimp' é `true', uma expresão `A.A' simplifica para
     `A^^2'.


 -- Variável de opção: dotident
     Valor padrão: 1

     `dotident' é o valor retornado por `X^^0'.


 -- Variável de opção: dotscrules
     Valor padrão: `false'

     Quando `dotscrules' é `true', uma expresão `A.SC' ou `SC.A'
     simplifica para `SC*A' e `A.(SC*B)' simplifica para `SC*(A.B)'.


 -- Função: echelon (<M>)
     Retorna a forma escalonada da matriz <M>, como produzido através
     da eliminação de Gauss.  A forma escalonada é calculada de <M> por
     operações elementares de linha tais que o primeiro elemento não
     zero em cada linha na matriz resultante seja o número um e os
     elementos da coluna abaixo do primeiro número um em cada linha
     sejam todos zero.

     `triangularize' também realiza eliminação de Gaussian, mas não
     normaliza o elemento líder não nulo em cada linha.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]


 -- Função: eigenvalues (<M>)
 -- Função: eivals (<M>)
     Retorna uma lista de duas listas contendo os autovalores da matriz
     <M>.  A primeira sublista do valor de retorno é a lista de
     autovalores da matriz, e a segunda sublista é a lista de
     multiplicidade dos autovalores na ordem correspondente.

     `eivals' é um sinônimo de `eigenvalues'.

     `eigenvalues' chama a função `solve' para achar as raízes do
     polinômio característico da matriz.  Algumas vezes `solve' pode
     não estar habilitado a achar as raízes do polinômio; nesse caso
     algumas outras funções nesse pacote (except `innerproduct',
     `unitvector', `columnvector' e `gramschmidt') não irão trabalhar.

     Em alguns casos os autovalores achados por `solve' podem ser
     expresões complicadas.  (Isso pode acontecer quando `solve'
     retorna uma expresão real não trivial para um autovalor que é
     sabidamente real.)  Isso pode ser possível para simplificar os
     autovalores usando algumas outras funções.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.


 -- Função: eigenvectors (<M>)
 -- Função: eivects (<M>)
     pegam uma matriz <M> como seu argumento e retorna uma lista de
     listas cuja primeira sublista é a saída de `eigenvalues' e as
     outras sublistas são os autovetores da matriz correspondente para
     esses autovalores respectivamente.  Os autovetores e os
     autovetores unitários da matriz são os autovetores direitos e os
     autovetores unitários direitos.

     `eivects' é um sinônimo para `eigenvectors'.

     O pacote `eigen.mac' é chamado automaticamente quando
     `eigenvalues' ou `eigenvectors' é referenciado.  Se `eigen.mac'
     não tiver sido ainda chamado, `load ("eigen")' chama-o.  Após ser
     chamado, todas as funções e variáveis no pacote estarão
     disponíveis.

     Os sinalizadores que afetam essa função são:

     `nondiagonalizable' é escolhido para `true' ou `false' dependendo
     de se a matriz é não diagonalizável ou diagonalizável após o
     retorno de `eigenvectors'.

     `hermitianmatrix' quando `true', faz com que os autovetores
     degenerados da matriz Hermitiana sejam ortogonalizados usando o
     algorítmo de Gram-Schmidt.

     `knowneigvals' quando `true' faz com que o pacote `eigen' assumir
     que os autovalores da matriz são conhecidos para o usuário e
     armazenados sob o nome global `listeigvals'.  `listeigvals' poderá
     ser escolhido para uma lista similar à saída de `eigenvalues'.

     A função `algsys' é usada aqui para resolver em relação aos
     autovetores.  Algumas vezes se os autovalores estão ausêntes,
     `algsys' pode não estar habilitado a achar uma solução.  Em alguns
     casos, isso pode ser possível para simplificar os autovalores por
     primeiro achando e então usando o comando `eigenvalues' e então
     usando outras funções para reduzir os autovalores a alguma coisa
     mais simples.  Continuando a simplificação, `eigenvectors' pode
     ser chamada novamente com o sinalizador `knowneigvals' escolhido
     para `true'.


 -- Função: ematrix (<m>, <n>, <x>, <i>, <j>)
     Retorna uma matriz <m> por <n>, todos os elementos da qual são
     zero exceto para o elemento `[<i>, <j>]' que é <x>.


 -- Função: entermatrix (<m>, <n>)
     Retorna uma matriz <m> por <n>, lendo os elementos interativamente.

     Se <n> é igual a <m>, Maxima pergunta pelo tipo de matriz
     (diagonal, simétrica, antisimétrica, ou genérica) e por cada
     elemento.  Cada resposta é terminada por um ponto e vírgula `;' ou
     sinal de dólar `$'.

     Se <n> não é igual a <m>, Maxima pergunta por cada elemento.

     Os elementos podem ser quaisquer expressões, que são avaliadas.
     `entermatrix' avalia seus argumentos.

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matriz entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]


 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- Função: genmatrix (<a>, <i_2>, <j_2>)
     Retorna uma matriz gerada de <a>, pegando o elemento
     `<a>[<i_1>,<j_1>]' como o elemento do canto superior esquerdo e
     `<a>[<i_2>,<j_2>]' como o elemento do canto inferior direto da
     matriz.  Aqui <a> é um array (criado por `array' mas não por
     `make_array') ou por uma função array.** (Uma funçãO array é
     criado como outras funções com `:=' ou `define', mas os argumentos
     são colocados entre colchêtes em lugar de parêntesis.)

     Se <j_1> é omitido, isso é assumido ser igual a <i_1>.  Se ambos
     <j_1> e <i_1> são omitidos, ambos são assumidos iguais a 1.

     Se um elemento selecionado `i,j' de um array é indefinido, a
     matriz conterá um elemento simbólico `<a>[i,j]'.

          (%i1) h[i,j] := 1/(i+j-1)$
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2)$
          (%i4) a[1,1]: %e$
          (%i5) a[2,2]: %pi$
          (%i6) kill (a[1,2], a[2,1])$
          (%i7) genmatrix (a, 2, 2);
                                  [  %e    a     ]
                                  [         1, 2 ]
          (%o7)                   [              ]
                                  [ a       %pi  ]
                                  [  2, 1        ]


 -- Função: gramschmidt (<x>)
 -- Função: gschmit (<x>)
     Realiza o algorítmo de ortonalização de Gram-Schmidt sobre <x>,
     seja ela uma matriz ou uma lista de listas.  <x> não é modificado
     por `gramschmidt'.

     Se <x> é uma matriz, o algorítmo é aplicado para as linhas de <x>.
     Se <x> é uma lista de listas, o algorítmo é aplicado às sublistas,
     que devem ter igual números de elementos.  Nos dois casos, o valor
     de retorno é uma lista de listas, as sublistas das listas são
     ortogonais e alcançam o mesmo spaço que <x>.  Se a dimensão do
     alcance de <x> é menor que o número de linhas ou sublistas,
     algumas sublistas do valor de retorno são zero.

     `factor' é chamada a cada estágio do algorítmo para simplificar
     resultados intermediários.  Como uma conseqüência, o valor de
     retorno pode conter inteiros fatorados.

     `gschmit' (nota ortográfica) é um sinônimo para `gramschmidt'.

     `load ("eigen")' chama essa função.

     Exemplo:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function autovalores
          Warning - you are redefining the Macsyma function autovetores
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) i: innerproduct$
          (%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
          (%o5)                       [0, 0, 0]


 -- Função: hach (<a>, <b>, <m>, <n>, <l>)
     `hach' é um implementação algorítmo de programação linear de
     Hacijan.

     `load ("kach")' chama essa função.  `demo ("kach")' executa uma
     demonstração dessa função.


 -- Função: ident (<n>)
     Retorna uma matriz identidade <n> por <n>.


 -- Função: innerproduct (<x>, <y>)
 -- Função: inprod (<x>, <y>)
     Retorna o produto interno (também chamado produto escalar ou
     produto do ponto) de <x> e <y>, que são listas de igual
     comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual
     comprimento.  O valor de retorno é `conjugate (x) . y', onde `.' é
     o operador de multiplicação não comutativa.

     `load ("eigen")' chama essa função.

     `inprod' é um sinônimo para `innerproduct'.


 -- Função: invert (<M>)
     Retorna a inversa da matriz <M>.  A inversa é calculada pelo
     método adjunto.

     Isso permite a um usuário calcular a inversa de uma matriz com
     entradas bfloat ou polinômios com coeficientes em ponto flutuante
     sem converter para a forma CRE.

     Cofatores são calculados pela função  `determinant', então se
     `ratmx' é `false' a inversa é calculada sem mudar a representação
     dos elementos.

     A implementação corrente é ineficiente para matrizes de alta ordem.

     Quando `detout' é `true', o determinante é fatorado fora da
     inversa.

     Os elementos da inversa não são automaticamente expandidos.  Se
     <M> tem elementos polinomiais, melhor aparência de saída pode ser
     gerada por `expand (invert (m)), detout'.  Se isso é desejável
     para ela divisão até pelo determinante pode ser excelente por
     `xthru (%)' ou alternativamente na unha por

          expe (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     Veja `^^' (expoente não comutativo) para outro método de inverter
     uma matriz.


 -- Variável de opção: lmxchar
     Valor padrão: `['

     `lmxchar' é o caractere mostrado como o delimitador esquerdo de
     uma matriz.  Veja também `rmxchar'.

     Exemplo:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]


 -- Função: matrix (<row_1>, ..., <row_n>)
     Retorna uma matriz retangular que tem as linhas <row_1>, ...,
     <row_n>.  Cada linha é uma lista de expressões.  Todas as linhas
     devem ter o mesmo comprimento.

     As operações `+' (adição), `-' (subtração), `*' (multiplicação), e
     `/' (divisão), são realizadas elemento por elemento quando os
     operandos são duas matrizes, um escalar e uma matriz, ou uma
     matriz e um escalar.  A operação `^' (exponenciação,
     equivalentemente `**') é realizada elemento por elemento se os
     operandos são um escalar e uma matriz ou uma matriz e um escalar,
     mas não se os operandos forem duas matrizes.  Todos as operações
     são normalmente realizadas de forma completa, incluindo `.'
     (multiplicação não comutativa).

     Multiplicação de matrizes é representada pelo operador de
     multiplicação não comutativa `.'.  O correspondente operador de
     exponenciação não comutativa é `^^'.  Para uma matriz `<A>',
     `<A>.<A> = <A>^^2' e `<A>^^-1' é a inversa de <A>, se existir.

     Existem comutadores para controlar a simplificação de expresões
     envolvendo operações escalar e matriz-lista.  São eles
     `doallmxops', `domxexpt' `domxmxops', `doscmxops', e `doscmxplus'.

     Existem opções adicionais que são relacionadas a matrizes.  São
     elas: `lmxchar', `rmxchar', `ratmx', `listarith', `detout',
     `scalarmatrix', e `sparse'.

     Existe um número de funções que pegam matrizes como argumentos ou
     devolvem matrizes como valor de retorno.  Veja `eigenvalues',
     `eigenvectors', `determinant', `charpoly', `genmatrix', `addcol',
     `addrow', `copymatrix', `transpose', `echelon', e `rank'.

     Exemplos:

        * Construção de matrizes de listas.

          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]

        * Adição, elemento por elemento.

          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]

        * Subtração, elemento por elemento.

          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]

        * Multiplicação, elemento por elemento.

          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]

        * Divisão, elemento por elemento.

          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]

        * Matriz para um expoente escalar, elemento por elemento.

          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]

        * Base escalar para um expoente matriz, elemento por elemento.

          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * Base matriz para um expoente matriz.  Essa não é realizada
          elemento por elemento.

          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]

        * Multiplicação não comutativa de matrizes.

          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]

        * Exponenciação não comutativa de matrizes.  Uma base escalar
          <b> para uma potência matriz <M> é realizada elemento por
          elemento e então `b^^m' é o mesmo que `b^m'.

          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]

        * A matriz elevada a um expoente -1 com exponenciação não
          comutativa é a matriz inversa, se existir.

          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]


 -- Função: matrixmap (<f>, <M>)
     Retorna uma matriz com elemento `i,j' igual a `<f>(<M>[i,j])'.

     Veja também `map', `fullmap', `fullmapl', e `apply'.


 -- Função: matrixp (<expr>)
     Retorna `true' se <expr> é uma matriz, de outra forma retorna
     `false'.


 -- Variável de opção: matrix_element_add
     Valor padrão: `+'

     `matrix_element_add' é a operação invocada em lugar da adição em
     uma multiplicação de matrizes.  A `matrix_element_add' pode ser
     atribuído qualquer operador n-ário (que é, uma função que manuseia
     qualquer número de argumentos).  Os valores atribuídos podem ser o
     nome de um operador entre aspas duplas, o nome da função, ou uma
     expressão lambda.

     Veja também `matrix_element_mult' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]


 -- Variável de opção: matrix_element_mult
     Valor padrão: `*'

     `matrix_element_mult' é a operação invocada em lugar da
     multiplicação em uma multiplicação de matrizes.  A
     `matrix_element_mult' pode ser atribuído qualquer operador binário.
     O valor atribuído pode ser o nome de um operador entre aspas
     duplas, o nome de uma função, ou uma expressão lambda.

     O operador do ponto `.' é uma escolha útil em alguns contextos.

     Veja também `matrix_element_add' e `matrix_element_transpose'.

     Exemplo:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]


 -- Variável de opção: matrix_element_transpose
     Valor padrão: `false'

     `matrix_element_transpose' é a operação aplicada a cada elemento
     de uma matriz quando for uma transposta.  A `matrix_element_mult'
     pode ser atribuído qualquer operador unário.  O valor atribuído
     pode ser  nome de um operador entre aspas duplas, o nome de uma
     função, ou uma expressão lambda.

     Quando `matrix_element_transpose' for igual a `transpose', a
     função  `transpose' é aplicada a todo elemento.  Quando
     `matrix_element_transpose' for igual a `nonscalars', a função
     `transpose' é aplicada a todo elemento não escalar.  Se algum
     elemento é um átomo, a opção `nonscalars' aplica `transpose'
     somente se o átomo for declarado não escalar, enquanto a opção
     `transpose' sempre aplica `transpose'.

     O valor padrão, `false', significa nenhuma operação é aplicada.

     Veja também `matrix_element_add' e `matrix_element_mult'.

     Exemplos:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]


 -- Função: mattrace (<M>)
     Retorna o traço (que é, a soma dos elementos sobre a diagonal
     principal) da matriz quadrada <M>.

     `mattrace' é chamada por `ncharpoly', uma alternativa para
     `charpoly' do Maxima.

     `load ("nchrpl")' chama essa função.


 -- Função: minor (<M>, <i>, <j>)
     Retorna o <i>, <j> menor do elemento localizado na linha <i>
     coluna <j> da matriz <M>.  Que é <M> com linha <i> e coluna <j>
     ambas removidas.


 -- Função: ncexpt (<a>, <b>)
     Se uma expressão exponencial não comutativa é muito alta para ser
     mostrada como `<a>^^<b>' aparecerá como `ncexpt (<a>,<b>)'.

     `ncexpt' não é o nome de uma função ou operador; o nome somente
     aparece em saídas, e não é reconhecido em entradas.


 -- Função: ncharpoly (<M>, <x>)
     Retorna o polinômio característico da matriz <M> com relação a
     <x>.  Essa é uma alternativa para `charpoly' do Maxima.

     `ncharpoly' trabalha pelo cálculo dos traços das potências na dada
     matriz, que são sabidos serem iguais a somas de potências das
     raízes do polinômio característico.  Para essas quantidade a função
     simétrica das raízes pode ser calculada, que nada mais são que os
     coeficientes do polinômio característico.  `charpoly' trabalha
     formatando o determinante de `<x> * ident [n] - a'.  Dessa forma
     `ncharpoly' é vencedor, por exemplo, no caso de largas e densas
     matrizes preencidas com inteiros, desde que isso evite
     inteiramente a aritmética polinomial.

     `load ("nchrpl")' loads this file.


 -- Função: newdet (<M>, <n>)
     Calcula o determinante de uma matriz ou array <M> pelo algorítmo
     da árvore menor de Johnson-Gentleman.  O argumento <n> é a ordem;
     isso é optional se <M> for uma matriz.


 -- Declaração: nonscalar
     Faz átomos ser comportarem da mesma forma que uma lista ou matriz
     em relação ao operador do ponto.


 -- Função: nonscalarp (<expr>)
     Retorna `true' se <expr> é um não escalar, i.e., isso contém
     átomos declarados como não escalares, listas, ou matrizes.


 -- Função: permanent (<M>, <n>)
     Calcula o permanente da matriz <M>.  Um permanente é como um
     determinante mas sem mudança de sinal.


 -- Função: rank (<M>)
     Calcula o posto da matriz <M>.  Que é, a ordem do mais largo
     determinante não singular de <M>.

     <rank> pode retornar uma resposta ruim se não puder determinar que
     um elemento da matriz que é equivalente a zero é realmente isso.


 -- Variável de opção: ratmx
     Valor padrão: `false'

     Quando `ratmx' é `false', adição, subtração, e multiplicação para
     determinantes e matrizes são executados na representação dos
     elementos da matriz e fazem com que o resultado da inversão de
     matrizes seja esquerdo na representação geral.

     Quando `ratmx' é `true', as 4 operações mencionadas acima são
     executadas na forma CRE e o resultado da matriz inversa é dado na
     forma CRE.  Note isso pode fazer com que os elementos sejam
     expandidos (dependendo da escolha de `ratfac') o que pode não ser
     desejado sempre.


 -- Função: row (<M>, <i>)
     retorna a <i>'ésima linha da matriz <M>.  O valor de retorno é uma
     matriz.


 -- Variável de opção: scalarmatrixp
     Valor padrão: `true'

     Quando `scalarmatrixp' é `true', então sempre que uma matriz 1 x 1
     é produzida como um resultado de cálculos o produto do ponto de
     matrizes é simplificado para um escalar, a saber o elemento
     solitário da matriz.

     Quando `scalarmatrixp' é `all', então todas as matrizes 1 x 1
     serão simplificadas para escalares.

     Quando `scalarmatrixp' é `false', matrizes 1 x 1 não são
     simplificadas para escalares.


 -- Função: scalefactors (<coordinatetransform>)
     Aqui coordinatetransform avalia para a forma [[expresão1,
     expresão2, ...], indeterminação1, indeterminação2, ...], onde
     indeterminação1, indeterminação2, etc.  são as variáveis de
     coordenadas curvilíneas e onde a escolha de componentes
     cartesianas retangulares é dada em termos das coordenadas
     curvilíneas por [expresão1, expresão2, ...].  `coordinates' é
     escolhida para o vetor [indeterminação1, indeterminação2,...], e
     `dimension' é escolhida para o comprimento desse vetor.  SF[1],
     SF[2], ..., SF[DIMENSION] são escohidos para fatores de escala de
     coordenada, e `sfprod' é escohido para o produto desse fatores de
     escala.  Inicialmente, `coordinates' é [X, Y, Z], `dimension' é 3,
     e SF[1]=SF[2]=SF[3]=SFPROD=1, correspondendo a coordenadas
     Cartesianas retangulares 3-dimensional.  Para expandir uma
     expresão dentro de componentes físicos no sistema de coordenadas
     corrente , existe uma função com uso da forma


 -- Função: setelmx (<x>, <i>, <j>, <M>)
     Atribue <x> para o (<i>, <j>)'ésimo elemento da matriz <M>, e
     retorna a matriz alterada.

     `<M> [<i>, <j>]: <x>' tem o mesmo efeito, mas retorna <x> em lugar
     de <M>.


 -- Função: similaritytransform (<M>)
 -- Função: simtran (<M>)
     `similaritytransform' calcula uma transformação homotética da
     matriz `M'.  Isso retorna uma lista que é a saída do comando
     `uniteigenvectors'.  Em adição se o sinalizador `nondiagonalizable'
     é `false' duas matrizes globais `leftmatrix' e `rightmatrix' são
     calculadas.  Essas matrizes possuem a propriedade de `leftmatrix .
     <M> . rightmatrix' é uma matriz diagonal com os autovalores de <M>
     sobre a diagonal.  Se `nondiagonalizable' é `true' as matrizes
     esquerda e direita não são computadas.

     Se o sinalizador `hermitianmatrix' é `true' então `leftmatrix' é o
     conjugado complexo da transposta de `rightmatrix'.  De outra forma
     `leftmatrix' é a inversa de `rightmatrix'.

     `rightmatrix' é a matriz cujas colunas são os autovetores
     unitários de <M>.  Os outros sinalizadores (veja `eigenvalues' e
     `eigenvectors') possuem o mesmo efeito desde que
     `similaritytransform' chama as outras funções no pacote com o
     objetivo de estar habilitado para a forma `rightmatrix'.

     `load ("eigen")' chama essa função.

     `simtran' é um sinônimo para `similaritytransform'.


 -- Variável de opção: sparse
     Valor padrão: `false'

     Quando `sparse' é `true', e se `ratmx' é `true', então
     `determinant' usará rotinas especiais para calcular determinantes
     esparsos.


 -- Função: submatrix (<i_1>, ..., <i_m>, <M>, <j_1>, ..., <j_n>)
 -- Função: submatrix (<i_1>, ..., <i_m>, <M>)
 -- Função: submatrix (<M>, <j_1>, ..., <j_n>)
     Retorna uma nova matriz formada pela matrix <M> com linhas <i_1>,
     ..., <i_m> excluídas, e colunas <j_1>, ..., <j_n> excluídas.


 -- Função: transpose (<M>)
     Retorna a transposta de <M>.

     Se <M> é uma matriz, o valor de retorno é outra matriz <N> tal que
     `N[i,j] = M[j,i]'.

     De outra forma <M> é uma lista, e o valor de retorno é uma matriz
     <N> de `length (m)' linhas e 1 coluna, tal que `N[i,1] = M[i]'.


 -- Função: triangularize (<M>)
     Retorna a maior forma triangular da matriz `M', como produzido
     através da eliminação de Gauss.  O valor de retorno é o mesmo que
     `echelon', exceto que o o coeficiente lider não nulo em cada linha
     não é normalizado para 1.

     `lu_factor' e `cholesky' são outras funções que retornam matrizes
     triangularizadas.

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]


 -- Função: uniteigenvectors (<M>)
 -- Função: ueivects (<M>)
     Calcula autovetores unitários da matriz <M>.  O valor de retorno é
     uma lista de listas, a primeiro sublista é a saída do comando
     `eigenvalues', e as outras sublistas são os autovetores unitários
     da matriz correspondente a esses autovalores respectivamente.

     Os sinalizadores mencionados na descrição do comando
     `eigenvectors' possuem o mesmo efeito aqui também.

     Quando `knowneigvects' é `true', o pacote `eigen' assume que os
     autovetores da matriz são conhecidos para o usuário são
     armazenados sob o nome global `listeigvects'.  `listeigvects' pode
     ser ecolhido para uma lista similar à saída do comando
     `eigenvectors'.

     Se `knowneigvects' é escolhido para `true' e a lista de
     autovetores é dada a escolha do sinalizador `nondiagonalizable'
     pode não estar correta.  Se esse é o caso por favor ecolha isso
     para o valor correto.  O autor assume que o usuário sabe o que
     está fazendo e que não tentará diagonalizar uma matriz cujos
     autovetores não alcançam o mesmo espaço vetorial de dimensão
     apropriada.

     `load ("eigen")' chama essa função.

     `ueivects' é um sinônimo para `uniteigenvectors'.


 -- Função: unitvector (<x>)
 -- Função: uvect (<x>)
     Retorna <x>/norm(<x>); isso é um vetor unitário na mesma direção
     que <x>.

     `load ("eigen")' chama essa função.

     `uvect' é um sinônimo para `unitvector'.


 -- Função: vectorsimp (<expr>)
     Aplica simplificações e expansões conforme os seguintes
     sinalizadores globais:

     `expandall', `expanddot', `expanddotplus', `expandcross',
     `expandcrossplus', `expandcrosscross', `expandgrad',
     `expandgradplus', `expandgradprod', `expanddiv', `expanddivplus',
     `expanddivprod', `expandcurl', `expandcurlplus', `expandcurlcurl',
     `expandlaplacian', `expandlaplacianplus', e `expandlaplacianprod'.

     Todos esses sinalizadores possuem valor padrão `false'.  O sufixo
     `plus' refere-se a utilização aditivamente ou distribuitivamente.
     O sufixo `prod' refere-se a expansão para um operando que é
     qualquer tipo de produto.

    `expandcrosscross'
          Simplifica p ~ (q ~ r) para (p . r)*q - (p . q)*r.

    `expandcurlcurl'
          Simplifica curl curl p para grad div p + div grad p.

    `expandlaplaciantodivgrad'
          Simplifica laplacian p para div grad p.

    `expandcross'
          Habilita `expandcrossplus' e `expandcrosscross'.

    `expandplus'
          Habilita `expanddotplus', `expandcrossplus', `expandgradplus',
          `expanddivplus', `expandcurlplus', e `expandlaplacianplus'.

    `expandprod'
          Habilita `expandgradprod', `expanddivprod', e
          `expandlaplacianprod'.

     Esses sinalizadores foram todos declarados `evflag'.


 -- Variável de opção: vect_cross
     Valor padrão: `false'

     Quando `vect_cross' é `true', isso permite DIFF(X~Y,T) trabalhar
     onde ~ é definido em SHARE;VECT (onde VECT_CROSS é escolhido para
     `true', de qualqeur modo.)


 -- Função: zeromatrix (<m>, <n>)
     Retorna um matriz <m> por <n>, com todos os elementos sendo zero.


 -- Símbolo especial: "["
 -- Símbolo especial: "]"
     `[' e `]' marcam o omeço e o fim, respectivamente, de uma lista.

     `[' e `]' também envolvem os subscritos de uma lista, array, array
     desordenado, ou função array.

     Exemplos:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101



File: maxima.info,  Node: Funções Afins,  Next: itensor,  Prev: Matrizes e Álgebra Linear,  Up: Top

28 Funções Afins
****************

* Menu:

* Definições para Funções Afins::


File: maxima.info,  Node: Definições para Funções Afins,  Prev: Funções Afins,  Up: Funções Afins

28.1 Definições para Funções Afins
==================================

 -- Função: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ...,
          <x_n>])
     Resolve equações lineares simultâneas <expr_1>, ..., <expr_m> para
     as variáveis <x_1>, ..., <x_n>.  Cada <expr_i> pode ser uma
     equação ou uma expressão geral; se dada como uma expressão geral,
     ela  tratada como uma equação na forma `<expr_i> = 0'.

     O valor de retorno é uma lista de equações da forma `[<x_1> =
     <a_1>, ..., <x_n> = <a_n>]' onde <a_1>, ..., <a_n> são todas
     livres de <x_1>, ..., <x_n>.

     `fast_linsolve' é mais rápido que `linsolve' para sistemas de
     equações que são esparsas.


 -- Função: grobner_basis ([<expr_1>, ..., <expr_m>])
     Retorna uma base de Groebner para as equações <expr_1>, ...,
     <expr_m>.  A funçã `polysimp' pode então ser usada para
     simplificar outras funções relativas às equações.

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     `polysimp(f)' produz 0 se e somente se <f> está no ideal gerado por
     <expr_1>, ..., <expr_m>, isto é, se e somente se <f> for uma
     combinação polinomial dos elementos de <expr_1>, ..., <expr_m>.


 -- Função: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- Função: set_up_dot_simplifications (<eqns>)
     As <eqns> são equações polinomiais em variáveis não comutativas.
     O valor de `current_variables'  é uma lista de variáveis usadas
     para calcular graus.  As equações podem ser homogêneas, em ordem
     para o procedimento terminar.

     Se você checou simplificações de envoltório em
     `dot_simplifications' acima do grau de <f>, então o seguinte é
     verdadeiro: `dotsimp (<f>)' retorna 0 se e somente se <f> está no
     ideal gerado pelas equações, i.e., se e somente se <f> for uma
     combinação polinomial dos elementos das equações.

     acima do grau de f, então o seguinte é verdadeiro: `dotsimp (f)'
     retorna 0 se e somente se <f> está no ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.

     O grau é aquele retornado por `nc_degree'.   Isso por sua vez é
     nfluenciado pelos pesos das variáveis individuais.


 -- Função: declare_weight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     Atribui pesos <w_1>, ..., <w_n> to <x_1>, ..., <x_n>,
     respectivamente.  Esses são pesos usados em cálculos `nc_degree'.


 -- Função: nc_degree (<p>)
     Retorna o grau de um polinômio não comutativo <p>.  Veja
     `declare_weights'.


 -- Função: dotsimp (<f>)
     Retorna 0 se e somente se <f> for um ideal gerado pelas equações,
     i.e., se e somente se <f> for uma combinação polinomial dos
     elementos das equações.


 -- Função: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     Se `set_up_dot_simplifications' tiver sido feito previamente, ache
     o polinômio central nas variáveis <x_1>, ..., <x_n> no grau dado,
     <n>.

     Por exemplo:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];


 -- Função: check_overlaps (<n>, <add_to_simps>)
     Verifica as sobreposies através do grau <n>, tendo certeza que
     você tem regras de simplificaçõ suficiente em cada grau, para
     `dotsimp' trabalhar corretamente.  Esse processo pode ter sua
     velocidade aumentada se você souber antes de começar souber de
     qual dimensão do espaço de monômios é.  Se ele for de dimensão
     global finita, então `hilbert' pode ser usada.  Se você não
     conhece as dimensões monomiais, não especifique um `rank_function'.
     Um opcional terceiro argumento `reset', `false' diz para não se
     incomodar em perguntar sobre resetar coisas.


 -- Função: mono ([<x_1>, ..., <x_n>], <n>)
     Retorna a lista de monômios independentes relativamente à
     simplificação atual do grau <n> nas variáveis <x_1>, ..., <x_n>.


 -- Função: monomial_dimensions (<n>)
     Calcula a série de Hilbert através do grau <n> para a algebra
     corrente.


 -- Função: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>, ...,
          <m_n>])
     Faz uma lista dos coeficientes dos polinômios não comutativos
     <p_1>, ..., <p_n> dos monomios não comutatvos <m_1>, ..., <m_n>.
     Os coeficientes podem ser escalares.   Use `list_nc_monomials'
     para construir a lista dos monômios.


 -- Função: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- Função: list_nc_monomials (<p>)
     Retorna uma lista de monômios não comutativos que ocorrem em um
     polinômio <p> ou em uma lista de polinômios <p_1>, ..., <p_n>.


 -- Variável de opção: all_dotsimp_denoms
     Valor padrão: `false'

     Quando `all_dotsimp_denoms' é uma lista, os denominadores
     encontrados por `dotsimp' são adicionados ao final da lista.
     `all_dotsimp_denoms' pode ser iniciado como uma lista vazia `[]'
     antes chamando `dotsimp'.

     Por padrão, denominadores não são coletados por `dotsimp'.



File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Funções Afins,  Up: Top

29 itensor
**********

* Menu:

* Introdução a itensor::
* Definições para itensor::


File: maxima.info,  Node: Introdução a itensor,  Next: Definições para itensor,  Prev: itensor,  Up: itensor

29.1 Introdução a itensor
=========================

Maxima implementa a manipulação de tensores simbólicos d dois tipos
distintos: manipulação de componentes de tensores (pacote `ctensor') e
manipulação de tensores indiciais (pacote `itensor').

   Note bem: Por favor veja a nota sobre 'nova notação de tensor'
abaixo.

   Manipulação de componentes de tensores significa que objetos do tipo
tensor geométrico são representados como arrays ou matrizes. Operações
com tensores tais com contração ou diferenciação covariante são
realizadas sobre índices (que ocorrem exatamente duas vezes) repetidos
com declarações `do'.  Isto é, se executa explicitamente operações
sobre as componentes apropriadas do tensor armazenadas em um array ou
uma matriz.

   Manipulação tensorial de índice é implementada através da
representação de tensores como funções e suas covariantes,
contravariantes e índices de derivação. Operações com tensores como
contração ou diferenciação covariante são executadas através de
manipulação dos índices em si mesmos em lugar das componentes para as
quais eles correspondem.

   Esses dois métodos aproximam-se do tratamento de processos
diferenciais, algébricos e analíticos no contexto da geometria de
Riemannian possuem várias vantagens e desvantagens as quais se revelam
por si mesmas somente apesar da natureza particular e dificuldade dos
problemas de usuário.  Todavia, se pode ter em mente as seguintes
características das duas implementações:

   As representações de tensores e de operações com tensores
explicitamente em termos de seus componntes tornam o pacote `ctensor'
fácil de usar. Especificação da métrica e o cálculo de tensores
induzidos e invariantes é direto. Embora todas a capacidade de
simplificação poderosa do Maxima está em manusear, uma métrica complexa
com intrincada dependência funcional e de coordenadas pode facilmente
conduzir a expressões cujo tamanho é excessivo e cuja estrutura está
escondida. Adicionalmente, muitos cálculos envolvem expressões
intermediárias cujo crescimento fazem com que os programas terminem
antes de serem completados. Através da experiência, um usuário pode
evitar muitas dessas dificuldade.

   O motivo de caminhos especiais através dos quais tensores e
operações de tensores são representados em termos de operações
simbólicas sobre seus índices, expressões cujas representação de
componentes podem ser não gerenciaveis da forma comum podem algumas
vezes serem grandemente simplificadas através do uso das rotinas
especiais para objetos simétricos em `itensor'. Nesse caminho a
estrutura de uma expressão grande pode ser mais transparente. Por outro
lado, o motivo da representação indicial especial em `itensor', faz com
que em alguns casos o usuário possa encontrar dificuldade com a
especificação da métrica, definição de função, e a avaliação de objetos
"indexados" diferenciados.

29.1.1 Nova notação d tensores
------------------------------

Até agora, o pacote `itensor' no Maxima tinha usado uma notação que
algumas vezes conduzia a ordenação incorreta de índices. Considere o
seguinte, por exemplo:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   O resultado está incorreto a menos que ocorra ser `a' um tensor
simétrico.  A razão para isso é que embora `itensor' mantenha
corretamente a ordem dentro do conjunto de índices covariantes e
contravariantes, assim que um índice é incrementado ou decrementado,
sua posição relativa para o outro conjunto de índices é perdida.

   Para evitar esse problema, uma nova notação tem sido desenvolvida
que mantém total compatibilidade com a notação existente e pode ser
usada intercambiavelmente. Nessa notação, índices contravariantes são
inseridos na posição apropriada na lista de índices covariantes, mas
com um sinal de menos colocado antes.  Funções como `contract' e
`ishow' estão agora consciente dessa nova notação de índice e podem
processar tensores apropriadamente.

   Nessa nova notação, o exemplo anterior retorna um resultado correto:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   Presentemente, o único código que faz uso dessa notação é a função
`lc2kdt'. Através dessa notação, a função `lc2kdt' encontra com êxito
resultados consistentes como a aplicação do tensor métrico para
resolver os símbolos de Levi-Civita sem reordenar para índices
numéricos.

   Uma vez que esse código é um tipo novo, provavelmente contém erros.
Enquanto esse tipo novo não tiver sido testado para garantir que ele
não interrompe nada usando a "antiga" notação de tensor, existe uma
considerável chance que "novos" tensores irão falhar em interoperar com
certas funções ou recursos. Essas falhas serão corrigidas à medida que
forem encontradas... até então, seja cuidadoso!

29.1.2 Manipulação de tensores indiciais
----------------------------------------

o pacote de manipulação de tensores indiciais pode ser chamado através
de `load(itensor)'. Demonstações estão também disponíveis: tente
`demo(tensor)'.  Em `itensor' um tensor é representado como um "objeto
indexado" .  Um "objeto indexado" é uma função de 3 grupos de índices
os quais representam o covariante, o contravariante e o índice de
derivação.  Os índices covariantes são especificados através de uma
lista com o primeiro argumento para o objeto indexado, e os índices
contravariantes através de uma lista como segundo argumento. Se o
objeto indexado carece de algum desses grupos de índices então a lista
vazia `[]' é fornecida como o argumento correspondente.  Dessa forma,
`g([a,b],[c])' representa um objeto indexado chamado `g' o qual tem
dois índices covariantes `(a,b)', um índice contravariante (`c') e não
possui índices de derivação.

   Os índices de derivação, se estiverem presente, são anexados ao
final como argumentos adicionais para a função numérica representando o
tensor.  Eles podem ser explicitamente especificado pelo usuário ou
serem criados no processo de diferenciação com relação a alguma
variável coordenada.  Uma vez que diferenciação ordinária é comutativa,
os índices de derivação são ordenados alfanumericamente, a menos que
`iframe_flag' seja escolhida para `true', indicando que uma moldura
métrica está sendo usada. Essa ordenação canônica torna possível para
Maxima reconhecer que, por exemplo, `t([a],[b],i,j)' é o mesmo que
`t([a],[b],j,i)'.  Diferenciação de um objeto indexado com relação a
alguma coordenada cujos índices não aparecem como um argumento para o
objeto indexado podem normalmente retornar zero. Isso é porque Maxima
pode não saber que o tensor representado através do objeto indexado
possívelmente depende implicitamente da respectiva coordenada.  Pela
modificação da função existente no Maxima, `diff',  em `itensor',
Maxima sabe assumir que todos os objetos indexados dependem de qualquer
variável de diferenciação a menos que seja declarado de outra forma.
Isso torna possível para a convençào de somatório ser extendida para
índices derivativos. Pode ser verificado que `itensor' não possui a
compatibilidade de incrementar índices derivativos, e então eles são
sempre tratados como covariantes.

   As seguintes funções estão disponíveis no pacote tensor para
manipulação de objetos.  Atualmente, com relação às rotinas de
simplificação, é assumido que objetos indexados não possuem por padrão
propriedades simétricas. Isso pode ser modificado através da escolha da
variável `allsym[false]' para `true', o que irá resultar no tratamento
de todos os objetos indexados completamente simétricos em suas listas
de índices covariantes e simétricos em suas listas de índices
contravariantes.

   O pacote `itensor' geralmente trata tensores como objetos opacos.
Equações tensoriais são manipuladas baseadas em regras algébricas,
especificamente simetria e regras de contração. Adicionalmente, o
pacote `itensor' não entende diferenciação covariante, curvatura, e
torsão. Cálculos podem ser executados relativamente a um métrica de
molduras de movimento, dependendo da escolha para a variável
`iframe_flag'.

   Uma sessão demonstrativa abaixo mostra como chamar o pacote
`itensor', especificando o nome da métrica, e executando alguns
cálculos simples.

     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                    %4 %5
     (%t12) v    - g      v   (e p       + e   p     - e p       - e    p
             i,j           %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                                     + e p       + e   p    )/2
                                                          i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %8                    %6 %8
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %8 i             %6    i j %8      i,j

                                                         %6 %8
                                                    - ifg      v   ifb      )/2
                                                                %6    %8 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0


File: maxima.info,  Node: Definições para itensor,  Prev: Introdução a itensor,  Up: itensor

29.2 Definições para itensor
============================

29.2.1 Gerenciando objetos indexados
------------------------------------

 -- Função: entertensor (<nome>)
     É uma função que, através da linha de comando, permite criar um
     objeto indexado chamado <nome> com qualquer número de índices de
     tensores e derivativos. Ou um índice simples ou uma lista de
     índices (às quais podem ser nulas) são entradas aceitáveis (veja o
     exemplo sob `covdiff').


 -- Função: changename (<antigo>, <novo>, <expr>)
     Irá mudar o nome de todos os objetos indexados chamados <antigo>
     para <novo> em <expr>. <antigo> pode ser ou um símbolo ou uma
     lista da forma `[<nome>, <m>, <n>]' nesse caso somente esses
     objetos indexados chamados <nome> com índice covariante <m> e
     índice contravariante <n> serão renomeados para <novo>.


 -- Função: listoftens
     Lista todos os tensores em uma expressão tensorial, incluindo seus
     índices. E.g.,


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y


 -- Função: ishow (<expr>)
     Mostra <expr> com os objetos indexados tendo seus índices
     covariantes como subscritos e índices contravariantes como
     sobrescritos.  Os índices derivativos são mostrados como
     subscritos, separados dos índices covariantes por uma vírgula
     (veja os exemplos através desse documento).


 -- Função: indices (<expr>)
     Retorna uma lista de dois elementos.  O primeiro é uma lista de
     índices livres em <expr> (aqueles que ocorrem somente uma vez). O
     segundo é uma lista de indices que ocorrem exatamente duas vezes
     em <expr> (dummy) como demonstra o seguinte exemplo.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     Um produto de tensores contendo o mesmo índice mais que duas vezes
     é sintaticamente ilegal. `indices' tenta lidar com essas
     expressões de uma forma razoável; todavia, quando `indices' é
     chamada para operar sobre tal uma expressão ilegal, seu
     comportamento pode ser considerado indefinido.


 -- Função: rename (<expr>)
 -- Função: rename (<expr>, <contador>)
     Retorna uma expressão equivalente para <expr> mas com índices que
     ocorrem exatamente duas vezes em cada termo alterado do conjunto
     `[%1, %2,...]', se o segundo argumento opcional for omitido. De
     outra forma, os índices que ocorrem exatamente duas vezes são
     indexados começando no valor de <contador>.  Cada índice que
     ocorre exatamente duas vezes em um produto será diferente. Para
     uma adição, `rename' irá operar sobre cada termo na a adição
     zerando o contador com cada termo. Nesse caminho `rename' pode
     servir como um simplificador tensorial. Adicionalmente, os índices
     serão ordenados alfanumericamente (se `allsym' for `true') com
     relação a índices covariantes ou contravariantes dependendo do
     valor de `flipflag'.  Se `flipflag' for `false' então os índices
     serão renomeados conforme a ordem dos índices contravariantes. Se
     `flipflag' for `true' a renomeação ocorrerá conforme a ordem dos
     índices covariantes. Isso muitas vezes ajuda que o efeito
     combinado dos dois restantes sejam reduzidos a uma expressão de
     valor um ou mais que um por si mesma.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$

                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                        %4 %5  %6 %7      u          %1         %3         %2
                     - g      g      ichr2      ichr2      ichr2      ichr2
                                          %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                        %1 %2  %3 %4      %6         %5         %7        u
                     - g      g      ichr2      ichr2      ichr2     ichr2
                                          %1 %3      %2 %6      %4 r      %5 %7


 -- Variável de Opção: flipflag
     Valor padrão: `false'. Se `false' então os índices irão ser
     renomeados conforme a ordem dos índices contravariantes, de outra
     forma serão ordenados conforme a ordem dos índices covariantes.

     Se `flipflag' for `false' então `rename' forma uma lista de
     índices contravariantes na ordem em que forem encontrados da
     esquerda para a direita (se `true' então de índices
     contravariantes). O primeiro índice que ocorre exatamente duas
     vezes na lista é renomeado para `%1', o seguinte para `%2', etc.
     Então a ordenação ocorre após a ocorrência do `rename' (veja o
     exemplo sob `rename').


 -- Função: defcon (<tensor_1>)
 -- Função: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     Dado <tensor_1> a propriedade que a contração de um produto do
     <tensor_1> e do <tensor_2> resulta em <tensor_3> com os índices
     apropriados.  Se somente um argumento, <tensor_1>, for dado, então
     a contração do produto de <tensor_1> com qualquer objeto indexado
     tendo os índices apropriados (digamos `my_tensor') irá retornar
     como resultado um objeto indexado com aquele nome, i.e.
     `my_tensor', e com uma nova escolha de índices refletindo as
     contrações executadas.  Por exemplo, se `imetric:g', então
     `defcon(g)' irá implementar o incremento e decremento de índices
     através da contração com o tensor métrico.  Mais de uma `defcon'
     pode ser dada para o mesmo objeto indexado; o último  fornecido
     que for aplicado a uma contração particular irá ser usado.
     `contractions' é uma lista de objetos indexados que tenham
     fornecido propriedades de contrações com `defcon'.


 -- Função: remcon (<tensor_1>, ..., <tensor_n>)
 -- Função: remcon (all)
     Remove todas as propriedades de contração de <tensor_1>, ...,
     <tensor_n>). `remcon(all)' remove todas as propriedades de
     contração de todos os objetos indexados.


 -- Função: contract (<expr>)
     Realiza contrações tensoriais em <expr> a qual pode ser qualquer
     combinação de adições e produtos. Essa função usa a informação
     dada para a função `defcon'. Para melhores resultados, `expr' pode
     ser completamente expandida. `ratexpand' é o meio mais rápido para
     expandir produtos e expoentes de adições se não existirem
     variáveis nos denominadores dos termos. O comutador `gcd' pode ser
     `false' se cancelamentos de máximo divisor comum forem
     desnecessários.


 -- Função: indexed_tensor (<tensor>)
     Deve ser executada antes de atribuir componentes para um <tensor>
     para o qual um valor interno já existe como com `ichr1', `ichr2',
     `icurvature'. Veja o exemplo sob `icurvature'.


 -- Função: components (<tensor>, <expr>)
     Permite que se atribua um valor indicial a uma expressão <expr>
     dando os valores das componentes do <tensor>. Esses são
     automaticamente substituídos para o tensor mesmo que isso ocorra
     com todos os seus índices. O tensor deve ser da forma
     `t([...],[...])' onde qualquer lista pode ser vazia. <expr> pode
     ser qualquer expressão indexada envolvendo outros objetos com os
     mesmos índices livres que <tensor>. Quando usada para atribuir
     valores a um tensor métrico no qual as componentes possuem índices
     que ocorrem exatamente duas vezes se deve ser cuidadoso para
     definir esses índices de forma a evitar a geração de índices que
     ocorrem exatamente duas vezes e que são multiplos. a remoção dessas
     atribuições é dada para a função `remcomps'.

     É importante ter em mente que `components' cuida somente da
     valência de um tensor, e que ignora completamente qualquer
     ordenação particular de índices. Dessa forma atribuindo
     componentes a, digamos, `x([i,-j],[])', `x([-j,i],[])', ou
     `x([i],[j])' todas essas atribuições produzem o mesmo resultado, a
     saber componentes sendo atribuidas a um tensor chamado `x' com
     valência `(1,1)'.

     Componentes podem ser atribuidas a uma expressão indexada por
     quatro caminhos, dois dos quais envolvem o uso do comando
     `components':

     1) Como uma expressão indexada. Por exemplo:


          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) Como uma matriz:


          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([3,3],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) Como uma função. Você pode usar uma função Maxima para
     especificar as componentes de um tensor baseado nesses índices.
     Por exemplo, os seguintes códigos atribuem `kdelta' a `h' se `h'
     tiver o mesmo número de índices covariantes e índices
     contravariantes e nenhum índice derivativo, e atribui `kdelta' a
     `g' caso as condições anteriores não sejam atendidas:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Usando a compatibilidade dos modelos de coincidência do Maxima,
     especificamente os comandos `defrule' e `applyb1':


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n


 -- Função: remcomps (<tensor>)
     Desassocia todos os valores de <tensor> que foram atribuídos com a
     função `components'.


 -- Função: showcomps (<tensor>)
     Mostra atribuições de componentes de um tensor, feitas usando o
     comando `components'. Essa função pode ser particularmente útil
     quando uma matriz é atribuída a um tensor indicial usando
     `components', como demonstrado através do seguinte exemplo:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load(itensor);
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     O comando `showcomps' pode também mostrar componentes de um tensor
     de categoria maior que 2.


 -- Função: idummy ()
     Incrementos `icounter' e retorno como seu valor um índice da forma
     `%n' onde n é um inteiro positivo.  Isso garante que índices que
     ocorrem exatamente duas vezes e que são necessários na formação de
     expressões não irão conflitar com índices que já estiverem sendo
     usados (veja o exemplo sob `indices').


 -- Variável de opção: idummyx
     Valor padrão: `%'

     É o prefixo para índices que ocorrem exatamente duas vezes (veja o
     exemplo sob índices `indices').


 -- Variável de Opção: icounter
     Valor padrão: `1'

     Determina o sufixo numérico a ser usado na geração do próximo
     índice que ocorre exatamente duas vezes no pacote tensor.  O
     prefixo é determinado através da opção `idummy' (padrão: `%').

 -- Função: kdelta (<L1>, <L2>)
     é a função delta generalizada de Kronecker definida no pacote
     `itensor' com <L1> a lista de índices covariantes e <L2> a lista
     de índices contravariantes.  `kdelta([i],[j])' retorna o delta de
     Kronecker comum.  O comando `ev(<expr>,kdelta)' faz com que a
     avaliação de uma expressão contendo `kdelta([],[])' se dê para a
     dimensão de multiplicação.

     No que conduzir a um abuso dessa notação, `itensor' também permite
     `kdelta' ter 2 covariantes e nenhum contravariante, ou 2
     contravariantes e nenhum índice covariante, com efeito fornecendo
     uma compatibilidade para "matriz unitária" covariante ou
     contravariante. Isso é estritamente considerado um recurso de
     programação e não significa implicar que `kdelta([i,j],[])' seja
     um objeto tensorial válido.


 -- Função: kdels (<L1>, <L2>)
     Delta de Kronecker simetrizado, usado em alguns cálculos. Por
     exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b


 -- Função: levi_civita (<L>)
     é o tensor de permutação (ou de Levi-Civita) que retorna 1 se a
     lista <L> consistir de uma permutação par de inteiros, -1 se isso
     consistir de uma permutação ímpar, e 0 se alguns índices em <L>
     forem repetidos.


 -- Função: lc2kdt (<expr>)
     Simplifica expressões contendo os símbolos de Levi-Civita,
     convertendo esses para expressões delta de Kronecker quando
     possível. A principal diferença entre essa função e simplesmente
     avaliar os simbolos de Levi-Civita é que a avaliação direta muitas
     vezes resulta em expressões Kronecker contendo índices numéricos.
     Isso é muitas vezes indesejável como na prevenção de simplificação
     adicional.  A função `lc2kdt' evita esse problema, retornando
     expressões que são mais facilmente simplificadas com `rename' ou
     `contract'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])*'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     A função `lc2kdt' algumas vezes faz uso de tensores métricos.  Se
     o tensor métrico não tiver sido definido previamente com `imetric',
     isso resulta em um erro.


          (%i7) expr:ishow('levi_civita([],[i,j])*'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j       k
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g     kdelta  ) a
                              %3             %4               %3             %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i      l i
          (%t11)                           a    - a g


 -- Função: lc_l
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2)  el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) ishow(canform(contract(expand(applyb1(el1,lc_l,lc_u)))))$
          (%t4)                                  0
          (%i5) ishow(canform(contract(expand(applyb1(el2,lc_l,lc_u)))))$
          (%t5)                                  0


 -- Função: lc_u
     Regra de simplificação usada para expressões contendo símbolos não
     avaliados de Levi-Civita (`levi_civita'). Juntamente com `lc_u',
     pode ser usada para simplificar muitas expressões mais
     eficientemente que a avaliação de `levi_civita'.  Para detalhes,
     veja `lc_l'.


 -- Função: canten (<expr>)
     Simplifica <expr> por renomeação (veja `rename') e permutando
     índices que ocorrem exatamente duas vezes. `rename' é restrito a
     adições de produto de tensores nos quais nenhum índice derivativo
     estiver presente. Como tal isso é limitado e pode somente ser
     usado se `canform' não for capaz de realizar a simplificação
     requerida.

     A função `canten' retorna um resultado matematicamente correto
     somente se seu argumento for uma expressão que é completamente
     simétrica em seus índices.  Por essa razão, `canten' retorna um
     erro se `allsym' não for posicionada em `true'.


 -- Função: concan (<expr>)
     Similar a `canten' mas também executa contração de índices.


29.2.2 Simetrias de tensores
----------------------------

 -- Variável de Opção: allsym
     Valor padrão: `false'. Se `true' então todos os objetos indexados
     são assumidos simétricos em todos os seus índices covariantes e
     contravariantes. Se `false' então nenhum simétrico de qualquer
     tipo é assumidos nesses índices. Índices derivativos são sempre
     tomados para serem simétricos a menos que `iframe_flag' seja
     escolhida para `true'.


 -- Função: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])
     Declara propriedades de simetria para <tensor> de covariante <m> e
     <n> índices contravariantes. As <cov_i> e <contr_i> são
     pseudofunções expressando relações de simetrias em meio a índices
     covariante e índices contravariantes respectivamente.  Esses são
     da forma `symoper(<index_1>, <index_2>,...)' onde `symoper' é um
     entre `sym', `anti' ou `cyc' e os <index_i> são inteiros indicando
     a posição do índice no <tensor>.  Isso irá declarar <tensor> para
     ser simétrico, antisimétrico ou cíclico respectivamente nos
     <index_i>. `symoper(all)' é também forma permitida que indica
     todos os índices obedecem à condição de simetria. Por exemplo,
     dado um objeto `b' com 5 índices covariantes,
     `decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])' declara `b'
     simétrico no seu primeiro e no seu segundo índices e antisimétrico
     no seu terceiro e quarto índices covariantes, e cíclico em todos
     de seus índices contravariantes.  Qualquer lista de declarações de
     simetria pode ser nula.  A função que executa as simplificações é
     `canform' como o exemplo abaixo ilustra.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract(expand(a([i1,j1,k1],[])*kdels([i,j,k],[i1,j1,k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]


 -- Função: remsym (<tensor>, <m>, <n>)
     Remove todas as propriedades de simetria de <tensor> que tem <m>
     índices covariantes e <n> índices contravariantes.

 -- Função: canform (<expr>)
     Simplifica <expr> através de mudança de nome de índices que
     ocorrem exatamente duas vezes e reordenação de todos os índices
     como ditados pelas condições de simetria impostas sobre eles. Se
     `allsym' for `true' então todos os índices são assumidos
     simétricos, de outra forma a informação de simetria fornecida
     pelas declarações `decsym' irão ser usadas. Os índices que ocorrem
     exatamente duas vezes são renomeados da mesma maneira que na
     função `rename'. Quando `canform' é aplicada a uma expressão larga
     o cálculo pode tomar um considerável montante de tempo.  Esse
     tempo pode ser diminuído através do uso de `rename' sobre a
     expressão em primeiro lugar.  Também veja o exemplo sob `decsym'.
     Nota: `canform' pode não estar apta a reduzir um expressão
     completamente para sua forma mais simples embora retorne sempre um
     resultado matemáticamente correto.

29.2.3 Cálculo de tensores indiciais
------------------------------------

 -- Função: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     É a função usual de diferenciação do Maxima que tem sido expandida
     nessas habilidades para `itensor'. `diff' toma a derivada de <expr>
     <n_1> vezes com relação a <v_1>, <n_2> vezes com relação a <v_2>
     , etc. Para o pacote `tensor', a função tem sido modificada de
     forma que os <v_i> possam ser inteiros de 1 até o valor da variável
     `dim'.  Isso causará a conclusão da diferenciação com relação ao
     <v_i>ésimo membro da lista `vect_coords'.  Se `vect_coords' for
     associado a uma variável atômica, então aquela variável subscrita
     através de <v_i> irá ser usada para a variável de diferenciação.
     Isso permite que um array de nomes de coordenadas ou nomes
     subscritos como `x[1]', `x[2]', ...  sejam usados.

 -- Função: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     Diferenciação indicial. A menos que `diff', que diferencia com
     relação a uma variável independente, `idiff' possa ser usada para
     diferenciar com relação a uma coordenada. Para um objeto indexado,
     isso equivale a anexar ao final os <v_i> como índices derivativos.
     Subseqüêntemente, índices derivativos irão ser ordenados, a menos
     que `iframe_flag' seja escolhida para `true'.

     `idiff' pode também ser o determinante de um tensor métrico. Dessa
     forma, se `imetric' tiver sido associada a `G' então
     `idiff(determinant(g),k)' irá retornar
     `2*determinant(g)*ichr2([%i,k],[%i])' onde o índice que ocorre
     exatamente duas vezes `%i' é escolhido apropriadamente.


 -- Função: liediff (<v>, <ten>)
     Calcula a derivada de Lie da expressão tensorial <ten> com relação
     ao campo vetorial <v>. <ten> pode ser qualquer expressão tensorial
     indexada; <v> pode ser o nome (sem índices) de um campo vetorial.
     Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                          %1  k        %1  k      %1  k
                                      + (v   b      - b   v    + v   b   ) a
                                              ,%1 l    ,l  ,%1    ,l  ,%1   i j


 -- Função: rediff (<ten>)
     Avalia todas as ocorrências do comando `idiff' na expressão
     tensorial <ten>.


 -- Função: undiff (<expr>)
     Retorna uma expressão equivalente a <expr> mas com todas as
     derivadas de objetos indexados substituídas pela forma substantiva
     da função `idiff'. Seu argumento pode retornar aquele objeto
     indexado se a diferenciação for concluída.  Isso é útil quando for
     desejado substituir um objeto indexado que sofreu diferenciação
     com alguma definição de função resultando em <expr> e então
     concluir a diferenciação através de digamos `ev(<expr>, idiff)'.


 -- Função: evundiff (<expr>)
     Equivalente à execução de `undiff', seguida por `ev' e `rediff'.

     O ponto dessa operação é facilmente avaliar expressões que não
     possam ser diretamente avaliadas na forma derivada. Por exemplo, o
     seguinte causa um erro:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     Todavia, se `icurvature' é informado em sua forma substantiva,
     pode ser avaliado usando `evundiff':

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                          l              l         %1           l           %1
                   + ichr2        + ichr2     ichr2      + ichr2       ichr2
                          i j,k m        %1 k      i j,m        %1 k,m      i j

     Nota: Em versões anteriores do Maxima, formas derivadas dos
     símbolos de Christoffel também não podiam ser avaliadas. Isso foi
     corrigido atualmente, de forma que `evundiff' não mais é
     necessária para expressões como essa:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2


 -- Função: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que não tiverem índices derivativos.


 -- Função: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     Escolhe para zero, em <expr>, todas as ocorrências de <tensor_i>
     que tiverem índices derivativos.


 -- Função: flushnd (<expr>, <tensor>, <n>)
     Escolhe para zero, em <expr>, todas as ocorrências do objeto
     diferenciado <tensor> que tem <n> ou mais índices derivativos como
     demonstra o seguinte exemplo.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- Função: coord (<tensor_1>, <tensor_2>, ...)
     Dados os <tensor_i> a propriedade de diferenciação da coordenada
     que a derivada do vetor contravariante cujo nome é um dos
     <tensor_i> retorna um delta de Kronecker. Por exemplo, se
     `coord(x)' tiver sido concluída então `idiff(x([],[i]),j)' fornece
     `kdelta([i],[j])'.  `coord' que é uma lista de todos os objetos
     indexados tendo essa propriedade.


 -- Função: remcoord (<tensor_1>, <tensor_2>, ...)
 -- Função: remcoord (all)
     Remove a propriedade de coordenada de diferenciação dos `tensor_i'
     que foram estabelecidos através da função `coord'.  `remcoord(all)'
     remove essa propriedade de todos os objetos indexados.


 -- Função: makebox (<expr>)
     Mostra <expr> da mesma maneira que `show'; todavia, qualquer
     tensor d'Alembertiano ocorrendo em <expr> irá ser indicado usando o
     símbolo `[]'.  Por exemplo, `[]p([m],[n])' representa
     `g([],[i,j])*p([m],[n],i,j)'.


 -- Função: conmetderiv (<expr>, <tensor>)
     Simplifica expressões contendo derivadas comuns de ambas as formas
     covariantes e contravariantes do tensor métrico (a restrição
     corrente).  Por exemplo, `conmetderiv' pode relatar a derivada do
     tensor contravariante métrico com símbolos de Christoffel como
     visto adiante:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- Função: simpmetderiv (<expr>)
 -- Função: simpmetderiv (<expr>[, <stop>])
     Simplifica expressões contendo produtos de derivadas de tensores
     métricos. Especificamente, `simpmetderiv' reconhece duas
     identidades:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     conseqüêntemente


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     e


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     que seguem de simetrias de símbolos de Christoffel.

     A função `simpmetderiv' toma um parâmetro opcional que, quando
     presente, faz com que a função pare após a primeira substituição
     feita com sucesso em uma expressão produto. A função `simpmetderiv'
     também faz uso da variável global <flipflag> que determina como
     aplicar uma ordenação "canonica" para os índices de produto.

     Colocados juntos, essas compatibilidades podem ser usadas
     poderosamente para encontrar simplificações que são difíceis ou
     impossíveis de realizar de outra forma.  Isso é demonstrado
     através do seguinte exemplo que explicitamente usa o recurso de
     simplificação parcial de `simpmetderiv' para obter uma expressão
     contractível:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Veja também `weyl.dem' para um exemplo que usa `simpmetderiv' e
     `conmetderiv' juntos para simplificar contrações do tensor de Weyl.


 -- Função: flush1deriv (<expr>, <tensor>)
     Escolhe para zero, em `expr', todas as ocorrências de `tensor' que
     possuem exatamente um índice derivativo.


29.2.4 Tensores em espaços curvos
---------------------------------

 -- Função: imetric (<g>)
 -- Variável de sistema: imetric
     Especifica a métrica através de atribuição à variável `imetric:<g>'
     adicionalmente, as propriedades de contração da métrica <g> são
     escolhidas através da execução dos comandos
     `defcon(<g>),defcon(<g>,<g>,kdelta)'.  A variável `imetric'
     (desassociada por padrão), é associada à métrica, atribuida pelo
     comando `imetric(<g>)'.


 -- Função: idim (<n>)
     Escolhe as dimensões da métrica. Também inicializa as propriedades
     de antisimetria dos símbolos de Levi-Civita para as dimensões
     dadas.


 -- Função: ichr1 ([<i>, <j>, <k>])
     Retorna o símbolo de Christoffel de primeiro tipo via definição
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     Para avaliar os símbolos de Christoffel para uma métrica
     particular, à variável `imetric' deve ser atribuída um nome como
     no exemplo sob `chr2'.


 -- Função: ichr2 ([<i>, <j>], [<k>])
     Retorna o símbolo de Christoffel de segundo tipo definido pela
     relação
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- Função: icurvature ([<i>, <j>, <k>], [<h>])
     Retorna o tensor da curvatura de Riemann em termos de símbolos de
     Christoffel de segundo tipo (`ichr2').  A seguinte notação é usada:
                         h             h            h         %1         h
               icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                         i j k         i k,j        %1 j      i k        i j,k
                                         h          %1
                                  + ichr2      ichr2
                                         %1 k       i j

 -- Função: covdiff (<expr>, <v_1>, <v_2>, ...)
     Retorna a derivada da covariante de <expr> com relação às
     variáveis <v_i> em termos de símbolos de Christoffel de segundo
     tipo (`ichr2').  Com o objetivo de avaliar esses, se pode usar
     `ev(<expr>,ichr2)'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the índices covariantes: [i,j];
          Enter a list of the índices contravariantes: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k            k     %1
          (%t3)     - a     ichr2    - a     ichr2    + a      + ichr2     a
                       i %1      j s    %1 j      i s    i j,s        %1 s  i j
          (%i4) imetric:g;
          (%o4) 				       g
          (%i5) ishow(ev(%th(2),ichr2))$
          	 %1 %4  k
          	g      a     (g	      - g       + g	 )
          		i %1   s %4,j	 j s,%4	   j %4,s
          (%t5) - ------------------------------------------
          			    2
              %1 %3  k
             g	  a     (g       - g	   + g	    )
          	   %1 j	  s %3,i    i s,%3    i %3,s
           - ------------------------------------------
          		       2
              k %2  %1
             g     a    (g        - g	   + g	     )
          	  i j   s %2,%1	   %1 s,%2    %1 %2,s	  k
           + ------------------------------------------- + a
          			2			  i j,s
          (%i6)


 -- Função: lorentz_gauge (<expr>)
     Impõe a condição de Lorentz através da substituição de 0 para
     todos os objetos indexados em <expr> que possui um índice de
     derivada idêntico ao índice contravariante.


 -- Função: igeodesic_coords (<expr>, <nome>)
     Faz com que símbolos de Christoffel não diferenciados e a primeira
     derivada do tensor métrico tendam para zero em <expr>. O <nome> na
     função `igeodesic_coords' refere-se à métrica <nome> (se isso
     aparecer em <expr>) enquando os coeficientes de conecção devem ser
     chamados com os nomes `ichr1' e/ou `ichr2'. O seguinte exemplo
     demonstra a verificação da identidade cíclica satisfeita através
     do tensor da curvatura de Riemann usando a função
     `igeodesic_coords'.


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u            u         %1
          (%t2) - ichr2      - ichr2     ichr2    + ichr2      + ichr2     ichr2
                       r t,s        %1 s      r t        r s,t        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t        r t,s

                                                                            u
                                                                     + ichr2
                                                                            r s,t
          (%i5) canform(%);
          (%o5)                                  0


29.2.5 Molduras móveis
----------------------

Maxima atualmente tem a habilidade de executar cálculos usando molduras
móveis.  Essas podem ser molduras ortonormais (tetrads, vielbeins) ou
uma moldura arbitrária.

   Para usar molduras, você primeiro escolhe `iframe_flag' para `true'.
Isso faz com que os símbolos de Christoffel, `ichr1' e `ichr2', sejam
substituídos pelas molduras mais gerais de coeficientes de conecção
`icc1' e `icc2' em cálculos. Especialmente, o comportamento de
`covdiff' e `icurvature' são alterados.

   A moldura é definida através de dois tensores: o campo de moldura
inversa (`ifri'), a base tetrad dual), e a métrica da moldura `ifg'. A
métrica da moldura é a matriz identidade para molduras ortonormais, ou
a métrica de Lorentz para molduras ortonormais no espaço-tempo de
Minkowski. O campo de moldura inversa define a base da moldura (vetores
unitários).  Propriedades de contração são definidas para o campo de
moldura e para a métrica da moldura.

   Quando `iframe_flag' for `true', muitas expressões `itensor' usam a
métrica da moldura `ifg' em lugar da métrica definida através de
`imetric' para o decremento e para o incremento de índices.

   IMPORTANTE: Escolhendo a variável `iframe_flag' para `true' NÃO
remove a definição das propriedades de contração de uma métrica
definida através de uma chamada a `defcon' ou `imetric'. Se um campo de
moldura for usado, ele é melhor para definir a métrica através de
atribuição desse nome para a variável `imetric' e NÃO invoque a função
`imetric'.

   Maxima usa esses dois tensores para definir os coeficientes de
moldura (`ifc1' e `ifc2') cuja forma parte dos coeficientes de conecção
(`icc1' e `icc2'), como demonstra o seguinte exemplo:


     (%i1) load(itensor);
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                             %1      i           i        i
     (%t4)                  v   (ifc2     + ichr2    ) + v
                                     %1 j        %1 j     ,j
     (%i5) ishow(ev(%,ifc2))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t5)      -------------------------------------------------- + v
                                        2                             ,j
     (%i6) ishow(ifb([a,b,c]))$
                            %5    %4
     (%t6)               ifr   ifr   (ifri        - ifri       )
                            a     b       c %4,%5       c %5,%4

   Um método alternativo é usado para calcular o suporte da moldura
(`ifb') se o sinalizador `iframe_bracket_form' é escolhido para `false':


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                            %7    %6        %6      %7
     (%t8)              (ifr   ifr     - ifr     ifr  ) ifri
                            a     b,%7      a,%7    b       c %6

 -- Função: iframes ()
     Uma vez que nessa versão do Maxima, identidades de contração para
     `ifr' e `ifri' são sempre definidas, como é o suporte da moldura
     (`ifb'), essa função não faz nada.


 -- Variável: ifb
     O suporte da moldura. A contribuição da métrica da moldura para os
     coeficientes de conecção é expressa usando o suporte da moldura:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     O suporte da moldura por si mesmo é definido em termos de campo de
     moldura e métrica da moldura. Dois métodos alternativos de cálculo
     são usados dependendo do valor de `frame_bracket_form'. Se `true'
     (o padrão) ou se o sinalizador `itorsion_flag' for `true':


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e

     Otherwise:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d


 -- Variável: icc1
     Coeficientes de conecção de primeiro tipo. Em `itensor', definido
     como


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr1' é substituído com o coeficiente de conecção da
     moldura `ifc1'.  Se `itorsion_flag' for `false', `ikt1' será
     omitido. `ikt1' é também omitido se uma base de moldura for usada,
     como a torsão está já calculada como parte do suporte da moldura.
     Ultimamente, como `inonmet_flag' é `false', `inmc1' não estará
     presente.


 -- Variável: icc2
     Coeficientes de conecção de segundo tipo. Em `itensor', definido
     como


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     Nessa expressão, se `iframe_flag' for `true', o símbolo de
     Christoffel `ichr2' é substituído com o coeficiente de conecção
     `ifc2'.  Se `itorsion_flag' for `false', `ikt2' será omitido.
     `ikt2' também será omitido se uma base de moldura for usada, uma
     vez que a torsão já está calculada como parte do suporte da
     moldura.  Ultimamente, como `inonmet_flag' é `false', `inmc2' não
     estará presente.


 -- Variável: ifc1
     Coeficiente de moldura de primeiro tipo (também conhecido como
     coeficientes de rotação de Ricci).  Esse tensor representa a
     contribuição da métrica da moldura para o coeficiente de conecção
     de primeiro tipo. Definido como:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- Variável: ifc2
     Coeficiente de moldura de primeiro tipo. Esse tensor representa a
     contribuição da métrica da moldura para o coeficiente de conecção
     de primeiro tipo. Definido como uma permutação de suporte de
     moldura (`ifb') com os índices apropriados incrementados e
     decrementados como necessário:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd


 -- Variável: ifr
     O campo da moldura. Contrai (`ifri') para e com a forma do campo
     inverso da moldura para formar a métrica da moldura (`ifg').


 -- Variável: ifri
     O campo inverso da moldura. Especifica a base da moldura (vetores
     base duais). Juntamente com a métrica da moldura, forma a base de
     todos os cálculos baseados em molduras.


 -- Variável: ifg
     A métrica da moldura. O valor padrão é `kdelta', mas pode ser
     mudada usando `components'.


 -- Variável: ifgi
     O inverso da métrica da moldura. Contrai com a métrica da moldura
     (`ifg') para `kdelta'.


 -- Variável de Opção: iframe_bracket_form
     Valor padrão: `true'

     Especifica como o suporte da moldura (`ifb') é calculado.


29.2.6 Torsão e não metricidade
-------------------------------

Maxima pode trabalhar com torsão e não metricidade. Quando o sinalizador
`itorsion_flag' for escolhido para `true', a contribuição de torsão é
adicionada aos coeficientes de conecção. Similarmente, quando o
sinalizador `inonmet_flag' for `true', componentes de não metricidades
são incluídos.

 -- Variável: inm
     O vetor de não metricidade. Conforme a não metricidade está
     definida através da derivada covariante do tensor métrico.
     Normalmente zero, o tensor da métrica derivada covariante irá
     avaliar para o seguinte quando `inonmet_flag' for escolhido para
     `true':


          g     =- g  inm
           ij;k     ij  k


 -- Variável: inmc1
     Permutação covariante de componentes do vetor de não metricidade.
     Definida como


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: inmc2
     Permutação covariante de componentes do vetor de não metricidade.
     Usada nos coeficicientes de conecção se `inonmet_flag' for `true'.
     Definida como:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: ikt1
     Permutação covariante do tensor de torsão (também conhecido como
     contorsão).  Definido como:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: ikt2
     Permutação contravariante do tensor de torsão (também conhecida
     como contorsão).  Definida como:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (Substitue `ifg' em lugar de `g' se uma moldura métrica for usada.)


 -- Variável: itr
     O tensor de torsão. Para uma métrica com torsão, diferenciação
     covariante repetida sobre uma funçào escalar não irá comutar,como
     demonstrado através do seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff(covdiff(f([],[]),i),j)-covdiff(covdiff(f([],[]),j),i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j


29.2.7 Álgebra exterior
-----------------------

O pacote `itensor' pode executar operações sobre campos tensores
covariantes totalmente antisimétricos. Um campo tensor totalmente
antisimétrico de classe (0,L) corresponde a uma forma diferencial L.
Sobre esses objetos, uma operação de multiplicação funciona como um
produto exterior, ou produto cunha, é definido.

   Desafortunadamente, nem todos os autores concordam sobre a definição
de produto cunha. Alguns autores preferem uma definição que corresponde
à noção de antisimetrização: nessas palavras, o produto cunha de dois
campos vetoriais, por exemplo, pode ser definido como

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   Mais geralmente, o produto de uma forma p e uma forma q pode ser
definido como

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   onde `D' simboliza o delta de Kronecker.

   Outros autores, todavia, preferem uma definição "geométrica" que
corresponde à notação de elemento volume:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   e, no caso geral

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   Uma vez que `itensor' é um pacote de algebra de tensores, a primeira
dessas duas definições aparenta ser a mais natural por si mesma. Muitas
aplicações, todavia, usam a segunda definição. Para resolver esse
dilema, um sinalizador tem sido implementado que controla o
comportamento do produto cunha: se `igeowedge_flag' for `false' (o
padrão), a primeira, definição "tensorial" é usada, de outra forma a
segunda, definição "geométrica" irá ser aplicada.

 -- Operator: "~"
     O operador do produto cunha é definido como sendo o acento til
     `~'. O til é um operador binário. Seus argumentos podem ser
     expressões envolvendo escalares, tensores covariantes de categoria
     1, ou tensores covariantes de categoria `l' que tiverem sido
     declarados antisimétricos em todos os índices covariantes.

     O comportamento do operador do produto cunha é controlado através
     do sinalizador `igeowedge_flag', como no seguinte exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j


 -- Operator: "|"
     A barra vertical `|' denota a operação binária "contração com um
     vetor". Quando um tensor covariante totalmente antisimétrico é
     contraído com um vetor contravariante, o resultado é o mesmo
     independente de qual índice foi usado para a contração. Dessa
     forma, é possível definir a operação de contração de uma forma
     livre de índices.

     No pacote `itensor', contração com um vetor é sempre realizada com
     relação ao primeiro índice na ordem literal de ordenação. Isso
     garante uma melhor simplificação de expressões envolvendo o
     operador `|'. Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     Note que isso é essencial que os tensores usado como o operador
     `|' seja declarado totalmente antisimétrico em seus índices
     covariantes. De outra forma, os resultados serão incorretos.


 -- Função: extdiff (<expr>, <i>)
     Calcula a derivada exterior de <expr> com relação ao índice <i>. A
     derivada exterior é formalmente definida como o produto cunha do
     operador de derivada parcial e uma forma diferencial. Como tal,
     essa operação é também controlada através da escolha de
     `igeowedge_flag'.  Por exemplo:

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                      a      - a      + a
                                      j k,i    i k,j    i j,k


 -- Função: hodge (<expr>)
     Calcula o Hodge dual de <expr>. Por exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g        g
                                                               %1 %106  %2 %107
                                                      g        g      A        /6
                                                       %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108


 -- Variável de Opção: igeowedge_flag
     Valor padrão: `false'

     Controla o comportamento de produto cunha e derivada exterior.
     Quando for esconhida para `false' (o padrão), a noção de formas
     diferenciais irá corresponder àquela de um campo tensor covariante
     totalmente antisimétrico.  Quando escolhida para `true', formas
     diferenciais irão concordar com a noção do elemento volume.


29.2.8 Exportando expressões TeX
--------------------------------

O pacote `itensor' fornece suporte limitado à exportação de expressões
de tensores para o TeX.  Uma vez que expressões `itensor' aparecem como
chamada a funções, o comando regular `tex' do Maxima não produzirá a
saída esperada. Você pode tentar em seu lugar o comando `tentex', o
qual tenta traduzir expressões de tensores dentro de objetos TeX
indexados apropriadamente.

 -- Função: tentex (<expr>)
     Para usar a função `tentex', você deve primeiro chamar `tentex',
     como no seguinte exemplo:


          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load(tentex);
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i            i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2      + ichr2
                      j k      m1 l        j l      m1 k        j l,k        j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     Note o uso da declaração `idummyx', para evitar o aparecimento do
     sinal de porcentagem na expressão TeX, o qual pode induzir a erros
     de compilação.

     Note Bem: Essa vesão da função `tentex' é um tanto quanto
     experimental.


29.2.9 Interagindo com o pacote `ctensor'
-----------------------------------------

O pacote `itensor' possui a habilidade de gerar código Maxima que pode
então ser executado no contexto do pacote `ctensor'. A função que
executa essa tarefa é `ic_convert'.

 -- Função: ic_convert (<eqn>)
     Converte a equação <eqn> na sintaxe `itensor' para uma declaração
     de atribuição `ctensor'.  Adições implícitas sobre índices que
     ocorrem exatamente duas vezes são tornadas explícitas enquanto
     objetos indexados são transformados em arrays (os arrays
     subscritos estão na ordem de covariância seguidos de índices
     contravariantes dos objetos indexados). A derivada de um objeto
     indexado irá ser substituída pela forma substantiva de `diff'
     tomada com relação a `ct_coords' subscrita pelo índice de
     derivação. Os símbolos de Christoffel `ichr1' e `ichr2' irão ser
     traduzidos para `lcs' e `mcs', respectivamente e se
     `metricconvert' for `true' então todas as ocorrências da métrica
     com dois índices covariantes (ou contravariantes) irão ser
     renomeadas para `lg' (ou `ug'). Adicionalmente, ciclos `do' irão
     ser introduzidos adicionando sobre todos os índices livres de
     forma que a declaração de atribuição transformada pode ser
     avaliada através de apenas fazendo `ev'. Os seguintes exemplos
     demonstam os recursos dessa função.

          (%i1) load(itensor);
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)*b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim

          do (for k thru dim do t        : f sum(sum(diff(a , ct_coords ) b
                                 i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m


29.2.10 Palavras reservadas
---------------------------

As palavras seguintes do Maxima são usadas internamente pelo pacote
`itensor' e não podem ser redefinidas:

       Keyword    Comments
       ------------------------------------------
       indices2() versão interna de `indices()'
       conti      Lista de índices contravariantes
       covi       Lista de índices covariantes de um objeto indexado
       deri       Lista de índices de derivada de um objeto indexado
       name       Retorna o nome de um objeto indexado
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: Pacote atensor,  Prev: itensor,  Up: Top

30 ctensor
**********

* Menu:

* Introdução a ctensor::
* Definições para ctensor::


File: maxima.info,  Node: Introdução a ctensor,  Next: Definições para ctensor,  Prev: ctensor,  Up: ctensor

30.1 Introdução a ctensor
=========================

`ctensor' é um pacote de manipulação de componentes.  Para usar o pacote
`ctensor', digite `load(ctensor)'.  Para começar uma sessão iterativa
com `ctensor', digite `csetup()'.  Você é primeiramente solicitado a
especificar a dimensão a ser manipulada. Se a dimensão for 2, 3 ou 4
então a lista de coordenadas padrão é `[x,y]', `[x,y,z]' ou `[x,y,z,t]'
respectivamente.  Esses nomes podem ser mudados através da atribuição
de uma nova lista de coordenadas para a variável `ct_coords' (descrita
abaixo) e o usuário é perguntado sobre isso.Cuidado deve ser tomado
para evitar o conflito de nomes de coordenadas com outras definições de
objetos.

   No próximo passo, o usuário informa a métrica ou diretamente ou de
um arquivo especificando sua posição ordinal. Como um exemplo de um
arquivo de métrica comum, veja `share/tensor/metrics.mac'. A métrica
está armazenada na matriz LG. Finalmente, o inverso da métrica é
calculado e armazenado na matriz UG. Se tem a opção de realizar todos
os cálculos em séries de potência.

   Um protocolo amostra é iniciado abaixo para a métrica estática,
esfericamente simétrica (coordenadas padrão) que será aplicadas ao
problema de derivação das equações de vácuo de Einstein (que levam à
solução de Schwarzschild) como um exemplo. Muitas das funções em
`ctensor' irão ser mostradas para a métrica padrão como exemplos.

     (%i1) load(ctensor);
     (%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Definições para ctensor,  Prev: Introdução a ctensor,  Up: ctensor

30.2 Definições para ctensor
============================

30.2.1 Inicialização e configuração
-----------------------------------

 -- Função: csetup ()
     É uma função no pacote `ctensor' (component tensor) que inicializa
     o pacote e permite ao usuário inserir uma métrica interativamente.
     Veja `ctensor' para mais detalhes.

 -- Função: cmetric (<dis>)
 -- Função: cmetric ()
     É uma função no pacote `ctensor' que calcula o inverso da métrica
     e prepara o pacote para cálculos adiante.

     Se `cframe_flag' for `false', a função calcula a métrica inversa
     `ug' a partir da matriz `lg' (definida pelo usuário). O
     determinante da métrica é também calculado e armazenado na
     variável `gdet'. Mais adiante, o pacote determina se a métrica é
     diagonal e escolhe o valor de `diagmetric' conforme a
     determinação. Se o argumento opcional <dis> estiver presente e não
     for `false', a saída é mostrada ao usuário pela linha de comando
     para que ele possa ver o inverso da métrica.

     Se `cframe_flag' for `true', a função espera que o valor de `fri'
     (a matriz moldura inversa) e `lfg' (a métrica da moldura) sejam
     definidas. A partir dessas, a matriz da moldura `fr' e a métrica
     da moldura inversa `ufg' são calculadas.


 -- Função: ct_coordsys (<sistema_de_coordenadas>, <extra_arg>)
 -- Função: ct_coordsys (<sistema_de_coordenadas>)
     Escolhe um sistema de coordenadas predefinido e uma métrica. O
     argumento <sistema_de_coordenadas> pode ser um dos seguintes
     símbolos:


            SYMBOL               Dim Coordenadas       Descrição/comentários
            --------------------------------------------------------------------------
            cartesian2d           2  [x,y]             Sist. de coord. cartesianas 2D
            polar                 2  [r,phi]           Sist. de coord. Polare
            elliptic              2  [u,v]
            confocalelliptic      2  [u,v]
            bipolar               2  [u,v]
            parabolic             2  [u,v]
            cartesian3d           3  [x,y,z]           Sist. de coord. cartesianas 3D
            polarcylindrical      3  [r,theta,z]
            ellipticcylindrical   3  [u,v,z]           Elíptica 2D com Z cilíndrico
            confocalellipsoidal   3  [u,v,w]
            bipolarcylindrical    3  [u,v,z]           Bipolar 2D com Z cilíndrico
            paraboliccylindrical  3  [u,v,z]           Parabólico 2D com Z cilíndrico
            paraboloidal          3  [u,v,phi]
            conical               3  [u,v,w]
            toroidal              3  [u,v,phi]
            spherical             3  [r,theta,phi]     Sist. de coord. Esféricas
            oblatespheroidal      3  [u,v,phi]
            oblatespheroidalsqrt  3  [u,v,phi]
            prolatespheroidal     3  [u,v,phi]
            prolatespheroidalsqrt 3  [u,v,phi]
            ellipsoidal           3  [r,theta,phi]
            cartesian4d           4  [x,y,z,t]         Sist. de coord. 4D
            spherical4d           4  [r,theta,eta,phi]
            exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
            interiorschwarzschild 4  [t,z,u,v]        Métrica de Schwarzschild Interior
            kerr_newman           4  [t,r,theta,phi]   Métrica simétrica axialmente alterada

     `sistema_de_coordenadas' pode também ser uma lista de funções de
     transformação, seguida por uma lista contendo as varáveis
     coordenadas. Por exemplo, você pode especificar uma métrica
     esférica como segue:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     Funções de transformação podem também serem usadas quando
     `cframe_flag' for `true':


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
                [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
                [                                                                       ]
          (%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
                [                                                                       ]
                [     sin(theta)            r cos(theta)                   0            ]
          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     O argumento opcional <extra_arg> pode ser qualquer um dos
     seguintes:

     `cylindrical' diz a `ct_coordsys' para anexar uma coordenada
     adicional cilíndrica.

     `minkowski' diz a `ct_coordsys' para anexar uma coordenada com
     assinatura métrica negativa.

     `all' diz a `ct_coordsys' para chamar `cmetric' e
     `christof(false)' após escolher a métrica.

     Se a variável global `verbose' for escolhida para `true',
     `ct_coordsys' mostra os valores de `dim', `ct_coords', e ou `lg'
     ou `lfg' e `fri', dependendo do valor de `cframe_flag'.


 -- Função: init_ctensor ()
     Inicializa o pacote `ctensor'.

     A função `init_ctensor' reinicializa o pacote `ctensor'. Essa
     função remove todos os arrays e matrizes usados por `ctensor',
     coloca todos os sinalizadores de volta a seus valores padrão,
     retorna `dim' para 4, e retorna a métrica da moldura para a
     métrica da moldura de Lorentz.


30.2.2 Os tensores do espaço curvo
----------------------------------

O principal propósito do pacote `ctensor' é calcular os tensores do
espaç(tempo) curvo, mais notavelmente os tensores usados na relatividade
geral.

   Quando uma base métrica é usada, `ctensor' pode calcular os
seguintes tensores:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem

   `ctensor' pode também usar molduras móveis. Quando `cframe_flag' for
escolhida para `true', os seguintes tensores podem ser calculados:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- Função: christof (<dis>)
     Uma função no pacote `ctensor'.  Essa função calcula os símbolos
     de Christoffel de ambos os tipos.  O argumento <dis> determina
     quais resultados são para serem imediatamente mostrados.  Os
     símbolos de Christoffel de primeiro e de segundo tipo são
     armazenados nos arrays `lcs[i,j,k]' e `mcs[i,j,k]' respectivamente
     e definidos para serem simétricos nos primeiros dois índices. Se o
     argumento para `christof' for `lcs' ou for `mcs' então o único
     valor não nulo de `lcs[i,j,k]' ou de `mcs[i,j,k]',
     respectivamente, será mostrado. Se o argumento for `all' então o
     único valor não nulo de `lcs[i,j,k]' e o único valor não nulo de
     `mcs[i,j,k]' serão mostrados.  Se o argumento for `false' então a
     exibição dos elementos não acontecerá. Os elementos do array
     `mcs[i,j,k]' são definidos de uma tal maneira que o índice final é
     contravariante.

 -- Função: ricci (<dis>)
     Uma função no pacote `ctensor'.  `ricci' calcula as componentes
     contravariantes (simétricas) `ric[i,j]' do tensor de Ricci.  Se o
     argumento <dis> for `true', então as componentes não nulas são
     mostradas.

 -- Função: uricci (<dis>)
     Essa função primeiro calcula as componentes contravariantes
     `ric[i,j]' do tensor de Ricci.  Então o tensor misto de Ricci é
     calculado usando o tensor métrico contravariante.  Se o valor do
     argumento <dis> for `true', então essas componentes mistas,
     `uric[i,j]' (o índice "i" é covariante e o índice "j" é
     contravariante), serão mostradas diretamente.  De outra forma,
     `ricci(false)' irá simplesmente calcular as entradas do array
     `uric[i,j]' sem mostrar os resultados.


 -- Função: scurvature ()
     Retorna a curvatura escalar (obtida através da contração do tensor
     de Ricci) do Riemaniano multiplicado com a métrica dada.


 -- Função: einstein (<dis>)
     Uma função no pacote `ctensor'.  `einstein' calcula o tensor misto
     de Einstein após os símbolos de Christoffel e o tensor de Ricci
     terem sido obtidos (com as funções `christof' e `ricci').  Se o
     argumento <dis> for `true', então os valores não nulos do tensor
     misto de Einstein `ein[i,j]' serão mostrados quando `j' for o
     índice contravariante.  A variável `rateinstein' fará com que a
     simplificação racional ocorra sobre esses componentes. Se `ratfac'
     for `true' então as componentes irão também ser fatoradas.


 -- Função: leinstein (<dis>)
     Tensor covariante de Einstein. `leinstein' armazena o valor do
     tensor covariante de Einstein no array `lein'. O tensor covariante
     de Einstein é calculado a partir tensor misto de Einstein `ein'
     através da multiplicação desse pelo tensor métrico. Se o argumento
     <dis> for `true', então os valores não nulos do tensor covariante
     de Einstein são mostrados.


 -- Função: riemann (<dis>)
     Uma função no pacote `ctensor'.  `riemann' calcula o tensor de
     curvatura de Riemann a partir da métrica dada e correspondendo aos
     símbolos de Christoffel. As seguintes convenções de índice são
     usadas:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     Essa notação é consistente com a notação usada por no pacote
     `itensor' e sua função `icurvature'.  Se o argumento opcional
     <dis> for `true', as componentes não nulas `riem[i,j,k,l]' serão
     mostradas.  Como com o tensor de Einstein, vários comutadores
     escolhidos pelo usuário controlam a simplificação de componentes
     do tensor de Riemann.  Se `ratriemann' for `true', então
     simplificação racional será feita. Se `ratfac' for `true' então
     cada uma das componentes irá também ser fatorada.

     Se a variável `cframe_flag' for `false', o tensor de Riemann é
     calculado diretamente dos símbolos de Christoffel. Se
     `cframe_flag' for `false', o tensor covariante de Riemann é
     calculado primeiro dos coeficientes de campo da moldura.


 -- Função: lriemann (<dis>)
     Tensor covariante de Riemann (`lriem[]').

     Calcula o tensor covariante de Riemann como o array `lriem'. Se o
     argumento <dis> for `true', únicos valores não nulos são mostrados.

     Se a variável `cframe_flag' for `true', o tensor covariante de
     Riemann é calculado diretamente dos coeficientes de campo da
     moldura. De outra forma, o tensor (3,1) de Riemann é calculado
     primeiro.

     Para informação sobre a ordenação de índice, veja `riemann'.


 -- Função: uriemann (<dis>)
     Calcula as componentes contravariantes do tensor de curvatura  de
     Riemann como elementos do array `uriem[i,j,k,l]'.  Esses são
     mostrados se <dis> for `true'.


 -- Função: rinvariant ()
     Compõe o invariante de Kretchmann (`kinvariant') obtido através da
     contração dos tensores

          lriem[i,j,k,l]*uriem[i,j,k,l].

     Esse objeto não é automaticamente simplificado devido ao fato de
     poder ser muito largo.


 -- Função: weyl (<dis>)
     Calcula o tensor conformal de Weyl.  Se o argumento <dis> for
     `true', as componentes não nulas `weyl[i,j,k,l]' irão ser
     mostradas para o usuário.  De outra forma, essas componentes irão
     simplesmente serem calculadas e armazenadas.  Se o comutador
     `ratweyl' é escolhido para `true', então as componentes irão ser
     racionalmente simplificadas; se `ratfac' for `true' então os
     resultados irão ser fatorados também.


30.2.3 Expansão das séries de Taylor
------------------------------------

O pacote `ctensor' possui a habilidade para truncar resultados assumindo
que eles são aproximações das séries de Taylor. Esse comportamenteo é
controlado através da variável `ctayswitch'; quando escolhida para
`true', `ctensor' faz uso internamente da função `ctaylor' quando
simplifica resultados.

   A função `ctaylor' é invocada pelas seguintes funções de `ctensor':


         Function     Comments
         ---------------------------------
         christof()   só para mcs
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- Função: ctaylor ()
     A função `ctaylor' trunca seus argumentos através da conversão
     destes para uma série de Taylor usando `taylor', e então chamando
     `ratdisrep'. Isso tem efeito combinado de abandonar termos de
     ordem mais alta na variável de expansão `ctayvar'. A ordem dos
     termos que podem ser abandonados é definida através de `ctaypov'; o
     ponto em torno do qual a expansão da série é realizada está
     especificado em `ctaypt'.

     Como um exemplo, considere uma métrica simples que é uma
     perturbação da métrica de Minkowski. Sem restrições adicionais,
     mesmo uma métrica diagonal produz expressões para o tensor de
     Einstein que são de longe muito complexas:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                   [ h11 l - 1      0          0                 0            ]
                   [                                                          ]
                   [     0      h22 l + 1      0                 0            ]
                   [                                                          ]
          (%o8)    [                        2                                 ]
                   [     0          0      r  + h33 l            0            ]
                   [                                                          ]
                   [                                    2    2                ]
                   [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     Todavia, se nós recalcularmos esse exemplo como uma aproximação
     que é linear na variável `l', pegamos expressões muito simples:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                          2               2      4    2
                            - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                     r r                r

     Essa compatibilidade pode ser útil, por exemplo, quando
     trabalhamos no limite do campo fraco longe de uma fonte
     gravitacional.


30.2.4 Campos de moldura
------------------------

Quando a variável `cframe_flag' for escolhida para `true', o pacote
`ctensor' executa seus cálculos usando uma moldura móvel.

 -- Função: frame_bracket (<fr>, <fri>, <diagframe>)
     O delimitador da moldura (`fb[]').

     Calcula o delimitador da moldura conforme a seguinte definição:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b


30.2.5 Classificação Algébrica
------------------------------

Um novo recurso (a partir de November de 2004) de `ctensor' é sua
habilidade para calcular a classificação de Petrov de uma métrica
espaço tempo tetradimensional.  Para uma demonstração dessa
compatibilidade, veja o arquivo `share/tensor/petrov.dem'.

 -- Função: nptetrad ()
     Calcula um tetrad nulo de Newman-Penrose (`np') e seus índices
     ascendentes em contrapartida (`npi'). Veja `petrov' para um
     exemplo.

     O tetrad nulo é construído assumindo que uma moldura métrica
     ortonormal tetradimensional com assinatura métrica (-,+,+,+) está
     sendo usada.  As componentes do tetrad nulo são relacionadas para
     a matriz moldura inversa como segue:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4


 -- Função: psi (<dis>)
     Calcula os cinco coeficientes de Newman-Penrose
     `psi[0]'...`psi[4]'.  Se `psi' for escolhida para `true', os
     coeficientes são mostrados.  Veja `petrov' para um exemplo.

     Esses coeficientes são calculados a partir do tensor de Weyl em
     uma base de coordenada.  Se uma base de moldura for usada,o tensor
     de Weyl é primeiro convertido para a base de coordenada, que pode
     ser um procedimento computacional expansível. Por essa razão, em
     alguns casos pode ser mais vantajoso usar uma base de coordenada em
     primeiro lugar antes que o tensor de Weyl seja calculado. Note
     todavia, que para a construção de um tetrad nulo de Newman-Penrose
     é necessário uma base de moldura. Portanto, uma seqüência de
     cálculo expressiva pode começar com uma base de moldura, que é
     então usada para calcular `lg' (calculada automaticamente através
     de `cmetric') e em seguida calcula `ug'. Nesse ponto, você pode
     comutar de volta para uma base de coordenada escolhendo
     `cframe_flag' para `false' antes de começar a calcular os símbolos
     de Christoffel. Mudando para uma base de moldura em um estágio
     posterior pode retornar resultados inconsistentes, já que você
     pode terminar com um grande mistura de tensores, alguns calculados
     em uma base de moldura, alguns em uma base de coordenada, sem
     nenhum modo para distingüir entre os dois tipos.


 -- Função: petrov ()
     Calcula a classificação de petrov da métrica caracterizada através
     de `psi[0]'...`psi[4]'.

     Por exemplo, o seguinte demonstra como obter a classificação de
     Petrov da métrica de Kerr:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

                 [  sqrt(r - 2 m)           sqrt(r)                                     ]
                 [ ---------------   ---------------------      0             0         ]
                 [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
                 [                                                                      ]
                 [  sqrt(r - 2 m)            sqrt(r)                                    ]
                 [ ---------------  - ---------------------     0             0         ]
                 [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
                 [                                                                      ]
                 [                                              r      %i r sin(theta)  ]
                 [        0                    0             -------   ---------------  ]
                 [                                           sqrt(2)       sqrt(2)      ]
                 [                                                                      ]
                 [                                              r       %i r sin(theta) ]
                 [        0                    0             -------  - --------------- ]
                 [                                           sqrt(2)        sqrt(2)     ]

                                       sqrt(r)          sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     A função de classificação Petrov é baseada no algorítmo publicado
     em "Classifying geometries in general relativity: III
     Classification in practice" por Pollney, Skea, e d'Inverno, Class.
     Quant. Grav. 17 2885-2902 (2000).  Exceto para alguns casos de
     teste simples, a implementação não está testada até 19 de Dezembro
     de 2004, e é provável que contenha erros.


30.2.6 Torsão e não metricidade
-------------------------------

`ctensor' possui a habilidade de calcular e incluir coeficientes de
torsão e não metricidade nos coeficientes de conecção.

   Os coeficientes de torsão são calculados a partir de um tensor
fornecido pelo usuário `tr', que pode ser um tensor de categoria (2,1).
A partir disso, os coeficientes de torsão `kt' são calculados de
acordo com a seguinte fórmula:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   Note que somente o tensor de índice misto é calculao e armazenado no
array `kt'.

   Os coeficientes de não metricidade são calculados a partir  do vetor
de não metricidade fornecido pelo usuário `nm'. A partir disso, os
coeficientes de não metricidade `nmc' são calculados como segue:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   onde D simboliza o delta de Kronecker.

   Quando `ctorsion_flag' for escolhida para `true', os valores de `kt'
são subtraídos dos coeficientes de conecção indexados mistos calculados
através de `christof' e armazenados em `mcs'. Similarmente, se
`cnonmet_flag' for escolhida para `true', os valores de `nmc' são
subtraídos dos coeficientes de conecção indexados mistos.

   Se necessário, `christof' chama as funções `contortion' e
`nonmetricity' com o objetivo de calcular `kt' e `nm'.

 -- Função: contortion (<tr>)
     Calcula os coeficientes de contorsão de categoria (2,1) a partir
     do tensor de torsão <tr>.


 -- Função: nonmetricity (<nm>)
     Calcula o coeficiente de não metricidade de categoria (2,1) a
     partir do vetor de não metricidade <nm>.


30.2.7 Recursos diversos
------------------------

 -- Função: ctransform (<M>)
     Uma função no pacote `ctensor' que irá executar uma transformação
     de coordenadas sobre uma matriz simétrica quadrada arbitrária <M>.
     O usuário deve informar as funçãoes que definem a transformação.
     (Formalmente chamada `transform'.)


 -- Função: findde (<A>, <n>)
     Retorna uma lista de equações diferenciais únicas (expressões)
     correspondendo aos elementos do array quadrado <n> dimensional
     <A>. Atualmente, <n> pode ser 2 ou 3. `deindex' é uma lista global
     contendo os índices de <A> correspondendo a essas únicas equações
     diferenciais. Para o tensor de Einstein (`ein'), que é um array
     dimensional, se calculado para a métrica no exemplo abaixo,
     `findde' fornece as seguintes equações diferenciais independentes:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
                  x                     x x         x        x    x            x

                                                                  2          2
                                                          - 2 a  d , a  x + a  - a]
                                                               x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]


 -- Função: cograd ()
     Calcula o gradiente covariante de uma função escalar permitindo ao
     usuário escolher o nome do vetor correspondente como o exemplo sob
     `contragrad' ilustra.

 -- Função: contragrad ()
     Calcula o gradiente contravariante de uma função escalar permitindo
     ao usuário escolher o nome do vetor correspondente como o exemplo
     abaixo como ilustra a métrica de Schwarzschild:


          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r


 -- Função: dscalar ()
     Calcula o tensor d'Alembertiano da função escalar assim que as
     dependências tiverem sido declaradas sobre a função. Po exemplo:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r


 -- Função: checkdiv ()
     Calcula a divergência covariante do tensor de segunda categoria
     misto (cujo primeiro índice deve ser covariante) imprimindo as
     correspondentes n componentes do campo do vetor (a divergência)
     onde n = `dim'. Se o argumento para a função for `g' então a
     divergência do tensor de Einstein irá ser formada e pode ser zero.
     Adicionalmente, a divergência (vetor) é dada no array chamado
     `div'.

 -- Função: cgeodesic (<dis>)
     Uma função no pacote `ctensor'.  `cgeodesic' calcula as equações
     geodésicas de movimento para uma dada métrica.  Elas são
     armazenadas no array `geod[i]'.  Se o argumento <dis> for `true'
     então essas equações são mostradas.


 -- Função: bdvac (<f>)
     Gera as componentes covariantes das equações de campo de vácuo da
     teoria de gravitação de Brans-Dicke. O campo escalar é especificado
     através do argumento <f>, que pode ser um nome de função (com
     apóstrofo) com dependências funcionais, e.g., `'p(x)'.

     As componentes de segunda categoria do tensor campo covariante são
     as componentes de segunda categoria representadas pelo array `bd'.


 -- Função: invariant1 ()
     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de R^2. As equações de campo são componentes
     de um array chamado `inv1'.


 -- Função: invariant2 ()
     *** NOT YET IMPLEMENTED ***

     Gera o tensor misto de Euler-Lagrange (equações de campo) para a
     densidade invariante de `ric[i,j]*uriem[i,j]'. As equações de
     campo são as componentes de um array chamado `inv2'.


 -- Função: bimetric ()
     *** NOT YET IMPLEMENTED ***

     Gera as euauações de campo da teoria bimétrica de Rosen. As
     equações de campo são as componentes de um array chamado `rosen'.


30.2.8 Funções utilitárias
--------------------------

 -- Função: diagmatrixp (<M>)
     Retorna `true' se <M> for uma matriz diagonal ou um array (2D).


 -- Função: symmetricp (<M>)
     Retorna `true' se <M> for uma matriz simétrica ou um array (2D).


 -- Função: ntermst (<f>)
     Fornece ao usuário um rápido quadro do "tamanho" do tensor
     duplamente subscrito (array) <f>.  Imprime uma lista de dois
     elementos onde o segundo elemento corresponde a N-TERMOS de
     componentes especificadas através dos primeiros elementos.  Nesse
     caminho, é possível rapidamente encontrar as expressões não nulas
     e tentar simplificação.


 -- Função: cdisplay (<ten>)
     Mostra todos os elementos do tensor <ten>, como representados por
     um array multidimensional. Tensores de categoria 0 e 1, assim como
     outros tipos de variáveis, são mostrados com `ldisplay'. Tensores
     de categoria 2 são mostrados como matrizes bidimensionais,
     enquanto tensores de alta categoria são mostrados como uma lista
     de matrizes bidimensionais. Por exemplo, o tensor de Riemann da
     métrica de Schwarzschild pode ser visto como:

          (%i1) load(ctensor);
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                         [ 0               0                    0            0      ]
                         [                                                          ]
                         [                              2                           ]
                         [      3 m (r - 2 m)   m    2 m                            ]
                         [ 0  - ------------- + -- - ----       0            0      ]
                         [            4          3     4                            ]
                         [           r          r     r                             ]
                         [                                                          ]
              riem     = [                                 m (r - 2 m)              ]
                  1, 1   [ 0               0               -----------       0      ]
                         [                                      4                   ]
                         [                                     r                    ]
                         [                                                          ]
                         [                                              m (r - 2 m) ]
                         [ 0               0                    0       ----------- ]
                         [                                                   4      ]
                         [                                                  r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                             [     2 m                                         ]
                             [ ------------  0        0               0        ]
                             [  2                                              ]
                             [ r  (r - 2 m)                                    ]
                             [                                                 ]
                             [      0        0        0               0        ]
                             [                                                 ]
                  riem     = [                         m                       ]
                      2, 2   [      0        0  - ------------        0        ]
                             [                     2                           ]
                             [                    r  (r - 2 m)                 ]
                             [                                                 ]
                             [                                         m       ]
                             [      0        0        0         - ------------ ]
                             [                                     2           ]
                             [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                           [        2                                             ]
                           [   m sin (theta)                                      ]
                           [ - -------------         0                0         0 ]
                           [         r                                            ]
                           [                                                      ]
                           [                         2                            ]
                           [                    m sin (theta)                     ]
                riem     = [        0         - -------------         0         0 ]
                    4, 4   [                          r                           ]
                           [                                                      ]
                           [                                          2           ]
                           [                                   2 m sin (theta)    ]
                           [        0                0         ---------------  0 ]
                           [                                          r           ]
                           [                                                      ]
                           [        0                0                0         0 ]

          (%o5)                                done

 -- Função: deleten (<L>, <n>)
     Retorna uma nova lista consistindo de <L> com o <n>'ésimo elemento
     apagado.

30.2.9 Variáveis usadas por `ctensor'
-------------------------------------

 -- Variável de opção: dim
     Valor padrão: 4

     Uma opção no pacote `ctensor'.  `dim' é a dimensão de
     multiplicação com o padrão 4. O comando `dim: n' irá escolher a
     dimensão para qualquer outro valor `n'.


 -- Variável de opção: diagmetric
     Valor padrão: `false'

     Uma opção no pacote `ctensor'.  Se `diagmetric' for `true' rotinas
     especiais calculam todos os objetos geométricos (que possuem o
     tensor métrico explicitamente) levando em consideração a
     diagonalidade da métrica. Tempo de execuçào reduzido irá, com
     certeza, resultar dessa escolha. Nota: essa opção é escolhida
     automaticamente por `csetup' se uma métrica diagonal for
     especificada.


 -- Variável de opção: ctrgsimp
     Faz com que simplificações trigonométricas sejam usadas quando
     tensores forem calculados. Atualmente, `ctrgsimp' afeta somente
     cálculos envolvendo uma moldura móvel.


 -- Variável de opção: cframe_flag
     Faz com que cálculos sejam executados relativamente a uma moldura
     móvel em oposição a uma métrica holonômica. A moldura é definida
     através do array da moldura inversa `fri' e da métrica da moldura
     `lfg'. Para cálculos usando uma moldura Cartesiana, `lfg' pode ser
     a matriz unitária de dimensão apropriada; para cálculos em uma
     moldura de Lorentz, `lfg' pode ter a assinatura apropriada.


 -- Variável de opção: ctorsion_flag
     Faz com que o tensor de contorsão seja incluído no cálculo dos
     coeficientes de conecção. O tensor de contorsão por si mesmo é
     calculado através de `contortion' a partir do tensor `tr'
     fornecido pelo usuário.


 -- Variável de opção: cnonmet_flag
     Faz com que os coeficientes de não metricidade sejam incluídos no
     cálculo dos coeficientes de conecção. Os coeficientes de não
     metricidade são calculados a partir do vetor de não metricidade
     `nm' fornecido pelo usuário através da função `nonmetricity'.


 -- Variável de opção: ctayswitch
     Se escolhida para `true', faz com que alguns cálculos de `ctensor'
     sejam realizados usando expansões das séries de Taylor.
     atualmente, `christof', `ricci', `uricci', `einstein', e `weyl'
     levam em conta essa escolha.


 -- Variável de opção: ctayvar
     Variável usada pela expansão de séries de Taylor se `ctayswitch' é
     escolhida para `true'.


 -- Variável de opção: ctaypov
     Maximo expoente usado em expansões de séries de Taylor quando
     `ctayswitch' for escolhida para `true'.


 -- Variável de opção: ctaypt
     Ponto em torno do qual expansões de séries de Taylor sao
     realizadas quando `ctayswitch' for escolhida para `true'.


 -- Variável de sistema: gdet
     O determinante do tensor métrico `lg'. Calculado através de
     `cmetric' quando `cframe_flag' for escolhido para `false'.


 -- Variável de opção: ratchristof
     Faz com que simplificações racionais sejam aplicadas através de
     `christof'.


 -- Variável de opção: rateinstein
     Valor padrão: `true'

     Se `true' simplificação racional irá ser executada sobre as
     componentes não nulas de tensores de Einstein; se `ratfac' for
     `true' então as componentes irão também ser fatoradas.


 -- Variável de opção: ratriemann
     Valor padrão: `true'

     Um dos comutadores que controlam simplificações dos tensores de
     Riemann; se `true', então simplificações racionais irão ser
     concluídas; se `ratfac' for `true' então cada uma das componentes
     irá também ser fatorada.


 -- Variável de opção: ratweyl
     Valor padrão: `true'

     Se `true', esse comutador faz com que a função de `weyl' aplique
     simplificações racionais aos valores do tensor de Weyl. Se
     `ratfac' for `true', então as componentes irão também ser
     fatoradas.

 -- Variável: lfg
     A moldura métrica covariante. Por padrão, é inicializada para a
     moldura tetradimensional de Lorentz com assinatura (+,+,+,-).
     Usada quando `cframe_flag' for `true'.

 -- Variável: ufg
     A métrica da moldura inversa. Calculada de `lfg' quando `cmetric'
     for chamada enquanto `cframe_flag' for escolhida para `true'.

 -- Variável: riem
     O tensor de categoria (3,1) de Riemann. Calculado quando a função
     `riemann' é invocada. Para informação sobre ordenação de índices,
     veja a descrição de `riemann'.

     Se `cframe_flag' for `true', `riem' é calculado a partir do tensor
     covariante de Riemann `lriem'.


 -- Variável: lriem
     O tensor covariante de Riemann. Calculado através de `lriemann'.


 -- Variável: uriem
     O tensor contravariante de Riemann. Calculado através de
     `uriemann'.


 -- Variável: ric
     O tensor misto de Ricci. Calculado através de `ricci'.


 -- Variável: uric
     O tensor contravariante de Ricci. Calculado através de `uricci'.


 -- Variável: lg
     O tensor métrico. Esse tensor deve ser especificado (como uma
     `dim' através da matriz `dim') antes que outro cálculo possa ser
     executado.


 -- Variável: ug
     O inverso do tensor métrico. Calculado através de `cmetric'.


 -- Variável: weyl
     O tensor de Weyl. Calculado através de `weyl'.


 -- Variável: fb
     Coeficientes delimitadores da moldura, como calculado através de
     `frame_bracket'.


 -- Variável: kinvariant
     O invariante de Kretchmann. Calculado através de `rinvariant'.


 -- Variável: np
     Um tetrad nulo de Newman-Penrose. Calculado através de `nptetrad'.


 -- Variável: npi
     O índice ascendente do tetrad nulo de Newman-Penrose. Calculado
     através de `nptetrad'.  Definido como `ug.np'. O produto
     `np.transpose(npi)' é constante:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]


 -- Variável: tr
     Tensor de categoria 3 fornecido pelo usuário representando torsão.
     Usado por `contortion'.

 -- Variável: kt
     O tensor de contorsão, calculado a partir de `tr' através de
     `contortion'.

 -- Variável: nm
     Vetor de não metrcidade fornecido pelo usuário. Usado por
     `nonmetricity'.

 -- Variável: nmc
     Os coeficientes de não metricidade, calculados a partir de `nm'
     por `nonmetricity'.


 -- Variável de sistema: tensorkill
     Variável indicando se o pacote tensor foi inicializado. Escolhida
     e usada por `csetup', retornada ao seu valor original através de
     `init_ctensor'.


 -- Variável de opção: ct_coords
     Valor padrão: `[]'

     Uma opção no pacote `ctensor'.  `ct_coords' contém uma lista de
     coordenadas.  Enquanto normalmente definida quando a função
     `csetup' for chamada, se pode redefinir as coordenadas com a
     atribuição `ct_coords: [j1, j2, ..., jn]' onde os j's são os novos
     nomes de coordenadas.  Veja também `csetup'.


30.2.10 Nomes reservados
------------------------

Os seguintes nomes são usados internamente pelo pacote `ctensor' e não
devem ser redefinidos:

       Name         Description
       ---------------------------------------
       _lg()        Avalia para `lfg' se a moldura métrica for usada,
     		    para `lg' de outra forma
       _ug()        Avalia para `ufg' se a moldura métrica for usada,
     		    para `ug' de outra forma
       cleanup()    Remove ítens da lista `deindex'
       contract4()  Usado por psi()
       filemet()    Usado por csetup() quando lendo a métrica de um arquivo
       findde1()    Usado por findde()
       findde2()    Usado por findde()
       findde3()    Usado por findde()
       kdelt()      Delta de Kronecker (não generalizado)
       newmet()     Usado por csetup() para escolher uma métrica
     		    interativamente
       setflags()   Usado por init_ctensor()
       readvalue()
       resimp()
       sermet()     Usado por csetup() para informar uma métricacom série
     		    de Taylor
       txyzsum()
       tmetric()    Moldura métrica, usado por cmetric() quando
     		    cframe_flag:true
       triemann()   Tensor de Riemann em base de moldura, usado quando
     		    cframe_flag:true
       tricci()     Tensor de Ricci em base de moldura, usada quando
     		    cframe_flag:true
       trrc()       Coeficientes de rotação de Ricci, usado por
     		    christof()
       yesp()

30.2.11 Changes
---------------

Em Novembro de 2004, o pacote `ctensor' foi extensivamente reescrito.
Muitas funções e variáveis foram renomeadas com o objetivo de tornar o
pacote com a versão comercial do Macsyma.

       Novo Nome    Nome Antigo     Descrição
       --------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Expansão da série de Taylor de uma
       -----------------------------expressão
       lgeod[]      EM              Equações geodésicas
       ein[]        G[]             Tensor misto de Einstein
       ric[]        LR[]            Tensor misto de Ricci
       ricci()      LRICCICOM()     Calcula o tensor misto de Ricci
       ctaypov      MINP            Maximo expoente em expansões de séries de
       -----------------------------Taylor
       cgeodesic()  MOTION          Calcula as equações geodésicas
       ct_coords    OMEGA           Coordenadas métricas
       ctayvar      PARAM           Variável de expansão de séries de
       -----------------------------Taylor
       lriem[]      R[]             Tensor covariante de Riemann
       uriemann()   RAISERIEMANN()  Calcula o tensor contravariante de
       -----------------------------Riemann
       ratriemann   RATRIEMAN       Simplificação racional do tensor de
       -----------------------------Riemann
       uric[]       RICCI[]         Tensor de Ricci contravariante
       uricci()     RICCICOM()      Calcula o tensor de Ricci contravariante
       cmetric()    SETMETRIC()     Escolhe a métrica
       ctaypt       TAYPT           Ponto para expansões de séries de Taylor
       ctayswitch   TAYSWITCH       Escolhe o comutador de séries de Taylor
       csetup()     TSETUP()        Inicia sessão interativa de configuração
       ctransform() TTRANSFORM()    Transformação de coordenadas interativa
       uriem[]      UR[]            Tensor contravariante de Riemann
       weyl[]       W[]             Tensor (3,1) de Weyl


File: maxima.info,  Node: Pacote atensor,  Next: Séries,  Prev: ctensor,  Up: Top

31 Pacote atensor
*****************

* Menu:

* Introdução ao Pacote atensor::
* Definições para o Pacote atensor::


File: maxima.info,  Node: Introdução ao Pacote atensor,  Next: Definições para o Pacote atensor,  Prev: Pacote atensor,  Up: Pacote atensor

31.1 Introdução ao Pacote atensor
=================================

`atensor' é um pacote de manipulção de tensores algébricos.  Para usar
`atensor', digite `load(atensor)', seguido por uma chamada à função
`init_atensor'.

   A essência de `atensor' é um conjunto de regras de simplificação
para o operador de produto (ponto) não comutativo ("`.'").  `atensor'
reconhece muitos tipos de álgebra; as regras de simplificação
correspondentes são ativadas quando a função `init_atensor' é chamada.

   A compatibilidade de `atensor' pode ser demonstrada pela definição da
álgebra de quatérnios como uma álgera-Clifford Cl(0,2) com dois vetores
fundamentais.  As três unidades quaterniônicas imaginárias fundamentais
são então os dois vetores base  e seu produto, i.e.:

         i = v     j = v     k = v  .  v
              1         2         1    2

   Embora o pacote `atensor' tenha uma definição interna para a álgebra
dos quatérnios, isso não foi usado nesse exemplo, no qual nós nos
esforçamos para construir a tabela de multiplicação dos quatérnios como
uma matriz:


     (%i1) load(atensor);
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  .  v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  .  v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  .  v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  .  v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  .  v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   `atensor' reconhece como bases vetoriais símbolos indexados, onde o
símbolo é aquele armazenado em `asymbol' e o iíndice está entre 1 e
`adim'.  Para símbolos indexado, e somente para símbolos indexados, as
formas bilineares `sf', `af', e `av' são avaliadas.  A avaliação
substitui os valores  de `aform[i,j]' em lugar de `fun(v[i],v[j])' onde
`v' representa o valor de `asymbol' e `fun' é ainda `af' ou `sf'; ou,
isso substitui `v[aform[i,j]]' em lugar de `av(v[i],v[j])'.

   Desnecessário dizer, as funções `sf', `af' e `av' podem ser
redefinidas.

   Quando o pacote `atensor' é chamado, os seguintes sinalizadores são
configurados:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   Se você deseja experimentar com uma álgebra não associativa, você
pode também considerar a configuração de `dotassoc' para `false'.
Nesse caso, todavia, `atensimp' não stará sempre habilitado a obter as
simplificações desejadas.


File: maxima.info,  Node: Definições para o Pacote atensor,  Prev: Introdução ao Pacote atensor,  Up: Pacote atensor

31.2 Definições para o Pacote atensor
=====================================

 -- Função: init_atensor (<alg_type>, <opt_dims>)
 -- Função: init_atensor (<alg_type>)
     Inicializa o pacote `atensor' com o tipo especificado de álgebra.
     <alg_type> pode ser um dos seguintes:

     `universal': A álgebra universal tendo regras não comutativas.

     `grassmann': A álgebra de Grassman é definida pela relação de
     comutação `u.v+v.u=0'.

     `clifford': A álgebra de Clifford é definida pela relação de
     comutação `u.v+v.u=-2*sf(u,v)' onde `sf' é a função valor-escalar
     simétrico.  Para essa álgebra, <opt_dims> pode ser acima de três
     inteiros não negativos, representando o número de dimensões
     positivas, dimensões degeneradas, e dimensões negativas da
     álgebra, respectivamente.  Se quaisquer valores <opt_dims> são
     fornecidos, `atensor' irá configurar os valores de `adim' e
     `aform' apropriadamente.  Caso contrário, `adim' irá por padrão
     para 0 e `aform' não será definida.

     `symmetric': A álgebra simétrica é definida pela relação de
     comutação `u.v-v.u=0'.

     `symplectic': A álgebra simplética é definida pela relação de
     comutação `u.v-v.u=2*af(u,v)' onde `af' é uma função valor-escalar
     antisimétrica.  Para a álgebra simplética, <opt_dims> pode mais de
     dois inteiros não negativos, representando a dimensão não
     degenerada e e a dimensão degenerada, respectivamente.  Se
     quaisquer valores <opt_dims> são fornecidos, `atensor' irá
     configurar os valores de `adim' e `aform' apropriadamente.  Caso
     contrário, `adim' irá por padrão para 0 e `aform' não será
     definida.

     `lie_envelop': O invólucro da álgebra de Lie é definido pela
     relação de comutação `u.v-v.u=2*av(u,v)' onde `av' é uma função
     antisimétrica.

     A função `init_atensor' também reconhece muitos tipos
     pré-definidos de álgebra:

     `complex' implementa a álgebra de números complexos como a álgebra
     de Clifford Cl(0,1).  A chamada `init_atensor(complex)' é
     equivalente a `init_atensor(clifford,0,0,1)'.

     `quaternion' implementa a álgebra de quatérnios.  A chamada
     `init_atensor(quaternion)' é equivalente a
     `init_atensor(clifford,0,0,2)'.

     `pauli' implementa a álgebra de Pauli-spinors como a
     Clifford-álgebra Cl(3,0).  Uma chamada a `init_atensor(pauli)' é
     equivalente a `init_atensor(clifford,3)'.

     `dirac' implementa a álgebra de Dirac-spinors como a
     Clifford-álgebra Cl(3,1).  Uma chamada a `init_atensor(dirac)' é
     equivalente a `init_atensor(clifford,3,0,1)'.


 -- Função: atensimp (<expr>)
     Simplifica a expressão algébrica de tensores <expr> conforme as
     regras configuradas por uma chamada a `init_atensor'.
     Simplificações incluem aplicação recursiva de relações comutativas
     e resoluções de chamadas a `sf', `af', e `av' onde for aplicável.
     Uma salvaguarda é usada para garantir que a função sempre termine,
     mesmo para expressões complexas.


 -- Função: alg_type
     O tipo de álgebra.  Valores válidos sáo `universal', `grassmann',
     `clifford', `symmetric', `symplectic' and `lie_envelop'.


 -- Variável: adim
     A dimensionalidade da álgebra.  `atensor' usa o valor de `adim'
     para determinar se um objeto indexado é uma base vetorial válida.
     Veja `abasep'.


 -- Variável: aform
     Valor padrão para as formas bilineares `sf', `af', e `av'.  O
     padrão é a matriz identidade `ident(3)'.


 -- Variável: asymbol
     O símbolo para bases vetoriais.


 -- Função: sf (<u>, <v>)
     É uma função escalar simétrica que é usada em relações comutativas.
     A implementação padrão verifica se ambos os argumentos são bases
     vetoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.


 -- Função: af (<u>, <v>)
     É uma função escalar antisimétrica que é usada em relações
     comutativas.  A implementação padrão verifica se ambos os
     argumentos são bases vetoriais usando `abasep' e se esse for o
     caso, substitui o valor correspondente da matriz `aform'.


 -- Função: av (<u>, <v>)
     É uma função antisimétrica que é usada em relações comutativas.  A
     implementação padrão verifica se ambos os argumentos são bases
     vetoriais usando `abasep' e se esse for o caso, substitui o valor
     correspondente da matriz `aform'.

     Por exemplo:

          (%i1) load(atensor);
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3


 -- Função: abasep (<v>)
     Verifica se esse argumento é uma base vetorial `atensor' .

     E será, se ele for um símbolo indexado, com o símbolo sendo o
     mesmo que o valor de `asymbol', e o índice tiver o mesmo valor
     numérico entre 1 e `adim'.



File: maxima.info,  Node: Séries,  Next: Teoria dos Números,  Prev: Pacote atensor,  Up: Top

32 Séries
*********

* Menu:

* Introdução a Séries::
* Definições para Séries::


File: maxima.info,  Node: Introdução a Séries,  Next: Definições para Séries,  Prev: Séries,  Up: Séries

32.1 Introdução a Séries
========================

Maxima contém funções `taylor' e `powerseries' (séries de potência)
para encontrar as séries de funções diferenciáveis.   Maxima também tem
ferramentas  tais como `nusum' capazes de encontrar a forma fechada de
algumas séries.   Operações tais como adição e multiplicação travalham
da forma usual sobre séries.  Essa seção apresenta as variáveis globais
que controlam a expansão.


File: maxima.info,  Node: Definições para Séries,  Prev: Introdução a Séries,  Up: Séries

32.2 Definições para Séries
===========================

 -- Variável de opção: cauchysum
     Valor padrão: `false'

     Quando multiplicando adições jutas com `inf' como seus limites
     superiores, se `sumexpand' for `true' e `cauchysum' for `true'
     então o produto de Cauchy será usado em lugar do produto usual.
     No produto de Cauchy o índice do somatório interno é uma função do
     índice do externo em lugar de variar independentemente.

     Exemplo:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0


 -- Função: deftaylor (<f_1>(<x_1>), <expr_1>, ..., <f_n>(<x_n>),
          <expr_n>)
     Para cada função <f_i> de uma variável <x_i>, `deftaylor' define
     <expr_i> como a séries de Taylor sobre zero.  <expr_i> é
     tipicamente um polinômio em <x_i> ou um somatório; expressões mais
     gerais são aceitas por `deftaylor' sem reclamações.

     `powerseries (<f_i>(<x_i>), <x_i>, 0)' retorna as séries definidas
     por `deftaylor'.

     `deftaylor' retorna uma lista das funções <f_1>, ..., <f_n>.
     `deftaylor' avalia seus argumentos.

     Exemplo:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200


 -- Variável de opção: maxtayorder
     Valor padrão: `true'

     Quando `maxtayorder' for `true', durante a manipulação algébrica
     de séries (truncadas) de Taylor, `taylor' tenta reter tantos
     termos quantos forem conhecidos serem corretos.


 -- Função: niceindices (<expr>)
     Renomeia os índices de adições e produtos em <expr>.
     `niceindices' tenta renomear cada índice para o valor de
     `niceindicespref[1]', a menos que o nome apareça nas parcelas do
     somatório ou produtório, nesses casos `niceindices' tenta os
     elementos seguintes de `niceindicespref' por sua vez, até que uma
     varável não usada unused variable seja encontrada.  Se a lista
     inteira for exaurida, índices adicionais são constrídos através da
     anexaao de inteiros ao valor de `niceindicespref[1]', e.g., `i0',
     `i1', `i2', ....

     `niceindices' retorna uma expressão.  `niceindices' avalia seu
     argumento.

     Exemplo:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1


 -- Variável de opção: niceindicespref
     Valor padrão: `[i, j, k, l, m, n]'

     `niceindicespref' é a lista da qual `niceindices' pega os nomes
     dos índices de adições e produtos products.

     Os elementos de `niceindicespref' são tipicamente nomes de
     variáveis, embora que não seja imposto por `niceindices'.

     Exemplo:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1


 -- Função: nusum (<expr>, <x>, <i_0>, <i_1>)
     Realiza o somatório hipergeométrico indefinido de <expr> com
     relação a <x> usando um procedimento de decisão devido a R.W.
     Gosper.  <expr> e o resultado deve ser expressável como produtos
     de expoentes inteiros, fatoriais, binomios, e funções recionais.

     Os termos "definido" and "e somatório indefinido" são usados
     analogamente a "definida" and "integração indefinida".  Adicionar
     indefinidamente significa dar um resultado simólico para a adição
     sobre intervalos de comprimentos de variáveis, não apenas e.g. 0 a
     infinito.  Dessa forma, uma vez que não existe fórmula para a
     adição parcial geral de séries binomiais, `nusum' não pode fazer
     isso.

     `nusum' e `unsum' conhecem um porco sobre adições e subtrações de
     produtos finitos.  Veja também `unsum'.

     Exemplos:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1


 -- Função: pade (<taylor_series>, <numer_deg_bound>, <denom_deg_bound>)
     Retorna uma lista de todas as funções racionais que possuem a dada
     expansão da séries de Taylor onde a adição dos graus do numerador
     e do denominador é menor que ou igual ao nível de truncação das
     séries de potência, i.e.  são "melhores" aproximações, e que
     adicionalmente satisfazem o grau especificado associado.

     <taylor_series> é uma séries de Taylor de uma variável.
     <numer_deg_bound> e <denom_deg_bound> são inteiros positivos
     especificando o grau associado sobre o numerador e o denominador.

     <taylor_series> podem também ser séries de Laurent, e o grau
     associado pode ser `inf' que acarreta todas funções racionais cujo
     grau total for menor que ou igual ao comprimento das séries de
     potências a serem retornadas.  O grau total é definido como
     `<numer_deg_bound> + <denom_deg_bound>'.  O comprimento de séries
     de potência é definido como `"nível de trncação" + 1 - min(0,
     "ordem das séries")'.

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     Não existe função racional de grau 4 numerador/denominador, com
     essa expansão de série de potência.  Você obrigatoriamente em
     geral tem grau do numerador e grau do denominador adicionando para
     cima ao menor grau das séries de potência, com o objetivo de ter
     disponível coeficientes desconhecidos para resolver.

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]


 -- Variável de opção: powerdisp
     Valor padrão: `false'

     Quando `powerdisp' for `true', uma adição é mostrada com seus
     termos em ordem do crescimento do expoente.  Dessa forma um
     polinômio é mostrado como séries de potências truncadas, com o
     termo constante primeiro e o maior expoente por último.

     Por padão, termos de uma adição são mostrados em ordem do expoente
     decrescente.


 -- Função: powerseries (<expr>, <x>, <a>)
     Retorna a forma geral expansão de séries de potência para <expr>
     na variável <x> sobre o ponto <a> (o qual pode ser `inf' para
     infinito).

     Se `powerseries' incapaz de expandir <expr>, `taylor' pode dar os
     primeiros muitos termos de séries.

     Quando `verbose' for `true', `powerseries' mostra mensagens de
     progresso.

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2


 -- Variável de opção: psexpand
     Valor padrão: `false'

     Quando `psexpand' for `true', uma expressão função racional
     extendida é mostrada completamente expandida.  O comutador
     `ratexpand' tem o mesmo efeito.

     Quando `psexpand' for `false', uma expressão de várias variáveis é
     mostrada apenas como no pacote de função racional.

     Quando `psexpand' for  `multi', então termos com o mesmo grau
     total nas variáveis são agrupados juntos.


 -- Função: revert (<expr>, <x>)
 -- Função: revert2 (<expr>, <x>, <n>)
     Essas funções retornam a reversão de <expr>, uma série de Taylor
     sobre zero na variável <x>.  `revert' retorna um polinômio de grau
     igual ao maior expoente em <expr>.  `revert2' retorna um polinômio
     de grau <n>, o qual pode ser maior que, igual a, ou menor que o
     grau de <expr>.

     `load ("revert")' chama essas funções.

     Exemplos:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2


 -- Função: taylor (<expr>, <x>, <a>, <n>)
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- Função: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- Função: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
     `taylor (<expr>, <x>, <a>, <n>)' expande a expressão <expr> em uma
     série truncada de Taylor ou de Laurent na variável <x> em torno do
     ponto <a>, contendo termos até `(<x> - <a>)^<n>'.

     Se <expr> é da forma `<f>(<x>)/<g>(<x>)' e `<g>(<x>)' não possui
     de grau acima do grau <n> então `taylor' tenta expandir `<g>(<x>)'
     acima do gau `2 <n>'.  Se existe ainda termos não zero, `taylor'
     dobra o grau de expansão de `<g>(<x>)' contanto que o grau da
     expansão o grau da expansão seja menor que ou igual a `<n>
     2^taylordepth'.

     `taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)' retorna uma série
     de potência truncada de grau <n> em todas as variáveis <x_1>,
     <x_2>, ...  sobre o ponto `(<a>, <a>, ...)'.

     `taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)'  retorna uma série de potência truncada nas variáveis <x_1>,
     <x_2>, ...  sobre o ponto `(<a_1>, <a_2>, ...)', truncada em
     <n_1>, <n_2>, ....

     `taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])' retorna uma série de potência truncada nas variáveis
     <x_1>, <x_2>, ...  sobre o ponto `(<a_1>, <a_2>, ...)', truncada
     em <n_1>, <n_2>, ....

     `taylor (<expr>, [<x>, <a>, <n>, 'asymp])' retorna uma expansão de
     <expr> em expoentes negativos de `<x> - <a>'.  O termo de maior
     ordem é `(<x> - <a>)^<-n>'.

     Quando `maxtayorder' for `true', então durante maniplulação
     algébrica da séries de Taylor (truncada), `taylor' tenta reter
     tantos termos quantos forem conhecidos serem corretos.

     Quando `psexpand' for `true', uma expressão de função racional
     extendida é mostrada completamente expandida.  O comutador
     `ratexpand' tem o mesmo efeito.  Quando `psexpand' for `false',
     uma expressão de várias variáveis é mostrada apenas como no pacote
     de função racional.  Quando `psexpand' for  `multi', então os
     termos com o mesmo grau total nas variáveis são agrupados juntos.

     Veja também o comutador `taylor_logexpand' para controlar a
     expansão.

     Exemplos:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360


 -- Variável de opção: taylordepth
     Valor padrão: 3

     Se existem ainda termos não zero, `taylor' dobra o grau da
     expansão de `<g>(<x>)' contanto que o grau da expansão seja menor
     que ou igual a `<n> 2^taylordepth'.


 -- Função: taylorinfo (<expr>)
     Retorna information about the séries de Taylor <expr>.  O valor de
     retorno é uma lista de listas.  Cada lista compreende o nome de
     uma variável, o ponto de expansão, e o grau da expansão.

     `taylorinfo' retorna `false' se <expr> não for uma séries de
     Taylor.

     Exemplo:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]


 -- Função: taylorp (<expr>)
     Retorna `true' se <expr> for uma séries de Taylor, e `false' de
     outra forma.


 -- Variável de opção: taylor_logexpand
     Valor padrão: `true'

     `taylor_logexpand' controla expansão de logarítmos em séries de
     `taylor'.

     Quando `taylor_logexpand' for `true', todos  logarítmos são
     expandidos completamente dessa forma problemas de reconhecimento
     de zero envolvendo envolvendo identidades logarítmicas não
     atrapalham o processo de expansão.  Todavia, esse esquema não é
     sempre maematicamente correto uma vez que isso ignora
     informações de ramo.

     Quando `taylor_logexpand' for escolhida para `false', então a
     expansão logarítmica que ocorre é somente aquela que for
     necessária para obter uma séries de potência formal.


 -- Variável de opção: taylor_order_coefficients
     Valor padrão: `true'

     `taylor_order_coefficients' controla a ordenação dos coeficientes
     em uma série de Taylor.

     Quando `taylor_order_coefficients' for `true', coeficientes da
     séries de Taylor são ordenados canonicamente.


 -- Função: taylor_simplifier (<expr>)
     Simplifica coeficientes da séries  de potência <expr>.  `taylor'
     chama essa função.


 -- Variável de opção: taylor_truncate_polynomials
     Valor padrão: `true'

     Quando `taylor_truncate_polynomials' for `true', polinômios são
     truncados baseados sobre a entrada de níveis de truncação.

     De outra forma, entrada de polinômios para `taylor' são
     consideradas terem precisão infinita.


 -- Função: taytorat (<expr>)
     Converte <expr> da forma `taylor' para a forma de expressão
     racional canônica (CRE).  O efeito é o mesmo que `rat (ratdisrep
     (<expr>))', mas mais rápido.


 -- Função: trunc (<expr>)
     Coloca notas na representação interna da expressão geral <expr> de
     modo que isso é mostrado como se suas adições forem séries de
     Taylor truncadas.  <expr> is not otherwise modified.

     Exemplo:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true


 -- Função: unsum (<f>, <n>)
     Retorna a primeira diferençã de trás para frente `<f>(<n>) -
     <f>(<n> - 1)'.  Dessa forma `unsum' logicamente é a inversa de
     `sum'.

     Veja também `nusum'.

     Exemplos:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)


 -- Variável de opção: verbose
     Valor padrão: `false'

     Quando `verbose' for `true', `powerseries' mostra mensagens de
     progresso.



File: maxima.info,  Node: Teoria dos Números,  Next: Symmetries,  Prev: Séries,  Up: Top

33 Teoria dos Números
*********************

* Menu:

* Definições para Teoria dos Números::


File: maxima.info,  Node: Definições para Teoria dos Números,  Prev: Teoria dos Números,  Up: Teoria dos Números

33.1 Definições para Teoria dos Números
=======================================

 -- Função: bern (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     Números de Bernoulli iguais a zero são suprimidos se `zerobern'
     for `false'.

     Veja também `burn'.

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798


 -- Função: bernpoly (<x>, <n>)
     Retorna o <n>'ésimo polinômio de Bernoulli na variável <x>.


 -- Função: bfzeta (<s>, <n>)
     Retorna a função zeta de Riemann para o argumento <s>.  O valor de
     retorno é um grande inteiro em ponto flutuante (bfloat); <n> é o
     número de dígitos no valor de retorno.

     `load ("bffac")' chama essa função.


 -- Função: bfhzeta (<s>, <h>, <n>)
     Retorna a função zeta de Hurwitz para os argumentos <s> e <h>.  O
     valor de retorno é um grande inteiro em ponto flutuante (bfloat);
     <n> é o números de dígitos no valor de retorno.

     A função zeta de Hurwitz é definida como

          sum ((k+h)^-s, k, 0, inf)

     `load ("bffac")' chama essa função.


 -- Função: binomial (<x>, <y>)
     O coeficiente binomial `<x>!/(<y>! (<x> - <y>)!)'.  Se <x> e <y>
     forem inteiros, então o valor numérico do coeficiente binomial é
     calculado.  Se <y>, ou <x - y>, for um inteiro, o the coeficiente
     binomial é expresso como um polinômio.

     Exemplos:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)


 -- Função: burn (<n>)
     Retorna o <n>'ésimo número de Bernoulli para o inteiro <n>.
     `burn' pode ser mais eficitente que `bern' para valores grandes e
     isolados de <n> (talvez <n> maior que 105 ou algo parecido), como
     `bern' calcula todos os números de Bernoulli até o índice <n>
     antes de retornar.

     `burn' explora a observação que números de Bernoulli (racionais)
     podem ser aproximados através de zetas (transcendentes) com
     eficiência tolerável.

     `load ("bffac")' chama essa função.


 -- Função: cf (<expr>)
     Converte <expr> em uma fração contínua.  <expr> é uma expressão
     compreendendo frações contínuas e raízes quadradas de inteiros.
     Operandos na expressão podem ser combinados com operadores
     aritméticos.  Com excessão de frações contínuas e raízes quadradas,
     fatores na expressão devem ser números inteiros ou racionais.
     Maxima não conhece operações sobre frações contínuas fora de `cf'.

     `cf' avalia seus argumentos após associar `listarith' a `false'.
     `cf' retorna uma fração contínua, representada como uma lista.

     Uma fração contínua `a + 1/(b + 1/(c + ...))' é representada
     através da lista `[a, b, c, ...]'.  Os elementos da lista `a',
     `b', `c', ... devem avaliar para inteiros.  <expr> pode também
     conter `sqrt (n)' onde `n' é um inteiro.  Nesse caso `cf'
     fornecerá tantos termos de fração contínua quantos forem o valor
     da variável `cflength' vezes o período.

     Uma fração contínua pode ser avaliada para um número através de
     avaliação da representação aritmética retornada por `cfdisrep'.
     Veja também `cfexpand' para outro caminho para avaliar uma fração
     contínua.

     Veja também `cfdisrep', `cfexpand', e `cflength'.

     Exemplos:

        * <expr> é uma expressão compreendendo frações contínuas e
          raízes quadradas de inteiros.

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        * `cflength' controla quantos períodos de fração contínua são
          computados para números algébricos, números irracionais.

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        * Um fração contínua pode ser avaliado através da avaliação da
          representação aritmética retornada por `cfdisrep'.

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        * Maxima não conhece operações sobre frações contínuas fora de
          `cf'.

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]


 -- Função: cfdisrep (<list>)
     Constrói e retorna uma expressão aritmética comum da forma `a +
     1/(b + 1/(c + ...))' a partir da representação lista de uma fração
     contínua `[a, b, c, ...]'.

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2


 -- Função: cfexpand (<x>)
     Retorna uma matriz de numeradores e denominadores dos último
     (columa 1) e penúltimo (columa 2) convergentes da fração contínua
     <x>.

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993//33102 = 3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902


 -- Variável de opção: cflength
     Valor padrão: 1

     `cflength' controla o número de termos da fração contínua que a
     função `cf' fornecerá, como o valor de `cflength' vezes o período.
     Dessa forma o padrão é fornecer um período.

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]


 -- Função: divsum (<n>, <k>)
 -- Função: divsum (<n>)
     `divsum (<n>, <k>)' retorna a adição dos divisores de <n> elevados
     à <k>'ésima potência.

     `divsum (<n>)' retorna a adição dos divisores de <n>.

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210


 -- Função: euler (<n>)
     Retorna o <n>'ésimo número de Euler para o inteiro <n> não
     negativo.

     Para a constante de Euler-Mascheroni, veja `%gamma'.

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]


 -- Constante: %gamma
     A constante de Euler-Mascheroni, 0.5772156649015329 ....


 -- Função: factorial (<x>)
     Representa a função fatorial. Maxima trata `factorial (<x>)' da
     mesma forma que `<x>!'.  Veja `!'.


 -- Função: fib (<n>)
     Retorna o <n>'ésimo número de Fibonacci.  `fib(0)' igual a 0 e
     `fib(1)' igual a 1, e `fib (-<n>)' igual a `(-1)^(<n> + 1) *
     fib(<n>)'.

     Após chamar `fib', `prevfib' é iguala `fib (<x> - 1)', o número de
     Fibonacci anterior ao último calculado.

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


 -- Função: fibtophi (<expr>)
     Expressa números de Fibonacci em termos da constante `%phi', que é
     `(1 + sqrt(5))/2', aproximadamente 1.61803399.

     Por padrão, Maxima não conhece `%phi'.  Após executar `tellrat
     (%phi^2 - %phi - 1)' e `algebraic: true', `ratsimp' pode
     simplificar algumas expressões contendo `%phi'.

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) ratsimp (fibtophi (%));
          (%o3)                           0


 -- Função: inrt (<x>, <n>)
     Retorna a parte inteira da <n>'ésima raíz do valor absoluto de <x>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]


 -- Função: jacobi (<p>, <q>)
     Retorna símbolo de Jacobi de <p> e <q>.

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]


 -- Função: lcm (<expr_1>, ..., <expr_n>)
     Retorna o menor múltiplo comum entre seus argumentos.  Os
     argumentos podem ser expressões gerais também inteiras.

     `load ("functs")' chama essa função.


 -- Função: minfactorial (<expr>)
     Examina <expr> procurando por ocorrências de dois fatoriais que
     diferem por um inteiro.  `minfactorial' então converte um em um
     polinômio vezes o outro.

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)


 -- Função: partfrac (<expr>, <var>)
     Expande a expressão <expr> em frações parciais com relação à
     variável principal <var>.  `partfrac' faz uma decomposição
     completa de fração parcial.  O algorítmo utilizado é baseado no
     fato que os denominadores de uma expansão de fração parcial (os
     fatores do denominador original) são relativamente primos.  Os
     numeradores podem ser escritos como combinação linear dos
     denominadores, e a expansão acontece.

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)


 -- Função: primep (<n>)
     Retorna `true' se `n' for um primo, `false' se não.


 -- Função: qunit (<n>)
     Retorna a principal unidade do campo dos números quadráticos reais
     `sqrt (<n>)' onde <n> é um inteiro, i.e., o elemento cuja norma é
     unidade.  Isso é importante para resolver a equação de Pell `a^2 -
     <n> b^2 = 1'.

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1


 -- Função: totient (<n>)
     Retorna o número de inteiros menores que ou iguais a <n> que são
     relativamente primos com <n>.


 -- Variável de opção: zerobern
     Valor padrão: `true'

     Quando `zerobern' for `false', `bern' exclui os números de
     Bernoulli que forem iguais a zero.  Veja `bern'.


 -- Função: zeta (<n>)
     Retorna a função zeta de Riemann se <x> for um inteiro negativo,
     0, 1, ou número par positivo, e retorna uma forma substantiva
     `zeta (<n>)' para todos os outros argumentos, incluindo não
     inteiros racionais, ponto flutuante, e argumentos complexos.

     Veja também `bfzeta' e `zeta%pi'.

          (%i1) map (zeta, [-4, -3, -2, -1, 0, 1, 2, 3, 4, 5]);
                                               2              4
                     1        1     1       %pi            %pi
          (%o1) [0, ---, 0, - --, - -, inf, ----, zeta(3), ----, zeta(5)]
                    120       12    2        6              90


 -- Variável de opção: zeta%pi
     Valor padrão: `true'

     Quando `zeta%pi' for `true', `zeta' retorna uma expressão
     proporcional a `%pi^n' para inteiro par `n'.  De outra forma,
     `zeta' retorna uma forma substantiva `zeta (n)' para inteiro par
     `n'.

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)



File: maxima.info,  Node: Symmetries,  Next: Grupos,  Prev: Teoria dos Números,  Up: Top

34 Symmetries
*************

* Menu:

* Definitions for Symmetries::


File: maxima.info,  Node: Definitions for Symmetries,  Prev: Symmetries,  Up: Symmetries

34.1 Definitions for Symmetries
===============================

THIS SECTION NEEDS TO BE TRANSLATED.


File: maxima.info,  Node: Grupos,  Next: Tempo de Execução,  Prev: Symmetries,  Up: Top

35 Grupos
*********

* Menu:

* Definições para Grupos::


File: maxima.info,  Node: Definições para Grupos,  Prev: Grupos,  Up: Grupos

35.1 Definições para Grupos
===========================

 -- Função: todd_coxeter (<relação>, <subgroupo>)
 -- Função: todd_coxeter (<relação>)
     Acha a ordem de G/H onde G é o módulo do Grupo Livre <relação>, e
     H é o subgroupo de G gerado por <subgroupo>.  <subgroupo> é um
     argumento opcional, cujo valor padrão é [].  Em fazendo isso a
     função produz uma tabela de multiplicação à direita de G sobre
     G/H, onde os co-conjuntos são enumerados [H,Hg2,Hg3,...].  Isso
     pode ser visto internamente no `$todd_coxeter_state'.

     As tabelas de multiplicação para as variáveis estão em
     `table:todd_coxeter_state[2]'.  Então `table[i]' fornece a tabela
     para a i'ésima variável.  `multiplos_co_conjuntos(co_conjunto,i)
     := table[varnum][co_conjunto];'

     Exemplo:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20
          (%i7) table:todd_coxeter_state[2]$
          (%i8) table[1];
          (%o8) {Array: (SIGNED-BYTE 30) #(0 2 1 3 7 6 5 4 8 11 17 9 12 14 #

          13 20 16 10 18 19 15 0 0 0 0 0 0 0 0 0 0 0 0

            0 0 0)}

     Observe que somente os elementos de 1 a 20 desse array `%o8' são
     significativos.  `table[1][4] = 7' indica coset4.var1 = coset7



File: maxima.info,  Node: Tempo de Execução,  Next: Opções Diversas,  Prev: Grupos,  Up: Top

36 Tempo de Execução
********************

* Menu:

* Introdução a Tempo de Execução::
* Interrupções::
* Definições para Tempo de Execução::


File: maxima.info,  Node: Introdução a Tempo de Execução,  Next: Interrupções,  Prev: Tempo de Execução,  Up: Tempo de Execução

36.1 Introdução a Tempo de Execução
===================================

`maxima-init.mac' é um arquivo que é chamado automaticamente quando o
Maxima inicia.  Você pode usar `maxima-init.mac' para personalizar seu
ambiente Maxima.  `maxima-init.mac', se existir, é tipicamente colocado
no diretório chamado por `:lisp (default-userdir)', embora possa estar
em qualquer outro diretório procurado pela função `file_search'.

   Aqui está um exemplo do arquivo `maxima-init.mac':

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   Nesse Exemplo, `setup_autoload' diz ao Maxima para chamar o arquivo
especificado (`specfun.mac') se qualquer das funções (`ultraspherical',
`assoc_legendre_p') forem chamadas sem estarem definidas.  Dessa forma
você não precisa lembrar de chamar o arquivo antes das funções.

   A declaração `showtime: all' diz ao Maxima escolher a variável
`showtime'.  O arquivo `maxima-init.mac' pode conter qualquer outras
atribuições ou outras declarações do Maxima.


File: maxima.info,  Node: Interrupções,  Next: Definições para Tempo de Execução,  Prev: Introdução a Tempo de Execução,  Up: Tempo de Execução

36.2 Interrupções
=================

O usuário pode parar uma computação que consome muito tempo com o
caractere ^C (control-C).  A ação padrão é parar a computação e mostrar
outra linha de comando do usuário.  Nesse caso, não é possível
continuar a computação interrompida.

   Se a variável `*debugger-hook*' é escolhida para `nil', através do
comando

     :lisp (setq *debugger-hook* nil)

então na ocasião do recebimento do ^C, Maxima iniciará o depurador Lisp,
e o usuário pode usar o depurador para inspecionar o ambiente Lisp.  A
computação interrompida pode ser retomada através do comando `continue'
no depurador Lisp.  O método de retorno para ao Maxima partindo do
depurador Lisp (outro como executando a computação para
complementação) é diferente para cada versão do Lisp.

   Em sistemas Unix, o caratere ^Z (control-Z) faz com que Maxima pare
tudo e aguarde em segundo plano, e o controle é retornado para a linha
de comando do shell.  O comando `fg' faz com que o Maxima retorne ao
primeiro plano e continue a partir do ponto no qual foi interrompido.


File: maxima.info,  Node: Definições para Tempo de Execução,  Prev: Interrupções,  Up: Tempo de Execução

36.3 Definições para Tempo de Execução
======================================

 -- Declaração: feature
     Maxima compreende dois tipos distintos de recurso, recursos do
     sistema e recursos aplicados a expressões matemáticas.  Veja
     Também `status' para informações sobre recursos do sistema.  Veja
     Também `features' e `featurep' para informações sobre recursos
     matemáticos.

     `feature' por si mesmo não é o nome de uma função ou variável.


 -- Função: featurep (<a>, <f>)
     Tenta determinar se o objeto <a> tem o recurso <f> na base dos
     fatos dentro base de dados corrente.  Se possue, é retornado
     `true', de outra forma é retornado `false'.

     Note que `featurep' retorna `false' quando nem <f> nem a negação
     de <f> puderem ser estabelecidas.

     `featurep' avalia seus argumentos.

     Veja também `declare' e `features'.

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true


 -- Função: room ()
 -- Função: room (true)
 -- Função: room (false)
     Mostra uma descrição do estado de armazenamento e gerenciamento de
     pilha no Maxima. `room' chama a função Lisp de mesmo nome.

        * `room ()' mostra uma descrição moderada.

        * `room (true)' mostra uma descrição detalhada.

        * `room (false)' mostra uma descrição resumida.


 -- Função: status (feature)
 -- Função: status (feature, <recurso_ativo>)
 -- Função: status (status)
     Retorna informações sobre a presença ou ausência de certos
     recursos dependentes do sistema operacional.

        * `status (feature)' retorna uma lista dos recursos do sistema.
          Inclui a versão do Lisp, tipo de sistema operacional, etc.  A
          lista pode variar de um tipo de Lisp para outro.

        * `status (feature, <recurso_ativo>)' retorna `true' se
          <recurso_ativo> está na lista de ítens retornada através de
          `status (feature)' e `false' de outra forma.  `status' não
          avalia o argumento <recurso_ativo>.  O operador aspas
          simples, `''', evita a avaliação.  Um recurso cujo nome
          contém um caractere especial, tal como um hífem, deve ser
          fornecido como um argumento em forma de seqüência de
          caracteres. Por Exemplo, `status (feature, "ansi-cl")'.

        * `status (status)' retorna uma lista de dois elementos
          `[feature, status]'.  `feature' e `status' são dois
          argumentos aceitos pela função `status'; Não está claro se
          essa lista tem significância adicional.

     A variável `features' contém uma lista de recursos que se aplicam a
     expressões matemáticas. Veja `features' e `featurep' para maiores
     informações.


 -- Função: time (%o1, %o2, %o3, ...)
     Retorna uma lista de tempos, em segundos, usados para calcular as
     linhas de saída `%o1', `%o2', `%o3', .... O tempo retornado é uma
     estimativa do Maxima do tempo interno de computação, não do tempo
     decorrido. `time' pode somente ser aplicado a variáveis(rótulos)
     de saída de linha; para quaisquer outras variáveis, `time' retorna
     `unknown' (tempo desconhecido).

     Escolha `showtime: true' para fazer com que Maxima moste o tempo
     de computação e o tempo decorrido a cada linha de saída.


 -- Função: timedate ()
     Retorna uma seqüência de caracteres representando a data e hora
     atuais.  A seqüência de caracteres tem o formato `HH:MM:SS Dia,
     mm/dd/aaaa (GMT-n)', Onde os campos são horas, minutos, segundos,
     dia da semana, mês, dia do mês, ano, e horas que diferem da hora
     GMT.

     O valor de retorno é uma seqüência de caracteres Lisp.

     Exemplo:

          (%i1) d: timedate ();
          (%o1) 08:05:09 Wed, 11/02/2005 (GMT-7)
          (%i2) print ("timedate mostra o tempo atual", d)$
          timedate reports current time 08:05:09 Wed, 11/02/2005 (GMT-7)



File: maxima.info,  Node: Opções Diversas,  Next: Regras e Modelos,  Prev: Tempo de Execução,  Up: Top

37 Opções Diversas
******************

* Menu:

* Introdução a Opções Diversas::
* Compartilhado::
* Definições para Opções Diversas::


File: maxima.info,  Node: Introdução a Opções Diversas,  Next: Compartilhado,  Prev: Opções Diversas,  Up: Opções Diversas

37.1 Introdução a Opções Diversas
=================================

Nessa seção várias opções são tratadas pelo fato de possuirem um efeito
global sobre a operação do Maxima.   Também várias listas tais como a
lista de todas as funções definidas pelo usuário, são discutidas.


File: maxima.info,  Node: Compartilhado,  Next: Definições para Opções Diversas,  Prev: Introdução a Opções Diversas,  Up: Opções Diversas

37.2 Compartilhado
==================

O diretório "share" do Maxima contém programas e outros arquivos de
interesse para os usuários do Maxima, mas que não são parte da
implementação do núcleo do Maxima.  Esses programas são tipicamente
chamados via `load' ou `setup_autoload'.

   `:lisp *maxima-sharedir*' mostra a localização do diretório
compartilhado dentro do sistema de arquivos do usuário.

   `printfile ("share.usg")' imprime uma lista de pacotes
desatualizados dos pacotes compartilhados.  Usuários podem encontrar
isso de forma mais detalhada navegando no diretório compartilhado
usando um navegador de sistema de arquivo.


File: maxima.info,  Node: Definições para Opções Diversas,  Prev: Compartilhado,  Up: Opções Diversas

37.3 Definições para Opções Diversas
====================================

 -- Variável de sistema: aliases
     Valor padrão: `[]'

     `aliases' é a lista de átomos que possuem um alias definido pelo
     usuário (escolhido através das funções `alias', `ordergreat',
     `orderless' ou através da declaração do átomo como sendo um `noun'
     (substantivo) com `declare').

 -- Declaração: alphabetic
     `declare (<char>, alphabetic)' adiciona `char' (caracteres) ao
     alfabeto do Maxima, que inicialmente contém as letras de `A' até
     `Z', de `a' até `z', `%' e `_'.  <char> é especificado como uma
     seqüência de caracteres de comprimento 1, e.g., `"~"'.

          (%i1) declare ("~", alphabetic);
          (%o1)                         done
          (%i2) foo~bar;
          (%o2)                        foo~bar
          (%i3) atom (foo~bar);
          (%o3)                         true


 -- Função: apropos (<string>)
     Procura por nomes Maxima que possuem <string> aparecendo em
     qualquer lugar dentro de seu nome.  Dessa forma, `apropos (exp)'
     retorna uma lista de todos os sinalizadores e funções que possuem
     `exp' como parte de seus nomes, tais como `expand', `exp', e
     `exponentialize'.  Dessa forma você pode somente lembra parte do
     nome de alguma coisa você pode usar esse comando para achar o
     restante do nome.  Similarmente, você pode dizer `apropos (tr_)'
     para achar uma lista de muitos dos comutadores relatando para o
     tradutor, muitos dos quais começam com `tr_'.


 -- Função: args (<expr>)
     Retorna a lista de argumentos de `expr', que pode ser de qualquer
     tipo de expressão outra como um átomo.  Somente os argumentos do
     operador de nível mais alto são extraídos; subexpressões de `expr'
     aparecem como elementos ou subexpressões de elementos da lista de
     argumentos.

     A ordem dos ítens na lista pode depender do sinalizador global
     `inflag'.

     `args (<expr>)' é equivalente a `substpart ("[", <expr>, 0)'.
     Veja também `substpart'.

     Veja também `op'.


 -- Variável de opção: genindex
     Valor padrão: `i'

     `genindex' é o prefixo usado para gerar a próxima variável do
     somatório quando necessário.


 -- Variável de opção: gensumnum
     Valor padrão: 0

     `gensumnum' é o sufixo numérico usado para gerar variável seguinte
     do somatório.  Se isso for escolhido para `false' então o índice
     consistirá somente de `genindex' com um sufixo numérico.


 -- Constante: inf
     Infinito positivo real.


 -- Constante: infinity
     Infinito complexo, uma magnitude infinita de ângulo de fase
     arbitrária.  Veja também `inf' e `minf'.


 -- Variável de sistema: infolists
     Valor padrão: `[]'

     `infolists' é uma lista dos nomes de todas as listas de informação
     no Maxima. São elas:

    `labels'
          Todos associam `%i', `%o', e rótulos `%t'.

    `values'
          Todos associam átomos que são variáveis de usuário, não
          opções do Maxima ou comutadores, criados através de `:' ou
          `::' ou associando funcionalmente.

    `functions'
          Todas as funções definidas pelo usuário, criadas através de
          `:=' ou `define'.

    `arrays'
          Todos os arrays declarados e não declarados, criados através
          de `:', `::', ou `:='.

    `macros'
          Todas as macros definidas pelo usuário.

    `myoptions'
          Todas as opções alguma vez alteradas pelo usuário (mesmo que
          tenham ou não elas tenham mais tarde retornadas para seus
          valores padrão).

    `rules'
          Todos os modelos definidos pelo usuário que coincidirem e
          regras de simplificação, criadas através de `tellsimp',
          `tellsimpafter', `defmatch', ou `defrule'.

    `aliases'
          Todos os átomos que possuem um alias definido pelo usuário,
          criado através das funções `alias', `ordergreat', `orderless'
          ou declarando os átomos como um `noun' com `declare'.

    `dependencies'
          Todos os átomos que possuem dependências funcionais, criadas
          através das funções `depends' ou `gradef'.

    `gradefs'
          Todas as funções que possuem derivadas definidas pelo
          usuário, cridas através da função `gradef'.

    `props'
          Todos os átomos que possuem quaisquer propriedades outras que
          não essas mencionadas acima, tais como propriedades
          estabelecidas por `atvalue' , `matchdeclare', etc., também
          propriedades estabelecidas na função `declare'.

    `let_rule_packages'
          Todos os pacote de régras em uso definidos pelo usuário mais
          o pacote especial `default_let_rule_package'.
          (`default_let_rule_package' é o nome do pacote de régras
          usado quando um não está explicitamente escolhido pelo
          usuário.)



 -- Função: integerp (<expr>)
     Retorna `true' se <expr> é um inteiro numérico literal, de outra
     forma retorna `false'.

     `integerp' retorna falso se seu argumento for um símbolo, mesmo se
     o argumento for declarado inteiro.

     Exemplos:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false


 -- Variável de opção: m1pbranch
     Valor padrão: `false'

     `m1pbranch' é principal descendente de `-1' a um expoente.
     Quantidades tais como `(-1)^(1/3)' (isto é, um expoente racional
     "ímpar") e `(-1)^(1/4)' (isto é, um expoente racional "par") são
     manuseados como segue:

                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2


 -- Função: numberp (<expr>)
     Retorna `true' se <expr> for um inteiro literal, número racional,
     número em ponto flutuante, ou um grande número em ponto flutuante,
     de outra forma retorna `false'.

     `numberp' retorna falso se seu argumento for um símbolo, mesmo se
     o argumento for um número simbólico tal como `%pi' ou `%i', ou
     declarado ser par, ímpar, inteiro, racional, irracional, real,
     imaginário, ou complexo.

     Exemplos:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]


 -- Função: properties (<a>)
     Retorna uma lista de nomes de todas as propriedades associadas com
     o átomo <a>.


 -- Símbolo especial: props
     `props' são átomos que possuem qualquer propriedade outra como
     essas explicitamente mencionadas em `infolists', tais como
     atvalues, matchdeclares, etc., também propriedades especificadas
     na função  `declare'.


 -- Função: propvars (<prop>)
     Retorna uma lista desses átomos sobre a lista `props' que possui a
     propriedade indicada através de <prop>.  Dessa forma `propvars
     (atvalue)' retorna uma lista de átomos que possuem atvalues.


 -- Função: put (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  <indicador> pode ser o nome de qualquer
     propriedade, não apenas uma propriedade definida pelo sistema.

     `put' avalia seus argumentos.  `put' retorna <valor>.

     Exemplos:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello


 -- Função: qput (<átomo>, <valor>, <indicador>)
     Atribui <valor> para a propriedade (especificada através de
     <indicador>) do <átomo>.  Isso é o mesmo que `put', exceto que os
     argumentos nã são avaliados.

     Exemplo:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar


 -- Função: rem (<átomo>, <indicador>)
     Remove a propriedade indicada através de <indicador> do <átomo>.


 -- Função: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- Função: remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)
 -- Função: remove ("<a>", operator)
 -- Função: remove (<a>, transfun)
 -- Função: remove (all, <p>)
     Remove propriedades associadas a átomos.

     `remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)' remove a propriedade
     `p_k' do átomo `a_k'.

     `remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)' remove as
     propriedades `<p_1>, ..., <p_n>' dos átomos <a_1>, ..., <a_m>.
     Pode existir mais que um par de listas.

     `remove (all, <p>)' remove a propriedade <p> de todos os átomos
     que a possuem.

     A propriedade removida pode ser definida pelo sistema tal como
     `function', `macro' ou `mode_declare', ou propriedades definidas
     pelo usuário.

     uma propriedade pode ser `transfun' para remover a versão
     traduzida Lisp de uma função.  Após executar isso, a versão Maxima
     da função é executada em lugar da versão traduzida.

     `remove ("<a>", operator)' ou, equivalentemente, `remove ("<a>",
     op)' remove de <a> as propriedades `operator' declaradas através de
     `prefix', `infix', `nary', `postfix', `matchfix', ou `nofix'.
     Note que o nome do operador deve ser escrito como uma seqüência de
     caracteres com apóstofo.

     `remove' sempre retorna `done' se um átomo possui ou não uma
     propriedade especificada.  Esse comportamento é diferente das
     funções remove mais específicas `remvalue', `remarray',
     `remfunction', e `remrule'.


 -- Função: remvalue (<nome_1>, ..., <nome_n>)
 -- Função: remvalue (all)
     Remove os valores de Variáveis de usuário <nome_1>, ..., <nome_n>
     (que podem ser subscritas) do sistema.

     `remvalue (all)' remove os valores de todas as variáveis em
     `values', a lista de todas as variáveis nomeadas através do usuário
     (em oposição a essas que são automaticamente atribuídas através do
     Maxima).

     Veja também `values'.


 -- Função: rncombine (<expr>)
     Transforma <expr> combinando todos os termos de <expr> que possuem
     denominadores idênticos ou denominadores que diferem de cada um
     dos outros apenas por fatores numéricos somente.  Isso é
     ligeiramente diferente do comportamento de de `combine', que
     coleta termos que possuem denominadores idênticos.

     Escolhendo `pfeformat: true' e usando `combine' retorna resultados
     similares a esses que podem ser obtidos com `rncombine', mas
     `rncombine' pega o passo adicional de multiplicar cruzado fatores
     numérios do denominador.  Esses resultados em forma ideal, e a
     possibilidade de reconhecer alguns cancelamentos.


 -- Função: scalarp (<expr>)
     Retorna `true' se <expr> for um número, constante, ou variável
     declarada `scalar' com `declare', ou composta inteiramente de
     números, constantes, e tais Variáveis, bmas não contendo matrizes
     ou listas.


 -- Função: setup_autoload (<nomedearquivo>, <função_1>, ...,
          <função_n>)
     Especifica que se qualquer entre <função_1>, ..., <função_n> for
     referenciado e não ainda definido, <nomedeqrquivo> é chamado via
     `load'.  <nomedearquivo> usualmente contém definições para as
     funções especificadas, embora isso não seja obrigatório.

     `setup_autoload' não trabalha para funções array.

     `setup_autoload' não avalia seus argumentos.

     Exemplo:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma função ultraspherical
          Warning - you are redefining the Macsyma função legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2



File: maxima.info,  Node: Regras e Modelos,  Next: Listas,  Prev: Opções Diversas,  Up: Top

38 Regras e Modelos
*******************

* Menu:

* Introdução a Regras e Modelos::
* Definições para Regras e Modelos::


File: maxima.info,  Node: Introdução a Regras e Modelos,  Next: Definições para Regras e Modelos,  Prev: Regras e Modelos,  Up: Regras e Modelos

38.1 Introdução a Regras e Modelos
==================================

Essa seção descreve coincidências de modelos definidos pelo usuário e
regras de simplificação.  Existem dois grupos de funções que
implementam até certo ponto diferentes esquemas de coincidência de
modelo.  Em um grupo estão `tellsimp', `tellsimpafter', `defmatch',
`defrule', `apply1', `applyb1', e `apply2'.  Em outro grupo estão `let'
e `letsimp'.  Ambos os esquemas definem modelos em termos de variáveis
de modelo declaradas por `matchdeclare'.

   Regras de coincidência de modelos definidas por `tellsimp' e
`tellsimpafter' são aplicadas automaticamente através do simplificador
do Maxima.  Regras definidas através de `defmatch', `defrule', e `let'
são aplicadas através de uma chamada explícita de função.

   Existe mecanismos adicionais para regras aplicadas a polinômios
através de `tellrat', e para álgebra comutativa e não comutativa no
pacote `affine'.



Local Variables:
coding: iso-8859-1
End:
