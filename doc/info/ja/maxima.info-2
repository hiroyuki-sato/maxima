This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Simplification,  Next: Mathematical Functions,  Prev: Evaluation,  Up: Top

9 Simplification
****************

* Menu:

* Functions and Variables for Simplification::  


File: maxima.info,  Node: Functions and Variables for Simplification,  Prev: Simplification,  Up: Simplification

9.1 Functions and Variables for Simplification
==============================================

 -- キーワード: additive

     もし‘declare(f, additive)’が実行されると:

     (1) もし‘f’が1変数関数なら、‘f’が和に適用された時はいつでも、 ‘f’は
     和の上に分配整理されます。 例えば、‘f(y+x)’は、‘f(y)+f(x)’に整理さ
     れます。

     (2) もし‘f’が2変数以上の関数なら、 ‘sum’や‘integrate’の場合と同様に
     加法性が第一番目の引数に対して定義されます。 例えば、
     ‘f(h(x)+g(x),x)’は‘f(h(x),x)+f(g(x),x)’に整理されます。 ‘f’が
     ‘sum(x[i],i,lower-limit,upper-limit)’の形の式に適用されたときには こ
     の整理はされません。

 -- 宣言: antisymmetric
     もし‘declare(h,antisymmetric)’が実行されると、 ‘h’は反対称として整
     理されます。 例えば、‘h(x,z,y)’は‘-h(x,y,z)’と整理されます。 即ち、
     ‘symmetric’か‘commutative’で得られた結果に(-1)^nを掛けたものとなり
     ます。 ここで、nはその形に変換するのに必要な置換の回数です。

 -- 関数: combine (<expr>)
     同じ分母を持つ項を単一の項に結合することによって和<expr>を整理しま
     す。

 -- 宣言: commutative

     もし‘declare(h,commutative)’が実行されたなら、 ‘h’は可換関数として
     整理されます。 例えば、‘h(x,z,y)’は‘h(x,y,z)’に整理されます。 これ
     は‘symmetric’と同じです。

 -- 関数: demoivre (<expr>)
 -- オプション変数: demoivre

     関数‘demoivre (expr)’は、 グローバル変数‘demoivre’を設定することな
     しに式を変換します。

     変数‘demoivre’が‘true’の時、 複素数の指数関数は、円関数の項で表した
     同値な式に変換されます: もし‘b’が‘%i’を含まなければ、 ‘exp (a +
     b*%i)’は、‘%e^a * (cos(b) + %i*sin(b))’に整理されます。 ‘a’と‘b’は
     展開されません。

     ‘demoivre’のデフォルト値は‘false’です。

     ‘exponentialize’は、円関数や双曲関数を指数関数形に変換します。
     ‘demoivre’と‘exponentialize’は、同時に両方trueにはできません。

 -- 関数: distrib (<expr>)

     和を積上に分配します。 式のトップレベルのみで働き、すなわち、再帰的
     でなく、 ‘expand’より速い点で、‘expand’とは違います。 トップレベル
     の和すべてを展開する点で、‘multthru’とは違います。

     例:

          (%i1) distrib ((a+b) * (c+d));
          (%o1)                 b d + a d + b c + a c
          (%i2) multthru ((a+b) * (c+d));
          (%o2)                 (b + a) d + (b + a) c
          (%i3) distrib (1/((a+b) * (c+d)));
                                          1
          (%o3)                    ---------------
                                   (b + a) (d + c)
          (%i4) expand (1/((a+b) * (c+d)), 1, 0);
                                          1
          (%o4)                 ---------------------
                                b d + a d + b c + a c

 -- オプション変数: distribute_over
     デフォルト値: ‘true’

     ‘distribute_over’は、 リストや行列や等式のようなバッグ(重複を許す集
     合)上の関数のマッピングを制御します。 今回、すべてのMaxima関数がこ
     のプロパティを持つ訳ではありません。 このプロパティはコマンド
     ‘properties’で調べることが可能です。

     ‘distribute_over’を値‘false’に設定した時、 関数のマッピングはオフに
     スイッチされます。

     例:

     ‘sin’関数はリスト上にマップします:

          (%i1) sin([x,1,1.0]);
          (%o1)                 [sin(x), sin(1), .8414709848078965]

     ‘mod’は リスト上にマップされる２変数関数です。 入れ子のリスト上のマ
     ッピングも可能です:

          (%i2) mod([x,11,2*a],10);
          (%o2)                    [mod(x, 10), 1, 2 mod(a, 5)]
          (%i3) mod([[x,y,z],11,2*a],10);
          (%o3)       [[mod(x, 10), mod(y, 10), mod(z, 10)], 1, 2 mod(a, 5)]

     ‘floor’関数の行列や等式上のマッピング:

          (%i4) floor(matrix([a,b],[c,d]));
                                      [ floor(a)  floor(b) ]
          (%o4)                       [                    ]
                                      [ floor(c)  floor(d) ]
          (%i5) floor(a=b);
          (%o5)                         floor(a) = floor(b)

     １変数以上の関数は、任意の引数上、または、すべての引数上にマップし
     ます:

          (%i6) expintegral_e([1,2],[x,y]);
          (%o6) [[expintegral_e(1, x), expintegral_e(1, y)],
                 [expintegral_e(2, x), expintegral_e(2, y)]]

     関数がプロパティdistribute_overを持つかチェックします:

          (%i7) properties(abs);
          (%o7) [integral, distributes over bags, noun, rule, gradef]

 -- オプション変数: domain
     デフォルト値: ‘real’

     ‘domain’が‘complex’に設定されている時、 ‘sqrt (x^2)’は、‘abs(x)’を
     返さず、‘sqrt (x^2)’ のままを保ちます。

 -- 宣言: evenfun
 -- 宣言: oddfun

     ‘declare(f, evenfun’や ‘declare(f, oddfun’は 関数 ‘f’を奇関数か偶関
     数として認識するように指示します。

     例:

          (%i1) o (- x) + o (x);
          (%o1)                     o(x) + o(- x)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- x) + o (x);
          (%o3)                           0
          (%i4) e (- x) - e (x);
          (%o4)                     e(- x) - e(x)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- x) - e (x);
          (%o6)                           0

 -- 関数: expand (<expr>)
 -- 関数: expand (<expr>, <p>, <n>)

     式<expr>を展開します。 指数和や和の積の積を実行し、有理式の分子をそ
     れぞれの項に分割し、 （可換、非可換な）積が<expr>のすべてのレベルの
     和で分配されます。

     多項式の場合、もっと効率的なアルゴリズムの‘ratexpand’を普通使うべき
     です。

     ‘maxnegex’と‘maxposex’はそれぞれ、展開される最大の負と正の指数を制
     御します。

     ‘expand (expr, p, n)’は、 <expr>を、‘maxposex’に<p>を‘maxnegex’に
     <n>を使って展開します。 これは、式のすべてではなく、一部を展開する
     ために役立ちます。

     ‘expon’ - 自動的に展開される最大の負のべきの指数（‘expand’のコール
     に独立して）。 例えば、もしも‘expon’が4なら‘(x+1)^(-5)’は自動では展
     開されません。

     ‘expop’ - 自動的に展開される最大の正の指数。 もし‘expop’が3以上なら
     、‘(x+1)^3’は自動的に展開されます。 もし‘n’が‘expop’よりも大きい時
     ‘(x+1)^n’が展開されるのが望まれるなら、 ‘maxposex’が‘n’より小さくな
     い場合のみ、‘expand ((x+1)^n)’の実行が行われます。

     ‘ev’で使われる‘expand’フラグによって展開が実行されます。

     ファイル‘share/simplification/facexp.mac’は、 ユーザーに制御された
     展開によって式を構成する機能を提供するいくつかの関連関数 （特に自動
     ロードされる‘facsum’, ‘factorfacsum’と‘collectterms’）と 変数
     (‘nextlayerfactor’と‘facsum_combine’)を含みます。 簡単な関数の記述
     が‘simplification/facexp.usg’にあります。 ‘demo("facexp")’でデモが
     実行できます。

     例:

          (%i1) expr:(x+1)^2*(y+1)^3;
                                         2        3
          (%o1)                   (x + 1)  (y + 1)
          (%i2) expand(expr);
                 2  3        3    3      2  2        2      2      2
          (%o2) x  y  + 2 x y  + y  + 3 x  y  + 6 x y  + 3 y  + 3 x  y
                                                                2
                                               + 6 x y + 3 y + x  + 2 x + 1
          (%i3) expand(expr,2);
                         2        3              3          3
          (%o3)         x  (y + 1)  + 2 x (y + 1)  + (y + 1)
          (%i4) expr:(x+1)^-2*(y+1)^3;
                                             3
                                      (y + 1)
          (%o4)                       --------
                                             2
                                      (x + 1)
          (%i5) expand(expr);
                      3               2
                     y             3 y            3 y             1
          (%o5) ------------ + ------------ + ------------ + ------------
                 2              2              2              2
                x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1   x  + 2 x + 1
          (%i6) expand(expr,2,2);
                                             3
                                      (y + 1)
          (%o6)                     ------------
                                     2
                                    x  + 2 x + 1

     展開なしに式を再整理します:

          (%i7) expr:(1+x)^2*sin(x);
                                                 2
          (%o7)                           (x + 1)  sin(x)
          (%i8) exponentialize:true;
          (%o8)                                true
          (%i9) expand(expr,0,0);
                                             2    %i x     - %i x
                                   %i (x + 1)  (%e     - %e      )
          (%o9)                  - -------------------------------
                                                  2

 -- 関数: expandwrt (<expr>, <x_1>, ..., <x_n>)

     式‘expr’を、変数<x_1>, ..., <x_n>に関して展開します。 変数を含む積
     すべては陽に現れます。 返される形式は、変数を含む式の和の積を含みま
     せん。 <x_1>, ..., <x_n>は、変数、演算子、式であり得ます。

     デフォルトでは、分母は展開されませんが、これは、スイッチ
     ‘expandwrt_denom’によって 制御することができます。

     この関数は‘simplification/stopex.mac’から自動ロードされます。

 -- オプション変数: expandwrt_denom
     デフォルト値: ‘false’

     ‘expandwrt_denom’は、‘expandwrt’によって有理式の扱いを制御します。
     もし‘true’なら、式の分子も分母も‘expandwrt’の引数に従って展開されま
     すが、 もし‘expandwrt_denom’が‘false’なら、分子だけがその方法で展開
     されます。

 -- 関数: expandwrt_factored (<expr>, <x_1>, ..., <x_n>)

     ‘expandwrt’に似ていますが、積の式を幾分違って扱います。
     ‘expandwrt_factored’は、‘expr’の、 変数<x_1>, ..., <x_n>を含む因子
     上でだけ展開します。

     この関数は、‘simplification/stopex.mac’から自動ロードされます。

 -- オプション変数: expon
     デフォルト値: 0

     ‘expon’は、(‘expand’のコールに依らず)自動的に展開される負のべき乗の
     最大指数です。 例えば、 もし‘expon’が4なら、 ‘(x+1)^(-5)’は自動的に
     は展開されません。

 -- 関数: exponentialize (<expr>)
 -- オプション変数: exponentialize

     関数‘exponentialize (expr)’は、 <expr>の中の円関数や双曲関数を指数
     関数に変換します。 グローバル変数‘exponentialize’を設定する必要はあ
     りません。

     変数‘exponentialize’が‘true’の時、 円関数や双曲関数すべては指数関数
     形に変換されます。 デフォルト値は‘false’です。

     ‘demoivre’は複素数の指数関数を円関数に変換します。
     ‘exponentialize’や‘demoivre’は同時にtrueにすることはできません。

 -- オプション変数: expop
     デフォルト値: 0

     ‘expop’は、自動的に展開される最高の正の指数です。 例えば、‘(x +
     1)^3’が入力された時、 ‘expop’が3以下の時だけ自動的に展開されます。
     もし、‘n’が‘expop’より大きい‘(x + 1)^n’が展開されることを望むなら、
     ‘expand ((x + 1)^n)’の実行は、 ‘maxposex’がn以上の時だけ機能します
     。

 -- 宣言: lassociative

     ‘declare (g, lassociative)’は、 Maximaの整理器に ‘g’が左結合である
     ことを告げます。 例えば、‘g (g (a, b), g (c, d))’は‘g (g (g (a, b),
     c), d)’に整理されます。

 -- 宣言: linear

     Maximaの演算子のプロパティの１つ。 そう宣言された1変数関数‘f’に関し
     て、 "expansion" ‘f(x + y)’は‘f(x) + f(y)’を出力し、 ‘a’が定数の
     ‘f(a*x)’は、‘a*f(x)’を出力します。 ２つ以上の引数の関数に関しては、
     「線形性」は、‘sum’や‘integrate’の場合のように定義されます。 すなわ
     ち、‘a’と‘b’が‘x’に独立の場合， ‘f (a*x + b, x)’は‘a*f(x,x) +
     b*f(1,x)’を出力します。

     ‘linear’は、‘additive’かつ‘outative’と同値です。 ‘opproperties’も参
     照してください。

 -- オプション変数: maxnegex
     デフォルト値: 1000

     ‘maxnegex’は、 ‘expand’コマンドによって展開される最大の負の指数です
     。 （‘maxposex’)も参照してください。）

 -- オプション変数: maxposex
     デフォルト値: 1000

     ‘maxposex’は、 ‘expand’コマンドで展開される最大指数です。 （
     ‘maxnegex’)も参照してください。）

 -- 宣言: multiplicative

     ‘declare (f, multiplicative)’は、Maxima整理器に ‘f’が乗法的であるこ
     とを告げます。

       1. もし‘f’が１変数関数なら、 整理器が積に適用された‘f’に出会うと
          いつでも、 ‘f’はその積上に分配されます。 例えば、‘f(x*y)’は
          ‘f(x)*f(y)’に整理されます。

       2. もし‘f’が多変数関数なら、 乗法性は、‘f’の最初の引数の乗法性と
          して定義されます。 例えば、 ‘f (g(x) * h(x), x)’は、‘f (g(x)
          ,x) * f (h(x), x)’に整理されます。

     この式整理は、‘f’が‘product (x[i], i, m, n)’の形の式に適用された時
     にはなされません。

 -- 関数: multthru (<expr>)
 -- 関数: multthru (<expr_1>, <expr_2>)

     <expr>の（和の）因子に<expr>の他の因子を掛ける。 すなわち、<expr>は
     ‘<f_1> <f_2> ... <f_n>’です。 ここで、少なくとも１つの因子、<f_i>と
     しましょう、は項の和です。 この和の各項に、積の中の他の因子を掛けま
     す。 （すなわち、<f_i>を除いた因子すべてです。） ‘multthru’は、指数
     化された和を展開しません。 この関数は、（可換であれ非可換であれ）積
     を和上に分配する最も速い方法です。 割り算は積として表現されるので、
     ‘multthru’は積によって和を割ることにも使うことができます。

     ‘multthru (<expr_1>, <expr_2>)’は、 （和もしくは等式の）<expr_2>の
     中の各項に<expr_1>を掛けます。 もし<expr_1>がそれ自身和でなければ、
     この形式は‘multthru (<expr_1>*<expr_2>)’と同値です。

          (%i1) x/(x-y)^2 - 1/(x-y) - f(x)/(x-y)^3;
                                1        x         f(x)
          (%o1)             - ----- + -------- - --------
                              x - y          2          3
                                      (x - y)    (x - y)
          (%i2) multthru ((x-y)^3, %);
                                     2
          (%o2)             - (x - y)  + x (x - y) - f(x)
          (%i3) ratexpand (%);
                                     2
          (%o3)                   - y  + x y - f(x)
          (%i4) ((a+b)^10*s^2 + 2*a*b*s + (a*b)^2)/(a*b*s^2);
                                  10  2              2  2
                           (b + a)   s  + 2 a b s + a  b
          (%o4)            ------------------------------
                                            2
                                       a b s
          (%i5) multthru (%);  /* note that this does not expand (b+a)^10 */
                                                  10
                                 2   a b   (b + a)
          (%o5)                  - + --- + ---------
                                 s    2       a b
                                     s
          (%i6) multthru (a.(b+c.(d+e)+f));
          (%o6)            a . f + a . c . (e + d) + a . b
          (%i7) expand (a.(b+c.(d+e)+f));
          (%o7)         a . f + a . c . e + a . c . d + a . b

 -- 宣言: nary

     ‘declare(f, nary)’はMaximaに 関数 ‘f’をn項関数として認識するよう指
     示します。

     ‘nary’宣言は ‘nary’関数をコールするのと同じではありません。
     ‘declare(f, nary)’は唯一の効果は 例えば、 ‘foo(x, foo(y, z))’を
     ‘foo(x, y, z)’に整理するように 入れ子の式をフラットにするよう
     Maxima整理器に指示することです。 ‘declare’.も参照してください。

     例:

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

 -- オプション変数: negdistrib
     デフォルト値: ‘true’

     ‘negdistrib’が‘true’の時, -1が式上に分配されます。 例えば、‘-(x +
     y)’は‘- y - x’になります。 ‘false’に設定すると、‘- (x + y)’はそのま
     ま表示されることになるでしょう。 これは時々役に立ちますが、非常に注
     意してください; ‘simp’フラグ同様に、 当然のことながら、Maximaの中で
     ローカルな使用以外には、 これは、‘false’に設定したくないフラグの１
     つです。

 -- システム変数: opproperties

     ‘opproperties’は、Maximaの整理器が認識する特殊演算子プロパティのリ
     ストです: ‘linear’, ‘additive’, ‘multiplicative’, ‘outative’,
     ‘evenfun’, ‘oddfun’, ‘commutative’, ‘symmetric’, ‘antisymmetric’,
     ‘nary’, ‘lassociative’, ‘rassociative’.

 -- 宣言: outative

     ‘declare (f, outative)’は、Maximaの整理器に ‘f’の引数の中の定数因子
     が外に出すことができることを告げます。

       1. もし‘f’が1変数関数なら、 整理器が積に適用された‘f’に出会うとい
          つでも、その積は定数因子と、ていすうでない因子に分割され、定数
          因子が外に出されます。 例えば、‘f(a*x)’は、‘a’を定数とすると、
          ‘a*f(x)’に整理されます。 非アトムな定数因子は外に出されません
          。
       2. もし‘f’が多変数関数なら、 outativityは、‘sum’や‘integrate’の場
          合のように定義されます。 すなわち、‘f (a*g(x), x)’は、‘a’が
          ‘x’に依らないとすると、 ‘a * f(g(x), x)’に整理されます。

     ‘sum’, ‘integrate’, ‘limit’はすべて‘outative’です。

 -- 関数: radcan (<expr>)

     対数関数、指数関数、累乗根を含む<expr>を、与えられ場変数の順序で式
     の大きなクラス上の標準形式に整理します; 関数的に同値な形式は特殊な
     形式にマップされます。 式の幾分大きなクラスのため、‘radcan’は正規の
     形式を生成します。 このクラスの２つの式は、必ずしも、同じ結果ではあ
     りませんが、それらの差は‘radcan’によって0に整理されます。

     いくつかの式のため、‘radcan’は特殊な時間消費をします。 これは、因数
     分解や指数関数の部分分解展開に基づいた整理のための式のコンポーネン
     トの間のある関係を探求するコストです。

     例:

          (%i1) radcan((log(x+x^2)-log(x))^a/log(1+x)^(a/2));
                                                     a/2
          (%o1)                            log(x + 1)

          (%i2) radcan((log(1+2*a^x+a^(2*x))/log(1+a^x)));
          (%o2)                                  2

          (%i3) radcan((%e^x-1)/(1+%e^(x/2)));
                                               x/2
          (%o3)                              %e    - 1

 -- オプション変数: radexpand
     デフォルト値: ‘true’

     ‘radexpand’は、根号のいくつかの整理を制御します。

     ‘radexpand’が‘all’の時 n乗の積の因子のn番目の根を根号の外に出すよう
     にします。 例えば、もし‘radexpand’が‘all’なら、 ‘sqrt (16*x^2)’は
     ‘4*x’に整理されます。

     特に、‘sqrt (x^2)’を考えます。
        • もし‘radexpand’が‘all’もしくは‘assume (x > 0)’が実行されたなら
          、 ‘sqrt(x^2)’は‘x’に整理されます。
        • もし‘radexpand’が‘true’、かつ‘domain’が‘real’(これはデフォルト
          です)なら、 ‘sqrt(x^2)’は‘abs(x)’に整理されます。
        • もし‘radexpand’が‘false’、もしくは、‘radexpand’が‘true’かつ
          ‘domain’が‘complex’なら、 ‘sqrt(x^2)’は整理されません。

     ‘domain’は、‘radexpand’が‘true’の時だけ意味を持つことに注意してくだ
     さい。

 -- 宣言: rassociative

     ‘declare (g, rassociative)’は、 Maximaの整理器に ‘g’が右結合である
     ことを告げます。 例えば、 ‘g(g(a, b), g(c, d))’は、‘g(a, g(b, g(c,
     d)))’に整理されます。

 -- 関数: scsimp (<expr>, <rule_1>, ..., <rule_n>)

     順次的な相対整理(Sequential Comparative Simplification) (Stouteによ
     る方法)。 ‘scsimp’は、 規則<rule_1>, ..., <rule_n>に従って、
     <expr>を整理しようとします。 もしより小さな式が得られたら、 プロセ
     スは繰り返されます。 そうでなければ、すべての整理が試された後、 元
     の答えを返します。

     ‘example (scsimp)’はいくつかの例を表示します。

 -- オプション変数: simp
     デフォルト値: ‘true’

     ‘simp’は整理を有効にします。 これは標準です。 ‘simp’は‘evflag’でも
     あります。 それは関数‘ev’に認識されます。‘ev’を参照してください。

     ‘simp’が 値‘false’で‘evflag’として使われる時、 式の評価フェイズの間
     だけ 整理は抑制されます。 フラグは評価フェイズに続く整理を抑制でき
     ません。

     例:

     整理がグローバルにオフにスイッチされます。 式‘sin(1.0)’は数値に整理
     されません。 ‘simp’-フラグは整理をオンにスイッチします。

          (%i1) simp:false;
          (%o1)                                false
          (%i2) sin(1.0);
          (%o2)                              sin(1.0)
          (%i3) sin(1.0),simp;
          (%o3)                          .8414709848078965

     整理が再びオンにスイッチされます。 ‘simp’-フラグは完全に整理を抑制
     できません。 割り当ては式の評価フェイズの間に起こるので、 出力は整
     理された式を示しますが、 変数‘x’は、値として未整理の式を持ちます。

          (%i4) simp:true;
          (%o4)                                true
          (%i5) x:sin(1.0),simp:false;
          (%o5)                          .8414709848078965
          (%i6) :lisp $X
          ((%SIN) 1.0)

 -- 宣言: symmetric

     ‘declare (h, symmetric)’は、Maximaの整理器に ‘h’が対称関数であるこ
     とを告げます。 例えば、‘h (x, z, y)’は‘h (x, y, z)’に整理されます。

     ‘commutative’は‘symmetric’と同義です。

 -- 関数: xthru (<expr>)

     （和でなければいけない）<expr>のすべての項を、 共通分母上で、
     ‘ratsimp’がするように積や指数和を展開することなしに結合させます。
     ‘xthru’は、因子が陽であるときだけ、有理式の分子と分母の共通因子を消
     去します。

     分子と分母の最大公約数の陽因子を消去するために、式を‘ratsimp’する前
     に‘xthru’を使うのがよい場合があります。

          (%i1) ((x+2)^20 - 2*y)/(x+y)^20 + (x+y)^(-19) - x/(x+y)^20;
                                          20
                           1       (x + 2)   - 2 y       x
          (%o1)        --------- + --------------- - ---------
                              19             20             20
                       (y + x)        (y + x)        (y + x)
          (%i2) xthru (%);
                                           20
                                    (x + 2)   - y
          (%o2)                     -------------
                                             20
                                      (y + x)


File: maxima.info,  Node: Mathematical Functions,  Next: Maximas Database,  Prev: Simplification,  Up: Top

10 Mathematical Functions
*************************

* Menu:

* Functions for Numbers::
* Functions for Complex Numbers::
* Combinatorial Functions::
* Root Exponential and Logarithmic Functions::
* Trigonometric Functions::
* Random Numbers::


File: maxima.info,  Node: Functions for Numbers,  Next: Functions for Complex Numbers,  Prev: Mathematical Functions,  Up: Mathematical Functions

10.1 Functions for Numbers
==========================

 -- 関数: abs (<expr>)

     <expr>の絶対値を返します。もし<expr>が複素数なら、<expr>の絶対値
     (modulus)を返します。

     ‘abs’はリスト上、行列上、等式上に分配されます。 ‘distribute_over’を
     参照してください。

 -- 関数: ceiling (<x>)

     <x>が実数の時、<x>以上の最小の整数を返します。

     もし<x>が定数式(例えば‘10 * %pi’)なら、 ‘ceiling’は、<x>を多倍長浮
     動小数点数を使って評価し、 その多倍長浮動小数点数に‘ceiling’を適用
     します。 ‘ceiling’は浮動小数点を使うので、ほとんど起こりえませんが
     、 ‘ceiling’は定数入力に対して間違った値を返す可能性があります。 こ
     のエラーを起こさないようにするには、‘fpprec’の３つの値を使って浮動
     小数点評価を行います。

     定数でない入力に関しては、‘ceiling’は整理された値を返そうとします。
     以下は、‘ceiling’が知っている式整理の例です:

          (%i1) ceiling (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) ceiling (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
          (%o4)                [n, abs(n), max(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) ceiling (x);
          (%o6)                           1
          (%i7) tex (ceiling (a));
          $$\left \lceil a \right \rceil$$
          (%o7)                         false

     関数‘ceiling’は、自動ではリストや行列上にマップしません。 最終的に
     、明らかに複雑な入力すべてに対して、‘ceiling’は名詞形を返します。

     もし関数の範囲が整数の部分集合なら、 ‘integervalued’に宣言できます
     。 ‘ceiling’、‘floor’関数両方とも、この情報を使います; 例えば:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- 関数: entier (<x>)
     <x>が数値の場合、<x>以下の最大の整数を返します。 （‘fixnum’における
     ）‘fix’はこれの別名で、 ‘fix(<x>)’は正確に同じです。

 -- 関数: floor (<x>)

     <x>が実数の時、<x>以下の最大の整数を返します。

     もし<x>が定数式(例えば‘10 * %pi’)なら、 ‘floor’は、多倍長浮動小数点
     数を使って<x>を評価し、 結果の多倍長浮動小数点に‘floor’を適用します
     。 ‘floor’は浮動小数点を使うので、ほとんど起こりえませんが、
     ‘floor’は定数入力に対して間違った値を返す可能性があります。 このエ
     ラーを起こさないようにするには、‘fpprec’の３つの値を使って浮動小数
     点評価を行います。

     定数でない入力に関しては、‘floor’は整理された値を返そうとします。 以
     下は、‘ceiling’が知っている式整理の例です:

          (%i1) floor (ceiling (x));
          (%o1)                      ceiling(x)
          (%i2) floor (floor (x));
          (%o2)                       floor(x)
          (%i3) declare (n, integer)$
          (%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
          (%o4)                [n, abs(n), min(n, 6)]
          (%i5) assume (x > 0, x < 1)$
          (%i6) floor (x);
          (%o6)                           0
          (%i7) tex (floor (a));
          $$\left \lfloor a \right \rfloor$$
          (%o7)                         false

     関数‘floor’は、自動ではリストや行列上にマップしません。 最終的に、
     明らかに複雑な入力すべてに対して、‘floor’は名詞形を返します。

     もし関数の範囲が整数の部分集合なら、 ‘integervalued’に宣言できます
     。 ‘ceiling’、‘floor’関数両方とも、この情報を使います; 例えば:

          (%i1) declare (f, integervalued)$
          (%i2) floor (f(x));
          (%o2)                         f(x)
          (%i3) ceiling (f(x) - 1);
          (%o3)                       f(x) - 1

 -- 関数: fix (<x>)
     ‘entier (<x>)’の別名です。

 -- 関数: lmax (<L>)

     <L>がリストもしくは集合の時、‘apply ('max, args (<L>))’を返します。
     <L>がリストでも集合でもない時、エラーを示します。

 -- 関数: lmin (<L>)

     <L>がリストもしくは集合の時、‘apply ('min, args (<L>))’を返します。
     <L>がリストでも集合でもない時、エラーを示します。

 -- 関数: max (<x_1>, ..., <x_n>)

     式<x_1>から<x_n>の中の最大値に関して整理された値を返します。 ‘get
     (trylevel, maxmin)’が２以上の時、 ‘max’は、式整理‘max (e, -e) -->
     |e|’を使います。 ‘get (trylevel, maxmin)’が３以上の時、 <max>は、２
     つの他の引数の間の式を消去しようとします; 例えば、‘max (x, 2*x,
     3*x) --> max (x, 3*x)’。 ‘trylevel’を2に設定するには、‘put
     (trylevel, 2, maxmin)’を使います。

 -- 関数: min (<x_1>, ..., <x_n>)

     式<x_1>から<x_n>の中の最小値に関して整理された値を返します。 ‘get
     (trylevel, maxmin)’が２以上の時、 ‘max’は、式整理‘max (e, -e) -->
     |e|’を使います。 ‘get (trylevel, maxmin)’が３以上の時、 <max>は、２
     つの他の引数の間の式を消去しようとします; 例えば、‘max (x, 2*x,
     3*x) --> max (x, 3*x)’。 ‘trylevel’を2に設定するには、‘put
     (trylevel, 2, maxmin)’を使います。

     ‘max’や ‘lmin’.も参照してください。

 -- 関数: round (<x>)

     <x>が実数の時、<x>に最も近い整数を返します。 1/2を掛けてroundして
     2を掛けると、最も近い偶数に丸められます。 <x>の評価は、‘floor’や
     ‘ceiling’に似ています。

 -- 関数: signum (<x>)
     実数か複素数<x>に対して、もし<x>が0ならsignum関数は0を返します; 非
     ゼロ数値入力<x>に対して、signum関数は‘abs(x)/x’を返します。

     非数値入力に対して、Maximaは入力の符号を決定しようと試みます。 符号
     が負、ゼロ、正いずれかの時、‘signum’はそれぞれ、-1, 0, 1を返します
     。 符号に関する他の値すべてに対して、‘signum’は式整理された同値形を
     返します。 式整理は(‘signum(-x)’は‘-signum(x)’を与える)反転と
     (‘signum(x*y)’は‘signum(x) * signum(y)’を与える)乗法恒等式を含みま
     す。

     ‘signum’関数はリスト、行列もしくは等式上に分配されます。
     ‘distribute_over’を参照してください。


File: maxima.info,  Node: Functions for Complex Numbers,  Next: Combinatorial Functions,  Prev: Functions for Numbers,  Up: Mathematical Functions

10.2 Functions for Complex Numbers
==================================

 -- 関数: cabs (<expr>)
     <expr>の複素数の絶対値を返します。

 -- 関数: carg (<z>)
     <z>の複素偏角を返します。 複素偏角は、 ‘r exp (theta %i) = <z>’（
     ‘r’は<z>の絶対値）を満たす ‘(-%pi, %pi]’の間の角‘theta’です。

     ‘carg’は、計算関数であって、式整理関数ではありません。

     ‘abs’ (複素絶対値), ‘polarform’, ‘rectform’, ‘realpart’,
     ‘imagpart’も参照してください。

     例:

          (%i1) carg (1);
          (%o1)                           0
          (%i2) carg (1 + %i);
                                         %pi
          (%o2)                          ---
                                          4
          (%i3) carg (exp (%i));
          (%o3)                           1
          (%i4) carg (exp (%pi * %i));
          (%o4)                          %pi
          (%i5) carg (exp (3/2 * %pi * %i));
                                          %pi
          (%o5)                         - ---
                                           2
          (%i6) carg (17 * exp (2 * %i));
          (%o6)                           2

 -- 関数: conjugate (<x>)
     <x>の複素共役を返します。

          (%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

          (%o1)                         done
          (%i2) conjugate (aa + bb*%i);

          (%o2)                      aa - %i bb
          (%i3) conjugate (cc);

          (%o3)                     conjugate(cc)
          (%i4) conjugate (ii);

          (%o4)                         - ii
          (%i5) conjugate (xx + yy);

          (%o5)             conjugate(yy) + conjugate(xx)

 -- 関数: imagpart (<expr>)
     式<expr>の虚部を返します。

     ‘imagpart’は、計算関数であり、整理関数ではありません。

     ‘abs’, ‘carg’, ‘polarform’, ‘rectform’, ‘realpart’も 参照してくださ
     い。

 -- 関数: polarform (<expr>)
     <expr>と同値な式‘r %e^(%i theta)’を返します。 ここで、‘r’と
     ‘theta’は純粋な実数です。

 -- 関数: realpart (<expr>)
     <expr>の実部を返します。 ‘realpart’と‘imagpart’は、 平方根、対数関
     数、指数関数はもちろん三角関数や双曲関数を含む式上で機能します。

 -- 関数: rectform (<expr>)
     <expr>と同値な式‘a + b %i’を返します。 ここで<a>と<b>は純粋な実数で
     す。


File: maxima.info,  Node: Combinatorial Functions,  Next: Root Exponential and Logarithmic Functions,  Prev: Functions for Complex Numbers,  Up: Mathematical Functions

10.3 Combinatorial Functions
============================

 -- 演算子: !!
     二重階乗演算子。

     整数や浮動小数点、有理数 ‘n’に対して、 ‘n!!’は、 積 ‘n (n-2) (n-4)
     (n-6) ... (n - 2 (k - 1))’ （‘k’は ‘entier (n/2)’、すなわち ‘n/2’以
     下の最大整数に等しい）に評価します。 この定義は、非整数の引数に対し
     て他の出版物の定義と一致しないことに注意してください。

     偶数(もしくは奇数) ‘n’に対して、 ‘n!!’は、2(もしくは1)からnまでのす
     べての偶数 (もしくは奇数)の積に評価されます。

     整数でも浮動小数点でも有理数でもない引数 ‘n’に対して、 ‘n!!’は名詞
     形 ‘genfact (n, n/2, 2)’を返します。

 -- 関数: binomial (<x>, <y>)
     二項係数‘<x>!/(<y>! (<x> - <y>)!)’。 もし<x>と<y>が整数なら、 二項
     係数の数値が計算されます。 もし<y>もしくは<x - y>が整数なら、 二項
     係数は多項式として表現されます。

     例:

          (%i1) binomial (11, 7);
          (%o1)                          330
          (%i2) 11! / 7! / (11 - 7)!;
          (%o2)                          330
          (%i3) binomial (x, 7);
                  (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
          (%o3)   -------------------------------------------------
                                        5040
          (%i4) binomial (x + 7, x);
                (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
          (%o4) -------------------------------------------------------
                                         5040
          (%i5) binomial (11, y);
          (%o5)                    binomial(11, y)

 -- 関数: factcomb (<expr>)
     例えば、‘(n + 1)*n!’を‘(n + 1)!’に変換することによって、 <expr>の中
     の階乗の係数を階乗それ自身と結合しようとします。

     もし‘sumsplitfact’が‘false’に設定されたなら、 ‘minfactorial’が
     ‘factcomb’の後適用されるようになります。

 -- 関数: factorial
 -- 演算子: !
     階乗演算子。

     （整数、有理数、実数を含む）負の整数を除いた任意の複素数 ‘x’に対し
     て、 ‘x!’は ‘gamma(x+1)’として定義されます。

     整数 ‘x’に対して、 ‘x!’は1からxまでの整数の積に整理されます。 ‘0!’は
     1に整理されます。 浮動小数点または多倍長浮動小数点精度の実数または
     複素数 ‘x’に対して、 ‘x!’は ‘gamma(x+1)’の値に整理されます。 ‘x’が
     ‘n/2’（‘n’は奇数）に等しい時、 （‘gamma (1/2)’は‘sqrt (%pi)’に等し
     いから） ‘x!’は有理因子に‘sqrt (%pi)’を掛けたものに整理されます。

     変数 ‘factlim’, ‘gammalim’は整数や有理数の引数の階乗の数値評価を制
     御します。 関数 ‘minfactorial’, ‘factcomb’は階乗を含む式の整理を制
     御します。 ‘factlim’, ‘gammalim’, ‘minfactorial’, ‘factcomb’を参照
     してください。

     関数 ‘gamma’, ‘bffac’, ‘cbffac’はガンマ関数の変形です。 多倍長浮動
     小数点精度の実数と複素数のガンマ関数を評価するために、 ‘gamma’は内
     部で ‘bffac’や ‘cbffac’をコールします。

     ‘makegamma’は階乗や関係した関数に‘gamma’を代入します。

     Maximaは階乗関数の導関数や、負の整数のような特殊な値の極限を知って
     います。

     オプション変数 ‘factorial_expand’は ‘(n+x)!’のような式の整理を制御
     します。 ここで‘n’は整数です。

     ‘binomial’も参照してください。

     オペランドが‘factlim’より大きくないなら、整数の階乗は正確な値に整理
     されます。 実数と複素数の階乗は浮動小数点または多倍長浮動小数点精度
     に評価されます。

          (%i1) factlim : 10;
          (%o1)                          10
          (%i2) [0!, (7/2)!, 8!, 20!];
                                      105 sqrt(%pi)
          (%o2)                   [1, -------------, 40320, 20!]
                                           16
          (%i3) [4.77!, (1.0+%i)!];
          (%o3)    [81.44668037931197,
                    .3430658398165454 %i + .6529654964201665]
          (%i4) [2.86b0!, (1.0b0+%i)!];
          (%o4) [5.046635586910012b0,
                 3.430658398165454b-1 %i + 6.529654964201667b-1]

     既知の定数や一般式の階乗は整理されません。 オペランドを評価した後階
     乗を整理できたとしても整理はされません。

          (%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
          (%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
          (%i2) ev (%, numer, %enumer);
          (%o2) [.3430658398165454 %i + .6529654964201665,
                 7.188082728976031,
                 4.260820476357003, 1.227580202486819]

          (%i1) kill (foo);
          (%o1)                         done
          (%i2) foo!;
          (%o2)                         foo!

     階乗の計算は整理であって、評価ではありません。 従って、‘x!’はクォー
     トされた式の中でも置き換えられます。

          (%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
                    105 sqrt(%pi)
          (%o1) [1, -------------, 81.44668037931199, 40320,
                         16
                                                       2432902008176640000]

     Maximaは階乗関数の導関数を知っています。

          (%i1) diff(x!,x);
          (%o1)                           x! psi (x + 1)
                                                0

     オプション変数‘factorial_expand’は、 階乗関数を含む式の展開と整理を
     制御します。

          (%i1) (n+1)!/n!,factorial_expand:true;
          (%o1)                                n + 1

 -- オプション変数: factlim
     デフォルト値: -1

     ‘factlim’は、自動的に展開される最高の階乗を指定します。 もし-1なら
     、すべての整数は展開されます。

 -- オプション変数: factorial_expand
     デフォルト値: false

     オプション変数‘factorial_expand’は ‘(n+1)!’のような式の整理を制御し
     ます。 ここで‘n’は整数です。 例は‘!’を参照してください。

 -- 関数: genfact (<x>, <y>, <z>)
     一般化された階乗を返します。 ‘x (x-z) (x - 2 z) ... (x - (y - 1)
     z)’のように定義されます。 それゆえに、整数<x>に関して、 ‘genfact
     (x, x, 1) = x!’であり、‘genfact (x, x/2, 2) = x!!’です。

 -- 関数: minfactorial (<expr>)

     整数だけ違う２つの階乗の出現に関して <expr>を検査します。 そして、
     ‘minfactorial’は、 一方を多項式掛ける他方に変えます。

          (%i1) n!/(n+2)!;
                                         n!
          (%o1)                       --------
                                      (n + 2)!
          (%i2) minfactorial (%);
                                          1
          (%o2)                    ---------------
                                   (n + 1) (n + 2)

 -- オプション変数: sumsplitfact
     デフォルト値: ‘true’

     ‘sumsplitfact’が‘false’の時、 ‘minfactorial’は、‘factcomb’の後に適
     用されます。


File: maxima.info,  Node: Root Exponential and Logarithmic Functions,  Next: Trigonometric Functions,  Prev: Combinatorial Functions,  Up: Mathematical Functions

10.4 Root, Exponential and Logarithmic Functions
================================================

 -- オプション変数: %e_to_numlog
     デフォルト値: ‘false’

     ‘true’の時、 ‘r’をある有理数、‘x’をある式とすると、
     ‘%e^(r*log(x))’は‘x^r’に整理されます。 ‘radcan’コマンドもこの変換を
     行い、その上この同類のさらに複雑な変換をすることに注意すべきです。
     ‘logcontract’コマンドは‘log’を含む式を「短縮」します。

 -- オプション変数: %emode
     デフォルト値: ‘true’

     ‘%emode’が‘true’の時、 ‘%e^(%pi %i x)’は以下のように整理されます。

     もし‘x’が浮動小数点、整数、もしくは1/2, 1/3, 1/4, 1/6の整数倍なら、
     ‘%e^(%pi %i x)’は‘cos (%pi x) + %i sin (%pi x)’に整理された後、 さ
     らに整理されます。

     他の数値‘x’に関して、 ‘%e^(%pi %i x)’は、‘%e^(%pi %i y)’に整理され
     ます。 ここで‘y’は‘x - 2 k’（‘k’は‘abs(y) < 1’が成り立つような整数
     ）です。

     ‘%emode’が‘false’の時には、 ‘%e^(%pi %i x)’の特別な整理は実行されま
     せん。

 -- オプション変数: %enumer
     デフォルト値: ‘false’

     ‘%enumer’が‘true’の時、 ‘numer’が‘true’の時はいつでも、 ‘%e’は数値
     2.718...に置き換えられます。

     ‘%enumer’が‘false’の時、 ‘%e^x’の指数が数に評価される時だけ、 この
     代入が実行されます。

     ‘ev’, ‘numer’も参照してください。

 -- 関数: exp (<x>)

     指数関数を表します。 入力にある‘exp (<x>)’のインスタンスは、
     ‘%e^<x>’に整理されます; ‘exp’は整理された式の中には現れません。

     もし‘demoivre’が‘true’で、かつ、 ‘b’が‘%i’を含まないなら、 ‘%e^(a +
     b %i)’は‘%e^(a (cos(b) + %i sin(b)))’に整理されます。 ‘demoivre’を
     参照してください。

     ‘%emode’が‘true’の時、 ‘%e^(%pi %i x)’は整理されます。 ‘%emode’を参
     照してください。

     ‘%enumer’が‘true’の時、 ‘numer’が‘true’の時にはいつでも ‘%e’は
     2.718...に置き換えれます。 ‘%enumer’を参照してください。

 -- 関数: li [<s>] (<z>)

     次数<s>、引数<z>の多重対数関数を表します。 これは、以下の無限級数で
     定義されます。

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     ‘li [1]’は、‘- log (1 - z)’です。 ‘li [2]’と‘li [3]’は、それぞれ、
     dilogarithm関数、trilogarithm関数です。

     次数が1の時、多重対数関数は‘- log (1 - z)’に整理され、 もし<z>が実
     数もしくは複素数の浮動小数点数、もしくは、‘numer’評価フラグが有効な
     ら、さらに数値に整理されます。

     次数が2もしくは3の時、 もし<z>が実数の浮動小数点数、もしくは
     ‘numer’評価フラグが有効なら、 多重対数関数は数値に整理されます。

     例:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]

 -- 関数: log (<x>)

     <x>の自然対数（基数eの対数）を表します。

     Maximaは、基数10や他の基数の対数の組み込み関数を持ちません。
     ‘log10(x) := log(x) / log(10)’は、役立つ定義です。

     対数の整理と評価は、いくつかのグローバルフラグによって管理されます:

     ‘logexpand’
          ‘log(a^b)’を‘b*log(a)’にします。 もし‘all’に設定されているなら
          、 ‘log(a*b)’も‘log(a)+log(b)’に整理されます。 もし‘super’に設
          定されているなら, 有理数‘a/b’ただし‘a#1’について‘log(a/b)’も
          ‘log(a)-log(b)’に整理されます。 (整数‘b’に関して‘log(1/b)’はい
          つも整理されます。) もし‘false’に設定されているなら、 これらの
          すべての整理は止められます。

     ‘logsimp’
          もし‘false’なら、 ‘%e’は、‘log’を含む累乗へ整理がなされます。

     ‘lognumer’
          もし‘true’なら、 引数は、‘log’の計算の前に絶対値に変換されます
          。 もし‘numer’も‘true’なら、 ‘log’の引数に負の整数を与えたとき
          、 引数は、‘log’の計算の前に絶対値に変換されます。

     ‘lognegint’
          もし‘true’なら、正の整数‘n’に対して規則 ‘log(-n)’ ->
          ‘log(n)+%i*%pi’ が実装されます。

     ‘%e_to_numlog’
          ‘true’の時、 ‘r’をある有理数、‘x’をある式とすると、 式
          ‘%e^(r*log(x))’は‘x^r’に整理されます。 ‘radcan’コマンドもこの
          変換を行い、その上この同類のさらに複雑な変換をすることに注意す
          べきです。 ‘logcontract’コマンドは‘log’を含む式を「短縮」しま
          す。

 -- オプション変数: logabs
     デフォルト値: ‘false’

     例えば‘integrate(1/x,x)’のように、logが生成される不定積分を実行する
     時、 もし‘logabs’が‘true’なら もし‘logabs’が‘false’なら 答えは、
     ‘log(...)’の形で与えられます。 定積分については、 終端での不定積分
     の「評価」がしばしば必要になるので、‘logabs:true’設定が使われます。

 -- オプション変数: logarc
 -- 関数: logarc (<expr>)

     グローバル変数‘logarc’が‘true’の時、 逆円関数や逆双曲線関数は、同値
     の対数関数に置き換えられます。 ‘logarc’のデフォルト値は‘false’です
     。

     関数‘logarc(<expr>)’は、 グローバル変数‘logarc’を設定することなしに
     、式<expr>に対して上記置き換えを実行します。

 -- オプション変数: logconcoeffp
     デフォルト値: ‘false’

     ‘logcontract’を使った時、どの係数が短縮されるかを制御します。 引数
     １つの述語論理関数の名前に設定することができます。 例えば、もし
     SQRTを生成したいなら、 ‘logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$’を実行できます。 す
     ると、 ‘logcontract(1/2*log(x));’は‘log(sqrt(x))’を与えるでしょう。

 -- 関数: logcontract (<expr>)

     形式‘a1*log(b1) + a2*log(b2) + c’の部分式を ‘log(ratsimp(b1^a1 *
     b2^a2)) + c’に変換しながら、 再帰的に式<expr>を走査します。

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     ‘declare(n,integer);’を実行すると、 ‘logcontract(2*a*n*log(x));’は
     、‘a*log(x^(2*n))’に整理されます。 この方法で「短縮」される係数は、
     ここで2や‘n’に当たるもので、‘featurep(coeff,integer)’を満たします。
     ユーザーは、 オプション‘logconcoeffp’を引数１つの述語論理関数名に設
     定することで、 どの係数を短縮するか制御できます。 例えば、もし
     SQRTを生成したいなら、 ‘logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$’を実行できます。 す
     ると、 ‘logcontract(1/2*log(x));’は‘log(sqrt(x))’を与えるでしょう。

 -- オプション変数: logexpand
     デフォルト値: ‘false’

     もし‘true’なら、 ‘log(a^b)’が‘b*log(a)’になるようにします。 もし
     ‘all’に設定されているなら、 ‘log(a*b)’も‘log(a)+log(b)’に整理されま
     す。 もし‘super’に設定されているなら, 有理数‘a/b’ただし‘a#1’につい
     て‘log(a/b)’も‘log(a)-log(b)’に整理されます。 (整数‘b’に関して
     ‘log(1/b)’はいつも整理されます。) もし‘false’に設定されているなら、
     これらのすべての整理は止められます。

 -- オプション変数: lognegint
     デフォルト値: ‘false’

     もし‘true’なら、正の整数‘n’に対して規則 ‘log(-n)’ ->
     ‘log(n)+%i*%pi’ が実装されます。

 -- オプション変数: lognumer
     デフォルト値: ‘false’

     もし‘true’なら、 引数は、‘log’の計算の前に絶対値に変換されます。 も
     し‘numer’も‘true’なら、 ‘log’の引数に負の整数を与えたとき、 引数は
     、‘log’の計算の前に絶対値に変換されます。

 -- オプション変数: logsimp
     デフォルト値: ‘true’

     もし‘false’なら、 ‘%e’は、‘log’を含む累乗へ整理がなされます。

 -- 関数: plog (<x>)

     ‘-%pi’ < ‘carg(<x>)’ <= ‘+%pi’を虚部係数とする複素数値の自然対数の
     主値を表します。

 -- 関数: sqrt (<x>)
     <x>の平方根。 内部的には‘<x>^(1/2)’で表現されます。
     ‘rootscontract’も参照してください。

     ‘radexpand’が‘true’なら、nのべき乗となる積の因子のn番目の根を 累乗
     根の外部に押し出すようにします。 例えば、 ‘radexpand’が‘true’の時だ
     け、‘sqrt(16*x^2)’は‘4*x’になります。


File: maxima.info,  Node: Trigonometric Functions,  Next: Random Numbers,  Prev: Root Exponential and Logarithmic Functions,  Up: Mathematical Functions

10.5 Trigonometric Functions
============================

* Menu:

* Introduction to Trigonometric::
* Functions and Variables for Trigonometric::


File: maxima.info,  Node: Introduction to Trigonometric,  Next: Functions and Variables for Trigonometric,  Prev: Trigonometric Functions,  Up: Trigonometric Functions

10.5.1 Introduction to Trigonometric
------------------------------------

Maximaは、定義されたたくさんの三角関数を持ちます。 すべての三角恒等式が
プログラムされているわけではありませんが、 ユーザーは、システムのパター
ンマッチング能力を使ってそれらの多くを追加することができます。 Maximaで
定義された三角関数は以下の通りです: ‘acos’, ‘acosh’, ‘acot’, ‘acoth’,
‘acsc’, ‘acsch’, ‘asec’, ‘asech’, ‘asin’, ‘asinh’, ‘atan’, ‘atanh’,
‘cos’, ‘cosh’, ‘cot’, ‘coth’, ‘csc’, ‘csch’, ‘sec’, ‘sech’, ‘sin’,
‘sinh’, ‘tan’, ‘tanh’。 特に三角関数を扱うためのたくさんのコマンドがあり
ます。 ‘trigexpand’, ‘trigreduce’, スイッチ‘trigsign’を参照してください
。 ２つの共用パッケージ‘ntrig’, ‘atrig1’は、 Maximaに組み込まれた整理規
則を拡張します。 詳しくは、‘describe(<command>)’を実行してください。


File: maxima.info,  Node: Functions and Variables for Trigonometric,  Prev: Introduction to Trigonometric,  Up: Trigonometric Functions

10.5.2 Functions and Variables for Trigonometric
------------------------------------------------

 -- オプション変数: %piargs
     デフォルト値: ‘true’

     ‘%piargs’が‘true’の時で、 引数が %pi, %pi/2, %pi/3, %pi/4, %pi/6の
     いずれか の整数倍の時は、 三角関数は、代数定数に整理されます。

     Maximaは、 %pi などが、整数変数（すなわち、整数に宣言されたシンボル
     ）倍された時適用できる いくつかの恒等式を知っています。

     例:

          (%i1) %piargs : false$
          (%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          %pi       %pi
          (%o2)            [sin(%pi), sin(---), sin(---)]
                                           2         3
          (%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                %pi       %pi       %pi
          (%o3)            [sin(---), sin(---), sin(---)]
                                 4         5         6
          (%i4) %piargs : true$
          (%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                          sqrt(3)
          (%o5)                    [0, 1, -------]
                                             2
          (%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                                   1         %pi   1
          (%o6)                [-------, sin(---), -]
                                sqrt(2)       5    2
          (%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
                 cos (sqrt(2)*%pi/3)];
                          1    1               sqrt(2) %pi
          (%o7)          [-, - -, sqrt(3), cos(-----------)]
                          2    2                    3

     %pi and %pi/2 が整数変数にかけられた時、いくつかの恒等式が適用され
     ます。

          (%i1) declare (n, integer, m, even)$
          (%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
                 cos (%pi/2 * m)];
                                                m/2
          (%o2)                  [0, 1, 0, (- 1)   ]

 -- オプション変数: %iargs
     デフォルト値: ‘true’

     ‘%iargs’が‘true’の時、 引数が明らかに、虚数単位 %i を掛けたものの時
     、 三角関数は双曲線関数に整理されます。

     引数が明らかに実数の時でさえ、整理は実行されます; Maximaは、ただ、
     引数が、 %i を文字通り掛けたものかどうかを考慮します。

     例:

          (%i1) %iargs : false$
          (%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o2)           [sin(%i x), cos(%i x), tan(%i x)]
          (%i3) %iargs : true$
          (%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
          (%o4)           [%i sinh(x), cosh(x), %i tanh(x)]

     引数が明らかに実数の時でさえ、整理は実行されます。

          (%i1) declare (x, imaginary)$
          (%i2) [featurep (x, imaginary), featurep (x, real)];
          (%o2)                     [true, false]
          (%i3) sin (%i * x);
          (%o3)                      %i sinh(x)

 -- 関数: acos (<x>)
     – 逆余弦

 -- 関数: acosh (<x>)
     – 逆双曲余弦

 -- 関数: acot (<x>)
     – 逆余接

 -- 関数: acoth (<x>)
     – 逆双曲余接

 -- 関数: acsc (<x>)
     – 逆余割

 -- 関数: acsch (<x>)
     – 逆双曲余割

 -- 関数: asec (<x>)
     – 逆正割

 -- 関数: asech (<x>)
     – 逆双曲正割

 -- 関数: asin (<x>)
     – 逆正弦

 -- 関数: asinh (<x>)
     – 逆双曲正弦

 -- 関数: atan (<x>)
     – 逆正接

 -- 関数: atan2 (<y>, <x>)
     – ‘-%pi’から‘%pi’までの間の‘atan(<y>/<x>)’の値をもたらします。

 -- 関数: atanh (<x>)
     – 逆双曲正接

 -- パッケージ: atrig1
     ‘atrig1’パッケージは、逆三角関数のためのいくつかの追加の整理規則を
     含みます。 Maximaが既に知っている規則と合わせて、 以下の角度が完全
     に実装されます: ‘0’, ‘%pi/6’, ‘%pi/4’, ‘%pi/3’, ‘%pi/2’。 他の3象限
     の対応する角度も利用可能です。 これらを使うには、
     ‘load("atrig1");’を実行してください。

 -- 関数: cos (<x>)
     – 余弦

 -- 関数: cosh (<x>)
     – 双曲余弦

 -- 関数: cot (<x>)
     – 余接

 -- 関数: coth (<x>)
     – 双曲余接

 -- 関数: csc (<x>)
     – 余割

 -- 関数: csch (<x>)
     – 双曲余割

 -- オプション変数: halfangles
     デフォルト値: ‘false’

     ‘halfangles’が‘true’の時、 引数‘<expr>/2’の三角関数は、<expr>の関数
     に整理されます。

     区間‘0 < x < 2*%pi’の実引数<x>に関して、 半角の正弦は簡単な公式に整
     理されます:

                                   sqrt(1 - cos(x))
                                   ----------------
                                       sqrt(2)

     複雑な因子は すべての複素引数<z>でこの公式を正しくするために必要で
     す:

                realpart(z)
          floor(-----------)
                   2 %pi
     (- 1)                   (1 - unit_step(- imagpart(z))

                                 realpart(z)            realpart(z)
                           floor(-----------) - ceiling(-----------)
                                    2 %pi                  2 %pi
                     ((- 1)                                          + 1))

     Maximaは、この因子と、 関数‘sin’, ‘cos’, ‘sinh’, ‘cosh’に関する類似
     の因子を知っています。 引数zの特別な値に関して、 これらの因子は相応
     に整理されます。

     例:

          (%i1) halfangles:false;
          (%o1)                                false
          (%i2) sin(x/2);
                                                  x
          (%o2)                               sin(-)
                                                  2
          (%i3) halfangles:true;
          (%o3)                                true
          (%i4) sin(x/2);
                                                              x
                                                      floor(-----)
                                                            2 %pi
                                sqrt(1 - cos(x)) (- 1)
          (%o4)                 ----------------------------------
                                             sqrt(2)
          (%i5) assume(x>0, x<2*%pi)$
          (%i6) sin(x/2);
                                         sqrt(1 - cos(x))
          (%o6)                          ----------------
                                             sqrt(2)

 -- パッケージ: ntrig
     ‘ntrig’パッケージは、 引数が形式‘<f>(<n> %pi/10)’ ―<f>は関数 ‘sin’,
     ‘cos’, ‘tan’, ‘csc’, ‘sec’, ‘cot’のいずれか― の三角関数を整理するの
     に使われる整理規則の集合を含みます。

 -- 関数: sec (<x>)
     – 正割

 -- 関数: sech (<x>)
     – 双曲正割

 -- 関数: sin (<x>)
     – 正弦

 -- 関数: sinh (<x>)
     – 双曲正弦

 -- 関数: tan (<x>)
     – 正接

 -- 関数: tanh (<x>)
     – 双曲正接

 -- 関数: trigexpand (<expr>)
     <expr>の中に現れる角の和や角の倍数の三角関数、双曲線関数を展開しま
     す。 最もよい結果では、<expr>は展開されるべきです。 整理のユーザー
     制御を強化するために、 この関数は、一度に１レベルのみ、角の和もしく
     は角の倍数を展開します。 ただちにサインとコサインへの完全な展開を得
     るには、 スイッチ‘trigexpand: true’を設定してください。

     ‘trigexpand’は、以下のグローバルフラグによって決定されます:

     ‘trigexpand’
          もし‘true’なら、 続いて現れるサインやコサインを含んでいる式す
          べての展開を起こします。
     ‘halfangles’
          もし‘true’なら、 半角が整理されます。
     ‘trigexpandplus’
          ‘trigexpand’の「和」規則を制御します。 和（例えば‘sin(x + y)’）
          の展開は、 ‘trigexpandplus’が‘true’の時だけ起こります。
     ‘trigexpandtimes’
          ‘trigexpand’の「積」規則を制御します。 積(例えば‘sin(2 x)’)の
          展開は、 ‘trigexpandtimes’が‘true’の時だけ起こります。

     例:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)

 -- オプション変数: trigexpandplus
     デフォルト値: ‘true’

     ‘trigexpandplus’は、‘trigexpand’の「和」規則を制御します。
     ‘trigexpand’コマンドが使われるか、もしくは ‘trigexpand’スイッチが
     ‘true’に設定されている時 和(例えば‘sin(x+y))’)の展開は、
     ‘trigexpandplus’が‘true’の時だけ起こります。

 -- オプション変数: trigexpandtimes
     デフォルト値: ‘true’

     ‘trigexpandtimes’は、‘trigexpand’の「積」規則を制御します。
     ‘trigexpand’コマンドが使われるか、もしくは、 ‘trigexpand’スイッチが
     ‘true’に設定されている時、 積(例えば‘sin(2*x)’)の展開は、
     ‘trigexpandtimes’が‘true’の時だけ起こります。

 -- オプション変数: triginverses
     デフォルト値: ‘true’

     ‘triginverses’は、 三角関数や双曲線関数とそれらの逆関数の合成の整理
     を制御します。

     もし‘all’なら、 例えば、‘atan(tan(<x>))’ と‘tan(atan(<x>))’のどちら
     も<x>に整理されます。

     もし‘true’なら、 ‘<arcfun>(<fun>(<x>))’の整理は止められます。

     もし‘false’なら、 ‘<arcfun>(<fun>(<x>))’と ‘<fun>(<arcfun>(<x>))’の
     どちらの整理も止められます。

 -- 関数: trigreduce (<expr>, <x>)
 -- 関数: trigreduce (<expr>)
     <x>を引数とする三角と双曲の正弦、余弦の積とべきを <x>の倍数のそれら
     に結合します。 これらの関数が分母に現れた時、これらを消去しようとも
     します。 もし<x>が省略されたら、<expr>の中の変数すべてが使われます
     。

     ‘poissimp’も参照してください。

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

 -- オプション変数: trigsign
     デフォルト値: ‘true’

     ‘trigsign’が‘true’の時、 三角関数への負の引数の整理を認めます。 例
     えば、‘sin(-x)’は、 ‘trigsign’が‘true’の時だけ、 ‘-sin(x)’になりま
     す。

 -- 関数: trigsimp (<expr>)
     ‘tan’, ‘sec’などを含む式を‘sin’, ‘cos’, ‘sinh’, ‘cosh’に整理するた
     めに、 恒等式 sin(x)^2 + cos(x)^2 = 1 と cosh(x)^2 - sinh(x)^2 = 1
     を使います。

     ‘trigreduce’, ‘ratsimp’, ‘radcan’ は、結果を更に整理できるかもしれ
     ません。

     ‘demo ("trgsmp.dem")’は、‘trigsimp’のいくつかの例を表示します。

 -- 関数: trigrat (<expr>)
     三角関数の整理された標準疑似線形形式を与えます; <expr>は、‘sin’,
     ‘cos’もしくは‘tan’のいくつかの有理分数であり、 それらの引数は、整数
     係数を持つ、いくつかの変数（もしくは核）と‘%pi/<n>’ (<n>は整数)の線
     形形式です。 結果は、分子と分母が‘sin’と‘cos’に関して線形の整理され
     た分数です。 ‘trigrat’はいつも可能なときは線形化します。

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     以下の例は、 Davenport, Siret, and TournierのCalcul Formel, Masson
     (もしくは英語版ではAddison-Wesley), 1.5.5節, モーレイの定理から取ら
     れました。

          (%i1) c : %pi/3 - a - b$
          (%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                                    %pi
                            sin(a) sin(3 (- b - a + ---))
                                                     3
          (%o2)             -----------------------------
                                     sin(b + a)
          (%i3) ba : bc, c=a, a=c;
                                                   %pi
                              sin(3 a) sin(b + a - ---)
                                                    3
          (%o3)               -------------------------
                                            %pi
                                    sin(a - ---)
                                             3
          (%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2         2         %pi
                sin (3 a) sin (b + a - ---)
                                        3
          (%o4) ---------------------------
                          2     %pi
                       sin (a - ---)
                                 3
                                                 %pi
           - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                                  3
                       %pi            %pi
           sin(b + a - ---))/(sin(a - ---) sin(b + a))
                        3              3
                2       2              %pi
             sin (a) sin (3 (- b - a + ---))
                                        3
           + -------------------------------
                          2
                       sin (b + a)
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
           - 9)/4


File: maxima.info,  Node: Random Numbers,  Prev: Trigonometric Functions,  Up: Mathematical Functions

10.6 Random Numbers
===================

 -- 関数: make_random_state (<n>)
 -- 関数: make_random_state (<s>)
 -- 関数: make_random_state (true)
 -- 関数: make_random_state (false)

     ランダムステートオブジェクトは、乱数生成器の状態を表します。 状態は
     、627個の32ビットワードで構成されます。

     ‘make_random_state (<n>)’は、 <n>を2^32で割った余りに等しい整数シー
     ドの値から新しいランダムステートオブジェクトを 生成します。<n>は負
     でもいいです。

     ‘make_random_state (<s>)’は、ランダムステート<s>のコピーを返します
     。

     ‘make_random_state (true)’は、新しいランダムステートオブジェクトを
     返します。 シードとしてコンピュータの現在時刻を使います。

     ‘make_random_state (false)’は、乱数生成器の現在のステートのコピーを
     返します。

 -- 関数: set_random_state (<s>)
     <s>を乱数生成器状態にコピーします。

     ‘set_random_state’はいつも‘done’を返します。

 -- 関数: random (<x>)

     疑似乱数を返します。 もし<x>が整数なら、‘random (<x>)’は、0から‘<x>
     - 1’までの 整数を返します。 もし<x>が浮動小数点なら、‘random
     (<x>)’は、<x>より小さい非負の浮動小数点を返します。 もし<x>が整数で
     も浮動小数点でもなかったり、<x>が正でなければ、 ‘random’は、エラー
     を出力します。

     関数‘make_random_state’と‘set_random_state’は、 乱数生成器の状態を
     保守します。

     Maximaの乱数生成器は、メルセンヌ・ツイスタ MT 19937の実装です。

     例:

          (%i1) s1: make_random_state (654321)$
          (%i2) set_random_state (s1);
          (%o2)                         done
          (%i3) random (1000);
          (%o3)                          768
          (%i4) random (9573684);
          (%o4)                        7657880
          (%i5) random (2^75);
          (%o5)                11804491615036831636390
          (%i6) s2: make_random_state (false)$
          (%i7) random (1.0);
          (%o7)                   .2310127244107132
          (%i8) random (10.0);
          (%o8)                   4.394553645870825
          (%i9) random (100.0);
          (%o9)                   32.28666704056853
          (%i10) set_random_state (s2);
          (%o10)                        done
          (%i11) random (1.0);
          (%o11)                  .2310127244107132
          (%i12) random (10.0);
          (%o12)                  4.394553645870825
          (%i13) random (100.0);
          (%o13)                  32.28666704056853


File: maxima.info,  Node: Maximas Database,  Next: Plotting,  Prev: Mathematical Functions,  Up: Top

11 Maximas Database
*******************

* Menu:

* Introduction to Maximas Database::
* Functions and Variables for Properties::
* Functions and Variables for Facts::
* Functions and Variables for Predicates::


File: maxima.info,  Node: Introduction to Maximas Database,  Next: Functions and Variables for Properties,  Prev: Maximas Database,  Up: Maximas Database

11.1 Introduction to Maximas Database
=====================================


File: maxima.info,  Node: Functions and Variables for Properties,  Next: Functions and Variables for Facts,  Prev: Introduction to Maximas Database,  Up: Maximas Database

11.2 Functions and Variables for Properties
===========================================

 -- 関数: declare (<a_1>, <p_1>, <a_2>, <p_2>, …)

     アトムやアトムのリスト<a_i>に、プロパティやプロパティのリスト
     <p_i>を割り当てます。 <a_i>や<p_i>がリストの時、 アトムのそれぞれは
     、プロパティすべてを得ます。

     ‘declare’は引数をクォートします。 ‘declare’はいつも‘done’を返します
     。

     それぞれの宣言フラグに関する記述で注意しているように、 いくつかのフ
     ラグに関して、 もし<object>が<feature>を持つよう宣言されているなら
     、 ‘featurep(<object>, <feature>)’は、 ‘true’を返します。 しかしな
     がら、‘featurep’はいくつかのフラグを認識しません; これはバグです。

     ‘features’も参照してください。

     ‘declare’は以下のプロパティを認識します:

     ‘evfun’
          ‘ev’のフラグ引数として<a_i>が現れた時 <a_i>で名付けられた関数
          を適用するように ‘ev’に伝えます。 ‘evfun’を参照してください。

     ‘evflag’
          ‘ev’のフラグ引数として<a_i>が現れた時 ‘ev’の実行中<a_i>が
          ‘true’にバインドされるように ‘ev’に伝えます。 ‘evflag’を参照し
          てください。

     ‘bindtest’
          <a_i>がバインドされていない状態に評価された時、 Maximaにエラー
          をトリガーするように伝えます。

     ‘noun’
          <a_i>を名詞としてパースするようにMaximaに伝えます。 この効果は
          、<a_i>のインスタンスを‘'<a_i>’や‘nounify(<a_i>)’ で置き換える
          ことです。どちらに置き換えるかは文脈に依存します。

     ‘constant’
          <a_i>をシンボル定数と考えるようにMaximaに伝えます。

     ‘scalar’
          <a_i>をスカラー変数と考えるようにMaximaに伝えます。

     ‘nonscalar’
          <a_i>を非スカラー変数と考えるようにMaximaに伝えます。 普通の使
          い方は、変数をシンボルベクトルや行列として宣言することです。

     ‘nonarray’
          Maximaに<a_i>を配列でないものと考えるように伝えます。 この宣言
          は添字付き変数名の多重評価を抑制します。

     ‘mainvar’
          <a_i>を「主変数」と考えるようにMaximaに伝えます。
          ‘ordergreatp’で決定されるように、 Maximaの式の標準順序では、主
          変数は他のすべての定数や変数に続きます。

     ‘alphabetic’
          （文字列の）<a_i>の中の文字すべてをアルファベット文字として認
          識するように Maximaに伝えます。

     ‘feature’
          <a_i>をfeature名として認識するようにMaximaに伝えます。 他のア
          トムは、<a_i>プロパティを持つように定義されます。

     ‘rassociative’, ‘lassociative’
          <a_i>を右結合、もしくは左結合関数として認識するようにMaximaに
          伝えます。

     ‘nary’
          <a_i>をn項関数として認識するようにMaximaに伝えます。

          ‘nary’宣言は、‘nary’関数をコールするのとは同じではありません。
          ‘declare(foo, nary)’だけの効果は、Maxima整理器を ネストされた
          式を平坦にするように指示することです。 例えば、‘foo(x, foo(y,
          z))’を‘foo(x, y, z)’に整理します。

     ‘symmetric’, ‘antisymmetric’, ‘commutative’
          <a_i>を対称もしくは反対称関数として認識するようにMaximaに伝え
          ます。 ‘commutative’は‘symmetric’と同じです。

     ‘oddfun’, ‘evenfun’
          <a_i>を偶関数もしくは奇関数として認識するようにMaximaに伝えま
          す。

     ‘outative’
          <a_i>式を最初の引数から定数因子を引き出すことで整理するように
          Maximaに伝えます。

          <a_i>が１つ引数を持つ時、 もしリテラル定数や宣言定数なら、因子
          は定数とみなされます。

          <a_i>が２つ以上の引数を持つ時、 もし２番目の引数がシンボルであ
          り、因子が２番目の引数の制約を受けなければ、 因子は定数とみな
          されます。

     ‘multiplicative’
          代入‘<a_i>(x * y * z * ...)’  ‘-->’ ‘<a_i>(x) * <a_i>(y) *
          <a_i>(z) * ...’. によって、<a_i>式を整理するようにMaximaに伝え
          ます。 代入は、１番目の引数のみで実行されます。

     ‘additive’
          代入‘<a_i>(x + y + z + ...)’  ‘-->’ ‘<a_i>(x) + <a_i>(y) +
          <a_i>(z) + ...’. によって、<a_i>式を整理するようにMaximaに伝え
          ます。 代入は、１番目の引数のみで実行されます。

     ‘linear’
          <a_i>を‘outative’かつ‘additive’に宣言することと同値です。

     ‘integer’, ‘noninteger’
          <a_i>を整数もしくは非整数変数として認識するようにMaximaに伝え
          ます。

     ‘even’, ‘odd’
          <a_i>を偶数変数もしくは奇数変数として認識するようにMaximaに伝
          えます。

     ‘rational’, ‘irrational’
          <a_i>を有理変数もしくは非有理実変数として認識するように
          Maximaに伝えます。

     ‘real’, ‘imaginary’, ‘complex’
          <a_i>を実変数もしくは純虚数変数もしくは複素変数として認識する
          ようにMaximaに伝えます。

     ‘increasing’, ‘decreasing’
          <a_i>を単調増加関数もしくは単調減少関数として認識するように
          Maximaに伝えます。

     ‘posfun’
          <a_i>を正関数として認識するようにMaximaに伝えます。

     ‘integervalued’
          <a_i>を整数値を返す関数として認識するようにMaximaに伝えます。

     例:

     ‘evfun’と‘evflag’宣言。

          (%i1) declare (expand, evfun);
          (%o1)                         done
          (%i2) (a + b)^3;
                                             3
          (%o2)                       (b + a)
          (%i3) (a + b)^3, expand;
                               3        2      2      3
          (%o3)               b  + 3 a b  + 3 a  b + a
          (%i4) declare (demoivre, evflag);
          (%o4)                         done
          (%i5) exp (a + b*%i);
                                       %i b + a
          (%o5)                      %e
          (%i6) exp (a + b*%i), demoivre;
                                a
          (%o6)               %e  (%i sin(b) + cos(b))

     ‘bindtest’宣言。

          (%i1) aa + bb;
          (%o1)                        bb + aa
          (%i2) declare (aa, bindtest);
          (%o2)                         done
          (%i3) aa + bb;
          aa unbound variable
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) aa : 1234;
          (%o4)                         1234
          (%i5) aa + bb;
          (%o5)                       bb + 1234

     ‘noun’宣言。

          (%i1) factor (12345678);
                                       2
          (%o1)                     2 3  47 14593
          (%i2) declare (factor, noun);
          (%o2)                         done
          (%i3) factor (12345678);
          (%o3)                   factor(12345678)
          (%i4) ''%, nouns;
                                       2
          (%o4)                     2 3  47 14593

     ‘constant’, ‘scalar’, ‘nonscalar’, ‘mainvar’宣言。

     ‘alphabetic’宣言。

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

     ‘feature’宣言。

          (%i1) declare (FOO, feature);
          (%o1)                         done
          (%i2) declare (x, FOO);
          (%o2)                         done
          (%i3) featurep (x, FOO);
          (%o3)                         true

     ‘rassociative’, ‘lassociative’宣言。

     ‘nary’宣言。

          (%i1) H (H (a, b), H (c, H (d, e)));
          (%o1)               H(H(a, b), H(c, H(d, e)))
          (%i2) declare (H, nary);
          (%o2)                         done
          (%i3) H (H (a, b), H (c, H (d, e)));
          (%o3)                   H(a, b, c, d, e)

     ‘symmetric’, ‘antisymmetric’宣言。

          (%i1) S (b, a);
          (%o1)                        S(b, a)
          (%i2) declare (S, symmetric);
          (%o2)                         done
          (%i3) S (b, a);
          (%o3)                        S(a, b)
          (%i4) S (a, c, e, d, b);
          (%o4)                   S(a, b, c, d, e)
          (%i5) T (b, a);
          (%o5)                        T(b, a)
          (%i6) declare (T, antisymmetric);
          (%o6)                         done
          (%i7) T (b, a);
          (%o7)                       - T(a, b)
          (%i8) T (a, c, e, d, b);
          (%o8)                   T(a, b, c, d, e)

     ‘oddfun’, ‘evenfun’宣言。

          (%i1) o (- u) + o (u);
          (%o1)                     o(u) + o(- u)
          (%i2) declare (o, oddfun);
          (%o2)                         done
          (%i3) o (- u) + o (u);
          (%o3)                           0
          (%i4) e (- u) - e (u);
          (%o4)                     e(- u) - e(u)
          (%i5) declare (e, evenfun);
          (%o5)                         done
          (%i6) e (- u) - e (u);
          (%o6)                           0

     ‘outative’宣言。

          (%i1) F1 (100 * x);
          (%o1)                       F1(100 x)
          (%i2) declare (F1, outative);
          (%o2)                         done
          (%i3) F1 (100 * x);
          (%o3)                       100 F1(x)
          (%i4) declare (zz, constant);
          (%o4)                         done
          (%i5) F1 (zz * y);
          (%o5)                       zz F1(y)

     ‘multiplicative’宣言。

          (%i1) F2 (a * b * c);
          (%o1)                       F2(a b c)
          (%i2) declare (F2, multiplicative);
          (%o2)                         done
          (%i3) F2 (a * b * c);
          (%o3)                   F2(a) F2(b) F2(c)

     ‘additive’宣言。

          (%i1) F3 (a + b + c);
          (%o1)                     F3(c + b + a)
          (%i2) declare (F3, additive);
          (%o2)                         done
          (%i3) F3 (a + b + c);
          (%o3)                 F3(c) + F3(b) + F3(a)

     ‘linear’宣言。

          (%i1) 'sum (F(k) + G(k), k, 1, inf);
                                 inf
                                 ====
                                 \
          (%o1)                   >    (G(k) + F(k))
                                 /
                                 ====
                                 k = 1
          (%i2) declare (nounify (sum), linear);
          (%o2)                         done
          (%i3) 'sum (F(k) + G(k), k, 1, inf);
                               inf          inf
                               ====         ====
                               \            \
          (%o3)                 >    G(k) +  >    F(k)
                               /            /
                               ====         ====
                               k = 1        k = 1

 -- 宣言: features

     Maximaは、関数や変数のある数学的プロパティを認識します。 それらは「
     フィーチャー」と呼ばれます。

     ‘declare (<x>, <foo>)’は、 プロパティ<foo>を関数もしくは変数<x>に与
     えます。

     ‘declare (<foo>, feature)’は、 新しいフィーチャー<foo>を宣言します
     。 例えば、 ‘declare ([red, green, blue], feature)’は、 ３つの新し
     いフィーチャー‘red’, ‘green’, ‘blue’を宣言します。

     もし<x>が<foo>プロパティを持つなら、 述語論理‘featurep (<x>,
     <foo>)’は、‘true’を返し、 そうでなければ、‘false’を返します。

     インフォリスト‘features’は既知のフィーチャーのリストです。 それらは
     、

        integer        noninteger      even
        odd            rational        irrational
        real           imaginary       complex
        analytic       increasing      decreasing
        oddfun         evenfun         posfun
        commutative    lassociative    rassociative
        symmetric      antisymmetric

     プラス、任意のユーザー定義フィーチャーです。

     ‘features’は、数学的フィーチャーのリストです。 非数学的で、システム
     依存のフィーチャーのリストもあります。 ‘status’を参照してください。

 -- 関数: get (<a>, <i>)

     <i>が示すアトム <a>のユーザープロパティを検索し、 もしaがプロパティ
     <i>を持たないなら、 ‘false’を返します。

     ‘get’は、引数を評価します。

          (%i1) put (%e, 'transcendental, 'type);
          (%o1)                    transcendental
          (%i2) put (%pi, 'transcendental, 'type)$
          (%i3) put (%i, 'algebraic, 'type)$
          (%i4) typeof (expr) := block ([q],
                  if numberp (expr)
                  then return ('algebraic),
                  if not atom (expr)
                  then return (maplist ('typeof, expr)),
                  q: get (expr, 'type),
                  if q=false
                  then errcatch (error(expr,"is not numeric.")) else q)$
          (%i5) typeof (2*%e + x*%pi);
          x is not numeric.
          (%o5)  [[transcendental, []], [algebraic, transcendental]]
          (%i6) typeof (2*%e + %pi);
          (%o6)     [transcendental, [algebraic, transcendental]]

 -- プロパティ: nonarray

     コマンド‘declare(a, nonarray)’はMaximaに <a>が配列でないものと考え
     るように伝えます。 もし<a>が添字付き変数なら、この宣言は多重評価を
     抑制します。

     例:

          (%i1) a:'b$ b:'c$ c:'d$


          (%i4) a[x];
          (%o4)                          d
                                          x
          (%i5) declare(a, nonarray);
          (%o5)                         done
          (%i6) a[x];
          (%o6)                          a
                                          x

 -- 宣言: posfun
     ‘declare (f, posfun)’は、 ‘f’を正の関数と宣言します。 ‘is (f(x) >
     0)’は‘true’を出力します。

 -- 関数: printprops (<a>, <i>)
 -- 関数: printprops ([<a_1>, ..., <a_n>], <i>)
 -- 関数: printprops (all, <i>)

     アトム<a>に関連付けられた指標<i>の属性を表示します。 <a>は、アトム
     のリストもしくはアトム‘all’もありえます。 その場合，与えられたプロ
     パティを持つすべてのアトムに適用します。 例えば、 ‘printprops ([f,
     g], atvalue)’。 ‘printprops’は、表示できないプロパティ、 すなわち
     ‘atvalue’, ‘atomgrad’, ‘gradef’, ‘matchdeclare’のためのものです。


File: maxima.info,  Node: Functions and Variables for Facts,  Next: Functions and Variables for Predicates,  Prev: Functions and Variables for Properties,  Up: Maximas Database

11.3 Functions and Variables for Facts
======================================

 -- 関数: activate (<context_1>, …, <context_n>)
     文脈<context_1>, …, <context_n>をアクティベートします。 これらの文
     脈に関する事実は、演繹し情報を検索するために利用可能となります。 こ
     れらの文脈に関する事実は、‘facts ()’によってリストされません。

     変数‘activecontexts’は、 ‘activate’関数を使ってアクティブになった文
     脈のリストです。

 -- システム変数: activecontexts
     デフォルト値: ‘[]’

     変数‘activecontexts’は、 アクティブである文脈と対照的に、
     ‘activate’関数を使ってアクティブになった文脈のリストです。 ゆえに、
     それらは現在の文脈の部分文脈です。

 -- システム変数: askexp
     ‘asksign’がコールされた時、 ‘askexp’は、‘asksign’がテストしている式
     です。

     以前は、control-AでMaximaブレイクに入ることによって、 ユーザーが
     ‘askexp’を検査することができました。

 -- 関数: askinteger (<expr>, integer)
 -- 関数: askinteger (<expr>)
 -- 関数: askinteger (<expr>, even)
 -- 関数: askinteger (<expr>, odd)

     ‘askinteger (<expr>, integer)’は、 ‘assume’データベースから、
     <expr>が整数かどうかを決定しようとします。 そうでなく、もし決定でき
     なければ、‘askinteger’はユーザーに入力を促し、 可能ならばデータベー
     スに情報をインストールしようとします。 ‘askinteger (<expr>)’は、
     ‘askinteger (<expr>, integer)’と同値です。

     同様に、 ‘askinteger (<expr>, even)’や‘askinteger (<expr>, odd)’は
     、 それぞれ、<expr>が偶数か奇数か、決定しようとします。

 -- 関数: asksign (<expr>)

     最初に、指定された式が正か負かゼロか決定しようとします。 できなけれ
     ば、演繹を完了するのに必要な質問をユーザーに尋ねます。 ユーザーの答
     えは、現在の計算の演繹のため、データベースに記録されます。
     ‘asksign’の戻り値は、‘pos’, ‘neg’もしくは‘zero’のいずれか１つです。

 -- 関数: assume (<pred_1>, …, <pred_n>)

     述語論理<pred_1>, …, <pred_n>を現在の文脈に追加します。 もし述語論
     理が現在の文脈と矛盾していたり、冗長だったりしたなら、文脈に追加さ
     れません。 文脈は‘assume’がコールされる毎に述語論理を累積していきま
     す。

     ‘assume’は、文脈に追加された述語論理を要素に持つリストか、 適用され
     たアトム‘redundant’もしくは‘inconsistent’を返します。

     述語論理<pred_1>, …, <pred_n>は 関係演算子‘< <= equal notequal >=
     >’を持つ式のみ許されます。 述語論理はリテラル等号‘=’やリテラル不等
     号‘#’の式は使えません。 ‘integerp’のような述語関数も使えません。

     形式‘<pred_1> and ...and <pred_n>’の合成された述語論理が認識されま
     す。 しかし、‘<pred_1> or ... or <pred_n>’は認識されません。 もし
     ‘pred_k’が関係述語論理なら、‘not <pred_k>’は認識されます。 形式‘not
     (<pred_1> and <pred_2>)’の式や ‘not (<pred_1> or <pred_2>)’は認識さ
     れません。

     Maximaの推論メカニズムはそれほど強くありません; ‘is’によって決定さ
     れない多くの明らかな結果があります。 これは既知の弱みです。

     ‘assume’は複素数を伴う述語論理を扱いません。 もし述語論理が複素数を
     含むなら、‘assume’は‘inconsistent’か‘redundant’を返します。

     ‘assume’は引数を評価します。

     ‘is’や‘facts’, ‘forget’, ‘context’, ‘declare’も参照してください。

     例:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown

 -- オプション変数: assumescalar
     デフォルト値: ‘true’

     ‘assumescalar’は、 ‘nonscalarp (expr)’が‘false’であるような式
     ‘expr’が、 ある変換に関してスカラーのように振る舞うと仮定されるかど
     うかを決めるのを助けます。

     Let ‘expr’がリストや行列以外の任意の式を表してるとし、 ‘[1, 2, 3]’が
     任意のリストや行列を表しているとすると、 もし‘assumescalar’が
     ‘true’、 もしくは‘scalarp (expr)’が‘true’、 もしくは‘constantp
     (expr)’が‘true’なら、 ‘expr . [1, 2, 3]’は、‘[expr, 2 expr, 3
     expr]’をもたらします。

     もし‘assumescalar’が‘true’なら、 そんな式は可換演算子に関してだけス
     カラーのように振る舞いますが、 非可換乗算‘.’に関してはそうは振る舞
     いません。

     ‘assumescalar’が‘false’の時 そんな式は、非スカラーのように振る舞い
     ます。

     ‘assumescalar’が‘all’の時、 そんな式は、上でリストされた演算子すべ
     てに関してスカラーのように振る舞います。

 -- オプション変数: assume_pos
     デフォルト値: ‘false’

     ‘assume_pos’が‘true’で、 パラメータ<x>の符号が現在の文脈や他の考慮
     から決定できない時、 ‘sign’や‘asksign (<x>)’は、‘true’を返します。
     これは、‘integrate’や他の計算から起こるような、 自動生成される
     ‘asksign’問い合わせを事前に防ぐことができます。

     デフォルトでは、パラメータは‘symbolp (<x>)’もしくは ‘subvarp
     (<x>)’のような<x>です。 パラメータとして考えられる式のクラスは、 変
     数‘assume_pos_pred’を介して、ある程度変えることができます。

     ‘sign’と‘asksign’は、 式の中のオペランドの符号から式の符号を演繹し
     ようとします。 例えば、もし‘a’や‘b’がともに正なら、 ‘a + b’も正です
     。

     しかしながら、‘asksign’問い合わせすべてを迂回する方法はありません。
     特に、‘asksign’引数が、差‘<x> - <y>’もしくは 対数‘log(<x>)’の時、 た
     とえ‘assume_pos’が‘true’で、‘assume_pos_pred’が 引数すべてに
     ‘true’を返す関数であっても、 ‘asksign’は、いつもユーザーからの入力
     を要請します。

 -- オプション変数: assume_pos_pred
     デフォルト値: ‘false’

     ‘assume_pos_pred’が関数名や、引数<x>のラムダ式に割り当てられている
     時、 その関数は、 <x>が、‘assume_pos’のためのパラメータと考えられる
     かどうかを決定するために コールされます。 ‘assume_pos’が‘false’の時
     、 ‘assume_pos_pred’は、無視されます。

     ‘assume_pos_pred’関数は、引数<x>で‘sign’と‘asksign’によってコールさ
     れます。 ここで、<x>はアトム、添字付き変数、関数コール式のいずれか
     です。 もし‘assume_pos_pred’関数が‘true’を返すなら、 <x>は、
     ‘assume_pos’のためのパラメータと考えられます。

     デフォルトでは、パラメータは、‘symbolp (<x>)’もしくは‘subvarp
     (<x>)’のような<x>です。

     ‘assume’と‘assume_pos’も参照してください。

     例:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg

 -- オプション変数: context
     デフォルト値: ‘initial’

     ‘context’は、‘assume’と‘forget’によって保守される事実の集まりの名前
     です。

     ‘assume’は、‘context’と名付けられた集まりに事実を追加する一方、
     ‘forget’は、事実を取り除きます。

     ‘context’を名前<foo>にバインドすることは、 現在の文脈を<foo>に変え
     ます。 もし指定された文脈<foo>がまだ存在しないなら、 ‘newcontext’の
     コールによって自動的に生成されます。 指定された文脈は自動的にアクテ
     ィベートされます。

     文脈メカニズムの一般的な記述に関しては、‘contexts’を参照してくださ
     い。

 -- オプション変数: contexts
     デフォルト値: ‘[initial, global]’

     ‘contexts’は、 現在アクティブな文脈を含んでいる、現在存在する文脈の
     リストです。

     文脈メカニズムは、ユーザーが 文脈と呼ばれる事実の集まりにバインドし
     、名付けることを可能にします。 一旦これがなされると、ユーザーは、 文
     脈を単にアクティベートしたりデアクティベートすることで、 たくさんの
     数の事実をMaximaに仮定させたり忘れさせたりできます。

     任意のシンボルのアトムは、文脈となりえ、 その文脈の中に含まれた事実
     は、 ‘forget’をコールすることで１つ１つ破壊されるまで、 あるいは、
     それらが属する文脈を破壊するために‘kill’をコールすることで、全体と
     して破壊されるまで、記憶装置に保持されます。

     文脈は階層的に存在します。 その根はいつも文脈‘global’であり、 文脈
     ‘global’は、いくつかの関数が必要とするMaximaについての情報を含みま
     す。 アクティブな文脈の部分文脈である任意の文脈の中の事実すべてそう
     であるように、 与えられた文脈の中では、 その文脈の中の事実すべては
     、「アクティブ」（それらが演繹や探索に使われるという意味） です。

     新鮮なMaximaが起動された時、 ユーザーは、‘initial’と呼ばれる文脈の
     中にいます。 それは、部分文脈として‘global’を持ちます。

     ‘facts’, ‘newcontext’, ‘supcontext’, ‘killcontext’, ‘activate’,
     ‘deactivate’, ‘assume’, ‘forget’も参照してください。

 -- 関数: deactivate (<context_1>, …, <context_n>)

     特定の文脈<context_1>, …, <context_n>をデアクティベートします。

 -- 関数: facts (<item>)
 -- 関数: facts ()

     もし<item>が文脈の名前なら、 ‘facts (<item>)’は指定された文脈の
     ‘facts’のリストを返します。

     もし<item>が文脈の名前でなければ、 ‘facts (<item>)’は現在の文脈の中
     で、 <item>について知っている‘facts’のリストを返します。 異なる文脈
     中のアクティブな‘facts’はリストされません。

     ‘facts ()’（すなわち引数なし）は現在の文脈をリストします。

 -- 関数: forget (<pred_1>, …, <pred_n>)
 -- 関数: forget (<L>)
     ‘assume’で規定された述語論理を取り除きます。 述語論理は以前に規定さ
     れたものと同値の（必ずしも同一である必要なない）式です。

     ‘forget (<L>)’（<L>は述語論理のリスト）は、 リスト上のそれぞれの項
     目を忘れます。

 -- 関数: is (<expr>)

     ‘assume’データベースの中の事実から述語論理<expr>が確かか否かを決定
     しようとします。

     もし述語論理が確かに‘true’もしくは‘false’なら、 ‘is’は、それぞれ
     ‘true’もしくは‘false’を返します。 そうでなければ、戻り値は、グロー
     バルフラグ‘prederror’に依存します。 ‘prederror’が‘true’の時、 ‘is’は
     エラーメッセージを出力します。 そうでなければ、‘is’は‘unknown’を出
     力します。

     ‘ev(<expr>, pred)’ (対話プロンプトでは、‘<expr>, pred’と書けます) は
     、‘is(<expr>)’と同値です。

     ‘assume’, ‘facts’, ‘maybe’も参照してください。

     例:

     ‘is’は述語論理の評価を引き起こします。

          (%i1) %pi > %e;
          (%o1)                       %pi > %e
          (%i2) is (%pi > %e);
          (%o2)                         true

     ‘is’は、‘assume’データベースから述語論理を演繹しようとします。

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) assume (b > c);
          (%o2)                        [b > c]
          (%i3) is (a < b);
          (%o3)                         false
          (%i4) is (a > c);
          (%o4)                         true
          (%i5) is (equal (a, c));
          (%o5)                         false

     もし‘is’が‘assume’データベースから述語論理を証明もしくは否定できな
     かったら、 グローバルフラグ‘prederror’が‘is’の振る舞いを決めます。

          (%i1) assume (a > b);
          (%o1)                        [a > b]
          (%i2) prederror: true$
          (%i3) is (a > 0);
          Maxima was unable to evaluate the predicate:
          a > 0
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) prederror: false$
          (%i5) is (a > 0);
          (%o5)                        unknown

 -- 関数: killcontext (<context_1>, …, <context_n>)

     文脈<context_1>, …, <context_n>を消します。

     もし文脈の１つが現在の文脈なら、 新しい文脈は、 消されなかった現在
     の文脈の最初の利用可能な部分文脈になるでしょう。 もし最初の利用可能
     な消されなかった文脈が‘global’なら、 ‘initial’が代わりに使われます
     。 もし‘initial’文脈が消されたら、 新しい、空の‘initial’文脈が生成
     されます。

     ‘killcontext’は、現在アクティブな文脈を消すことを拒否します。 なぜ
     なら、それは現在の文脈の部分文脈、もしくは 関数‘activate’の使用によ
     ってアクティブになっているから。

     ‘killcontext’は、引数を評価します。 ‘killcontext’は、‘done’を返しま
     す。

 -- 関数: maybe (<expr>)

     述語論理<expr>が‘assume’データベースの事実から正しいかどうかを 決定
     しようとします。

     もし述語論理が確かに‘true’もしくは‘false’なら、 ‘maybe’は、それぞれ
     ‘true’もしくは‘false’を返します。 そうでなければ、‘maybe’は
     ‘unknown’を返します。

     ‘maybe’は、‘prederror: false’での‘is’と関数的に同値です。 しかし、
     ‘prederror’に値を実際に割り当てることなく結果が計算されます。

     ‘assume’, ‘facts’, ‘is’も参照してください。

     例:

          (%i1) maybe (x > 0);
          (%o1)                        unknown
          (%i2) assume (x > 1);
          (%o2)                        [x > 1]
          (%i3) maybe (x > 0);
          (%o3)                         true

 -- 関数: newcontext (<name>)

     <name>と呼ばれる新しい、空の文脈を生成します。 <name>は、唯一の部分
     文脈として‘global’を持ちます。 新しく生成された文脈は現在アクティブ
     な文脈になります。

     ‘newcontext’は、引数を評価します。 ‘newcontext’は、<name>を返します
     。

 -- 関数: sign (<expr>)
     現在のデータベースの事実に基づいて<expr>の符号を決定しようとします
     。 以下の答えの１つを返します; ‘pos’ (positive), ‘neg’ (negative),
     ‘zero’, ‘pz’ (正もしくはゼロ), ‘nz’ (負もしくはゼロ), ‘pn’ (正もし
     くは負), or ‘pnz’ (正、負もしくはゼロ、すなわちなにもわからない).

 -- 関数: supcontext (<name>, <context>)
 -- 関数: supcontext (<name>)

     <name>と呼ばれる新しい文脈を生成します。 <name>は、部分文脈として
     <context>を持ちます。 <context>は存在しなければいけません。

     もし<context>が指定されないなら、 現在の文脈が仮定されます。


File: maxima.info,  Node: Functions and Variables for Predicates,  Prev: Functions and Variables for Facts,  Up: Maximas Database

11.4 Functions and Variables for Predicates
===========================================

 -- 関数: charfun (<p>)

     述語論理<p>が‘false’に評価される時、0を返します; 述語論理<p>が
     ‘true’に評価される時、1を返します。 述語論理が‘true’も‘false’でもな
     い何かに評価される時(unknown), 名詞形を返します。

     例:

          (%i1) charfun (x < 1);
          (%o1)                    charfun(x < 1)
          (%i2) subst (x = -1, %);
          (%o2)                           1
          (%i3) e : charfun ('"and" (-1 < x, x < 1))$
          (%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
          (%o4)                       [0, 1, 0]

 -- 関数: compare (<x>, <y>)

     ‘is (<x> <op> <y>)’が ‘true’に評価されるような比較演算子<op>
     (‘<’,‘<=’,‘>’,‘>=’,‘=’,‘#’)を返します; <x>か<y>が ‘%i’に依存して、
     ‘<x> # y’の時、 ‘notcomparable’を返します; 該当する演算子がなかった
     り、Maximaが演算子を決定できなかった時には ‘unknown’を返します。

     例:

          (%i1) compare (1, 2);
          (%o1)                           <
          (%i2) compare (1, x);
          (%o2)                        unknown
          (%i3) compare (%i, %i);
          (%o3)                           =
          (%i4) compare (%i, %i + 1);
          (%o4)                     notcomparable
          (%i5) compare (1/x, 0);
          (%o5)                           #
          (%i6) compare (x, abs(x));
          (%o6)                          <=

     関数‘compare’は引数の実領域が空でないか決定しようとはしません; 従っ
     て、

          (%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
          (%o1)                           <

     ‘acos (x^2 + 1)’の実領域は空です。

 -- 特殊演算子: constant

     ‘declare (<a>, constant)’は、<a>を定数に宣言します。 ‘declare’を参
     照してください。

 -- 関数: constantp (<expr>)

     もし<expr>が定数式なら、‘true’を返します。 そうでなければ、
     ‘false’を返します。

     もし引数が、（‘/R/’をつけて表示される有理数を含む）数や ‘%pi’,
     ‘%e’, ‘%i’にようなシンボル定数、 定数にバインドされた変数、
     ‘declare’で宣言された定数、 引数が定数の関数のいずれかなら、 式は定
     数式と考えられます。

     ‘constantp’は引数を評価します。

     例:

          (%i1) constantp (7 * sin(2));
          (%o1)                                true
          (%i2) constantp (rat (17/29));
          (%o2)                                true
          (%i3) constantp (%pi * sin(%e));
          (%o3)                                true
          (%i4) constantp (exp (x));
          (%o4)                                false
          (%i5) declare (x, constant);
          (%o5)                                done
          (%i6) constantp (exp (x));
          (%o6)                                true
          (%i7) constantp (foo (x) + bar (%e) + baz (2));
          (%o7)                                false
          (%i8)

 -- 関数: equal (<a>, <b>)

     同値、すなわち、同じ値であることを表します。

     ‘equal’はそれ自身で評価も整理もされません。 関数‘is’は、‘equal’をブ
     ーリアン値に評価しようとします。 ‘is(equal(<a>, <b>)’は、 もし<a>と
     <b>が、‘ratisimp(<a> - <b>)’を評価することで決定されるように、 変数
     の可能な値すべてで等しいときだけ‘true’を返します; もし‘ratsimp’が
     0を返したら、２つの式は同値と考えれます。 ２つの式は構文法的に等し
     くなくても（すなわち同一でなくても）同値でありえます。

     ‘is’が‘equal’を‘true’もしくは‘false’への換算に失敗した時、 結果は、
     グローバルフラグ‘prederror’に依ります。 ‘prederror’が‘true’の時、
     ‘is’はエラーメッセージを出力します。 そうでなければ、‘is’は
     ‘unknown’を返します。

     ‘is’に加えて、 いくつかの他の演算子、‘if’, ‘and’, ‘or’, ‘not’は
     ‘equal’と‘notequal’を‘true’もしくは‘false’に評価します。

     ‘equal’の否定が‘notequal’です。

     例:

     ‘equal’はそれ自身で評価も整理もされません。

          (%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                                  2
          (%o1)            equal(x  - 1, (x - 1) (x + 1))
          (%i2) equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) equal (x, y);
          (%o3)                      equal(x, y)

     関数‘is’は、‘equal’をブーリアン値に評価しようとします。
     ‘is(equal(<a>, <b>)’は、 ‘ratisimp(<a> - <b>)’が0を返すとき‘true’を
     返します。 ２つの式は構文法的に等しくなくても（すなわち同一でなくて
     も）同値でありえます。

          (%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
          (%o1)                           0
          (%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
          (%o2)                         true
          (%i3) is (x^2 - 1 = (x + 1) * (x - 1));
          (%o3)                         false
          (%i4) ratsimp (x - (x + 1));
          (%o4)                          - 1
          (%i5) is (equal (x, x + 1));
          (%o5)                         false
          (%i6) is (x = x + 1);
          (%o6)                         false
          (%i7) ratsimp (x - y);
          (%o7)                         x - y
          (%i8) is (equal (x, y));
          (%o8)                        unknown
          (%i9) is (x = y);
          (%o9)                         false

     ‘is’が、‘equal’を‘true’もしくは‘false’への換算に失敗したとき、 結果
     は、グローバルフラグ‘prederror’に依ります。

          (%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                              2             2
          (%o1)             [x  + 2 x + 1, x  - 2 x - 1]
          (%i2) ratsimp (aa - bb);
          (%o2)                        4 x + 2
          (%i3) prederror : true;
          (%o3)                         true
          (%i4) is (equal (aa, bb));
          Maxima was unable to evaluate the predicate:
                 2             2
          equal(x  + 2 x + 1, x  - 2 x - 1)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) prederror : false;
          (%o5)                         false
          (%i6) is (equal (aa, bb));
          (%o6)                        unknown

     いくつかの演算子が‘equal’や‘notequal’を ‘true’もしくは‘false’に評価
     します。

          (%i1) if equal (y, y - 1) then FOO else BAR;
          (%o1)                          BAR
          (%i2) eq_1 : equal (x, x + 1);
          (%o2)                    equal(x, x + 1)
          (%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                                   2                   2
          (%o3)             equal(y  + 2 y + 1, (y + 1) )
          (%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
          (%o4)                  [false, true, true]

     ‘not <expr>’は、<expr>の評価を伴うので、 ‘not equal(<a>, <b>)’は、
     ‘is(notequal(<a>, <b>))’と同値です。

          (%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
          (%o1)            [notequal(2 z, 2 z - 1), true]
          (%i2) is (notequal (2*z, 2*z - 1));
          (%o2)                         true

 -- 関数: notequal (<a>, <b>)

     ‘equal(<a>, <b>)’の否定を表します。

     例:

          (%i1) equal (a, b);
          (%o1)                      equal(a, b)
          (%i2) maybe (equal (a, b));
          (%o2)                        unknown
          (%i3) notequal (a, b);
          (%o3)                    notequal(a, b)
          (%i4) not equal (a, b);
          (%o4)                    notequal(a, b)
          (%i5) maybe (notequal (a, b));
          (%o5)                        unknown
          (%i6) assume (a > b);
          (%o6)                        [a > b]
          (%i7) equal (a, b);
          (%o7)                      equal(a, b)
          (%i8) maybe (equal (a, b));
          (%o8)                         false
          (%i9) notequal (a, b);
          (%o9)                    notequal(a, b)
          (%i10) maybe (notequal (a, b));
          (%o10)                        true

 -- 関数: unknown (<expr>)]

     <expr>がMaximaの整理器が認識しない演算子や関数を含む時だけ、
     ‘true’を返します。

 -- 関数: zeroequiv (<expr>, <v>)

     変数<v>の式<expr>がゼロと同値かどうかテストし、 ‘true’, ‘false’, も
     しくは‘dontknow’を返します。

     ‘zeroequiv’は以下の制限を持ちます:

       1. Maximaが微分や評価する方法を知らない関数を使わない。
       2. もし式が実線上で極を持つなら、 結果としてエラーになります。（
          しかしこれは起こりにくいことです。）
       3. もし式が１階微分方程式の解ではない関数（例えばベッセル関数）を
          含むなら、 正しくない結果になるかもしれません。
       4. アルゴリズムは、注意深く選ばれた部分式に関してランダムに選ばれ
          た点での評価を使います。 アルゴリズムはエラーの可能性を細小に
          しようとしますが、これはいつも危険な仕事です。

     例えば、‘zeroequiv (sin(2 * x) - 2 * sin(x) * cos(x), x)’は‘true’を
     返し、 ‘zeroequiv (%e^x + x, x)’は‘false’を返します。 一方、
     ‘zeroequiv (log(a * b) - log(a) - log(b), a)’は、 余分なパラメータ
     ‘b’があるので、‘dontknow’を返します。


File: maxima.info,  Node: Plotting,  Next: File Input and Output,  Prev: Maximas Database,  Up: Top

12 Plotting
***********

* Menu:

* Introduction to Plotting::
* Plotting Formats::
* Functions and Variables for Plotting::
* Plotting Options::
* Gnuplot Options::
* Gnuplot_pipes Format Functions::


File: maxima.info,  Node: Introduction to Plotting,  Next: Plotting Formats,  Prev: Plotting,  Up: Plotting

12.1 Introduction to Plotting
=============================

Maximaは、プロットするために、外部のプロットパッケージを使います （以下
のPlottingフォーマットを参照してください）。 プロット関数は、点一式を計
算し、コマンド一式と一緒にプロットパッケージに渡します。 その情報は、パ
イプを通したり、 データが保存されたファイル名と共にプログラムをコールす
ることで、 外部のプログラムに渡されます。 データファイルは名前
‘maxout.interface’を与えられます。 ‘interface’は使われるプロットインター
フェース名 (gnuplot, xmaxima, mgnuplotまたはgnuplot_pipes)です。

   ‘maxout.interface’ファイルが使われる場合、 システム変数
<maxima_tempdir>で指定されたディレクトリに生成されます。 場所は変更でき
ます; その変数に、Maximaが新しいファイルを作ることができる有効なディレク
トリ を示す文字列を割り当てることで。

   プロットが生成さられた後でも、 ファイル‘maxout.interface’は、 適切な
外部のプログラムで再度実行することができます。 もしMaximaのプロットコマ
ンドが何かを表示するのに失敗したなら、 問題の可能性のある元をファイルで
調べることができます。

   この章で記述されたプロット関数と合わせて、 パッケージ ‘draw’は他の機
能を加えます。 いくつかのプロットオプションはどちらのプロット文脈でも同
じ名前が付けられていますが、 異なる構文を持つことに注意してください; も
しこれらのオプションに関係した描画情報をアクセスしたいなら、 ‘?? opt’と
タイプしなければいけません。ここで、‘opt’はオプション名です。


File: maxima.info,  Node: Plotting Formats,  Next: Functions and Variables for Plotting,  Prev: Introduction to Plotting,  Up: Plotting

12.2 Plotting Formats
=====================

現在、Maximaが使う２つの外部のプロットプログラムがあります: Gnuplotと
Xmaximaです。 これらのプログラムに対して様々な異なるフォーマットがありま
す。 それらは、オプション‘plot_format’で選択することができます。
(Plotting Options節を参照してください。)

   プロットフォーマットは以下の通りです:

   • *gnuplot* (Windowsでのデフォルト)

     外部のプログラムgnuplotを起動するのに使われます。 gnuplotはあなたの
     システムにインストールされていなければいけません。 すべてのプロット
     コマンドとデータは、ファイル‘maxout.gnuplot’に保存されます。

   • *gnuplot_pipes* (Windows以外のプラットフォームでのデフォルト)

     このフォーマットはWindowsプラットフォームでは利用できません。
     ‘gnuplot’フォーマットと似ていますが、 データがファイル
     ‘maxout.gnuplot_pipes’に保存される一方、 コマンドがパイプを通して
     gnuplotに送られるところが違います。 gnuplotパイプが関数
     ‘gnuplot_close()’で閉じられない限り、 １つのgnuplotプロセスが開き続
     けて、続きのプロットコマンドは同じプロセスに送られ、 以前のプロット
     を置き換えます。 このフォーマットが使われる時、関数
     ‘gnuplot_replot’は スクリーン上に既に表示されたプロットを変更するの
     に使うことができます。 (‘gnuplot_replot’を参照してください。)

     このフォーマットはスクリーンへのプロットするのにだけ使うべきです; フ
     ァイルへのプロットには‘gnuplot’フォーマットを使ったほうがいいです。

   • 値: ‘mgnuplot’

     Mgnuplotは、gnuplotのTkベースのラッパーです。 Maximaディストリビュ
     ーションに含まれます。 Mgnuplotはgnuplotの基本的なGUIを提供しますが
     、gnuplotの素のインターフェースより 総合的な特長が少ないです。
     Mgnuplotは、gnuplotとTckl/Tkを別途インストールする必要があります。

   • *xmaxima*

     XmaximaはMaxima用Tcl/Tkグラフィカルインターフェースです。 これもま
     た、コンソールや他のグラフィカルインターフェースからMaximaを走らせ
     た時、 生成されるプロットを表示するのに使うことができます。 このフ
     ォーマットを使うには、xmaximaプログラム―これはMaximaと一緒に配布さ
     れます― をインストールする必要があります。 もしMaximaをxmaxima自身
     から走らせるなら、 このフォーマットは、MaximaとXmaximaの間の通信に
     使われているのと同じソケットを通して、 プロット関数にデータとコマン
     ドを送らせます。 コンソールや他のインターフェースから使われる時、
     xmaximaプログラムはそのファイルの位置の名前を引数として起動されます
     。

     以前のバージョンでは、このフォーマットは‘openmath’と呼ばれていまし
     た; その古い名前はまだ‘xmaxima’に対する同義語として受け付けられます
     。


File: maxima.info,  Node: Functions and Variables for Plotting,  Next: Plotting Options,  Prev: Plotting Formats,  Up: Plotting

12.3 Functions and Variables for Plotting
=========================================

 -- 関数: contour_plot (<expr>, <x_range>, <y_range>, <options>, …)

     <expr>の等高線を、領域<x_range>、<y_range>でプロットします。 他の引
     数は、‘plot3d’と同じように扱われます。

     この関数は、プロットフォーマットが‘gnuplot’か‘gnuplot_pipes’の時だ
     け、 動作します。 付加パッケージ‘implicit_plot’も等高線をプロットす
     るのに使われ、 それは任意のフォーマットで動作します。
     ‘implicit_plot’も参照してください。

     例:

          (%i1) contour_plot (x^2 + y^2, [x, -4, 4], [y, -4, 4])$

          (%i1) F(x, y) := x^3 + y^2;
                                             3    2
          (%o1)                  F(x, y) := x  + y
          (%i2) contour_plot (F, [u, -4, 4], [v, -4, 4])$

     ‘plot3d’が受け付ける任意のオプションを足すことができます; 例えば、
     オプション‘legend’にfalseの値を入れると、凡例を取り除きます。
     Gnuplotはデフォルトで3つの高等線を示すように選びます。 レベルの数を
     増やすには、カスタムのgnuplot前置きを指定する必要があります;

          (%i1) contour_plot (u^3 + v^2, [u, -4, 4], [v, -4, 4],
                              [legend,false],
                              [gnuplot_preamble, "set cntrparam levels 12"])$

 -- 関数: get_plot_option (<keyword>, <index>)

     グローバル変数‘plot_options’に保存されている 名前<keyword>を持つオ
     プションの値を返します。 添字で1の値はキーワード自身を返します; 2番
     の値はキーワードに続く一番目のパラメータを返す、などなど。

     ‘plot_options’や‘set_plot_option’、Plotting Optionの節も参照してく
     ださい。

 -- 関数: make_transform ([<var1>, <var2>, <var3>], <fx>, <fy>, <fz>)

     plot3dのオプション‘transform_xy’で使われるのに適した関数を返します
     。 3つの変数<var1>, <var2>, <var3>は3つのダミー変数名です。 それら
     は、plot3dコマンドが与える3変数 (最初2つの独立変数と、その後それら
     2つの変数に依存する関数)を表します。 3つの関数<fx>, <fy>, <fz>は、
     それら3変数にだけ依存しなければいけなく、プロットすべき対応するx,
     y, z座標を与えます。 デフォルトで定義された2つの変換があります;
     ‘polar_to_xy’と‘spherical_to_xyz’; それら2つの変換に関するドキュメ
     ンテーションを参照してください。

 -- システム関数: polar_to_xy

     plot3dの‘transform_xy’オプションに対する値として与えることができま
     す。 その効果はplot3dの2つの独立変数をz軸からの距離と方位角(極座標
     )として通訳し、 それらをxとy座標に変換することです。

 -- 関数: plot2d (<plot>, <x_range>, …, <options>, …)
 -- 関数: plot2d ([<plot_1>, …, <plot_n>], …, <options>, …)
 -- 関数: plot2d ([<plot_1>, …, <plot_n>], <x_range>, …, <options>, …)

     ここで、<plot>, <plot_1>, …, <plot_n>は式か関数名、もしくは以下のい
     ずれかの形式のリストです:

     ‘[discrete, [<x1>, ..., <xn>], [<y1>, ..., <yn>]]’, ‘[discrete,
     [[<x1>, <y1>], ..., [<xn>, ..., <yn>]]’, または‘[parametric,
     <x_expr>, <y_expr>, <t_range>]’.

     １つもしくは複数の式を１変数か1パラメータの関数としてプロット表示し
     ます。

     ‘plot2d’は1つもしくは複数のプロットを2次元に表示します。 プロットを
     定義するのに式や関数名を使う時には、 それらは１変数<var>だけに依存
     すべきであり、 変数名とその最小値と最大値を提供するために
     <x_range>の使用が必須です; <x_range>の構文法は以下の通りです:

     ‘[<variable>, <min>, <max>]’

     プロットを、離散形式やパラメトリック形式で定義することもできます。
     離散形式は既定の座標で表された点の集合をプロットするのに使われます
     。 離散プロットは、キーワード<discrete>で始まり、 値についてのリス
     ト1つか2つが続くリストで定義されます。 もし2つのリストが与えられた
     ら、それらは同じ長さを持たなければいけません; 1番目のリストはプロッ
     トされる点のx座標として、 2番目のリストはy座標として解釈されます。
     もし<discrete>キーワードの後、1つのリストだけ与えられたら、 リスト
     上のそれぞれの要素は、点のxとy座標に対応する2つの値を持つリストでな
     ければいけません。

     パラメトリックプロットは、 キーワード<parametric>で始まり、 2つの式
     か関数名と、パラメータの範囲が続くリストで定義されます。 パラメータ
     の範囲は、パラメータ名とその最小値、最大値が続くリストでなければい
     けません:

     ‘[<param>, <min>, <max>]’。

     <param>が<min>から<max>に増えるにつれ、 2つの式または関数で与えられ
     る座標の点によって描かれる軌跡をプロットは表示します。

     垂直軸の範囲は以下の形式を持つオプション引数です:

     ‘[y, <min>, <max>]’(キーワード<y>はいつも垂直軸に使われます)。

     もしこのオプションを使ったなら、 プロットが到達する値と別に、ちょう
     どオプションの垂直範囲をプロットは表示します。 もし垂直範囲を指定し
     なかったなら、プロット点のy座標の最小値と最大値に従って、 垂直範囲
     が設定されます。

     他のすべてのオプションも、 キーワードで始まり、1つか複数の値が続く
     リストでなければいけません。 ‘plot_options’を参照してください。

     もし複数のプロットがプロットされるなら、式のそれぞれを識別するため
     に凡例が書かれます。 その凡例で使われるラベルは、オプション
     <legend>で与えることができます。 もしそのオプションが使われないなら
     、Maximaは式や関数名からラベルを生成します。

     *例:*

     よくある関数のプロット:

          (%i1) plot2d (sin(x), [x, -%pi, %pi])$

     もし関数の増大が速すぎるなら、yオプションを使って、垂直軸の値を制限
     する必要があるかもしれません:

          (%i1) plot2d (sec(x), [x, -2, 2], [y, -20, 20])$
          plot2d: some values were clipped.

     プロットの外観は使うプロットプログラムに依存して異なるかもしれませ
     ん。 プロットボックスが使用不可能になっている時、Xmaximaは矢印を使
     って軸をプロットします:

          (%i1) plot2d ( x^2-1, [x, -3, 3], [y, -2, 10],
                                [box, false], [plot_format, xmaxima])$

     対数プロットの例:

          (%i11) plot2d (exp(3*s), [s, -2, 2], [logy])$

     関数を名前でプロット:

          (%i1) F(x) := x^2 $
          (%i2) :lisp (defun |$g| (x) (m* x x x))
          $g
          (%i2) H(x) := if x < 0 then x^4 - 1 else 1 - x^5 $
          (%i3) plot2d ([F, G, H], [u, -1, 1], [y, -1.5, 1.5])$

     パラメトリックに定義されたバタフライカーブのプロット:

          (%i1) r: (exp(cos(t))-2*cos(4*t)-sin(t/12)^5)$
          (%i2) plot2d([parametric, r*sin(t), r*cos(t),
                       [t, -8*%pi, 8*%pi], [nticks, 2000]])$

     7点だけでプロットする時の2回転「円」:

          (%i1) plot2d ([parametric, cos(t), sin(t),
                        [t, -2*%pi, 2*%pi], [nticks, 8]])$

     円のパラメトリック表現と一緒に、よくある関数のプロット。 プロットの
     サイズは、円を丸く、楕円のように変形しないように、 xとyオプションで
     調整されています。 これらの値は、このプロットを生成するのに使われた
     Postscript端末ではうまく機能します; あなたはあなたのスクリーンのた
     めに値を調整しなければいけないかもしれません。

          (%i1) plot2d([[parametric, cos(t), sin(t),
                        [t,0,2*%pi], [nticks, 80]],
                  abs(x)], [x,-2,2], [y, -1.5, 1.5])$
          plot2d: some values were clipped.

     x座標、y座標を別々に定義した点の離散集合のプロット:

          (%i1) plot2d ([discrete, [10, 20, 30, 40, 50],
                                   [.6, .9, 1.1, 1.3, 1.4]])$

     それぞれの点を別々に定義し、点を繋ぐ線をなくした、前の例で示された
     同じ点:

          (%i1) plot2d([discrete, [[10, .6], [20, .9], [30, 1.1],
                                   [40, 1.3], [50, 1.4]]],
                                  [style, points])$

     この例では、3つの列を持つテーブルがファイル”data.txt”に保存され、 読
     み込まれ、2番目、3番目の列は2つの軸上にプロットされます:

          (%i1) with_stdout ("data.txt", for x:0 thru 10 do
                                             print (x, x^2, x^3))$
          (%i2) data: transpose ( read_matrix ("data.txt"))$
          (%i3) plot2d ([discrete, transpose(data)[2], transpose(data)[3]],
            [style,points], [point_type,diamond], [color,red])$

     実験データ点を、データを予測する理論的関数と一緒にプロット:

          (%i1) xy: [[10, .6], [20, .9], [30, 1.1], [40, 1.3], [50, 1.4]]$
          (%i2) plot2d([[discrete, xy], 2*%pi*sqrt(l/980)], [l,0,50],
                  [style, points, lines], [color, red, blue],
                  [point_type, asterisk],
                  [legend, "experiment", "theory"],
                  [xlabel, "pendulum's length (cm)"],
                  [ylabel, "period (s)"])$

     プロットオプションに関する節も参照してください。

 -- 関数: plot3d (<expr>, <x_range>, <y_range>, …, <options>, …)
 -- 関数: plot3d ([<expr_1>, <expr_2>, <expr_3>], <x_range>, <y_range>,
          …, <options>, …)

     ２変数関数もしくはパラメトリック形式で定義された、１つか複数の表面
     のプロットを表示します。

     プロットされる関数は、式か関数名として指定できます。 違った側面から
     表面を見るためにマウスを使ってプロットを回転することができます。

     *例:*

     よくある関数のプロット:

          (%i1) plot3d (2^(-u^2 + v^2), [u, -3, 3], [v, -2, 2]);

     無限大に発散する関数を制限するためのzオプションの使用(この場合、関
     数はxとy軸上でマイナス無限だい); これは線のみ陰影なしでプロットする
     仕方も示します。

          (%i1) plot3d ( log ( x^2*y^2 ), [x, -2, 2], [y, -2, 2], [z, -8, 4],
                         [palette, false], [color, magenta, blue])$

     zの無限大は、いかなる漸近線上にも落ちないグリッドを選ぶことによって
     も避けることができます; この例は事前に定義されたパレットの1つ、この
     場合4番目のものを選択する仕方も示します:

          (%i1) plot3d( log (x^2*y^2), [x, -2, 2], [y, -2, 2],
                   [grid, 29, 29],
                   [palette, get_plot_option(palette,5)])$

     同じ領域を共有する同じプロットでの2つの表面; gnuplotでは2つの表面は
     同じパレットを使用します:

          (%i1) plot3d ([2^(-x^2 + y^2), 4*sin(3*(x^2+y^2))/(x^2+y^2),
                        [x, -3, 3], [y, -2, 2]])$

     異なる領域を持つ、同じ2つの表面; xmaximaでは、それぞれの表面は、オ
     プションパレットで定義されたリストから選ばれた 異なるパレットを使い
     ます:

          (%i1) plot3d ( [[2^(-x^2 + y^2),[x,-2,2],[y,-2,2]],
                   4*sin(3*(x^2+y^2))/(x^2+y^2),
                   [x, -3, 3], [y, -2, 2]], [plot_format,xmaxima])$

     パラメトリックに定義されたKleinの壷のプロット:

          (%i1) expr_1:5*cos(x)*(cos(x/2)*cos(y)+sin(x/2)*sin(2*y)+3.0)-10.0$
          (%i2) expr_2:-5*sin(x)*(cos(x/2)*cos(y) + sin(x/2)*sin(2*y) + 3.0)$
          (%i3) expr_3: 5*(-sin(x/2)*cos(y) + cos(x/2)*sin(2*y))$
          (%i4) plot3d ([expr_1, expr_2, expr_3], [x, -%pi, %pi],
                  [y, -%pi, %pi], [grid, 40, 40])$

     球座標から直交座標に変換するのにあらかじめ定義された変換
     ‘spherical_to_xyz’ を使った球調和のプロット。 ‘spherical_to_xyz’に
     関するドキュメンテーションを参照してください。

          (%i1) plot3d (sin(2*theta)*cos(phi), [theta, 0, %pi],
                        [phi, 0, 2*%pi],
                        [transform_xy, spherical_to_xyz], [grid,30,60])$

     円筒座標から直交座標に変換するのにあらかじめ定義された変換
     ‘polar_to_xyz’ を使った球面調和関数のプロット。 ‘polarl_to_xyz’に関
     するドキュメンテーションを参照してください。 この例は境界ボックスと
     凡例を消去する仕方も示します。
          (%i1) plot3d (r^.33*cos(th/3), [r, 0, 1], [th, 0, 6*%pi],
                   [grid, 12, 80],
                   [transform_xy, polar_to_xy], [box, false],
                   [legend,false])$

     球座標から直交座標への変換を使っての球のプロット。 xmaximaでは、球
     の対称形を維持するように3つの軸は同じ比でスケールされます。 同一色
     で異なる陰影のパレットが使われます:

          (%i1) plot3d ( 5, [theta, 0, %pi], [phi, 0, 2*%pi],
                   [plot_format,xmaxima],
                   [transform_xy, spherical_to_xyz],
                   [palette,[value,0.65,0.7,0.1,0.9]])$

     行列を使った2変数関数の定義。 関数の定義の中のシングルクォートに注
     意してください。 行列が整数添字を要求する状況に実際に至る時、
     plot3dが失敗しないためのものです。

          (%i1) M: matrix([1, 2, 3, 4], [1, 2, 3, 2], [1, 2, 3, 4],
                          [1, 2, 3, 3])$
          (%i2) f(x, y) := float('M [round(x), round(y)])$
          (%i3) plot3d (f(x,y), [x, 1, 4], [y, 1, 4], [grid, 4, 4])$
          apply: subscript must be an integer; found: round(x)

     elevationを零の等しく設定することで， 表面は地図として見ることがで
     きます。 その地図は、それぞれの色は違ったレベルを表現します。 オプ
     ション‘colorbox’は、 色とレベルの対応を示すのに使われます。 メッシ
     ュ線を使用不可にし、色が見やすいようにしています。
          (%i1) plot3d (cos (-x^2 + y^3/4), [x, -4, 4], [y, -4, 4],
                  [mesh_lines_color, false], [elevation, 0], [azimuth, 0],
                  [colorbox, true], [grid, 150, 150])$

     プロットオプションについての節も参照してください。

 -- システム変数: plot_options

     このリストの要素は、プロットのデフォルトオプションを指定します。 も
     し‘plot2d’もしくは‘plot3d’がコールされる時、オプションが指定された
     ら、 その値は、デフォルトオプションより優先されます。 そうでなけれ
     ば、‘plot_options’の中の値が使われます。 デフォルトオプションは、
     ‘set_plot_option’を使って割り当てられます。 それぞれのプロットコマ
     ンドに特化したローカルオプションがあり、それらは、この、グローバル
     オプションのリストには含まれません。

     ‘plot_options’のそれぞれの要素は、２つ以上の項目のリストです。 最初
     の項目はオプション名で、残りはオプションに割り当てられる値です。 い
     くつかの場合、割り当てられた値はリストであり、複数の項目からなるこ
     とがあります。

     ‘set_plot_option’と‘get_option’、プロットオプションの節も参照してく
     ださい。

 -- 関数: set_plot_option (<option>)

     プロットオプションの節にリストされているオプションのほとんどを受け
     付け、 それらをグローバル変数‘plot_options’に保存します。

     ‘set_plot_option’は引数を評価し、 (与えられたオプションを変更した後
     、)完全なリスト‘plot_options’を返します。

     ‘plot_options’と‘get_option’、プロットオプションの節も参照してくだ
     さい。

     例:

     ‘grid’値の変更。

          (%i1) set_plot_option ([grid, 30, 40]);
          (%o1) [[t, - 3, 3], [grid, 30, 40], [transform_xy, false],
          [run_viewer, true], [axes, true], [plot_format, gnuplot_pipes],
          [color, blue, red, green, magenta, black, cyan],
          [point_type, bullet, circle, plus, times, asterisk, box, square,
          triangle, delta, wedge, nabla, diamond, lozenge],
          [palette, [hue, 0.25, 0.7, 0.8, 0.5],
          [hue, 0.65, 0.8, 0.9, 0.55], [hue, 0.55, 0.8, 0.9, 0.4],
          [hue, 0.95, 0.7, 0.8, 0.5]], [gnuplot_term, default],
          [gnuplot_out_file, false], [nticks, 29], [adapt_depth, 5],
          [gnuplot_preamble, ], [gnuplot_default_term_command,
          set term pop], [gnuplot_dumb_term_command, set term dumb 79 22],
          [gnuplot_ps_term_command, set size 1.5, 1.5;set term postscript ¥
          eps enhanced color solid 24], [plot_realpart, false]]

 -- システム関数: spherical_to_xyz

     plot3dの‘transform_xy’オプションに対する値として与えることができま
     す。 その効果はplot3dでの2つの独立変数と関数を点の球座標 (1番目は
     z軸に対する角度、次にxy射影のx軸に対する角度、最後に原点からの距離)
     として解釈し、それらをx,y,z座標に変換することです。


File: maxima.info,  Node: Plotting Options,  Next: Gnuplot Options,  Prev: Functions and Variables for Plotting,  Up: Plotting

12.4 Plotting Options
=====================

すべてのオプションは、この節のキーワードの1つで始まり、 1つ以上の値が続
くリストで構成されます。 オプションのほとんどは (<plot2d>, <plot3d>,
<contour_plot>, <implicit_plot>) どのプロットコマンドでも。また関数
<set_plot_option>の中でも使うことができます; 例外は以下のリストで指定さ
れます。

 -- プロットオプション: adapt_depth [adapt_depth, <integer>]

     適応プロットルーチンで使われる分割の最大数です。

     デフォルト値: 5

 -- プロットオプション: axes [axes, <symbol>]

     ここで、<symbol>は‘true’, ‘false’, ‘x’, ‘y’のいずれかでありえます。
     もし‘false’なら、軸は表示されません; もし‘x’か‘y’に等しいなら、xか
     y軸のみが表示され、 ‘true’に等しいなら、両方の軸が表示されます。 こ
     のオプションはplot2dとimplicit_plotだけが使います。

     デフォルト値: ‘true’

 -- プロットオプション: azimuth [azimuth, <number>]

     plot3dプロットは plot2dと同様の水平軸と垂直軸に関してx軸とy軸と、 紙
     から垂直に出てくるz軸で始まるものと考えることができます。 z軸はその
     後x軸の回りに‘elevation’に等しい角度だけ回転され、 その後、xy平面は
     新しいz軸の回りに角度‘azimuth’だけ回転されます。 このオプションは
     azimuthに関する値を単位、度で設定します。

     デフォルト値: 30

     ‘elevation’も参照してください。

 -- プロットオプション: box [box, <symbol>]

     もし‘true’に設定されるなら、 境界枠がプロットに表示されます; もし
     ‘false’に設定されるなら、 枠は表示されません。

     デフォルト値: ‘true’

 -- プロットオプション: color [color, <color_1>, …, <color_n>]

     plot2dとimplicit_plotでは、様々な曲線の色を定義します。 plot3dでは
     、パレットが使われない時、表面のメッシュ線の色を定義します; 表面の
     片方の側面は色‘color_1’を持ち、逆の側面は<color_2>を(またはもし1つ
     の色しかないなら、同じ色を)持ちます。

     もし色よりも曲線や表面が多いなら、色は順に繰り返されます。 gnuplotを
     使う時、色は、 青、赤、緑、マゼンタ、シアンまたは黒です; xmaximaで
     は、色はそれらもしくは文字#で始まり、6桁の16進数字が続く文字列です;
     2つは赤成分、2つは緑成分、2つが青成分です。 もし未知の色の名前が与
     えられたら、黒が代わりに使われます。

     デフォルト値: blue, red, green, magenta, black, byan

 -- プロットオプション: colorbox [colorbox, <symbol>]

     ここで、<symbol>は‘true’か‘false’であり得ます。 もし‘true’なら、
     plot3dはzの違った値を表現するために、 違った色のパレットを使う時は
     いつでも、 zの値の大きさに従って使われた色を示す枠が右に示されます
     。 このオプションはxmaximaでは機能しません。

     デフォルト値: ‘false’

 -- プロットオプション: elevation [elevation, <number>]

     plot3dプロットは plot2dでの水平と垂直軸にxとy軸に 紙から直立に立っ
     たz軸から始まると考えられます。 その後、z軸はx軸の回りを
     ‘elevation’に等しい角度だけ回転し、 xy平面は新しいz軸の回りを
     ‘azimuth’角度だけ回転します。 このオプションはelevationの値を度単位
     で設定します。

     デフォルト値: 60

     ‘azimuth’も参照してください。

 -- プロットオプション: grid [grid, <integer>, <integer>]

     3次元プロットのためにx方向、y方向で使われるグリッド点の数を設定しま
     す。

     デフォルト値: 30, 30

 -- プロットオプション: legend [legend, <string_1>, …, <string_n>]
 -- プロットオプション: legend [legend, <false>]

     複数のプロットが示される時、プロットのラベルを指定します。 もし与え
     られたラベルの数より多くの式があるなら、ラベルは繰り返されます。 も
     し値‘false’が与えられるなら、凡例は表示されません。 デフォルトでは
     、式や関数の名前が使われます。また、点の離散集合に関しては、 単語
     discrete1, discrete2, …が使われます。 このオプションは
     <set_plot_optiion>で設定することができます。

 -- プロットオプション: logx [logx]

     水平軸を対数的にスケールするようにします。 <set_plot_option>では使
     うことはできません。

 -- プロットオプション: logy [logy]

     垂直軸を対数的にスケールするようにします。 <set_plot_option>では使
     うことはできません。

 -- Plot option: mesh_lines_color [mesh_lines_color, <color>]

     パレットが使われる時、plot3dがメッシュ線を描くのに使う色を設定しま
     す。 オプション ‘color’と同じ色を受け付けます。 (‘color’で許される
     色のリストを参照してください。) 値 ‘false’を与えて、メッシュ線を完
     全に消すこともできます。

     デフォルト値: black

 -- プロットオプション: nticks [nticks, <integer>]

     plot2dで関数をプロットする時、 関数をプロットするための適応プロット
     ルーチンによって使われる点の数の初期値を与えます。 plot2dやplot3dで
     パラメトリック関数をプロットする時、 プロットで表示される点の数を設
     定します。

     デフォルト値: 29

 -- プロットオプション: palette [palette, [<palette_1>], ...,
          [<palette_n>]]
 -- プロットオプション: palette [palette, <false>]

     1つのパレットか複数のパレットのリストで構成されます。 それぞれのパ
     レットは4つの数が続くキーワード付きリストです。 最初の3つの数は、
     0と1の間でなければならず、 zの最小値に割り当てられる基本色の色調と
     飽和、値を定義します。 キーワードは3つの属性(色調、飽和、値)のいず
     れかがzの値に従っての増えることを指定します。 その最後の数は1よりも
     大きいこともマイナスでもありえます; 変更された属性の対応する値は法
     1で丸められます。

     gnuplotはリストの中の最初のパレットだけを使います; xmaximaは、複数
     の表面が一緒にプロットされる時、リストの中のパレットを順に使います;
     パレットの数が尽きたら、それらは順に繰り返されます。

     メッシュ線の色はオプション‘mesh_lines_color’で与えられます。 もし
     ‘palette’が値‘false’を与えられたら、 表面は陰影されず、曲線のメッシ
     ュだけで表されます。 その場合、線の色はオプション‘color’で決定され
     ます。

     デフォルト値: [hue, 0.25, 0.7, 0.8, 0.5], [hue, 0.65, 0.8, 0.9,
     0.55], [hue, 0.55, 0.8, 0.9, 0.4], [hue, 0.95, 0.7, 0.8, 0.5]

 -- プロットオプション: plot_format [plot_format, <format>]

     ここで<format>は以下のいずれかです; gnuplot, xmaxima, mgnuplot,
     gnuplot_pipes.

     プロットで使われるフォーマットを設定します。

     デフォルト値: Windowsシステムではgnuplot, 他のシステムでは
     gnuplot_pipes

 -- プロットオプション: plot_real_part [plot_real_part, <symbol>]

     ‘true’に設定される時、プロットされる関数は 実数値がプロットされる複
     素関数と見なされます; これは‘realpart(<function>)’をプロットするこ
     とと同値です。 もし‘false’に設定されたら、 関数が実数値を与えない時
     には何も表示されません。 例えば、‘x’が負の時、‘log(x)’は、 実数値が
     ‘log(abs(x))’に等しい複素数値を与えます; もし‘plot_real_part’ が
     ‘true’だったなら、 ‘log(-5)’は‘log(5)’としてプロットされますが、 も
     し‘plot_real_part’ が‘false’だったなら、 何もプロットされません。

     デフォルト値: ‘false’

 -- プロットオプション: point_type [point_type, <type_1>, …, <type_n>]

     gnuplotでは、 , each set of points to be plotted with the style ス
     タイル“points”か“linespoints”でプロットされた点のそれぞれの集合は こ
     のリストから取られたオブジェクトで順に表されます。 もしこのリスト内
     のオブジェクト以上に点の集合があるなら、 それらは順に繰り返されます
     。 使うことができる可能なオブジェクト: bullet, circle, plus, times,
     asterisk, box, square,triangle, delta, wedge, nabla, diamond,
     lozenge

     デフォルト値: bullet, circle, plus, times, asterisk, box,
     square,triangle, delta, wedge, nabla, diamond, lozenge

 -- プロットオプション: psfile [psfile, <string>]

     このオプションは、プロットをスクリーンに表示する代わりに、
     <string>に等しい名前のポストスクリプトファイルに保存します。 デフォ
     ルトでは、そのファイルは、変数<maxima_tempdir>で定義されたディレク
     トリに 生成されます; 変数の値を変えて、違うディレクトリにファイルを
     保存できます。

 -- プロットオプション: run_viewer [run_viewer, <symbol>]

     プロットフォーマット用の適切なビューアを走らせるかどうか制御します
     。

     デフォルト値: ‘true’

 -- プロットオプション: style [style, <type_1>, …, <type1_n>]
 -- プロットオプション: style [style, [<style_1>], …, [<style_n>]]

     様々な関数やデータ一式のために2dプロットで使われるスタイル。 単語
     <style>の後には、１つ以上のスタイルが続きます。 もし与えられたスタ
     イルよりも多くの関数やデータ集合があったら、スタイルは繰り返されま
     す。 それぞれのスタイルは、実線のためには<lines>、孤立点のためには
     <points>、 線分と孤立点のためには<linespoints>、点線のためには
     <dots>を取り得ます。 Gnuplotでは、<impulses>スタイルも使えます。

     スタイルのそれぞれは、いくつかの追加のパラメータとリストの中に入れ
     ることができます。 <lines>は、１つか２つの数を取ります: 線の太さと
     、色を指定する整数。 デフォルトの色コードは、1: 青, 2: 赤, 3: マゼ
     ンタ, 4: オレンジ, 5: ブラウン, 6: ライム, 7: アクア、です。 もし
     X11ではない端末でGnuplotを使うなら、これらの色は、違っているかもし
     れません; 例えば、もしオプション[<gnuplot_term>,<ps>]を使うなら、色
     インデックス4は、 オレンジではなく、黒に対応します。

     <points>は、１つか２つか３つのパラメータを取ります; 最初のパラメー
     タは、点の半径、 ２番目のパラメータは、同じ色を選択する（<lines>で
     使われるコードと同じ）整数、 ３番目のパラメータは現在、Gnuplotでだ
     け使われており、点の代わりにいくつかのオブジェクトに対応します。オ
     ブジェクトのデフォルト値は、1: 黒丸, 2: 白丸, 3: 十字, 4: ×, 5: 米
     印, 6: 黒四角, 7: 白四角, 8: 黒三角, 9: 白三角, 10: 黒逆三角, 11: 白
     逆三角, 12: 黒菱形, 13: 白菱形、です。

     <linesdots>は、４つまでのパラメータを取ります; 線の太さ、点の半径、
     色、点を置き換えるオブジェクトのタイプ。

     デフォルト値: <lines> (太さ1で、オプション‘color’で与えられた最初の
     色を持つ線で結んだ点一式をプロットします)

     ‘color’と‘point_type’も参照してください。

 -- プロットオプション: t [t, <min>, <max>]

     パラメトリックプロットのデフォルトの範囲。

     デフォルト値: -3, 3

 -- プロットオプション: transform_xy [transform_xy, <symbol>]

     ここで、<symbol>は‘false’か 関数‘transform_xy’を使うことで得られる
     結果をとり得ます。 もし‘false’と違うなら、 plot3dで3座標を変換する
     のに使われます。

     デフォルト値: ‘false’

     ‘make_transform’, ‘polar_to_xy’, ‘spherical_to_xyz’を参照してくださ
     い。

 -- プロットオプション: x [x, <min>, <max>]

     2dプロットコマンドの最初の(またはplot3dの最初の二つのどちらかの) オ
     プションとして使われる時、 1番目の独立変数がxであることを示し、その
     範囲を設定します。 最初のオプションの後(またはplot3dでは2番目のオプ
     ションの後)、 プロット内で示される有効な水平領域を定義するために、
     再び使うことができます。

 -- プロットオプション: xlabel [xlabel, <string>]

     1番目の軸をラベルする<string>を指定します; もしこのオプションが使わ
     れないなら、 plot2dかimplicit_plotで関数をプロットする時、そのラベ
     ルは独立変数の名前です。 plot3dで表面を、もしくはcontour_plotで等高
     線をプロットする時、 そのラベルは1番目の変数の名前です。 パラメトリ
     ックプロットの場合、1番目の式です。 <set_plot_option>では使うことは
     できません。

 -- プロットオプション: y [y, <min>, <max>]
     plot3dでの最初の2つのオプションの1つとして使われる時、 独立変数の
     1つがyであることを示し、その範囲を設定します。 そうでなければ、 プ
     ロットで示される2番目の変数の有効領域を定義します。

 -- プロットオプション: ylabel [ylabel, <string>]

     二番目の軸をラベルする<string>を指定します; もしこのオプションが使
     われないなら、 plot2dやimplicit_plotで関数をプロットする時、そのラ
     ベルは、”y”となり、 plot3dで表面をプロットするときや、
     contour_plotで等高線をプロットする時、 二番目の変数名となり、 パラ
     メトリックプロットの場合には、二番目の式になります。
     <set_plot_option>では使うことはできません。

 -- プロットオプション: z [z, <min>, <max>]
     プロットで示されるzの値の有効範囲を設定するためにplot3dで使われます
     。

 -- プロットオプション: zlabel [zlabel, <string>]

     plot3dを使う時、第三軸をラベルする<string>を指定します。 もしこのオ
     プションが使われないなら、 そのラベルは、 表面をプロットする時は
     “z”となり、 パラメトリックプロットの場合には三番目の式になります。
     <set_plot_option>では使うことはできません。 また、plot2d,
     implicit_plotでは無視されます。


File: maxima.info,  Node: Gnuplot Options,  Next: Gnuplot_pipes Format Functions,  Prev: Plotting Options,  Up: Plotting

12.5 Gnuplot Options
====================

gnuplotに特化したプロットオプションがいくつかあります。 これらのオプショ
ンのいくつかは、gnuplotコマンドそのもので、文字列として指定されます。 詳
細はgnuplotドキュメンテーションを参照してください。 ほとんどの場合、これ
らのオプションは、 より一般的な上記のオプションの１つで置き換えることが
できます; これらの場合、より一般的な形式を使うことをお勧めします。

 -- プロットオプション: gnuplot_term

     gnuplot用の出力端末タイプを設定します。
        • *default* (デフォルト値)

          Gnuplot出力が、別のグラフィカルなウィンドウに表示されます。

        • *dumb*

          Gnuplot出力が、Mグラフィックスの"ASCIIアート"近似で、Maximaコ
          ンソールに表示されます。

        • *ps*

          Gnuplotが、ポストスクリプトページ記述言語でコマンドを生成しま
          す。 もしオプション‘gnuplot_out_file’が<filename>に設定されて
          いるなら、 gnuplotは、<filename>にポストスクリプトコマンドを書
          きます。 そうでなければ、‘maxplot.ps’ファイルとして保存します
          。

        • 他のいかなる有効なgnuplot端末仕様

          Gnuplotは、png, jpeg, svgのような多くの他のグラフィカルフォー
          マットで出力を 生成することができます。 これらのフォーマットす
          べてでプロットを生成するに、‘gnuplot_term’に 任意のサポートさ
          れたgnuplot端末名(シンボル)もしくは、任意の有効なオプションを
          伴う gnuplot端末フル仕様(文字列)さえ設定できます。 例えば、
          ‘[gnuplot_term,png]’は、PNG (Portable Network Graphics)形式で
          出力を生成する一方、‘[gnuplot_term,"png size 1000,1000"]’は、
          1000x1000ピクセルサイズのPNGを生成します。

          もしオプション‘gnuplot_out_file’が<filename>に設定されたら、
          gnuplotは、<filename>に出力を書き込みます。 そうでなければ、
          ‘maxplot.<term>’ファイルに書き込みます。 ここで、<term>は
          gnuplot端末名です。

 -- プロットオプション: gnuplot_out_file

     ‘gnuplot_term’オプションと関連して使われる時、 Gnuplotがサポートす
     るグラフィックフォーマットの１つで、 ファイルにプロットを保存するの
     に使われます。 もしポストスクリプトファイルを生成したければ、 代わ
     りにオプション ‘psfile’を使うことができます。 これは、Openmathでも
     機能し、たった１つのオプションで同じことができます。

          [gnuplot_term, png], [gnuplot_out_file, "graph3.png"]

 -- プロットオプション: gnuplot_pm3d

     ‘false’の値では、PM3Dモードの使用を抑制するのに使われます。 PM3Dモ
     ードはデフォルトで使用可能です。

 -- プロットオプション: gnuplot_preamble

     プロットを描く前に、gnuplotコマンドを挿入します。 有効などんな
     gnuplotコマンドも使うことができます。 複数のコマンドは、セミコロン
     で分離されなければいけません。 示される例はログスケールプロットを生
     成します。 ‘gnuplot_preamble’のデフォルト値は、空の文字列‘""’です。

 -- プロットオプション: gnuplot_curve_titles

     これは、上記で記載した_legend_で置き換えられた古いオプションです。

 -- プロットオプション: gnuplot_curve_styles

     これは、上記で記載した_style_で置き換えられた古いオプションです。

 -- プロットオプション: gnuplot_default_term_command

     デフォルト端末の端末タイプを設定するgnuplotコマンド。 デフォルト値
     は、‘set term pop’です。

 -- プロットオプション: gnuplot_dumb_term_command

     ダム端末の端末タイプを設定するgnuplotコマンド。 デフォルト値は、
     ‘"set term dumb 79 22"’です。 これは、79文字 x 22文字のテキスト出力
     を生成します。

 -- プロットオプション: gnuplot_ps_term_command

     ポストスクリプト端末の端末タイプを設定するgnuplotコマンド。 デフォ
     ルト値は、 ‘"set size 1.5, 1.5; set term postscript eps enhanced
     color solid 24"’, です。 これは、サイズをgnuplotのデフォルトの1.5倍
     に設定し、フォントサイズを24に設定などします。 ‘set term
     postscript’の詳細については、gnuplotドキュメンテーションを 参照して
     ください。


File: maxima.info,  Node: Gnuplot_pipes Format Functions,  Prev: Gnuplot Options,  Up: Plotting

12.6 Gnuplot_pipes Format Functions
===================================

 -- 関数: gnuplot_start ()

     ‘gnuplot_pipes’フォーマットでのプロットのため使われるgnuplotへのパ
     イプを開きます。 プロットの前に手動でパイプを開く必要はありません。

 -- 関数: gnuplot_close ()

     ‘gnuplot_pipes’フォーマットで使われたgnuplotへのパイプを閉じます。

 -- 関数: gnuplot_restart ()

     ‘gnuplot_pipes’フォーマットで使われたgnuplotへのパイプを閉じて、 新
     しいパイプを開きます。

 -- 関数: gnuplot_replot ()
 -- 関数: gnuplot_replot (<s>)

     gnuplotウィンドウを更新します。 もし‘gnuplot_replot’が、文字列<s>の
     中のgnuplotコマンドを引数としてコールされたなら、 ‘s’はウィンドウが
     再プロットされる前にgnuplotに送られます。

 -- 関数: gnuplot_reset ()

     ‘gnuplot_pipes’フォーマットと一緒に使われるgnuplotの状態をリセット
     します。 gnuplotウィンドウを更新するには、 ‘gnuplot_reset’の後に
     ‘gnuplot_replot’をコールください。


File: maxima.info,  Node: File Input and Output,  Next: Polynomials,  Prev: Plotting,  Up: Top

13 File Input and Output
************************

* Menu:

* Comments::
* Files::                       
* Functions and Variables for File Input and Output::  


File: maxima.info,  Node: Comments,  Next: Files,  Prev: File Input and Output,  Up: File Input and Output

13.1 Comments
=============

Maximaの入力の中のコメントは、‘/*’と‘*/’の間の任意のテキストです。

   Maximaのパーサは、コメントを、入力外リームでのトークンを見つけるため
の空白として扱います; コメントで常にトークンは終わります。 ‘a/* foo
*/b’のような入力は、１つのトークン‘ab’ではなく、２つのトークン、‘a’と
‘b’を含みます。 そうでなければ、Maximaはコメントを無視します; コメントの
中身も位置もパースされた入力式に残りません。

   コメントは任意の深さに入れ子にすることができます。 ‘/*’と‘*/’の区切り
記号はマッチングペアを形作ります。 ‘/*’の数は‘*/’と同じでなければいけま
せん。

   例:

     (%i1) /* aa is a variable of interest */  aa : 1234;
     (%o1)                         1234
     (%i2) /* Value of bb depends on aa */  bb : aa^2;
     (%o2)                        1522756
     (%i3) /* User-defined infix operator */  infix ("b");
     (%o3)                           b
     (%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
     (%o4)                         a b c
     (%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
     (%o5)                        xyz + 1


File: maxima.info,  Node: Files,  Next: Functions and Variables for File Input and Output,  Prev: Comments,  Up: File Input and Output

13.2 Files
==========

ファイルは、単に、データやテキスト含む、特別なストレージデバイスのある領
域です。 ディスク上のファイルは、比喩的に「ディレクトリ」の中にグループ
化されます。 ディレクトリは、単にファイルのリストです。 ファイルを扱うコ
マンドは以下の通りです:

   ‘save’, ‘load’, ‘loadfile’, ‘stringout’, ‘batch’, ‘demo’,
‘writefile’, ‘closefile’,と ‘appendfile’。

   ファイル名が‘plot2d’や‘save’、‘writefile’のような関数に渡され、 ファ
イル名がパスを含まない時、Maximaは現在のワーキングディレクトリにファイル
を保存します。 現在のワーキングディレクトリはWindowsやLinuxのようなシス
テムと、インストールに依存します。


File: maxima.info,  Node: Functions and Variables for File Input and Output,  Prev: Files,  Up: File Input and Output

13.3 Functions and Variables for File Input and Output
======================================================

 -- 関数: appendfile (<filename>)
     コンソールの筆記録を<filename>に追加します。 ‘appendfile’は、 筆記
     録ファイルが、存在すれば、いつも追加されることを除いて、
     ‘writefile’と同じです。

     ‘closefile’は、‘appendfile’や‘writefile’によって開かれた筆記録ファ
     イルを閉じます。

 -- 関数: batch (<filename>)
 -- 関数: batch (<filename>, ‘option’)

     ‘batch(<filename>)’はMaximaの式を<filename>から読み込み、評価します
     。 ‘batch’は、リスト‘file_search_maxima’の中で<filename>を検索しま
     す。 ‘file_search’も参照してください。

     ‘batch(<filename>, demo)’は、 ‘demo(<filename>)’ようなものです。 こ
     の場合、‘batch’は、リスト‘file_search_demo’の中で <filename>を検索
     します。 ‘demo’を参照してください。

     ‘batch(<filename>, test)’は、 オプション‘display_all=true’を付けた
     ‘run_testsuite’ようなものです。 この場合、‘batch’は、
     ‘run_testsuite’のようにリスト‘file_search_tests’ではなく、 リスト
     ‘file_search_maxima’の中で<filename>を検索します。 更に、
     ‘run_testsuite’はリスト‘testsuite_files’の中にあるテストを実行しま
     す。 ‘batch’を使うと、どんなファイルもテストモードで実行することが
     可能です。 ファイルはリスト‘file_search_maxima’の中であってもいいで
     す。 これはテストファイルを書いている時に便利です。

     <filename>は、一連のMaximaの式より成り、それぞれの式は、‘;’もしくは
     ‘$’で終了します。 特殊変数‘%’と関数‘%th’は、ファイル内での前の結果
     を参照します。 ファイルは‘:lisp’構成子を含むかもしれません。 ファイ
     ルの中の空白、タブ、改行は無視されます。 適した入力ファイルは、テキ
     ストエディタもしくは、‘stringout’関数で作ることができます。

     ‘batch’は、それぞれの入力式を<filename>から読み込み、 入力をコンソ
     ールに表示し、 対応する出力式を計算し、 出力式を表示します。 入力ラ
     ベルは入力式に割り当てられ、出力ラベルは出力式に割り当てられます。
     ‘batch’は、エラーがない限り、ファイルの中のすべての入力式を評価しま
     す。 もしユーザー入力が（例えば、‘asksign’や‘askinteger’によって）
     要求されたら、 ‘batch’は、ポーズして必要な入力を入手し、続けます。

     コンソールで‘control-C’をタイプすることで、‘batch’を停止させること
     が可能かもしれません。 ‘control-C’の効果は、基礎となるLispの実装に
     依存します。

     ‘batch’にはいくつか用法があります。 役立つコマンドラインの蓄積を供
     給したり、 エラーのないデモンストレーションを与えたり、 複雑な問題
     を解く時、人の考えを整理するのを助けたり。

     ‘batch’は引数を評価します。 第二引数なしで呼び出されたり、オプショ
     ン‘demo’で呼び出された時、 ‘batch’は‘filename’のパスを文字列として
     返します。 オプション‘test’で呼び出された時、 戻り値は、空のリスト
     ‘[]’か、<filename>と失敗したテストの数を含むリストです。

     ‘load’, ‘batchload’, ‘demo’も参照してください。

 -- 関数: batchload (<filename>)

     <filename>からMaximaの式を読み込み、評価します。 入力式や出力式を表
     示しません。 ラベルを出力式に割り当てません。 しかし、（‘print’や
     ‘describe’が生成するような)プリント文の出力は表示されます。

     特殊変数‘%’や関数‘%th’は、 ファイルの中の結果ではなく、対話インター
     プリタからの以前の結果を参照します。 ファイルは‘:lisp’構成子を含む
     ことはできません。

     ‘batchload’は、<filename>のパスを文字列として返します。
     ‘batchload’は引数を評価します。

     ‘batch’や‘load’も参照してください。

 -- 関数: closefile ()

     ‘writefile’や‘appendfile’で開いたトランスクリプトファイルを閉じます
     。

 -- オプション変数: file_output_append
     デフォルト値: ‘false’

     ‘file_output_append’は、 ファイル出力関数が出力ファイルに追加するか
     、ファイルを切り詰めるか決めます。 ‘file_output_append’が‘true’の時
     、 ファイル出力関数は出力ファイルに追加します。 そうでなければ，出
     力ファイルは切り詰められます。

     ‘save’, ‘stringout’, ‘with_stdout’は、‘file_output_append’を考慮し
     ます。 出力ファイルを書き出す他の関数は‘file_output_append’を考慮し
     ません。 特に、プロット感巣や変換関数は常に出力ファイルを切り詰め、
     ‘tex’や‘appendfile’はいつも追加します。

 -- 関数: filename_merge (<path>, <filename>)

     <path>と<filename>から修正されたパスを構成します。 もし、<path>の最
     後の構成要素が形式‘###.<something>’なら、 構成要素は、
     ‘<filename>.<something>’に置き換えられます。 そうでなければ、最後の
     構成要素は単に<filename>に置き換えられます。

     結果はLispのパス名オブジェクトです。

 -- 関数: file_search (<filename>)
 -- 関数: file_search (<filename>, <pathlist>)

     ‘file_search’は、ファイル<filename>を検索し、 もし見つかれば、（文
     字列として）ファイルへのパスを返します; そうでなければ、
     ‘file_search’は‘false’を返します。 ‘file_search (<filename>)’は、 デ
     フォルトのサーチディレクトリを検索します。 デフォルトのサーチディレ
     クトリは、‘file_search_maxima’, ‘file_search_lisp’,
     ‘file_search_demo’変数によって指定されます。

     ‘file_search’は、 名前を「ワイルドカード」ファイルサーチパターンに
     マッチさせようとする前に、 最初に、渡された実際の名前が存在するかチ
     ェックします。 ファイルサーチパターンに関連した
     ‘file_search_maxima’を参照してください。

     引数<filename>は、パスとファイル名、もしくは単にファイル名、もしく
     は、 もしファイルサーチディレクトリがファイルサーチパターンを含むな
     ら、単にファイル名のベース（拡張子なし）、を取り得ます。 例えば、

          file_search ("/home/wfs/special/zeta.mac");
          file_search ("zeta.mac");
          file_search ("zeta");

     ファイルが存在していて、‘/home/wfs/special/###.mac’が
     ‘file_search_maxima’に中にあるという仮定の下で、上記すべては同じフ
     ァイルを見つけます。

     ‘file_search (<filename>, <pathlist>)’は、 <pathlist>によって指定さ
     れたディレクトリの中だけを検索します。 ここで、<pathlist>は文字列の
     りすとです。 引数<pathlist>は、デフォルトの検索ディレクトリに取って
     代わります。 だから、もしパスリストが与えられたら、デフォルトの検索
     ディレクトリのいずれでもなく、‘file_search’は指定されたところだけを
     検索します。 <pathlist>の中に１つのディレクトリだけしかない場合でさ
     え、まだ、 それは、要素１つのリストとして与えられなければいけません
     。

     ユーザーはデフォルト検索ディレクトリを修正できます。
     ‘file_search_maxima’を参照してください。

     ‘file_search’は、‘file_search_maxima’と‘file_search_lisp’を を検索
     ディレクトリとして、 ‘load’によって呼び出されます。

 -- オプション変数: file_search_maxima
 -- オプション変数: file_search_lisp
 -- オプション変数: file_search_demo
 -- オプション変数: file_search_usage
 -- オプション変数: file_search_tests

     これらの変数は、‘load’, ‘demo’や他のいくつかのMaximaの関数が検索す
     る ディレクトリのリストを指定します。 これらの変数のデフォルト値は
     、Maxima員ストレーションの様々なディレクトリを名指ししています。

     ユーザーは、 デフォルト値を置き換えるか、ディレクトリを追加すること
     で、 これらの変数を変更できます 例えば、

          file_search_maxima: ["/usr/local/foo/###.mac",
              "/usr/local/bar/###.mac"]$

     は、‘file_search_maxima’のデフォルト値を置き換える一方、

          file_search_maxima: append (file_search_maxima,
              ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$

     は、２つのディレクトリを追加します。 ファイル‘maxima-init.mac’に
     Maximaが起動した時にファイル検索パスが自動的に割り当てられるような
     式を入れておくと便利かもしれません。 *note Introduction for Runtime
     Environment::も参照してください。

     特別な「ワイルドカード」構造によって、ファイル名の拡張子やパスを多
     重にしてすることができます。 文字列‘###’は、求められている名前に拡
     張される一方、 カーリ括弧‘{foo,bar,baz}’で囲まれた、コンマで分離さ
     れたリストは多重文字列に拡張されます。 例えば、求められてる名前が
     ‘neumann’とすると、

          "/home/{wfs,gcj}/###.{lisp,mac}"

     は、‘/home/wfs/neumann.lisp’, ‘/home/gcj/neumann.lisp’,
     ‘/home/wfs/neumann.mac’, ‘/home/gcj/neumann.mac’に展開されます。

 -- 関数: file_type (<filename>)

     <filename>の中身について、ファイル名拡張子を下に、推測を返します。
     <filename>は、実際のファイルを参照する必要はありません; ファイルを
     開いたり、中身を探索したりはしません。

     戻り値はシンボルであり、‘object’, ‘lisp’, ‘maxima’のいずれかです。
     もし拡張子が‘file_type_maxima’の中の値の1つと一致したら、
     ‘file_type’は‘maxima’を返します。 もし拡張子が"‘file_type_lisp’の中
     の値の1つと一致したら、 ‘file_type’は‘lisp’を返します。 上のいずれ
     でもないなら、‘file_type’は‘object’を返します。

     ‘pathname_type’も参照してください。

     デフォルト値に関しては、‘file_type_maxima’と‘file_type_lisp’を 参照
     してください。

     例:

          (%i2) map('file_type,
                    ["test.lisp", "test.mac", "test.dem", "test.txt"]);
          (%o2)            [lisp, maxima, maxima, object]

 -- オプション変数: file_type_lisp
     デフォルト値: ‘[l, lsp, lisp]’

     ‘file_type_lisp’は、 maximaがLispソースファイルの印として認識するフ
     ァイル拡張子のリストです。

     ‘file_type’も参照してください。

 -- オプション変数: file_type_maxima
     デフォルト値: ‘[mac, mc, demo, dem, dm1, dm2, dm3, dmt]’

     ‘file_type_maxima’は、 maximaがMaximaソースファイルの印として認識す
     るファイル拡張子のリストです。

     ‘file_type’も参照してください。

 -- 関数: load (<filename>)

     <filename>の中の式を評価します。 そして、変数、関数、他のオブジェク
     トをMaximaにもたらします。 、<filename>から再生されたバインドは存在
     するオブジェクトのバインドを上書きします(clobber)。 ファイルを見つ
     けるために、 ‘load’は、探索ディレクトリとして‘file_search_maxima’と
     ‘file_search_lisp’を引数として‘file_search’をコールします。 もし
     ‘load’が成功したら ファイルの名前を返します。 そうでなければ、
     ‘load’はエラーメッセージを出力します。

     ‘load’は、LispコードでもMaximaコードでも等しく機能します。 ‘save’,
     ‘translate_file’, ‘compile_file’―これらはLispコードを生成します―が
     生成したファイルはすべて‘load’によって処理できます。 ‘load’は、
     Lispファイルをロードするために‘loadfile’をコールし、 Maximaファイル
     をロードするために‘batchload’をコールします。

     ‘load’は、Maximaファイルの中で‘:lisp’構成子を認識しません。
     <filename>を処理する時、 グローバル変数‘_’, ‘__’, ‘%’, ‘%th’は、
     ‘load’がコールされた時バインドされていた値を持ちます。

     ‘loadfile’, ‘batch’, ‘batchload’, ‘demo’も参照してください。
     ‘loadfile’はLispファイルを処理します; ‘batch’, ‘batchload’, ‘demo’は
     Maximaファイルを処理します。

     ファイル探索メカニズムについてもっと詳しいことは‘file_search’を参照
     してください。

     ‘load’は引数を評価します。

 -- システム変数: load_pathname
     デフォルト値: ‘false’

     関数‘load’や、‘loadfile’、‘batchload’を使ってファイルがロードされる
     時、 システム変数‘load_pathname’は処理するファイルのパス名を示しま
     す。

     変数‘load_pathname’はロード中にファイルからアクセスすることができま
     す。

     例:

     ディレクトリ
     ‘"/home/dieter/workspace/mymaxima/temp/"’に、以下のコマンドを含む
     バッチファイル‘test.mac’があるとしましょう。

          print("The value of load_pathname is: ", load_pathname)$
          print("End of batchfile")$

     すると、以下の出力を得ます。

          (%i1) load("/home/dieter/workspace/mymaxima/temp/test.mac")$
          The value of load_pathname is:
                             /home/dieter/workspace/mymaxima/temp/test.mac
          End of batchfile

 -- 関数: loadfile (<filename>)

     <filename>の中のLisp式を評価します。 ‘loadfile’は、‘file_search’を
     呼び出しません。 だから、‘filename’はファイル拡張子とファイルを見つ
     けるのに必要なパスも含まなければいけません。

     ‘loadfile’は、‘save’, ‘translate_file’, ‘compile_file’によって生成
     されたファイルを処理できます。 ユーザーは、‘loadfile’の代わりに
     ‘load’を使うほうが便利だと気づくでしょう。

 -- オプション変数: loadprint
     デフォルト値: ‘true’

     ‘loadprint’は、ファイルがロードされた時、メッセージを表示するかどう
     か告げます。

        • ‘loadprint’が‘true’の時, いつもメッセージを表示します。
        • ‘loadprint’が‘'loadfile’の時, ファイルが関数‘loadfile’によって
          ロードされた時だけメッセージを表示します。
        • ‘loadprint’が‘'autoload’の時、 ファイルが自動的にロードされた
          時だけメッセージを表示します。 ‘setup_autoload’を参照してくだ
          さい。
        • ‘loadprint’が‘false’の時, メッセージは決して表示されません。

 -- オプション変数: packagefile
     デフォルト値: ‘false’

     他の人が使うパッケージ（ファイル）を生成するために‘save’や
     ‘translate’を使う パッケージデザイナは、 ファイルがロードされる時必
     要な場合を除いて、 Maximaの情報リスト（例えば、‘values’,
     ‘functions’）に情報が追加されることを抑制するために、‘packagefile:
     true’を設定したいかもしれません。 この方法によれば、 ユーザーが自身
     のデータを追加した時ユーザーの方法では パッケージの中身は、得られな
     いでしょう。 これは、起こりうる名前衝突の問題を解決はしないことに注
     意してください。 このフラグは、パッケージファイルへの出力であるもの
     に素直に影響することにも注意してください。 フラグを‘true’に設定する
     ことは、 Maxima初期化ファイルを生成するにも役に立ちます。

 -- 関数: pathname_directory (<pathname>)
 -- 関数: pathname_name (<pathname>)
 -- 関数: pathname_type (<pathname>)

     これらの関数は<pathname>の構成要素を返します。

     例:

          (%i1) pathname_directory("/home/dieter/maxima/changelog.txt");
          (%o1)                 /home/dieter/maxima/
          (%i2) pathname_name("/home/dieter/maxima/changelog.txt");
          (%o2)                       changelog
          (%i3) pathname_type("/home/dieter/maxima/changelog.txt");
          (%o3)                          txt

 -- 関数: printfile (<path>)

     <path>という名前のファイルをコンソールに表示します。 <path>は、文字
     列もしくはシンボルです; もしシンボルなら、文字列に変換されます。

     もし<path>が現在のワーキングディレクトリからアクセス可能なファイル
     名なら、 そのファイルがコンソールに表示されます。 そうでなければ、
     ‘printfile’は、 ‘filename_merge’を介して‘file_search_usage’の要素の
     それぞれに <path>を追加することでファイルを見つけようとします。

     ‘printfile’は、もし<path>が存在しているファイルを示しているなら、
     <path>を返し、そうでなければ、 成功したファイル名マージの結果を返し
     ます。

 -- 関数: tcl_output (<list>, <i0>, <skip>)
 -- 関数: tcl_output (<list>, <i0>)
 -- 関数: tcl_output ([<list_1>, …, <list_n>], <i>)

     リストの要素を、 カーリ括弧‘{ }’で囲んで表示します。 Tcl/Tk言語でプ
     ログラムの一部として適した形です。

     ‘tcl_output (<list>, <i0>, <skip>)’ は、 要素<i0>で始まり、要素
     ‘<i0> + <skip>’, ‘<i0> + 2 <skip>’, などを表示するよう、<list>を表
     示します。

     ‘tcl_output (<list>, <i0>)’は、 ‘tcl_output (<list>, <i0>, 2)’と同
     値です。

     ‘tcl_output ([<list_1>, ..., <list_n>], <i>)’は、 <list_1>, …,
     <list_n>の<i>番目の要素を表示します。

     例:

          (%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

           {1.000000000     4.000000000
           }
          (%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

           {2.000000000     5.000000000
           }
          (%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

           {((RAT SIMP) 3 7) ((RAT SIMP) 11 13)
           }
          (%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

           {$Y1 $Y2 $Y3
           }
          (%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

           {SIMP 1.000000000     11.00000000
           }

 -- 関数: save (<filename>, <name_1>, <name_2>, <name_3>, …)
 -- 関数: save (<filename>, values, functions, labels, …)
 -- 関数: save (<filename>, [<m>, <n>])
 -- 関数: save (<filename>, <name_1>=<expr_1>, …)
 -- 関数: save (<filename>, all)
 -- 関数: save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>, …)

     <filename>に、<name_1>, <name_2>, <name_3>, …,の現在値を 保存します
     。 引数は、変数、関数、他のオブジェクトの名前です。 もし名前が関連
     づけられた値や関数を持たないなら、無視されます。 ‘save’は、
     <filename>を返します。

     ‘save’は、データをLisp式の形式で保存します。 ‘save’で保存されたデー
     タは、‘load (<filename>)’によって回復できます。 ‘load’を参照してく
     ださい。

     グローバルフラグ ‘file_output_append’は、 ‘save’が出力ファイルに追
     加するか、切り詰めるか決めます。 ‘file_output_append’が‘true’の時、
     ‘save’は出力ファイルに追加します。 そうでなければ、‘save’は出力ファ
     イルを切り詰めます。 どちらの場合も、もしファイルが存在しなければ、
     ‘save’はファイルを生成します。

     特殊形式‘save (<filename>, values, functions, labels, ...)’ は、
     ‘values’, ‘functions’, ‘labels’, などと名付けられた項目を 保存しま
     す。 名前は、変数‘infolists’によって指定された任意のものです。
     ‘values’は、ユーザー定義変数すべてから成ります。

     特殊形式‘save (<filename>, [<m>, <n>])’は、 <m>から<n>までの入力ラ
     ベル、出力ラベルの値を保存します。 <m>と<n>は、整数リテラルでなけれ
     ばならないことに注意してください。 例えば、‘save ("foo.1", %i42,
     %o42)’のように、 入力ラベル、出力ラベルは１つ１つ保存することもでき
     ます。 ‘save (<filename>, labels)’は、 入力ラベル出力ラベルすべてを
     保存します。 保存されたラベルが回復された時、それらは存在していたラ
     ベルを負かします。

     特殊形式‘save (<filename>, <name_1>=<expr_1>, <name_2>=<expr_2>,
     ...)’は、 <expr_1>, <expr_2>, …,の値を<name_1>, <name_2>, …という名
     前で保存します。 例えば、‘save ("foo.1", aa=%o88)’のように、 この形
     式を入力ラベル出力ラベルに適用することは便利です。 この形式の等式の
     右辺は任意の式であり、その式は評価されます。 この形式は、新しい名前
     を現在のMaximaの環境に導入はせず、 ただ、<filename>にそれらを保存し
     ます。

     これらの特殊形式と‘save’の一般形式は自由に混在させることができます
     。 例えば、‘save (<filename>, aa, bb, cc=42, functions, [11, 17])’。

     特殊形式‘save (<filename>, all)’は、Maximaの現在の状態を保存します
     。 これは、自動的に定義された項目はもちろん、ユーザー定義の変数、関
     数、配列などすべてを 含みます。 保存される項目は、 もしそれらがユー
     ザーによって新しい値を割り当てられたなら、 ‘file_search_maxima’や
     ‘showtime’のようなシステム変数を含みます。 ‘myoptions’を参照してく
     ださい。

     ‘save’は<filename>を評価し、他の引数すべてをクォートします。

 -- 関数: stringout (<filename>, <expr_1>, <expr_2>, <expr_3>, …)
 -- 関数: stringout (<filename>, [<m>, <n>])
 -- 関数: stringout (<filename>, input)
 -- 関数: stringout (<filename>, functions)
 -- 関数: stringout (<filename>, values)

     ‘stringout’は、 式が入力としてタイプされたのと同じ形式で、式をファ
     イルに書き込みます。 なので、ファイルは‘batch’や‘demo’コマンドの入
     力として使えますし、 どんな目的のためでも編集できます。
     ‘stringout’は、‘writefile’が進行中の間に実行することができます。

     グローバルフラグ‘file_output_append’は、 ‘stringout’が出力ファイル
     に追加するか、切り詰めるか決めます。 ‘file_output_append’が‘true’の
     時、 ‘stringout’は、出力ファイルに追加します。 そうでなければ、
     ‘stringout’は出力ファイルを切り詰めます。 どちらの場合も、もしファ
     イルが存在しなければ，‘stringout’はファイルを生成します。

     ‘stringout’の一般形式は、１つ以上の式の値を出力ファイルに書き込みま
     す。 もし式が変数なら、変数の値だけが書き込まれ、変数名は書き込まれ
     ないことに注意してください。 役に立つ特殊な場合として、式は、 入力
     ラベル(‘%i1’, ‘%i2’, ‘%i3’, …)もしくは出力ラベル(‘%o1’, ‘%o2’,
     ‘%o3’, …)でもよいです。 ）

     もし‘grind’が‘true’なら、 ‘stringout’は、‘grind’フォーマットを使っ
     て出力をフォーマットします。 そうでなければ、‘string’フォーマットが
     使われます。 ‘grind’と‘string’を参照してください。

     特殊形式‘stringout (<filename>, [<m>, <n>])’は、 mからnまでの入力ラ
     ベルの値を書き込みます。

     特殊形式 ‘stringout (<filename>, input)’は、 入力ラベルすべてをファ
     イルに書き込みます。

     特殊形式‘stringout (<filename>, functions)’は、 （グローバルリスト
     ‘functions’で名付けられた）ユーザー定義関数すべてをファイルに書き込
     みます。

     特殊形式‘stringout (<filename>, values)’は、 （グローバルリスト
     ‘values’で名付けられた）ユーザーが割り当てた変数すべてをファイルに
     書き込みます。 変数それぞれは、変数名とコロンとその値という割り当て
     文として出力されます。 ‘stringout’の一般形式は変数を割り当て文とし
     て出力しないことに注意してください。

 -- 関数: tex (<expr>)
 -- 関数: tex (<expr>, <destination>)
 -- 関数: tex (<expr>, false)
 -- 関数: tex (<label>)
 -- 関数: tex (<label>, <destination>)
 -- 関数: tex (<label>, false)

     TeXドキュメントの準備に適した式の表現を出力します。 結果は、ドキュ
     メントの断片です。 それは、より大きなドキュメントにコピーすることが
     できますが、それ自身では処理されません。

     ‘tex (<expr>)’は、<expr>のTeX表現をコンソールに出力します。

     ‘tex (<label>)’は、<label>で名付けられた式のTeX表現を出力し、 （式
     の左に表示されるよう）等式ラベルをそれに割り当てます。 TeX等式ラベ
     ルは、Maximaラベルと同じです。

     <destination>は、出力ストリームもしくはファイル名です。
     <destination>がファイル名の時、 ‘tex’は、ファイルに出力を追加します
     。 関数‘openw’と‘opena’は、出力ストリームを生成します。

     ‘tex (<expr>, false)’と‘tex (<label>, false)’は、 TeX出力を文字列と
     して返します。

     ‘tex’は、最初の引数がラベルかどうか見るためにテストした後、最初の引
     数を評価します。 クォートクォート‘''’は、引数の評価を強制し、 その
     結果、テストをだめにして、ラベルを妨げます。

     ‘texput’も参照してください。

     例:

          (%i1) integrate (1/(1+x^3), x);
                                              2 x - 1
                            2            atan(-------)
                       log(x  - x + 1)        sqrt(3)    log(x + 1)
          (%o1)      - --------------- + ------------- + ----------
                              6             sqrt(3)          3
          (%i2) tex (%o1);
          $$-{{\log \left(x^2-x+1\right)}\over{6}}+{{\arctan \left({{2\,x-1
           }\over{\sqrt{3}}}\right)}\over{\sqrt{3}}}+{{\log \left(x+1\right)
           }\over{3}}\leqno{\tt (\%o1)}$$
          (%o2)                          (\%o1)
          (%i3) tex (integrate (sin(x), x));
          $$-\cos x$$
          (%o3)                           false
          (%i4) tex (%o1, "foo.tex");
          (%o4)                          (\%o1)

     ‘tex (<expr>, false)’はTeX出力を文字列として返します。

          (%i1) S : tex (x * y * z, false);
          (%o1) $$x\,y\,z$$
          (%i2) S;
          (%o2) $$x\,y\,z$$

 -- 関数: tex1 (<e>)

     式<e>のTeX出力を表現する文字列を返します。 TeX出力は、等式や他の任
     意の環境のため、区切り記号で囲まれません。

     例:

          (%i1) tex1 (sin(x) + cos(x));
          (%o1)                     \sin x+\cos x

 -- 関数: texput (<a>, <s>)
 -- 関数: texput (<a>, <f>)
 -- 関数: texput (<a>, <s>, <operator_type>)
 -- 関数: texput (<a>, [<s_1>, <s_2>], matchfix)
 -- 関数: texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)

     アトム<a>のためのTeX出力を割り当てます。 ここで<a>はシンボルもしく
     は演算子名です。

     ‘texput (<a>, <s>)’は、 ‘tex’関数に、 <a>の代わりに文字列<s>をTeX出
     力に入れるようにさせます。

     ‘texput (<a>, <f>)’は、 ‘tex’関数に、 TeX出力を生成するために関数
     <f>をコールさせます。 <f>は、１つの引数を受け入れなければいけません
     。 ここで、引数は、演算子<a>を持つ式で、文字列（TeX出力）を返さなけ
     ればいけません。 <f>は、入力式の引数のためにTeX出力を生成するよう、
     ‘tex1’をコールするかもしれません。

     <operator_type>が‘prefix’, ‘infix’, ‘postfix’, ‘nary’, もしくは
     ‘nofix’,として、 ‘texput (<a>, <s>, <operator_type>)’は、 ‘tex’関数
     に <a>の代わりに<s>をTeX出力に入れるようにさせ、 適切な位置に挿入さ
     れた手キスを置くようにさせます。

     ‘texput (<a>, [<s_1>, <s_2>], matchfix)’は、 ‘tex’関数に、 <a>の引
     数のそれぞれの側に<s_1>と<s_2>を TeX出力に入れるようにさせます。 （
     もし複数なら）引数はコンマで分離されます。

     ‘texput (<a>, [<s_1>, <s_2>, <s_3>], matchfix)’は、 ‘tex’関数に、 引
     数を分離する<s_3>と一緒に <a>の引数のそれぞれの側に<s_1>と<s_2>を
     TeX出力に入れるようにさせます。

     例:

     変数にTeX出力を割り当てます。

          (%i1) texput (me,"\\mu_e");
          (%o1)                         \mu_e
          (%i2) tex (me);
          $$\mu_e$$
          (%o2)                         false

     任意の関数（演算子ではない）にTeX出力を割り当てます。

          (%i1) texput (lcm, "\\mathrm{lcm}");
          (%o1)                     \mathrm{lcm}
          (%i2) tex (lcm (a, b));
          $$\mathrm{lcm}\left(a , b\right)$$
          (%o2)                         false

     TeX出力を生成する関数をコールします。

          (%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
            concat ("\\left[\\stackrel{",tex1(b),"}{",tex1(a),"}\\right]"))$
          (%i2) texput (foo, texfoo);
          (%o2)                        texfoo
          (%i3) tex (foo (2^x, %pi));
          $$\left[\stackrel{\pi}{2^{x}}\right]$$
          (%o3)                         false

     前置演算子にTeX出力を割り当てます。

          (%i1) prefix ("grad");
          (%o1)                         grad
          (%i2) texput ("grad", " \\nabla ", prefix);
          (%o2)                        \nabla
          (%i3) tex (grad f);
          $$ \nabla f$$
          (%o3)                         false

     中置演算子にTeX出力を割り当てます。

          (%i1) infix ("~");
          (%o1)                           ~
          (%i2) texput ("~", " \\times ", infix);
          (%o2)                        \times
          (%i3) tex (a ~ b);
          $$a \times b$$
          (%o3)                         false

     後置演算子にTeX出力を割り当てます。

          (%i1) postfix ("##");
          (%o1)                          ##
          (%i2) texput ("##", "!!", postfix);
          (%o2)                          !!
          (%i3) tex (x ##);
          $$x!!$$
          (%o3)                         false

     n項演算子にTeX出力を割り当てます。

          (%i1) nary ("@@");
          (%o1)                          @@
          (%i2) texput ("@@", " \\circ ", nary);
          (%o2)                         \circ
          (%i3) tex (a @@ b @@ c @@ d);
          $$a \circ b \circ c \circ d$$
          (%o3)                         false

     無項演算子にTeX出力を割り当てます。

          (%i1) nofix ("foo");
          (%o1)                          foo
          (%i2) texput ("foo", "\\mathsc{foo}", nofix);
          (%o2)                     \mathsc{foo}
          (%i3) tex (foo);
          $$\mathsc{foo}$$
          (%o3)                         false

     マッチフィックス演算子にTeX出力を割り当てます。

          (%i1) matchfix ("<<", ">>");
          (%o1)                          <<
          (%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
          (%o2)                [ \langle ,  \rangle ]
          (%i3) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o3)                         false
          (%i4) tex (<<a, b>>);
          $$ \langle a , b \rangle $$
          (%o4)                         false
          (%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
                matchfix);
          (%o5)           [ \langle ,  \rangle ,  \, | \,]
          (%i6) tex (<<a>>);
          $$ \langle a \rangle $$
          (%o6)                         false
          (%i7) tex (<<a, b>>);
          $$ \langle a \, | \,b \rangle $$
          (%o7)                         false

 -- 関数: get_tex_environment (<op>)
 -- 関数: set_tex_environment (<op>, <before>, <after>)

     ‘tex’によって出力されるTeX環境をカスタマイズします。 これらの関数に
     よって保持されるように、TeX環境は２つの文字列から成ります; １つは他
     の任意のTeX出力に前もって出力されるもの、もう１つは後に出力されるも
     のです。

     式のトップレベル演算子のTeX環境だけが、出力されます; 他の演算子に関
     連づけられたTeX環境は無視されます。

     ‘get_tex_environment’は、 演算子<op>に適用されたTeX環境を返します;
     もし他の環境が割り当てられていなければ、デフォルトを返します。

     ‘set_tex_environment’は、 演算子<op>のためのTeX環境を割り当てます。

     例:

          (%i1) get_tex_environment (":=");
          (%o1) [
          \begin{verbatim}
          , ;
          \end{verbatim}
          ]
          (%i2) tex (f (x) := 1 - x);

          \begin{verbatim}
          f(x):=1-x;
          \end{verbatim}

          (%o2)                         false
          (%i3) set_tex_environment (":=", "$$", "$$");
          (%o3)                       [$$, $$]
          (%i4) tex (f (x) := 1 - x);
          $$f(x):=1-x$$
          (%o4)                         false

 -- 関数: get_tex_environment_default ()
 -- 関数: set_tex_environment_default (<before>, <after>)

     ‘tex’によって出力されるTeX環境をカスタマイズします。 これらの関数に
     よって保持されるように、TeX環境は２つの文字列から成ります; １つは他
     の任意のTeX出力に前もって出力されるもの、もう１つは後に出力されるも
     のです。

     ‘get_tex_environment_default’は、 トップレベル演算子が（
     ‘set_tex_environment’で割り当てられたような）特定のTeX環境を持たな
     い式に適用されたTeX環境を返します。

     ‘set_tex_environment_default’は、デフォルトのTeX環境を割り当てます
     。

     例:

          (%i1) get_tex_environment_default ();
          (%o1)                       [$$, $$]
          (%i2) tex (f(x) + g(x));
          $$g\left(x\right)+f\left(x\right)$$
          (%o2)                         false
          (%i3) set_tex_environment_default ("\\begin{equation}
          ", "
          \\end{equation}");
          (%o3) [\begin{equation}
          ,
          \end{equation}]
          (%i4) tex (f(x) + g(x));
          \begin{equation}
          g\left(x\right)+f\left(x\right)
          \end{equation}
          (%o4)                         false

 -- 関数: with_stdout (<f>, <expr_1>, <expr_2>, <expr_3>, …)
 -- 関数: with_stdout (<s>, <expr_1>, <expr_2>, <expr_3>, …)

     <expr_1>, <expr_2>, <expr_3>, ...を評価し、 生成された出力すべてを
     ファイル<f>もしくは出力ストリーム<s>に書き込みます。 評価される式は
     出力に書き込まれません。 出力は、‘print’, ‘display’, ‘grind’や他の
     関数によって生成されたものです。

     グローバルフラグ ‘file_output_append’は、 ‘with_stdout’が出力ファイ
     ル<f>に追加するか切り詰めるか決めます。 ‘file_output_append’が
     ‘true’の時、 ‘with_stdout’は出力ファイルに追加します。 そうでなけれ
     ば、‘with_stdout’は出力ファイルを切り詰めます。 どちらの場合も、も
     しファイルが存在しないなら、‘with_stdout’はファイルを生成します。

     ‘with_stdout’は最後の引数の値を返します。

     ‘writefile’も参照してください。

          (%i1) with_stdout ("tmp.out", for i:5 thru 10 do
                print (i, "! yields", i!))$
          (%i2) printfile ("tmp.out")$
          5 ! yields 120
          6 ! yields 720
          7 ! yields 5040
          8 ! yields 40320
          9 ! yields 362880
          10 ! yields 3628800

 -- 関数: writefile (<filename>)

     Maximaセッションのトランスクリプトを<filename>に書き込むことを開始
     します。 ユーザーとMaximaの間の対話すべてが、ちょうどコンソールに現
     れるように、このファイルに記録されます。

     トランスクリプトがコンソール出力フォーマットで出力されるので、 それ
     はMaximaに再ロードすることはできません。 最ロード可能な式を含むファ
     イルを作るには、 ‘save’と‘stringout’を参照してください。 ‘save’は、
     Lisp形式の式を保存する一方、‘stringout’は、Maxima形式 の式を保存し
     ます。

     <filename>が既に存在している時、‘writefile’の実行の効果は、 基礎と
     なるLisp実装に依存します; トランスクリプファイルは負かされるかもし
     れませんし、ファイルは追加されるかもしれません。 ‘appendfile’は、い
     つもトランスクリプトファイルに追加します。

     以前の対話の表示を保存するために‘writefile’の後、 ‘playback’を実行
     するのが便利かもしれません。 ‘playback’は入力と出力変数(‘%i1’,
     ‘%o1’, など)だけを表示し、 （戻り値と対照的に）関数の中のプリント文
     によって生成された任意の出力は‘playback’によって表示されません。

     ‘closefile’は、‘writefile’や‘appendfile’が開いたトランスクリプトフ
     ァイルを閉じます。


File: maxima.info,  Node: Polynomials,  Next: Special Functions,  Prev: File Input and Output,  Up: Top

14 Polynomials
**************

* Menu:

* Introduction to Polynomials::  
* Functions and Variables for Polynomials::  


File: maxima.info,  Node: Introduction to Polynomials,  Next: Functions and Variables for Polynomials,  Prev: Polynomials,  Up: Polynomials

14.1 Introduction to Polynomials
================================

多項式は、Maximaの中では、一般形もしくは、標準有理式(CRE)形として記憶さ
れます。 後者は標準形であり、factor, ratsimpなどのような演算によって内部
で使われます。

   標準有理式は、特に （RATFACが‘true’に設定された時の部分的に因数分解さ
れた多項式や有理関数はもちろん） 展開された多項式や有理関数に適したある
種の表現を構成します。 このCRE形では、変数の（最もメインから最小にまでの
）順序付けは、 式それぞれに仮定されます。 多項式は、一連の式の対が続く主
変数から成るリストによって再帰的に表現されます。 それぞれの対の最初のメ
ンバーは、その項の主変数の指数であり、 ２番目のメンバーは、その項の係数
で、係数は、数、もしくは、再度の形式で表現された別の変数の多項式です。 こ
のように、3*X^2-1のCRE形の主要な部分は、(X 2 3 0 -1)であり、 2*X*Y+X-3の
それは、 Yが主変数と仮定すると(Y 1 (X 1 2) 0 (X 1 1 0 -3)) であり、 Xが
主変数と仮定すると(X 1 (Y 1 2 0 1) 0 -3)です。 「主」であることは、普通
、アルファベットの逆順で決定されます。 CRE式の「変数」はアトムである必要
はありません。 実査、主演算子が+ - * /でも、整数べきの^でもない任意の部
分式は、 それが式の中で現れると、（CRE形の）式の「変数」と考えられます。
例えば、式X+SIN(X+1)+2*SQRT(X)+1のCRE変数は、XとSQRT(X)、SIN(X+1)です。
もしユーザーがRATVARS関数を使って変数の順序付けを指定しないなら、
Maximaはアルファベットの順序付けを選びます。 一般に、CREは、有理式、すな
わち、分子と分母が共通因子を持たず、分母が正の多項式の比を表します。 内
部形は、本質的に、変数順序付けリストが先行する多項式の対（分子と分母）で
す。 もし表示される式がCRE形なら、もしくはもしCRE形の部分式を含むなら、
シンボル/R/が行ラベルに続きます。 式をCRE形に変換することに関してはRAT関
数を参照してください。 拡張CRE形は、テイラー級数の表現に使われます。 有
理式の概念が拡張され、変数の指数は、単に正の整数ではなく、正の有理数も負
の有理数も取ることができ、係数はそれ自身単なる多項式ではなく上で記載され
た有理式を取ることができます。 これらは内部的にはCRE形に似ていて、その一
般化である再帰多項式形によって表現されます。 それは、切り詰めの次数のよ
うな追加の情報を持ちます。 CRE形として、そんな式の行ラベルにはシンボル
/T/が続きます。


File: maxima.info,  Node: Functions and Variables for Polynomials,  Prev: Introduction to Polynomials,  Up: Polynomials

14.2 Functions and Variables for Polynomials
============================================

 -- オプション変数: algebraic
     デフォルト値: ‘false’

     代数的整数の整理の効果が現れるようにするためには、 ‘algebraic’は
     ‘true’に設定されなければいけません。

 -- オプション変数: berlefact
     デフォルト値: ‘true’

     ‘berlefact’が‘false’の時、 Kroneckerの因数分解アルゴリズムが使われ
     ます。 そうでなければ、Berlekampのアルゴリズム―これがデフォルトです
     ーが使われます。

 -- 関数: bezout (<p1>, <p2>, <x>)

     ‘resultant’コマンドの代替。 行列を返します。 この行列の
     ‘determinant’は、望みの結果です。

 -- 関数: bothcoef (<expr>, <x>)

     最初のメンバーが<expr>の中の<x>の （もし<expr>がCRE形なら
     ‘ratcoef’が見つけるような） 係数であり、 ２番目のメンバーが<expr>の
     残りの部分であるリストを返します。 例えば、 ‘<expr> = A*<x> + B’の
     ‘[A, B]’。

     例:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true

 -- 関数: coeff (<expr>, <x>, <n>)
 -- 関数: coeff (<expr>, <x>)

     <expr>の‘<x>^<n>’の係数を返します。 ここで、<expr>は<x>の多項式か単
     項式です。

     ‘coeff(<expr>, <x>^<n>)’は ‘coeff(<expr>, <x>, <n>)’と同値です。
     ‘coeff(<expr>, <x>, 0)’は <x>を含まない<expr>の剰余項を返します。 も
     し省略されたら、<n>は1が仮定されます。

     <x>は単純変数か添字付き変数か、演算子1つとその引数のすべてから構成
     されるexprの部分式です。

     ‘expand’か‘factor’を適用することで、 <expr>と同値な式の係数を計算す
     ることが可能かもしれません。 ‘coeff’自身は‘expand’や‘factor’や他の
     いかなる関数も 適用しません。

     例:

     ‘coeff’は<expr>の‘<x>^<n>’の係数を返します。

          (%i1) coeff (b^3*a^3 + b^2*a^2 + b*a + 1, a^3);
                                          3
          (%o1)                          b

     ‘coeff(<expr>, <x>^<n>)’は ‘coeff(<expr>, <x>, <n>)’と同値です。

          (%i1) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z, 3);
          (%o1)                         - c
                                           3
          (%i2) coeff (c[4]*z^4 - c[3]*z^3 - c[2]*z^2 + c[1]*z, z^3);
          (%o2)                         - c
                                           3

     ‘coeff(<expr>, <x>, 0)’は <expr>の<x>を含まない剰余項です。

          (%i1) coeff (a*u + b^2*u^2 + c^3*u^3, b, 0);
                                      3  3
          (%o1)                      c  u  + a u

     <x>は単純変数か添字付き変数か、演算子1つとその引数のすべてから構成
     されるexprの部分式です。

          (%i1) coeff (h^4 - 2*%pi*h^2 + 1, h, 2);
          (%o1)                        - 2 %pi
          (%i2) coeff (v[1]^4 - 2*%pi*v[1]^2 + 1, v[1], 2);
          (%o2)                        - 2 %pi
          (%i3) coeff (sin(1+x)*sin(x) + sin(1+x)^3*sin(x)^3, sin(1+x)^3);
                                          3
          (%o3)                        sin (x)
          (%i4) coeff ((d - a)^2*(b + c)^3 + (a + b)^4*(c - d), a + b, 4);
          (%o4)                         c - d

     ‘coeff’自身は‘expand’や‘factor’や他のいかなる関数も 適用しません。

          (%i1) coeff (c*(a + b)^3, a);
          (%o1)                           0
          (%i2) expand (c*(a + b)^3);
                           3          2        2        3
          (%o2)           b  c + 3 a b  c + 3 a  b c + a  c
          (%i3) coeff (%, a);
                                          2
          (%o3)                        3 b  c
          (%i4) coeff (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c, (a + b)^3);
          (%o4)                           0
          (%i5) factor (b^3*c + 3*a*b^2*c + 3*a^2*b*c + a^3*c);
                                            3
          (%o5)                      (b + a)  c
          (%i6) coeff (%, (a + b)^3);
          (%o6)                           c

     ‘coeff’はリスト、行列、等式上を散逸します。

          (%i1) coeff ([4*a, -3*a, 2*a], a);
          (%o1)                      [4, - 3, 2]
          (%i2) coeff (matrix ([a*x, b*x], [-c*x, -d*x]), x);
                                    [  a    b  ]
          (%o2)                     [          ]
                                    [ - c  - d ]
          (%i3) coeff (a*u - b*v = 7*u + 3*v, u);
          (%o3)                         a = 7

 -- 関数: content (<p_1>, <x_1>, …, <x_n>)
     最初のメンバーが、多項式変数<p_1>の<x_n> に関する項の係数（これが中
     身です）の最大公約数であり、 ２番目のメンバーが中身で多項式<p_1>を
     割ったものであるリストを返します。

     例:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]

 -- 関数: denom (<expr>)

     有理式<expr>の分母を返します。

 -- 関数: divide (<p_1>, <p_2>, <x_1>, …, <x_n>)

     メインの多項式変数<x_n>に関して、 多項式<p_2>で割った多項式<p_1>の
     商と余りを計算します。 他の変数は、‘ratvars’関数の中でようなもので
     す。 結果は、最初の要素が商で、２番目の要素が余りのリストです。

     例:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     ‘y’は２番目の例の主変数であることに注意してください。

 -- 関数: eliminate ([<eqn_1>, …, <eqn_n>], [<x_1>, …, <x_k>])

     連続する結果を取ることによって、式（もしくは0に等しいと仮定された式
     ）から変数を消去します。 これは、<k>個の変数<x_1>, ..., <x_k>が消去
     された ‘<n> - <k>’個の式のリストを返します。 最初、<x_1>が消去され
     、‘<n> - 1’個の式をもたらし、 そして、変数<x_2>が消去され、などなど
     。 もし‘<k> = <n>’なら、 変数<x_1>, ..., <x_k>に依らないリストの中
     の単一式が返されます。 この場合、最後の変数について最後の結果を解く
     ため、‘solve’がコールされます。

     例:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]

 -- 関数: ezgcd (<p_1>, <p_2>, <p_3>, …)
     最初の要素が、多項式<p_1>, <p_2>, <p_3>, …の最大公約数で、 残りの要
     素が、多項式を最大公約数で割ったものであるリストを返します。 これは
     いつも‘ezgcd’アルゴリズムを使います。

     ‘gcd’, ‘gcdex’, ‘gcdivide’, ‘poly_gcd’も参照してください。

     例:

     三つの多項式は最大公約数 ‘2*x-3’を持ちます。 GCDは最初、関数 ‘gcd’で
     計算され、その後、関数 ‘ezgcd’で計算されます。

          (%i1) p1 : 6*x^3-17*x^2+14*x-3;
                                  3       2
          (%o1)                6 x  - 17 x  + 14 x - 3
          (%i2) p2 : 4*x^4-14*x^3+12*x^2+2*x-3;
                              4       3       2
          (%o2)            4 x  - 14 x  + 12 x  + 2 x - 3
          (%i3) p3 : -8*x^3+14*x^2-x-3;
                                    3       2
          (%o3)                - 8 x  + 14 x  - x - 3

          (%i4) gcd(p1, gcd(p2, p3));
          (%o4)                        2 x - 3

          (%i5) ezgcd(p1, p2, p3);
                             2               3      2           2
          (%o5) [2 x - 3, 3 x  - 4 x + 1, 2 x  - 4 x  + 1, - 4 x  + x + 1]

 -- オプション変数: facexpand
     デフォルト値: ‘true’

     ‘facexpand’は、‘factor’が返すこれ以上小さくできない因子が 展開され
     た形式（デフォルト）か再帰的（正規のCRE）形式かを制御します。

 -- 関数: factor (<expr>)
 -- 関数: factor (<expr>, <p>)

     任意の数の変数と関数を含んだ式<expr>を整数上既約な因子に因数分解し
     ます。 ‘factor (<expr>, <p>)’は<expr>を、 有理数体上で、最小多項式
     が<p>である要素で因数分解します。

     ‘factor’は、整数を素因数分解するのに‘ifactor’関数を使います。

     ‘factorflag’が‘false’なら有理式の整数因子の素因数分解を抑制します。

     ‘dontfactor’は、因数分解しない変数のリストに設定されます。 （初期状
     態では空です。） 因数分解は、‘dontfactor’リスト上のそれらより（
     CRE形式で仮定された変数順序を使って）重要でない変数に関しても 実行
     されません。

     ‘savefactors’が‘true’なら、 同じ因子のいくつかを含む式の後の因数分
     解をスピードアップするために、因子の積である式の因子が、ある関数に
     よって保存されます。

     ‘berlefact’が ‘false’ならKroneckerの因数分解アルゴリズムが使われ、
     そうでなければ、デフォルトであるBerlekampのアルゴリズムが使われます
     。

     ‘intfaclim’が‘true’なら、 もし自明な割り算やPollardのロー法の後、因
     子が見つからないなら、整数の素因数分解をあきらめます。 ‘false’に設
     定されていれば（これはユーザーが陽に‘factor’をコールする場合です）
     整数の完全な素因数分解が企てられます。 ‘intfaclim’のユーザー設定は
     内部で‘factor’がコールされた時に使われます。 ‘intfaclim’はMaximaが
     大きな整数を素因数分解するのにありえない長い時間を使うことを妨げる
     ようにリセットされます。

     例:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)

 -- オプション変数: factorflag
     デフォルト値: ‘false’

     ‘factorflag’が‘false’の時、 有理式の整数因子の素因素分解を抑制しま
     す。

 -- 関数: factorout (<expr>, <x_1>, <x_2>, …)

     和<expr>を 形式‘f (<x_1>, <x_2>, …)*g’の項の和に再整理します。 ここ
     で、‘g’は、いかなる<x_i>も含まない式の積で、‘f’は因数分解されていま
     す。

     オプション変数‘keepfloat’は‘factorout’に無視されることに注意してく
     ださい。

     例:

          (%i1) expand (a*(x+1)*(x-1)*(u+1)^2);
                       2  2          2      2      2
          (%o1)     a u  x  + 2 a u x  + a x  - a u  - 2 a u - a
          (%i2) factorout(%,x);
                   2
          (%o2) a u  (x - 1) (x + 1) + 2 a u (x - 1) (x + 1)
                                                        + a (x - 1) (x + 1)

 -- 関数: factorsum (<expr>)

     <expr>の因子（それらは和です）の中の項を それらの和が因数分解可能な
     項のグループにグループ化しようとします。 ‘factorsum’は、 ‘expand
     ((x + y)^2 + (z + w)^2)’の結果を回復できますが、 項が共通の変数を持
     つので、 ‘expand ((x + 1)^2 + (x + y)^2)’は回復できません。

     例:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )

 -- 関数: fasttimes (<p_1>, <p_2>)

     多項式の掛け算のための特殊なアルゴリズムを使って、 多項式<p_1>と
     <p_2>の積を返します。 ‘p_1’と‘p_2’は、 多変数で、密で、ほぼ同じサイ
     ズであるべきです。 ‘n_1’が‘p_1’の次数で、 ‘n_2’が‘p_2’の次数だとす
     ると、 古典的な掛け算は、 ‘n_1 n_2’のオーダーですが、 ‘fasttimes’は
     、‘max (n_1, n_2)^1.585’のオーダーです。

 -- 関数: fullratsimp (<expr>)

     ‘fullratsimp’は、ratsimpと式の非有理的整理を、式変形されなくなるま
     で繰り返し適応し、結果を返します。

     非有理式が含まれる時、‘ratsimp’を１回コールと、その後の非有理的（「
     一般」）整理だけでは、 整理された結果を返すのに十分でないかもしれま
     せん。 時々、複数回のコールが必要とされます。 ‘fullratsimp’はこのプ
     ロセスを楽にしてくれます。

     ‘fullratsimp (<expr>, <x_1>, ..., <x_n>)’は‘ratsimp’や‘rat’と同様 複
     数の引数を取ります。

     例:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1

 -- 関数: fullratsubst (<a>, <b>, <c>)

     結果が変わらなくなるまで、自身を再帰的にコールすることを除いて、
     ‘ratsubst’と同じです。 置き換える式と置き換えられる式が１つ以上の変
     数を共通に持つ時、 この関数は役に立ちます。

     ‘fullratsubst’は、‘lratsubst’のフォーマットでも引数を受け付けます。
     すなわち、最初の引数は、１つの代入等式もしくは、そんな等式のリスト
     で、 一方、２番目の引数は処理される式というものです。

     ‘load ("lrats")’は、‘fullratsubst’と‘lratsubst’をロードします。

     例:

          (%i1) load ("lrats")$
        • ‘subst’は多重代入を実行できます。 ‘lratsubst’は‘subst’に類似し
          ています。
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        • もしただ１つの代入が望まれるなら、 最初の引数として１つの等式
          を与えます。
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b
        • ‘fullratsubst’は、 結果が変わらなくなるまで再帰することを除い
          て、 ‘ratsubst’と同値です。
          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b
        • ‘fullratsubst’も、 最初の引数として、等式のリストもしくは１つ
          の式を受け入れます。
          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b
        • ‘fullratsubst’は、不確定な再帰を起こすかもしれません。
          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET

 -- 関数: gcd (<p_1>, <p_2>, <x_1>, …)

     <p_1>と<p_2>の最大公約数を返します。 フラグ‘gcd’は、どのアルゴリズ
     ムを利用するか決めます。 ‘gcd’を‘ez’, ‘subres’, ‘red’, もしくは
     ‘spmod’ 設定することは、それぞれ、‘ezgcd’, 部分終結式‘prs’, 被約, も
     しくはモジュラーアルゴリズムを選択します。 もし‘gcd’が‘false’なら、
     ‘gcd (<p_1>, <p_2>, <x>)’は、すべての<x>に関していつも1を返します。
     （例えば、‘ratsimp’, ‘factor’, など）多くの関数は、 陰にgcdを計算し
     ます。 斉次多項式に関して、 ‘subres’に等しい‘gcd’を使うことが推奨さ
     れます。 例えば、‘gcd (<x>^2 - 2*sqrt(2)*<x> + 2, <x> - sqrt(2))’の
     ように、代数的数が含まれる時 ‘algebraic’は‘true’でなくてはいけませ
     ん。また、‘gcd’は‘ez’であってはいけません。

     ‘gcd’フラグ―デフォルトは‘spmod’―は、 もし‘false’なら、 式が標準有理
     式(CRE)形に変換される時も、最大公約数を計算させません。 もしgcdが要
     求されないなら、これは、時々計算のスピードを上げます。

     ‘ezgcd’, ‘gcdex’, ‘gcdivide’, ‘poly_gcd’も参照してください。

     例:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) gcd(p1, p2);
                                      2
          (%o3)                    6 x  + 13 x + 6
          (%i4) p1/gcd(p1, p2), ratsimp;
          (%o4)                         x + 1
          (%i5) p2/gcd(p1, p2), ratsimp;
                                        3
          (%o5)                        x  + x

     ‘ezgcd’は 一番目の要素が多項式 <p_1>と <p_2>の最大公約数で、 残りの
     要素が最大公約数で多項式を割ったもので構成されるリストを返します。

          (%i6) ezgcd(p1, p2);
                              2                     3
          (%o6)           [6 x  + 13 x + 6, x + 1, x  + x]

 -- 関数: gcdex (<f>, <g>)
 -- 関数: gcdex (<f>, <g>, <x>)

     リスト‘[<a>, <b>, <u>]’を返します。 ここで、<u>は<f>と<g>の最大公約
     数(gcd)であり、 かつ、‘<a> <f> + <b> <g>’は<u>に等しいです。 引数
     <f>と<g>は、１変数多項式であるか、 そうでなければ、指定された主変数
     <x>の多項式でなければいけません。 これが機能するには単項イデアル整
     域にある必要があるからです。 gcdは、他の変数の有理関数係数を持つ１
     変数多項式としての<f>と<g>に関するgcdを意味します。

     ‘gcdex’は、ユークリッドのアルゴリズムを実行します。 すべてが‘[f, g,
     -1]’に直角の‘L[i]: [a[i], b[i], r[i]]’の列を持ち、 ‘q =
     quotient(r[i]/r[i+1])’なら‘L[i+2]: L[i] - q L[i+1]’となるように次を
     組み立て、 余り‘r[i+2]’がゼロの時、‘L[i+1]’で終了します。

     引数 <f>と <g>は整数であり得ます。 この場合、‘gcdex’は関数
     ‘igcdex’を呼び出します。

     ‘ezgcd’, ‘gcd’, ‘gcdivide’, ‘poly_gcd’も参照してください。

     例:

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0

     以下のgcdは、 ‘k(y)[x]’に関して働くので‘1’です。 ‘k[y, x]’で期待す
     る‘y+1’ではないことに注意してください。

          (%i1) gcdex (x*(y + 1), y^2 - 1, x);
                                         1
          (%o1)/R/                 [0, ------, 1]
                                        2
                                       y  - 1

 -- 関数: gcfactor (<n>)

     ガウス整数 すなわち、<a>と<b>が有理整数(元々の整数) である形式‘<a>
     + <b> %i’ の数、<n>をガウス整数上に因数分解します。 因子は、<a>と
     <b>を非負にすることによって正規化されます。

 -- 関数: gfactor (<expr>)

     多項式<expr>をガウス整数（虚数単位‘%i’を付け加えた整数）上で因数分
     解します。 <a>が‘%i’となる‘factor (<expr>, <a>^2+1)’ようなものです
     。

     例:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)

 -- 関数: gfactorsum (<expr>)

     ‘factorsum’に似ていますが、 ‘factor’の代わりに‘gfactor’を適用します
     。

 -- 関数: hipow (<expr>, <x>)

     <expr>の中で、<x>の、陽に示された最も大きな指数を返します。 <x>は変
     数もしくは一般式です。 もし<x>が<expr>の中に現れないなら、 ‘hipow’は
     ‘0’を返します。

     ‘hipow’は、‘expr’に等価な式を考慮しません。 特に、‘hipow’は、
     ‘expr’を展開しないので、 ‘hipow (<expr>, <x>)’と‘hipow (expand
     (<expr>, <x>))’ は、違った結果をもたらすかもしれません。

     例:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0

 -- オプション変数: intfaclim
     デフォルト値: true

     もし‘true’なら、 もし試し割りとPollardのロー法の後、因子が見つから
     なければ、 Maximaは、整数の素因素分解をあきらめ、素因数分解は完了し
     ません。

     ‘intfaclim’が‘false’の時、 (これは、ユーザーが明示的に‘factor’をコ
     ールした場合です） 完全な素因数分解が試みられます。 ‘divisors’,
     ‘divsum’ や‘totient’の中で因子が計算される時は、 ‘intfaclim’は
     ‘false’に設定されます

     ‘factor’への内部コールは、 ‘intfaclim’のユーザー指定の値を考慮しま
     す。 ‘intfaclim’を‘true’に設定することは、 大きな整数を素因数分解す
     るのに費やす時間を少なくするかもしれません。

 -- オプション変数: keepfloat
     デフォルト値: ‘false’

     ‘keepfloat’が‘true’の時、 浮動小数点数を含む式が標準有理式(CRE)形に
     変換される時、 浮動小数点が有理数化されないようにします。

     関数‘solve’とそれを呼び出す関数(例えば‘eigenvalues’)は、 現在、この
     フラグを無視し、とにかく浮動小数点数を変換することに注意してくださ
     い。

     例:

          (%i1) rat(x/2.0);

          `rat' replaced 0.5 by 1/2 = 0.5
                                                 x
          (%o1)/R/                               -
                                                 2
          (%i2) rat(x/2.0), keepfloat;

          (%o2)/R/                     E        0.5 x

     ‘solve’ ignores ‘keepfloat’:

          (%i3) solve(1.0-x,x), keepfloat;

          `rat' replaced 1.0 by 1/1 = 1.0
          (%o3)                               [x = 1]

 -- 関数: lopow (<expr>, <x>)

     <expr>の中に陽に現れる<x>の最小の指数を返します。 例えば、

          (%i1) lopow ((x+y)^2 + (x+y)^a, x+y);
          (%o1)                       min(a, 2)

 -- 関数: lratsubst (<L>, <expr>)

     ‘subst’の代わりに‘ratsubst’を使うことを除いて、 ‘subst (<L>,
     <expr>)’に類似しています。

     ‘lratsubst’の最初の引数は、 ‘subst’が受け付けるそれと同一のフォーマ
     ットの等式もしくは等式のリストです。 代入は、等式のリストによって与
     えられた順、すなわち、左から右に、実行されます。

     ‘load ("lrats")’は、‘fullratsubst’と‘lratsubst’をロードします。

     例:

          (%i1) load ("lrats")$
        • ‘subst’は多重代入を実行できます。 ‘lratsubst’は‘subst’に似てい
          ます。
          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c
        • もし代入１つだけを望むなら、 １つの等式を最初の引数として与え
          ることができます。
          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

 -- オプション変数: modulus
     デフォルト値: ‘false’

     ‘modulus’が正の数<p>の時、 （‘rat’や関連の関数が返すように）有理数
     上の演算は、 「バランスさせた」モジュラス系と呼ばれるものを使って、
     <p>を法とする合同変換が実行されます。 「バランスさせた」モジュラス
     系では、 ‘<n> modulo <p>’は、 ‘<a> <p> + <k>’が<n>に等しくなるよう
     なある整数<a>が存在するような整数<k>と定義され、<k>は、 <p>が奇数の
     時、 ‘[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]’の中から、 <p>が偶数の時
     、‘[-(<p>/2 - 1), ..., 0, ...., <p>/2]’の中から 選ばれます。

     ‘modulus’が再設定された時、もし<expr>が既に標準有理式(CRE)形なら、
     正しい結果を得るためには、 例えば‘expr: rat (ratdisrep (expr))’とい
     うように、<expr>を再ratする必要があるかもしれません。

     典型的には、‘modulus’は素数が設定されます。 もし‘modulus’が正の合成
     数に設定されたら、 この設定は受け入れられますが、警告メッセージが表
     示されます。 Maximaは、ゼロや負の整数が‘modulus’に割り当てられるの
     を許します。 それが役に立つ結果を持つかどうか明らかではありませんが
     。

 -- 関数: num (<expr>)

     もし<expr>が比なら、その分子を返します。 もし<expr>が比でないなら、
     <expr>が返されます。

     ‘num’は引数を評価します。

 -- 関数: polydecomp (<p>, <x>)

     変数<x>の多項式<p>を<x>の多項式の関数合成に分解します。
     ‘polydecomp’は、

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x))
            ...))

     が<p>に等しいようなリスト‘[<p_1>, ..., <p_n>]’を返します。 <n>より
     小さい<i>について<p_i>の次数は1より大きいです。

     このような分解は一意的ではありません。

     例:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     以下の関数は、‘x’の関数として、 ‘L = [e_1, ..., e_n]’を合成します;
     それはpolydecompの逆です。

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     ‘compose’を使って、上の例を再表現します:

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     ‘compose (polydecomp (<p>, <x>), <x>)’はいつも （展開されていない）
     <p>を返しますが、 ‘polydecomp (compose ([<p_1>, ..., <p_n>], <x>),
     <x>)’は、 必ずしも‘[<p_1>, ..., <p_n>]’を返さないことに注意してくだ
     さい。

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2

 -- 関数: polymod (<p>)
 -- 関数: polymod (<p>, <m>)

     多項式<p>を、変数‘modulus’の値である現在の法に関してモジュラー表現
     に変換します。

     ‘polymod (<p>, <m>)’は、 ‘modulus’の現在値の代わりに法<m>を使うよう
     に指定します。

     ‘modulus’を参照してください。

 -- 関数: powers (<expr>, <x>)

     <expr>に現れる<x>のべきを返します。

     ‘load ("powers")’ loads this function.

 -- 関数: quotient (<p_1>, <p_2>)
 -- 関数: quotient (<p_1>, <p_2>, <x_1>, …, <x_n>)

     多項式<p_1>を多項式<p_2>で割った結果を返します。 引数<x_1>, …,
     <x_n>は、‘ratvars’と同様に解釈されます。

     ‘quotient’は、‘divide’が返す２要素リストの最初の要素を返します。

 -- 関数: rat (<expr>)
 -- 関数: rat (<expr>, <x_1>, …, <x_n>)

     <expr>を標準有理式(CRE)形式に変換します。 展開し、共通の分母上です
     べての項を結合し、通分し、‘ratepsilon’の許容誤差内で浮動小数点を有
     理数に変換します。 変数は、もし指定されたなら、‘ratvars’のように
     <x_1>, …, <x_n>に従って並び替えられます。

     ‘rat’は一般に、加算‘+’, 減算‘-’, 乗算‘*’, 除算‘/’と整数べきの指数を
     除いた関数を 整理しません。 一方で‘ratsimp’はこれらの場合を扱います
     。 CRE形式の中のアトム(数と変数）は一般形式でのそれと同じではないこ
     とに注意してください。 例えば、‘rat(x) - x’は‘rat(0)’を出力します。
     これは0とは違う内部表現を持ちます。

     ‘ratfac’が‘true’の時、 ‘rat’は、CREの一部因数分解された形式を出力し
     ます。 有理演算の最中、因数分解パッケージをコールなしに、式は可能な
     限り因数分解され続けます。 これにより常に、いくつかの計算でメモリと
     時間を節約することになります。 分子と分母は互いに素になり（例えば、
     ‘((x^2 - 1)^4/(x + 10^2)’は‘(x - 1)^4 (x + 1)^2’を出力します）、 そ
     れぞれの部分の中の因子は互いに素とは限りません。

     ‘ratprint’が‘false’ならユーザーに浮動小数点を有理数に変換したことを
     通知するメッセージの出力を抑制します。

     ‘keepfloat’が‘true’なら、浮動小数点が有理数に変換されることを抑制し
     ます。

     ‘ratexpand’と‘ratsimp’も参照してください。

     例:
          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /
                (4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y

 -- オプション変数: ratalgdenom
     デフォルト値: ‘true’

     ‘ratalgdenom’が‘true’の時、 根号に関する分母の有理化が有効になるこ
     とを許します。 ‘ratalgdenom’は、 標準有理式(CRE)が代数モードで使わ
     れる時だけ、効果を持ちます。

 -- 関数: ratcoef (<expr>, <x>, <n>)
 -- 関数: ratcoef (<expr>, <x>)

     式<expr>の中の式‘<x>^<n>’の係数を返します。 <n>を省略した場合、
     <n>は1が仮定されます。

     戻り値は、（非有理な意味で可能な場合を除いて、）xの中の変数の制約を
     受けません。 このタイプの係数が存在しなければ、0を返します。

     ‘ratcoef’は最初の引数を展開し、有理的に整理するので、 純粋に構文法
     的な‘coeff’のそれとは違った答えを生成することがあります。 このよう
     に、‘ratcoef ((x + 1)/y + x, x)’は‘(y + 1)/y’を返しますが、
     ‘coeff’は1を返します。

     ‘ratcoef (<expr>, <x>, 0)’は、<expr>をsumとして見て、 <x>を含まない
     項の和を返します。 ゆえに、もし<x>の負のべき乗が存在するなら、
     <ratcoef>を使うべきではありません。

     <expr>は検査される前に有理的に整理されるので、 係数は、想像された形
     とは全く違って現れることがあります。

     例:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x

 -- 関数: ratdenom (<expr>)

     <expr>を標準有理式(CRE)に強制した後、<expr>の分母を返します。 戻り
     値はCREです。

     <expr>は、もしまだCREでないなら、‘rat’によってCREに強制的に変換され
     ます。 この変換は、すべての項を共通の分母上に置くことによって、
     <expr>の形式を変えます。

     ‘denom’は似ていますが、 CREではなく通常の式を返します。 また、
     ‘denom’は共通の分母上にすべての項を置こうとはしませんし、
     ‘ratdenom’によって比と見なされるいくつかの式は、‘denom’には比と見な
     されません。

 -- オプション変数: ratdenomdivide
     デフォルト値: ‘true’

     ‘ratdenomdivide’が‘true’の時、 ‘ratexpand’は、分子が和である比を、
     共通の分母を持つ比の和に展開します。 そうでなければ、‘ratexpand’は
     比の和を１つの比に縮約します。 その比の分子はそれぞれの比の分子の和
     です。

     例:

          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3

 -- 関数: ratdiff (<expr>, <x>)

     有理式<expr>を<x>に関して微分します。 <expr>は<x>の多項式もしくは多
     項式の商でなければなりません。 引数<x>は<expr>の変数もしくは部分式
     を取り得ます。

     たぶん違った形式になりますが、結果は、‘diff’と同値です。 有理式の場
     合、‘ratdiff’は‘diff’より速いでしょう。

     ‘ratdiff’は、もし<expr>が標準有理式(CRE)なら、標準有理式を返します
     。 そうでなければ、一般式を返します。

     ‘ratdiff’は、<expr>の<x>への依存のみを考慮し、‘depends’で規定された
     依存性は無視します。

     例:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a

 -- 関数: ratdisrep (<expr>)

     一般式として引数を返します。 もし<expr>が一般式なら、戻り値は引数か
     ら変わりません。

     典型的には、‘ratdisrep’は、 標準有理式(CRE)を一般式に変換するために
     コールされます。 もし「伝染」を止めたかったり、非有理文脈で有理関数
     を使いたいなら、 これは、時々便利です。

     ‘totaldisrep’も参照してください。

 -- 関数: ratexpand (<expr>)
 -- オプション変数: ratexpand

     <expr>を展開します。 指数和や和の積を展開し、共通分母上の分数を結合
     し、通分し、（もし和なら）分子を分母で割ったそれぞれの項に分割しま
     す。

     たとえ<expr>が標準有理式(CRE)でも、‘ratexpand’の戻り値は一般式です
     。

     スイッチ‘ratexpand’が‘true’なら、CRE式は、一般式や表示形式に変換さ
     れた時フルに展開されます。 一方もし‘false’なら再帰形式に変換します
     。 ‘ratsimp’も参照してください。

     ‘ratdenomdivide’が‘true’の時、 ‘ratexpand’は、分子が和である比を、
     共通の分母を持つ比の和に展開します。 そうでなければ、‘ratexpand’は
     日の和を、その分子がそれぞれの比の分子の和である単一の比にまとめま
     す。

     ‘keepfloat’が‘true’の時、 浮動小数点を含んだ式がCRE形式に変換される
     時、浮動小数点が有理化されるのを抑制します。

     例:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1

 -- オプション変数: ratfac
     デフォルト値: ‘false’

     ‘ratfac’が‘true’の時、 標準有理式(CRE)は部分的に因数分解された形式
     で操作されます。

     有理演算の間、 式は、‘factor’をコールすることなしに、 可能な限り最
     大限因数分解されるよう維持されます。 これは、いつも保存領域を節約し
     、いくつかの計算では時間も節約ことがあります。 分子と分母は互いに素
     になります。 例えば、‘rat ((x^2 - 1)^4/(x + 1)^2)’は、 ‘(x - 1)^4
     (x + 1)^2)’をもたらしますが、 それぞれの部分の中の因子は互いに素で
     はないかもしれません。

     ‘ctensr’（成分テンソル操作）パッケージでは、 ‘ratfac’が‘true’の時、
     リッチ、アインシュタイン、リーマン、そしてワイルテンソルとスカラー
     曲率は、 自動的に因数分解されます。 ‘ratfac’は、テンソルの成分が２
     、３の項から成ると知られている場合だけ 設定すべきです。

     ‘ratfac’と‘ratweight’体系は互換性はなく、 同時には使えないかもしれ
     ません。

 -- 関数: ratnumer (<expr>)

     <expr>を標準有理式(CRE)に強制変換した後、その分子を返します。 戻り
     値はCREです。

     もしまだCREでないなら、<expr>は、‘rat’によってCREに強制変換されます
     。 この変換は、 共通の分母上にすべての項を置くことによって、
     <expr>の形式を変えるかもしれません。

     ‘num’は似ていますが、 CREではなく通常の式を返します。 また、‘num’は
     共通の分母上にすべての項を置こうとはしませんし、 ‘ratnumer’によって
     比と見なされるいくつかの式は、‘num’には比と見なされません。

 -- 関数: ratp (<expr>)

     もし<expr>が標準有理式(CRE)もしくは拡張CREなら、‘true’を返し、 そう
     でなければ、‘false’を返します。

     CREは、‘rat’と関連関数によって生成されます。 拡張CREは、‘taylor’と
     関連関数によって生成されます。

 -- オプション変数: ratprint
     デフォルト値: ‘true’

     ‘ratprint’が‘true’の時、 ユーザーに浮動小数点を有理数に変換したこと
     を通知するメッセージが表示されます。

 -- 関数: ratsimp (<expr>)
 -- 関数: ratsimp (<expr>, <x_1>, ..., <x_n>)

     式<exp>とその部分式の全てを有理的に整理します（非有理的関数の引数も
     含みます）。 結果は二つの多項式の商として、再帰的形式—主変数の係数
     が他の変数の多項式である形式—で返されます。 変数は(例えば、
     ‘sin(z^2+1)’のような)非有理関数を含むかもしれませんが、 どんな非有
     理関数の引数もまた、有理的に整理されます。

     ‘ratsimp (<expr>, <x_1>, ..., <x_n>)’は、‘ratvars’で指定した場合と
     同様に、 変数の順序指定に従って有理的に整理します。

     ‘ratsimpexpons’が‘true’の時、 ‘ratsimp’は式の指数にも適用されます。

     ‘ratexpand’も参照してください。 ‘ratsimp’は、‘ratexpand’に影響する
     フラグのいくつかに影響されることに注意してください。

     例:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x

 -- オプション変数: ratsimpexpons
     デフォルト値: ‘false’

     ‘ratsimpexpons’が‘true’の時、 式整理の間、‘ratsimp’が式の指数に適用
     されます。

 -- オプション変数: radsubstflag
     デフォルト値: ‘false’

     ‘radsubstflag’がもし ‘true’なら、 ‘ratsubst’が ‘x’に関して‘sqrt
     (x)’に ‘u’を代入するような代入をできるようにします。

 -- 関数: ratsubst (<a>, <b>, <c>)

     <c>の中の<b>に<a>を代入し、結果の式を返します。 <b>はsumでも
     productでもpowerなどでも問題ありません。

     ‘subst’は純粋に構文法的代入ですが、‘ratsubst’は式の意味の何かを知っ
     ています。 ゆえに、‘subst (a, x + y, x + y + z)’は‘x + y + z’を返す
     一方、 ‘ratsubst’は‘z + a’を返します。

     ‘ratsubstflag’が‘true’の時、‘ratsubst’は、式が陽には含んでいない根
     への代入を実行します。

     ‘ratsubst’はオプション変数‘keepfloat’の値‘true’を無視します。

     例:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u

 -- 関数: ratvars (<x_1>, …, <x_n>)
 -- 関数: ratvars ()
 -- システム変数: ratvars

     有理式に関して主変数<x_1>, ..., <x_n>を宣言します。 もし有理式の中
     に存在するなら、<x_n>は主変数と見なされます。 そうでなければ、もし
     存在すれば、<x_[n-1]>が主変数と見なされます。 と、先行する変数を通
     して<x_1>まで続きます。 <x_1>は、続く変数が存在しなかった時だけ主変
     数と見なされます。

     もし有理式の中の変数が‘ratvars’リストの中に存在しなかったら、 その
     変数には、<x_1>よりも低い優先順位が与えられます。

     ‘ratvars’の引数は、変数もしくは‘sin(x)’のような非有理関数であり得ま
     す。

     変数‘ratvars’は、直近にコールされたときの関数‘ratvars’の引数のリス
     トです。 関数‘ratvars’のコールそれぞれは、リストを再設定します。
     ‘ratvars ()’はリストをクリアします。

 -- オプション変数: ratvarswitch
     デフォルト値: ‘true’

     MaximaはLisp変数‘VARLIST’の中に有理式の主変数の内部リストを保持しま
     す。 もし‘ratvarswitch’が‘true’なら、 すべての評価は新しいリスト
     ‘VARLIST’で開始します。 これがデフォルトの振る舞いです。 そうでなけ
     れば、以前の評価からの主変数は 内部リスト‘VARLIST’から取り除かれま
     せん。

     主変数は関数‘ratvars’で宣言されるのですが、 それはオプション変数
     ‘ratvarswitch’によって影響されません。

     例:

     もし ‘ratvarswitch’が‘true’, すべての評価は 新しいリスト‘VARLIST’で
     始まります。

          (%i1) ratvarswitch:true$

          (%i2) rat(2*x+y^2);
                                       2
          (%o2)/R/                    y  + 2 x
          (%i3) :lisp varlist
          ($X $Y)

          (%i3) rat(2*a+b^2);
                                       2
          (%o3)/R/                    b  + 2 a

          (%i4) :lisp varlist
          ($A $B)

     もし‘ratvarswitch’が‘false’なら、 直前の評価からの主変数はまだ存在
     しています。

          (%i4) ratvarswitch:false$

          (%i5) rat(2*x+y^2);
                                       2
          (%o5)/R/                    y  + 2 x
          (%i6) :lisp varlist
          ($X $Y)

          (%i6) rat(2*a+b^2);
                                       2
          (%o6)/R/                    b  + 2 a

          (%i7) :lisp varlist
          ($A $B $X $Y)

 -- 関数: ratweight (<x_1>, <w_1>, …, <x_n>, <w_n>)
 -- 関数: ratweight ()

     重み<w_i>を変数<x_i>に割り当てます。 これは、もし重みが変数
     ‘ratwtlvl’の値を越えるなら、項を0に置き換えるようにします。 （デフ
     ォルトでは切り詰めはもたらしません。） 項の重みは、項の中の変数の重
     みの積の和に変数の指数を掛けたものです。 例えば、‘3 x_1^2 x_2’の重
     みは‘2 w_1 + w_2’です。 ‘ratwtlvl’に従った切り詰めは、 標準有理式
     (CRE)を掛けたり、指数化する時だけ実行されます。

     ‘ratweight ()’は、重み割り当ての累積リストを返します。

     注意：‘ratfac’と‘ratweight’体系は互換性はなく、 同時には使えないか
     もしれません。

     例:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1

 -- システム変数: ratweights
     デフォルト値: ‘[]’

     ‘ratweights’は、‘ratweight’で割り当てられた重みのリストです。 リス
     トは累積されます: ‘ratweight’のコールそれぞれは、リストに項目を追加
     します。

     ‘kill (ratweights)’と‘save (ratweights)’はともに期待通り動作します
     。

 -- オプション変数: ratwtlvl
     デフォルト値: ‘false’

     ‘ratwtlvl’は、 標準有理式(CRE)の切り詰めを制御するために、
     ‘ratweight’関数と組み合わせて使われます。 デフォルト値の‘false’では
     、切り詰めは起こりません。

 -- 関数: remainder (<p_1>, <p_2>)
 -- 関数: remainder (<p_1>, <p_2>, <x_1>, …, <x_n>)

     多項式<p_1>を多項式<p_2>で割った余りを返します。 引数<x_1>, ...,
     <x_n>は、‘ratvars’と同様に解釈されます。

     ‘remainder’は、‘divide’が返す２要素リストの２番目の要素を返します。

 -- 関数: resultant (<p_1>, <p_2>, <x>)
 -- 変数: resultant

     変数<x>を消去して、２つの多項式<p_1>と<p_2>の終結式を計算します。 終
     結式は<p_1>と<p_2>の中の<x>の係数の判別式です。 それは、<p_1>と
     <p_2>が共通に定数でない因子を持つ時だけゼロに等しいです。

     もし<p_1>もしくは<p_2>が因数分解できるなら、 ‘resultant’をコールす
     る前に‘factor’をコールするのが望ましいかもしれません。

     変数‘resultant’は、 どのアルゴリズムが計算に使われるか制御します。
     部分終結式prsには‘subres’ モジュラー終結式アルゴリズムには‘mod’ 通
     分prsには‘red’。 大抵の問題では、‘subres’が最適です。 いくつかの大
     きな次数の１変数もしくは２変数問題では、‘mod’がよりよいかもしれませ
     ん。

     関数‘bezout’は、‘resultant’と同じ引数を取り、 行列を返します。 戻り
     値の判別式は望みの終結式です。

 -- オプション変数: savefactors
     デフォルト値: ‘false’

     ‘savefactors’が‘true’の時、 同じ因子のいくつかを含む式の因数分解を
     後でする時にスピードアップするために、 因子の積である式の因子がある
     関数によって保存されるようにします。

 -- 関数: showratvars (<expr>)
     式‘expr’の中の標準有理式 (CRE)変数のリストを返します。

     ‘ratvars’も参照してください。

 -- 関数: sqfr (<expr>)

     多項式因子が「平方にならない」ことを除いて、 ‘factor’に似ています。
     すなわち、それらは、次数１だけの因子を持ちます。 このアルゴリズムは
     、‘factor’の最初の段階でも使われるのですが、 多項式は、n階微分と共
     通に nよりも大きな次数のすべての因子を持つという事実を使います。 こ
     のように、それぞれの変数に関する微分の多項式との最大公約数を取るこ
     とによって、 1よりも大きな次数の因子を見つけることができます。

     例:

          (%i1) sqfr (4*x^4 + 4*x^3 - 3*x^2 - 4*x - 1);
                                          2   2
          (%o1)                  (2 x + 1)  (x  - 1)

 -- 関数: tellrat (<p_1>, ..., <p_n>)
 -- 関数: tellrat ()

     多項式<p_1>, ..., <p_n>の解である要素を Maximaに知られている代数的
     整数の環に加えます。 それぞれの引数<p_i>は、整数係数の多項式です。

     ‘tellrat (<x>)’は、実際には、 有理関数の中で<x>に0を代入することを
     意味します。

     ‘tellrat ()’は、現在の代入のリストを返します。

     代数的整数の整理が効果を持つようにするために、 ‘algebraic’は、
     ‘true’に設定されなければいけません。

     Maximaは、起動の際には、虚数単位と整数の根すべてについて知っていま
     す。

     核を取り、‘tellrat’プロパティを削除するコマンド‘untellrat’がありま
     す。

     例えば、‘tellrat (x^2 - y^2)’のように、 多変数多項式を‘tellrat’する
     時、 ‘<y>^2’を‘<x>^2’に代入するのか逆なのかといった あいまいさがあ
     ります。 Maximaは、特定の順序付けを選びますが、 もしユーザーがどち
     らか指定したいなら、 例えば，‘tellrat (y^2 = x^2)’は ‘<y>^2’を
     ‘<x>^2’で置き換えることを示す構文法を供給します。

     例:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]

 -- 関数: totaldisrep (<expr>)

     <expr>のすべての部分式を標準有理式(CRE)から一般形に変換して、 結果
     を返します。 もし<expr>がそれ自身CRE形なら、‘totaldisrep’は、
     ‘ratdisrep’と同一です。

     ‘totaldisrep’は、 CRE形の部分式を持つ等式やリストや行列などの式を
     ratdisrepするために役に立つかもしれません。

 -- 関数: untellrat (<x_1>, …, <x_n>)
     <x_1>, …, <x_n>から ‘tellrat’プロパティを 削除します。


File: maxima.info,  Node: Special Functions,  Next: Elliptic Functions,  Prev: Polynomials,  Up: Top

15 Special Functions
********************

* Menu:

* Introduction to Special Functions::
* Bessel Functions::
* Airy Functions::
* Gamma and factorial Functions::
* Exponential Integrals::
* Error Function::
* Struve Functions::
* Hypergeometric Functions::
* Parabolic Cylinder Functions::
* Functions and Variables for Special Functions::  


File: maxima.info,  Node: Introduction to Special Functions,  Next: Bessel Functions,  Prev: Special Functions,  Up: Special Functions

15.1 Introduction to Special Functions
======================================

特殊関数表記は以下の通りです:

     bessel_j (index, expr)         第一種ベッセル関数
     bessel_y (index, expr)         第二種ベッセル関数
     bessel_i (index, expr)         第一種変形ベッセル関数
     bessel_k (index, expr)         第二種変形ベッセル関数

     hankel_1 (v,z)                 第一種ハンケル関数
     hankel_2 (v,z)                 第二種ハンケル関数
     struve_h (v,z)                 シュトルーベH関数
     struve_l (v,z)                 シュトルーベL関数

     assoc_legendre_p[v,u] (z)      位数v、次数uのルジャンドル関数
     assoc_legendre_q[v,u] (z)      第二種ルジャンドル関数

     %f[p,q] ([], [], expr)         一般化超幾何関数
     gamma()                        ガンマ関数
     gamma_incomplete_lower(a,z)    第一種不完全ガンマ関数
     gammaincomplete(a,z)           第二種不完全ガンマ関数
     hypergeometric(l1, l2, z)      超幾何関数
     slommel
     %m[u,k] (z)                    第一種Whittaker関数
     %w[u,k] (z)                    第二種Whittaker関数
     erfc (z)                       相補誤差関数
     ei (z)                         指数積分 (?)
     kelliptic (z)                  第一種完全楕円積分 (K)
     parabolic_cylinder_d (v,z)     放物円筒D関数


File: maxima.info,  Node: Bessel Functions,  Next: Airy Functions,  Prev: Introduction to Special Functions,  Up: Special Functions

15.2 Bessel Functions
=====================

 -- 関数: bessel_j (<v>, <z>)

     次数vと独立変数zの第一種ベッセル関数。

     ‘bessel_j’は以下のように定義されます。

                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     計算のために無限級数は使われませんが。

 -- 関数: bessel_y (<v>, <z>)

     次数vと独立変数zの第二種ベッセル関数

     vが整数でない時、 ‘bessel_y’は以下のように定義されます。
                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     vが整数nの時、 vがnに近づく極限が取られます。

 -- 関数: bessel_i (<v>, <z>)

     次数v、独立変数zの第一種変形ベッセル関数

     ‘bessel_i’は以下のように定義されます。
                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     無限級数は計算には使われませんが。

 -- 関数: bessel_k (<v>, <z>)

     次数v、独立変数zの第二種変形ベッセル関数

     vが整数の時 ‘bessel_k’は以下のように定義されます。
                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     もしvが整数nでないなら、 vがnに近づく極限が取られます。

 -- 関数: hankel_1 (<v>, <z>)

     次数v、独立変数zの第一種ハンケル関数 (A&S 9.1.3)。 ‘hankel_1’は以下
     のように定義されます。

             bessel_j(v,z) + %i * bessel_y(v,z)

     Maximaは、 浮動小数点精度の実数次数vと複素独立変数zに対して
     ‘hankel_1’を数値的に評価します。 多倍長浮動小数点精度の数値評価と複
     素次数vはサポートされていません。

     ‘besselexpand’が‘true’の時、 次数vが奇数の1/2の時‘hankel_1’は初等関
     数の項に展開されます。 ‘besselexpand’を参照してください。

     Maximaは‘hankel_1’の独立変数zに関する導関数を知っています。

     例:

     数値評価:

          (%i1) hankel_1(1,0.5);
          (%o1)              .2422684576748738 - 1.471472392670243 %i
          (%i2) hankel_1(1,0.5+%i);
          (%o2)             - .2558287994862166 %i - 0.239575601883016

     複素次数vはサポートされていません。 Maximaは名詞形を返します:

          (%i3) hankel_1(%i,0.5+%i);
          (%o3)                       hankel_1(%i, %i + 0.5)

     ‘besselexpand’が‘true’の時の‘hankel_1’の展開:

          (%i4) hankel_1(1/2,z),besselexpand:true;
                                sqrt(2) sin(z) - sqrt(2) %i cos(z)
          (%o4)                 ----------------------------------
                                        sqrt(%pi) sqrt(z)

     ‘hankel_1’の独立変数zに関する導関数。 次数vに関する導関数はサポート
     されていません。 Maximaは名詞形を返します:

          (%i5) diff(hankel_1(v,z),z);
                              hankel_1(v - 1, z) - hankel_1(v + 1, z)
          (%o5)               ---------------------------------------
                                                 2
          (%i6) diff(hankel_1(v,z),v);
                                       d
          (%o6)                        -- (hankel_1(v, z))
                                       dv

 -- 関数: hankel_2 (<v>, <z>)

     次数v、独立変数zの第二種ハンケル関数 (A&S 9.1.4)。 ‘hankel_2’は以下
     のように定義されます。

             bessel_j(v,z) - %i * bessel_y(v,z)

     Maximaは、 浮動小数点精度の実数次数vと複素独立変数zに対して
     ‘hankel_2’を数値的に評価します。 多倍長浮動小数点精度の数値評価と複
     素次数vはサポートされていません。

     ‘besselexpand’が‘true’の時、 次数vが奇数の1/2の時‘hankel_2’は初等関
     数の項に展開されます。 ‘besselexpand’を参照してください。

     Maximaは‘hankel_2’の独立変数zに関する導関数を知っています。

     例は‘hankel_1’を参照してください。

 -- オプション変数: besselexpand
     デフォルト値: ‘false’

     次数が半奇数の時のベッセル関数の展開を制御します。 この場合、ベッセ
     ル関数は他の初等関数で展開することができます。 ‘besselexpand’が
     ‘true’の時、 ベッセル関数は展開されます。

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                                  sin(z)   cos(z)
                                 sqrt(2) sqrt(z) (------ - ------)
                                                     2       z
                                                    z
          (%o4)                  ---------------------------------
                                             sqrt(%pi)

 -- 関数: scaled_bessel_i (<v>, <z>)

     次数v、独立変数zのスケールされた第一種変形ベッセル関数。 すなわち、
     scaled_bessel_i(v,z) = exp(-abs(z))*bessel_i(v, z)。 この関数は、大
     きなzに関するbessel_i―これはおおきくなりますーの計算に 特に役に立ち
     ます。 しかしながら、そうでなければ、Maximaはこの関数についてあまり
     知りません。 数式処理のためには、式‘exp(-abs(z))*bessel_i(v, z)’を
     使って取り組むのが多分望ましいです。

 -- 関数: scaled_bessel_i0 (<z>)

     ‘scaled_bessel_i(0,z)’と同一です。

 -- 関数: scaled_bessel_i1 (<z>)

     ‘scaled_bessel_i(1,z)’と同一です。

 -- 関数: %s [<u>,<v>] (<z>)
     Lommelの小s[u,v](z)関数。 多分Gradshteyn & Ryzhik 8.570.1.


File: maxima.info,  Node: Airy Functions,  Next: Gamma and factorial Functions,  Prev: Bessel Functions,  Up: Special Functions

15.3 Airy Functions
===================

エアリー関数Ai(x)とBi(x)は、Abramowitz and Stegun, Handbook of
Mathematical Functions, Section 10.4の中で定義されています。

   ‘y = Ai(x)’と‘y = Bi(x)’は、 エアリー微分方程式‘diff (y(x), x, 2) - x
y(x) = 0’の ２つの線形独立な解です。

   もし引数‘x’が実数もしくは複素数の浮動小数点数なら、 関数の数値が返さ
れます。

 -- 関数: airy_ai (<x>)
     エアリー関数Ai(x)。 (A&S 10.4.2)

     導関数‘diff (airy_ai(x), x)’は、‘airy_dai(x)’です。

     ‘airy_bi’, ‘airy_dai’, ‘airy_dbi’も参照してください。

 -- 関数: airy_dai (<x>)
     エアリー関数Ai ‘airy_ai(x)’の導関数。

     ‘airy_ai’を参照してください。

 -- 関数: airy_bi (<x>)
     エアリー関数Bi(x)。 (A&S 10.4.3)

     導関数‘diff (airy_bi(x), x)’は‘airy_dbi(x)’です。

     ‘airy_ai’, ‘airy_dbi’を参照してください。

 -- 関数: airy_dbi (<x>)
     エアリーBi関数‘airy_bi(x)’の導関数。

     ‘airy_ai’と‘airy_bi’を参照してください。


File: maxima.info,  Node: Gamma and factorial Functions,  Next: Exponential Integrals,  Prev: Airy Functions,  Up: Special Functions

15.4 Gamma and factorial Functions
==================================

ガンマ関数と、関連したベータ、プサイ、不完全ガンマ関数は Abramowitz and
Stegun, Handbook of Mathematical Functions, Chapter 6の中で定義されてい
ます。

 -- 関数: bffac (<expr>, <n>)
     階乗（シフトガンマ）関数の多倍長浮動小数点バージョン。 ２番目の引数
     は、保持し返すディジットの数です。 少しの余分を要請するのはいい考え
     です。

 -- 関数: bfpsi (<n>, <z>, <fpprec>)
 -- 関数: bfpsi0 (<z>, <fpprec>)
     ‘bfpsi’は、実引数<z>と整数次数<n>の多ガンマ関数です。 ‘bfpsi0’はデ
     ィガンマ関数です。 ‘bfpsi0 (<z>, <fpprec>)’は‘bfpsi (0, <z>,
     <fpprec>)’と同値です。

     これらの関数は多倍長浮動小数点値を返します。 <fpprec>は戻り値の多倍
     長浮動小数点精度です。

 -- 関数: cbffac (<z>, <fpprec>)
     複素多倍長浮動小数点の階乗です。

     ‘load ("bffac")’はこの関数をロードします。

 -- 関数: gamma (<z>)

     ガンマ関数の基本的な定義 (A&S 6.1.1) は、

                                   inf
                                  /
                                  [     z - 1   - t
                       gamma(z) = I    t      %e    dt
                                  ]
                                  /
                                   0
     です。

     Maximaは、正の整数と正負の有理数に関して、‘gamma’を整理します。 半
     整数値に関して、結果は有理数掛ける‘sqrt(%pi)’です。 整数値に関する
     整理は、‘factlim’によって制御されます。

     ‘factlim’より大きな整数に関して、 階乗関数ー‘gamma’を計算するのに使
     われますーの数値的な結果はオーバーフローします。 有理数に関する整理
     は、内部オーバーフローを避けるために、 ‘gammalim’によって制御されま
     す。 ‘factlim’と‘gammalim’も参照してください。

     負の整数に関して、‘gamma’は未定義です。

     Maximaは、浮動小数点および多倍長浮動小数点の実数値および複素数値に
     関して、 ‘gamma’を数値的に評価できます。

     ‘gamma’は鏡像対称性を持ちます。

     ‘gamma_expand’が‘true’の時、 Maximaは、 引数‘z+n’と‘z-n’―‘n’は整数
     ―の‘gamma’を 展開します。

     Maximaは、‘gamma’の導関数を知っています。

     例:

     整数、半整数、有理数に関する整理:

          (%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
          (%o1)        [1, 1, 2, 6, 24, 120, 720, 5040, 40320]
          (%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                              sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
          (%o2)   [sqrt(%pi), ---------, -----------, ------------]
                                  2           4            8
          (%i3) map('gamma,[2/3,5/3,7/3]);
                                            2           1
                                    2 gamma(-)  4 gamma(-)
                                2           3           3
          (%o3)          [gamma(-), ----------, ----------]
                                3       3           9

     実数と複素数の数値評価:

          (%i4) map('gamma,[2.5,2.5b0]);
          (%o4)     [1.329340388179137, 1.329340388179137b0]
          (%i5) map('gamma,[1.0+%i,1.0b0+%i]);
          (%o5) [.4980156681183558 - .1549498283018108 %i,
                   4.980156681183561b-1 - 1.549498283018107b-1 %i]

     ‘gamma’は鏡像対称性を持ちます:

          (%i6) declare(z,complex)$
          (%i7) conjugate(gamma(z));
          (%o7)                  gamma(conjugate(z))

     ‘gamma_expand’が‘true’の時 Maximaは、‘gamma(z+n)’と‘gamma(z-n)’を展
     開します:

          (%i8) gamma_expand:true$

          (%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                         gamma(z)
          (%o9)             [z gamma(z), --------, z + 1]
                                          z - 1

     ‘gamma’の導関数:

          (%i10) diff(gamma(z),z);
          (%o10)                  psi (z) gamma(z)
                                     0

     ‘makegamma’も参照してください。

     オイラー-マスケローニ定数は‘%gamma’です。

 -- 関数: log_gamma (<z>)

     ガンマ関数の自然対数。

 -- 関数: gamma_incomplete (<a>,<z>)

     第二種不完全ガンマ関数 A&S 6.5.2:

                                        inf
                                       /
                                       [     a - 1   - t
              gamma_incomplete(a, z) = I    t      %e    dt
                                       ]
                                       /
                                        z

 -- 関数: gamma_incomplete_regularized (<a>, <z>)

     正則第二種不完全ガンマ関数 A&S 6.5.1:

          gamma_incomplete_regularized(a, z) =
                                                  gamma_incomplete(a, z)
                                                  ----------------------
                                                         gamma(a)

 -- 関数: gamma_incomplete_generalized (<a>,<z1>,<z1> )
     一般化不完全ガンマ関数

          gamma_incomplete_generalized(a, z1, z2) =
                                                         z2
                                                        /
                                                        [    a - 1   - t
                                                        I   t      %e    dt
                                                        ]
                                                        /
                                                         z1

 -- オプション変数: gammalim
     デフォルト値: 1000000

     ‘gammalim’は、整数と有理数引数に関してガンマ関数の整理を制御します
     。 もし引数の絶対値が‘gammalim’よりも大きくないなら、 整理が行われ
     ます。 ‘factlim’スイッチは、 整数引数の‘gamma’の結果の整理を制御し
     ます。 ‘factlim’スイッチは、 整数引数の‘gamma’の結果の整理も制御す
     ることに注意してください。

 -- 関数: makegamma (<expr>)
     <expr>の中の２項、階乗、ベータ関数のインスタンスをガンマ関数に変換
     します。

     ‘makefact’も参照してください。

 -- 関数: beta (<a>, <b>)
     ベータ関数は、‘gamma(a) gamma(b)/gamma(a+b)’ (A&S 6.2.1)として定義
     されます。

     Maximaは、正の整数と、合計すると整数になる有理数についてベータ関数
     を整理します。 ‘beta_args_sum_to_integer’が‘true’の時、 Maximaは、
     和が整数になる一般式も整理します。

     <a>もしくは<b>がゼロに等しい時には、ベータ関数は未定義です。

     一般にベータ関数は、負の整数の引数で未定義です。 例外は、
     <a=-n>―<n>は正の整数―かつ<b>が<b<=n>の正の整数で、 解析接続を定義す
     ることが可能です。 Maximaはこの場合結果を与えます。

     ‘beta_expand’が‘true’の時、 ‘n’を整数とする‘beta(a+n,b)’と
     ‘beta(a-n,b)’、 もしくは‘beta(a,b+n)’と‘beta(a,b-n)’ のような式は整
     理されます。

     Maximaは、実数値と複素数値のベータ関数を浮動小数点と多倍長浮動小数
     点精度で評価できます。 数値評価のために、Maximaは‘log_gamma’を使い
     ます:

                     - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
                   %e

     Maximaは、ベータ関数が対称で、鏡像対称性を持つことを知っています。

     Maximaは、<a>または<b>に関するベータ関数の導関数を知っています。

     ベータ関数をガンマ関数の比として表現するには、‘makegamma’を参照して
     ください。

     例:

     引数の１つが整数の時の整理:

          (%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                                         1   9      1
          (%o1)                         [--, -, ---------]
                                         12  4  a (a + 1)

     ２つの有理数引数の和が整数になる時の整理:

          (%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                                    3 %pi   2 %pi
          (%o2)                    [-----, -------, sqrt(2) %pi]
                                      8    sqrt(3)

     ‘beta_args_sum_to_integer’を‘true’に設定した時、 引数の和が整数の時
     、さらに一般的な式が整理されます:

          (%i3) beta_args_sum_to_integer:true$
          (%i4) beta(a+1,-a+2);
                                          %pi (a - 1) a
          (%o4)                         ------------------
                                        2 sin(%pi (2 - a))

     引数の１つが負の整数の時、可能な結果:

          (%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                              1  1    1
          (%o5)                            [- -, -, - -]
                                              3  6    3

     ‘beta_expand’が‘true’の時、 ‘n’が整数の‘beta(a+n,b)’または
     ‘beta(a-n)’は整理されます:

          (%i6) beta_expand:true$
          (%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                              a beta(a, b)  beta(a, b) (b + a - 1)  a
          (%o7)              [------------, ----------------------, -]
                                 b + a              a - 1           b

     引数の１つがゼロの時、ベータは未定義です:

          (%i7) beta(0,b);
          beta: expected nonzero arguments; found 0, b
           -- an error.  To debug this try debugmode(true);

     実数値と複素数値の浮動小数点または多倍長浮動小数点精度での数値評価:

          (%i8) beta(2.5,2.3);
          (%o8) .08694748611299981

          (%i9) beta(2.5,1.4+%i);
          (%o9) 0.0640144950796695 - .1502078053286415 %i

          (%i10) beta(2.5b0,2.3b0);
          (%o10) 8.694748611299969b-2

          (%i11) beta(2.5b0,1.4b0+%i);
          (%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i

     ベータは対称で、鏡像対称性を持ちます:

          (%i14) beta(a,b)-beta(b,a);
          (%o14)                                 0
          (%i15) declare(a,complex,b,complex)$
          (%i16) conjugate(beta(a,b));
          (%o16)                 beta(conjugate(a), conjugate(b))

     ‘a’に関するベータ関数の導関数:
          (%i17) diff(beta(a,b),a);
          (%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                                0             0

 -- 関数: beta_incomplete (<a>, <b>, <z>)

     不完全ベータ関数の基本定義(A&S 6.6.1)は、以下の通りです。

                  z
                 /
                 [         b - 1  a - 1
                 I  (1 - t)      t      dt
                 ]
                 /
                  0

     この定義は、realpart(a)>0かつrealpart(b)>0かつabs(z)<1で可能です。
     他の値では不完全ベータ関数は一般化超幾何関数を通じて定義することが
     できます。

             gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z

     (不完全ベータ関数の完全な定義については、functions.wolfram.comを参
     照してください。 )

     負の整数a = -nと正の整数b=mで、m<=nの場合、 不完全ベータ関数は以下
     を通して定義されます。

                                      m - 1           k
                                      ====  (1 - m)  z
                                n - 1 \            k
                               z       >    -----------
                                      /     k! (n - k)
                                      ====
                                      k = 0

     Maximaは、 負の整数<a>に関する‘beta_incomplete’を整理するために、こ
     の定義を使います。

     <a>が正の整数の時、 任意の引数<b>, <z>に関して、 <b>が正の整数の時
     、 非負の整数<a>, 任意の<z>に関して、 ‘beta_incomplete’は整理されま
     す。

     z=0かつrealpart(a)>0の時、‘beta_incomplete’は特別な値ゼロを取ります
     。 <z=1>かつrealpart(b)>0の時、 ‘beta_incomplete’はベータ関数
     ‘beta(a,b)’に整理されます。

     Maximaは、浮動小数点か多倍長浮動小数点精度の実数値と複素数値に対し
     て、 ‘beta_incomplete’を数値的に評価します。 数値評価に関して、 不
     完全ベータ函数の連分数展開を使います。

     オプション変数‘beta_expand’が‘true’の時、 Maximaは
     ‘beta_incomplete(a+n,b,z)’や‘beta_incomplete(a-n,b,z)’のような式を
     展開します。ここでnは正の整数です。

     Maximaは‘beta_incomplete’の変数<a>, <b>, <z>についての導関数と 変数
     <z>についての積分を知っています。

     例:

     正の整数<a>に関する整理:

          (%i1) beta_incomplete(2,b,z);
                                                 b
                                      1 - (1 - z)  (b z + 1)
          (%o1)                       ----------------------
                                            b (b + 1)

     正の整数<b>に関する整理:

          (%i2) beta_incomplete(a,2,z);
                                                         a
                                        (a (1 - z) + 1) z
          (%o2)                         ------------------
                                            a (a + 1)

     正の整数<a>, <b>に関する整理:

          (%i3) beta_incomplete(3,2,z);
                                                         3
                                        (3 (1 - z) + 1) z
          (%o3)                         ------------------
                                                12

     <a>が負の整数かつb<=(-a)の時、Maximaは整理します:

          (%i4) beta_incomplete(-3,1,z);
                                                 1
          (%o4)                              - ----
                                                  3
                                               3 z

     特定の値z=0とz=1に関して, Maximaは整理します:

          (%i5) assume(a>0,b>0)$
          (%i6) beta_incomplete(a,b,0);
          (%o6)                                 0
          (%i7) beta_incomplete(a,b,1);
          (%o7)                            beta(a, b)

     浮動小数点または多倍長浮動小数点精度の数値評価:

          (%i8) beta_incomplete(0.25,0.50,0.9);
          (%o8)                          4.594959440269333
          (%i9)  fpprec:25$
          (%i10) beta_incomplete(0.25,0.50,0.9b0);
          (%o10)                    4.594959440269324086971203b0

     abs(z)>1の時、‘beta_incomplete’は複素数を返します:

          (%i11) beta_incomplete(0.25,0.50,1.7);
          (%o11)              5.244115108584249 - 1.45518047787844 %i

     もっと一般的な複素引数に関する結果:

          (%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
          (%o14)             2.726960675662536 - .3831175704269199 %i
          (%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
          (%o15)             13.04649635168716 %i - 5.802067956270001
          (%i16)

     ‘beta_expand’が‘true’の時の展開:

          (%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                                 b  a
                             a beta_incomplete(a, b, z)   (1 - z)  z
          (%o23)             -------------------------- - -----------
                                       b + a                 b + a

          (%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                                     b  a - 1
                     beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
          (%o24)     -------------------------------------- - ---------------
                                     1 - a                         1 - a

     ‘beta_incomplete’の微分と積分:

          (%i34) diff(beta_incomplete(a, b, z), z);
                                        b - 1  a - 1
          (%o34)                 (1 - z)      z
          (%i35) integrate(beta_incomplete(a, b, z), z);
                        b  a
                 (1 - z)  z
          (%o35) ----------- + beta_incomplete(a, b, z) z
                    b + a
                                                 a beta_incomplete(a, b, z)
                                               - --------------------------
                                                           b + a
          (%i36) factor(diff(%, z));
          (%o36)              beta_incomplete(a, b, z)

 -- 関数: beta_incomplete_regularized (<a>, <b>, <z>)

          beta_incomplete_regularized(a, b, z) =
                                                beta_incomplete(a, b, z)
                                                ------------------------
                                                       beta(a, b)
     として定義された正則不完全ベータ関数 A&S 6.6.2。

     ‘beta_incomplete’同様、この定義は完全ではありません。
     ‘beta_incomplete_regularized’の完全な定義については、
     functions.wolfram.comを参照してください。

     ‘beta_incomplete_regularized’は、<a>または<b>が正の整数の時 整理さ
     れます。

     z=0かつrealpart(a)>0の時、 ‘beta_incomplete_regularized’は、具体的
     な値0を持ちます。 <z=1>かつrealpart(b)>0の時、
     ‘beta_incomplete_regularized’は、1に整理されます。

     Maximaは、実数と複素数の引数について、 浮動小数点と多倍長浮動小数点
     精度で‘beta_incomplete_regularized’を評価します。

     ‘beta_expand’が‘true’の時、 Maximaは、 nは整数として、引数a+nまたは
     a-nに関して ‘beta_incomplete_regularized’を展開します。

     Maximaは、変数<a>, <b>, <z>に関する ‘beta_incomplete_regularized’の
     導関数と、 変数<z>に関する積分を知っています。

     例:

     <a>または<b>が正の整数の時の整理:

          (%i1) beta_incomplete_regularized(2,b,z);
                                                 b
          (%o1)                       1 - (1 - z)  (b z + 1)

          (%i2) beta_incomplete_regularized(a,2,z);
                                                         a
          (%o2)                         (a (1 - z) + 1) z

          (%i3) beta_incomplete_regularized(3,2,z);
                                                         3
          (%o3)                         (3 (1 - z) + 1) z

     特定の値z=0, z=1について、Maximaは整理します:

          (%i4) assume(a>0,b>0)$
          (%i5) beta_incomplete_regularized(a,b,0);
          (%o5)                                 0
          (%i6) beta_incomplete_regularized(a,b,1);
          (%o6)                                 1

     実数と複素数引数に関する浮動小数点または多倍長浮動小数点精度の数値
     評価:

          (%i7) beta_incomplete_regularized(0.12,0.43,0.9);
          (%o7)                         .9114011367359802
          (%i8) fpprec:32$
          (%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
          (%o9)               9.1140113673598075519946998779975b-1
          (%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
          (%o10)             .2865367499935403 %i - 0.122995963334684
          (%i11) fpprec:20$
          (%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
          (%o12)      2.8653674999354036142b-1 %i - 1.2299596333468400163b-1

     ‘beta_expand’が‘true’の時の展開:

          (%i13) beta_incomplete_regularized(a+1,b,z);
                                                               b  a
                                                        (1 - z)  z
          (%o13) beta_incomplete_regularized(a, b, z) - ------------
                                                        a beta(a, b)
          (%i14) beta_incomplete_regularized(a-1,b,z);
          (%o14) beta_incomplete_regularized(a, b, z)
                                                               b  a - 1
                                                        (1 - z)  z
                                                   - ----------------------
                                                     beta(a, b) (b + a - 1)

     <z>に関する微分と積分:

          (%i15) diff(beta_incomplete_regularized(a,b,z),z);
                                        b - 1  a - 1
                                 (1 - z)      z
          (%o15)                 -------------------
                                     beta(a, b)
          (%i16) integrate(beta_incomplete_regularized(a,b,z),z);
          (%o16) beta_incomplete_regularized(a, b, z) z
                                                                     b  a
                                                              (1 - z)  z
                    a (beta_incomplete_regularized(a, b, z) - ------------)
                                                              a beta(a, b)
                  - -------------------------------------------------------
                                             b + a

 -- 関数: beta_incomplete_generalized (<a>, <b>, <z1>, <z2>)

     一般化不完全ベータ関数の基本的な定義は、以下の通りです。

                       z2
                     /
                     [          b - 1  a - 1
                     I   (1 - t)      t      dt
                     ]
                     /
                      z1

     Maximaは、 <a>と<b>が正の整数の時、 ‘beta_incomplete_regularized’を
     整理します。

     realpart(a)>0かつz1=0またはz2=0の時、 Maximaは、
     ‘beta_incomplete_generalized’を‘beta_incomplete’に整理します。
     realpart(b)>0かつz1=1または<z2=1>の時、 Maximaは、‘beta’と
     ‘beta_incomplete’を含む式に整理します。

     Maximaは、実数値と複素数値に関して、浮動小数点と多倍長浮動小数点精
     度で ‘beta_incomplete_regularized’を評価します。

     ‘beta_expand’が‘true’の時、 <n>を正の整数とすると、 Maximaは、a+nや
     a-nに関して‘beta_incomplete_generalized’ を整理します。

     Maximaは、 変数<a>, <b>, <z1>, <z2>に関する
     ‘beta_incomplete_generalized’の微分を知っており、 変数<z1>や<z2>に
     関する積分を知っています。

     例:

     Maximaは、<a>と<b>が正の整数の時、 ‘beta_incomplete_generalized’を
     整理します:

          (%i1) beta_incomplete_generalized(2,b,z1,z2);
                             b                      b
                     (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
          (%o1)      -------------------------------------------
                                      b (b + 1)
          (%i2) beta_incomplete_generalized(a,2,z1,z2);
                                        a                      a
                     (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
          (%o2)      -------------------------------------------
                                      a (a + 1)
          (%i3) beta_incomplete_generalized(3,2,z1,z2);
                        2      2                       2      2
                (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
          (%o3) -----------------------------------------------------------
                                            12

     特定の値z1=0, z2=0, z1=1またはz2=1に関する整理:

          (%i4) assume(a > 0, b > 0)$
          (%i5) beta_incomplete_generalized(a,b,z1,0);
          (%o5)                    - beta_incomplete(a, b, z1)

          (%i6) beta_incomplete_generalized(a,b,0,z2);
          (%o6)                    - beta_incomplete(a, b, z2)

          (%i7) beta_incomplete_generalized(a,b,z1,1);
          (%o7)              beta(a, b) - beta_incomplete(a, b, z1)

          (%i8) beta_incomplete_generalized(a,b,1,z2);
          (%o8)              beta_incomplete(a, b, z2) - beta(a, b)

     浮動小数点もしくは多倍長浮動小数点精度での実数値引数に関する数値評
     価:

          (%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
          (%o9)                        .09638178086368676

          (%i10) fpprec:32$
          (%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
          (%o10)               9.6381780863686935309170054689964b-2

     浮動小数点もしくは多倍長浮動小数点精度での複素数値引数に関する数値
     評価:

          (%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
          (%o11)           - .09625463003205376 %i - .003323847735353769
          (%i12) fpprec:20$
          (%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
          (%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3

     ‘beta_expand’が‘true’の時、 <n>を正の整数とする、 a+nまたはa-nに関
     する整理:

          (%i14) beta_expand:true$

          (%i15) beta_incomplete_generalized(a+1,b,z1,z2);

                         b   a           b   a
                 (1 - z1)  z1  - (1 - z2)  z2
          (%o15) -----------------------------
                             b + a
                                a beta_incomplete_generalized(a, b, z1, z2)
                              + -------------------------------------------
                                                   b + a
          (%i16) beta_incomplete_generalized(a-1,b,z1,z2);

                 beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
          (%o16) -------------------------------------------------------
                                          1 - a
                                              b   a - 1           b   a - 1
                                      (1 - z2)  z2      - (1 - z1)  z1
                                    - -------------------------------------
                                                      1 - a

     変数<z1>に関する微分と<z1>や<z2>に関する積分:

          (%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                         b - 1   a - 1
          (%o17)               - (1 - z1)      z1
          (%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
          (%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                            + beta_incomplete(a + 1, b, z1)
          (%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
          (%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                            - beta_incomplete(a + 1, b, z2)

 -- オプション変数: beta_expand
     デフォルト値: false

     ‘beta_expand’が‘true’の時、 a+nやa-nのような引数に対して
     ‘beta(a,b)’ と、関連した関数は展開されます。 ここでnは整数です。

 -- オプション変数: beta_args_sum_to_integer
     デフォルト値: false

     ‘beta_args_sum_to_integer’が‘true’の時、 引数<a>と<b>の和が整数の時
     、 Maximaは‘beta(a,b)’を整理します。

 -- 関数: psi [<n>](<x>)

     ‘log (gamma (<x>))’の次数‘<n>+1’の導関数。 例えば、 ‘psi[0](<x>)’は
     １階微分、 ‘psi[1](<x>)’は２階微分など。

     Maximaは、一般に、‘psi’の数値を計算する方法を知りませんが、 有理数
     の引数に関してはいくつかの厳密な値を計算することができます。 いくつ
     の変数は、‘psi’が可能なら厳密な値を返す有理数の引数の範囲を制御しま
     す。 ‘maxpsiposint’, ‘maxpsinegint’, ‘maxpsifracnum’,
     ‘maxpsifracdenom’を参照してください。 すなわち、<x>は、
     ‘maxpsinegint’と‘maxpsiposint’の間になければいけません。 もし<x>の
     小数部分の絶対値が有理数で、かつ分子が‘maxpsifracnum’より小さく、 分
     母が‘maxpsifracdenom’より小さければ、 ‘psi’は厳密な値を返します。

     ‘bffac’パッケージの中の 関数‘bfpsi’は数値を計算できます。

 -- オプション変数: maxpsiposint
     デフォルト値: 20

     ‘maxpsiposint’は、 ‘psi[n](x)’が厳密な値を計算しようとする 最も大き
     な正の値です。

 -- オプション変数: maxpsinegint
     デフォルト値: -10

     ‘maxpsinegint’ ‘psi[n](x)’が厳密な値を計算しようとする 最も大きな負
     の値です。 従って、もし <x>が‘maxnegint’よりも小さければ、 たとえ可
     能でも、 ‘psi[n](<x>)’は整理された答えを返しません。

 -- オプション変数: maxpsifracnum
     デフォルト値: 6

     <x>を１より小さい、形式‘p/q’の有理数とします。 もし‘p’が
     ‘maxpsifracnum’より大きいなら ‘psi[<n>](<x>)’は、 整理された値を返
     そうとしません。

 -- オプション変数: maxpsifracdenom
     デフォルト値: 6

     <x>を１より小さい、形式‘p/q’の有理数とします。 もし‘q’が
     ‘maxpsifracdenom’より大きいなら ‘psi[<n>](<x>)’は、 整理された値を
     返そうとしません。

 -- 関数: makefact (<expr>)
     <expr>の中の二項、ガンマ、ベータ関数のインスタンスを階乗に変換しま
     す。

     ‘makegamma’も参照してください。

 -- 関数: numfactor (<expr>)
     式<expr>を掛ける数値因子を返します。 式<expr>は単一項でなければいけ
     ません。

     ‘content’は、輪の中のすべての項の最大公約数を返します。

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8

