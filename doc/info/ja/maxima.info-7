This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: drawdf,  Next: dynamics,  Prev: draw,  Up: Top

49 drawdf
*********

* Menu:

* Introduction to drawdf::
* Functions and Variables for drawdf::


File: maxima.info,  Node: Introduction to drawdf,  Next: Functions and Variables for drawdf,  Prev: drawdf,  Up: drawdf

49.1 Introduction to drawdf
===========================

関数‘drawdf’は 一階常微分方程式(ODE)や 二連立自律一階ODE系の方向場を描画
します。

   これは追加パッケージなので、利用するには、最初に ‘load("drawdf")’でロ
ードしなければいけません。 Drawdfは‘draw’パッケージ上に構築されています
。これはGnuplot 4.2を要求します。

   単一のODEの方向場をプロットするには、ODEを以下の形式で書かなければい
けません:
            dy
            -- = F(x,y)
            dx

   そして関数<F>を‘drawdf’の引数に与えなければいけません。 もし独立変数
と従属変数が、上の式のように<x>と<y>でないなら、 drawdfコマンドへの引数
として与えられるリストの中に明示的に それら2つの変数を指名しなければいけ
ません。 (例を見てください。)

   2つの自励ODEの組の方向場をプロットするには、 それらを以下の形式で書か
なければいけません。
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   そして‘drawdf’の引数は2つの関数<G>と<F>を その順に持つリストでなけれ
ばいけません; すなわち、リストの最初の式は水平軸上に表された変数の時間導
関数であり、 二番目の式は垂直軸上に表された変数の時間導関数です。 それら
2つの変数は<x>と<y>である必要はありませんが、 もしそうでないなら、
drawdfに与えられる二番目の引数は 2つの変数を、最初のものが水平軸上のもの
を、その後垂直軸上のものを指定する別のリストでなければいけません。

   もしただ1つのODEが与えられるなら、 ‘drawdf’は、 暗に
‘x=t’,‘G(x,y)=1’と認め、 非自励方程式を2つの自励方程式系に変換します。


File: maxima.info,  Node: Functions and Variables for drawdf,  Prev: Introduction to drawdf,  Up: drawdf

49.2 Functions and Variables for drawdf
=======================================

49.2.1 Functions
----------------

 -- 関数: drawdf (<dydx>, ...options and objects...)
 -- 関数: drawdf (<dvdu>, ‘[’<u>,<v>‘]’, ...options and objects...)
 -- 関数: drawdf (<dvdu>, ‘[’<u>,<umin>,<umax>‘]’,
          ‘[’<v>,<vmin>,<vmax>‘]’, ...options and objects...)
 -- 関数: drawdf (‘[’<dxdt>,<dydt>‘]’, ...options and objects...)
 -- 関数: drawdf (‘[’<dudt>,<dvdt>‘]’, ‘[’<u>,<v>‘]’, ...options and
          objects...)
 -- 関数: drawdf (‘[’<dudt>,<dvdt>‘]’, ‘[’<u>,<umin>,<umax>‘]’,
          ‘[’<v>,<vmin>,<vmax>‘]’, ...options and objects...)

     関数‘drawdf’は、 オプションの解曲線や‘draw’パッケージを使う他のグラ
     フィックスと一緒に、 2D方向場を描きます。

     最初の引数は導関数を指定し、式か2つの式のリストでなければいけません
     。 <dydx>, <dxdt>, <dydt>は<x>と<y>に依存する式です。 <dvdu>,
     <dudt>, <dvdt>は<u>と<v>に依存する式です。

     もし独立変数と従属変数が<x>と<y>でないなら、 それらの名前を、導関数
     に続いてすぐに、 2つの名前のリスト‘[’<u>,<v>‘]’のとしてか、 形式
     ‘[’<u>,<umin>,<umax>‘]’と ‘[’<v>,<vmin>,<vmax>‘]’の2つのリストとし
     てのいずれか のように,指定しなければいけません。

     残りの引数はグラフィックオプションかグラフィックオブジェクト, 任意
     の深さで入れ子になったグラフィックオプションやオブジェクトを含むリ
     ストです。 ‘drawdf’がサポートするグラフィックオプションとオブジェク
     トの集合は ‘draw’パッケージの‘draw2d’と‘gr2d’がサポートするもの上位
     集合です。

     引数は順次解釈されます: グラフィックオプションは続くグラフィックオ
     ブジェクトすべてに影響します。 更に、グラフィックオブジェクトは指定
     された順にキャンバス上に描かれ、 先に描かれたグラフィックスを見えな
     くするかもしれません。 いくつかのグラフィックオプションはシーンのグ
     ローバルな外観に影響します。

     ‘drawdf’がサポートする追加のグラフィックオブジェクトは以下を含みま
     す: ‘solns_at’, ‘points_at’, ‘saddles_at’, ‘soln_at’, ‘point_at’,
     ‘saddle_at’.

     ‘drawdf’がサポートする追加のグラフィックオプションは以下を含みます:
     ‘field_degree’, ‘soln_arrows’, ‘field_arrows’, ‘field_grid’,
     ‘field_color’, ‘show_field’, ‘tstep’, ‘nsteps’, ‘duration’,
     ‘direction’, ‘field_tstep’, ‘field_nsteps’, ‘field_duration’.

     ‘draw’パッケージから受け継がれた、共通に使われるグラフィックオブジ
     ェクトは 以下を含みます: ‘explicit’, ‘implicit’, ‘parametric’,
     ‘polygon’, ‘points’, ‘vector’, ‘label’, ‘draw2d’と‘gr2d’がサポート
     する他のすべてのもの。

     ‘draw’パッケージから受け継がれた、共通に使われるグラフィックオプシ
     ョンは 以下を含みます:
     ‘points_joined’, ‘color’, ‘point_type’, ‘point_size’, ‘line_width’,
     ‘line_type’, ‘key’, ‘title’, ‘xlabel’, ‘ylabel’, ‘user_preamble’,
     ‘terminal’, ‘dimensions’, ‘file_name’, ‘draw2d’と‘gr2d’がサポートす
     る他のすべてのもの。

     ‘draw2d’も参照してください。

     wxMaximaやImaximaのユーザーは‘wxdrawdf’を代わりに使うかもしれません
     。 それは、 グラフィックスが‘wxdraw’を使うノートブック内で描かれる
     ことを除いて、 ‘drawdf’と同一です。

     この関数を利用するには、最初に‘load("drawdf")’を書いてください。

     例:

          (%i1) load("drawdf")$
          (%i2) drawdf(exp(-x)+y)$        /* default vars: x,y */
          (%i3) drawdf(exp(-t)+y, [t,y])$ /* default range: [-10,10] */
          (%i4) drawdf([y,-9*sin(x)-y/5], [x,1,5], [y,-2,2])$

     下位互換のために、‘drawdf’はplotdfがサポートしたパラメータのほとん
     どを 受け付けます。

          (%i5) drawdf(2*cos(t)-1+y, [t,y], [t,-5,10], [y,-4,9],
                       [trajectory_at,0,0])$

     ‘soln_at’と‘solns_at’は、 少し強化された4次のRunge Kutta数値積分器
     を使って、 指定された点を通る解曲線を描きます。

          (%i6) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     ‘field_degree=2’とすると、 それぞれのグリッド点での1次と2次の導関数
     に基づいて、 場が二次のスプラインで構成されます。
     ‘field_grid=[’<COLS>,<ROWS>‘]’は グリッドの列と行の数を指定します。

          (%i7) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       field_degree=2, field_grid=[20,15],
                       solns_at([0,0.1],[0,-0.1]),
                       color=blue, soln_at(0,0))$

     ‘soln_arrows=true’は 解曲線に矢印を加え、 (デフォルトでは)方向場か
     らそれらを削除します。 また、解曲線を強調するようにデフォルトの色を
     変えます。

          (%i8) drawdf(2*cos(t)-1+y, [t,-5,10], [y,-4,9],
                       soln_arrows=true,
                       solns_at([0,0.1],[0,-0.1],[0,0]))$

     ‘duration=40’は数値積分の時間間隔を指定します(デフォルトは10))。 も
     し解がプロット領域から遠くに移動し過ぎたり、 導関数が複素数や無限大
     になったりしても、積分は自動的に停止します。 ここでも、
     ‘field_degree=2’を指定して二次スプラインをプロットします。 以下の方
     程式は捕食者-被食者系をモデル化します。

          (%i9) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                       field_degree=2, duration=40,
                       soln_arrows=true, point_at(1/2,1/2),
                       solns_at([0.1,0.2], [0.2,0.1], [1,0.8], [0.8,1],
                                [0.1,0.1], [0.6,0.05], [0.05,0.4],
                                [1,0.01], [0.01,0.75]))$

     ‘field_degree='solns’とすると、 場は、4次のRunge Kuttaで計算された
     多くの小さな解曲線で構成され、 この場合、より良い結果をもたらします
     。

          (%i10) drawdf([x*(1-x-y), y*(3/4-y-x/2)], [x,0,1.1], [y,0,1],
                        field_degree='solns, duration=40,
                        soln_arrows=true, point_at(1/2,1/2),
                        solns_at([0.1,0.2], [0.2,0.1], [1,0.8],
                                 [0.8,1], [0.1,0.1], [0.6,0.05],
                                 [0.05,0.4], [1,0.01], [0.01,0.75]))$

     ‘saddles_at’は 自動的にそれぞれの鞍部で方程式を線形化しようとし、 セ
     パラトリクスを含む、それぞれの固有ベクトルに対応した数値解をプロッ
     トしようとします。 ‘tstep=0.05’は 数値積分器の最大時間ステップを指
     定します(デフォルトは0.1)。 xとyのステップを小さく保つために、小さ
     目の時間ステップが時々使われます。 以下の方程式は減衰振り子をモデル
     化します。

          (%i11) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        soln_arrows=true, point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        field_degree='solns,
                        saddles_at([%pi,0], [-%pi,0]))$

     ‘show_field=false’は場を完全に抑制します。

          (%i12) drawdf([y,-9*sin(x)-y/5], tstep=0.05,
                        show_field=false, soln_arrows=true,
                        point_size=0.5,
                        points_at([0,0], [2*%pi,0], [-2*%pi,0]),
                        saddles_at([3*%pi,0], [-3*%pi,0],
                                   [%pi,0], [-%pi,0]))$

     ‘drawdf’は、認識しないパラメータすべてを‘draw2d’や‘gr2d’に渡します
     。 なので、‘draw’パッケージのフルパワーを‘drawdf’と組み合わせられま
     す。

          (%i13) drawdf(x^2+y^2, [x,-2,2], [y,-2,2], field_color=gray,
                        key="soln 1", color=black, soln_at(0,0),
                        key="soln 2", color=red, soln_at(0,1),
                        key="isocline", color=green, line_width=2,
                        nticks=100, parametric(cos(t),sin(t),t,0,2*%pi))$

     ‘drawdf’はグラフィクオプションやオブジェクトの入れ子のリストを受け
     付けます。 なので、makelistやグラフィックスを生成する他の関数コール
     の便利な使用が可能です。

          (%i14) colors : ['red,'blue,'purple,'orange,'green]$
          (%i15) drawdf([x-x*y/2, (x*y - 3*y)/4],
                        [x,2.5,3.5], [y,1.5,2.5],
                        field_color = gray,
                        makelist([ key   = concat("soln",k),
                                   color = colors[k],
                                   soln_at(3, 2 + k/20) ],
                                 k,1,5))$


File: maxima.info,  Node: dynamics,  Next: ezunits,  Prev: drawdf,  Up: Top

50 dynamics
***********

* Menu:

* Introduction to dynamics::
* Functions and Variables for dynamics::


File: maxima.info,  Node: Introduction to dynamics,  Next: Functions and Variables for dynamics,  Prev: dynamics,  Up: dynamics

50.1 Introduction to dynamics
=============================

追加パッケージ‘dynamics’には、 離散力学系とフラクタルの様々なグラフィッ
クス表現を生成するためのいくつかの関数と、 微分方程式系を数値的に解くた
めの4次Runge-Kutta法の実装が含まれています。

   このパッケージの関数を使うには、 最初に‘load("dynamics")’でパッケージ
をロードしなければいけません。

   Maxima 5.12で導入された変更

   Maxima 5.12以来、現在まで、dynamicsパッケージは グラフを処理するのに
関数‘plot2d’を使います。 (‘julia’や‘mandelbrot’を除いて) グラフィックス
を生成するコマンドは‘plot2d’のいかなるオプションも受け付けます。 オプシ
ョンには、プロットスタイルや色を使ったり、 一方の、または両方の軸を対数
スケールで表したり、 様々なグラフィカルインターフェイス全体に渡って変更
を加えるものを含みます。 古いオプション<domain>, <pointsize>, <xcenter>,
<xradius>, <ycenter>, <yradius>, <xaxislabel>, <yaxislabel>は この新しい
バージョンでは受け付けられません。

   現在，すべてのプログラムは、 以前のバージョンのように<x>と<y>だけでな
く、 任意の変数名を受け付けます。 ２つの要求パラメータが2つのプログラム
で変えられました: ‘evolution2d’は、現在、 ２つの独立変数を陽に指定するリ
ストを要求し、 ‘orbits’の水平範囲はもはやステップサイズを要求しません; 範
囲は、変数名と最小値、最大値だけを指定しなければいけません; ステップ数は
、現在、オプション<nticks>で変えることができます。


File: maxima.info,  Node: Functions and Variables for dynamics,  Prev: Introduction to dynamics,  Up: dynamics

50.2 Functions and Variables for dynamics
=========================================

 -- 関数: chaosgame (‘[[’<x1>, <y1>‘]’...‘[’<xm>, <ym>‘]]’, ‘[’<x0>,
          <y0>‘]’, <b>, <n>, ..., options, ...);

     いわゆるカオスゲームを実装します: 初期点(<x0>, <y0>)がプロットされ
     、 <m>個の点‘[’<x1>, <y1>‘]’...‘[’<xm>, <ym>‘]’の１つがランダムに選
     択されます。 プロットされる次の点はプロットされた以前の点からランダ
     ムに選ばれた点までの線分上で、 ランダム点からその線分の長さに<b>を
     掛けた距離にあります。 手続きは <n>回繰り返されます。

 -- 関数: evolution (<F>, <y0>, <n>, ..., options, ...);

     ２次元グラフに、 点の水平座標が整数0, 1, 2, ..., <n>、 垂直座標が再
     帰関係
                  y(n+1) = F(y(n))
     で定義された数列の対応する値<y(n)>である <n+1>個の点を描きます。 こ
     こで、初期値<y(0)>は<y0>に等しいです。 <F>は１変数にだけ依存する式
     でなければいけません。 (例の中では、<y>に依存していますが、他のいか
     なる変数を使うことができます), <y0>は実数でなければいけなく、<n>は
     正の整数でなければいけません。

 -- 関数: evolution2d (‘[’<F>, <G>‘]’, ‘[’<u>, <v>‘]’, ‘[’<u0>, <y0>‘]’,
          <n>, ..., options, ...);

     再帰関係を伴う二次元離散力学系によって定義された点列の中の最初の
     <n+1>点を 二次元プロットで、 表示します。 初期値<u0>と<v0>を持つ
                  u(n+1) = F(u(n), v(n))    v(n+1) = G(u(n), v(n))

     <F>と<G>は2変数<u>と<v>のみに依存する式2つでなければいけません。 変
     数はリストの中に明示的に指名されなければいけません。

 -- 関数: ifs (‘[’<r1>, ..., <rm>‘]’, ‘[’<A1>, ..., <Am>‘]’, ‘[[’<x1>,
          <y1>‘]’, ..., ‘[’<xm>, <ym>‘]]’, ‘[’<x0>, <y0>‘]’, <n>, ...,
          options, ...);

     反復関数系法を実装します。 この方法は関数‘chaosgame’で記述した方法
     に似ていますが、 現在点からランダムに選ばれた点にセグメントを縮める
     代わりに、 そのセグメントの2成分はランダムに選ばれた点に対応する2行
     2列行列<Ai>を乗算されます。

     <m>個のアトラクティブな点の１つのランダムな選択を 重み
     <r1>,...,<rm>で定義された非均一な確率分布で作ることができます。 そ
     れらの重みは累積形で与えられます; 例えば、 もし確率0.2, 0.5, 0.3を
     持つ3点があるなら、 重み<r1>, <r2>と<r3>は2, 7, 10とできます。

 -- 関数: julia (<x>, <y>, ...<options>...)

     複素数(<x> + i <y>)に関するJulia集合の表現のグラフィックスファイル
     を生成します。 パラメータ<x>と<y>は実数でなければいけません。 ファ
     イルは、XPMグラフィックスフォーマットでカレントディレクトリかユーザ
     ーディレクトリに生成されます。 プログラムは走らせるのに数秒かかるか
     もしれません。終了後、生成したファイル名と共にメッセージが印字され
     ます。

     Julia集合に属さない点には、異なる色が割り当てられます。 繰り返し回
     数に従って、その点から始まり、半径2の収束円から動く数列を取ります。
     繰り返しの最大回数はオプション<levels>で設定されます; その回数の繰
     り返しの後、もし数列がまだ収束円内なら、 点はオプション<color>で定
     義された色で塗られます。

     Julia集合に属さない点に使われる色すべては、同じ<saturation>と
     <value>を持ちますが、 <hue>と(<hue> + <huerange>)の間に一様に分布す
     る、違った色相角を持ちます。

     <options>はオプションの列です。 受け付けられるオプションのリストは
     以下の節で与えられます。

 -- 関数: mandelbrot (<options>)

     Mandelbrot集合の表現のグラフィックスファイルを生成します。 ファイル
     は、XPMグラフィックスフォーマットでカレントディレクトリかユーザーデ
     ィレクトリに生成されます。 プログラムは走らせるのに数秒かかるかもし
     れません。終了後、生成したファイル名と共にメッセージが印字されます
     。

     Mandelbrot集合に属さない点には、異なる色が割り当てられます。 繰り返
     し回数に従って、その点から始まり、半径2の収束円から動く数列を取りま
     す。 繰り返しの最大回数はオプション<levels>で設定されます; その回数
     の繰り返しの後、もし数列がまだ収束円内なら、 点はオプション
     <color>で定義された色で塗られます。

     Mandelbrot集合に属さない点に使われる色すべては、同じ<saturation>と
     <value>を持ちますが、 <hue>と(<hue> + <huerange>)の間に一様に分布す
     る、違った色相角を持ちます。

     <options>はオプションの列です。 受け付けられるオプションのリストは
     以下の節で与えられます。

 -- 関数: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...options...);

     パラメータ<x>を持つ一次元離散力学系の族に関する軌道図を描画します;
     この種の図は一次元離散系の分岐の研究に使われます。

     関数<F(y)>は、 関数‘evolution’の場合と同様に値<y0>で始まる数列を定
     義しますが、 この場合、その関数は、<x0>から<xf>までの区間内の値を取
     り、 <xstep>の増分を持つパラメータ<x>にも依存します。 パラメータ
     <x>に使われるそれぞれの値は水平軸に示されます。 垂直軸は、 数列に
     <n1>回の時間発展させた後得られる数列<y(n1+1)>,..., <y(n1+n2+1)>の
     <n2>個の値を示します。

 -- 関数: rk (<ODE>, <var>, <initial>, <domain>)
 -- 関数: rk ([<ODE1>,...,<ODEm>], [<v1>,...,<vm>],
          [<init1>,...,<initm>], <domain>)

     4次のRunge-Kutta法を使って、最初の形式は一階常微分方程式一つを数値
     的に解き、二番目の形式はそれらm個の方程式系を解きます。 <var>は従属
     変数を表します。 <ODE>は独立変数と従属変数にだけ依存する式でなけれ
     ばいけません。 そして、独立変数に関する従属変数の導関数を定義します
     。

     独立変数は‘domain’で指定されます。 それは4つの要素のリストでなけれ
     ばいけません。 例えば:
          [t, 0, 10, 0.1]
     リストの最初の要素は独立変数を特定し、二番目と三番目の要素はその変
     数の初期値と最終値であり、 最後の要素はその区間内で使用されるべき増
     加分を設定します。

     もし<m>この方程式が解かれようとしているなら、 <m>個の従属変数<v1>,
     <v2>, ..., <vm>が存在しなければいけません。 それらの変数の初期値は
     <init1>, <init2>, ..., <initm>となります。 以前の場合と同様、
     ‘domain’で定義されたただ1つの独立変数が残っています。 <ODE1>, ...,
     <ODEm>は 独立変数に関する従属変数それぞれの導関数を定義する式です。
     それらの式に現れるかもしれない変数は独立変数と任意の従属変数だけで
     す。 従属変数と厳密に同じ順序でリストの中に導関数<ODE1>, ...,
     <ODEm>を与えることが重要です; 例えば、リストの三番目の要素は三番目
     の従属変数の導関数と解釈されます。

     プログラムは 方程式を独立変数の初期値から最終値まで一定の増加分を使
     って積分しようとします。 もしあるステップで従属変数の1つが大きすぎ
     る絶対値を取ったら、 積分はその点で中断されます。 結果は、なされた
     繰り返しの回数と同じ数の要素を持つリストです。 結果リストの中のそれ
     ぞれの要素は、それ自身<m>+1個の要素を持つもう一つのリストです: 独立
     変数の値にその点に対応する従属変数の値が続きます。

 -- 関数: staircase (<F>, <y0>, <n>, ...options...);

     再帰関係によって定義された数列に関する階段図形を描画します。
                  y(n+1) = F(y(n))

     入力パラメータの解釈と許される値は 関数‘evolution’に関するものと同
     じです。 階段図形は線<G(y)> ‘=’ <y>と共に関数<F(y)>のプロットから構
     成されます。 垂直区間は、 その線上の点(<y0>, <y0>)から 関数<F>と交
     差する点まで描画されます。 水平区間はその点から線上の点(<y1>,
     <y1>)に届くまで描画されます。 手続きは点(<yn>, <yn>)に届くまで<n>回
     繰り返されます。

   オプション

   それぞれのオプションは複数の項目のリストです。 最初の項目はオプション
名で、残りはオプションの引数からなります。

   関数‘evolution’, ‘evolution2d’, ‘staircase’, ‘orbits’, ‘ifs’,
‘chaosgame’が受け付けるオプションは は‘plot2d’に関するオプションと同じで
す。 ‘orbits’は、それらのオプションに加えて、 垂直方向に表される異なる点
の最大数を設定する特別なオプション<pixels>を受け付けます。

   以下のオプションを 関数‘julia’と‘mandelbrot’は受け付けます:

   • "size"は1つか2つの引数を取ります。 もし1つだけ引数が与えられたら、
     生成されるグラフィックスファイルの幅と高さはピクセル単位でその値に
     等しくなります。 もし引数2つが与えられたら、それらは幅と高さを定義
     します。 デフォルト値は、幅と高さ両方に関して400ピクセルです。 もし
     2つの値が等しくないなら、集合は歪んで現れます。

   • "levels"は繰り返しの最大数を定義します。 これは集合に属さない点に使
     われる色の数にも等しいです。 デフォルト値は12です; 値が大きくなると
     、処理時間が長くなります。

   • "huerange"は 集合に属さない点の色相に使われる色相角の範囲を定義しま
     す。 デフォルト値は360です。これは色が色相のすべての範囲に広がるこ
     とを意味します。 360より大きな値は、色相範囲の繰り返しを意味し、 負
     の値は、繰り返し回数が増えるにつれ、 色相角を減らすように使うことが
     できます。

   • "hue"は、 集合に属さない点に使われる最初の色の色相を度単位で設定し
     ます。 デフォルト値は300度です。これはマゼンダに対応します; 他の標
     準的な色の値は、赤には0、オレンジには45、黄には60、緑には120、シア
     ンには180、 青には240です。 オプション<huerange>も参照してください
     。

   • "saturation"は集合に属さない点に使われる飽和値を設定します。 0と1の
     間でなければいけません。 デフォルト値は、0.46です。

   • "value"は 集合に属さない点に使われる色の値を設定します。 0と1の間で
     なければいけません; 値が高くなると、色が明るくなります。 デフォルト
     値は、0.96です。

   • "color"には、 集合の点を表すのに使われる色の色相、飽和、値を定義す
     る 3つのパラメータが続きます。 デフォルト値は３つのパラメータすべて
     が0であり、黒に対応します。 許される値の範囲の説明に関して、 オプシ
     ョン<hue>, <saturation>, <value>を参照してください。

   • "center"には、2つの実パラメータが続きます。 これは、表示される領域
     の中心点の複素平面上の座標を与えます。 デフォルト値は両座標に関して
     0(原点)です。

   • "radius"は表示される正方形領域内の最大円の半径を設定します。 デフォ
     ルト値は2です。

   • "filename"は 結果のグラフが保存されるファイル名を与えます。 拡張子
     .xpmがその名前に加えられます。 もしファイルが既に存在しているなら、
     関数が生成したファイルで置き換えられます。 デフォルト値はJulia集合
     にはjulia、 Mandelbrot集合にはmandelbrotです。

   例

   以下の数列のグファフィックス表現と階段図形: 2, cos(2),
cos(cos(2)),...

     (%i1) load("dynamics")$

     (%i2) evolution(cos(y), 2, 11);

     (%i3) staircase(cos(y), 1, 11, [y, 0, 1.2]);

   もしシステムが遅いなら、 以下の例のように繰り返し回数を減らさなければ
いけないでしょう。 そして、もしモニタ上のドットが小さすぎるなら、
‘[’<style>,‘[’<points>,0.8‘]]’のように、 違ったスタイルを試したくなるか
もしれません。

   パラメータ<a>を持つ二次写像の軌跡図。
             x(n+1) = a + x(n)^2

     (%i4) orbits(x^2+a, 0, 50, 200, [a, -2, 0.25], [style, dots]);

   x ‘=’ -1.25近くのより低い分岐の回りの領域を拡大するには、以下を使って
ください:
     (%i5) orbits(x^2+a, 0, 100, 400, [a,-1,-1.53], [x,-1.6,-0.8],
                  [nticks, 400], [style,dots]);

   フラクタルに導かれる二次元系の発展:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$

     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$

     (%i8) evolution2d([f,g], [x,y], [-0.5,0], 50000, [style,dots]);

   そしてそのフラクタルの小さな領域の拡大:

     (%i9) evolution2d([f,g], [x,y], [-0.5,0], 300000, [x,-0.8,-0.6],
                       [y,-0.4,-0.2], [style, dots]);

   カオスゲームで得られるSierpinski三角形のプロット:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [style, dots]);

   反復函数系で得られるBarnsleyのシダ:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$

     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$

     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$

     (%i13) a4: matrix([0,0],[0,0.16])$

     (%i14) p1: [0,1.6]$

     (%i15) p2: [0,1.6]$

     (%i16) p3: [0,0.44]$

     (%i17) p4: [0,0]$

     (%i18) w: [85,92,99,100]$

     (%i19) ifs(w, [a1,a2,a3,a4], [p1,p2,p3,p4], [5,0], 50000, [style,dots]);

   そして数(-0.55 + i 0.6)に関するJulia集合は以下で得られます:
     julia (-0.55, 0.6, [iterations, 36], [x, -0.3, 0.2],
           [y, 0.3, 0.9], [grid, 400, 400], [color_bar_tics, 0, 6, 36])$

   x方向に-0.3から0.3まで、y方向に0.3から0.9までの領域を表示します。 青
から始まり黄で終わる36色が使われます。

   微分方程式

               dx/dt = t - x^2

   を、初期値x(t=0) = 1で、0から8までのtの区間で0.1の増分で 数値的に解く
には、以下を使ってください:

     (%i20) results: rk(t-x^2,x,1,[t,0,8,0.1])$

   結果はリスト‘results’に保存されます。

   系

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   を、t=0のxとyの初期値がそれぞれ-1.25, 0.75で、0から4までの区間で、 数
値的に解くには:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: ezunits,  Next: f90,  Prev: dynamics,  Up: Top

51 ezunits
**********

* Menu:

* Introduction to ezunits::
* Introduction to physical_constants::
* Functions and Variables for ezunits::


File: maxima.info,  Node: Introduction to ezunits,  Next: Introduction to physical_constants,  Prev: ezunits,  Up: ezunits

51.1 Introduction to ezunits
============================

‘ezunits’は次元量を扱うためのパッケージです。 次元解析のいくつかの関数を
含みます。 ‘ezunits’は 次元量と単位変換に関する算術演算を 実行できます。
組み込み単位は国際単位系(SI)とUS慣習単位系を含み、他の単位が宣言できます
。 ‘physical_constants’、物理定数のコレクション、も参照してください。

   ‘load("ezunits")’はこのパッケージをロードします。 ‘demo(ezunits)’はい
くつかの例を表示します。 便利な関数‘known_units’は組み込みとユーザー宣言
単位のリストを返し、 そして、 ‘display_known_unit_conversions’は 可読性
の高いフォーマットで既知の変換一式を表示します。

   式a ` bは、無次元量を示す‘a’と次元単位‘b’で 次元量を表します。 そのよ
うに宣言することなしに、シンボルを単位として使うことができます; 単位シン
ボルはいかなる特別なプロパティを持つ必要はありません。 式a ` bの量と単位
は、 それぞれ、‘qty’関数と‘units’関数で抽出することができます。

   シンボルは、指定された量か指定された単位か両方を持つ次元量であると宣
言することができます。

   式a ` b `` cは 単位‘b’から単位‘c’に変換します。 ‘ezunits’は SI基本単
位、SI組立単位、いくつかの非SI単位に関する組み込み変換を持っています。 ま
だ‘ezunits’が知らない単位変換は、宣言することができます。 ‘ezunits’が知
っている単位変換は 組み込み変換とユーザー定義の変換から構成される グロー
バル変数‘known_unit_conversions’で指定されます。 単位の積や商、冪に関す
る変換は知られている単位変換の組から演繹されます。

   Maximaは一般的に厳密でない数(浮動小数点数か多倍長浮動小数点数)より 厳
密な数(整数か有理数)を好むので、 次元量でそれらが現れた時、‘ezunits’は厳
密な数を保護します。 組み込み単位変換すべては厳密な数で表現されます; 宣
言された変換で厳密でない数は厳密なものに強制的に変換されます。

   単位の表示のために優先される系はありません; 入力単位は、変換を明示的
に示さない限り、他の単位には変換されません。 ‘ezunits’は 前置詞m-, k-,
M, G-(ミリ-, キロ-, メガ-, ギガ-)を SI基本単位やSI組立単位に適用された際
、 認識しますが、 そんな前置詞は明示的な変換で示された時だけ適用されます
。

   次元量に対する算術演算子は そんな演算子の慣例的な規則で実行されます。

   • (x ` a) * (y ` b) is equal to (x * y) ` (a * b).
   • (x ` a) + (y ` a) is equal to (x + y) ` a.
   • (x ` a)^y is equal to x^y ` a^y when ‘y’ is nondimensional.

   ‘ezunits’は 和の中の単位が同じ次元を持つことを要求しません; そんな項
は足さられず、エラーは報告されません。

   ‘ezunits’は初等的な次元解析関数を含みます。 すなわち、次元量の基本的
な次元と基本的な単位、無次元量と自然単位系の計算です。 次元解析の関数は
Barton Willisが書いた別のパッケージの類似の関数から焼き直されました。

   次元解析のために、 基本的な次元のリストと基本的な単位の連想リストは保
持されます; デフォルトでは、 基本的な次元は、長さ、質量、時刻、電荷、温
度、量であり、 基本的な単位は関連したSI単位で、 他の基本的な次元や単位を
宣言できます。


File: maxima.info,  Node: Introduction to physical_constants,  Next: Functions and Variables for ezunits,  Prev: Introduction to ezunits,  Up: ezunits

51.2 Introduction to physical_constants
=======================================

‘physical_constants’は物理定数のコレクションです。 CODATA 2006 推奨値か
らコピーしました。[1] ‘load("physical_constants")’はこのパッケージをロー
ドし、 まだロードされていないなら、‘ezunits’もロードします。

   物理定数は定数値のプロパティを持つシンボルとして表されます。 定数値は
、‘ezunits’が表すように次元量です。 関数‘constvalue’は定数値を取りに行き
ます; 定数値はシンボルの普通の値ではなく、 ‘constvalue’が値を取りに行く
まで、 物理定数のシンボルは評価される式の中でシンボルのままです。

   ‘physical_constants’はある補助情報、 すなわち、それぞれの定数の記述文
字列、 数値の誤差の見積もり、TeX表示のためのプロパティを含みます。 物理
定数を識別するために、それぞれのシンボルは ‘physical_constant’性質を持ち
ます; それ故に、‘propvars(physical_constant)’はそんなシンボルすべてのリ
ストを 表示します。

   ‘physical_constants’以下の定数を含みます。

‘%c’
     真空中の光速度
‘%mu_0’
     真空の透磁率
‘%e_0’
     真空の誘電率
‘%Z_0’
     真空の特性インピーダンス
‘%G’
     Newtonの重力定数
‘%h’
     Planck定数
‘%h_bar’
     Planck定数
‘%m_P’
     Planck質量
‘%T_P’
     Planck温度
‘%l_P’
     Planck長
‘%t_P’
     Planck時間
‘%%e’
     電気素量
‘%Phi_0’
     磁束量子
‘%G_0’
     コンダクタンス量子
‘%K_J’
     Josephson定数
‘%R_K’
     von Klitzing定数
‘%mu_B’
     Bohr磁子
‘%mu_N’
     核磁子
‘%alpha’
     微細構造定数
‘%R_inf’
     Rydberg定数
‘%a_0’
     Bohr半径
‘%E_h’
     Hartreeエネルギー
‘%ratio_h_me’
     循環量子
‘%m_e’
     電子質量
‘%N_A’
     Avogadro数
‘%m_u’
     原子質量定数
‘%F’
     Faraday定数
‘%R’
     気体定数
‘%%k’
     Boltzmann定数
‘%V_m’
     理想気体のモル体積
‘%n_0’
     Loschmidt定数
‘%ratio_S0_R’
     Sackur-Tetrode定数 (絶対エントロピー定数)
‘%sigma’
     Stefan-Boltzmann定数
‘%c_1’
     第一放射定数
‘%c_1L’
     スペクトル放射強度の第一放射定数
‘%c_2’
     第二放射定数
‘%b’
     Wien変位則定数
‘%b_prime’
     Wien変位則定数

   参考文献:

   [1] <http://physics.nist.gov/constants>

   例:

   ‘physical_constant’ プロパティを持つすべてのシンボルのリスト。

     (%i1) load ("physical_constants")$
     (%i2) propvars (physical_constant);
     (%o2) [%c, %mu_0, %e_0, %Z_0, %G, %h, %h_bar, %m_P, %T_P, %l_P,
     %t_P, %%e, %Phi_0, %G_0, %K_J, %R_K, %mu_B, %mu_N, %alpha,
     %R_inf, %a_0, %E_h, %ratio_h_me, %m_e, %N_A, %m_u, %F, %R, %%k,
     %V_m, %n_0, %ratio_S0_R, %sigma, %c_1, %c_1L, %c_2, %b, %b_prime]

   物理定数‘%c’のプロパティ。

     (%i1) load ("physical_constants")$
     (%i2) constantp (%c);
     (%o2)                         true
     (%i3) get (%c, description);
     (%o3)               speed of light in vacuum
     (%i4) constvalue (%c);
                                           m
     (%o4)                     299792458 ` -
                                           s
     (%i5) get (%c, RSU);
     (%o5)                           0
     (%i6) tex (%c);
     $$c$$
     (%o6)                         false

   1ポンドの質量に等価なエネルギー。 シンボル ‘%c’は、 ‘constvalue’が値
を取りにいくまでシンボルのままです。

     (%i1) load ("physical_constants")$
     (%i2) m * %c^2;
                                     2
     (%o2)                         %c  m
     (%i3) %, m = 1 ` lbm;
                                   2
     (%o3)                       %c  ` lbm
     (%i4) constvalue (%);
                                                 2
                                            lbm m
     (%o4)              89875517873681764 ` ------
                                               2
                                              s
     (%i5) E : % `` J;
     Computing conversions to base units; may take a moment.
                          366838848464007200
     (%o5)                ------------------ ` J
                                  9
     (%i6) E `` GJ;
                           458548560580009
     (%o6)                 --------------- ` GJ
                              11250000
     (%i7) float (%);
     (%o7)              4.0759872051556356e+7 ` GJ


File: maxima.info,  Node: Functions and Variables for ezunits,  Prev: Introduction to physical_constants,  Up: ezunits

51.3 Functions and Variables for ezunits
========================================

 -- 演算子: `

     次元量演算子。 式 a ` bは次元量を表します。 ‘a’は無次元量を表し、
     ‘b’は次元単位を表します。 シンボルは、宣言せずに単位として使うこと
     ができます; 単位シンボルは特別なプロパティを持つ必要はありません。
     式 a ` bの量と単位はそれぞれ、 ‘qty’と ‘units’関数で抽出することが
     できます。

     次元量の算術演算子は演算子の慣例規則に従って実行されます。

        • (x ` a) * (y ` b)は (x * y) ` (a * b)に等しい。
        • (x ` a) + (y ` a)は (x + y) ` aに等しい。
        • (x ` a)^yは ‘y’が無次元の時 x^y ` a^yに等しい。

     ‘ezunits’は和の中の単位が同じ次元であることを要求しません; そんな項
     は一緒には足されませんし、エラーは報告されません。

     ‘load("ezunits")’はこの演算子をイネーブルにします。

     例:

     SI (国際単位系) 単位。

          (%i1) load ("ezunits")$
          (%i2) foo : 10 ` m;
          (%o2)                        10 ` m
          (%i3) qty (foo);
          (%o3)                          10
          (%i4) units (foo);
          (%o4)                           m
          (%i5) dimensions (foo);
          (%o5)                        length

     "慣習"単位。

          (%i1) load ("ezunits")$
          (%i2) bar : x ` acre;
          (%o2)                       x ` acre
          (%i3) dimensions (bar);
                                             2
          (%o3)                        length
          (%i4) fundamental_units (bar);
                                          2
          (%o4)                          m

     アドホック単位。

          (%i1) load ("ezunits")$
          (%i2) baz : 3 ` sheep + 8 ` goat + 1 ` horse;
          (%o2)           8 ` goat + 3 ` sheep + 1 ` horse
          (%i3) subst ([sheep = 3*goat, horse = 10*goat], baz);
          (%o3)                       27 ` goat
          (%i4) baz2 : 1000`gallon/fortnight;
                                          gallon
          (%o4)                   1000 ` ---------
                                         fortnight
          (%i5) subst (fortnight = 14*day, baz2);
                                    500   gallon
          (%o5)                     --- ` ------
                                     7     day

     次元量の算術演算子

          (%i1) load ("ezunits")$
          (%i2) 100 ` kg + 200 ` kg;
          (%o2)                       300 ` kg
          (%i3) 100 ` m^3 - 100 ` m^3;
                                            3
          (%o3)                        0 ` m
          (%i4) (10 ` kg) * (17 ` m/s^2);
                                           kg m
          (%o4)                      170 ` ----
                                             2
                                            s
          (%i5) (x ` m) / (y ` s);
                                        x   m
          (%o5)                         - ` -
                                        y   s
          (%i6) (a ` m)^2;
                                        2    2
          (%o6)                        a  ` m

 -- 演算子: ` `

     単位変換演算子。 式 a ` b `` cは単位 ‘b’を単位 ‘c’に変換します。
     ‘ezunits’にはSI基本単位、SI組立単位、いくつかの非SI単位のための 組
     み込み変換があります。 ‘ezunits’がまだ知らない単位変換は宣言するこ
     とができます。 ‘ezunits’が知っている単位変換はグローバル変数
     ‘known_unit_conversions’に 明記されます。それは、組み込みとユーザー
     定義の変換を含みます。 単位の積、商、べきの変換は既知の単位変換一式
     から演繹されます。

     単位の表示のためにより好まれる系はありません; 変換が明示的に示され
     ない限り、 入力単位は他の単位に変換されません。 ‘ezunits’は、 変換
     が明示的に示されない限り、 前置詞(milli-, centi-, deci-, etc)で単位
     を整理しようとしません。

     ‘load("ezunits")’はこの演算子を有効にします。

     例:

     既知の単位変換一式。

          (%i1) load ("ezunits")$
          (%i2) display2d : false$
          (%i3) known_unit_conversions;
          (%o3) {acre = 4840*yard^2,Btu = 1055*J,cfm = feet^3/minute,
                 cm = m/100,day = 86400*s,feet = 381*m/1250,ft = feet,
                 g = kg/1000,gallon = 757*l/200,GHz = 1000000000*Hz,
                 GOhm = 1000000000*Ohm,GPa = 1000000000*Pa,
                 GWb = 1000000000*Wb,Gg = 1000000*kg,Gm = 1000000000*m,
                 Gmol = 1000000*mol,Gs = 1000000000*s,ha = hectare,
                 hectare = 100*m^2,hour = 3600*s,Hz = 1/s,inch = feet/12,
                 km = 1000*m,kmol = 1000*mol,ks = 1000*s,l = liter,
                 lbf = pound_force,lbm = pound_mass,liter = m^3/1000,
                 metric_ton = Mg,mg = kg/1000000,MHz = 1000000*Hz,
                 microgram = kg/1000000000,micrometer = m/1000000,
                 micron = micrometer,microsecond = s/1000000,
                 mile = 5280*feet,minute = 60*s,mm = m/1000,
                 mmol = mol/1000,month = 2629800*s,MOhm = 1000000*Ohm,
                 MPa = 1000000*Pa,ms = s/1000,MWb = 1000000*Wb,
                 Mg = 1000*kg,Mm = 1000000*m,Mmol = 1000000000*mol,
                 Ms = 1000000*s,ns = s/1000000000,ounce = pound_mass/16,
                 oz = ounce,Ohm = s*J/C^2,
                 pound_force = 32*ft*pound_mass/s^2,
                 pound_mass = 200*kg/441,psi = pound_force/inch^2,
                 Pa = N/m^2,week = 604800*s,Wb = J/A,yard = 3*feet,
                 year = 31557600*s,C = s*A,F = C^2/J,GA = 1000000000*A,
                 GC = 1000000000*C,GF = 1000000000*F,GH = 1000000000*H,
                 GJ = 1000000000*J,GK = 1000000000*K,GN = 1000000000*N,
                 GS = 1000000000*S,GT = 1000000000*T,GV = 1000000000*V,
                 GW = 1000000000*W,H = J/A^2,J = m*N,kA = 1000*A,
                 kC = 1000*C,kF = 1000*F,kH = 1000*H,kHz = 1000*Hz,
                 kJ = 1000*J,kK = 1000*K,kN = 1000*N,kOhm = 1000*Ohm,
                 kPa = 1000*Pa,kS = 1000*S,kT = 1000*T,kV = 1000*V,
                 kW = 1000*W,kWb = 1000*Wb,mA = A/1000,mC = C/1000,
                 mF = F/1000,mH = H/1000,mHz = Hz/1000,mJ = J/1000,
                 mK = K/1000,mN = N/1000,mOhm = Ohm/1000,mPa = Pa/1000,
                 mS = S/1000,mT = T/1000,mV = V/1000,mW = W/1000,
                 mWb = Wb/1000,MA = 1000000*A,MC = 1000000*C,
                 MF = 1000000*F,MH = 1000000*H,MJ = 1000000*J,
                 MK = 1000000*K,MN = 1000000*N,MS = 1000000*S,
                 MT = 1000000*T,MV = 1000000*V,MW = 1000000*W,
                 N = kg*m/s^2,R = 5*K/9,S = 1/Ohm,T = J/(m^2*A),V = J/C,
                 W = J/s}

     基本単位変換。

          (%i1) load ("ezunits")$
          (%i2) 1 ` ft `` m;
          Computing conversions to base units; may take a moment.
                                      381
          (%o2)                       ---- ` m
                                      1250
          (%i3) %, numer;
          (%o3)                      0.3048 ` m
          (%i4) 1 ` kg `` lbm;
                                      441
          (%o4)                       --- ` lbm
                                      200
          (%i5) %, numer;
          (%o5)                      2.205 ` lbm
          (%i6) 1 ` W `` Btu/hour;
                                     720   Btu
          (%o6)                      --- ` ----
                                     211   hour
          (%i7) %, numer;
                                                  Btu
          (%o7)               3.412322274881517 ` ----
                                                  hour
          (%i8) 100 ` degC `` degF;
          (%o8)                      212 ` degF
          (%i9) -40 ` degF `` degC;
          (%o9)                     (- 40) ` degC
          (%i10) 1 ` acre*ft `` m^3;
                                  60228605349    3
          (%o10)                  ----------- ` m
                                   48828125
          (%i11) %, numer;
                                                    3
          (%o11)                1233.48183754752 ` m

     フィートとメートルを相互に強制変換。

          (%i1) load ("ezunits")$
          (%i2) 100 ` m + 100 ` ft;
          (%o2)                  100 ` m + 100 ` ft
          (%i3) (100 ` m + 100 ` ft) `` ft;
          Computing conversions to base units; may take a moment.
                                     163100
          (%o3)                      ------ ` ft
                                      381
          (%i4) %, numer;
          (%o4)                428.0839895013123 ` ft
          (%i5) (100 ` m + 100 ` ft) `` m;
                                      3262
          (%o5)                       ---- ` m
                                       25
          (%i6) %, numer;
          (%o6)                      130.48 ` m

     基本次元と基本単位を見つけるための次元解析

          (%i1) load ("ezunits")$
          (%i2) foo : 1 ` acre * ft;
          (%o2)                      1 ` acre ft
          (%i3) dimensions (foo);
                                             3
          (%o3)                        length
          (%i4) fundamental_units (foo);
                                          3
          (%o4)                          m
          (%i5) foo `` m^3;
          Computing conversions to base units; may take a moment.
                                  60228605349    3
          (%o5)                   ----------- ` m
                                   48828125
          (%i6) %, numer;
                                                    3
          (%o6)                 1233.48183754752 ` m

     宣言された単位変換。

          (%i1) load ("ezunits")$
          (%i2) declare_unit_conversion (MMBtu = 10^6*Btu, kW = 1000*W);
          (%o2)                         done
          (%i3) declare_unit_conversion (kWh = kW*hour, MWh = 1000*kWh,
                                         bell = 1800*s);
          (%o3)                         done
          (%i4) 1 ` kW*s `` MWh;
          Computing conversions to base units; may take a moment.
                                       1
          (%o4)                     ------- ` MWh
                                    3600000
          (%i5) 1 ` kW/m^2 `` MMBtu/bell/ft^2;
                                 1306449      MMBtu
          (%o5)                 ---------- ` --------
                                8242187500          2
                                             bell ft

 -- 関数: constvalue (<x>)
 -- 関数: declare_constvalue (<a>, <x>)
 -- 関数: remove_constvalue (<a>)

     シンボルの宣言された定数や、 シンボルに宣言された定数を代入した式の
     値をを返します。

     定数は‘declare_constvalue’で宣言されます。 ‘constvalue’が認識する定
     数は ‘numerval’で宣言された値や‘constantp’が認識する値と区別される
     ことに 注意してください。

     ‘physical_units’パッケージはたくさんの物理定数の定数値を宣言します
     。

     ‘remove_constvalue’は ‘declare_constvalue’の効果を戻します。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

     物理定数の定数値。

          (%i1) load ("physical_constants")$
          (%i2) constvalue (%G);
                                               3
                                              m
          (%o2)                    6.67428 ` -----
                                                 2
                                             kg s
          (%i3) get ('%G, 'description);
          (%o3)           Newtonian constant of gravitation

     新しい定数の宣言。

          (%i1) load ("ezunits")$
          (%i2) declare_constvalue (FOO, 100 ` lbm / acre);
                                           lbm
          (%o2)                      100 ` ----
                                           acre
          (%i3) FOO * (50 ` acre);
          (%o3)                     50 FOO ` acre
          (%i4) constvalue (%);
          (%o4)                      5000 ` lbm

 -- 関数: units (<x>)
 -- 関数: declare_units (<a>, <u>)

     次元量<x>の単位を返します。 もし<x>が無次元なら、1を返します。

     <x>は、文字通り次元式 a ` bかもしれませんし、 ‘declare_units’を介し
     て宣言された単位を持つシンボルかもしれませんし、 それらの一方または
     両方を含む式かもしれません。

     ‘declare_units’は、 ‘units(<a>)’は式<u>を返さなければいけないことを
     宣言します。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

     文字通り次元式へ適用された‘units’。

          (%i1) load ("ezunits")$
          (%i2) foo : 100 ` kg;
          (%o2)                       100 ` kg
          (%i3) bar : x ` m/s;
                                            m
          (%o3)                         x ` -
                                            s
          (%i4) units (foo);
          (%o4)                          kg
          (%i5) units (bar);
                                          m
          (%o5)                           -
                                          s
          (%i6) units (foo * bar);
                                        kg m
          (%o6)                         ----
                                         s
          (%i7) units (foo / bar);
                                        kg s
          (%o7)                         ----
                                         m
          (%i8) units (foo^2);
                                           2
          (%o8)                          kg

     宣言された単位を持つシンボルに適用された‘units’。

          (%i1) load ("ezunits")$
          (%i2) units (aa);
          (%o2)                           1
          (%i3) declare_units (aa, J);
          (%o3)                           J
          (%i4) units (aa);
          (%o4)                           J
          (%i5) units (aa^2);
                                          2
          (%o5)                          J
          (%i6) foo : 100 ` kg;
          (%o6)                       100 ` kg
          (%i7) units (aa * foo);
          (%o7)                         kg J

 -- 関数: qty (<x>)
 -- 関数: declare_qty (<a>, <x>)

     ‘qty’は次元量<x>の無次元パーツを返します。 もし <x>が無次元なら、
     <x>を返します。 <x>は文字通り次元式 a ` bかも知れませんし、 宣言さ
     れた量のシンボルかもしれませんし、 それらの一方または両方を含む式か
     もしれません。

     ‘declare_qty’は、 ‘qty(<a>)’は無次元量<x>を返さなければいけないこと
     を宣言します。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

     文字通り次元式に適用された‘qty’。

          (%i1) load ("ezunits")$
          (%i2) foo : 100 ` kg;
          (%o2)                       100 ` kg
          (%i3) qty (foo);
          (%o3)                          100
          (%i4) bar : v ` m/s;
                                            m
          (%o4)                         v ` -
                                            s
          (%i5) foo * bar;
                                            kg m
          (%o5)                     100 v ` ----
                                             s
          (%i6) qty (foo * bar);
          (%o6)                         100 v

     宣言された量のシンボルへ適用された‘qty’。

          (%i1) load ("ezunits")$
          (%i2) declare_qty (aa, xx);
          (%o2)                          xx
          (%i3) qty (aa);
          (%o3)                          xx
          (%i4) qty (aa^2);
                                           2
          (%o4)                          xx
          (%i5) foo : 100 ` kg;
          (%o5)                       100 ` kg
          (%i6) qty (aa * foo);
          (%o6)                        100 xx

 -- 関数: unitp (<x>)

     もし<x>が文字通り次元式か、 次元的と宣言されたシンボルか、 主演算子
     が次元的宣言された式なら、 ‘true’を返します。 それ以外なら、
     ‘unitp’は ‘false’を返します。

     ‘load("ezunits")’はこの関数を返します。

     例:

     文字通り次元式へ適用された‘unitp’。

          (%i1) load ("ezunits")$
          (%i2) unitp (100 ` kg);
          (%o2)                         true

     次元的と宣言されたシンボルへ適用された‘unitp’。

          (%i1) load ("ezunits")$
          (%i2) unitp (foo);
          (%o2)                         false
          (%i3) declare (foo, dimensional);
          (%o3)                         done
          (%i4) unitp (foo);
          (%o4)                         true

     主演算子が次元的と宣言された式に適用された‘unitp’。

          (%i1) load ("ezunits")$
          (%i2) unitp (bar (x, y, z));
          (%o2)                         false
          (%i3) declare (bar, dimensional);
          (%o3)                         done
          (%i4) unitp (bar (x, y, z));
          (%o4)                         true

 -- 関数: declare_unit_conversion (<u> = <v>, ...)

     式 <u> = <v>, ... を 単位変換演算子 ``が知っている単位変換のリスト
     に追加します。 <u>と <v>はともにその中のいかなる変数も単位である乗
     法の項か、 文字通り次元式です。

     現在、 それぞれの式の左辺が(乗法式でなく)ただの単位か、 1に等しい量
     とただの単位である単位の文字通り次元式であるような 変換を表現する必
     要があります。 この限定は将来のバージョンで緩和されるかもしれません
     。

     ‘known_unit_conversions’は既知の単位変換のリストです。

     ‘load("ezunits")’はこの関数をロードします。

     例:

     乗法項の等式で表現された単位変換。

          (%i1) load ("ezunits")$
          (%i2) declare_unit_conversion (nautical_mile = 1852 * m,
                                         fortnight = 14 * day);
          (%o2)                         done
          (%i3) 100 ` nautical_mile / fortnight `` m/s;
          Computing conversions to base units; may take a moment.
                                      463    m
          (%o3)                       ---- ` -
                                      3024   s

     文字通り次元式の等式で表現された単位変換。

          (%i1) load ("ezunits")$
          (%i2) declare_unit_conversion (1 ` fluid_ounce = 2 ` tablespoon);
          (%o2)                         done
          (%i3) declare_unit_conversion (1 ` tablespoon = 3 ` teaspoon);
          (%o3)                         done
          (%i4) 15 ` fluid_ounce `` teaspoon;
          Computing conversions to base units; may take a moment.
          (%o4)                     90 ` teaspoon

 -- 関数: declare_dimensions (<a_1>, <d_1>, ..., <a_n>, <d_n>)
 -- 関数: remove_dimensions (<a_1>, ..., <a_n>)

     ‘declare_dimensions’は <a_1>, ..., <a_n>を それぞれ、次元<d_1>,
     ..., <d_n>を持つと 宣言します。

     <a_k>それぞれはシンボルかシンボルのリストです。 もしリストなら、
     <a_k>内のすべてのシンボルは 次元 <d_k>を持つように宣言されます。

     ‘remove_dimensions’は ‘declare_dimensions’の効果を戻します。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

          (%i1) load ("ezunits") $
          (%i2) declare_dimensions ([x, y, z], length, [t, u], time);
          (%o2)                         done
          (%i3) dimensions (y^2/u);
                                             2
                                       length
          (%o3)                        -------
                                        time
          (%i4) fundamental_units (y^2/u);
          0 errors, 0 warnings
                                          2
                                         m
          (%o4)                          --
                                         s

 -- 関数: declare_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- 関数: remove_fundamental_dimensions (<d_1>, <d_2>, <d_3>, ...)
 -- グローバル変数: fundamental_dimensions

     ‘declare_fundamental_dimensions’は基本次元を宣言します。 シンボル
     <d_1>, <d_2>, <d_3>, ... は、 もしそれらがまだリストの中にないなら
     、基本次元のリストに追加されます。

     ‘remove_fundamental_dimensions’は ‘declare_fundamental_dimensions’の
     効果を戻します。

     ‘fundamental_dimensions’は基本次元のリストです。 デフォルトでは、リ
     ストはいくつかの物理次元から成ります。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

          (%i1) load ("ezunits") $
          (%i2) fundamental_dimensions;
          (%o2) [length, mass, time, current, temperature, quantity]
          (%i3) declare_fundamental_dimensions (money, cattle, happiness);
          (%o3)                         done
          (%i4) fundamental_dimensions;
          (%o4) [length, mass, time, current, temperature, quantity,
                                                  money, cattle, happiness]
          (%i5) remove_fundamental_dimensions (cattle, happiness);
          (%o5)                         done
          (%i6) fundamental_dimensions;
          (%o6) [length, mass, time, current, temperature, quantity, money]

 -- 関数: declare_fundamental_units (<u_1>, <d_1>, ..., <u_n>, <d_n>)
 -- 関数: remove_fundamental_units (<u_1>, ..., <u_n>)

     ‘declare_fundamental_units’は <u_1>, ..., <u_n>を それぞれ、次元
     <d_1>, ..., <d_n>を持つように宣言します。 引数すべてはシンボルでな
     ければいけません。

     ‘declare_fundamental_units’をコールした後、 ‘dimensions(<u_k>)’は 引
     数<u_1>, ..., <u_n>それぞれに対して <d_k>を返し、
     ‘fundamental_units(<d_k>)’は 引数<d_1>, ..., <d_n>それぞれに対して
     <u_k>を返します。

     ‘remove_fundamental_units’は ‘declare_fundamental_units’の効果を戻
     します。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

          (%i1) load ("ezunits") $
          (%i2) declare_fundamental_dimensions (money, cattle, happiness);
          (%o2)                         done
          (%i3) declare_fundamental_units (dollar, money, goat, cattle, smile, happiness);
          (%o3)                 [dollar, goat, smile]
          (%i4) dimensions (100 ` dollar/goat/km^2);
                                       money
          (%o4)                    --------------
                                                2
                                   cattle length
          (%i5) dimensions (x ` smile/kg);
                                      happiness
          (%o5)                       ---------
                                        mass
          (%i6) fundamental_units (money*cattle/happiness);
          0 errors, 0 warnings
                                     dollar goat
          (%o6)                      -----------
                                        smile

 -- 関数: dimensions (<x>)
 -- 関数: dimensions_as_list (<x>)

     ‘dimensions’は 基礎次元の積と冪で構成された式として 次元量<x>の次元
     を返します。

     ‘dimensions_as_list’は それぞれの要素が<x>の次元に関して対応する基
     礎次元の冪を示す整数であるようなリストとして次元量<x>の次元を返しま
     す。

     ‘load("ezunits")’はこれらの関数をロードします。

     例:

          (%i1) load ("ezunits")$
          (%i2) dimensions (1000 ` kg*m^2/s^3);
                                          2
                                    length  mass
          (%o2)                     ------------
                                           3
                                       time
          (%i3) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o3)                        -------
                                        hour
          (%i4) dimensions (foo);
                                             3
                                       length
          (%o4)                        -------
                                        time

          (%i1) load ("ezunits")$
          (%i2) fundamental_dimensions;
          (%o2)  [length, mass, time, charge, temperature, quantity]
          (%i3) dimensions_as_list (1000 ` kg*m^2/s^3);
          (%o3)                 [2, 1, - 3, 0, 0, 0]
          (%i4) declare_units (foo, acre*ft/hour);
                                       acre ft
          (%o4)                        -------
                                        hour
          (%i5) dimensions_as_list (foo);
          (%o5)                 [3, 0, - 1, 0, 0, 0]

 -- 関数: fundamental_units (<x>)
 -- 関数: fundamental_units ()

     ‘fundamental_units(<x>)’は ‘dimensions(<x>)’が決定するように <x>の
     基本次元に関連付けられた 単位を返します。

     <x>は文字通り次元式a ` bか、 ‘declare_units’を介して宣言された単位
     を持つシンボルか それらのいずれかもしくは両方を含む式かもしれません
     。

     ‘fundamental_units()’は ‘declare_fundamental_units’が宣言するように
     、 既知の基本単位すべてのリストを返します。

     ‘load("ezunits")’はこの関数をロードします。

     例:

          (%i1) load ("ezunits")$
          (%i2) fundamental_units ();
          (%o2)                 [m, kg, s, A, K, mol]
          (%i3) fundamental_units (100 ` mile/hour);
                                          m
          (%o3)                           -
                                          s
          (%i4) declare_units (aa, g/foot^2);
                                          g
          (%o4)                         -----
                                            2
                                        foot
          (%i5) fundamental_units (aa);
                                         kg
          (%o5)                          --
                                          2
                                         m

 -- 関数: dimensionless (<L>)

     次元量のリスト<L>から形成できる 無次元量の基底を返します。

     ‘load("ezunits")’はこの関数をロードします。

     例:

          (%i1) load ("ezunits") $
          (%i2) dimensionless ([x ` m, y ` m/s, z ` s]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                         y z
          (%o2)                         [---]
                                          x

     Dimensionless quantities derived from fundamental physical
     quantities.  Note that the first element on the list is
     proportional to the fine-structure constant.

          (%i1) load ("ezunits") $
          (%i2) load ("physical_constants") $
          (%i3) dimensionless([%h_bar, %m_e, %m_P, %%e, %c, %e_0]);
          0 errors, 0 warnings
          0 errors, 0 warnings
                                        2
                                     %%e        %m_e
          (%o3)                [--------------, ----]
                                %c %e_0 %h_bar  %m_P

 -- 関数: natural_unit (<expr>, [<v_1>, ..., <v_n>])

     ‘dimension(<expr>) = dimension(<v_1>^<e_1> ... <v_n>^<e_n>)’である
     ような 指数<e_1>, ..., <e_n>を見つけます。

     ‘load("ezunits")’はこの関数をロードします。

     例:


File: maxima.info,  Node: f90,  Next: finance,  Prev: ezunits,  Up: Top

52 f90
******

* Menu:

* Functions and Variables for f90::


File: maxima.info,  Node: Functions and Variables for f90,  Prev: f90,  Up: f90

52.1 Functions and Variables for f90
====================================

 -- 関数: f90 (<expr_1>, ..., <expr_n>)

     １つ以上の式<expr_1>, ..., <expr_n>を Fortran 90プログラムとして印
     字します。 出力は標準出力に印字されます。

     ‘f90’は Fortran 90のいわゆる「自由形式」入力フォーマットで出力を印
     字します: 列位置に特別な注意はありません。 長い行は、 アンパサンド
     ‘&’継続文字で固定幅に分割されます。

     ‘load("f90")’はこの関数をロードします。

     例:

          (%i1) load ("f90")$
          (%i2) foo : expand ((xxx + yyy + 7)^4);
                   4            3         3        2    2             2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy  + 84 xxx yyy
                    2        3             2
           + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy + 588 xxx yyy + 1372 yyy
                4         3          2
           + xxx  + 28 xxx  + 294 xxx  + 1372 xxx + 2401
          (%i3) f90 ('foo = foo);
          foo = yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2&
          +294*yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**&
          4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                         false

     複数式。 ‘with_stdout’関数を介して標準出力をファイルにとらえます。

          (%i1) load ("f90")$
          (%i2) foo : sin (3*x + 1) - cos (7*x - 2);
          (%o2)              sin(3 x + 1) - cos(7 x - 2)
          (%i3) with_stdout ("foo.f90",
                             f90 (x = 0.25, y = 0.625, 'foo = foo, 'stop, 'end));
          (%o3)                         false
          (%i4) printfile ("foo.f90");
          x = 0.25
          y = 0.625
          foo = sin(3*x+1)-cos(7*x-2)
          stop
          end
          (%o4)                        foo.f90


File: maxima.info,  Node: finance,  Next: fractals,  Prev: f90,  Up: Top

53 finance
**********

* Menu:

* Introduction to finance::
* Functions and Variables for finance::


File: maxima.info,  Node: Introduction to finance,  Next: Functions and Variables for finance,  Prev: finance,  Up: finance

53.1 Introduction to finance
============================

これは金融パッケージ(第0.1版)です。

   すべての関数において、 <rate>は複利率であり、 <num>は期間で正でなくて
はいけません。 また、<flow>はキャッシュフローを示すので、 産出はフローが
負になり、投入は正になります。

   このパッケージで定義された関数を使う前に、 ‘load("finance")$’と書いて
パッケージをロードしなければいけないことに 注意してください。

   著者: Nicolas Guarin Zapata.


File: maxima.info,  Node: Functions and Variables for finance,  Prev: Introduction to finance,  Up: finance

53.2 Functions and Variables for finance
========================================

 -- 関数: days360 (<year1>,<month1>,<day1>,<year2>,<month2>,<day2>)

     2つの日付の距離を、 1年が360日、1月は30日と仮定して計算します。

     例:

          (%i1) load("finance")$
          (%i2) days360(2008,12,16,2007,3,25);
          (%o2)                      - 621

 -- 関数: fv (<rate>,<PV>,<num>)

     ある利率を与えられたとして、現在価値の将来価値を計算します。
     <rate>は利率で、<PV>は現在価値、 <num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) fv(0.12,1000,3);
          (%o2)                     1404.928

 -- 関数: pv (<rate>,<FV>,<num>)

     ある利率を与えられたとして、将来価値の現在価値を計算します。
     <rate>は利率で、<PV>は現在価値、 <num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) pv(0.12,1000,3);
          (%o2)                711.7802478134108

 -- 関数: graph_flow (<val>)

     時間順でマネーフローを、 正の値は青で上に、負の値は赤で下に プロッ
     トします。 フローの向きは値の符号で与えられます。 <val>はフローの値
     のリストです。

     例:

          (%i1) load("finance")$
          (%i2) graph_flow([-5000,-3000,800,1300,1500,2000])$

 -- 関数: annuity_pv (<rate>,<PV>,<num>)

     (総額のような)現在価値がわかっている年金を計算できます。 年金は一定
     で定期払いです。 <rate>は利率で、<PV>は現在価値、 <num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) annuity_pv(0.12,5000,10);
          (%o2)                884.9208207992202

 -- 関数: annuity_fv (<rate>,<FV>,<num>)

     要望価値(将来価値)がわかっている年金を計算できます。 年金は一定で定
     期払いです。 <rate>は利率で、<PV>は将来価値、 <num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) annuity_fv(0.12,65000,10);
          (%o2)                3703.970670389863

 -- 関数: geo_annuity_pv (<rate>,<growing_rate>,<PV>,<num>)

     (総額のような)現在価値がわかっている年金を計算できます。 年金は割増
     定期払いです。 <rate>は利率で、<growing_rate>は成長率、 <PV>は現在
     価値、<num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) geo_annuity_pv(0.14,0.05,5000,10);
          (%o2)                802.6888176505123

 -- 関数: geo_annuity_fv (<rate>,<growing_rate>,<FV>,<num>)

     要望価値(将来価値)がわかっている年金を計算できます。 年金は割増定期
     払いです。 <rate>は利率で、<growing_rate>は成長率、 <FV>は将来価値
     、<num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) geo_annuity_fv(0.14,0.05,5000,10);
          (%o2)                216.5203395312695

 -- 関数: amortization (<rate>,<ammount>,<num>)

     特定率で決定された償却表。 <rate>は利率で、<ammount>は総価値、
     <num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) amortization(0.05,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     52481.777      2800.000      3518.223      6318.223
               2.000     48787.643      2624.089      3694.134      6318.223
               3.000     44908.802      2439.382      3878.841      6318.223
               4.000     40836.019      2245.440      4072.783      6318.223
               5.000     36559.597      2041.801      4276.422      6318.223
               6.000     32069.354      1827.980      4490.243      6318.223
               7.000     27354.599      1603.468      4714.755      6318.223
               8.000     22404.106      1367.730      4950.493      6318.223
               9.000     17206.088      1120.205      5198.018      6318.223
              10.000     11748.170       860.304      5457.919      6318.223
              11.000      6017.355       587.408      5730.814      6318.223
              12.000         0.000       300.868      6017.355      6318.223

 -- 関数: arit_amortization (<rate>,<increment>,<ammount>,<num>)

     ‘arit_amortization’によって、特定率で決定された割増払いの償却表を計
     算することができます。 支払いは一定ではなく、算術級数的成長を示し、
     増分は"Payment"列の連続する2行の差であることに注意してください。
     <rate>は利率で、<increment>は増分、<ammount>は総価値、 <num>は期間
     です。

     例:

          (%i1) load("finance")$
          (%i2) arit_amortization(0.05,1000,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     57403.679      2800.000     -1403.679      1396.321
               2.000     57877.541      2870.184      -473.863      2396.321
               3.000     57375.097      2893.877       502.444      3396.321
               4.000     55847.530      2868.755      1527.567      4396.321
               5.000     53243.586      2792.377      2603.945      5396.321
               6.000     49509.443      2662.179      3734.142      6396.321
               7.000     44588.594      2475.472      4920.849      7396.321
               8.000     38421.703      2229.430      6166.892      8396.321
               9.000     30946.466      1921.085      7475.236      9396.321
              10.000     22097.468      1547.323      8848.998     10396.321
              11.000     11806.020      1104.873     10291.448     11396.321
              12.000        -0.000       590.301     11806.020     12396.321

 -- 関数: geo_amortization (<rate>,<growing_rate>,<ammount>,<num>)

     ‘geo_amortization’によって、ある率、ある総額、ある期間で決定された
     償却表を見つけることができます。

     支払いは一定ではなく、幾何級数的成長を示し、 <growing_rate>は
     "Payment"列の連続する2行の比率であることに注意してください。
     <rate>は利率で、<ammount>は総価値、 <num>は期間です。

     例:

          (%i1) load("finance")$
          (%i2) geo_amortization(0.05,0.03,56000,12)$
                "n"    "Balance"     "Interest"   "Amortization"  "Payment"
               0.000     56000.000         0.000         0.000         0.000
               1.000     53365.296      2800.000      2634.704      5434.704
               2.000     50435.816      2668.265      2929.480      5597.745
               3.000     47191.930      2521.791      3243.886      5765.677
               4.000     43612.879      2359.596      3579.051      5938.648
               5.000     39676.716      2180.644      3936.163      6116.807
               6.000     35360.240      1983.836      4316.475      6300.311
               7.000     30638.932      1768.012      4721.309      6489.321
               8.000     25486.878      1531.947      5152.054      6684.000
               9.000     19876.702      1274.344      5610.176      6884.520
              10.000     13779.481       993.835      6097.221      7091.056
              11.000      7164.668       688.974      6614.813      7303.787
              12.000         0.000       358.233      7164.668      7522.901

 -- 関数: saving (<rate>,<ammount>,<num>)

     ‘saving’によって、定額預金での価値を表すテーブルを見つけることがで
     きます。 <ammount>は要望量を、<num>は預金の期間を表します。

     例:

          (%i1) load("finance")$
          (%i2) saving(0.15,12000,15)$
                "n"    "Balance"     "Interest"   "Payment"
               0.000         0.000         0.000         0.000
               1.000       252.205         0.000       252.205
               2.000       542.240        37.831       252.205
               3.000       875.781        81.336       252.205
               4.000      1259.352       131.367       252.205
               5.000      1700.460       188.903       252.205
               6.000      2207.733       255.069       252.205
               7.000      2791.098       331.160       252.205
               8.000      3461.967       418.665       252.205
               9.000      4233.467       519.295       252.205
              10.000      5120.692       635.020       252.205
              11.000      6141.000       768.104       252.205
              12.000      7314.355       921.150       252.205
              13.000      8663.713      1097.153       252.205
              14.000     10215.474      1299.557       252.205
              15.000     12000.000      1532.321       252.205

 -- 関数: npv (<rate>,<val>)

     プロジェクトに関する存続可能性を評価するために、価値系列の正味現在
     価値を計算します。 <flowValues> es una lista con los valores para
     cada periodo.

     例:

          (%i1) load("finance")$
          (%i2) npv(0.25,[100,500,323,124,300]);
          (%o2)                714.4703999999999

 -- 関数: irr (<val>,<IO>)

     IRR (内部利益率)は正味現在価値をゼロにする割引率の値です。
     <flowValues> los valores para cada periodo (para periodos mayores a
     0) y <I0> el valor para el periodo cero.

     例:

          (%i1) load("finance")$
          (%i2) res:irr([-5000,0,800,1300,1500,2000],0)$
          (%i3) rhs(res[1][1]);
          (%o3)                .03009250374237132

 -- 関数: benefit_cost (<rate>,<input>,<output>)

     便益コスト比を計算します。 便益は投入の正味現在価値(NPV)で、 コスト
     は産出の正味現在価値(NPV)です。 もし特定の期間に関して投入価値か産
     出価値がゼロなら、 投入/産出比はその期間で0となることに注意してくだ
     さい。 <rate>は利率であり、 <input>は投入価値のリスト、 <output>は
     産出価値のリストです。

     例:

          (%i1) load("finance")$
          (%i2) benefit_cost(0.24,[0,300,500,150],[100,320,0,180]);
          (%o2)               1.427249324905784


File: maxima.info,  Node: fractals,  Next: ggf,  Prev: finance,  Up: Top

54 fractals
***********

* Menu:

* Introduction to fractals::
* Definitions for IFS fractals::
* Definitions for complex fractals::
* Definitions for Koch snowflakes::
* Definitions for Peano maps::


File: maxima.info,  Node: Introduction to fractals,  Next: Definitions for IFS fractals,  Prev: fractals,  Up: fractals

54.1 Introduction to fractals
=============================

このパッケージはよく知られているフラクタルをいくつか定義します:

   - ランダムIFS(反復函数系)を使って: Sierpinski三角形、木、シダ

   - 複素フラクタル: MandelbrotとJulia集合

   - Koch雪片集合

   - Peano写像: SierpinskiとHilbert写像

   著者: José Ramírez Labrador.

   質問、提案、バグに関しては、 pepe DOT ramirez AAATTT uca DOT es まで
、私に気兼ねせずコンタクトしてください。


File: maxima.info,  Node: Definitions for IFS fractals,  Next: Definitions for complex fractals,  Prev: Introduction to fractals,  Up: fractals

54.2 Definitions for IFS fractals
=================================

いくつかのフラクタルは、 縮小アフィン変換をランダムに繰り返し適用するこ
とで生成することができます; Hoggar S. G., "Mathematics for computer
graphics", Cambridge University Press 1994を参照してください。

   いくつかの縮小アフィン変換のリストを定義して、 繰り返しの中で変換をラ
ンダムに選択します。 変換の選択の確率は縮小比に関係しなければいけません
。

   変換を変えて、別のフラクタルを見つけることができます。

 -- 関数: sierpinskiale (<n>)

     Sierpinski三角形: 3つの縮小写像; .5の縮小定数と変形; すべての写像は
     同じ縮小比です。 引数<n>は十分大きく、10000以上でなければいけません
     、

     例:

          (%i1) load("fractals")$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,sierpinskiale(n)], [style,dots])$

 -- 関数: treefale (<n>)

     すべて同じ縮小比を持つ3つの縮小写像。 引数<n>は十分大きく、10000以
     上でなければいけません、

     例:

          (%i1) load("fractals")$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,treefale(n)], [style,dots])$

 -- 関数: fernfale (<n>)

     変換を選択する確率が縮小比に関係する、4つの縮小写像。 引数<n>は十分
     大きく、10000以上でなければいけません、

     例:

          (%i1) load("fractals")$
          (%i2) n: 10000$
          (%i3) plot2d([discrete,fernfale(n)], [style,dots])$


File: maxima.info,  Node: Definitions for complex fractals,  Next: Definitions for Koch snowflakes,  Prev: Definitions for IFS fractals,  Up: Top

54.3 Definitions for complex fractals
=====================================

 -- 関数: mandelbrot_set (<x>, <y>)

     Mandelbrot集合。

     例:

     たくさんの演算を実行しなければいけないので、このプログラムは時間が
     かかります; 計算時間は格子点の数にも関係します。

          (%i1) load("fractals")$
          (%i2) plot3d (mandelbrot_set, [x, -2.5, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

 -- 関数: julia_set (<x>, <y>)

     Julia集合。

     たくさんの演算を実行しなければいけないので、このプログラムは時間が
     かかります; 計算時間は格子点の数にも関係します。

     例:

          (%i1) load("fractals")$
          (%i2) plot3d (julia_set, [x, -2, 1], [y, -1.5, 1.5],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     See also ‘julia_parameter’.

 -- オプション変数: julia_parameter
     デフォルト値: ‘%i’

     Juliaフラクタルの複素パラメータ。 デフォルト値は‘%i’です; we
     suggest the values 値‘-.745+%i*.113002’, ‘-.39054-%i*.58679’,
     ‘-.15652+%i*1.03225’, ‘-.194+%i*.6557’, ‘.011031-%i*.67037’を提案し
     ます。

 -- 関数: julia_sin (<x>, <y>)

     関数‘julia_set’が変換‘julia_parameter+z^2’を実装する一方、 関数
     ‘julia_sin’は‘julia_parameter*sin(z)’を実装します。 詳細はソースコ
     ードを参照してください。

     たくさんのsinを計算するので、このプログラムはゆっくり実行されます

     例:

     たくさんの演算を実行しなければいけないので、このプログラムは時間が
     かかります; 計算時間は格子点の数にも関係します。

          (%i1) load("fractals")$
          (%i2) julia_parameter:1+.1*%i$
          (%i3) plot3d (julia_sin, [x, -2, 2], [y, -3, 3],
                          [gnuplot_preamble, "set view map"],
                          [gnuplot_pm3d, true],
                          [grid, 150, 150])$

     See also ‘julia_parameter’.


File: maxima.info,  Node: Definitions for Koch snowflakes,  Next: Definitions for Peano maps,  Prev: Definitions for complex fractals,  Up: Top

54.4 Definitions for Koch snowflakes
====================================

 -- 関数: snowmap (<ent>, <nn>)

     Koch雪片集合。 関数‘snowmap’は、 複素平面内の初期値の閉多角形の頂点
     上に雪Koch写像をプロットします。 ここで多角形の向きが重要です。 引
     数Argument <nn>はKoch変換の繰り返し適用の回数です; <nn>は小さく(5か
     6で)なければいけません。

     例:

          (%i1) load("fractals")$
          (%i2) plot2d([discrete,
                        snowmap([1,exp(%i*%pi*2/3),exp(-%i*%pi*2/3),1],4)])$
          (%i3) plot2d([discrete,
                        snowmap([1,exp(-%i*%pi*2/3),exp(%i*%pi*2/3),1],4)])$
          (%i4) plot2d([discrete, snowmap([0,1,1+%i,%i,0],4)])$
          (%i5) plot2d([discrete, snowmap([0,%i,1+%i,1,0],4)])$


File: maxima.info,  Node: Definitions for Peano maps,  Prev: Definitions for Koch snowflakes,  Up: fractals

54.5 Definitions for Peano maps
===============================

ある面積を覆う連続曲線。 警告: <n>と共に点の数は指数関数的に増加します。

 -- 関数: hilbertmap (<nn>)

     Hilbert写像。 <nn>は小さく(例えば5で)なければいけません。 もし7以上
     ならMaximaはクラッシュするかもしれません。

     例:

          (%i1) load("fractals")$
          (%i2) plot2d([discrete,hilbertmap(6)])$

 -- 関数: sierpinskimap (<nn>)

     Sierpinski写像。 <nn>は小さく(例えば5で)なければいけません。 もし
     7以上ならMaximaはクラッシュするかもしれません。

     例:

          (%i1) load("fractals")$
          (%i2) plot2d([discrete,sierpinskimap(6)])$


File: maxima.info,  Node: ggf,  Next: graphs,  Prev: fractals,  Up: Top

55 ggf
******

* Menu:

* Functions and Variables for ggf::


File: maxima.info,  Node: Functions and Variables for ggf,  Prev: ggf,  Up: ggf

55.1 Functions and Variables for ggf
====================================

 -- オプション変数: GGFINFINITY
     デフォルト値: 3

     これは関数‘ggf’のオプション変数です。

     母関数の連分数を計算する時、 (厳密に)<GGFINFINITY>より大きな次数を
     持つ 部分商は捨てられます。 現在のコンバージェントは母関数の正確な
     値として考えられます; 部分商すべての次数はたいてい0か1です; もしよ
     り大きな値を使うなら、 十分精度の高い計算を行うために十分な項を与え
     るべきです。

     ‘ggf’も参照してください。

 -- オプション変数: GGFCFMAX
     デフォルト値: 3

     これは 関数‘ggf’のオプション変数です。

     母関数の連分数を計算する時、 もし <GGFCFMAX>個の部分商を計算した後
     、よい結果が見つからないなら (<GGFINFINITY>フラグを参照してください
     )、 母関数は２つの多項式の分数でないように考えられ、 関数は抜けます
     。 もっと複雑な母関数のためにより大きな値を自由に入れてください。

     ‘ggf’も参照してください。

 -- 関数: ggf (<l>)
     (もし母関数が２つの多項式の分数なら) 与えられた最初の数項に対する、
     数列の母関数を計算します。 <l>は数のリストです。

     解は２つの多項式の分数として返されます。 解が見つからなかったら、
     ‘done’を返します。

     この関数は グローバル変数<GGFINFINITY>と<GGFCFMAX>で制御されます。
     <GGFINFINITY>と<GGFCFMAX>も参照してください。

     この関数を使うには、最初に‘load("ggf")’を書いてください。


File: maxima.info,  Node: graphs,  Next: grobner,  Prev: ggf,  Up: Top

56 graphs
*********

* Menu:

* Introduction to graphs::
* Functions and Variables for graphs::


File: maxima.info,  Node: Introduction to graphs,  Next: Functions and Variables for graphs,  Prev: graphs,  Up: graphs

56.1 Introduction to graphs
===========================

‘graphs’パッケージはMaximaにグラフと有向グラフデータ構造を提供します。 有
向グラフは<u>から<v>への有向辺と<v>から<u>への有向辺を持つことができます
が、グラフや有向グラフは単純です(多重辺もループも持ちません)。

   内部的にはグラフは隣接リストで表現され、 lisp構造として実装されます。
頂点はそれらのid(idは整数)で識別されます。 辺/弧は長さ2のリストで表現さ
れます。 グラフ/有向グラフの頂点にラベルを割り当てることができ、 グラフ
/有向グラフの辺/弧に重みを割り当てることができます。

   グラフを描画するためのの‘draw_graph’関数があります。 グラフはforce
based 頂点配置アルゴリズムを使って描画されます。 ‘draw_graph’は
<http://www.graphviz.org>から利用可能なgraphvizプログラムを使うこともで
きます。 ‘draw_graph’はMaxima ‘draw’パッケージに基づいています。

   ‘graphs’パッケージを使うには、 最初に‘load("graphs")’でロードしてくだ
さい。


File: maxima.info,  Node: Functions and Variables for graphs,  Prev: Introduction to graphs,  Up: graphs

56.2 Functions and Variables for graphs
=======================================

56.2.1 Building graphs
----------------------

 -- 関数: create_graph (<v_list>, <e_list>)
 -- 関数: create_graph (<n>, <e_list>)
 -- 関数: create_graph (<v_list>, <e_list>, <directed>)
     頂点の集合<v_list>上に辺<e_list>を使って新しいグラフを生成します。

     <v_list>は頂点のリスト(‘[v1, v2,..., vn]’)もしくは 頂点ラベルを持つ
     頂点のリスト(‘[[v1,l1], [v2,l2],..., [vn,ln]]’)です。

     <n>は頂点の数です。 頂点は0からn-1までの整数で識別されます。 (訳注:
     1から始まるMaximaのリストの添字の慣例とは異なることに注意してくださ
     い。)

     <e_list>は辺のリスト(‘[e1, e2,..., em]’)もしくは 辺の重みを持つ辺の
     リスト(‘[[e1, w1], ..., [em, wm]]’)です。

     もし<directed>が‘false’でないなら、 有向グラフが返されます。

     例1: 頂点3つの循環を生成する。
          (%i1) load ("graphs")$
          (%i2) g : create_graph([1,2,3], [[1,2], [2,3], [1,3]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     例2: 辺の重みを持つ頂点3つの循環を生成する。
          (%i1) load ("graphs")$
          (%i2) g : create_graph([1,2,3], [[[1,2], 1.0], [[2,3], 2.0],
                                    [[1,3], 3.0]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     例3: 有向グラフを生成する:
          (%i1) load ("graphs")$
          (%i2) d : create_graph(
                  [1,2,3,4],
                  [
                   [1,3], [1,4],
                   [2,3], [2,4]
                  ],
                  'directed = true)$
          (%i3) print_graph(d)$
          Digraph on 4 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :
            2 :  4  3
            1 :  4  3

 -- 関数: copy_graph (<g>)
     グラフ<g>のコピーを返します。

 -- 関数: circulant_graph (<n>, <d>)
     パラメータ <n>と <d>を持つ巡回グラフを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : circulant_graph(10, [1,3])$
          (%i3) print_graph(g)$
          Graph on 10 vertices with 20 edges.
          Adjacencies:
            9 :  2  6  0  8
            8 :  1  5  9  7
            7 :  0  4  8  6
            6 :  9  3  7  5
            5 :  8  2  6  4
            4 :  7  1  5  3
            3 :  6  0  4  2
            2 :  9  5  3  1
            1 :  8  4  2  0
            0 :  7  3  9  1

 -- 関数: clebsch_graph ()
     Clebschグラフを返します。

 -- 関数: complement_graph (<g>)
     グラフ <g>の補グラフを返します。

 -- 関数: complete_bipartite_graph (<n>, <m>)
     <n+m>この頂点上の完全2部グラフを返します。

 -- 関数: complete_graph (<n>)
     <n>この頂点上の完全グラフを返します。

 -- 関数: cycle_digraph (<n>)
     <n>個の頂点上の有向グラフを返します。

 -- 関数: cycle_graph (<n>)
     <n>この頂点上の閉路を返します。

 -- 関数: cuboctahedron_graph (<n>)
     立方八面体グラフを返します。

 -- 関数: cube_graph (<n>)
     <n>次元立方体を返します。

 -- 関数: dodecahedron_graph ()
     十二面体グラフを返します。

 -- 関数: empty_graph (<n>)
     <n>個の頂点上の空グラフを返します。

 -- 関数: flower_snark (<n>)
     <4n>個の頂点上の花グラフを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) f5 : flower_snark(5)$
          (%i3) chromatic_index(f5);
          (%o3)                           4

 -- 関数: from_adjacency_matrix (<A>)
     隣接行列 <A>で表現されるグラフを返します。

 -- 関数: frucht_graph ()
     Fruchtグラフを返します。

 -- 関数: graph_product (<g1>, <g1>)
     グラフ <g1>と <g2>の直積を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) grid : graph_product(path_graph(3), path_graph(4))$
          (%i3) draw_graph(grid)$

 -- 関数: graph_union (<g1>, <g1>)
     グラフ<g1>と <g2>の和を返します。

 -- 関数: grid_graph (<n>, <m>)
     <n x m>グリッドを返します。

 -- 関数: great_rhombicosidodecahedron_graph ()
     大菱形二十・十二面体グラフを返します。

 -- 関数: great_rhombicuboctahedron_graph ()
     大斜方立方八面体グラフを返します。

 -- 関数: grotzch_graph ()
     Grotzchグラフを返します。

 -- 関数: heawood_graph ()
     Heawoodグラフを返します。

 -- 関数: icosahedron_graph ()
     二十面体グラフを返します。

 -- 関数: icosidodecahedron_graph ()
     二十・十二面体グラフを返します。

 -- 関数: induced_subgraph (<V>, <g>)
     グラフ <g>の頂点の部分集合 <V>上の誘導部分グラフを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) V : [0,1,2,3,4]$
          (%i4) g : induced_subgraph(V, p)$
          (%i5) print_graph(g)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  3  0
            3 :  2  4
            2 :  1  3
            1 :  0  2
            0 :  1  4

 -- 関数: line_graph (<g>)
     グラフ <g>の折れ線グラフを返します。

 -- 関数: make_graph (<vrt>, <f>)
 -- 関数: make_graph (<vrt>, <f>, <oriented>)
     述語論理関数 <f>を使ってグラフを生成します。

     <vrt>は頂点か整数のリスト/集合です。 もし <vrt>が整数なら、 グラフ
     の頂点は1から <vrt>までの整数です。

     <f>は述語論理関数です。 2つの頂点 <a>と <b>は もし ‘f(a,b)=true’な
     ら結合されます。

     もし <directed>が <false>でないなら、 グラフは有向です。

     例 1:
          (%i1) load("graphs")$
          (%i2) g : make_graph(powerset({1,2,3,4,5}, 2), disjointp)$
          (%i3) is_isomorphic(g, petersen_graph());
          (%o3)                         true
          (%i4) get_vertex_label(1, g);
          (%o4)                        {1, 2}

     例 2:
          (%i1) load("graphs")$
          (%i2) f(i, j) := is (mod(j, i)=0)$
          (%i3) g : make_graph(20, f, directed=true)$
          (%i4) out_neighbors(4, g);
          (%o4)                    [8, 12, 16, 20]
          (%i5) in_neighbors(18, g);
          (%o5)                    [1, 2, 3, 6, 9]

 -- 関数: mycielski_graph (<g>)
     グラフ <g>のMycielskiグラフを返します。

 -- 関数: new_graph ()
     頂点も辺も持たないグラフを返します。

 -- 関数: path_digraph (<n>)
     <n>個の頂点上の有向道を返します。

 -- 関数: path_graph (<n>)
     <n>個の頂点上の道を返します。

 -- 関数: petersen_graph ()
 -- 関数: petersen_graph (<n>, <d>)
     Petersenグラフ <P_{n,d}>を返します。 <n>と <d>のデフォルト値は
     ‘n=5’と ‘d=2’です。

 -- 関数: random_bipartite_graph (<a>, <b>, <p>)
     ‘a+b’個の頂点上のランダムな2部グラフを返します。 辺それぞれは確率
     <p>で存在します。

 -- 関数: random_digraph (<n>, <p>)
     ‘n’個の頂点上のランダムな有向グラフを返します。 弧それぞれは確率
     <p>で存在します。

 -- 関数: random_regular_graph (<n>)
 -- 関数: random_regular_graph (<n>, <d>)
     <n>個の頂点上の ランダムな<d>正則グラフを返します。 <d>のデフォルト
     値は ‘d=3’です。

 -- 関数: random_graph (<n>, <p>)
     <n>個の頂点上のランダムグラフを返します。 辺それぞれは確率 <p>で存
     在します。

 -- 関数: random_graph1 (<n>, <m>)
     <n>個の頂点とランダムな <m>個の辺上のランダムグラフを返します。

 -- 関数: random_network (<n>, <p>, <w>)
     <n>個の頂点上のランダムネットワークを返します。 弧それぞれは確率
     <p>で存在し、 範囲 ‘[0,w]’の中に重みを持ちます。 関数はリスト
     ‘[network, source, sink]’を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) [net, s, t] : random_network(50, 0.2, 10.0);
          (%o2)                   [DIGRAPH, 50, 51]
          (%i3) max_flow(net, s, t)$
          (%i4) first(%);
          (%o4)                   27.65981397932507

 -- 関数: random_tournament (<n>)
     <n>個の頂点上のランダムなトーナメントを返します。

 -- 関数: random_tree (<n>)
     <n>個の頂点上のランダムな木を返します。

 -- 関数: small_rhombicosidodecahedron_graph ()
     斜方二十・十二面体グラフを返します。

 -- 関数: small_rhombicuboctahedron_graph ()
     斜方立方八面体グラフを返します。

 -- 関数: snub_cube_graph ()
     変形立方体グラフを返します。

 -- 関数: snub_dodecahedron_graph ()
     変形十二面体グラフを返します。

 -- 関数: truncated_cube_graph ()
     切頂六面体グラフを返します。

 -- 関数: truncated_dodecahedron_graph ()
     切頂十二面体グラフを返します。

 -- 関数: truncated_icosahedron_graph ()
     切頂二十面体グラフを返します。

 -- 関数: truncated_tetrahedron_graph ()
     切頂四面体グラフを返します。

 -- 関数: tutte_graph ()
     Tutteグラフを返します。

 -- 関数: underlying_graph (<g>)
     有向グラフ <g>の台グラフを返します。

 -- 関数: wheel_graph (<n>)
     <n+1>個の頂点上の車輪グラフを返します。

56.2.2 Graph properties
-----------------------

 -- 関数: adjacency_matrix (<gr>)
     グラフ <gr>の隣接行列を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) c5 : cycle_graph(4)$
          (%i3) adjacency_matrix(c5);
                                   [ 0  1  0  1 ]
                                   [            ]
                                   [ 1  0  1  0 ]
          (%o3)                    [            ]
                                   [ 0  1  0  1 ]
                                   [            ]
                                   [ 1  0  1  0 ]

 -- 関数: average_degree (<gr>)
     グラフ <gr>に関する平均次数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) average_degree(grotzch_graph());
                                         40
          (%o2)                          --
                                         11

 -- 関数: biconnected_components (<gr>)
     グラフ <gr>の2連結成分(の頂点集合)を返します

     例:
          (%i1) load ("graphs")$
          (%i2) g : create_graph(
                      [1,2,3,4,5,6,7],
                      [
                       [1,2],[2,3],[2,4],[3,4],
                       [4,5],[5,6],[4,6],[6,7]
                      ])$
          (%i3) biconnected_components(g);
          (%o3)        [[6, 7], [4, 5, 6], [1, 2], [2, 3, 4]]

 -- 関数: bipartition (<gr>)
     グラフ <gr>の頂点の2分割か、もし <gr>が2部でないなら空のリストを返
     します。

     例:

          (%i1) load ("graphs")$
          (%i2) h : heawood_graph()$
          (%i3) [A,B]:bipartition(h);
          (%o3)  [[8, 12, 6, 10, 0, 2, 4], [13, 5, 11, 7, 9, 1, 3]]
          (%i4) draw_graph(h, show_vertices=A, program=circular)$

 -- 関数: chromatic_index (<gr>)
     グラフ <gr>の彩色指数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) chromatic_index(p);
          (%o3)                           4

 -- 関数: chromatic_number (<gr>)
     グラフ <gr>の彩色数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) chromatic_number(cycle_graph(5));
          (%o2)                           3
          (%i3) chromatic_number(cycle_graph(6));
          (%o3)                           2

 -- 関数: clear_edge_weight (<e>, <gr>)
     グラフ <gr>の辺 <e>の重みを削除します。

     例:

          (%i1) load ("graphs")$
          (%i2) g : create_graph(3, [[[0,1], 1.5], [[1,2], 1.3]])$
          (%i3) get_edge_weight([0,1], g);
          (%o3)                          1.5
          (%i4) clear_edge_weight([0,1], g)$
          (%i5) get_edge_weight([0,1], g);
          (%o5)                           1

 -- 関数: clear_vertex_label (<v>, <gr>)
     グラフ <gr>の頂点 <v>のラベルを削除します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                         Zero
          (%i4) clear_vertex_label(0, g);
          (%o4)                         done
          (%i5) get_vertex_label(0, g);
          (%o5)                         false

 -- 関数: connected_components (<gr>)
     グラフ <gr>の連携成分(の頂点集合)を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g: graph_union(cycle_graph(5), path_graph(4))$
          (%i3) connected_components(g);
          (%o3)            [[1, 2, 3, 4, 0], [8, 7, 6, 5]]

 -- 関数: diameter (<gr>)
     グラフ <gr>の直径を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) diameter(dodecahedron_graph());
          (%o2)                           5

 -- 関数: edge_coloring (<gr>)
     グラフ <gr>の辺の最適色づけを返します。

     関数は彩色指数と<gr>の辺の色付けを表すリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) [ch_index, col] : edge_coloring(p);
          (%o3) [4, [[[0, 5], 3], [[5, 7], 1], [[0, 1], 1], [[1, 6], 2],
          [[6, 8], 1], [[1, 2], 3], [[2, 7], 4], [[7, 9], 2], [[2, 3], 2],
          [[3, 8], 3], [[5, 8], 2], [[3, 4], 1], [[4, 9], 4], [[6, 9], 3],
          [[0, 4], 2]]]
          (%i4) assoc([0,1], col);
          (%o4)                           1
          (%i5) assoc([0,5], col);
          (%o5)                           3

 -- 関数: degree_sequence (<gr>)
     グラフ <gr>の頂点次数のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) degree_sequence(random_graph(10, 0.4));
          (%o2)            [2, 2, 2, 2, 2, 2, 3, 3, 3, 3]

 -- 関数: edge_connectivity (<gr>)
     グラフ <gr>の辺連結性を返します。

     ‘min_edge_cut’も参照してください。

 -- 関数: edges (<gr>)
     (有向)グラフ <gr>の辺(弧)のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) edges(complete_graph(4));
          (%o2)   [[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]

 -- 関数: get_edge_weight (<e>, <gr>)
 -- 関数: get_edge_weight (<e>, <gr>, <ifnot>)
     グラフ <gr>の辺 <e>の重みを返します。

     もし辺に割り当てられた重みがないなら、 関数は1を返します。 もし辺が
     グラフの中に存在しないなら、 関数はエラーをシグナルするか、オプショ
     ン引数 <ifnot>を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) c5 : cycle_graph(5)$
          (%i3) get_edge_weight([1,2], c5);
          (%o3)                           1
          (%i4) set_edge_weight([1,2], 2.0, c5);
          (%o4)                         done
          (%i5) get_edge_weight([1,2], c5);
          (%o5)                          2.0

 -- 関数: get_vertex_label (<v>, <gr>)
     グラフ <gr>の頂点 <v>のラベルを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                         Zero

 -- 関数: graph_charpoly (<gr>, <x>)
     グラフ <gr>の(変数 <x>に関する)特性多項式を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_charpoly(p, x), factor;
                                             5        4
          (%o3)               (x - 3) (x - 1)  (x + 2)

 -- 関数: graph_center (<gr>)
     グラフ <gr>の中心を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_center(g);
          (%o3)                         [12]

 -- 関数: graph_eigenvalues (<gr>)
     グラフ <gr>の固有値を返します。 関数は maxima ‘eigenvalue’関数と同
     じフォーマットで固有値を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_eigenvalues(p);
          (%o3)               [[3, - 2, 1], [1, 4, 5]]

 -- 関数: graph_periphery (<gr>)
     グラフ <gr>の外周を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_periphery(g);
          (%o3)                    [24, 20, 4, 0]

 -- 関数: graph_size (<gr>)
     グラフ <gr>の辺の数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_size(p);
          (%o3)                          15

 -- 関数: graph_order (<gr>)
     グラフ <gr>の頂点の数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) graph_order(p);
          (%o3)                          10

 -- 関数: girth (<gr>)
     <gr>の最短閉路の長さを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : heawood_graph()$
          (%i3) girth(g);
          (%o3)                           6

 -- 関数: hamilton_cycle (<gr>)
     グラフ <gr>のHamilton閉路を返します。 もし <gr>がハミルトニアンでな
     いなら、空のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) c : cube_graph(3)$
          (%i3) hc : hamilton_cycle(c);
          (%o3)              [7, 3, 2, 6, 4, 0, 1, 5, 7]
          (%i4) draw_graph(c, show_edges=vertices_to_cycle(hc))$

 -- 関数: hamilton_path (<gr>)
     グラフ <gr>のHamilton経路を返します。 もし <gr>がHamilton経路を持た
     ないなら、空のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) hp : hamilton_path(p);
          (%o3)            [0, 5, 7, 2, 1, 6, 8, 3, 4, 9]
          (%i4) draw_graph(p, show_edges=vertices_to_path(hp))$

 -- 関数: isomorphism (<gr1>, <gr2>)

     グラフ/有向グラフ <gr1>と <gr2>の間の同型写像を返します。 もし
     <gr1>と <gr2>が同型でないなら、空のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) isomorphism(clk5, petersen_graph());
          (%o3) [9 -> 0, 2 -> 1, 6 -> 2, 5 -> 3, 0 -> 4, 1 -> 5, 3 -> 6,
                                                    4 -> 7, 7 -> 8, 8 -> 9]

 -- 関数: in_neighbors (<v>, <gr>)
     有向グラフ <gr>の頂点 <v>の内隣接点のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                          [1]
          (%i4) out_neighbors(2, p);
          (%o4)                          []

 -- 関数: is_biconnected (<gr>)
     もし <gr>が2連結なら ‘true’を、 そうでないなら、 ‘false’を返します
     。

     例:
          (%i1) load ("graphs")$
          (%i2) is_biconnected(cycle_graph(5));
          (%o2)                         true
          (%i3) is_biconnected(path_graph(5));
          (%o3)                         false

 -- 関数: is_bipartite (<gr>)
     もし <gr>が2部(2彩色)なら ‘true’を、 そうでないなら、 ‘false’を返し
     ます。

     例:
          (%i1) load ("graphs")$
          (%i2) is_bipartite(petersen_graph());
          (%o2)                         false
          (%i3) is_bipartite(heawood_graph());
          (%o3)                         true

 -- 関数: is_connected (<gr>)
     もしグラフ <gr>が連結なら ‘true’を、 そうでないなら ‘false’を返しま
     す。

     例:
          (%i1) load ("graphs")$
          (%i2) is_connected(graph_union(cycle_graph(4), path_graph(3)));
          (%o2)                         false

 -- 関数: is_digraph (<gr>)
     もし <gr>が有向グラフなら ‘true’を、 そうでないなら ‘false’を返しま
     す。

     例:
          (%i1) load ("graphs")$
          (%i2) is_digraph(path_graph(5));
          (%o2)                         false
          (%i3) is_digraph(path_digraph(5));
          (%o3)                         true

 -- 関数: is_edge_in_graph (<e>, <gr>)
     もし <e>が(有向)グラフ <g>の辺(弧)なら ‘true’を、 そうでないなら
     ‘false’を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_edge_in_graph([2,3], c4);
          (%o3)                         true
          (%i4) is_edge_in_graph([3,2], c4);
          (%o4)                         true
          (%i5) is_edge_in_graph([2,4], c4);
          (%o5)                         false
          (%i6) is_edge_in_graph([3,2], cycle_digraph(4));
          (%o6)                         false

 -- 関数: is_graph (<gr>)
     もし <gr>がグラフなら ‘true’を、 そうでないなら ‘false’を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) is_graph(path_graph(5));
          (%o2)                         true
          (%i3) is_graph(path_digraph(5));
          (%o3)                         false

 -- 関数: is_graph_or_digraph (<gr>)
     もし <gr>がグラフか有向グラフなら ‘true’を、 そうでないなら
     ‘false’を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) is_graph_or_digraph(path_graph(5));
          (%o2)                         true
          (%i3) is_graph_or_digraph(path_digraph(5));
          (%o3)                         true

 -- 関数: is_isomorphic (<gr1>, <gr2>)

     もし グラフ/有向グラフ <gr1>と <gr2>が同型なら ‘true’を、 そうでな
     いなら ‘false’を返します。

     ‘isomorphism’も参照してください。

     例:
          (%i1) load ("graphs")$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) is_isomorphic(clk5, petersen_graph());
          (%o3)                         true

 -- 関数: is_planar (<gr>)

     もし <gr>が平面グラフなら ‘true’を、 そうでないなら ‘false’を返しま
     す。

     使われているアルゴリズムはDemoucronのアルゴリズムです。 これは二次
     時間アルゴリズムです。

     例:
          (%i1) load ("graphs")$
          (%i2) is_planar(dodecahedron_graph());
          (%o2)                         true
          (%i3) is_planar(petersen_graph());
          (%o3)                         false
          (%i4) is_planar(petersen_graph(10,2));
          (%o4)                         true

 -- 関数: is_sconnected (<gr>)
     もし有向グラフ <gr>が強連結なら ‘true’を、 そうでないなら ‘false’を
     返します。

     例:
          (%i1) load ("graphs")$
          (%i2) is_sconnected(cycle_digraph(5));
          (%o2)                         true
          (%i3) is_sconnected(path_digraph(5));
          (%o3)                         false

 -- 関数: is_vertex_in_graph (<v>, <gr>)
     もし <v>がグラフ <g>の頂点なら ‘true’を、 そうでないなら ‘false’を
     返します。

     例:
          (%i1) load ("graphs")$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_vertex_in_graph(0, c4);
          (%o3)                         true
          (%i4) is_vertex_in_graph(6, c4);
          (%o4)                         false

 -- 関数: is_tree (<gr>)
     もし <gr>が木なら ‘true’を、 そうでないなら ‘false’を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) is_tree(random_tree(4));
          (%o2)                         true
          (%i3) is_tree(graph_union(random_tree(4), random_tree(5)));
          (%o3)                         false

 -- 関数: laplacian_matrix (<gr>)
     グラフ <gr>のLaplace行列を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) laplacian_matrix(cycle_graph(5));
                             [  2   - 1   0    0   - 1 ]
                             [                         ]
                             [ - 1   2   - 1   0    0  ]
                             [                         ]
          (%o2)              [  0   - 1   2   - 1   0  ]
                             [                         ]
                             [  0    0   - 1   2   - 1 ]
                             [                         ]
                             [ - 1   0    0   - 1   2  ]

 -- 関数: max_clique (<gr>)
     グラフ <gr>の最大クリークを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : random_graph(100, 0.5)$
          (%i3) max_clique(g);
          (%o3)          [6, 12, 31, 36, 52, 59, 62, 63, 80]

 -- 関数: max_degree (<gr>)
     グラフ <gr>の頂点の最大次数と最大次数の頂点を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : random_graph(100, 0.02)$
          (%i3) max_degree(g);
          (%o3)                        [6, 79]
          (%i4) vertex_degree(95, g);
          (%o4)                           2

 -- 関数: max_flow (<net>, <s>, <t>)
     ソース <s>とシンク <t>を持ち ネットワーク <net>を通る最大フローを返
     します。

     関数は最大フローの値と 最適フローで弧の重みを表現するリストを返しま
     す。

     例:
          (%i1) load ("graphs")$
          (%i2) net : create_graph(
            [1,2,3,4,5,6],
            [[[1,2], 1.0],
             [[1,3], 0.3],
             [[2,4], 0.2],
             [[2,5], 0.3],
             [[3,4], 0.1],
             [[3,5], 0.1],
             [[4,6], 1.0],
             [[5,6], 1.0]],
            directed=true)$
          (%i3) [flow_value, flow] : max_flow(net, 1, 6);
          (%o3) [0.7, [[[1, 2], 0.5], [[1, 3], 0.2], [[2, 4], 0.2],
          [[2, 5], 0.3], [[3, 4], 0.1], [[3, 5], 0.1], [[4, 6], 0.3],
          [[5, 6], 0.4]]]
          (%i4) fl : 0$
          (%i5) for u in out_neighbors(1, net)
               do fl : fl + assoc([1, u], flow)$
          (%i6) fl;
          (%o6)                          0.7

 -- 関数: max_independent_set (<gr>)
     グラフ <gr>の最大独立集合を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) mi : max_independent_set(d);
          (%o3)             [0, 3, 5, 9, 10, 11, 18, 19]
          (%i4) draw_graph(d, show_vertices=mi)$

 -- 関数: max_matching (<gr>)
     グラフ <gr>の最大マッチングを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) m : max_matching(d);
          (%o3) [[5, 7], [8, 9], [6, 10], [14, 19], [13, 18], [12, 17],
                                         [11, 16], [0, 15], [3, 4], [1, 2]]
          (%i4) draw_graph(d, show_edges=m)$

 -- 関数: min_degree (<gr>)
     グラフ <gr>の頂点の最小次数と最小次数の頂点を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : random_graph(100, 0.1)$
          (%i3) min_degree(g);
          (%o3)                        [3, 49]
          (%i4) vertex_degree(21, g);
          (%o4)                           9

 -- 関数: min_edge_cut (<gr>)
     グラフ <gr>の最小切断辺を返します。

     ‘edge_connectivity’も参照してください。

 -- 関数: min_vertex_cover (<gr>)
     グラフ <gr>の最小頂点被覆を返します。

 -- 関数: min_vertex_cut (<gr>)
     Returns the minimum vertex cut in the graph グラフ <gr>の最小頂点切
     断を返します。

     ‘vertex_connectivity’も参照してください。

 -- 関数: minimum_spanning_tree (<gr>)
     グラフ <gr>の最小全域木を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : graph_product(path_graph(10), path_graph(10))$
          (%i3) t : minimum_spanning_tree(g)$
          (%i4) draw_graph(g, show_edges=edges(t))$

 -- 関数: neighbors (<v>, <gr>)
     グラフ <gr>の頂点 <v>の隣接点のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : petersen_graph()$
          (%i3) neighbors(3, p);
          (%o3)                       [4, 8, 2]

 -- 関数: odd_girth (<gr>)
     グラフ <gr>の最短奇閉路の長さを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g : graph_product(cycle_graph(4), cycle_graph(7))$
          (%i3) girth(g);
          (%o3)                           4
          (%i4) odd_girth(g);
          (%o4)                           7

 -- 関数: out_neighbors (<v>, <gr>)
     有向グラフ <gr>の頂点 <v>の外隣接点のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                          [1]
          (%i4) out_neighbors(2, p);
          (%o4)                          []

 -- 関数: planar_embedding (<gr>)

     <gr>の平面埋め込みでのfacial walkのリストを返します。 もし <gr>が平
     面グラフでないなら ‘false’を返します。

     グラフ <gr>は2連結でなければいけません。

     使われるアルゴリズムはDemoucronのアルゴリズムです。 これは二次時間
     アルゴリズムです。

     例:
          (%i1) load ("graphs")$
          (%i2) planar_embedding(grid_graph(3,3));
          (%o2) [[3, 6, 7, 8, 5, 2, 1, 0], [4, 3, 0, 1], [3, 4, 7, 6],
                                                [8, 7, 4, 5], [1, 2, 5, 4]]

 -- 関数: print_graph (<gr>)
     グラフ <gr>についてのある情報を印字します。

     例:
          (%i1) load ("graphs")$
          (%i2) c5 : cycle_graph(5)$
          (%i3) print_graph(c5)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  0  3
            3 :  4  2
            2 :  3  1
            1 :  2  0
            0 :  4  1
          (%i4) dc5 : cycle_digraph(5)$
          (%i5) print_graph(dc5)$
          Digraph on 5 vertices with 5 arcs.
          Adjacencies:
            4 :  0
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i6) out_neighbors(0, dc5);
          (%o6)                          [1]

 -- 関数: radius (<gr>)
     グラフ <gr>の半径を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) radius(dodecahedron_graph());
          (%o2)                           5

 -- 関数: set_edge_weight (<e>, <w>, <gr>)
     グラフ <gr>の辺 <e>に重み <w>を割り当てます。

     例:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([1, 2], [[[1,2], 1.2]])$
          (%i3) get_edge_weight([1,2], g);
          (%o3)                          1.2
          (%i4) set_edge_weight([1,2], 2.1, g);
          (%o4)                         done
          (%i5) get_edge_weight([1,2], g);
          (%o5)                          2.1

 -- 関数: set_vertex_label (<v>, <l>, <gr>)
     グラフ <gr>の頂点 <v>にラベル <l>を割り当てます。

     例:
          (%i1) load ("graphs")$
          (%i2) g : create_graph([[1, "One"], [2, "Two"]], [[1,2]])$
          (%i3) get_vertex_label(1, g);
          (%o3)                          One
          (%i4) set_vertex_label(1, "oNE", g);
          (%o4)                         done
          (%i5) get_vertex_label(1, g);
          (%o5)                          oNE

 -- 関数: shortest_path (<u>, <v>, <gr>)
     グラフ <gr>の <u>から <v>までの最短経路を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) path : shortest_path(0, 7, d);
          (%o3)                   [0, 1, 19, 13, 7]
          (%i4) draw_graph(d, show_edges=vertices_to_path(path))$

 -- 関数: shortest_weighted_path (<u>, <v>, <gr>)
     グラフ <gr>の <u>から <v>までの最短重み付き経路とその長さを返します
     。

     重み付き経路の長さは経路内の辺の辺重みの和です。 もし辺に重みがない
     なら、辺はデフォルト重み1を持ちます。

     例:

          (%i1) load ("graphs")$
          (%i2) g: petersen_graph(20, 2)$
          (%i3) for e in edges(g) do set_edge_weight(e, random(1.0), g)$
          (%i4) shortest_weighted_path(0, 10, g);
          (%o4) [2.575143920268482, [0, 20, 38, 36, 34, 32, 30, 10]]

 -- 関数: strong_components (<gr>)
     有向グラフ <gr>の強成分を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) t : random_tournament(4)$
          (%i3) strong_components(t);
          (%o3)                 [[1], [0], [2], [3]]
          (%i4) vertex_out_degree(3, t);
          (%o4)                           3

 -- 関数: topological_sort (<dag>)

     Returns a topological sorting of the vertices of a directed graph 有
     向グラフ <dag>の頂点のトポロジカルソートを返します。 もし <dag>が有
     向無閉路グラフなら空のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g:create_graph(
                   [1,2,3,4,5],
                   [
                    [1,2], [2,5], [5,3],
                    [5,4], [3,4], [1,3]
                   ],
                   directed=true)$
          (%i3) topological_sort(g);
          (%o3)                    [1, 2, 5, 3, 4]

 -- 関数: vertex_connectivity (<g>)
     グラフ <g>の頂点連結性を返します。

     ‘min_vertex_cut’も参照してください。

 -- 関数: vertex_degree (<v>, <gr>)
     グラフ <gr>の頂点 <v>の次数を返します。

 -- 関数: vertex_distance (<u>, <v>, <gr>)
     (有向)グラフ <gr>の <u>と <v>の間の最短経路の長さを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) d : dodecahedron_graph()$
          (%i3) vertex_distance(0, 7, d);
          (%o3)                           4
          (%i4) shortest_path(0, 7, d);
          (%o4)                   [0, 1, 19, 13, 7]

 -- 関数: vertex_eccentricity (<v>, <gr>)

     グラフ <gr>の頂点 <v>の離心率を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) g:cycle_graph(7)$
          (%i3) vertex_eccentricity(0, g);
          (%o3)                           3

 -- 関数: vertex_in_degree (<v>, <gr>)
     有向グラフ <gr>の頂点 <v>の内次数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p5 : path_digraph(5)$
          (%i3) print_graph(p5)$
          Digraph on 5 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i4) vertex_in_degree(4, p5);
          (%o4)                           1
          (%i5) in_neighbors(4, p5);
          (%o5)                          [3]

 -- 関数: vertex_out_degree (<v>, <gr>)
     有向グラフ <gr>の頂点 <v>の外次数を返します。

     例:
          (%i1) load ("graphs")$
          (%i2) t : random_tournament(10)$
          (%i3) vertex_out_degree(0, t);
          (%o3)                           2
          (%i4) out_neighbors(0, t);
          (%o4)                        [7, 1]

 -- 関数: vertices (<gr>)
     グラフ <gr>の頂点のリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) vertices(complete_graph(4));
          (%o2)                     [3, 2, 1, 0]

 -- 関数: vertex_coloring (<gr>)
     グラフ <gr>の頂点の最適色付けを返します。

     関数は、彩色数と <gr>の頂点の色付けを表すリストを返します。

     例:
          (%i1) load ("graphs")$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                           [6, 1], [7, 1], [8, 2], [9, 2]]]

 -- 関数: wiener_index (<gr>)
     グラフ <gr>のWiener指数を返します。

     例:
          (%i2) wiener_index(dodecahedron_graph());
          (%o2)                          500

56.2.3 Modifying graphs
-----------------------

 -- 関数: add_edge (<e>, <gr>)
     辺 <e>をグラフ <gr>に加えます。

     例:
          (%i1) load ("graphs")$
          (%i2) p : path_graph(4)$
          (%i3) neighbors(0, p);
          (%o3)                          [1]
          (%i4) add_edge([0,3], p);
          (%o4)                         done
          (%i5) neighbors(0, p);
          (%o5)                        [3, 1]

 -- 関数: add_edges (<e_list>, <gr>)
     リスト <e_list>の中の辺すべてをグラフ <gr>に加えます。

     例:
          (%i1) load ("graphs")$
          (%i2) g : empty_graph(3)$
          (%i3) add_edges([[0,1],[1,2]], g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  1
            1 :  2  0
            0 :  1

 -- 関数: add_vertex (<v>, <gr>)
     頂点 <v>をグラフ <gr>に加えます。

     例:
          (%i1) load ("graphs")$
          (%i2) g : path_graph(2)$
          (%i3) add_vertex(2, g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 1 edges.
          Adjacencies:
            2 :
            1 :  0
            0 :  1

 -- 関数: add_vertices (<v_list>, <gr>)
     リスト <v_list>の中の頂点すべてをグラフ <gr>に加えます。

 -- 関数: connect_vertices (<v_list>, <u_list>, <gr>)
     グラフ <gr>に関して、 リスト <v_list>内の頂点すべてを リスト
     <u_list>内の頂点に連結します。

     <v_list>と <u_list>は1つの頂点か、頂点のリストを取り得ます。

     例:
          (%i1) load ("graphs")$
          (%i2) g : empty_graph(4)$
          (%i3) connect_vertices(0, [1,2,3], g)$
          (%i4) print_graph(g)$
          Graph on 4 vertices with 3 edges.
          Adjacencies:
            3 :  0
            2 :  0
            1 :  0
            0 :  3  2  1

 -- 関数: contract_edge (<e>, <gr>)
     グラフ <gr>の辺 <e>を縮約します。

     例:
          (%i1) load ("graphs")$
          (%i2) g: create_graph(
                8, [[0,3],[1,3],[2,3],[3,4],[4,5],[4,6],[4,7]])$
          (%i3) print_graph(g)$
          Graph on 8 vertices with 7 edges.
          Adjacencies:
            7 :  4
            6 :  4
            5 :  4
            4 :  7  6  5  3
            3 :  4  2  1  0
            2 :  3
            1 :  3
            0 :  3
          (%i4) contract_edge([3,4], g)$
          (%i5) print_graph(g)$
          Graph on 7 vertices with 6 edges.
          Adjacencies:
            7 :  3
            6 :  3
            5 :  3
            3 :  5  6  7  2  1  0
            2 :  3
            1 :  3
            0 :  3

 -- 関数: remove_edge (<e>, <gr>)
     グラフ <gr>から辺 <e>を削除します。

     例:
          (%i1) load ("graphs")$
          (%i2) c3 : cycle_graph(3)$
          (%i3) remove_edge([0,1], c3)$
          (%i4) print_graph(c3)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  0  1
            1 :  2
            0 :  2

 -- 関数: remove_vertex (<v>, <gr>)
     グラフ <gr>から頂点 <v>を削除します。

56.2.4 Reading and writing to files
-----------------------------------

 -- 関数: dimacs_export (<gr>, <fl>)
 -- 関数: dimacs_export (<gr>, <fl>, <comment1>, ..., <commentn>)

     グラフをファイル <fl>にDIMACSフォーマットでエクスポートします。 オ
     プションのコメントはファイルの頭に加えられます。

 -- 関数: dimacs_import (<fl>)

     DIMACSフォーマットのファイル <fl>からグラフを返します。

 -- 関数: graph6_decode (<str>)

     文字列 <str>にgraph6フォーマットで符号化されたグラフを返します。

 -- 関数: graph6_encode (<gr>)

     グラフ <gr>をgraph6フォーマットに符号化した文字列を返します。

 -- 関数: graph6_export (<gr_list>, <fl>)

     リスト <gr_list>内のグラフをファイル <fl>に graph6フォーマットでエ
     クスポートします。

 -- 関数: graph6_import (<fl>)

     graph6フォーマットのファイル <fl>からグラフのリストを返します。

 -- 関数: sparse6_decode (<str>)

     文字列 <str>にsparse6フォーマットで符号化されたグラフを返します。

 -- 関数: sparse6_encode (<gr>)

     グラフ <gr>をsparse6フォーマットに符号化した文字列を返します。

 -- 関数: sparse6_export (<gr_list>, <fl>)

     リスト <gr_list>内のグラフを ファイル <fl>にsparse6フォーマットでエ
     クスポートします。

 -- 関数: sparse6_import (<fl>)

     sparse6フォーマットのファイル <fl>からグラフのリストを返します。

56.2.5 Visualization
--------------------

 -- 関数: draw_graph (<graph>)
 -- 関数: draw_graph (<graph>, <option1>, ..., <optionk>)
     ‘draw’パッケージを使ってグラフを描画します。

     頂点を配置するのに使われるアルゴリズムは オプション引数 <program>で
     指定されます。 デフォルト値は ‘program=spring_embedding’です。
     <draw_graph>は 頂点を配置するのにgraphvizプログラムも使うことができ
     ますが、 graphvizを別途インストールしなければいけません。

     例 1:

          (%i1) load ("graphs")$
          (%i2) g:grid_graph(10,10)$
          (%i3) m:max_matching(g)$
          (%i4) draw_graph(g,
             spring_embedding_depth=100,
             show_edges=m, edge_type=dots,
             vertex_size=0)$

     例 2:

          (%i1) load ("graphs")$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) t:minimum_spanning_tree(g)$
          (%i4) draw_graph(
              g,
              show_edges=edges(t),
              show_edge_width=4,
              show_edge_color=green,
              vertex_type=filled_square,
              vertex_size=2
              )$

     例 3:

          (%i1) load ("graphs")$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) mi : max_independent_set(g)$
          (%i4) draw_graph(
              g,
              show_vertices=mi,
              show_vertex_type=filled_up_triangle,
              show_vertex_size=2,
              edge_color=cyan,
              edge_width=3,
              show_id=true,
              text_color=brown
              )$

     例 4:

          (%i1) load ("graphs")$
          (%i2) net : create_graph(
              [0,1,2,3,4,5],
              [
               [[0,1], 3], [[0,2], 2],
               [[1,3], 1], [[1,4], 3],
               [[2,3], 2], [[2,4], 2],
               [[4,5], 2], [[3,5], 2]
              ],
              directed=true
              )$
          (%i3) draw_graph(
              net,
              show_weight=true,
              vertex_size=0,
              show_vertices=[0,5],
              show_vertex_type=filled_square,
              head_length=0.2,
              head_angle=10,
              edge_color="dark-green",
              text_color=blue
              )$

     例 5:

          (%i1) load("graphs")$
          (%i2) g: petersen_graph(20, 2);
          (%o2)                         GRAPH
          (%i3) draw_graph(g, redraw=true, program=planar_embedding);
          (%o3)                         done

     例 6:

          (%i1) load("graphs")$
          (%i2) t: tutte_graph();
          (%o2)                         GRAPH
          (%i3) draw_graph(t, redraw=true,
                              fixed_vertices=[1,2,3,4,5,6,7,8,9]);
          (%o3)                         done

 -- オプション変数: draw_graph_program
     デフォルト値: <spring_embedding>

     頂点を配置するのに使われるプログラムのデフォルト値は ‘draw_graph’プ
     ログラムです。

 -- draw_graphオプション: show_id
     デフォルト値: <false>

     もし <true>なら頂点のidが表示されます。

 -- draw_graphオプション: show_label
     デフォルト値: <false>

     もし <true>なら頂点のラベルが表示されます。

 -- draw_graphオプション: label_alignment
     デフォルト値: <center>

     頂点のラベル/idをいかに整列させるか決めます。 ‘left’, ‘center’,
     ‘right’であり得ます。

 -- draw_graphオプション: show_weight
     デフォルト値: <false>

     もし <true>なら辺の重みを表示します。

 -- draw_graphオプション: vertex_type
     デフォルト値: <circle>

     頂点をいかに表示するか定義します。 可能な値に関しては、 ‘draw’パッ
     ケージの <point_type>オプションを参照してください。

 -- draw_graphオプション: vertex_size
     頂点のサイズ。

 -- draw_graphオプション: vertex_color
     頂点を表示するのに使う色。

 -- draw_graphオプション: show_vertices
     デフォルト値: []

     選択された頂点を異なる色を使って表示。

 -- draw_graphオプション: show_vertex_type

     <show_vertices>で指定された頂点をいかに表示するか定義します。 可能
     な値については、 ‘draw’パッケージの <point_type>オプションを参照し
     てください。

 -- draw_graphオプション: show_vertex_size
     <show_vertices>内の頂点のサイズ

 -- draw_graphオプション: show_vertex_color
     <show_vertices>リスト内の頂点を表示するのに使う色。

 -- draw_graphオプション: vertex_partition
     デフォルト値: []

     グラフの頂点の分割 ‘[[v1,v2,...],...,[vk,...,vn]]’ 分割内のそれぞれ
     のリストの頂点は異なる色で描画されます。

 -- draw_graphオプション: vertex_coloring
     頂点の色付けを指定します。 色付け <col>は <vertex_coloring>が返すよ
     うなフォーマットで指定されなければいけません。

 -- draw_graphオプション: edge_color
     辺を表示するのに使われる色。

 -- draw_graphオプション: edge_width
     辺の幅。

 -- draw_graphオプション: edge_type
     辺をいかに表示するか定義します。 ‘draw’パッケージの<line_type>オプ
     ションを参照してください。

 -- draw_graphオプション: show_edges
     異なる色を使ってリスト <e_list>内で指定された辺を表示する。

 -- draw_graphオプション: show_edge_color
     <show_edges>リスト内の辺を表示するのに使う色。

 -- draw_graphオプション: show_edge_width
     <show_edges>内の辺の幅。

 -- draw_graphオプション: show_edge_type
     <show_edges>内の辺を以下に表示するかを定義します。 ‘draw’パッケージ
     の<line_type>オプションを参照してください。

 -- draw_graphオプション: edge_partition
     グラフの辺の分割 ‘[[e1,e2,...],...,[ek,...,em]]’ 分割内のそれぞれの
     リストの辺は異なる色を使って描画されます。

 -- draw_graphオプション: edge_coloring
     辺の色付け。 色付けは 関数 <edge_coloring>が返すようなフォーマット
     で指定しなければいけません。

 -- draw_graphオプション: redraw
     デフォルト値: <false>

     もし ‘true’なら、 たとえ位置がグラフの以前の描画から保存されていて
     も頂点位置が再計算されます。

 -- draw_graphオプション: head_angle
     デフォルト値: 15

     (有向グラフの)弧に表示される矢印の角度。

 -- draw_graphオプション: head_length
     デフォルト値: 0.1

     (有向グラフの)弧に表示される矢印の長さ。

 -- draw_graphオプション: spring_embedding_depth
     デフォルト値: 50

     バネ埋め込みグラフ描画アルゴリズムでの繰り返し回数

 -- draw_graphオプション: terminal
     描画で使う端末。 (‘draw’パッケージの <terminal>オプションを参照して
     ください。)

 -- draw_graphオプション: file_name
     端末がスクリーンでないなら、描画のファイル名。

 -- draw_graphオプション: program
     グラフの頂点を配置するのに使われるプログラムを定義します。
     graphvizプログラム (dot, neato, twopi, circ, fdp)の1つ, <circular>,
     <spring_embedding>, <planar_embedding>を取り得ます。 2連結平面グラ
     フでは <planar_embedding>だけが利用可能です。
     ‘program=spring_embedding’の時、 固定位置の頂点の集合が
     <fixed_vertices>オプションで指定可能です。

 -- draw_graphオプション: fixed_vertices
     正多角形沿いに固定された位置を持つ頂点のリストを指定します。
     ‘program=spring_embedding’の時、使うことができます。

 -- 関数: vertices_to_path (<v_list>)
     頂点のリスト <v_list>を <v_list>で定義された経路の辺のリストに変換
     します。

 -- 関数: vertices_to_cycle (<v_list>)
     頂点のリスト <v_list>を <v_list>で定義された閉路の辺のリストに変換
     します。


File: maxima.info,  Node: grobner,  Next: impdiff,  Prev: graphs,  Up: Top

57 grobner
**********

* Menu:

* Introduction to grobner ::
* Functions and Variables for grobner ::


File: maxima.info,  Node: Introduction to grobner,  Next: Functions and Variables for grobner,  Prev: Top,  Up: Top

57.1 Introduction to grobner
============================

‘grobner’は MaximaでGroebner基底を使うためのパッケージです。

_Groebner基底_に関するチュートリアルは以下で見つかります。

<http://www.geocities.com/CapeCanaveral/Hall/3131/>

以下の関数を使うには、‘grobner.lisp’パッケージをロードしなければいけませ
ん。

     load("grobner");

     demo("grobner.demo");

もしくは
     batch("grobner.demo")
   でデモを開始することができます。

デモの中の計算のいくつかは長い時間かかります。 だから、デモの出力
‘grobner-demo.output’が デモファイルと同じディレクトリに見つかります。

57.1.1 Notes on the grobner package
-----------------------------------

パッケージは

Marek Rychlik

<http://alamos.math.arizona.edu>

によって書かれ、 General Public License(GPL)の条件の下、2002-05-24にリリ
ースされました。 (ファイル ‘grobner.lisp’を参照してください。) このドキ
ュメントは、 ファイル
‘README’, ‘grobner.lisp’, ‘grobner.demo’, ‘grobner-demo.output’
   から

Günter Nowakによって抽出されました。

   ドキュメントの改善に関する提案は _maxima_メーリングリスト
<maxima@math.utexas.edu>で議論することができます。 現在、コードは若干古
くなっています。 モダンな実装は 以下に記載されている高速の _F4_アルゴリ
ズムを使います。
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

57.1.2 Implementations of admissible monomial orders in grobner
---------------------------------------------------------------

   • ‘lex’

     純粋に辞書式の、 単項式比較のデフォルト順序
   • ‘grlex’

     全次数順序。同点は辞書式で決めます。

   • ‘grevlex’

     全次数。同点は逆辞書式で決めます。

   • ‘invlex’

     逆時書式順序。


File: maxima.info,  Node: Functions and Variables for grobner,  Prev: Introduction to grobner,  Up: Top

57.2 Functions and Variables for grobner
========================================

57.2.1 Global switches for grobner
----------------------------------

 -- オブション変数: poly_monomial_order
     デフォルト値: ‘lex’

     このグローバルスイッチは どの単項式順序が多項式とGroebner基底計算で
     使われるか制御します。 もし設定されないなら、 ‘lex’が使われます。

 -- オブション変数: poly_coefficient_ring
     デフォルト値: ‘expression_ring’

     このスイッチは grober計算で使われる多項式の係数環を示します。 もし
     設定されないなら、 _maximaの_ 一般式環が使われます。 もし望むなら、
     この変数を ‘ring_of_integers’に設定できます。

 -- オブション変数: poly_primary_elimination_order
     デフォルト値: ‘false’

     消去ベース関数で消去される変数のデフォルト順序名。 設定されていない
     なら、 ‘lex’が使われます。

 -- オブション変数: poly_secondary_elimination_order
     デフォルト値: ‘false’

     消去ベース関数で保持される変数のデフォルト順序名。 設定されていない
     なら、 ‘lex’が使われます。

 -- オブション変数: poly_elimination_order
     デフォルト値: ‘false’

     消去計算で使われるデフォルト消去順序名。 設定されているなら、 変数
     ‘poly_primary_elimination_order’と
     ‘poly_secondary_elimination_order’の設定を上書きします。 ユーザーは
     これが消去変数の数に有効な真の消去順序であることを保証しなければい
     けません。

 -- オブション変数: poly_return_term_list
     デフォルト値: ‘false’

     もし ‘true’に設定されているなら、 このパッケージの関数すべては
     _maxima_一般式ではなく、 それぞれの多項式を 現在の単項式順序で並べ
     た項のリストとして返します。

 -- オブション変数: poly_grobner_debug
     デフォルト値: ‘false’

     もし ‘true’に設定されているなら、 デバッグ用、トレース用出力を生成
     します。

 -- オブション変数: poly_grobner_algorithm
     デフォルト値: ‘buchberger’

     可能な値:
        • ‘buchberger’
        • ‘parallel_buchberger’
        • ‘gebauer_moeller’

     Groebner基底を見つけるのに使われるアルゴリズム名。

 -- オブション変数: poly_top_reduction_only
     デフォルト値: ‘false’

     もし ‘false’でないなら、 可能な時はいつでも、頭項簡約を使います。 頭
     項簡約は、割り算アルゴリズムが最初の簡約後に停止することを意味しま
     す。

57.2.2 Simple operators in grobner
----------------------------------

‘poly_add’, ‘poly_subtract’, ‘poly_multiply’, ‘poly_expt’は 多項式の算出
演算子です。 これらは 内部表現を使って実行されますが、 結果は _maxima_一
般形式に変換されます。

 -- 関数: poly_add (<poly1>, <poly2>, <varlist>)
     2つの多項式 <poly1>と <poly2>を足します。

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x

 -- 関数: poly_subtract (<poly1>, <poly2>, <varlist>)
     多項式 <poly1>から <poly2>を引きます。

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- 関数: poly_multiply (<poly1>, <poly2>, <varlist>)
     多項式 <poly1>と <poly2>の積を返します。

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- 関数: poly_s_polynomial (<poly1>, <poly2>, <varlist>)
     2つの多項式 <poly1>と <poly2>の _シジジー多項式_ (_S多項式_)を返し
     ます。

 -- 関数: poly_primitive_part (<poly1>, <varlist>)
     多項式 <poly1>を係数のGCDで割ったものを返します。

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- 関数: poly_normalize (<poly>, <varlist>)
     多項式 <poly1>を主係数で割ったものを返します。 割り算が可能であるこ
     とを仮定しています。 これは、体の場合には大丈夫ですが、環の場合には
     いつも可能なわけではありません。

57.2.3 Other functions in grobner
---------------------------------

 -- 関数: poly_expand (<poly>, <varlist>)
     この関数は 多項式を内部形式にパースします。 もし <poly>が多項式を正
     確にパースしたら、 それは ‘expand(<poly>)’と同値です。 もし表現が変
     数 <varlist>の多項式と互換性がないなら、 結果はエラーです。 式が正
     確に内部表現にパースするかテストするのに使うことができます。 以下の
     例は添字付き変数と超越関数変数が許されることを例示します。

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1

 -- 関数: poly_expt (<poly>, <number>, <varlist>)
     <poly>の、正の整数 <number>のべき乗を返します。 もし <number>が正の
     整数でないなら、 エラーが生じます。

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- 関数: poly_content (<poly>. <varlist>)
     ‘poly_content’は係数のGCDを抽出します。

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- 関数: poly_pseudo_divide (<poly>, <polylist>, <varlist>)
     多項式 <poly>を n個の多項式のリスト <polylist>で擬似的に割ります。
     複数の値を返します。 一番目の値は 商のリスト aです。 二番目の値は余
     り rです。 三番目の値は、 係数環(体である必要はありません)内で
     <polylist>がc*polyを割れるような スカラ係数 cです。 最後に 四番目の
     値は実行された簡約の回数です。 結果のオブジェクトは以下の等式を満た
     します:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- 関数: poly_exact_divide (<poly1>, <poly2>, <varlist>)
     多項式 <poly1>を多項式 <poly2>で割ります。 余りのない厳密な割り算が
     可能と仮定します。 商を返します。

 -- 関数: poly_normal_form (<poly>, <polylist>, <varlist>)
     ‘poly_normal_form’は 多項式の集合 <polylist>に関して 多項式 <poly>の
     正規形を見つけます。

 -- 関数: poly_buchberger_criterion (<polylist>, <varlist>)
     Buchberger判定(criterion)を使って もし <polylist>が現在の項順序に関
     して Groebner基底なら ‘true’を返します: Buchberger判定(criterion)は
     、 <polylist>の2つの多項式 h1と h2すべてに関して、 S多項式
     S(h1,h2)が <polylist>を法として0に簡約されるというものです。

 -- 関数: poly_buchberger (<polylist_fl> <varlist>)
     ‘poly_buchberger’は 多項式のリスト上でBuchbergerアルゴリズムを実行
     し、 結果の Groebner基底を返します。

57.2.4 Standard postprocessing of Groebner Bases
------------------------------------------------

K[ x[1],...,x[n] ]上のイデアル Iの _k番目の消去イデアル_ I_kは イデアル
intersect(I, K[ x[k+1],...,x[n] ])です。
_コロンイデアル_ I:Jは イデアル {h|for all w in J: w*h in I}です。.
イデアル I:p^infはイデアル {h| there is a n in N: p^n*h in I}です。
イデアル I:J^infはイデアル {h| there is a n in N and a p in J: p^n*h in
I}です。
The _根基イデアル_ sqrt(I)はイデアル {h| there is a n in N : h^n in I }で
す。

 -- 関数: poly_reduction (<polylist>, <varlist>)
     ‘poly_reduction’は多項式のリスト <polylist>を簡約します。 それぞれ
     の多項式は他の多項式で完全に簡約されます。

 -- 関数: poly_minimization (<polylist>, <varlist>)
     <polylist>と同じ単項式イデアルの最小全域である、 多項式リスト
     <polylist>の部分リストを返します。 すなわち、部分リストの中の多項式
     の主単項式はすべて、他の多項式の主単項式を割りません。

 -- 関数: poly_normalize_list (<polylist>, <varlist>)
     ‘poly_normalize_list’は ‘poly_normalize’をリストの中の多項式それぞ
     れに適用します。 これは リスト <polylist>の中のすべての多項式を主係
     数で割ることを意味します。

 -- 関数: poly_grobner (<polylist>, <varlist>)
     多項式リスト <polylist>で張られたイデアルのGroebner基底を返します。
     グローバルフラグで影響を受けます。

 -- 関数: poly_reduced_grobner (<polylist>, <varlist>)
     多項式リスト <polylist>で張られたイデアルの簡約Groebner基底を返しま
     す。

 -- 関数: poly_depends_p (<poly>, <var>, <varlist>)
     ‘poly_depends’は多項式が変数 <var>に依存するかテストします。

 -- 関数: poly_elimination_ideal (<polylist>, <number>, <varlist>)

     ‘poly_elimination_ideal’は、 (必ずしもGroebner基底である必要はない
     )生成多項式のリストとして指定されたイデアルの number番目の消去イデ
     アルの Groebner基底を返します。

 -- 関数: poly_colon_ideal (<polylist1>, <polylist2>, <varlist>)

     コロンイデアル

     I(polylist1):I(polylist2)

     の簡約Groebner基底を返します。

     ここで、 polylist1と polylist2は2つの多項式リストです。

 -- 関数: poly_ideal_intersection (<polylist1>, <polylist2>, <varlist>)

     ‘poly_ideal_intersection’は2つのイデアルの交わりです。

 -- 関数: poly_lcm (<poly1>, <poly2>, <varlist>)
     <poly1>と <poly2>の最小公倍数(式)を返します。

 -- 関数: poly_gcd (<poly1>, <poly2>, <varlist>)

     <poly1>と <poly2>の最大公約数(式)を返します。

     ‘ezgcd’, ‘gcd’, ‘gcdex’, ‘gcdivide’ も参照してください。

     例:

          (%i1) p1:6*x^3+19*x^2+19*x+6;
                                  3       2
          (%o1)                6 x  + 19 x  + 19 x + 6
          (%i2) p2:6*x^5+13*x^4+12*x^3+13*x^2+6*x;
                            5       4       3       2
          (%o2)          6 x  + 13 x  + 12 x  + 13 x  + 6 x
          (%i3) poly_gcd(p1, p2, [x]);
                                      2
          (%o3)                    6 x  + 13 x + 6

 -- 関数: poly_grobner_equal (<polylist1>, <polylist2>, <varlist>)
     ‘poly_grobner_equal’は 2つの Groebner基底が同じイデアルを生成するか
     テストします。 もし、Groebner基底と仮定された2つの多項式リスト
     <polylist1>と <polylist2>が 同じイデアルを生成するなら、‘true’を返
     します。 そうでないなら、 ‘false’を返します。 これは、 一番目の基底
     のすべての多項式が二番目の基底を法として0に簡約されるかとその逆をチ
     ェックする ことと同値です。 以下の例では、一番目のリストが
     Groebner基底でないので 結果が ‘false’であることに注意してください。

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false

 -- 関数: poly_grobner_subsetp (<polylist1>, <polylist2>, <varlist>)

     ‘poly_grobner_subsetp’は <polylist1>が生成するイデアルが
     <polylist2>が生成するイデアルに含まれるかテストします。 このテスト
     が常に成功するには、<polylist2>が Groebner基底でなければいけません
     。

 -- 関数: poly_grobner_member (<poly>, <polylist>, <varlist>)

     もし多項式 <poly>が Groebner基底であると仮定された多項式リスト
     <polylist>が生成するイデアルに属するなら、 ‘true’を返します。 そう
     でないなら、 ‘false’を返します。

     ‘poly_grobner_member’は 多項式が Groebner基底であると仮定された多項
     式のリストが生成するイデアルに属するかテストします。 ‘normal_form’が
     0と同値です。

 -- 関数: poly_ideal_saturation1 (<polylist>, <poly>, <varlist>)
     イデアル

     I(polylist):poly^inf のsaturationの簡約 Groebner基底を返します。

     幾何学的に、代数的閉体上で、 これは <poly>の多様体上で恒等的に0とな
     らない <polylist>が生成するイデアルの中の 多項式の集合です。

 -- 関数: poly_ideal_saturation (<polylist1>, <polylist2>, <varlist>)
     イデアル

     I(polylist1):I(polylist2)^inf のsaturationの簡約 Groebner基底を返し
     ます。

     幾何学的に、代数的閉体上で、 これは <polylist2>の多様体上で恒等的に
     0とならない <polylist1>が生成するイデアルの中の 多項式の集合です。

 -- 関数: poly_ideal_polysaturation1 (<polylist1>, <polylist2>,
          <varlist>)
     <polylist2>は2個の多項式のリスト ‘[poly1,...,polyn]’です。 多項式リ
     スト <polylist1>が生成するイデアルの 多項式リスト <polylist2>の多項
     式に関する連続saturationの列によって得られるイデアル

     I(polylist):poly1^inf:...:polyn^inf

     の簡約 Groebner基底を返します。

 -- 関数: poly_ideal_polysaturation (<polylist>, <polylistlist>,
          <varlist>)
     <polylistlist>は多項式リストn個のリスト
     ‘[polylist1,...,polylistn]’です。 イデアル

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf のsaturationの
     簡約 Groebner基底を返します。

 -- 関数: poly_saturation_extension (<poly>, <polylist>, <varlist1>,
          <varlist2>)

     ‘poly_saturation_extension’は有名な Rabinowitzのトリックを実装しま
     す。

 -- 関数: poly_polysaturation_extension (<poly>, <polylist>, <varlist1>,
          <varlist2>)


File: maxima.info,  Node: impdiff,  Next: implicit_plot,  Prev: grobner,  Up: Top

58 impdiff
**********

* Menu:

* Functions and Variables for impdiff::


File: maxima.info,  Node: Functions and Variables for impdiff,  Prev: impdiff,  Up: impdiff

58.1 Functions and Variables for impdiff
========================================

 -- 関数: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     このサブルーチンは多変数関数の陰導関数を計算します。 <f>は配列関数
     で、 インデックスは<indvarlist>順の微分の階数です; <indvarlist>は独
     立変数リストです; <orderlist>は望みの次数です; <depvar>は従属変数で
     す。

     この関数を使うには、最初に‘load("impdiff")’を書いてください。


File: maxima.info,  Node: implicit_plot,  Next: interpol,  Prev: impdiff,  Up: Top

59 implicit_plot
****************

* Menu:

* Functions and Variables for implicit_plot::


File: maxima.info,  Node: Functions and Variables for implicit_plot,  Prev: implicit_plot,  Up: implicit_plot

59.1 Functions and Variables for implicit_plot
==============================================

 -- 関数: implicit_plot (<expr>, <x_range>, <y_range>)
 -- 関数: implicit_plot ([<expr_1>, ..., <expr_n>], <x_range>,
          <y_range>)

     １つ以上の式のプロットを陰形式で表示します。 <expr>はプロットされる
     式で、 <x_range>は水平軸の範囲、 <y_range>は垂直軸の範囲です。
     ‘implicit_plot’は <set_plot_option>関数が設定するgnuplotドライバの
     グローバル設定を考慮します。 オプションはオプション引数として
     ‘implicit_plot’関数にも渡されることができます。

     ‘implicit_plot’は <x_range>と<y_range>で与えられる領域上で符号の変
     化を辿ることで機能し、 複雑な式では失敗する可能性があります。

     ‘load("implicit_plot")’はこの関数をロードします。

     例:
          (%i1) implicit_plot (x^2 = y^3 - 3*y + 1, [x, -4, 4], [y, -4, 4],
           [gnuplot_preamble, "set zeroaxis"]);


File: maxima.info,  Node: interpol,  Next: lapack,  Prev: implicit_plot,  Up: Top

60 interpol
***********

* Menu:

* Introduction to interpol::
* Functions and Variables for interpol::


File: maxima.info,  Node: Introduction to interpol,  Next: Functions and Variables for interpol,  Prev: interpol,  Up: interpol

60.1 Introduction to interpol
=============================

パッケージ‘interpol’は 多項式内挿のためのLagrange、線形、三次スプライン
法を定義します。

   コメント、バグ、提案は<’mario AT edu DOT xunta DOT es’>にコンタクトを
取ってください。


File: maxima.info,  Node: Functions and Variables for interpol,  Prev: Introduction to interpol,  Up: interpol

60.2 Functions and Variables for interpol
=========================================

 -- 関数: lagrange (<points>)
 -- 関数: lagrange (<points>, <option>)
     Lagrange法で多項式内挿を計算します。 引数 <points>は以下のいずれか
     でなければいけません:

        • 2列行列, ‘p:matrix([2,4],[5,6],[9,3])’,
        • 対のリスト, ‘p: [[2,4],[5,6],[9,3]]’,
        • 数のリスト, ‘p: [4,6,3]’, この場合、横座標は自動的に1, 2, 3な
          どに割り当てられます。

     最初の2つの場合には、 計算を行う前に、対は最初の座標に関して並び替
     えられます。

     <option>引数を使って、 独立変数の名前を選択することが可能です。 デ
     フォルトでは ‘'x’です; 別のものを定義するには、 ‘varname='z’のよう
     なものを書いてください。

     高次多項式を使って計算する時には、浮動小数点評価は不安定なことに注
     意してください。

     例:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                 (x - 7) (x - 6) (x - 3) (x - 1)
          (%o3)  -------------------------------
                               35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i4) f(x):=''%;
                         (x - 7) (x - 6) (x - 3) (x - 1)
          (%o4)  f(x) := -------------------------------
                                       35
             (x - 8) (x - 6) (x - 3) (x - 1)
           - -------------------------------
                           12
             7 (x - 8) (x - 7) (x - 3) (x - 1)
           + ---------------------------------
                            30
             (x - 8) (x - 7) (x - 6) (x - 1)
           - -------------------------------
                           60
             (x - 8) (x - 7) (x - 6) (x - 3)
           + -------------------------------
                           84
          (%i5) /* Evaluate the polynomial at some points */
                expand(map(f,[2.3,5/7,%pi]));
                                            4          3           2
                              919062  73 %pi    701 %pi    8957 %pi
          (%o5)  [- 1.567535, ------, ------- - -------- + ---------
                              84035     420       210         420
                                                       5288 %pi   186
                                                     - -------- + ---]
                                                         105       5
          (%i6) %,numer;
          (%o6) [- 1.567535, 10.9366573451538, 2.89319655125692]
          (%i7) load("draw")$  /* load draw package */
          (%i8) /* Plot the polynomial together with points */
                draw2d(
                  color      = red,
                  key        = "Lagrange polynomial",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i9) /* Change variable name */
                lagrange(p, varname=w);
                 (w - 7) (w - 6) (w - 3) (w - 1)
          (%o9)  -------------------------------
                               35
             (w - 8) (w - 6) (w - 3) (w - 1)
           - -------------------------------
                           12
             7 (w - 8) (w - 7) (w - 3) (w - 1)
           + ---------------------------------
                            30
             (w - 8) (w - 7) (w - 6) (w - 1)
           - -------------------------------
                           60
             (w - 8) (w - 7) (w - 6) (w - 3)
           + -------------------------------
                           84

 -- 関数: charfun2 (<x>, <a>, <b>)
     もし数 <x>が区間 [a, b)に属するなら、‘true’を返し、 そうでないなら
     、 ‘false’を返します。

 -- 関数: linearinterpol (<points>)
 -- 関数: linearinterpol (<points>, <option>)
     線形法で多項式内挿を計算します。 引数 <points>は以下のいずれかでな
     ければいけません:

        • 2列行列, ‘p:matrix([2,4],[5,6],[9,3])’,
        • 対のリスト, ‘p: [[2,4],[5,6],[9,3]]’,
        • 数のリスト, ‘p: [4,6,3]’, この場合、横座標は自動的に1, 2, 3な
          どに割り当てられます。

     最初の2つの場合には、 計算を行う前に、対は最初の座標に関して並び替
     えられます。

     <option>引数を使って、 独立変数の名前を選択することが可能です。 デ
     フォルトでは ‘'x’です; 別のものを定義するには、 ‘varname='z’のよう
     なものを書いてください。

     例:
          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7) load("draw")$  /* load draw package */
          (%i8)  /* Plot the polynomial together with points */
                 draw2d(
                   color      = red,
                   key        = "Linear interpolator",
                   explicit(f(x),x,-5,20),
                   point_size = 3,
                   color      = blue,
                   key        = "Sample points",
                   points(args(p)))$
          (%i9)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o9) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3

 -- 関数: cspline (<points>)
 -- 関数: cspline (<points>, <option1>, <option2>, ...)
     三次スプライン法で多項式内挿を計算します。 引数 <points>は以下のい
     ずれかでなければいけません:

        • 2列行列, ‘p:matrix([2,4],[5,6],[9,3])’,
        • 対のリスト, ‘p: [[2,4],[5,6],[9,3]]’,
        • 数のリスト, ‘p: [4,6,3]’, この場合、横座標は自動的に1, 2, 3な
          どに割り当てられます。

     最初の2つの場合には、 計算を行う前に、対は最初の座標に関して並び替
     えられます。

     特定の必要性に合わせるため3つのオプションがあります:
        • ‘'d1’, デフォルトは ‘'unknown’, は x_1での一階導関数です; もし
          ‘'unknown’なら、 x_1での二階導関数は0に等しいとされます(自然な
          三次スプライン); もし数字だったら、二階導関数はこの数字に基づ
          いて計算されます。

        • ‘'dn’, デフォルトは ‘'unknown’, は x_nでの一階導関数です; もし
          ‘'unknown’なら、 x_nでの二階導関数は0に等しいとされます(自然な
          三次スプライン); もし数字だったら、二階導関数はこの数字に基づ
          いて計算されます。

        • ‘'varname’, デフォルトは ‘'x’, は 独立変数の名前です。

     例:
          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) load("draw")$  /* load draw package */
          (%i7) /* Plotting interpolating function */
                draw2d(
                  color      = red,
                  key        = "Cubic splines",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i8) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o8)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                draw2d(
                  color      = black,
                  key        = "Cubic splines (default)",
                  explicit(f(x),x,0,10),
                  color      = red,
                  key        = "Cubic splines (d1=0,dn=0)",
                  explicit(g(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$

 -- 関数: ratinterpol (<points>, <numdeg>)
 -- 関数: ratinterpol (<points>, <numdeg>, <option1>, <option2>, ...)
     <points>で与えられたデータと<numdeg>に等しい分子の次数の関して、 有
     理形内挿を生成します; 分子の次数は自動的に計算されます。 引数
     <points>は以下のいずれかでなければいけません:

        • 2列行列, ‘p:matrix([2,4],[5,6],[9,3])’,
        • 対のリスト, ‘p: [[2,4],[5,6],[9,3]]’,
        • 数のリスト, ‘p: [4,6,3]’, この場合、横座標は自動的に1, 2, 3な
          どに割り当てられます。

     最初の2つの場合には、 計算を行う前に、対は最初の座標に関して並び替
     えられます。

     特定の必要性に合わせるため2つのオプションがあります:
        • ‘'denterm’, デフォルトは ‘1’, は 分子の中の多項式の独立項です
          。

        • ‘'varname’, デフォルトは ‘'x’, は 独立変数の名前です。

     例:

          (%i1) load("interpol")$
          (%i2) load("draw")$
          (%i3) p:[[7.2,2.5],[8.5,2.1],[1.6,5.1],[3.4,2.4],[6.7,7.9]]$
          (%i4) for k:0 thru length(p)-1 do
                  draw2d(
                    explicit(ratinterpol(p,k),x,0,9),
                    point_size = 3,
                    points(p),
                    title = concat("Degree of numerator = ",k),
                    yrange=[0,10])$


File: maxima.info,  Node: lapack,  Next: lbfgs,  Prev: interpol,  Up: Top

61 lapack
*********

* Menu:

* Introduction to lapack::
* Functions and Variables for lapack::


File: maxima.info,  Node: Introduction to lapack,  Next: Functions and Variables for lapack,  Prev: lapack,  Up: lapack

61.1 Introduction to lapack
===========================

‘lapack’は SLATECプロジェクトから得られるようなFortranライブラリLAPACKの
(プログラム ‘f2c’を介した) Common Lisp翻訳です。

   (訳者注意書き: lapackを使用するには、load("lapack");
load("eigensys");を実行してください。load("lapack")には、初回だけコンパ
イルで時間がかかるかもしれません。)


File: maxima.info,  Node: Functions and Variables for lapack,  Prev: Introduction to lapack,  Up: lapack

61.2 Functions and Variables for lapack
=======================================

 -- 関数: dgeev (<A>)
 -- 関数: dgeev (<A>, <right_p>, <left_p>)

     行列<A>の固有値と、オプションで固有ベクトルを計算します。 <A>の要素
     はすべて整数か浮動小数点数でなければいけません。 <A>は平方(行と列が
     同じ数)でなければいけません。 <A>は対称であってもなくてもいいです。

     ‘dgeev(<A>)’は<A>の固有値だけを計算します。 ‘dgeev(<A>, <right_p>,
     <left_p>)’は <A>の固有値と、 <right_p> = ‘true’の時、右固有ベクトル
     、 <left_p> = ‘true’の時、左固有ベクトルを計算します。

     3項目のリストが返されます。 最初の項目は固有値のリストです。 二番目
     の項目は‘false’か右固有ベクトルの行列です。 三番目の項目は‘false’か
     左固有ベクトルの行列です。

     右固有ベクトルv(j) (右固有ベクトル行列のj番目の列)は

     A . v(j) = lambda(j) . v(j)

     を満たします。ここでlambda(j)は対応する固有値です。

     左固有ベクトルv(j) (左固有ベクトル行列のj番目の列)は

     u(j)**H . A = lambda(j) . u(j)**H

     を満たします。ここでu(j)**Hはu(j)の共役転置を意味します。 Maxima関
     数‘ctranspose’が共役転置を計算します。

     計算された固有ベクトルは、 Euclideanノルムが1に等しく、 最大成分の
     虚部が0になるように規格化されます。

     例:

          (%i1) load ("lapack")$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M : matrix ([9.5, 1.75], [3.25, 10.45]);
                                   [ 9.5   1.75  ]
          (%o3)                    [             ]
                                   [ 3.25  10.45 ]
          (%i4) dgeev (M);
          (%o4)          [[7.54331, 12.4067], false, false]
          (%i5) [L, v, u] : dgeev (M, true, true);
                                     [ - .666642  - .515792 ]
          (%o5) [[7.54331, 12.4067], [                      ],
                                     [  .745378   - .856714 ]
                                                  [ - .856714  - .745378 ]
                                                  [                      ]]
                                                  [  .515792   - .666642 ]
          (%i6) D : apply (diag_matrix, L);
                                [ 7.54331     0    ]
          (%o6)                 [                  ]
                                [    0     12.4067 ]
          (%i7) M . v - v . D;
                          [      0.0       - 8.88178E-16 ]
          (%o7)           [                              ]
                          [ - 8.88178E-16       0.0      ]
          (%i8) transpose (u) . M - D . transpose (u);
                               [ 0.0  - 4.44089E-16 ]
          (%o8)                [                    ]
                               [ 0.0       0.0      ]

 -- 関数: dgeqrf (<A>)

     行列 <A>のQR分解します。 All elements of <A>のすべての要素は整数か
     浮動小数点数でなければいけません。 <A>は行と列の数は同じかもしれま
     せんし違うかもしれません。

     2つの項目のリストを返します。 一番目の項目は行列 <Q>で、それは<A>と
     同じ行数を持つ平方正規直交行列です。 二番目の項目は行列 <R>で、それ
     は<A>tお同じサイズで、 対角以下のすべての要素がが零に等しいものです
     。 積 ‘<Q> . <R>’は(浮動小数点の丸め誤差を除いて)<A>に等しい。 ここ
     で "."は非可換乗算演算子です。

          (%i1) load ("lapack") $
          (%i2) fpprintprec : 6 $
          (%i3) M : matrix ([1, -3.2, 8], [-11, 2.7, 5.9]) $
          (%i4) [q, r] : dgeqrf (M);
                 [ - .0905357  .995893  ]
          (%o4) [[                      ],
                 [  .995893    .0905357 ]
                                         [ - 11.0454   2.97863   5.15148 ]
                                         [                               ]]
                                         [     0      - 2.94241  8.50131 ]
          (%i5) q . r - M;
                   [ - 7.77156E-16   1.77636E-15   - 8.88178E-16 ]
          (%o5)    [                                             ]
                   [      0.0       - 1.33227E-15   8.88178E-16  ]
          (%i6) mat_norm (%, 1);
          (%o6)                      3.10862E-15

 -- 関数: dgesv (<A>, <b>)

     線形方程式 <A> <x> = <b>の 解 <x>を計算します。 ここで、 <A>は平方
     行列、 <b>は<A>と同じ数の行と任意の長さの列を持つ行列です。 戻り値
     <x>は <b>と同じサイズです。

     <A>と <b>の要素は ‘float’を介して実の浮動小数点数に評価されなければ
     いけません; 従って、要素は任意の数値型か、数値定数のシンボルか、 浮
     動小数点に評価される式であり得ます。 <x>の要素はいつも浮動小数点数
     です。 すべての算術は浮動小数演算として実行されます。

     ‘dgesv’は <A>のLU分解を介して 解を計算します。

     例:

     ‘dgesv’は 線形方程式 <A> <x> = <b>の解を計算します。

          (%i1) A : matrix ([1, -2.5], [0.375, 5]);
                                         [   1    - 2.5 ]
          (%o1)                          [              ]
                                         [ 0.375    5   ]
          (%i2) b : matrix ([1.75], [-0.625]);
                                            [  1.75   ]
          (%o2)                             [         ]
                                            [ - 0.625 ]
          (%i3) x : dgesv (A, b);
                                      [  1.210526315789474  ]
          (%o3)                       [                     ]
                                      [ - 0.215789473684211 ]
          (%i4) dlange (inf_norm, b - A.x);
          (%o4)                                 0.0

     <b>は<A>と同じ数の行と任意の長さの列を持つ行列です。 <x>は <b>と同
     じサイズです。

          (%i1) A : matrix ([1, -0.15], [1.82, 2]);
                                         [  1    - 0.15 ]
          (%o1)                          [              ]
                                         [ 1.82    2    ]
          (%i2) b : matrix ([3.7, 1, 8], [-2.3, 5, -3.9]);
                                        [  3.7   1    8   ]
          (%o2)                         [                 ]
                                        [ - 2.3  5  - 3.9 ]
          (%i3) x : dgesv (A, b);
                [  3.103827540695117   1.20985481742191    6.781786185657722  ]
          (%o3) [                                                             ]
                [ - 3.974483062032557  1.399032116146062  - 8.121425428948527 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                       1.1102230246251565E-15

     <A>と <b>の要素は 実の浮動小数点数に評価されなければいけません;

          (%i1) A : matrix ([5, -%pi], [1b0, 11/17]);
                                         [   5    - %pi ]
                                         [              ]
          (%o1)                          [         11   ]
                                         [ 1.0b0   --   ]
                                         [         17   ]
          (%i2) b : matrix ([%e], [sin(1)]);
                                            [   %e   ]
          (%o2)                             [        ]
                                            [ sin(1) ]
          (%i3) x : dgesv (A, b);
                                       [ 0.690375643155986 ]
          (%o3)                        [                   ]
                                       [ 0.233510982552952 ]
          (%i4) dlange (inf_norm, b - A . x);
          (%o4)                        2.220446049250313E-16

 -- 関数: dgesvd (<A>)
 -- 関数: dgesvd (<A>, <left_p>, <right_p>)

     特異値から成る行列 <A>の特異値分解(SVD)を計算します。 オプションで
     左および右特異ベクトルを取ります。

     <A>の要素はすべて整数か浮動小数点数でなければいけません。 <A>は(行
     と列が同じ数の)平方かもしれませんし、そうでないかもしれません。

     mを <A>の行数、nを列数とします。 <A>の特異値分解は <A> = <U> .
     <Sigma> . <V>^T のような3つの行列 <U>, <Sigma>, <V^T>から構成されま
     す。 ここで、 <U>は m掛けmのユニタリ行列、 <Sigma>は m掛けnの対角行
     列、 <V^T>は n掛けnのユニタリ行列です。

     sigma[i]を Sigmaの対角要素、すなわち、 <Sigma>[i, i] = <sigma>[i]と
     します。 要素 sigma[i]は <A>のいわゆる特異値です; これらは実数で、
     非負で、降順で返されます。 <U>と <V>の最初の min(m, n)列は <A>の左
     と右特異ベクトルです。 ‘dgesvd’は、<V>自身ではなく<V>の転置を返すこ
     とに注意してください。

     ‘dgesvd(<A>)’は <A>の特異値だけを計算します。 ‘dgesvd(<A>,
     <left_p>, <right_p>)’は <A>の特異値と、 <left_p> = ‘true’の時、左特
     異ベクトル、 <right_p> = ‘true’の時、右特異ベクトルを計算します。

     3つの項目のリストが返されます。 一つ目の項目は特異値のリストです。
     二つ目の項目は ‘false’か、左特異ベクトルの行列です。 三つ目の項目は
     ‘false’か、右特異ベクトルの行列です。

     例:

          (%i1) load ("lapack")$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M: matrix([1, 2, 3], [3.5, 0.5, 8], [-1, 2, -3], [4, 9, 7]);
                                  [  1    2    3  ]
                                  [               ]
                                  [ 3.5  0.5   8  ]
          (%o3)                   [               ]
                                  [ - 1   2   - 3 ]
                                  [               ]
                                  [  4    9    7  ]
          (%i4) dgesvd (M);
          (%o4)      [[14.4744, 6.38637, .452547], false, false]
          (%i5) [sigma, U, VT] : dgesvd (M, true, true);
          (%o5) [[14.4744, 6.38637, .452547],
          [ - .256731  .00816168   .959029    - .119523 ]
          [                                             ]
          [ - .526456   .672116   - .206236   - .478091 ]
          [                                             ],
          [  .107997   - .532278  - .0708315  - 0.83666 ]
          [                                             ]
          [ - .803287  - .514659  - .180867    .239046  ]
          [ - .374486  - .538209  - .755044 ]
          [                                 ]
          [  .130623   - .836799   0.5317   ]]
          [                                 ]
          [ - .917986   .100488    .383672  ]
          (%i6) m : length (U);
          (%o6)                           4
          (%i7) n : length (VT);
          (%o7)                           3
          (%i8) Sigma:
                  genmatrix(lambda ([i, j], if i=j then sigma[i] else 0),
                            m, n);
                            [ 14.4744     0        0    ]
                            [                           ]
                            [    0     6.38637     0    ]
          (%o8)             [                           ]
                            [    0        0     .452547 ]
                            [                           ]
                            [    0        0        0    ]
          (%i9) U . Sigma . VT - M;
                    [  1.11022E-15        0.0       1.77636E-15 ]
                    [                                           ]
                    [  1.33227E-15    1.66533E-15       0.0     ]
          (%o9)     [                                           ]
                    [ - 4.44089E-16  - 8.88178E-16  4.44089E-16 ]
                    [                                           ]
                    [  8.88178E-16    1.77636E-15   8.88178E-16 ]
          (%i10) transpose (U) . U;
                 [     1.0      5.55112E-17    2.498E-16     2.77556E-17  ]
                 [                                                        ]
                 [ 5.55112E-17      1.0       5.55112E-17    4.16334E-17  ]
          (%o10) [                                                        ]
                 [  2.498E-16   5.55112E-17       1.0       - 2.08167E-16 ]
                 [                                                        ]
                 [ 2.77556E-17  4.16334E-17  - 2.08167E-16       1.0      ]
          (%i11) VT . transpose (VT);
                    [      1.0           0.0      - 5.55112E-17 ]
                    [                                           ]
          (%o11)    [      0.0           1.0       5.55112E-17  ]
                    [                                           ]
                    [ - 5.55112E-17  5.55112E-17       1.0      ]

 -- 関数: dlange (<norm>, <A>)
 -- 関数: zlange (<norm>, <A>)

     行列 <A>のノルムもしくはノルムのような関数を計算します。

     ‘max’
          max(abs(A(i, j)))を計算します。 ここで iと jはそれぞれ行と列を
          行き渡ります。 この関数は適切な行列ノルムではないことに注意し
          てください。
     ‘one_norm’
          <A>の L[1]ノルム、 すなわち、それぞれの列の要素の絶対値の和の
          最大値 を計算します。
     ‘inf_norm’
          <A>の L[inf]ノルム、 すなわち、それぞれの行の要素の絶対値の和
          の最大値 を計算します。
     ‘frobenius’
          <A>のFrobeniusノルム、すなわち、 行列要素の平方の和の平方根 を
          計算します。

 -- 関数: dgemm (<A>, <B>)
 -- 関数: dgemm (<A>, <B>, <options>)
     2つの行列の積を計算します。オプションで積を三つ目の行列に足し算しま
     す。

     最も簡単な形式では、 ‘dgemm(<A>, <B>)’は 2つの実行列 <A>と <B>の積
     を計算します。

     二番目の形式では、 ‘dgemm’は <alpha> * <A> * <B> + <beta> * <C> を
     計算します。 ここで <A>, <B>, <C>は 適当なサイズの実行列であり、
     <alpha>と <beta>は実数です。 オプションで、 <A>と/もしくは <B>は 積
     を計算する前に転置を取ることができます。 追加のパラメータはオプショ
     ンのキーワード引数で指定できます: キーワード引数はオプションで、 ど
     んな順番でも指定できます。 それらはすべて、形式 ‘key=val’を取ります
     。 キーワード引数は以下の通りです:

     ‘C’
          足すべき行列 <C>。 デフォルトは ‘false’であり、行列を足さない
          ことを意味します。
     ‘alpha’
          <A>と <B>の積がこの値に掛けられます。 デフォルトは1です。
     ‘beta’
          もし行列 <C>が与えられたら、 この値は、足される前に<C>に掛けら
          れます。 デフォルト値は0で、これは, たとえ<C>が与えられても
          <C>が足されないことを意味します。 故に、必ず<beta>に零でない値
          を指定してください。
     ‘transpose_a’
          もし ‘true’なら、 <A>の代わりに<A>の転置が積に使われます。 デ
          フォルトは ‘false’です。
     ‘transpose_b’
          もし ‘true’なら <B>の代わりに<B>の転置が積に使われます。 デフ
          ォルトは ‘false’です。

          (%i1) load ("lapack")$
          (%i2) A : matrix([1,2,3],[4,5,6],[7,8,9]);
                                            [ 1  2  3 ]
                                            [         ]
          (%o2)                             [ 4  5  6 ]
                                            [         ]
                                            [ 7  8  9 ]
          (%i3) B : matrix([-1,-2,-3],[-4,-5,-6],[-7,-8,-9]);
                                         [ - 1  - 2  - 3 ]
                                         [               ]
          (%o3)                          [ - 4  - 5  - 6 ]
                                         [               ]
                                         [ - 7  - 8  - 9 ]
          (%i4) C : matrix([3,2,1],[6,5,4],[9,8,7]);
                                            [ 3  2  1 ]
                                            [         ]
          (%o4)                             [ 6  5  4 ]
                                            [         ]
                                            [ 9  8  7 ]
          (%i5) dgemm(A,B);
                                   [ - 30.0   - 36.0   - 42.0  ]
                                   [                           ]
          (%o5)                    [ - 66.0   - 81.0   - 96.0  ]
                                   [                           ]
                                   [ - 102.0  - 126.0  - 150.0 ]
          (%i6) A . B;
                                      [ - 30   - 36   - 42  ]
                                      [                     ]
          (%o6)                       [ - 66   - 81   - 96  ]
                                      [                     ]
                                      [ - 102  - 126  - 150 ]
          (%i7) dgemm(A,B,transpose_a=true);
                                   [ - 66.0  - 78.0   - 90.0  ]
                                   [                          ]
          (%o7)                    [ - 78.0  - 93.0   - 108.0 ]
                                   [                          ]
                                   [ - 90.0  - 108.0  - 126.0 ]
          (%i8) transpose(A) . B;
                                     [ - 66  - 78   - 90  ]
                                     [                    ]
          (%o8)                      [ - 78  - 93   - 108 ]
                                     [                    ]
                                     [ - 90  - 108  - 126 ]
          (%i9) dgemm(A,B,c=C,beta=1);
                                   [ - 27.0  - 34.0   - 41.0  ]
                                   [                          ]
          (%o9)                    [ - 60.0  - 76.0   - 92.0  ]
                                   [                          ]
                                   [ - 93.0  - 118.0  - 143.0 ]
          (%i10) A . B + C;
                                      [ - 27  - 34   - 41  ]
                                      [                    ]
          (%o10)                      [ - 60  - 76   - 92  ]
                                      [                    ]
                                      [ - 93  - 118  - 143 ]
          (%i11) dgemm(A,B,c=C,beta=1, alpha=-1);
                                      [ 33.0   38.0   43.0  ]
                                      [                     ]
          (%o11)                      [ 72.0   86.0   100.0 ]
                                      [                     ]
                                      [ 111.0  134.0  157.0 ]
          (%i12) -A . B + C;
                                         [ 33   38   43  ]
                                         [               ]
          (%o12)                         [ 72   86   100 ]
                                         [               ]
                                         [ 111  134  157 ]


File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: lapack,  Up: Top

62 lbfgs
********

* Menu:

* Introduction to lbfgs::
* Functions and Variables for lbfgs::


File: maxima.info,  Node: Introduction to lbfgs,  Next: Functions and Variables for lbfgs,  Prev: Top,  Up: Top

62.1 Introduction to lbfgs
==========================

‘lbfgs’はL-BFGS algorithm [1]の実装であり、 限定メモリ準ニュートン
(BFGS)アルゴリズムによって無制約な最小化問題を解きます。 Hessian行列の逆
元全体の代わりに低ランク近似が保存されるので、限定メモリと呼ばれます。 プ
ログラムは、 Jorge Nocedalによって、 Jorge J. MoréとDavid J. Thuenteが最
初に書いたいくつかの関数を組み入れて 最初、Fortranで書かれ、 プログラム
‘f2cl’によってLispに自動翻訳されました。

   Maximaパッケージ‘lbfgs’は翻訳されたコードと いくつかの詳細を扱うイン
ターフェース関数からなります。

   参考文献:

   [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
large scale optimization".  Mathematical Programming B 45:503–528 (1989)

   [2] <http://netlib.org/opt/lbfgs_um.shar>


File: maxima.info,  Node: Functions and Variables for lbfgs,  Prev: Introduction to lbfgs,  Up: Top

62.2 Functions and Variables for lbfgs
======================================

 -- 関数: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
 -- 関数: lbfgs ([<FOM>, <grad>], <X>, <X0>, <epsilon>, <iprint>)

     性能指標<FOM>の、 初期見積もり<X0>から始めて 変数リスト<X>上での、
     norm(grad(FOM)) < epsilon*max(1, norm(X))のような 無制約最小化の近
     似解を見つけます。

     もし与えられたなら、<grad>は<FOM>の多変数<X>に関する勾配です。
     <grad>は<X>の要素それぞれに対して1つの要素を持つリストです。 もし与
     えられなかったら、勾配は記号微分で自動的に計算されます。

     適用されるアルゴリズムは限定メモリ準Newton(BFGS)アルゴリズム [1]で
     す。 Hessian行列の逆元全体の代わりに低ランク近似が保存されるので、
     限定メモリと呼ばれます。 アルゴリズムのそれぞれの繰り返しは直線探索
     です。 すなわち、変数<X>に関して、近似Hessian逆元から計算される探索
     方向の線(ray)に沿っての探索です。 FOMはいつも直線探索でうまく減少し
     ます。 普通(しかしいつもではありません)FOMの勾配のノルムも減少しま
     す。

     <iprint>は‘lbfgs’が印字する進捗メッセージを制御します。

     ‘iprint[1]’
          ‘<iprint>[1]’ controls the frequency of progress messages.
          ‘iprint[1] < 0’
               進捗メッセージなし。
          ‘iprint[1] = 0’
               最初と最後の繰り返しでメッセージ。
          ‘iprint[1] > 0’
               毎‘<iprint>[1]’回の繰り返してメッセージを印字する。
     ‘iprint[2]’
          ‘<iprint>[2]’は進捗メッセージの量を制御します。
          ‘iprint[2] = 0’
               繰り返し回数、<FOM>の評価回数、<FOM>の値、<FOM>の勾配のノ
               ルム、ステップ長 を印字します。
          ‘iprint[2] = 1’
               ‘<iprint>[2] = 0’に加えて、 <X0>と<X0>で評価された<FOM>の
               勾配を印字します。
          ‘iprint[2] = 2’
               ‘<iprint>[2] = 1’に加えて、 繰り返しそれぞれで<X>の値を印
               字します。
          ‘iprint[2] = 3’
               ‘<iprint>[2] = 2’に加えて、 繰り返しそれぞれで<FOM>の勾配
               を印字します。

     ‘lbfgs’が印字する列は以下の通りです。

     ‘I’
          繰り返し関数。それぞれの直線探索で増えます。
     ‘NFN’
          性能指標の評価回数。
     ‘FUNC’
          最も最近の直線探索の最後での性能指標の値。
     ‘GNORM’
          最も最近の直線探索の最後での性能指標の勾配のノルム。
     ‘STEPLENGTH’
          探索アルゴリズムの内部パラメータ。

     アルゴリズムの詳細に関係する付加情報は、元々のFortranコード[2]のコ
     メントに見つけられます。

     ‘lbfgs_nfeval_max’と‘lbfgs_ncorrections’も参照してください。

     参考文献:

     [1] D. Liu and J. Nocedal.  "On the limited memory BFGS method for
     large scale optimization".  Mathematical Programming B 45:503–528
     (1989)

     [2] <http://netlib.org/opt/lbfgs_um.shar>

     例:

     NetlibからのLBFGSパッケージの中で、プログラムsdrive.f中、
     FGCOMPUTEが計算したのと同じFOM。 問題の変数が添字付き変数であること
     に注意してください。 FOMはu[k] = 1(k = 1, ..., 8)で0に等しい厳密な
     最小を持ちます。

          (%i1) load ("lbfgs");
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1],u[2],u[3],u[4],u[5],u[6],u[7],u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************
           I NFN   FUNC                    GNORM                   STEPLENGTH

           1   3   1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
           2   4   1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
           3   5   1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
           4   6   1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
           5   7   1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
           6   8   1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
           7   9   1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
           8  10   1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
           9  11   1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
          10  12   9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
          11  13   7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
          12  15   7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
          13  16   6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
          14  17   5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
          15  18   3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
          16  20   3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
          17  22   2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
          18  23   2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
          19  24   2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
          20  25   1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
          21  27   1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
          22  28   9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
          23  29   5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
          24  31   3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
          25  32   3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
          26  33   1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
          27  34   9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
          28  35   4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
          29  36   1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
          30  37   6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
          31  38   1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
          32  39   1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
          33  40   1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
          34  41   1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
          35  42   1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
          36  43   3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

     回帰問題。 FOMは、予言値F(X[i])と観測値Y[i]の二乗平均差です。 関数
     Fは有界な単調関数(いわゆる「シグモイド」函数)です。 この例では、Fの
     パラメータに関して‘lbfgs’は近似値を計算し、 ‘plot2d’はFの観測データ
     との比較を表示します。

          (%i1) load ("lbfgs");
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1,
                                                          length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

          I  NFN  FUNC                    GNORM                   STEPLENGTH
          1    3  1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
          2    6  2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
          3    8  1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
          4    9  7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
          5   10  7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
          6   11  6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
          7   12  5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
          8   13  5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
          9   14  5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)

     FOMの勾配が(自動的に計算される代わりに)指定されます。

          (%i1) load ("lbfgs")$
          (%i2) F(a, b, c) := (a - 5)^2 + (b - 3)^4 + (c - 2)^6;
                                         2          4          6
          (%o2)     F(a, b, c) := (a - 5)  + (b - 3)  + (c - 2)
          (%i3) F_grad : map (lambda ([x], diff (F(a, b, c), x)), [a, b, c]);
                                              3           5
          (%o3)          [2 (a - 5), 4 (b - 3) , 6 (c - 2) ]
          (%i4) estimates : lbfgs ([F(a, b, c), F_grad],
                                   [a, b, c], [0, 0, 0], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.700000000000000D+02   GNORM=  2.205175729958953D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    2     6.632967565917638D+01   6.498411132518770D+01   4.534785987412505D-03
             2    3     4.368890936228036D+01   3.784147651974131D+01   1.000000000000000D+00
             3    4     2.685298972775190D+01   1.640262125898521D+01   1.000000000000000D+00
             4    5     1.909064767659852D+01   9.733664001790506D+00   1.000000000000000D+00
             5    6     1.006493272061515D+01   6.344808151880209D+00   1.000000000000000D+00
             6    7     1.215263596054294D+00   2.204727876126879D+00   1.000000000000000D+00
             7    8     1.080252896385334D-02   1.431637116951849D-01   1.000000000000000D+00
             8    9     8.407195124830908D-03   1.126344579730013D-01   1.000000000000000D+00
             9   10     5.022091686198527D-03   7.750731829225274D-02   1.000000000000000D+00
            10   11     2.277152808939775D-03   5.032810859286795D-02   1.000000000000000D+00
            11   12     6.489384688303218D-04   1.932007150271008D-02   1.000000000000000D+00
            12   13     2.075791943844548D-04   6.964319310814364D-03   1.000000000000000D+00
            13   14     7.349472666162257D-05   4.017449067849554D-03   1.000000000000000D+00
            14   15     2.293617477985237D-05   1.334590390856715D-03   1.000000000000000D+00
            15   16     7.683645404048675D-06   6.011057038099201D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o4) [a = 5.000086823042934, b = 3.05239542970518,
                                                     c = 1.927980629919583]

 -- 変数: lbfgs_nfeval_max
     デフォルト値: 100

     ‘lbfgs_nfeval_max’は、‘lbfgs’がする性能指標(FOM)の評価の最大回数で
     す。 ‘lbfgs_nfeval_max’に届いた時、 ‘lbfgs’は最後に成功した直線探索
     の結果を返します。

 -- 変数: lbfgs_ncorrections
     デフォルト値: 25

     ‘lbfgs_ncorrections’は‘lbfgs’が保つ近似逆Hessian行列に適用された修
     正回数です。


File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

63 lindstedt
************

* Menu:

* Functions and Variables for lindstedt::


File: maxima.info,  Node: Functions and Variables for lindstedt,  Prev: lindstedt,  Up: lindstedt

63.1 Functions and Variables for lindstedt
==========================================

 -- 関数: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     これはLindstedtコードで最初のパスです。 摂動方程式上の初期条件が
     i>0に対して z[i]=0, z'[i]=0で、 入力した初期条件―(<%k1>と<%k2>だけ
     でなく)任意の定数があり得ます―で問題を解くことができます。 <ic>は初
     期条件のリストです。

     初期条件が与えられない時、 摂動方程式の中の定数がゼロ次方程式解と同
     じなので、問題が起こります。 また、Van der Pol方程式のように、摂動
     方程式の初期条件がi>0に対して z[i]=0, z'[i]=0でない時、問題が起こり
     ます。

     例:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     この関数を使うには、最初に‘load("makeOrders")’と
     ‘load("lindstedt")’を書いてください。


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

64 linearalgebra
****************

* Menu:

* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::


File: maxima.info,  Node: Introduction to linearalgebra,  Next: Functions and Variables for linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

64.1 Introduction to linearalgebra
==================================

‘linearalgebra’は線形代数に関する関数のコレクションです。

   例:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],
                        [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Functions and Variables for linearalgebra,  Prev: Introduction to linearalgebra,  Up: linearalgebra

64.2 Functions and Variables for linearalgebra
==============================================

 -- 関数: addmatrices (<f>, <M_1>, …, <M_n>)

     関数<f>を加算関数として使い、 行列<M_1>, …, <M_n>の和を返します。 関
     数<f>は任意の数の引数を受け付けなければいけません(Maxima n項関数)。

     例:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])

 -- 関数: blockmatrixp (<M>)

     <M>のエントリがすべて行列なら、その時に限って、 trueを返します。

 -- 関数: columnop (<M>, <i>, <j>, <theta>)

     もし<M>が行列なら、 列演算‘C_i <- C_i - <theta> * C_j’を施すことで
     生じる行列を返します。 もし<M>が行<i>か行<j>を持たないなら エラーを
     シグナルします。

 -- 関数: columnswap (<M>, <i>, <j>)

     もし <M>が行列なら、列 <i>と <j>を交換します。 もし <M>に列 <i>か
     <j>がないなら、 エラーをシグナルします。

 -- 関数: columnspace (<M>)

     もし <M>が行列なら、 ‘span (v_1, ..., v_n)’を返します。 ここで、集
     合 ‘{v_1, ..., v_n}’は <M>の列空間の基底です。 空集合の包は ‘{0}’で
     す。 従って、列空間が1員だけ持つ時、 ‘span ()’を返します。

 -- 関数: copy (<e>)

     Maxima式 <e>のコピーを返します。 <e>は任意のMaxima式であり得ますが
     、 <e>がリストか行列の時、 コピー関数はもっとも役立ちます; 以下を考
     えてください:

          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]

     同じ実験を試みましょう。 しかし、今回 <mm>を <m>のコピーとします。

          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]

     今回、 <mm>への割り当ては<m>の値を変えません。

 -- 関数: cholesky (<M>)
 -- 関数: cholesky (<M>, <field>)

     自己共役(すなわちHermite)行列のCholesky分解を返します。

     二番目の引数はデフォルトでは’generalring’です。 <field>の取り得る値
     の説明については ‘lu_factor’を参照してください。

 -- 関数: ctranspose (<M>)

     行列 <M>の複素共役転置を返します。 関数 ‘ctranspose’は それぞれの行
     列要素を転置するのに ‘matrix_element_transpose’を使います。

 -- 関数: diag_matrix (<d_1>, <d_2>,...,<d_n>)

     対角成分 <d_1>, <d_2>,...,<d_n>を持つ対角行列を返します。 対角成分
     が行列の時、 戻り値行列の零成分は 適切なサイズの零行列です; 例えば:

          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- 関数: dotproduct (<u>, <v>)

     ベクトル <u>と <v>の内積を返します。 これは‘conjugate (transpose
     (<u>)) . <v>’と同じです。 引数 <u>と <v>は列ベクトルでなければいけ
     ません。

 -- 関数: eigens_by_jacobi (<A>)
 -- 関数: eigens_by_jacobi (<A>, <field_type>)

     <A>の固有値と固有ベクトルを Jacobi回転法で計算します。 <A>は対称行
     列でなければいけません。 (しかし、正定値である必要も半正定値である
     必要もありません。) <field_type>は計算上の体を示し、‘floatfield’か
     ‘bigfloatfield’です。 もし <field_type>が指定されないなら、 デフォ
     ルトは ‘floatfield’です。

     <A>の要素は、数か、 (<field_type>に依存して)‘float’か ‘bfloat’を介
     して 数に評価される式でなければいけません。

     例:

          (%i1) S: matrix([1/sqrt(2), 1/sqrt(2)],[-1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]

 -- 関数: get_lu_factors (<x>)

     ‘<x> = lu_factor (<A>)’の時、 ‘get_lu_factors’は 形式 ‘[P, L, U]’の
     リストを返します。 ここで、 <P>は置換行列、 <L>は対角成分を含む下三
     角行列、 <U>は上三角行列であり、 ‘<A> = <P> <L> <U>’が成り立ちます
     。

 -- 関数: hankel (<col>)
 -- 関数: hankel (<col>, <row>)

     Hankel行列 <H>を返します。 <H>の最初の列は <col>です; 最初の成分を
     除いて、 <H>の最後の行は <row>です。 <row>のデフォルトは <col>と同
     じ長さを持つ零ベクトルです。

 -- 関数: hessian (<f>, <x>)

     変数 <x>のリストに関する <f>のHessian行列を返します。 Hessian行列の
     ‘(i, j)’成分は ‘diff(<f>, <x>[i], 1, <x>[j], 1)’です。

     例:

          (%i1) hessian (x * sin (y), [x, y]);
                               [   0       cos(y)   ]
          (%o1)                [                    ]
                               [ cos(y)  - x sin(y) ]
          (%i2) depends (F, [a, b]);
          (%o2)                       [F(a, b)]
          (%i3) hessian (F, [a, b]);
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [  ---   ----- ]
                                  [    2   da db ]
                                  [  da          ]
          (%o3)                   [              ]
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [ -----   ---  ]
                                  [ da db     2  ]
                                  [         db   ]

 -- 関数: hilbert_matrix (<n>)

     <n>掛け<n>のHilbert行列を返します。 <n>が正の整数でない時、エラーを
     シグナルします。

 -- 関数: identfor (<M>)
 -- 関数: identfor (<M>, <fld>)

     行列 <M>と同じ形を持つ単位行列を返します。 単位行列の対角成分は体
     <fld>の乗算単位元です; <fld>のデフォルトは <generalring>です。

     一番目の引数 <M>は平方行列か非行列でなければいけません。 <M>が行列
     の時、 <M>のそれぞれの成分は平方行列であり得ます。 – 従って、 <M>は
     区分されたMaxima行列であり得ます。 行列は、任意の(有限の)深さに区分
     できます。

     ‘zerofor’も参照してください。

 -- 関数: invert_by_lu (<M>, <(rng generalring)>)

     LU分解を使って、 行列 <M>の逆行列を返します。 LU分解は環 <rng>を使
     って実行されます。

 -- 関数: jacobian (<f>, <x>)

     変数のリスト <x>に関する 関数のリスト <f>のJacobi行列を返します。
     Jacobi行列の ‘(i, j)’成分は ‘diff(<f>[i], <x>[j])’です。

     例:

          (%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                            [ cos(v - u)  - cos(v - u) ]
          (%o1)             [                          ]
                            [ v cos(u v)   u cos(u v)  ]
          (%i2) depends ([F, G], [y, z]);
          (%o2)                  [F(y, z), G(y, z)]
          (%i3) jacobian ([F, G], [y, z]);
                                     [ dF  dF ]
                                     [ --  -- ]
                                     [ dy  dz ]
          (%o3)                      [        ]
                                     [ dG  dG ]
                                     [ --  -- ]
                                     [ dy  dz ]

 -- 関数: kronecker_product (<A>, <B>)

     行列 <A>と <B>のKronecker積を返します。

 -- 関数: listp (<e>, <p>)
 -- 関数: listp (<e>)

     オプションの引数 <p>が与えられたとして、 もし <e>がMaximaリストで、
     <p>がすべてのリストの要素で ‘true’に評価されるなら、 ‘true’を返しま
     す。 ‘listp’がオプションの引数を与えられない時、 もし <e>がMaximaリ
     ストなら、 ‘true’を返します。 他のすべての場合、 ‘false’を返します
     。

 -- 関数: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)

     一番目の引数は行列でなければいけません; 引数 <r_1>から <c_2>は 行
     <r_1>から <r_2>と列 <c_1>から <c_2>から成る <M>の部分行列を決定しま
     す。

     ある性質を満たす部分行列 <M>の中の成分を見つけます。 3つのケース:

     (1) ‘<rel> = 'bool’で <f>が述語論理:

     左から右へ、そして上から下へ部分行列をスキャンし、 述語論理 <f>を満
     たす最初の成分のインデックスを返します。 もし <f>を満たす行列成分が
     ないなら、 ‘false’を返します。

     (2) ‘<rel> = 'max’で <f>が実関数:

     <f>を最大にする成分を探して部分行列をスキャンします。 最大化の成分
     のインデックスを返します。

     (3) ‘<rel> = 'min’で <f>が実関数:

     <f>を最小にする成分を探して部分行列をスキャンします。 最小化の成分
     のインデックスを返します。

 -- 関数: lu_backsub (<M>, <b>)

     ‘<M> = lu_factor (<A>, <field>)’の時、 ‘lu_backsub (<M>, <b>)’は 線
     形系 ‘<A> <x> = <b>’を解きます。

 -- 関数: lu_factor (<M>, <field>)

     形式 ‘[<LU>, <perm>, <fld>]’か ‘[<LU>, <perm>, <fld>, <lower-cnd>
     <upper-cnd>]’ のリストを返します。 ここで、

     (1) 行列 <LU>は<M>の分解をパックされた形式で含みます。 パックされた
     形式は3つのことを意味します; 第一に <LU>の行はリスト <perm>に従って
     置換されます。 もし、例えば、 <perm>がリスト ‘[3,2,1]’なら、 <LU>分
     解の実際の一番目の行は行列 <LU>の三番目の行です。 第二に、mの下三角
     因子はすべて1で置き換えられた対角成分を持つ <LU>の下三角部です。 第
     三に、 <M>の上三角因子は <LU>の上三角部です。

     (2) 体が ‘floatfield’か ‘complexfield’の時、 数 <lower-cnd>と
     <upper-cnd>は <M>の無限ノルム条件数の下限と上限です。 すべての体に
     対して条件数を見積ることができるわけではありません; そんな体に対し
     ては ‘lu_factor’は2項目リストを返します。 下限と上限どちらも真の値
     から任意に大きな因子だけ異なる可能性があります。 (‘mat_cond’も参照
     してください。)

     引数 <M>は平方行列でなければいけません。

     オプション引数 <fld>は環か体かを決めるシンボルでなければいけません
     。 予め定義された体と環は以下のものがあります:

     (a) ‘generalring’ – Maxima式の環, (b) ‘floatfield’ – 倍精度浮動小数
     点数体, (c) ‘complexfield’ – 倍精度浮動小数点複素数体, (d)
     ‘crering’ – Maxima CRE式の環, (e) ‘rationalfield’ – 有理数体, (f)
     ‘runningerror’ – 浮動小数点の丸め誤差をトラック, (g)
     ‘noncommutingring’ – 乗算が非可換ドット演算子のMaxima式の環

     体が ‘floatfield’か ‘complexfield’、‘runningerror’のいずれかの時、
     アルゴリズムは部分ピボットを使います; 他のすべての体に対しては、 零
     ピボットを避ける必要があるときだけ、行がスイッチされます。

     浮動小数点加算算術は結合的でなく、 ’体’の意味は数学的定義と異なりま
     す。

     体 ‘runningerror’の要素は 形式 ‘[x,n]’の2つの要素のMaximaリストです
     。 ここで、 <x>は浮動小数点数で、 ‘n’は整数です。 ‘x’の’真’の値と
     ‘x’の相対差は 計算機イプシロンに ‘n’をかけたもので近似的に抑えられ
     ます。 The running error bound drops some terms that of the order
     the square of the machine epsilon.

     新しい体を定義するユーザーインターフェースはありません。 Common
     Lispに精通しているユーザーは新しい体を定義することができるはずです
     。 これをするには、ユーザーは算術演算のための関数と 体表現と
     Maximaの相互変換のための関数を定義しなければいけません。 さらに、
     (部分ピボットが使われる)順序体に関しては、 ユーザーは大きさの関数と
     体の元の比較関数を定義しなければいけません。 あとは、Common Lisp 構
     造体 ‘mring’を定義することだけです。 ファイル ‘mring’に多くの例があ
     ります。

     分解を計算するために、 最初の仕事は 行列成分それぞれを指定された体
     の元に変換することです。 変換が不可能な時は、分解はエラーメッセージ
     とともに停止します。 体の元はMaxima式である必要はありません。 例え
     ば、‘complexfield’の元はCommon Lisp複素数です。 そして、分解を計算
     した後には、行列成分はMaxima式に変換されなければいけません。

     ‘get_lu_factors’も参照してください。

     例:

          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9)  [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]

 -- 関数: mat_cond (<M>, 1)
 -- 関数: mat_cond (<M>, inf)

     行列 <m>の<p>-ノルムの行列条件数を返します。 <p>に許される値は1と
     <inf>です。 この関数は、行列 <m>の逆元を計算するのにLU分解を使いま
     す。 このため、‘mat_cond’の実行時間は行列サイズの三乗に比例します;
     ‘lu_factor’は、 行列サイズの二乗に比例する時間内に 無限大ノルム条件
     数の下限と上限を決定します。

 -- 関数: mat_norm (<M>, 1)
 -- 関数: mat_norm (<M>, inf)
 -- 関数: mat_norm (<M>, frobenius)

     行列 <M>の行列 <p>-ノルムを返します。 .  The allowed values for
     <p>に許される値は1か ‘inf’か ‘frobenius’ (Frobenius行列ノルム)です
     。 行列 <M>は区分されない行列でなければいけません。

 -- 関数: matrixp (<e>, <p>)
 -- 関数: matrixp (<e>)

     オプション引数 <p>が与えられたとして、 もし <e>が行列で、 <p>が行列
     成分すべてに対して ‘true’に評価されるなら、 ‘true’を返します。
     ‘matrixp’がオプション引数を与えられない時は、 もし ‘e’が行列なら、
     ‘true’を返します。 他のすべての場合には、 ‘false’を返します。

     ‘blockmatrixp’も参照してください。

 -- 関数: matrix_size (<M>)

     行列 <M>の行数と列数をそれぞれ与える2要素リストを返します。

 -- 関数: mat_fullunblocker (<M>)

     もし <M>が区分行列なら、 行列をすべてのレベルで区分解除します。 も
     し <M>が行列なら、 <M>を返します; それ以外ではエラーをシグナルしま
     す。

 -- 関数: mat_trace (<M>)

     行列 <M>の跡を返します。 もし <M>が行列でないなら、名詞形を返します
     。 <M>が区分行列の時、 ‘mat_trace(M)’は
     ‘mat_trace(mat_unblocker(m))’するのと同じ値を返します。

 -- 関数: mat_unblocker (<M>)

     もし <M>が区分行列なら、 <M>を1レベル区分解除します。 もし <M>が行
     列なら、 ‘mat_unblocker (M)’は <M>を返します; それ以外ではエラーを
     シグナルします。

     このように、 もし <M>の成分それぞれが行列なら、 ‘mat_unblocker
     (M)’は区分されていない行列を返しますが、 もし <M>の成分それぞれが区
     分行列なら、 ‘mat_unblocker (M)’は 区分が1レベル少ない区分行列を返
     します。

     もし区分行列を使うなら、 おそらく、 ‘matrix_element_mult’を ‘"."’に
     、 ‘matrix_element_transpose’を ‘'transpose’に設定したくなるでしょ
     う。 ‘mat_fullunblocker’も参照してください。

     例:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]

 -- 関数: nullspace (<M>)

     もし <M>が行列なら、 ‘span (v_1, ..., v_n)’を返します。 ここで、,
     where the set 集合 ‘{v_1, ..., v_n}’は <M>の零空間の基底です。 空集
     合のスパンは ‘{0}’です。 なので、零空間が要素を1つだけ持つときは、
     ‘span ()’を返します。

 -- 関数: nullity (<M>)

     もし <M>が行列なら、 <M>の零空間の次元を返します。

 -- 関数: orthogonal_complement (<v_1>, ..., <v_n>)

     ‘span (u_1, ..., u_m)’を返します。 ここで、, where the se 集合
     ‘{u_1, ..., u_m}’は 集合 ‘(v_1, ..., v_n)’の直交補空間の基底です。

     ベクトル <v_1>から <v_n>それぞれは列ベクトルでなければいけません。

 -- 関数: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- 関数: polynomialp (<p>, <L>, <coeffp>)
 -- 関数: polynomialp (<p>, <L>)

     もし <p>がリスト <L>の中の変数に関して多項式なら、 ‘true’を返します
     。 述語論理 <coeffp>は係数それぞれに対して ‘true’に評価されなければ
     いけなく、 述語論理 <exponp>は <L>の中の変数の指数すべてに対して
     ‘true’に評価されなければいけません。 もし <exponp>に対してデフォル
     トでない値を使いたいなら、 たとえ<coeffp>に関してデフォルトを使いた
     くても <coeffp>を値とともに供給しなければいけません。

     ‘polynomialp (<p>, <L>, <coeffp>)’は ‘polynomialp (<p>, <L>,
     <coeffp>, 'nonnegintegerp)’に同値です。

     ‘polynomialp (<p>, <L>)’は ‘polynomialp (<p>, L<,> 'constantp,
     'nonnegintegerp)’に同値です。

     多項式は展開される必要はありません:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     coeffpとexponpにデフォルトでない値を使う例:

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp,
                                                                  numberp);
          (%o2)                         true

     2変数多項式:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true

 -- 関数: polytocompanion (<p>, <x>)

     もし <p>が <x>の多項式なら、 <p>のコンパニオン行列を返します。 次数
     <n>のモニック多項式(最高次数の係数が1の多項式)に対しては、 ‘<p> =
     (-1)^<n> charpoly (polytocompanion (<p>, <x>))’. があります。

     <p>が <x>の多項式でないなら、エラーをシグナルします。

 -- 関数: ptriangularize (<M>, <v>)

     もし <M>がそれぞれの成分が<v>の多項式の行列なら、 以下のような行列
     <M2>を返します。

     (1) <M2>は上三角で、

     (2) ‘<M2> = <E_n> ... <E_1> <M>’, ここで、 <E_1>から <E_n>は成分が
     <v>の多項式の基本行列です。

     (3) ‘|det (<M>)| = |det (<M2>)|’,

     注意: この関数はすべての成分が<v>の多項式かチェックしません。

 -- 関数: rowop (<M>, <i>, <j>, <theta>)

     もし <M>が行列なら、 行演算 ‘R_i <- R_i - theta * R_j’をすることで
     生じる 行列を返します。 もし <M>に行<i>か <j>がないなら、 エラーを
     シグナルします。

 -- 関数: rank (<M>)

     行列 <M>の階数を返します。 階数は列空間の次元です。

     例:
          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o2)                                  2

 -- 関数: rowswap (<M>, <i>, <j>)

     もし <M>が行列なら、行 <i>と <j>を入れ替えます。 もし <M>に行<i>か
     <j>がないなら、エラーをシグナルします。

 -- 関数: toeplitz (<col>)
 -- 関数: toeplitz (<col>, <row>)

     Toeplitz行列 <T>を返します。 <T>の一番目の列は <col>です; 一番目の
     成分を除いて、 <T>の最初の行は <row>です。 <row>のデフォルトは
     <col>の複素共役です。

     例:
          (%i1)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]

 -- 関数: vandermonde_matrix ([<x_1>, ..., <x_n>])

     <i>番目の行が‘[1, <x_i>, <x_i>^2, ... <x_i>^(<n>-1)]’の <n>掛け
     <n>行列を返します。

 -- 関数: zerofor (<M>)
 -- 関数: zerofor (<M>, <fld>)

     行列 <M>と同じ形の零行列を返します。 零行列の成分すべては体 <fld>の
     加算の単位元です; <fld>のデフォルトは <generalring>です。

     一番目の引数 <M>は 平方行列か行列以外でなければいけません。 <M>が行
     列の時、 <M>の成分それぞれは平方行列であり得ます。 – 従って <M>は区
     分Maxima行列であり得ます。 行列は任意の(有限の)深さに区分できます。

     ‘identfor’も参照してください。

 -- 関数: zeromatrixp (<M>)

     <M>が区分行列でない時、 もし行列 <M>のそれぞれの要素 <e>に対して
     ‘is (equal (<e>, 0))’が真なら、 ‘true’を返します。 <M>が区分行列の
     時、 もし<e>の要素それぞれに対して ‘zeromatrixp’が ‘true’に評価され
     るなら、 ‘true’を返します。


File: maxima.info,  Node: lsquares,  Next: minpack,  Prev: linearalgebra,  Up: Top

65 lsquares
***********

* Menu:

* Introduction to lsquares::
* Functions and Variables for lsquares::


File: maxima.info,  Node: Introduction to lsquares,  Next: Functions and Variables for lsquares,  Prev: lsquares,  Up: lsquares

65.1 Introduction to lsquares
=============================

‘lsquares’は 数値データからモデルのパラメータを見積もる 最小二乗法を実装
するための関数のコレクションです。


File: maxima.info,  Node: Functions and Variables for lsquares,  Prev: Introduction to lsquares,  Up: lsquares

65.2 Functions and Variables for lsquares
=========================================

 -- 関数: lsquares_estimates (<D>, <x>, <e>, <a>)
 -- 関数: lsquares_estimates (<D>, <x>, <e>, <a>, initial = <L>, tol =
          <t>)

     最小二乗の方法で決定されるような 変数<x>と<a>の方程式<e>を データ
     <D>に最良フィットする パラメータ<a>を見積もります。
     ‘lsquares_estimates’は最初に厳密な解を探し、 それが失敗したら、近似
     的な解を探します。

     戻り値は 形式 ‘[a = ..., b = ..., c = ...]’の等式のリストのリストで
     す。 リストのそれぞれの要素は 二乗平均誤差の、個別の等価な最小です
     。

     データ <D>は行列でなければいけません。 行それぞれは(文脈によって「
     レコード」とか「ケース」とか呼ばれる)1つのデータで、 列それぞれは す
     べてのデータに関するある変数の値を含みます。 変数のリスト <x>は
     <D>の列それぞれの名前を与えます。 解析をしない列にも名前を与えます
     。

     パラメータのリスト <a>は 見積もられるパラメータの名前を与えます。 方
     程式 <e>は変数 <x>と <a>に関する式か等式です; もし <e>が等式でない
     なら、 ‘<e> = 0’と同様に扱われます。

     ‘lsquares_estimates’の付加引数は 等式として指定され、 厳密な結果が
     見つからなかった時 数値方法で見積もりを見つけるためにコールされる関
     数 ‘lbfgs’へそのまま渡されます。

     もしある厳密解が(‘solve’を介して)見つけることができるなら、 データ
     <D>は非数値を含むかもしれません。 しかし、もし厳密解が見つからない
     なら、 <D>の要素それぞれは数値でなければいけません。 これは 数リテ
     ラル(整数、有理数、通常の浮動小数点、多倍長浮動小数点)はもちろん、
     ‘%pi’や‘%e’のような数値定数を含みます。 数値計算は通常の浮動小数点
     算出で実行されます。 他の種類の数値は計算のため、すべて通常の浮動小
     数点に変換されます。

     ‘load("lsquares")’はこの関数をロードします。

     ‘lsquares_estimates_exact’, ‘lsquares_estimates_approximate’,
     ‘lsquares_mse’, ‘lsquares_residuals’, ‘lsquares_residual_mse’も参照
     してください。

     例:

     厳密解が見つかる問題。

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                  [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) lsquares_estimates (
                   M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32

     厳密解が見つからない問題。 だから ‘lsquares_estimates’は数値近似に
     頼ります。

          (%i1) load ("lsquares")$
          (%i2) M : matrix ([1, 1], [2, 7/4], [3, 11/4], [4, 13/4]);
                                             [ 1  1  ]
                                             [       ]
                                             [    7  ]
                                             [ 2  -  ]
                                             [    4  ]
                                             [       ]
          (%o2)                              [    11 ]
                                             [ 3  -- ]
                                             [    4  ]
                                             [       ]
                                             [    13 ]
                                             [ 4  -- ]
                                             [    4  ]
          (%i3) lsquares_estimates (
            M, [x,y], y=a*x^b+c, [a,b,c], initial=[3,3,3], iprint=[-1,0]);
          (%o3) [[a = 1.387365874920637, b = .7110956639593767,
                                                  c = - .4142705622439105]]

 -- 関数: lsquares_estimates_exact (<MSE>, <a>)

     方程式系を構成し、‘solve’を介して記号的にそれらを解くことを試みるこ
     とで、 平均二乗誤差 <MSE>を最小化する パラメータ <a>を見積もります
     。 平均二乗誤差は ‘lsquares_mse’が返すような パラメータ <a>の式です
     。

     戻り値は 形式 ‘[a = ..., b = ..., c = ...]’の等式のリストのリストで
     す。 戻り値は、0個か1個、2以上の要素を含むかもしれません。 もし複数
     の要素が返されたら、 それぞれは個別の、平均二乗誤差の等価最小を表し
     ます。

     ‘lsquares_estimates’, ‘lsquares_estimates_approximate’,
     ‘lsquares_mse’,
     ‘lsquares_residuals’, ‘lsquares_residual_mse’も参照してください。

     例:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_exact (mse, [A, B, C, D]);
                            59        27      10921        107
          (%o4)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32

 -- 関数: lsquares_estimates_approximate (<MSE>, <a>, initial = <L>, tol
          = <t>)

     平均二乗誤差 <MSE>を最小化する パラメータ <a>を 数値最小化関数
     ‘lbfgs’を介して 見積もります。 平均二乗誤差は、 ‘lsquares_mse’が返
     すようなパラメータ <a>の式です。

     ‘lsquares_estimates_approximate’が返す解は 平均二乗誤差の(たぶん大
     域ですが)局所最小値です。 ‘lsquares_estimates_exact’との一貫性のた
     め、 戻り値は 要素1つ、すなわち、形式 ‘[a = ..., b = ..., c =
     ...]’の等式のリスト を持つ入れ子のリストです。

     ‘lsquares_estimates_approximate’の付加引数は 等式として指定され、 数
     値方法で見積もりを見つけるためにコールされる関数 ‘lbfgs’へそのまま
     渡されます。

     パラメータが数値が割り当てられた時 <MSE>はは数に評価されなければい
     けません。 これは This requires that the data from which <MSE>が構
     成されるデータが ‘%pi’や‘%e’、 数リテラル(整数、有理数、通常の浮動
     小数点、多倍長浮動小数点) のような数値定数を含みます。 数値計算は通
     常の浮動小数点算出で実行されます。 他の種類の数値は計算のため、すべ
     て通常の浮動小数点に変換されます。

     ‘load("lsquares")’はこの関数をロードします。

     ‘lsquares_estimates’, ‘lsquares_estimates_exact’, ‘lsquares_mse’,
     ‘lsquares_residuals’, ‘lsquares_residual_mse’も参照してください。

     例:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_approximate (
                        mse, [A, B, C, D], iprint = [-1, 0]);
          (%o4) [[A = - 3.67850494740174, B = - 1.683070351177813,
                           C = 10.63469950148635, D = - 3.340357993175206]]

 -- 関数: lsquares_mse (<D>, <x>, <e>)

     平均二乗誤差 (MSE)、 変数 <x>の 方程式<e>に関する データ <D>の和の
     式を返します。

     MSEは以下のように定義されます:

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     ここで、 <n>はデータ数で、 ‘<e>[i]’は、 ‘i’番目のデータ ‘<D>[i]’か
     ら値を割り当てられた <x>の中の変数に対して評価された方程式 <e>です
     。

     ‘load("lsquares")’はこの関数をロードします。

     例:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) diff (mse, D);
                   5
                  ====
                  \                             2
                4  >    (D + M    ) ((D + M    )  - C - M     B - M     A)
                  /           i, 1         i, 1          i, 3      i, 2
                  ====
                  i = 1
          (%o4) ----------------------------------------------------------
                                            5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5

 -- 関数: lsquares_residuals (<D>, <x>, <e>, <a>)

     指定されたパラメータ <a>とデータ <D>での 方程式 <e>に関する残差を返
     します。

     <D>は行列で、 <x>は変数のリスト、 <e>は方程式か一般式です; もし方程
     式でないなら、 <e>は ‘<e> = 0’であるかのように扱われます。 <a>は
     <x>を除いた<e>の任意の自由変数に値を指定する 方程式のリストです。

     残差は以下のように定義されます:

                                  lhs(e ) - rhs(e )
                                       i         i

     ここで、 ‘<e>[i]’は、 <a>から任意の残りの自由変数を割り当てて、
     ‘i’番目のデータ ‘<D>[i]’から値を割り当てられた <x>の中の変数に対し
     て評価された方程式 <e>です。

     ‘load("lsquares")’はこの関数をロードします。

     例:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32
          (%i4) lsquares_residuals (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, first(a));
                                      13    13    13  13  13
          (%o4)                      [--, - --, - --, --, --]
                                      64    64    32  64  64

 -- 関数: lsquares_residual_mse (<D>, <x>, <e>, <a>)

     指定されたパラメータ <a>とデータ <D>での 方程式 <e>に関する残差平均
     二乗誤差を返します。

     残差MSEは以下のように定義されます:

                              n
                             ====
                         1   \                        2
                         -    >    (lhs(e ) - rhs(e ))
                         n   /           i         i
                             ====
                             i = 1

     ここで、 ‘<e>[i]’は、 <a>から任意の残りの自由変数を割り当てて、
     ‘i’番目のデータ ‘<D>[i]’から値を割り当てられた <x>の中の変数に対し
     て評価された方程式 <e>です。

     ‘load("lsquares")’はこの関数をロードします。

     例:

          (%i1) load ("lsquares")$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                       M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);

                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residual_mse (
                       M, [z,x,y], (z + D)^2 = A*x + B*y + C, first (a));
                                        169
          (%o4)                         ----
                                        2560

 -- 関数: plsquares (<Mat>,<VarList>,<depvars>)
 -- 関数: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- 関数: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     「最小二乗」法によるデータ表の多変数多項式調整。 <Mat>はデータを含
     む行列であり、 <VarList>は変数名(Mat列それぞれの名前ですが、Mat列を
     無視する際には変数名の代わりに"-")のリストであり、 <depvars>は従属
     変数の名前か、 従属変数の1つ以上の名前(その名前<VarList>の中になけ
     ればいけません)のリストであり、 <maxexpon>はオプションの、独立変数
     それぞれの最大指数(デフォルト1)であり、 <maxdegree>はオプションの最
     大多項式次数(デフォルトで<maxexpon>)です; それぞれの項の指数の和は
     <maxdegree>以下でなければいけないことに注意してください。 もし
     ‘maxdgree = 0’なら制限は適用されません。

     もし <depvars>が(リストではなく)従属変数の名前なら、 ‘plsquares’は
     調整された多項式を返します。 もし <depvars>が1つ以上の従属変数のリ
     ストなら、 ‘plsquares’は調整された多項式のリストを返します。 適合度
     について知らせるために 決定係数が表示されます。 それは0 (無相関)か
     ら1 (厳密相関)までの範囲です。 これらの値は グローバル変数
     <DETCOEF>(もし <depvars>がリストならリスト)にも保管されます。

     多変数線形調整の簡単な例:
          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     次数制限のない同じ例:
          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     N面ポリゴンは何本の対角線を持ちますか？ いくつの多項式次数を使うべ
     きですか？
          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonals],diagonals,5);
               Determination Coefficient for diagonals = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonals = --------
                                            2
          (%i5) ev(%, N=9);   /* Testing for a 9 sides polygon */
          (%o5)                 diagonals = 27

     何通りの方法でn掛けnのチェス盤に2つのクィーンを取られないように置け
     ますか？
          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,positions],[positions],4);
               Determination Coefficient for [positions] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [positions = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testing for a (8 x 8) chessboard */
          (%o7)                positions = 1288

     6つの従属変数を持つ例:
          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     この関数を使うには、 最初に ‘load("lsquares")’を書いてください。


File: maxima.info,  Node: minpack,  Next: makeOrders,  Prev: lsquares,  Up: Top

66 minpack
**********

* Menu:

* Introduction to minpack::
* Functions and Variables for minpack::


File: maxima.info,  Node: Introduction to minpack,  Next: Functions and Variables for minpack

66.1 Introduction to minpack
============================

‘Minpack’は Netlibから得られるFortranライブラリ MINPACKの (‘f2cl’を介し
た)Common Lisp翻訳です。


File: maxima.info,  Node: Functions and Variables for minpack,  Prev: Introduction to minpack

66.2 Functions and Variables for minpack
========================================

 -- 関数: minpack_lsquares
          minpack_lsquares (<flist>, <varlist>, <guess>)
          minpack_lsquares (..., 'tolerance = <tolerance>)
          minpack_lsquares (..., 'jacobian = <jacobian>)

     リスト <flist>の関数の平方の和を最小化する 点を計算します。 変数は
     リスト <varlist>の中にあります。 最適点の初期推測は<guess>で供給さ
     れなければいけません

     オプションのキーワード引数 <tolerance>と <jacobian>は アルゴリズム
     上のある制御を提供します。 <tolerance>は平方の和に関する相対誤差を
     見積もられます。 <jacobian>はJacobianを指定するのにつかうことができ
     ます。 もし <jacobian>が与えられず、l (デフォルト)‘true’ なら、
     <flist>から計算されます。 もし <jacobian>が ‘false’なら数値近似が使
     われます。

     ‘minpack_lsquares’はリストを返します。 最初の項目は見積もられた解で
     す; 二番目は平方の和で， 三番目はアルゴリズムの成功を示します。 可
     能な値は以下の通りです。

     ‘0’
          不適切な入力パラメータ。
     ‘1’
          アルゴリズムが平方の和の相対誤差がせいぜい‘tolerance’と見積も
          ります。
     ‘2’
          アルゴリズムがxと解の相対誤差がせいぜい ‘tolerance’と見積もり
          ます。
     ‘3’
          info = 1と info = 2の条件が両方とも成立します。
     ‘4’
          fvec が機械精度のjacobianの列に直交的です。
     ‘5’
          iflag = 1が100*(n+1)に至るfcnへのコールの回数
     ‘6’
          tolが小さすぎます。平方の和の更なる減少は不可能です。
     ‘7’
          tolが小さすぎます。近似解xの更なる改善は不可能です。

          /* Problem 6: Powell singular function */
          (%i1) powell(x1,x2,x3,x4) :=
                   [x1+10*x2, sqrt(5)*(x3-x4), (x2-2*x3)^2,
                        sqrt(10)*(x1-x4)^2]$
          (%i2) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1]);
          (%o2) [[1.652117596168394e-17, - 1.652117596168393e-18,
                  2.643388153869468e-18, 2.643388153869468e-18],
                 6.109327859207777e-34, 4]

          /* Same problem but use numerical approximation to Jacobian */
          (%i3) minpack_lsquares(powell(x1,x2,x3,x4), [x1,x2,x3,x4],
                                 [3,-1,0,1], jacobian = false);
          (%o3) [[5.060282149485331e-11, - 5.060282149491206e-12,
                  2.179447843547218e-11, 2.179447843547218e-11],
                 3.534491794847031e-21, 5]

 -- 関数: minpack_solve
          minpack_solve (<flist>, <varlist>, <guess>)
          minpack_solve (..., 'tolerance = <tolerance>)
          minpack_solve (..., 'jacobian = <jacobian>)

     ‘n’個の未知数に関する ‘n’個の方程式系を解きます。 ‘n’個の方程式形が
     リスト <flist>で 与えられます。 解の初期推測は<guess>の中で提供され
     ます。

     オプションのキーワード引数、 <tolerance>と <jacobian>は アルゴリズ
     ム上のある制御を提供します。 <tolerance>は、平方の和に関して宣言さ
     れた見積もられた相対誤差です。 <jacobian>はJacobianを指定するのに使
     うことができます。 もし<jacobian>が与えらないか、‘true’(デフォルト
     )なら、 Jacobianを<flist>から計算します。 もし<jacobian>が‘false’な
     ら、数値近似が使われます。

     ‘minpack_solve’はリストを返します。 最初の項は見積もられた解です; 最
     初のエスティマート解であることが解されます。 最初の解が、最初の項は
     未つられた解と一緒なranmpolが渡り気味。 リストを返します。 評価され
     た解の最初の案件はリストを返します。

     ‘0’
          不適切な入力パラメータ。
     ‘1’
          アルゴリズムが解の相対誤差がせいぜい‘tolerance’と見積もります
          。
     ‘2’
          iflag = 1でfcnをコールした回数が100*(n+1)に達しました。
     ‘3’
          tolが小さ過ぎます。平方和の中で換算がこれ以上不可能です。
     ‘4’
          繰り返しがよい進捗を産んでいません。


File: maxima.info,  Node: makeOrders,  Next: mnewton,  Prev: minpack,  Up: Top

67 makeOrders
*************

* Menu:

* Functions and Variables for makeOrders::


File: maxima.info,  Node: Functions and Variables for makeOrders,  Prev: makeOrders,  Up: makeOrders

67.1 Functions and Variables for makeOrders
===========================================

 -- 関数: makeOrders (<indvarlist>,<orderlist>)
     引数までの多項式のべきすべてのリストを返します。

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     ここで、 ‘[0, 1]’は項bに関連づけられ、 ‘[2, 3]’はa^2 b^3に関連づけ
     られます。

     この関数を使うには、最初に‘load("makeOrders")’を書いてください。


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: makeOrders,  Up: Top

68 mnewton
**********

* Menu:

* Introduction to mnewton::
* Functions and Variables for mnewton::


File: maxima.info,  Node: Introduction to mnewton,  Next: Functions and Variables for mnewton,  Prev: mnewton,  Up: mnewton

68.1 Introduction to mnewton
============================

‘mnewton’は １変数または多変数の非線形方程式を解くための Newton法の実装
です。


File: maxima.info,  Node: Functions and Variables for mnewton,  Prev: Introduction to mnewton,  Up: mnewton

68.2 Functions and Variables for mnewton
========================================

 -- オプション変数: newtonepsilon
     デフォルト値: ‘10.0^(-fpprec/2)’

     ‘mnewton’関数が解に向かって収束した時を決定する精度。 もし
     ‘newtonepsilon’が多倍長浮動小数点なら、‘mnewton’計算は多倍長浮動小
     数点でされます。 ‘mnewton’も参照してください。

 -- オプション変数: newtonmaxiter
     デフォルト値: ‘50’

     もし収束しないか収束が遅すぎるなら ‘mnewton’関数を止める繰り返しの
     最大数。

     ‘mnewton’も参照してください。

 -- 関数: mnewton (<FuncList>,<VarList>,<GuessList>)

     Newton法を使った複数非線形関数の解。 <FuncList>は解くべき関数のリス
     ト、 <VarList>は変数名のリスト、 <GuessList>は初期近似のリストです
     。

     解は ‘solve()’が返すのと同じフォーマットで返されます。 もし解が見つ
     からないなら、‘[]’が返されます。

     この関数は グローバル変数‘newtonepsilon’と‘newtonmaxiter’によって制
     御されます。

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     変数‘newtonepsilon’は近似の精度を制御します。 それはまた、計算が浮
     動小数点で実行されるか、多倍長浮動小数点で実行されるかを制御します
     。

          (%i1) (load("mnewton"), fpprec : 25, newtonepsilon : bfloat(10^(-fpprec+5)))$

          (%i2) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o2) [[u = 1.066618389595406772591173b0, v = 1.552564766841786450100418b0]]

     この関数を使うためには、最初に‘load("mnewton")’を書いてください。
     ‘newtonepsilon’と‘newtonmaxiter’も参照してください。


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

69 numericalio
**************

* Menu:

* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::


File: maxima.info,  Node: Introduction to numericalio,  Next: Functions and Variables for plain-text input and output,  Prev: numericalio,  Up: numericalio

69.1 Introduction to numericalio
================================

‘numericalio’は ファイルやストリームを読み書きする関数のコレクションです
。 プレインテキスト入出力のための関数は、 数(整数、浮動小数点、多倍長浮
動小数点)やシンボル、文字列を読み書きできます。 バイナリ入出力のための関
数は、 浮動小数点数だけを読み書きできます。

   もし既に入力データを記憶すべきリスト、行列、配列オブジェクトがあるな
ら、 ‘numericalio’入力関数群はデータをそのオブジェクトに書き込むことがで
きます。 そうでなければ、 ‘numericalio’はデータを記憶するオブジェクトの
構造をある程度推測し、 そのオブジェクトを返します。

69.1.1 Plain-text input and output
----------------------------------

プレインテキスト入出力では、 読み書きする項目それぞれがアトムであること
が仮定されます: 整数、浮動小数点数、多倍長浮動小数点、文字列、シンボルで
あり、 有理数や複素数や他のどんなアトムでない式でもありません。
‘numericalio’関数群は、アトムでない式に直面した時、 何か適当なことを試み
るかもしれませんが、 結果はここで規定されず、変更の対象となります。

   入力ファイルと出力ファイルどちらのアトムも、 Maximaバッチファイルや対
話コンソールでのものと同じフォーマットを持ちます。 特に、文字列はダブル
クォートで括られ、 バックスラッシュ‘\’は次の文字の任意の特殊解釈を抑制し
、 クエスチョンマーク‘?’は (Maximaシンボルではなく、)Lispシンボルを意味
するシンボルの始まりとして認識されます。 (分割された行をつなぎ合わせる
)いかなる継続文字も認識されません。

69.1.2 Separator flag values for input
--------------------------------------

プレインテキスト入出力のための関数は、オプションの引数<separator_flag> を
取ります。 それはどの文字がデータを分離するかを示します。

   プレインテキスト入力では、 <separator_flag>の以下の値が認識されます:
コンマで区切られた値のための‘comma’、 垂直バー文字‘|’で区切られた値のた
めの‘pipe’、 セミコロン‘;’で区切られた値のための‘semicolon’、 空白かタブ
文字で区切られた値のための‘space’。 もしファイル名が‘.csv’で終わり、
<separator_flag>が指定されていないなら、 ‘comma’が仮定されます。 もしフ
ァイル名が‘.csv’以外の何かで終わり、 ‘separator_flag’が指定されていない
なら、 ‘space’が仮定されます。

   プレインテキスト入力では、 複数続く空白とタブ文字は1つの区切り文字と
して数えられます． しかしながら、複数のコンマ、パイプまたはセミコロンは
意味を持ちます。 連続するコンマ、パイプ、セミコロン文字は (空白やタブが
間に入ろうが入るまいが) 区切り文字の間に‘false’を持つと見なされます。 例
えば、‘1234,,Foo’は ‘1234,false,Foo’と同じと扱われます。

69.1.3 Separator flag values for output
---------------------------------------

プレインテキスト出力では、 ‘comma’, ‘pipe’, ‘semicolon’, そして‘space’は
もちろん、 タブ文字で区切られた値のための‘tab’も、 <separator_flag>の値
として認識されます。

   プレインテキスト出力では、 ‘false’アトムは以下のように書かれます: リ
スト‘[1234, false, Foo]’は‘1234,false,Foo’と書かれ、 出力を‘1234,,Foo’に
つぶすことはありません。

69.1.4 Binary floating-point input and output
---------------------------------------------

‘numericalio’関数群は8バイトIEEE754浮動小数点数を読み書きすることができ
ます。 これらの数は、 ‘assume_external_byte_order’で設定されたグローバル
フラグに従って、 最下位バイトから順でも最上位バイトから順でも記憶するこ
とができます。

   もし指定されないなら、 ‘numericalio’は外部バイト順は最上位バイトから
と仮定します。

   他の種類の数は8バイト浮動小数点に強制変換されます; ‘numericalio’はア
トムでないバイナリデータを読み書きできません。

   いくつかのLisp実装は IEEE 754の特殊値(正負の無限大、非数値、指数表現
でない数)を認識しません。 ‘numericalio’でそんな値を読み込むことの効果は
未定義です。

   ‘numericalio’は バイトストリームを読んだり書いたりするためのストリー
ムを開く 関数を含みます。


File: maxima.info,  Node: Functions and Variables for plain-text input and output,  Next: Functions and Variables for binary input and output,  Prev: Introduction to numericalio,  Up: numericalio

69.2 Functions and Variables for plain-text input and output
============================================================

 -- 関数: read_matrix (<S>)
 -- 関数: read_matrix (<S>, <M>)
 -- 関数: read_matrix (<S>, <separator_flag>)
 -- 関数: read_matrix (<S>, <M>, <separator_flag>)

     ‘read_matrix(<S>)’は、 ソース<S>を読み込み、行列として内容全体を返
     します。 行列のサイズは入力データから推論されます; ファイルの行それ
     ぞれは行列の1行になります。 もし複数の行が異なる長さを持つなら、
     ‘read_matrix’はエラーを出力します。

     ‘read_matrix(<S>, <M>)’は、 <M>が一杯になるか、ソースが尽きるまで、
     ソース<S>を行列<M>に読み込みます。 入力データは行優先順に行列に読み
     込まれます; 入力は<M>と同じ行数と列数を持つ必要はありません。

     ソース<S>はファイル名かストリームかもしれません。

     <separator_flag>の認識される値は ‘comma’, ‘pipe’, ‘semicolon’,
     ‘space’です。 もし<separator_flag>が指定されないなら、ファイルは空
     白で区切られていると仮定されます。

 -- 関数: read_array (<S>, <A>)
 -- 関数: read_array (<S>, <A>, <separator_flag>)

     <A>が一杯になるか、ソースが尽きるまで、 ソース<S>を配列<A>に読み込
     みます。 入力データは列優先順に配列に読み込まれます; 入力は<A>の次
     元に一致する必要はありません。

     ソース<S>はファイル名かストリームかもしれません。

     <separator_flag>の認識される値は ‘comma’, ‘pipe’, ‘semicolon’,
     ‘space’です。 もし<separator_flag>が指定されないなら、ファイルは空
     白で区切られていると仮定されます。

 -- 関数: read_hashed_array (<S>, <A>)
 -- 関数: read_hashed_array (<S>, <A>, <separator_flag>)

     ソース<S>が読み込まれ、ハッシュ配列として内容全体が返されます。 ソ
     ース<S>はファイル名かストリームかもしれません。

     ‘read_hashed_array’は、 それぞれの行の最初の項目をハッシュキーとし
     て扱い、 行の残りを(リストとして)キーと結合します。 例えば、 行‘567
     12 17 32 55’は ‘A[567]: [12, 17, 32, 55]$’と同値です。 行数は要素数
     と同じである必要はありません。

     <separator_flag>の認識される値は ‘comma’, ‘pipe’, ‘semicolon’,
     ‘space’です。 もし<separator_flag>が指定されないなら、ファイルは空
     白で区切られていると仮定されます。

 -- 関数: read_nested_list (<S>)
 -- 関数: read_nested_list (<S>, <separator_flag>)

     ソース<S>を読み込み、 入れ子のリストとして内容全体を返します。 ソー
     ス<S>はファイル名かストリームかもしれません。

     ‘read_nested_list’は 入力のそれぞれの行について部分リストを持つリス
     トを返します。 行数は要素数と同じである必要はありません。 空の行は
     無視されません: 空の行は空の部分リストをもたらします。

     <separator_flag>の認識される値は ‘comma’, ‘pipe’, ‘semicolon’,
     ‘space’です。 もし<separator_flag>が指定されないなら、ファイルは空
     白で区切られていると仮定されます。

 -- 関数: read_list (<S>)
 -- 関数: read_list (<S>, <L>)
 -- 関数: read_list (<S>, <separator_flag>)
 -- 関数: read_list (<S>, <L>, <separator_flag>)

     ‘read_list(<S>)’は、 ソース<S>を読み込み、 フラットなリストとして内
     容全体を返します。

     ‘read_list(<S>, <L>)’は、 <L>が一杯になるかソースが尽きるまで、 ソ
     ース<S>を リスト<L>に読み込みます。

     ソース<S>はファイル名かストリームかもしれません。

     <separator_flag>の認識される値は ‘comma’, ‘pipe’, ‘semicolon’,
     ‘space’です。 もし<separator_flag>が指定されないなら、ファイルは空
     白で区切られていると仮定されます。

 -- 関数: write_data (<X>, <D>)
 -- 関数: write_data (<X>, <D>, <separator_flag>)

     オブジェクト<X>をデスティネーション<D>に書き出します。

     ‘write_data’は行列を 行につき一行で行優先順に書き出します。

     ‘write_data’は ‘array’や‘make_array’で生成された配列を 行優先順でス
     ラブ毎に改行して書き出します。 高次元スラブは更に改行で分割されます
     。

     ‘write_data’はハッシュ配列を 1行に、キーそれぞれに結合したリストが
     続くように書き出します。

     ‘write_data’は入れ子のリストを それぞれの部分リストを1行に書き出し
     ます。

     ‘write_data’はフラットなリストすべてを1行に書き出します。

     デスティネーション<D>はファイル名かストリームかもしれません。 デス
     ティネーションがファイル名の時、 グローバル変数
     ‘file_output_append’は 出力ファイルに追加されるか上書きされるか決定
     します。 デスティネーションがストリームの時、 ‘write_data’は データ
     すべてが書かれた後、特殊なアクションを取ります; 特にストリームは開
     いたままとなります。

     <separator_flag>の認識される値は ‘comma’, ‘pipe’, ‘semicolon’,
     ‘space’です。 もし<separator_flag>が指定されないなら、ファイルは空
     白で区切られていると仮定されます。

