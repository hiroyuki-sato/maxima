<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Maxima 5.46.0 Manual: Functions and Variables for itensor</title>

<meta name="description" content="Maxima 5.46.0 Manual: Functions and Variables for itensor">
<meta name="keywords" content="Maxima 5.46.0 Manual: Functions and Variables for itensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="maxima_toc.html#Top" rel="start" title="Top">
<link href="maxima_307.html#Function-and-Variable-Index" rel="index" title="Function and Variable Index">
<link href="maxima_toc.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="maxima_116.html#itensor" rel="up" title="itensor">
<link href="maxima_119.html#ctensor" rel="next" title="ctensor">
<link href="maxima_117.html#Introduction-to-itensor" rel="previous" title="Introduction to itensor">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 1em; padding-bottom: 1em;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}
img {max-width:80%; max-height: 80%; display: block; margin-left: auto; margin-right: auto}

-->
</style>

<link rel="icon" href="figures/favicon.ico">

</head>

<body lang="ja" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Functions-and-Variables-for-itensor"></a>
<div class="header">
<p>
Previous: <a href="maxima_117.html#Introduction-to-itensor" accesskey="p" rel="previous">Introduction to itensor</a>, Up: <a href="maxima_116.html#itensor" accesskey="u" rel="up">itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_307.html#Function-and-Variable-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Functions-and-Variables-for-itensor-1"></a>
<h3 class="section">25.2 Functions and Variables for itensor</h3>
<a name="Managing-indexed-objects"></a>
<h4 class="subsection">25.2.1 Managing indexed objects</h4>

<a name="dispcon"></a><a name="Item_003a-Itensor_002fdeffn_002fdispcon"></a><dl>
<dt><a name="index-dispcon"></a>関数: <strong>dispcon</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dt><a name="index-dispcon-1"></a>関数: <strong>dispcon</strong> <em>(all)</em></dt>
<dd>
<p><code>defcon</code>に与えられたような引数の縮約プロパティを表示します。
<code>dispcon (all)</code>は、定義された縮約プロパティすべてを表示します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Display-functions">Display functions</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fentertensor"></a><dl>
<dt><a name="index-entertensor"></a>関数: <strong>entertensor</strong> <em>(<var>name</var>)</em></dt>
<dd>
<p>プロンプトによって、
任意の数のテンソル添字や微分添字を持つ<var>name</var>と呼ばれる添字付きオブジェクトを生成することを許す関数です。
単一添字または(nullもありえる)添字のリストが容認可能な入力です。
(<code>covdiff</code>の下の例を参照してください。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fchangename"></a><dl>
<dt><a name="index-changename"></a>関数: <strong>changename</strong> <em>(<var>old</var>, <var>new</var>, <var>expr</var>)</em></dt>
<dd>
<p><var>expr</var>の中の<var>old</var>と呼ばれるすべての添字付きオブジェクトの名前を<var>new</var>に変えます。
<var>old</var>はシンボルまたは形式<code>[<var>name</var>, <var>m</var>, <var>n</var>]</code>のリストであり得ます。
後者の場合、<var>m</var>個の共変添字と<var>n</var>個の反変添字を持つ
<var>name</var>と呼ばれるそれらの添字付きオブジェクトだけが<var>new</var>にリネームされます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flistoftens"></a><dl>
<dt><a name="index-listoftens"></a>関数: <strong>listoftens</strong></dt>
<dd>
<p>テンソル式の中のすべてのテンソルを添字が完備した形でリストします。
例えば、
</p>
<div class="example">
<pre class="example">
(%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                         k
(%t6)                        d e c    + a    b
                                  x y    i j  u,v
(%i7) ishow(listoftens(%))$
                               k
(%t7)                        [a   , b   , c   , d]
                               i j   u,v   x y

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fishow"></a><dl>
<dt><a name="index-ishow"></a>関数: <strong>ishow</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>下付き添字としての共変添字と上付き添字としての反変添字を持つように
添字付きオブジェクトを持つ形で<var>expr</var>を表示します。
微分添字は、共変添字からコンマで区切られた下付き添字として表示されます。
(このドキュメント至る所の例を参照してください。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002findices"></a><dl>
<dt><a name="index-indices"></a>関数: <strong>indices</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>2つの要素のリストを返します。
以下の例が例示するように、
一番目は、<var>expr</var>の中の自由添字(一度だけ現れるもの)のリストです。
二番目は、<var>expr</var>の中のダミー添字(正確に二回現れるもの)のリストです。
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                k l      j m p
(%t2)                          a        b
                                i j,m n  k o,q r
(%i3) indices(%);
(%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

</pre></div>

<p>同じ添字を二回以上含むテンソル積は構文的に認められていません。
<code>indices</code>は、これらの式を合理的な方法で扱おうとします;
しかしながら、そんな非合法な式上で動くようにコールされた時、その振る舞いは未定義と考えなければいけません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002frename"></a><dl>
<dt><a name="index-rename"></a>関数: <strong>rename</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-rename-1"></a>関数: <strong>rename</strong> <em>(<var>expr</var>, <var>count</var>)</em></dt>
<dd>
<p>もしオプションの二番目の引数が省略されたら、
<var>expr</var>と同値な、
しかし、各項に対して、集合<code>[%1, %2,...]</code>から選ばれたダミー添字を持つ式を返します。
そうでなければ、ダミー添字は<var>count</var>の値で始まるようインデックスされます。
積の中のそれぞれのダミー添字は異なります。
和に関しては、<code>rename</code>は各項毎にカウンタが再設定されるように和の中の各項上で作用します。
この方法で、<code>rename</code>はテンソル整理器として利用できます。
加えて、
(もし<code>allsym</code>が<code>true</code>なら、)
添字は、
<code>flipflag</code>の値に依存して共変または反変添字に関して、
英数字順に並び替えられます。
もし<code>flipflag</code>が<code>false</code>なら、
添字は反変添字の順に従ってリネームされます。
もし<code>flipflag</code>が<code>true</code>なら、
リネームは共変添字の順に従って起こるでしょう。
２つのリネームの組み合わせた効果が、それ自身によって、
どちらか１つよりも更に式を簡単にすることがしばしば起こります。
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) allsym:true;
(%o2)                                true
(%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
(%i4) expr:ishow(%)$
</pre><pre class="example">       %4 %5  %6 %7      %3         u          %1         %2
(%t4) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %4      %2 %3      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %5      %4 %6      %7 r
</pre><pre class="example">(%i5) flipflag:true;
(%o5)                                true
(%i6) ishow(rename(expr))$
       %2 %5  %6 %7      %4         u          %1         %3
(%t6) g      g      ichr2      ichr2      ichr2      ichr2
                         %1 %2      %3 %4      %5 %6      %7 r

        %4 %5  %6 %7      u          %1         %3         %2
     - g      g      ichr2      ichr2      ichr2      ichr2
                          %1 %2      %3 %4      %5 %6      %7 r
(%i7) flipflag:false;
(%o7)                                false
(%i8) rename(%th(2));
(%o8)                                  0
(%i9) ishow(rename(expr))$
       %1 %2  %3 %4      %5         %6         %7        u
(%t9) g      g      ichr2      ichr2      ichr2     ichr2
                         %1 %6      %2 %3      %4 r      %5 %7

        %1 %2  %3 %4      %6         %5         %7        u
     - g      g      ichr2      ichr2      ichr2     ichr2
                          %1 %3      %2 %6      %4 r      %5 %7
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>


<a name="show"></a><a name="Item_003a-Itensor_002fdeffn_002fshow"></a><dl>
<dt><a name="index-show"></a>関数: <strong>show</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>下付き添字として共変インデックス、上付き添字として反変インデックスを持つよう、
インデックスされたオブジェクトと一緒に<code>expr</code>を表示します。
微分インデックスは下付き添字として表示され、
コンマによって共変インデックスと区別されます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;<a href="maxima_311.html#Category_003a-Display-functions">Display functions</a>
&middot;</div>
</dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fflipflag"></a><dl>
<dt><a name="index-flipflag"></a>オプション変数: <strong>flipflag</strong></dt>
<dd>
<p>デフォルト: <code>false</code>.
もし<code>false</code>なら反変添字の順に従って、
そうでなければ、共変添字の順に従って、
添字がリネームされます。
</p>
<p>もし<code>flipflag</code>が<code>false</code>なら、
<code>rename</code>は
左から右に現れるよう反変添字のリストを形成します
(もし<code>true</code>なら共変添字について同様に)。
リストの最初のダミー添字は<code>%1</code>に、次は<code>%2</code>にというように、リネームされます。
そして、<code>rename</code>の後、並び替えが起こります。
(<code>rename</code>の下の例を参照してください。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fdefcon"></a><dl>
<dt><a name="index-defcon"></a>関数: <strong>defcon</strong> <em>(<var>tensor_1</var>)</em></dt>
<dt><a name="index-defcon-1"></a>関数: <strong>defcon</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, <var>tensor_3</var>)</em></dt>
<dd><p><var>tensor_1</var>に、
<var>tensor_1</var>と<var>tensor_2</var>の積の縮約が
適切な添字を持つ<var>tensor_3</var>に帰着するという
プロパティを与えます。
もし引数が<var>tensor_1</var>１つだけ与えれたなら、
, then the contraction of the product of 
適切な添字を持つ任意の添字付きオブジェクト(<code>my_tensor</code>とします)との<var>tensor_1</var>の積の縮約はその名前、すなわち、<code>my_tensor</code>と、実行された縮約を反映した添字の新しい集合を持つ添字付きオブジェクトをもたらします。
例えば、もし<code>imetric:g</code>なら、<code>defcon(g)</code>は
計量テンソルとの縮約を通して添字の上げ下げを実行します。
１つ以上の<code>defcon</code>を同じ添字付きオブジェクトに関して与えることができます;
特定の縮約に関して適用する最新のものが使われます。
<code>contractions</code>は、
<code>defcon</code>で縮約プロパティを与えられたそれら添字付きオブジェクトのリストです。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcon"></a><dl>
<dt><a name="index-remcon"></a>関数: <strong>remcon</strong> <em>(<var>tensor_1</var>, ..., <var>tensor_n</var>)</em></dt>
<dt><a name="index-remcon-1"></a>関数: <strong>remcon</strong> <em>(all)</em></dt>
<dd><p><var>tensor_1</var>, ..., <var>tensor_n</var>からすべての縮約プロパティを取り除きます。
<code>remcon(all)</code>は、すべての添字付きオブジェクトから
すべての縮約プロパティを取り除きます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcontract"></a><dl>
<dt><a name="index-contract"></a>関数: <strong>contract</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>和と積の任意の組み合わせであり得る
<var>expr</var>に関して
テンソル縮約を実行します。
この関数は
<code>defcon</code>関数に与えられた情報を使います。
最高の結果として、
<code>expr</code>は完全に展開されなければいけません。
もし項の分母の中に変数がないなら、
<code>ratexpand</code>は
和の積やべきを展開する
最速の方法です。
もしGCD消去が不要なら、
<code>gcd</code>スイッチは<code>false</code>でなければいけません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002findexed_005ftensor"></a><dl>
<dt><a name="index-indexed_005ftensor"></a>関数: <strong>indexed_tensor</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p>値に関する美しい姿が既に
<code>ichr1</code>, <code>ichr2</code>, <code>icurvature</code>とともにあるように存在する
<var>tensor</var>に成分を割り当てる前に実行されなければいけません。
<code>icurvature</code>の下の例を参照してください。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcomponents"></a><dl>
<dt><a name="index-components"></a>関数: <strong>components</strong> <em>(<var>tensor</var>, <var>expr</var>)</em></dt>
<dd>
<p><var>tensor</var>の成分の値を与える式<var>expr</var>に添字値を割り当てることを許します。
その添字のすべてとともに起こるときはいつでも、これらは自動的にテンソルに代入されます。
テンソルは、形式<code>t([...],[...])</code>でなければいけません。
ここで形式<code>t([...],[...])</code>の中のリストのいずれかは空であり得えます。
<var>expr</var>は、
<var>tensor</var>と同じ自由添字を持つ他のオブジェクトを含む任意の添字付き式であり得ます。
成分がダミー添字を含む計量テンソルへ値を割り当てるのに使われる時、
複数のダミー添字の生成を避けるようにこれらの添字を定義するように注意しなければいけません。
この割り当ての削除は関数<code>remcomps</code>に与えられます。
</p>
<p>It is important to keep in mind that 
<code>components</code>はテンソル価についてだけ知る必要があり、特別な添字順序について知る必要がないことを覚えておくことは重要です。
このように、成分を、例えば、<code>x([i,-j],[])</code>, <code>x([-j,i],[])</code>または
<code>x([i],[j])</code>すべてに割り当てることは、同じ結果、
すなわち、
価<code>(1,1)</code>を持つ<code>x</code>と名付けられたテンソルに割り当てられた
成分を生成します。
</p>
<p>成分を、4つの方法で添字付き式に割り当てることができます。
そのうちの2つは<code>components</code>コマンドの使用を含みます:
</p>
<p>1) 添字付き式として。例えば:
</p>
<div class="example">
<pre class="example">(%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
(%i3) ishow(g([],[i,j]))$
                                      i  j
(%t3)                                e  p

</pre></div>

<p>2) 行列として:
</p>
<div class="example">
<pre class="example">
(%i5) lg:-ident(4)$lg[1,1]:1$lg;
</pre><pre class="example">                            [ 1   0    0    0  ]
                            [                  ]
                            [ 0  - 1   0    0  ]
(%o5)                       [                  ]
                            [ 0   0   - 1   0  ]
                            [                  ]
                            [ 0   0    0   - 1 ]
</pre><pre class="example">(%i6) components(g([i,j],[]),lg);
(%o6)                                done
(%i7) ishow(g([i,j],[]))$
(%t7)                                g
                                      i j
(%i8) g([1,1],[]);
(%o8)                                  1
(%i9) g([4,4],[]);
(%o9)                                 - 1
</pre></div>

<p>3) 関数として。Maxima関数を使って、添字に基づいたテンソルの成分を指定することができます。
例えば、以下のコードは、
もし<code>h</code>が同じ数の共変添字と反変添字を持ち、微分添字を持たないなら、<code>kdelta</code>を<code>h</code>に割り当て、そうでなければ、<code>g</code>を割り当てます:
</p>
<div class="example">
<pre class="example">
(%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
  then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
(%i5) ishow(h([i],[j]))$
                                          j
(%t5)                               kdelta
                                          i
(%i6) ishow(h([i,j],[k],l))$
                                     k
(%t6)                               g
                                     i j,l
</pre></div>

<p>4) Maximaのパターンマッチング機能、特に<code>defrule</code>と<code>applyb1</code>コマンド
を使って:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) matchdeclare(l1,listp);
(%o2)                                done
(%i3) defrule(r1,m(l1,[]),(i1:idummy(),
      g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

(%i4) defrule(r2,m([],l1),(i1:idummy(),
      w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

(%i5) ishow(m([i,n],[])*m([],[i,m]))$
</pre><pre class="example">                                    i m
(%t5)                              m    m
                                         i n
</pre><pre class="example">(%i6) ishow(rename(applyb1(%,r1,r2)))$
                           %1  %2  %3 m
(%t6)                     e   q   w     q   e   g
                                         %1  %2  %3 n
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcomps"></a><dl>
<dt><a name="index-remcomps"></a>関数: <strong>remcomps</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p><code>components</code>関数で割り当てられたすべての値を
<var>tensor</var>からアンバインドします。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002fshowcomps"></a><dl>
<dt><a name="index-showcomps"></a>関数: <strong>showcomps</strong> <em>(<var>tensor</var>)</em></dt>
<dd>
<p><code>components</code>コマンドを使って作られたように
テンソルの成分割り当てを表示します。
以下の例で明示されるように、
行列が、<code>components</code>を使って
添字テンソルに割り当てられている時、
この関数は特に役に立ちます:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;ctensor&quot;);
(%o1)       /share/tensor/ctensor.mac
(%i2) load(&quot;itensor&quot;);
(%o2)      /share/tensor/itensor.lisp
(%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
               [         r                                     ]
               [ sqrt(-------)  0       0              0       ]
               [      r - 2 m                                  ]
               [                                               ]
               [       0        r       0              0       ]
(%o3)          [                                               ]
               [       0        0  r sin(theta)        0       ]
               [                                               ]
               [                                      r - 2 m  ]
               [       0        0       0        sqrt(-------) ]
               [                                         r     ]
(%i4) components(g([i,j],[]),lg);
(%o4)                                done
(%i5) showcomps(g([i,j],[]));
                  [         r                                     ]
                  [ sqrt(-------)  0       0              0       ]
                  [      r - 2 m                                  ]
                  [                                               ]
                  [       0        r       0              0       ]
(%t5)      g    = [                                               ]
            i j   [       0        0  r sin(theta)        0       ]
                  [                                               ]
                  [                                      r - 2 m  ]
                  [       0        0       0        sqrt(-------) ]
                  [                                         r     ]
(%o5)                                false

</pre></div>

<p><code>showcomps</code>コマンドは
2よりも高い階数のテンソルの成分も表示することができます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fidummy"></a><dl>
<dt><a name="index-idummy"></a>関数: <strong>idummy</strong> <em>()</em></dt>
<dd>
<p>Increments 
<code>icounter</code>を1つ増やし、
形式<code>%n</code>の添字を値として返します。ここでnは正の整数です。
これは式を形成する際必要なダミー添字が既に使用中の添字とぶつからないことを保証します。
(<code>indices</code>の下の例を参照してください。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fidummyx"></a><dl>
<dt><a name="index-idummyx"></a>オプション変数: <strong>idummyx</strong></dt>
<dd><p>デフォルト値: <code>%</code>
</p>
<p>ダミー添字の接頭辞です。
(<code>indices</code>の下の例を参照してください。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002ficounter"></a><dl>
<dt><a name="index-icounter"></a>オプション変数: <strong>icounter</strong></dt>
<dd><p>デフォルト値: <code>1</code>
</p>
<p>テンソルパッケージで次のダミー添字を生成する際使われる数値接尾を決定します。
接頭辞はオプション<code>idummy</code> (デフォルト: <code>%</code>)で決定されます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fkdelta"></a><dl>
<dt><a name="index-kdelta"></a>関数: <strong>kdelta</strong> <em>(<var>L1</var>, <var>L2</var>)</em></dt>
<dd><p>共変添字のリスト<var>L1</var>と反変添字のリスト<var>L2</var>を使って
<code>itensor</code>パッケージで定義された
一般化されたKroneckerのデルタ関数です。
<code>kdelta([i],[j])</code>は通常のKroneckerデルタを返します。
コマンド<code>ev(<var>expr</var>,kdelta)</code>は
<code>kdelta([],[])</code>を多様体の次元に含む
式の評価をもたらします。
</p>
<p>この表記法の乱用となることですが、
<code>itensor</code>は
<code>kdelta</code>が2つの共変添字だけ、または、2つの反変添字だけを持つことも許し、
事実上、共(反)変「単位行列」を供給します。
これは厳密にはプログラミング目的としてみなされ、
<code>kdelta([i,j],[])</code>が有効なテンソルオブジェクトだということを意味するつもりではありません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fkdels"></a><dl>
<dt><a name="index-kdels"></a>関数: <strong>kdels</strong> <em>(<var>L1</var>, <var>L2</var>)</em></dt>
<dd>
<p>いくつかの計算で使われる、対称化されたKroneckerデルタ。
例えば:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) kdelta([1,2],[2,1]);
(%o2)                                 - 1
(%i3) kdels([1,2],[2,1]);
(%o3)                                  1
(%i4) ishow(kdelta([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  - kdelta  kdelta
                             a       b         a       b
(%i4) ishow(kdels([a,b],[c,d]))$
                             c       d         d       c
(%t4)                  kdelta  kdelta  + kdelta  kdelta
                             a       b         a       b

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flevi_005fcivita"></a><dl>
<dt><a name="index-levi_005fcivita"></a>関数: <strong>levi_civita</strong> <em>(<var>L</var>)</em></dt>
<dd><p>もしリスト<var>L</var>が整数の偶置換から成るなら1を返し、
<var>L</var>が奇置換なら成るなら-1を返し、
<var>L</var>のいくつかの添字が繰り返しなら0を返す
置換(別名Levi-Civita)テンソルです。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002flc2kdt"></a><dl>
<dt><a name="index-lc2kdt"></a>関数: <strong>lc2kdt</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>Levi-Civitaシンボルを含む式を整理し、可能ならこれらをKroneckerデルタ式に変換します。
この関数と単にLevi-Civitaシンボルを評価することの主な違いは、
直接評価はしばしば数値添字を含むKronecker式に帰着することです。
これは、更なる整理を妨げるので、しばしば望ましくないことです。
<code>lc2kdt</code>関数はこの問題を避けて、
<code>rename</code>や<code>contract</code>を使って更に容易に整理される式をもたらします。
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([k,l],[])*a([j],[k]))$
                                  i j  k
(%t2)                  levi_civita    a  levi_civita
                                       j            k l
(%i3) ishow(ev(expr,levi_civita))$
                                  i j  k       1 2
(%t3)                       kdelta    a  kdelta
                                  1 2  j       k l
(%i4) ishow(ev(%,kdelta))$
             i       j         j       i   k
(%t4) (kdelta  kdelta  - kdelta  kdelta ) a
             1       2         1       2   j

                               1       2         2       1
                        (kdelta  kdelta  - kdelta  kdelta )
                               k       l         k       l
(%i5) ishow(lc2kdt(expr))$
                     k       i       j    k       j       i
(%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                     j       k       l    j       k       l
(%i6) ishow(contract(expand(%)))$
                                 i           i
(%t6)                           a  - a kdelta
                                 l           l
</pre></div>

<p><code>lc2kdt</code>関数は時々計量テンソルを利用します。
もし前もって計量テンソルが<code>imetric</code>で定義されていなかったなら、
これはエラーになります。
</p>
<div class="example">
<pre class="example">
(%i7) expr:ishow('levi_civita([],[i,j])
                 *'levi_civita([],[k,l])*a([j,k],[]))$
</pre><pre class="example">                                 i j            k l
(%t7)                 levi_civita    levi_civita    a
                                                     j k
</pre><pre class="example">(%i8) ishow(lc2kdt(expr))$
Maxima encountered a Lisp error:

 Error in $IMETRIC [or a callee]:
 $IMETRIC [or a callee] requires less than two arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i9) imetric(g);
(%o9)                                done
(%i10) ishow(lc2kdt(expr))$
         %3 i       k   %4 j       l     %3 i       l   %4 j
(%t10) (g     kdelta   g     kdelta   - g     kdelta   g    
                    %3             %4               %3
              k
        kdelta  ) a
              %4   j k
(%i11) ishow(contract(expand(%)))$
                                  l i    l i  j
(%t11)                           a    - g    a
                                              j
</pre></div>


<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002flc_005fl"></a><dl>
<dt><a name="index-lc_005fl"></a>関数: <strong>lc_l</strong></dt>
<dd>
<p>未評価のLevi-Civitaシンボル(<code>levi_civita</code>)を含む式のために使われる整理ルール。
<code>lc_u</code>と組み合わせて、
たくさんの式を、<code>levi_civita</code>の評価より、より効率的に整理するのに使うことができます。
</p>
<p>例えば:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                             i  j
(%t2)                       a  a  levi_civita
                                             i j k
(%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                       i j k
(%t3)                       levi_civita      a  a
                                              i  j
(%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
(%t4)                                  0
(%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
(%t5)                                  0

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdeffn_002flc_005fu"></a><dl>
<dt><a name="index-lc_005fu"></a>関数: <strong>lc_u</strong></dt>
<dd>
<p>未評価のLevi-Civitaシンボル(<code>levi_civita</code>)を含む式のために使われる整理ルール。
<code>lc_l</code>と組み合わせて、
たくさんの式を、<code>levi_civita</code>の評価より、より効率的に整理するのに使うことができます。
詳しくは、<code>lc_l</code>を参照してください。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcanten"></a><dl>
<dt><a name="index-canten"></a>関数: <strong>canten</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>名前を変えて(<code>rename</code>を参照してください)、ダミー添字を置換することで、
<var>expr</var>を整理します。
<code>rename</code>は
微分がないテンソル積の和に制限されます。
本当に限定されていて、
もし<code>canform</code>が要求された整理を実行する能力がない時だけ使われるはずです。
</p>
<p><code>canten</code>関数は、
引数が添字が完全に対称な式の時だけ数学的に正確な結果を返します。
この理由から、<code>canten</code>は、
もし<code>allsym</code>が<code>true</code>に設定されてないなら
エラーを返します。
</p>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fconcan"></a><dl>
<dt><a name="index-concan"></a>関数: <strong>concan</strong> <em>(<var>expr</var>)</em></dt>
<dd><p><code>canten</code>に似ていますが、添字縮約も実行します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Tensor-symmetries"></a>
<h4 class="subsection">25.2.2 Tensor symmetries</h4>

<a name="Item_003a-Itensor_002fdefvr_002fallsym"></a><dl>
<dt><a name="index-allsym"></a>オプション変数: <strong>allsym</strong></dt>
<dd>
<p>デフォルト: <code>false</code>。
もし<code>true</code>なら、すべての添字付きオブジェクトは共変、反変添字のすべてに関して対称と仮定されます。
もし<code>false</code>なら、これらの添字に関して、いかなる種類の対称性も仮定されません。
<code>iframe_flag</code>が<code>true</code>に設定されない限り、
微分添字はいつも対称と取られます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fdecsym"></a><dl>
<dt><a name="index-decsym"></a>関数: <strong>decsym</strong> <em>(<var>tensor</var>, <var>m</var>, <var>n</var>, [<var>cov_1</var>, <var>cov_2</var>, ...], [<var>contr_1</var>, <var>contr_2</var>, ...])</em></dt>
<dd>
<p><var>m</var>個の共変添字と<var>n</var>個の反変添字を持つ<var>tensor</var>に関する
対称プロパティを宣言します。
<var>cov_i</var>と<var>contr_i</var>は
それぞれ、共変添字と反変添字の間の対称関係を表す擬似関数です。
これらは
contravariant indices respectively.  These are of the form
形式<code>symoper(<var>index_1</var>, <var>index_2</var>,...)</code>を取ります。
ここで<code>symoper</code>は
<code>sym</code>, <code>anti</code>もしくは<code>cyc</code>のいずれかで、
 and the 
<var>index_i</var>は
<var>tensor</var>の添字の位置を示す整数です。
これは、<var>tensor</var>が<var>index_i</var>に関してそれぞれ対称、反対称、巡回であると宣言します。
<code>symoper(all)</code>も対称条件に従う添字すべてを示す有効な形式です。
例えば、
5つの共変添字を持つオブジェクト<code>b</code>が与えられたとして、
<code>decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])</code>は、
<code>b</code>が一番目と二番目の共変添字に対して対称であり、三番目、四番目の共変添字に対して反対称であり、反変添字すべてに対して巡回的であると宣言します。
対称宣言のリストのどれかは空であり得ます。
式整理を実行する関数は
以下の例で示すように<code>canform</code>です。
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) expr:contract( expand( a([i1, j1, k1], [])
           *kdels([i, j, k], [i1, j1, k1])))$
(%i3) ishow(expr)$
</pre><pre class="example">(%t3)         a      + a      + a      + a      + a      + a
               k j i    k i j    j k i    j i k    i k j    i j k
</pre><pre class="example">(%i4) decsym(a,3,0,[sym(all)],[]);
(%o4)                                done
(%i5) ishow(canform(expr))$
(%t5)                              6 a
                                      i j k
(%i6) remsym(a,3,0);
(%o6)                                done
(%i7) decsym(a,3,0,[anti(all)],[]);
(%o7)                                done
(%i8) ishow(canform(expr))$
(%t8)                                  0
(%i9) remsym(a,3,0);
(%o9)                                done
(%i10) decsym(a,3,0,[cyc(all)],[]);
(%o10)                               done
(%i11) ishow(canform(expr))$
(%t11)                        3 a      + 3 a
                                 i k j      i j k
(%i12) dispsym(a,3,0);
(%o12)                     [[cyc, [[1, 2, 3]], []]]

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremsym"></a><dl>
<dt><a name="index-remsym"></a>関数: <strong>remsym</strong> <em>(<var>tensor</var>, <var>m</var>, <var>n</var>)</em></dt>
<dd><p><var>m</var>個の共変添字と<var>n</var>個の反変添字を持つ<var>tensor</var>から
すべての対称プロパティを取り除きます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcanform"></a><dl>
<dt><a name="index-canform"></a>関数: <strong>canform</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-canform-1"></a>関数: <strong>canform</strong> <em>(<var>expr</var>, <var>rename</var>)</em></dt>
<dd><p>ダミー添字をリネームして、
それらに課せられた対称条件によって指令されたようにすべての添字を並べ替えることで、
<var>expr</var>を整理します。
もし<code>allsym</code>が<code>true</code>なら、
すべての添字は対称と仮定され、
そうでなければ、<code>decsym</code>宣言が提供する対称情報が使われます。
ダミー添字は<code>rename</code>関数に関するものと同じ方法でリネームされます。
<code>canform</code>が大きな式に適用される時、
計算にかなりの時間が費やされるかもしれません。
この時間は最初に式に対して<code>rename</code>をコールすることで短くできます。
<code>decsym</code>の下の例も参照してください。
注意: <code>canform</code>は
いつも数学的に正しい結果を返しますが、
式を最も簡単な形式に完全に整理できないかもしれません。
</p>
<p>オプションの二番目のパラメータ<var>rename</var>は、
もし<code>false</code>に設定されたなら、リネームを抑制します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Indicial-tensor-calculus"></a>
<h4 class="subsection">25.2.3 Indicial tensor calculus</h4>

<a name="Item_003a-Itensor_002fdeffn_002fdiff"></a><dl>
<dt><a name="index-diff-4"></a>関数: <strong>diff</strong> <em>(<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</em></dt>
<dd>
<p><code>itensor</code>のための能力に関して拡張された
通常のMaxima微分関数です。
It takes the derivative of 
<var>v_1</var>に関して <var>n_1</var>階、
<var>v_2</var>に関して <var>n_2</var>階、
という<var>expr</var>の微分を取ります。
テンソルパッケージでは、
<var>v_i</var>が1から変数 <code>dim</code>の値までの整数であるように
関数が修正されています。
これによって、
微分がリスト <code>vect_coords</code>の <var>v_i</var>番目の要素に関して実行されます。
もし
<code>vect_coords</code>がアトム変数にバインドされているなら、
<var>v_i</var>が下付きしたその変数が
微分変数として使われます。
これは
座標名や、<code>x[1]</code>, <code>x[2]</code>, ... のような下付き名の配列を使うことを可能にします。
</p>
<p>更なる拡張は、
添字付き変数に関する微分を計算する能力を<code>diff</code>に追加します。
特にテンソルパッケージは
計量テンソルと、計量テンソルやその一階微分、二階微分に関する微分を含む
式を微分する方法を知っています。
この能力は
重力理論のLagrange形式を考える時、
特に役に立ちます。
作用原理からEinsteinテンソルと場の方程式を演繹することを可能にします。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fidiff"></a><dl>
<dt><a name="index-idiff"></a>関数: <strong>idiff</strong> <em>(<var>expr</var>, <var>v_1</var>, [<var>n_1</var>, [<var>v_2</var>, <var>n_2</var>] ...])</em></dt>
<dd><p>添字微分。
独立変数に関して微分する<code>diff</code>と異なり、
<code>idiff)</code>は座標に関して微分するのにつかうことができます。
添字付きオブジェクトに関して，
結果的に、これは
<var>v_i</var>を微分添字として追加することになります。
<code>iframe_flag</code>が <code>true</code>に設定されていない限り
続いて，微分添字が並び替えられます。
</p>
<p><code>idiff</code>は計量テンソルの行列式も微分することができます。
従って、もし <code>imetric</code>が
<code>G</code>にバインドされていたら、
<code>idiff(determinant(g),k)</code>は
ダミー添字 <code>%i</code>が適当に選ばれて
<code>2 * determinant(g) * ichr2([%i,k],[%i])</code>を返します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fliediff"></a><dl>
<dt><a name="index-liediff"></a>関数: <strong>liediff</strong> <em>(<var>v</var>, <var>ten</var>)</em></dt>
<dd>
<p>ベクトル場 <var>v</var>に対してテンソル式 <var>ten</var>のLie微分を計算します。
<var>ten</var>は任意の添字付きテンソル式でなければいけません;
<var>v</var>はベクトル場の(添字なしの)名前でなければいけません。
例えば:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
       k    %2            %2          %2
(%t2) b   (v   a       + v   a     + v   a    )
       ,l       i j,%2    ,j  i %2    ,i  %2 j

                          %1  k        %1  k      %1  k
                      + (v   b      - b   v    + v   b   ) a
                              ,%1 l    ,l  ,%1    ,l  ,%1   i j

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002frediff"></a><dl>
<dt><a name="index-rediff"></a>関数: <strong>rediff</strong> <em>(<var>ten</var>)</em></dt>
<dd>
<p>テンソル式 <var>ten</var>の中の<code>idiff</code>コマンドすべてを評価します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fundiff"></a><dl>
<dt><a name="index-undiff"></a>関数: <strong>undiff</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p><var>expr</var>と同値な、
添字付きオブジェクトの微分すべてが<code>idiff</code>関数の名詞形で置き換えられた
式を返します。
引数はもし微分が実行されていたらその添字付きオブジェクトをもたらします。
微分された添字付きオブジェクトを
<var>expr</var>を生じるある関数定義で置き換えて、
<code>ev(<var>expr</var>, idiff)</code>で微分を実行したい時、
これは役に立ちます。
</p>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fevundiff"></a><dl>
<dt><a name="index-evundiff"></a>関数: <strong>evundiff</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p><code>undiff</code>の実行と同値ですが、<code>ev</code>と <code>rediff</code>が続きます。
</p>
<p>この演算のポイントは
微分形式で直接評価できない式を簡単に評価することです。
例えば、以下はエラーをもたらします:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) icurvature([i,j,k],[l],m);
Maxima encountered a Lisp error:

 Error in $ICURVATURE [or a callee]:
 $ICURVATURE [or a callee] requires less than three arguments.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre></div>

<p>しかし、もし <code>icurvature</code>は名詞形で入っているなら、
<code>evundiff</code>を使って評価できます:
</p>
<div class="example">
<pre class="example">(%i3) ishow('icurvature([i,j,k],[l],m))$
                                         l
(%t3)                          icurvature
                                         i j k,m
(%i4) ishow(evundiff(%))$
             l              l         %1           l           %1
(%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
             i k,j m        %1 j      i k,m        %1 j,m      i k

             l              l         %1           l           %1
      + ichr2        + ichr2     ichr2      + ichr2       ichr2
             i j,k m        %1 k      i j,m        %1 k,m      i j
</pre></div>

<p>注意: Maximaの以前のバージョンでは、
Christoffel記号の微分形式も評価できませんでした。
これは現在修正されています。
だから <code>evundiff</code>はもはやこのような式に関しては不要です:
</p>
<div class="example">
<pre class="example">(%i5) imetric(g);
(%o5)                                done
(%i6) ishow(ichr2([i,j],[k],l))$
       k %3
      g     (g         - g         + g        )
              j %3,i l    i j,%3 l    i %3,j l
(%t6) -----------------------------------------
                          2

                         k %3
                        g     (g       - g       + g      )
                         ,l     j %3,i    i j,%3    i %3,j
                      + -----------------------------------
                                         2
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflush"></a><dl>
<dt><a name="index-flush"></a>関数: <strong>flush</strong> <em>(<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd><p><var>expr</var>において、
微分添字を持たない <var>tensor_i</var>をすべて0にします。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflushd"></a><dl>
<dt><a name="index-flushd"></a>関数: <strong>flushd</strong> <em>(<var>expr</var>, <var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd><p><var>expr</var>において、
微分添字を持つ <var>tensor_i</var>をすべて0にします。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflushnd"></a><dl>
<dt><a name="index-flushnd"></a>関数: <strong>flushnd</strong> <em>(<var>expr</var>, <var>tensor</var>, <var>n</var>)</em></dt>
<dd><p>以下の例で例示されるように、
<var>expr</var>において、
<var>n</var>以上の微分添字を持つ微分されたオブジェクト <var>tensor</var>をすべて0にします。
</p><div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                J r      j r s
(%t2)                          a      + a
                                i,k r    i,k r s
(%i3) ishow(flushnd(%,a,3))$
                                     J r
(%t3)                               a
                                     i,k r
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcoord"></a><dl>
<dt><a name="index-coord"></a>関数: <strong>coord</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dd>
<p><var>tensor_i</var>に、
その名前が<var>tensor_i</var>の1つである反変ベクトルの微分がKroneckerデルタをもたらす
座標微分プロパティを与えます。
例えば、
もし <code>coord(x)</code>が実行されたら、
<code>idiff(x([],[i]),j)</code>は <code>kdelta([i],[j])</code>を与えます。
<code>coord</code>はこのプロパティを持つ添字付きオブジェクトすべてのリストです。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fremcoord"></a><dl>
<dt><a name="index-remcoord"></a>関数: <strong>remcoord</strong> <em>(<var>tensor_1</var>, <var>tensor_2</var>, ...)</em></dt>
<dt><a name="index-remcoord-1"></a>関数: <strong>remcoord</strong> <em>(all)</em></dt>
<dd>
<p><code>tensor_i</code>から
関数 <code>coord</code>がもたらした座標微分プロパティを削除します。
<code>remcoord(all)</code>は添字付きオブジェクトすべてからこのプロパティを削除します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fmakebox"></a><dl>
<dt><a name="index-makebox"></a>関数: <strong>makebox</strong> <em>(<var>expr</var>)</em></dt>
<dd><p><code>show</code>と同じように <var>expr</var>を表示します;
しかし、
<var>expr</var>に現れるテンソル d&rsquo;Alembert演算子はすべて記号 <code>[]</code>を使って示されます。
例えば、 <code>[]p([m],[n])</code>は
<code>g([],[i,j])*p([m],[n],i,j)</code>を表します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fconmetderiv"></a><dl>
<dt><a name="index-conmetderiv"></a>関数: <strong>conmetderiv</strong> <em>(<var>expr</var>, <var>tensor</var>)</em></dt>
<dd>
<p>計量テンソルの共変と反変形式両方(現在の制約)の常微分を含む式を整理します。
例えば、 以下に見られるように、
<code>conmetderiv</code>は
反変計量テンソルの微分をChristoffelシンボルに結びつけます:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(g([],[a,b],c))$
                                      a b
(%t2)                                g
                                      ,c
(%i3) ishow(conmetderiv(%,g))$
                         %1 b      a       %1 a      b
(%t3)                 - g     ichr2     - g     ichr2
                                   %1 c              %1 c
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fsimpmetderiv"></a><dl>
<dt><a name="index-simpmetderiv"></a>関数: <strong>simpmetderiv</strong> <em>(<var>expr</var>)</em></dt>
<dt><a name="index-simpmetderiv-1"></a>関数: <strong>simpmetderiv</strong> <em>(<var>expr</var>[, <var>stop</var>])</em></dt>
<dd>
<p>計量テンソルの微分の積を含む式を整理します。
特に、 <code>simpmetderiv</code>は2つの恒等式を知っています:
</p>
<div class="example">
<pre class="example">
   ab        ab           ab                 a
  g   g   + g   g     = (g   g  )   = (kdelta )   = 0
   ,d  bc        bc,d         bc ,d          c ,d

</pre></div>

<p>従って、
</p>
<div class="example">
<pre class="example">
   ab          ab
  g   g   = - g   g
   ,d  bc          bc,d
</pre></div>

<p>と
</p>
<div class="example">
<pre class="example">
  ab          ab
 g   g     = g   g
  ,j  ab,i    ,i  ab,j

</pre></div>

<p>これはChristoffel記号の対称性の結果です。
</p>
<p><code>simpmetderiv</code>関数はオプションパラメータを1つ取ります。
それは、与えられた時、
積式の中の最初にうまくいった代入の後、関数が停止するようにします。
<code>simpmetderiv</code>関数は
&ldquo;正準&rdquo;順序を積添字に適用する方法を決めるグローバル変数 <var>flipflag</var>も利用します。
</p>
<p>まとめると、
これらの機能は
そうでなければ遂行困難か不可能な強力な式整理を達成するのに使うことができます。
これは、
縮約式を得るために<code>simpmetderiv</code>の部分的な整理の特長を明示的に使う
以下の例を通じて例示されます:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                                done
(%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                             a b  b c
(%t3)                       g    g    g      g
                                       a b,d  b c,e
(%i4) ishow(canform(%))$

errexp1 has improper indices
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ishow(simpmetderiv(%))$
                             a b  b c
(%t5)                       g    g    g      g
                                       a b,d  b c,e
(%i6) flipflag:not flipflag;
(%o6)                                true
(%i7) ishow(simpmetderiv(%th(2)))$
                               a b  b c
(%t7)                         g    g    g    g
                               ,d   ,e   a b  b c
(%i8) flipflag:not flipflag;
(%o8)                                false
(%i9) ishow(simpmetderiv(%th(2),stop))$
                               a b  b c
(%t9)                       - g    g    g      g
                                    ,e   a b,d  b c
(%i10) ishow(contract(%))$
                                    b c
(%t10)                           - g    g
                                    ,e   c b,d

</pre></div>

<p>Weylテンソルの縮約を整理するために
<code>simpmetderiv</code>と <code>conmetderiv</code>を一緒に使う例として、
<code>weyl.dem</code>も参照してください。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fflush1deriv"></a><dl>
<dt><a name="index-flush1deriv"></a>関数: <strong>flush1deriv</strong> <em>(<var>expr</var>, <var>tensor</var>)</em></dt>
<dd>
<p><var>expr</var>において、
微分添字を1つだけ持つ <var>tensor</var>をすべて0にします。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Tensors-in-curved-spaces"></a>
<h4 class="subsection">25.2.4 Tensors in curved spaces</h4>

<a name="Item_003a-Itensor_002fdeffn_002fimetric"></a><dl>
<dt><a name="index-imetric"></a>関数: <strong>imetric</strong> <em>(<var>g</var>)</em></dt>
<dt><a name="index-imetric-1"></a>システム変数: <strong>imetric</strong></dt>
<dd>
<p>変数 <code>imetric:<var>g</var></code>を割り当てることで計量を指定します。
加えて、
コマンド <code>defcon(<var>g</var>),defcon(<var>g</var>, <var>g</var>, kdelta)</code>を実行することで
計量 <var>g</var>の縮約プロパティが設定されます。
(デフォルトではバインドされていない)変数 <code>imetric</code>は
<code>imetric(<var>g</var>)</code>コマンドが割り当てる計量にバインドされます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fidim"></a><dl>
<dt><a name="index-idim"></a>関数: <strong>idim</strong> <em>(<var>n</var>)</em></dt>
<dd><p>計量の次元を設定します。
与えられた次元でLevi-Civita記号の反対称プロパティも初期化します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fichr1"></a><dl>
<dt><a name="index-ichr1"></a>関数: <strong>ichr1</strong> <em>([<var>i</var>, <var>j</var>, <var>k</var>])</em></dt>
<dd><p>以下の定義を介して第一種Christoffel記号をもたらします。
</p><div class="example">
<pre class="example">       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k
</pre></div>
<p>特定の計量で Christoffel記号を評価するには、
<code>chr2</code>の下の例のように
変数 <code>imetric</code>が名前を割り当てられなければいけません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fichr2"></a><dl>
<dt><a name="index-ichr2"></a>関数: <strong>ichr2</strong> <em>([<var>i</var>, <var>j</var>], [<var>k</var>])</em></dt>
<dd><p>以下の定義を介して第二種Christoffel記号をもたらします。
</p><div class="example">
<pre class="example">                       ks
   ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002ficurvature"></a><dl>
<dt><a name="index-icurvature"></a>関数: <strong>icurvature</strong> <em>([<var>i</var>, <var>j</var>, <var>k</var>], [<var>h</var>])</em></dt>
<dd><p>第二種Christoffel記号(<code>ichr2</code>)を使った
Riemann曲率テンソルをもたらします。
以下の表記法が使われます:
</p><div class="example">
<pre class="example">            h             h            h         %1         h
  icurvature     = - ichr2      - ichr2     ichr2    + ichr2
            i j k         i k,j        %1 j      i k        i j,k
                            h          %1
                     + ichr2      ichr2
                            %1 k       i j
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fcovdiff"></a><dl>
<dt><a name="index-covdiff"></a>関数: <strong>covdiff</strong> <em>(<var>expr</var>, <var>v_1</var>, <var>v_2</var>, ...)</em></dt>
<dd><p>第二種Christoffel記号(<code>ichr2</code>)を使って、
変数 <var>v_i</var>に対する
<var>expr</var>の共変微分をもたらします。
これらを評価するには、
<code>ev(<var>expr</var>,ichr2)</code>を使わなければ行けません。
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) entertensor()$
Enter tensor name: a;
Enter a list of the covariant indices: [i,j];
Enter a list of the contravariant indices: [k];
Enter a list of the derivative indices: [];
                                      k
(%t2)                                a
                                      i j
(%i3) ishow(covdiff(%,s))$
             k         %1     k         %1     k
(%t3)     - a     ichr2    - a     ichr2    + a
             i %1      j s    %1 j      i s    i j,s

             k     %1
      + ichr2     a
             %1 s  i j
(%i4) imetric:g;
(%o4)                                  g
(%i5) ishow(ev(%th(2),ichr2))$
         %1 %4  k
        g      a     (g       - g       + g      )
                i %1   s %4,j    j s,%4    j %4,s
(%t5) - ------------------------------------------
                            2
</pre><pre class="example">    %1 %3  k
   g      a     (g       - g       + g      )
           %1 j   s %3,i    i s,%3    i %3,s
 - ------------------------------------------
                       2
    k %2  %1
   g     a    (g        - g        + g       )
          i j   s %2,%1    %1 s,%2    %1 %2,s     k
 + ------------------------------------------- + a
                        2                         i j,s
</pre><pre class="example">(%i6)
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002florentz_005fgauge"></a><dl>
<dt><a name="index-lorentz_005fgauge"></a>関数: <strong>lorentz_gauge</strong> <em>(<var>expr</var>)</em></dt>
<dd><p>反変添字と同一の微分添字を持つ <var>expr</var>の中で
添字付きオブジェクトすべてに0を代入することで、
Lorentz条件を課します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002figeodesic_005fcoords"></a><dl>
<dt><a name="index-igeodesic_005fcoords"></a>関数: <strong>igeodesic_coords</strong> <em>(<var>expr</var>, <var>name</var>)</em></dt>
<dd>
<p><var>expr</var>内の、未微分 Christoffel記号と
計量テンソルの一階微分を消すようにします。
<code>igeodesic_coords</code>関数での <var>name</var>は
(もし <var>expr</var>)の中で現れるなら)
計量 <var>name</var>を参照します。
一方で、接続係数は
名前 <code>ichr1</code>か <code>ichr2</code>でコールされなければいけません。
以下の例は、
<code>igeodesic_coords</code>関数を使った、
Riemann曲率テンソルが満たす巡回恒等式の検証を例示します。
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(icurvature([r,s,t],[u]))$
             u            u         %1         u     
(%t2) - ichr2      - ichr2     ichr2    + ichr2      
             r t,s        %1 s      r t        r s,t 

                                              u         %1
                                       + ichr2     ichr2
                                              %1 t      r s
(%i3) ishow(igeodesic_coords(%,ichr2))$
                                 u            u
(%t3)                       ichr2      - ichr2
                                 r s,t        r t,s
(%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
            igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
            igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
             u            u            u            u
(%t4) - ichr2      + ichr2      + ichr2      - ichr2
             t s,r        t r,s        s t,r        s r,t

                                             u            u
                                      - ichr2      + ichr2
                                             r t,s        r s,t
(%i5) canform(%);
(%o5)                                  0

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Moving-frames"></a>
<h4 class="subsection">25.2.5 Moving frames</h4>

<p>今ではMaximaは
動標構(moving frame)を使って計算を実行する能力があります。
これらは直交標構(テトラド、四脚場)か任意系であり得ます。
</p>
<p>標構(frame)を使うには、
最初に<code>iframe_flag</code>を <code>true</code>に設定しなければいけません。
これにより、
計算内で、
Christoffel記号, <code>ichr1</code>と <code>ichr2</code>が
もっと一般的な標構(frame)の接続係数
<code>icc1</code>と <code>icc2</code>に置き換えられることになります。
特に、
<code>covdiff</code>と <code>icurvature</code>の振る舞いが変わります。
</p>
<p>系は2つのテンソルで定義されます:
逆標枠場 (<code>ifri</code>, 双対基底四脚場)と
標構計量(frame metric) <code>ifg</code>。
標構計量は直交標構の単位行列、すなわち、
Minkowski時空での直交標構のLorentz計量です。
逆標枠場は標構基底(単位ベクトル)を定義します。
標枠と標構計量に縮約プロパティが定義されます。
</p>
<p><code>iframe_flag</code>がtrueなら、
たくさんの <code>itensor</code>式が、
<code>imetric</code>が上付き添字と下付き添字に関して定義する計量の代わりに
標構計量 <code>ifg</code>を使います。
</p>
<p>重要: 変数 <code>iframe_flag</code>を <code>true</code>に設定することは
<code>defcon</code>や <code>imetric</code>のコールによって定義された計量の縮約プロパティを
未定義に戻しません。
もし標枠場が使われるなら、
<code>imetric</code>関数を呼び出さず、
変数 <code>imetric</code>に名前を割り当てて計量を定義することが最良です。
</p>

<p>Maximaはこれら2つのテンソルを使って、
接続係数 (<code>icc1</code>と <code>icc2</code>)の一部を形成する
標構係数 (<code>ifc1</code>と <code>ifc2</code>)を定義します。
以下の例がそれを例示します:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) iframe_flag:true;
(%o2)                                true
(%i3) ishow(covdiff(v([],[i]),j))$
                               i        i     %1
(%t3)                         v   + icc2     v
                               ,j       %1 j
(%i4) ishow(ev(%,icc2))$
                               %1     i       i
(%t4)                         v   ifc2     + v
                                      %1 j    ,j
(%i5) ishow(ev(%,ifc2))$
                          %1    i %2                i
(%t5)                    v   ifg     ifc1        + v
                                         %1 j %2    ,j
(%i6) ishow(ev(%,ifc1))$
</pre><pre class="example">            %1    i %2
           v   ifg     (ifb        - ifb        + ifb       )
                           j %2 %1      %2 %1 j      %1 j %2     i
(%t6)      -------------------------------------------------- + v
                                   2                             ,j
</pre><pre class="example">(%i7) ishow(ifb([a,b,c]))$
                                                   %3    %4
(%t7)               (ifri        - ifri       ) ifr   ifr
                         a %3,%4       a %4,%3     b     c

</pre></div>

<p>もし <code>iframe_bracket_form</code>フラグが <code>false</code>に設定されているなら
標構ブラケット(frame bracket) (<code>ifb</code>)を計算するのに代わりの方法が使われます:
</p>
<div class="example">
<pre class="example">
(%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                %6    %5        %5      %6
(%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                       a %5     b     c,%6      b,%6    c

</pre></div>

<a name="Item_003a-Itensor_002fdeffn_002fiframes"></a><dl>
<dt><a name="index-iframes"></a>関数: <strong>iframes</strong> <em>()</em></dt>
<dd>
<p>Maximaのこのバージョン以来、
<code>ifr</code>と <code>ifri</code>に関する縮約恒等式がいつも定義されます。
as is the frame bracket (<code>ifb</code>), 
この関数は何もしません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifb"></a><dl>
<dt><a name="index-ifb"></a>変数: <strong>ifb</strong></dt>
<dd>
<p>標構ブラケット(frame bracket)。
標構計量の接続係数への寄与が標構ブラケットを使って表されます:
</p>
<div class="example">
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                  2

</pre></div>

<p>標構ブラケット自身は
標枠と標構計量を使って定義されます。
<code>frame_bracket_form</code>の値に依存して
2つの代わりの計算方法が使われます。
もし true (デフォルト)か、もし <code>itorsion_flag</code>が <code>true</code>なら:
</p>
<div class="example">
<pre class="example">
          d      e                                      f
ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
   abc    b      c       a d,e       a e,d       a f    d e


</pre></div>

<p>そうでないなら:
</p>
<div class="example">
<pre class="example">
             e      d        d      e
ifb    = (ifr    ifr    - ifr    ifr   ) ifri
   abc       b      c,e      b,e    c        a d

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>


<a name="Item_003a-Itensor_002fdefvr_002ficc1"></a><dl>
<dt><a name="index-icc1"></a>変数: <strong>icc1</strong></dt>
<dd>
<p>第一種接続係数。
<code>itensor</code>では、以下のように定義されます。
</p>
<div class="example">
<pre class="example">
icc1    = ichr1    - ikt1    - inmc1
    abc        abc       abc        abc

</pre></div>

<p>この式では、
もし <code>iframe_flag</code>が trueなら、
Christoffel記号 <code>ichr1</code>が
標構接続係数 <code>ifc1</code>に置き換えられます。
もし <code>itorsion_flag</code>が <code>false</code>なら、
 <code>ikt1</code>は省略されます。
もし標構基底が使われるなら、
ねじれが標構ブラケットの一部として既に計算されているので、
その時にも <code>ikt1</code>は省略されます。
最後に、
<code>inonmet_flag</code>が <code>false</code>なら、
<code>inmc1</code>は存在しません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002ficc2"></a><dl>
<dt><a name="index-icc2"></a>変数: <strong>icc2</strong></dt>
<dd>
<p>第二種接続係数。
<code>itensor</code>では、以下のように定義されます。
</p>
<div class="example">
<pre class="example">
    c         c        c         c
icc2   = ichr2   - ikt2   - inmc2
    ab        ab       ab        ab

</pre></div>

<p>この式では、
もし <code>iframe_flag</code>が trueなら、
Christoffel記号 <code>ichr2</code>が
標構接続係数 <code>ifc2</code>に置き換えられます。
もし <code>itorsion_flag</code>が <code>false</code>なら、
 <code>ikt2</code>は省略されます。
もし標構基底が使われるなら、
ねじれが標構ブラケットの一部として既に計算されているので、
その時にも <code>ikt1</code>は省略されます。
最後に、
<code>inonmet_flag</code>が <code>false</code>なら、
<code>inmc1</code>は存在しません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifc1"></a><dl>
<dt><a name="index-ifc1"></a>変数: <strong>ifc1</strong></dt>
<dd>
<p>(Ricci回転係数としても知られている)第一種標構係数。
このテンソルは
標構計量の第一種接続係数への寄与を表します。
以下のように定義されます:
</p>
<div class="example">
<pre class="example">
          - ifb      + ifb      + ifb
               c a b      b c a      a b c
ifc1    = --------------------------------
    abc                   2


</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifc2"></a><dl>
<dt><a name="index-ifc2"></a>変数: <strong>ifc2</strong></dt>
<dd>
<p>第二種標構係数。
このテンソルは標構計量の第一種接続係数への寄与を表します。
必要に応じて、標構ブラケット (<code>ifb</code>)の、
適切な上付き、下付き添字での置換として定義されます:
</p>
<div class="example">
<pre class="example">
    c       cd
ifc2   = ifg   ifc1
    ab             abd

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifr"></a><dl>
<dt><a name="index-ifr"></a>変数: <strong>ifr</strong></dt>
<dd>
<p>標枠。
標構計量(<code>ifg</code>)を形成するために
逆標構場 (<code>ifri</code>)を
縮約します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifri"></a><dl>
<dt><a name="index-ifri"></a>変数: <strong>ifri</strong></dt>
<dd>
<p>逆標構場。
(双対基底ベクトル)標構基底を指定します。
標構計量と一緒に、
標構に基づいた計算すべての基底を形成します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifg"></a><dl>
<dt><a name="index-ifg"></a>変数: <strong>ifg</strong></dt>
<dd>
<p>標構計量。
<code>kdelta</code>のデフォルトですが、
<code>components</code>を使って変えることができます。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fifgi"></a><dl>
<dt><a name="index-ifgi"></a>変数: <strong>ifgi</strong></dt>
<dd>
<p>逆標構計量。
標構計量 (<code>ifg</code>)を <code>kdelta</code>に縮約します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fiframe_005fbracket_005fform"></a><dl>
<dt><a name="index-iframe_005fbracket_005fform"></a>オプション変数: <strong>iframe_bracket_form</strong></dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p>標構ブラケット (<code>ifb</code>)が如何に計算されるか指定します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Torsion-and-nonmetricity"></a>
<h4 class="subsection">25.2.6 Torsion and nonmetricity</h4>

<p>Maximaは今では、ねじれと非計量性を考慮することができます。
フラグ <code>itorsion_flag</code>が <code>true</code>に設定されている時、
ねじれの寄与が
接続係数に加えられます。
同様に、
フラグ <code>inonmet_flag</code>が trueの時、
非計量性成分が含まれます。
</p>
<a name="Item_003a-Itensor_002fdefvr_002finm"></a><dl>
<dt><a name="index-inm"></a>変数: <strong>inm</strong></dt>
<dd>
<p>非計量性ベクトル。
共形非計量性は計量テンソルの共変微分を通して定義されます。
<code>inonmet_flag</code>が <code>true</code>に設定されている時
通常零の計量テンソルの共変微分は以下のように評価されます:
</p>
<div class="example">
<pre class="example">
g     =- g  inm
 ij;k     ij   k

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002finmc1"></a><dl>
<dt><a name="index-inmc1"></a>変数: <strong>inmc1</strong></dt>
<dd>
<p>非計量ベクトル成分の共変置換。
以下のように定義されます:
</p>
<div class="example">
<pre class="example">
           g   inm  - inm  g   - g   inm
            ab    c      a  bc    ac    b
inmc1    = ------------------------------
     abc                 2

</pre></div>

<p>(もし標構計量を使うなら、<code>ifg</code>を <code>g</code>に代入します。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002finmc2"></a><dl>
<dt><a name="index-inmc2"></a>変数: <strong>inmc2</strong></dt>
<dd>
<p>非計量ベクトル成分の反変置換。
もし <code>inonmet_flag</code>が <code>true</code>なら
接続係数で使われます。
以下のように定義されます:
</p>
<div class="example">
<pre class="example">
                      c         c         cd
          -inm  kdelta  - kdelta  inm  + g   inm  g
     c        a       b         a    b          d  ab
inmc2   = -------------------------------------------
     ab                        2

</pre></div>

<p>(もし標構計量を使うなら、<code>ifg</code>を <code>g</code>に代入します。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fikt1"></a><dl>
<dt><a name="index-ikt1"></a>変数: <strong>ikt1</strong></dt>
<dd>
<p>(コントーションとしても知られる)ねじれテンソルの共変置換。
以下のように定義されます:
</p>
<div class="example">
<pre class="example">
                  d           d       d
          -g   itr  - g    itr   - itr   g
            ad    cb    bd    ca      ab  cd
ikt1    = ----------------------------------
    abc                   2

</pre></div>

<p>(もし標構計量を使うなら、<code>ifg</code>を <code>g</code>に代入します。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fikt2"></a><dl>
<dt><a name="index-ikt2"></a>変数: <strong>ikt2</strong></dt>
<dd>
<p>(コントーションとしても知られる)ねじれテンソルの共変置換。
以下のように定義されます:
</p>
<div class="example">
<pre class="example">
    c     cd
ikt2   = g   ikt1
    ab           abd

</pre></div>

<p>(もし標構計量を使うなら、<code>ifg</code>を <code>g</code>に代入します。)
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002fitr"></a><dl>
<dt><a name="index-itr"></a>変数: <strong>itr</strong></dt>
<dd>
<p>ねじれテンソル。
以下の例で例示されるように、
ねじれを伴う計量に関してスカラー関数上の繰り返される共変微分は計算されません:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric:g;
(%o2)                                  g
(%i3) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i4) ishow(%)$
                                   %4              %2
(%t4)                    f    ichr2    - f    ichr2
                          ,%4      j i    ,%2      i j
(%i5) canform(%);
(%o5)                                  0
(%i6) itorsion_flag:true;
(%o6)                                true
(%i7) covdiff( covdiff( f( [], []), i), j)
                      - covdiff( covdiff( f( [], []), j), i)$
(%i8) ishow(%)$
                           %8             %6
(%t8)             f    icc2    - f    icc2    - f     + f
                   ,%8     j i    ,%6     i j    ,j i    ,i j
(%i9) ishow(canform(%))$
                                   %1             %1
(%t9)                     f    icc2    - f    icc2
                           ,%1     j i    ,%1     i j
(%i10) ishow(canform(ev(%,icc2)))$
                                   %1             %1
(%t10)                    f    ikt2    - f    ikt2
                           ,%1     i j    ,%1     j i
(%i11) ishow(canform(ev(%,ikt2)))$
                      %2 %1                    %2 %1
(%t11)          f    g      ikt1       - f    g      ikt1
                 ,%2            i j %1    ,%2            j i %1
(%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                           %3 %2            %1       %1
                     f    g      g      (itr    - itr   )
                      ,%3         %2 %1     j i      i j
(%t12)               ------------------------------------
                                      2
(%i13) decsym(itr,2,1,[anti(all)],[]);
(%o13)                               done
(%i14) defcon(g,g,kdelta);
(%o14)                               done
(%i15) subst(g,nounify(g),%th(3))$
(%i16) ishow(canform(contract(%)))$
                                           %1
(%t16)                           - f    itr
                                    ,%1    i j

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Exterior-algebra"></a>
<h4 class="subsection">25.2.7 Exterior algebra</h4>

<p><code>itensor</code>パッケージは
完全反対称共変テンソル場上の
演算を実行できます。
回数 (0,L)の完全反対称テンソル場は
微分L形式に対応します。
これらのオブジェクト上で、
外積やウェッジ積として知られる乗算が定義されます。
</p>
<p>不運にも、
すべての作者がウェッジ積の定義に同意しません。
何人の作者は反対称の概念に対応した定義を好みます:
これらの仕事では、
2つのベクトル場のウェッジ積は
例えば、以下のように定義されます。
</p>
<div class="example">
<pre class="example">            a a  - a a
             i j    j i
 a  /\ a  = -----------
  i     j        2
</pre></div>

<p>もっと一般的に、
p形式や q形式の積は以下のように定義されます。
</p>
<div class="example">
<pre class="example">                       1     k1..kp l1..lq
A       /\ B       = ------ D              A       B
 i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p>ここで、 <code>D</code>はKroneckerのデルタを表します。
</p>
<p>しかし、他の作者は容積要素の概念に対応する
&ldquo;幾何的&rdquo;定義を好みます:
</p>
<div class="example">
<pre class="example">a  /\ a  = a a  - a a
 i     j    i j    j i
</pre></div>

<p>そいて、一般的な場合，
</p>
<div class="example">
<pre class="example">                       1    k1..kp l1..lq
A       /\ B       = ----- D              A       B
 i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq
</pre></div>

<p><code>itensor</code>はテンソル代数パッケージなので、
これら2つの定義の前者がより自然なもののようです。
しかし、多くの応用は後者の定義を使います。
このジレンマを解決するに、
ウェッジ積の振る舞いを制御するフラグが実装されました:
もし <code>igeowedge_flag</code>が <code>false</code> (デフォルト)なら、
前者の &quot;テンソル的&quot;定義が使われ、
層でないなら，後者の&quot;幾何的&quot;定義が適用されます。
</p>
<a name="Item_003a-Itensor_002fdefvr_002f_007e"></a><dl>
<dt><a name="index-_007e"></a>演算子: <strong>~</strong></dt>
<dd>
<p>ウェッジ積演算子は
ティルデ <code>~</code>で示されれます。
これは二項演算子です。
引数は、
スカラ、階数1の共変テンソル、
共変添字すべてに関して反対称と宣言された階数 <code>l</code>の共変テンソルを含む式
でなければいけません。
</p>
<p>以下の例のように、
ウェッジ積演算子の振る舞いは
<code>igeowedge_flag</code>
フラグで制御されます:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(a([i])~b([j]))$
                                 a  b  - b  a
                                  i  j    i  j
(%t2)                            -------------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(a([i,j])~b([k]))$
                          a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
(%t4)                     ---------------------------
                                       3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(a([i])~b([j]))$
(%t6)                            a  b  - b  a
                                  i  j    i  j
(%i7) ishow(a([i,j])~b([k]))$
(%t7)                     a    b  + b  a    - a    b
                           i j  k    i  j k    i k  j
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;<a href="maxima_311.html#Category_003a-Operators">Operators</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002f_007c"></a><dl>
<dt><a name="index-_007c"></a>演算子: <strong>|</strong></dt>
<dd>
<p>縦線 <code>|</code>は
&quot;ベクトルの縮約&quot;二項演算子を示します。
完全反対称共変テンソルが反変ベクトルと縮約される時、
結果は、どの添字が縮約に使われるかに関わらず同じです。
このように、
添字に無関係な方法で縮約演算子を定義することが可能です。
</p>
<p><code>itensor</code>パッケージでは、
ベクトルとの縮約は常に
文字通りの並べ順で最初の添字に対して実行されます。
これは
<code>|</code>演算子を含む式のより良い整理を保証します。
例えば:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) decsym(a,2,0,[anti(all)],[]);
(%o2)                                done
(%i3) ishow(a([i,j],[])|v)$
                                    %1
(%t3)                              v   a
                                        %1 j
(%i4) ishow(a([j,i],[])|v)$
                                     %1
(%t4)                             - v   a
                                         %1 j
</pre></div>

<p><code>|</code>演算子で使われるテンソルは
は共変添字に対して完全反対称と宣言されなければいけないことが
本質的であることに注意してください。
そうでないなら、結果は正しくありません。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;<a href="maxima_311.html#Category_003a-Operators">Operators</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fextdiff"></a><dl>
<dt><a name="index-extdiff"></a>関数: <strong>extdiff</strong> <em>(<var>expr</var>, <var>i</var>)</em></dt>
<dd>
<p>添字 <var>i</var>に対する
<var>expr</var>の外積を計算します。
外微分は形式的に
偏微分演算子のウェッジ積で微分形式として定義されます。
そんなように、
演算子も
<code>igeowedge_flag</code>の設定で制御されます。
例えば:
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) ishow(extdiff(v([i]),j))$
                                  v    - v
                                   j,i    i,j
(%t2)                             -----------
                                       2
(%i3) decsym(a,2,0,[anti(all)],[]);
(%o3)                                done
(%i4) ishow(extdiff(a([i,j]),k))$
                           a      - a      + a
                            j k,i    i k,j    i j,k
(%t4)                      ------------------------
                                      3
(%i5) igeowedge_flag:true;
(%o5)                                true
(%i6) ishow(extdiff(v([i]),j))$
(%t6)                             v    - v
                                   j,i    i,j
(%i7) ishow(extdiff(a([i,j]),k))$
(%t7)                    - (a      - a      + a     )
                             k j,i    k i,j    j i,k

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdeffn_002fhodge"></a><dl>
<dt><a name="index-hodge"></a>関数: <strong>hodge</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p><var>expr</var>のHodge双対を計算します。
例えば:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) imetric(g);
(%o2)                            done
(%i3) idim(4);
(%o3)                            done
(%i4) icounter:100;
(%o4)                             100
(%i5) decsym(A,3,0,[anti(all)],[])$

(%i6) ishow(A([i,j,k],[]))$
(%t6)                           A
                                 i j k
(%i7) ishow(canform(hodge(%)))$
                          %1 %2 %3 %4
               levi_civita            g        A
                                       %1 %102  %2 %3 %4
(%t7)          -----------------------------------------
                                   6
(%i8) ishow(canform(hodge(%)))$
                 %1 %2 %3 %8            %4 %5 %6 %7
(%t8) levi_civita            levi_civita            g       
                                                     %1 %106
                             g        g        g      A         /6
                              %2 %107  %3 %108  %4 %8  %5 %6 %7
(%i9) lc2kdt(%)$

(%i10) %,kdelta$

(%i11) ishow(canform(contract(expand(%))))$
(%t11)                     - A
                              %106 %107 %108

</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Item_003a-Itensor_002fdefvr_002figeowedge_005fflag"></a><dl>
<dt><a name="index-igeowedge_005fflag"></a>オプション変数: <strong>igeowedge_flag</strong></dt>
<dd><p>デフォルト値: <code>false</code>
</p>
<p>ウェッジ積と外微分の振る舞いを制御します。
<code>false</code> (デフォルト)に設定された時、
微分形式の概念は
完全反対称共変テンソル場のそれに対応します。
<code>true</code>に設定された時、
微分形式は容積要素の概念に一致します。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;</div></dd></dl>

<a name="Exporting-TeX-expressions"></a>
<h4 class="subsection">25.2.8 Exporting TeX expressions</h4>

<p><code>itensor</code>パッケージは
テンソル式をTexにエクスポートするための限定サポートを提供します。
<code>itensor</code>式は関数コールとして現れるので、
いつもの Maxima <code>tex</code>コマンドは
期待された出力を生成しません。
代わりに<code>tentex</code>コマンドを試すことができます。
これは、テンソル式を適切に添字が付けられたTeXオブジェクトに翻訳しようとします。
</p>
<a name="Item_003a-Itensor_002fdeffn_002ftentex"></a><dl>
<dt><a name="index-tentex"></a>関数: <strong>tentex</strong> <em>(<var>expr</var>)</em></dt>
<dd>
<p>以下の例のように、
<code>tentex</code>関数を使うには、
最初に<code>tentex</code>をロードしなければいけません:
</p>
<div class="example">
<pre class="example">
(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) load(&quot;tentex&quot;);
(%o2)       /share/tensor/tentex.lisp
(%i3) idummyx:m;
(%o3)                                  m
(%i4) ishow(icurvature([j,k,l],[i]))$
            m1       i           m1       i           i
(%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
            j k      m1 l        j l      m1 k        j l,k

                                                      i
                                               + ichr2
                                                      j k,l
(%i5) tentex(%)$
$$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
 \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$
</pre></div>

<p>コンパイルエラーに導かれるTeX式でのパーセント符号の出現を避けるための、
<code>idummyx</code>割り当ての使用に注意してください。
</p>
<p>注意せよ: このバージョンの<code>tentex</code>関数は幾分実験的です。
</p>
<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;<a href="maxima_311.html#Category_003a-TeX-output">TeX output</a>
&middot;</div></dd></dl>

<a name="Interfacing-with-ctensor"></a>
<h4 class="subsection">25.2.9 Interfacing with ctensor</h4>

<p><code>itensor</code>パッケージは
<code>ctensor</code>パッケージの文脈で実行することができる
Maximaコードを生成する能力があります。
この仕事を実行する関数は <code>ic_convert</code>です。
</p>
<a name="Item_003a-Itensor_002fdeffn_002fic_005fconvert"></a><dl>
<dt><a name="index-ic_005fconvert"></a>関数: <strong>ic_convert</strong> <em>(<var>eqn</var>)</em></dt>
<dd>
<p><code>itensor</code>方程式 <var>eqn</var>を
<code>ctensor</code>割り当て文に変換します。
添字付きオブジェクトが配列に変換される一方で、
ダミー添字上の暗黙の和は明示的にされます。
</p>
<p>(配列下付き添字は添字付きオブジェクトの反変添字が続く共変の順です。)
添字付きオブジェクトの微分は、
微分添字で下に添えられた <code>ct_coords</code>に対して取られる <code>diff</code>の名詞形に
置き換えられます。
Christoffel記号 <code>ichr1</code>と <code>ichr2</code>は
それぞれ、<code>lcs</code>と <code>mcs</code>に翻訳されます。
もし <code>metricconvert</code>が <code>true</code>なら、
2つの共変(反変)添字を持つ計量はすべて
<code>lg</code> (<code>ug</code>)にリネームされます。
更に、 自由添字すべての上で足される<code>do</code>ループが導入されます。
なので、
ただ <code>ev</code>するだけで
変換される割り当て分を評価することができます。
以下の例はこの関数の特長を例示します。
</p>
<div class="example">
<pre class="example">(%i1) load(&quot;itensor&quot;);
(%o1)      /share/tensor/itensor.lisp
(%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
      *b([i],[l,k]))$
                             k        m   l k
(%t2)                       t    = f a   b    g
                             i j      ,j  i    l m
(%i3) ic_convert(eqn);
(%o3) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 g    , l, 1, dim), m, 1, dim)))
  l, m
(%i4) imetric(g);
(%o4)                                done
(%i5) metricconvert:true;
(%o5)                                true
(%i6) ic_convert(eqn);
(%o6) for i thru dim do (for j thru dim do (
       for k thru dim do
        t        : f sum(sum(diff(a , ct_coords ) b
         i, j, k                   m           j   i, l, k

 lg    , l, 1, dim), m, 1, dim)))
   l, m
</pre></div>

<div class=categorybox>
<a href="maxima_311.html#Category_003a-Package-itensor">Package itensor</a>
&middot;<a href="maxima_311.html#Category_003a-Package-ctensor">Package ctensor</a>
&middot;</div></dd></dl>

<a name="Reserved-words"></a>
<h4 class="subsection">25.2.10 Reserved words</h4>

<p>以下の Maximaワードは <code>itensor</code>パッケージで内部的に使われているので、
再定義してはいけません:
</p>
<div class="example">
<pre class="example">  Keyword    Comments
  ------------------------------------------
  indices2() Internal version of indices()
  conti      Lists contravariant indices
  covi       Lists covariant indices of a indexed object
  deri       Lists derivative indices of an indexed object
  name       Returns the name of an indexed object
  concan
  irpmon
  lc0
  _lc2kdt0
  _lcprod
  _extlc
</pre></div>


<hr>
<div class="header">
<p>
Previous: <a href="maxima_117.html#Introduction-to-itensor" accesskey="p" rel="previous">Introduction to itensor</a>, Up: <a href="maxima_116.html#itensor" accesskey="u" rel="up">itensor</a> &nbsp; [<a href="maxima_toc.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="maxima_307.html#Function-and-Variable-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
