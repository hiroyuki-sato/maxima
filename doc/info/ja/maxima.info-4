This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Functions and Variables for itensor,  Prev: Introduction to itensor,  Up: itensor

25.2 Functions and Variables for itensor
========================================

25.2.1 Managing indexed objects
-------------------------------

 -- 関数: dispcon (<tensor_1>, <tensor_2>, ...)
 -- 関数: dispcon (all)

     ‘defcon’に与えられたような引数の縮約プロパティを表示します。
     ‘dispcon (all)’は、定義された縮約プロパティすべてを表示します。

 -- 関数: entertensor (<name>)

     プロンプトによって、 任意の数のテンソル添字や微分添字を持つ<name>と
     呼ばれる添字付きオブジェクトを生成することを許す関数です。 単一添字
     または(nullもありえる)添字のリストが容認可能な入力です。
     (‘covdiff’の下の例を参照してください。)

 -- 関数: changename (<old>, <new>, <expr>)

     <expr>の中の<old>と呼ばれるすべての添字付きオブジェクトの名前を
     <new>に変えます。 <old>はシンボルまたは形式‘[<name>, <m>, <n>]’のリ
     ストであり得ます。 後者の場合、<m>個の共変添字と<n>個の反変添字を持
     つ <name>と呼ばれるそれらの添字付きオブジェクトだけが<new>にリネー
     ムされます。

 -- 関数: listoftens

     テンソル式の中のすべてのテンソルを添字が完備した形でリストします。
     例えば、


          (%i6) ishow(a([i,j],[k])*b([u],[],v)+c([x,y],[])*d([],[])*e)$
                                                   k
          (%t6)                        d e c    + a    b
                                            x y    i j  u,v
          (%i7) ishow(listoftens(%))$
                                         k
          (%t7)                        [a   , b   , c   , d]
                                         i j   u,v   x y

 -- 関数: ishow (<expr>)

     下付き添字としての共変添字と上付き添字としての反変添字を持つように
     添字付きオブジェクトを持つ形で<expr>を表示します。 微分添字は、共変
     添字からコンマで区切られた下付き添字として表示されます。 (このドキ
     ュメント至る所の例を参照してください。)

 -- 関数: indices (<expr>)

     2つの要素のリストを返します。 以下の例が例示するように、 一番目は、
     <expr>の中の自由添字(一度だけ現れるもの)のリストです。 二番目は、
     <expr>の中のダミー添字(正確に二回現れるもの)のリストです。


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i,j],[k,l],m,n)*b([k,o],[j,m,p],q,r))$
                                          k l      j m p
          (%t2)                          a        b
                                          i j,m n  k o,q r
          (%i3) indices(%);
          (%o3)                 [[l, p, i, n, o, q, r], [k, j, m]]

     同じ添字を二回以上含むテンソル積は構文的に認められていません。
     ‘indices’は、これらの式を合理的な方法で扱おうとします; しかしながら
     、そんな非合法な式上で動くようにコールされた時、その振る舞いは未定
     義と考えなければいけません。

 -- 関数: rename (<expr>)
 -- 関数: rename (<expr>, <count>)

     もしオプションの二番目の引数が省略されたら、 <expr>と同値な、 しか
     し、各項に対して、集合‘[%1, %2,...]’から選ばれたダミー添字を持つ式
     を返します。 そうでなければ、ダミー添字は<count>の値で始まるようイ
     ンデックスされます。 積の中のそれぞれのダミー添字は異なります。 和
     に関しては、‘rename’は各項毎にカウンタが再設定されるように和の中の
     各項上で作用します。 この方法で、‘rename’はテンソル整理器として利用
     できます。 加えて、 (もし‘allsym’が‘true’なら、) 添字は、
     ‘flipflag’の値に依存して共変または反変添字に関して、 英数字順に並び
     替えられます。 もし‘flipflag’が‘false’なら、 添字は反変添字の順に従
     ってリネームされます。 もし‘flipflag’が‘true’なら、 リネームは共変
     添字の順に従って起こるでしょう。 ２つのリネームの組み合わせた効果が
     、それ自身によって、 どちらか１つよりも更に式を簡単にすることがしば
     しば起こります。


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) allsym:true;
          (%o2)                                true
          (%i3) g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%4],[%3])*
          ichr2([%2,%3],[u])*ichr2([%5,%6],[%1])*ichr2([%7,r],[%2])-
          g([],[%4,%5])*g([],[%6,%7])*ichr2([%1,%2],[u])*
          ichr2([%3,%5],[%1])*ichr2([%4,%6],[%3])*ichr2([%7,r],[%2]),noeval$
          (%i4) expr:ishow(%)$
                 %4 %5  %6 %7      %3         u          %1         %2
          (%t4) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %4      %2 %3      %5 %6      %7 r

                  %4 %5  %6 %7      u          %1         %3         %2
               - g      g      ichr2      ichr2      ichr2      ichr2
                                    %1 %2      %3 %5      %4 %6      %7 r
          (%i5) flipflag:true;
          (%o5)                                true
          (%i6) ishow(rename(expr))$
                 %2 %5  %6 %7      %4         u          %1         %3
          (%t6) g      g      ichr2      ichr2      ichr2      ichr2
                                   %1 %2      %3 %4      %5 %6      %7 r

                  %4 %5  %6 %7      u          %1         %3         %2
               - g      g      ichr2      ichr2      ichr2      ichr2
                                    %1 %2      %3 %4      %5 %6      %7 r
          (%i7) flipflag:false;
          (%o7)                                false
          (%i8) rename(%th(2));
          (%o8)                                  0
          (%i9) ishow(rename(expr))$
                 %1 %2  %3 %4      %5         %6         %7        u
          (%t9) g      g      ichr2      ichr2      ichr2     ichr2
                                   %1 %6      %2 %3      %4 r      %5 %7

                  %1 %2  %3 %4      %6         %5         %7        u
               - g      g      ichr2      ichr2      ichr2     ichr2
                                    %1 %3      %2 %6      %4 r      %5 %7

 -- 関数: show (<expr>)
     下付き添字として共変インデックス、上付き添字として反変インデックス
     を持つよう、 インデックスされたオブジェクトと一緒に‘expr’を表示しま
     す。 微分インデックスは下付き添字として表示され、 コンマによって共
     変インデックスと区別されます。

 -- オプション変数: flipflag

     デフォルト: ‘false’. もし‘false’なら反変添字の順に従って、 そうでな
     ければ、共変添字の順に従って、 添字がリネームされます。

     もし‘flipflag’が‘false’なら、 ‘rename’は 左から右に現れるよう反変添
     字のリストを形成します (もし‘true’なら共変添字について同様に)。 リ
     ストの最初のダミー添字は‘%1’に、次は‘%2’にというように、リネームさ
     れます。 そして、‘rename’の後、並び替えが起こります。 (‘rename’の下
     の例を参照してください。)

 -- 関数: defcon (<tensor_1>)
 -- 関数: defcon (<tensor_1>, <tensor_2>, <tensor_3>)
     <tensor_1>に、 <tensor_1>と<tensor_2>の積の縮約が 適切な添字を持つ
     <tensor_3>に帰着するという プロパティを与えます。 もし引数が
     <tensor_1>１つだけ与えれたなら、 , then the contraction of the
     product of 適切な添字を持つ任意の添字付きオブジェクト(‘my_tensor’と
     します)との<tensor_1>の積の縮約はその名前、すなわち、‘my_tensor’と
     、実行された縮約を反映した添字の新しい集合を持つ添字付きオブジェク
     トをもたらします。 例えば、もし‘imetric:g’なら、‘defcon(g)’は 計量
     テンソルとの縮約を通して添字の上げ下げを実行します。 １つ以上の
     ‘defcon’を同じ添字付きオブジェクトに関して与えることができます; 特
     定の縮約に関して適用する最新のものが使われます。 ‘contractions’は、
     ‘defcon’で縮約プロパティを与えられたそれら添字付きオブジェクトのリ
     ストです。

 -- 関数: remcon (<tensor_1>, ..., <tensor_n>)
 -- 関数: remcon (all)
     <tensor_1>, ..., <tensor_n>からすべての縮約プロパティを取り除きます
     。 ‘remcon(all)’は、すべての添字付きオブジェクトから すべての縮約プ
     ロパティを取り除きます。

 -- 関数: contract (<expr>)

     和と積の任意の組み合わせであり得る <expr>に関して テンソル縮約を実
     行します。 この関数は ‘defcon’関数に与えられた情報を使います。 最高
     の結果として、 ‘expr’は完全に展開されなければいけません。 もし項の
     分母の中に変数がないなら、 ‘ratexpand’は 和の積やべきを展開する 最
     速の方法です。 もしGCD消去が不要なら、 ‘gcd’スイッチは‘false’でなけ
     ればいけません。

 -- 関数: indexed_tensor (<tensor>)

     値に関する美しい姿が既に ‘ichr1’, ‘ichr2’, ‘icurvature’とともにある
     ように存在する <tensor>に成分を割り当てる前に実行されなければいけま
     せん。 ‘icurvature’の下の例を参照してください。

 -- 関数: components (<tensor>, <expr>)

     <tensor>の成分の値を与える式<expr>に添字値を割り当てることを許しま
     す。 その添字のすべてとともに起こるときはいつでも、これらは自動的に
     テンソルに代入されます。 テンソルは、形式‘t([...],[...])’でなければ
     いけません。 ここで形式‘t([...],[...])’の中のリストのいずれかは空で
     あり得えます。 <expr>は、 <tensor>と同じ自由添字を持つ他のオブジェ
     クトを含む任意の添字付き式であり得ます。 成分がダミー添字を含む計量
     テンソルへ値を割り当てるのに使われる時、 複数のダミー添字の生成を避
     けるようにこれらの添字を定義するように注意しなければいけません。 こ
     の割り当ての削除は関数‘remcomps’に与えられます。

     It is important to keep in mind that ‘components’はテンソル価につい
     てだけ知る必要があり、特別な添字順序について知る必要がないことを覚
     えておくことは重要です。 このように、成分を、例えば、
     ‘x([i,-j],[])’, ‘x([-j,i],[])’または ‘x([i],[j])’すべてに割り当てる
     ことは、同じ結果、 すなわち、 価‘(1,1)’を持つ‘x’と名付けられたテン
     ソルに割り当てられた 成分を生成します。

     成分を、4つの方法で添字付き式に割り当てることができます。 そのうち
     の2つは‘components’コマンドの使用を含みます:

     1) 添字付き式として。例えば:

          (%i2) components(g([],[i,j]),e([],[i])*p([],[j]))$
          (%i3) ishow(g([],[i,j]))$
                                                i  j
          (%t3)                                e  p

     2) 行列として:


          (%i5) lg:-ident(4)$lg[1,1]:1$lg;
                                      [ 1   0    0    0  ]
                                      [                  ]
                                      [ 0  - 1   0    0  ]
          (%o5)                       [                  ]
                                      [ 0   0   - 1   0  ]
                                      [                  ]
                                      [ 0   0    0   - 1 ]
          (%i6) components(g([i,j],[]),lg);
          (%o6)                                done
          (%i7) ishow(g([i,j],[]))$
          (%t7)                                g
                                                i j
          (%i8) g([1,1],[]);
          (%o8)                                  1
          (%i9) g([4,4],[]);
          (%o9)                                 - 1

     3) 関数として。Maxima関数を使って、添字に基づいたテンソルの成分を指
     定することができます。 例えば、以下のコードは、 もし‘h’が同じ数の共
     変添字と反変添字を持ち、微分添字を持たないなら、‘kdelta’を‘h’に割り
     当て、そうでなければ、‘g’を割り当てます:


          (%i4) h(l1,l2,[l3]):=if length(l1)=length(l2) and length(l3)=0
            then kdelta(l1,l2) else apply(g,append([l1,l2], l3))$
          (%i5) ishow(h([i],[j]))$
                                                    j
          (%t5)                               kdelta
                                                    i
          (%i6) ishow(h([i,j],[k],l))$
                                               k
          (%t6)                               g
                                               i j,l

     4) Maximaのパターンマッチング機能、特に‘defrule’と‘applyb1’コマンド
     を使って:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) matchdeclare(l1,listp);
          (%o2)                                done
          (%i3) defrule(r1,m(l1,[]),(i1:idummy(),
                g([l1[1],l1[2]],[])*q([i1],[])*e([],[i1])))$

          (%i4) defrule(r2,m([],l1),(i1:idummy(),
                w([],[l1[1],l1[2]])*e([i1],[])*q([],[i1])))$

          (%i5) ishow(m([i,n],[])*m([],[i,m]))$
                                              i m
          (%t5)                              m    m
                                                   i n
          (%i6) ishow(rename(applyb1(%,r1,r2)))$
                                     %1  %2  %3 m
          (%t6)                     e   q   w     q   e   g
                                                   %1  %2  %3 n

 -- 関数: remcomps (<tensor>)

     ‘components’関数で割り当てられたすべての値を <tensor>からアンバイン
     ドします。

 -- 関数: showcomps (<tensor>)

     ‘components’コマンドを使って作られたように テンソルの成分割り当てを
     表示します。 以下の例で明示されるように、 行列が、‘components’を使
     って 添字テンソルに割り当てられている時、 この関数は特に役に立ちま
     す:


          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) load("itensor");
          (%o2)      /share/tensor/itensor.lisp
          (%i3) lg:matrix([sqrt(r/(r-2*m)),0,0,0],[0,r,0,0],
                          [0,0,sin(theta)*r,0],[0,0,0,sqrt((r-2*m)/r)]);
                         [         r                                     ]
                         [ sqrt(-------)  0       0              0       ]
                         [      r - 2 m                                  ]
                         [                                               ]
                         [       0        r       0              0       ]
          (%o3)          [                                               ]
                         [       0        0  r sin(theta)        0       ]
                         [                                               ]
                         [                                      r - 2 m  ]
                         [       0        0       0        sqrt(-------) ]
                         [                                         r     ]
          (%i4) components(g([i,j],[]),lg);
          (%o4)                                done
          (%i5) showcomps(g([i,j],[]));
                            [         r                                     ]
                            [ sqrt(-------)  0       0              0       ]
                            [      r - 2 m                                  ]
                            [                                               ]
                            [       0        r       0              0       ]
          (%t5)      g    = [                                               ]
                      i j   [       0        0  r sin(theta)        0       ]
                            [                                               ]
                            [                                      r - 2 m  ]
                            [       0        0       0        sqrt(-------) ]
                            [                                         r     ]
          (%o5)                                false

     ‘showcomps’コマンドは 2よりも高い階数のテンソルの成分も表示すること
     ができます。

 -- 関数: idummy ()

     Increments ‘icounter’を1つ増やし、 形式‘%n’の添字を値として返します
     。ここでnは正の整数です。 これは式を形成する際必要なダミー添字が既
     に使用中の添字とぶつからないことを保証します。 (‘indices’の下の例を
     参照してください。)

 -- オプション変数: idummyx
     デフォルト値: ‘%’

     ダミー添字の接頭辞です。 (‘indices’の下の例を参照してください。)

 -- オプション変数: icounter
     デフォルト値: ‘1’

     テンソルパッケージで次のダミー添字を生成する際使われる数値接尾を決
     定します。 接頭辞はオプション‘idummy’ (デフォルト: ‘%’)で決定されま
     す。

 -- 関数: kdelta (<L1>, <L2>)
     共変添字のリスト<L1>と反変添字のリスト<L2>を使って ‘itensor’パッケ
     ージで定義された 一般化されたKroneckerのデルタ関数です。
     ‘kdelta([i],[j])’は通常のKroneckerデルタを返します。 コマンド
     ‘ev(<expr>,kdelta)’は ‘kdelta([],[])’を多様体の次元に含む 式の評価
     をもたらします。

     この表記法の乱用となることですが、 ‘itensor’は ‘kdelta’が2つの共変
     添字だけ、または、2つの反変添字だけを持つことも許し、 事実上、共(反
     )変「単位行列」を供給します。 これは厳密にはプログラミング目的とし
     てみなされ、 ‘kdelta([i,j],[])’が有効なテンソルオブジェクトだという
     ことを意味するつもりではありません。

 -- 関数: kdels (<L1>, <L2>)

     いくつかの計算で使われる、対称化されたKroneckerデルタ。 例えば:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) kdelta([1,2],[2,1]);
          (%o2)                                 - 1
          (%i3) kdels([1,2],[2,1]);
          (%o3)                                  1
          (%i4) ishow(kdelta([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  - kdelta  kdelta
                                       a       b         a       b
          (%i4) ishow(kdels([a,b],[c,d]))$
                                       c       d         d       c
          (%t4)                  kdelta  kdelta  + kdelta  kdelta
                                       a       b         a       b

 -- 関数: levi_civita (<L>)
     もしリスト<L>が整数の偶置換から成るなら1を返し、 <L>が奇置換なら成
     るなら-1を返し、 <L>のいくつかの添字が繰り返しなら0を返す 置換(別名
     Levi-Civita)テンソルです。

 -- 関数: lc2kdt (<expr>)
     Levi-Civitaシンボルを含む式を整理し、可能ならこれらをKroneckerデル
     タ式に変換します。 この関数と単にLevi-Civitaシンボルを評価すること
     の主な違いは、 直接評価はしばしば数値添字を含むKronecker式に帰着す
     ることです。 これは、更なる整理を妨げるので、しばしば望ましくないこ
     とです。 ‘lc2kdt’関数はこの問題を避けて、 ‘rename’や‘contract’を使
     って更に容易に整理される式をもたらします。


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:ishow('levi_civita([],[i,j])
                           *'levi_civita([k,l],[])*a([j],[k]))$
                                            i j  k
          (%t2)                  levi_civita    a  levi_civita
                                                 j            k l
          (%i3) ishow(ev(expr,levi_civita))$
                                            i j  k       1 2
          (%t3)                       kdelta    a  kdelta
                                            1 2  j       k l
          (%i4) ishow(ev(%,kdelta))$
                       i       j         j       i   k
          (%t4) (kdelta  kdelta  - kdelta  kdelta ) a
                       1       2         1       2   j

                                         1       2         2       1
                                  (kdelta  kdelta  - kdelta  kdelta )
                                         k       l         k       l
          (%i5) ishow(lc2kdt(expr))$
                               k       i       j    k       j       i
          (%t5)               a  kdelta  kdelta  - a  kdelta  kdelta
                               j       k       l    j       k       l
          (%i6) ishow(contract(expand(%)))$
                                           i           i
          (%t6)                           a  - a kdelta
                                           l           l

     ‘lc2kdt’関数は時々計量テンソルを利用します。 もし前もって計量テンソ
     ルが‘imetric’で定義されていなかったなら、 これはエラーになります。


          (%i7) expr:ishow('levi_civita([],[i,j])
                           *'levi_civita([],[k,l])*a([j,k],[]))$
                                           i j            k l
          (%t7)                 levi_civita    levi_civita    a
                                                               j k
          (%i8) ishow(lc2kdt(expr))$
          Maxima encountered a Lisp error:

           Error in $IMETRIC [or a callee]:
           $IMETRIC [or a callee] requires less than two arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i9) imetric(g);
          (%o9)                                done
          (%i10) ishow(lc2kdt(expr))$
                   %3 i       k   %4 j       l     %3 i       l   %4 j
          (%t10) (g     kdelta   g     kdelta   - g     kdelta   g
                              %3             %4               %3
                        k
                  kdelta  ) a
                        %4   j k
          (%i11) ishow(contract(expand(%)))$
                                            l i    l i  j
          (%t11)                           a    - g    a
                                                        j

 -- 関数: lc_l

     未評価のLevi-Civitaシンボル(‘levi_civita’)を含む式のために使われる
     整理ルール。 ‘lc_u’と組み合わせて、 たくさんの式を、‘levi_civita’の
     評価より、より効率的に整理するのに使うことができます。

     例えば:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) el1:ishow('levi_civita([i,j,k],[])*a([],[i])*a([],[j]))$
                                       i  j
          (%t2)                       a  a  levi_civita
                                                       i j k
          (%i3) el2:ishow('levi_civita([],[i,j,k])*a([i])*a([j]))$
                                                 i j k
          (%t3)                       levi_civita      a  a
                                                        i  j
          (%i4) canform(contract(expand(applyb1(el1,lc_l,lc_u))));
          (%t4)                                  0
          (%i5) canform(contract(expand(applyb1(el2,lc_l,lc_u))));
          (%t5)                                  0

 -- 関数: lc_u

     未評価のLevi-Civitaシンボル(‘levi_civita’)を含む式のために使われる
     整理ルール。 ‘lc_l’と組み合わせて、 たくさんの式を、‘levi_civita’の
     評価より、より効率的に整理するのに使うことができます。 詳しくは、
     ‘lc_l’を参照してください。

 -- 関数: canten (<expr>)
     名前を変えて(‘rename’を参照してください)、ダミー添字を置換すること
     で、 <expr>を整理します。 ‘rename’は 微分がないテンソル積の和に制限
     されます。 本当に限定されていて、 もし‘canform’が要求された整理を実
     行する能力がない時だけ使われるはずです。

     ‘canten’関数は、 引数が添字が完全に対称な式の時だけ数学的に正確な結
     果を返します。 この理由から、‘canten’は、 もし‘allsym’が‘true’に設
     定されてないなら エラーを返します。

 -- 関数: concan (<expr>)
     ‘canten’に似ていますが、添字縮約も実行します。

25.2.2 Tensor symmetries
------------------------

 -- オプション変数: allsym

     デフォルト: ‘false’。 もし‘true’なら、すべての添字付きオブジェクト
     は共変、反変添字のすべてに関して対称と仮定されます。 もし‘false’な
     ら、これらの添字に関して、いかなる種類の対称性も仮定されません。
     ‘iframe_flag’が‘true’に設定されない限り、 微分添字はいつも対称と取
     られます。

 -- 関数: decsym (<tensor>, <m>, <n>, [<cov_1>, <cov_2>, ...],
          [<contr_1>, <contr_2>, ...])

     <m>個の共変添字と<n>個の反変添字を持つ<tensor>に関する 対称プロパテ
     ィを宣言します。 <cov_i>と<contr_i>は それぞれ、共変添字と反変添字
     の間の対称関係を表す擬似関数です。 これらは contravariant indices
     respectively.  These are of the form 形式‘symoper(<index_1>,
     <index_2>,...)’を取ります。 ここで‘symoper’は ‘sym’, ‘anti’もしくは
     ‘cyc’のいずれかで、 and the <index_i>は <tensor>の添字の位置を示す
     整数です。 これは、<tensor>が<index_i>に関してそれぞれ対称、反対称
     、巡回であると宣言します。 ‘symoper(all)’も対称条件に従う添字すべて
     を示す有効な形式です。 例えば、 5つの共変添字を持つオブジェクト
     ‘b’が与えられたとして、
     ‘decsym(b,5,3,[sym(1,2),anti(3,4)],[cyc(all)])’は、 ‘b’が一番目と二
     番目の共変添字に対して対称であり、三番目、四番目の共変添字に対して
     反対称であり、反変添字すべてに対して巡回的であると宣言します。 対称
     宣言のリストのどれかは空であり得ます。 式整理を実行する関数は 以下
     の例で示すように‘canform’です。


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) expr:contract( expand( a([i1, j1, k1], [])
                     *kdels([i, j, k], [i1, j1, k1])))$
          (%i3) ishow(expr)$
          (%t3)         a      + a      + a      + a      + a      + a
                         k j i    k i j    j k i    j i k    i k j    i j k
          (%i4) decsym(a,3,0,[sym(all)],[]);
          (%o4)                                done
          (%i5) ishow(canform(expr))$
          (%t5)                              6 a
                                                i j k
          (%i6) remsym(a,3,0);
          (%o6)                                done
          (%i7) decsym(a,3,0,[anti(all)],[]);
          (%o7)                                done
          (%i8) ishow(canform(expr))$
          (%t8)                                  0
          (%i9) remsym(a,3,0);
          (%o9)                                done
          (%i10) decsym(a,3,0,[cyc(all)],[]);
          (%o10)                               done
          (%i11) ishow(canform(expr))$
          (%t11)                        3 a      + 3 a
                                           i k j      i j k
          (%i12) dispsym(a,3,0);
          (%o12)                     [[cyc, [[1, 2, 3]], []]]

 -- 関数: remsym (<tensor>, <m>, <n>)
     <m>個の共変添字と<n>個の反変添字を持つ<tensor>から すべての対称プロ
     パティを取り除きます。

 -- 関数: canform (<expr>)
 -- 関数: canform (<expr>, <rename>)
     ダミー添字をリネームして、 それらに課せられた対称条件によって指令さ
     れたようにすべての添字を並べ替えることで、 <expr>を整理します。 も
     し‘allsym’が‘true’なら、 すべての添字は対称と仮定され、 そうでなけ
     れば、‘decsym’宣言が提供する対称情報が使われます。 ダミー添字は
     ‘rename’関数に関するものと同じ方法でリネームされます。 ‘canform’が
     大きな式に適用される時、 計算にかなりの時間が費やされるかもしれませ
     ん。 この時間は最初に式に対して‘rename’をコールすることで短くできま
     す。 ‘decsym’の下の例も参照してください。 注意: ‘canform’は いつも
     数学的に正しい結果を返しますが、 式を最も簡単な形式に完全に整理でき
     ないかもしれません。

     オプションの二番目のパラメータ<rename>は、 もし‘false’に設定された
     なら、リネームを抑制します。

25.2.3 Indicial tensor calculus
-------------------------------

 -- 関数: diff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])

     ‘itensor’のための能力に関して拡張された 通常のMaxima微分関数です。
     It takes the derivative of <v_1>に関して <n_1>階、 <v_2>に関して
     <n_2>階、 という<expr>の微分を取ります。 テンソルパッケージでは、
     <v_i>が1から変数 ‘dim’の値までの整数であるように 関数が修正されてい
     ます。 これによって、 微分がリスト ‘vect_coords’の <v_i>番目の要素
     に関して実行されます。 もし ‘vect_coords’がアトム変数にバインドされ
     ているなら、 <v_i>が下付きしたその変数が 微分変数として使われます。
     これは 座標名や、‘x[1]’, ‘x[2]’, ... のような下付き名の配列を使うこ
     とを可能にします。

     更なる拡張は、 添字付き変数に関する微分を計算する能力を‘diff’に追加
     します。 特にテンソルパッケージは 計量テンソルと、計量テンソルやそ
     の一階微分、二階微分に関する微分を含む 式を微分する方法を知っていま
     す。 この能力は 重力理論のLagrange形式を考える時、 特に役に立ちます
     。 作用原理からEinsteinテンソルと場の方程式を演繹することを可能にし
     ます。

 -- 関数: idiff (<expr>, <v_1>, [<n_1>, [<v_2>, <n_2>] ...])
     添字微分。 独立変数に関して微分する‘diff’と異なり、 ‘idiff)’は座標
     に関して微分するのにつかうことができます。 添字付きオブジェクトに関
     して， 結果的に、これは <v_i>を微分添字として追加することになります
     。 ‘iframe_flag’が ‘true’に設定されていない限り 続いて，微分添字が
     並び替えられます。

     ‘idiff’は計量テンソルの行列式も微分することができます。 従って、も
     し ‘imetric’が ‘G’にバインドされていたら、
     ‘idiff(determinant(g),k)’は ダミー添字 ‘%i’が適当に選ばれて ‘2 *
     determinant(g) * ichr2([%i,k],[%i])’を返します。

 -- 関数: liediff (<v>, <ten>)

     ベクトル場 <v>に対してテンソル式 <ten>のLie微分を計算します。
     <ten>は任意の添字付きテンソル式でなければいけません; <v>はベクトル
     場の(添字なしの)名前でなければいけません。 例えば:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(liediff(v,a([i,j],[])*b([],[k],l)))$
                 k    %2            %2          %2
          (%t2) b   (v   a       + v   a     + v   a    )
                 ,l       i j,%2    ,j  i %2    ,i  %2 j

                                    %1  k        %1  k      %1  k
                                + (v   b      - b   v    + v   b   ) a
                                        ,%1 l    ,l  ,%1    ,l  ,%1   i j

 -- 関数: rediff (<ten>)

     テンソル式 <ten>の中の‘idiff’コマンドすべてを評価します。

 -- 関数: undiff (<expr>)

     <expr>と同値な、 添字付きオブジェクトの微分すべてが‘idiff’関数の名
     詞形で置き換えられた 式を返します。 引数はもし微分が実行されていた
     らその添字付きオブジェクトをもたらします。 微分された添字付きオブジ
     ェクトを <expr>を生じるある関数定義で置き換えて、 ‘ev(<expr>,
     idiff)’で微分を実行したい時、 これは役に立ちます。

 -- 関数: evundiff (<expr>)

     ‘undiff’の実行と同値ですが、‘ev’と ‘rediff’が続きます。

     この演算のポイントは 微分形式で直接評価できない式を簡単に評価するこ
     とです。 例えば、以下はエラーをもたらします:

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) icurvature([i,j,k],[l],m);
          Maxima encountered a Lisp error:

           Error in $ICURVATURE [or a callee]:
           $ICURVATURE [or a callee] requires less than three arguments.

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.

     しかし、もし ‘icurvature’は名詞形で入っているなら、 ‘evundiff’を使
     って評価できます:

          (%i3) ishow('icurvature([i,j,k],[l],m))$
                                                   l
          (%t3)                          icurvature
                                                   i j k,m
          (%i4) ishow(evundiff(%))$
                       l              l         %1           l           %1
          (%t4) - ichr2        - ichr2     ichr2      - ichr2       ichr2
                       i k,j m        %1 j      i k,m        %1 j,m      i k

                       l              l         %1           l           %1
                + ichr2        + ichr2     ichr2      + ichr2       ichr2
                       i j,k m        %1 k      i j,m        %1 k,m      i j

     注意: Maximaの以前のバージョンでは、 Christoffel記号の微分形式も評
     価できませんでした。 これは現在修正されています。 だから
     ‘evundiff’はもはやこのような式に関しては不要です:

          (%i5) imetric(g);
          (%o5)                                done
          (%i6) ishow(ichr2([i,j],[k],l))$
                 k %3
                g     (g         - g         + g        )
                        j %3,i l    i j,%3 l    i %3,j l
          (%t6) -----------------------------------------
                                    2

                                   k %3
                                  g     (g       - g       + g      )
                                   ,l     j %3,i    i j,%3    i %3,j
                                + -----------------------------------
                                                   2

 -- 関数: flush (<expr>, <tensor_1>, <tensor_2>, ...)
     <expr>において、 微分添字を持たない <tensor_i>をすべて0にします。

 -- 関数: flushd (<expr>, <tensor_1>, <tensor_2>, ...)
     <expr>において、 微分添字を持つ <tensor_i>をすべて0にします。

 -- 関数: flushnd (<expr>, <tensor>, <n>)
     以下の例で例示されるように、 <expr>において、 <n>以上の微分添字を持
     つ微分されたオブジェクト <tensor>をすべて0にします。

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i],[J,r],k,r)+a([i],[j,r,s],k,r,s))$
                                          J r      j r s
          (%t2)                          a      + a
                                          i,k r    i,k r s
          (%i3) ishow(flushnd(%,a,3))$
                                               J r
          (%t3)                               a
                                               i,k r

 -- 関数: coord (<tensor_1>, <tensor_2>, ...)

     <tensor_i>に、 その名前が<tensor_i>の1つである反変ベクトルの微分が
     Kroneckerデルタをもたらす 座標微分プロパティを与えます。 例えば、 も
     し ‘coord(x)’が実行されたら、 ‘idiff(x([],[i]),j)’は
     ‘kdelta([i],[j])’を与えます。 ‘coord’はこのプロパティを持つ添字付き
     オブジェクトすべてのリストです。

 -- 関数: remcoord (<tensor_1>, <tensor_2>, ...)
 -- 関数: remcoord (all)

     ‘tensor_i’から 関数 ‘coord’がもたらした座標微分プロパティを削除しま
     す。 ‘remcoord(all)’は添字付きオブジェクトすべてからこのプロパティ
     を削除します。

 -- 関数: makebox (<expr>)
     ‘show’と同じように <expr>を表示します; しかし、 <expr>に現れるテン
     ソル d’Alembert演算子はすべて記号 ‘[]’を使って示されます。 例えば、
     ‘[]p([m],[n])’は ‘g([],[i,j])*p([m],[n],i,j)’を表します。

 -- 関数: conmetderiv (<expr>, <tensor>)

     計量テンソルの共変と反変形式両方(現在の制約)の常微分を含む式を整理
     します。 例えば、 以下に見られるように、 ‘conmetderiv’は 反変計量テ
     ンソルの微分をChristoffelシンボルに結びつけます:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(g([],[a,b],c))$
                                                a b
          (%t2)                                g
                                                ,c
          (%i3) ishow(conmetderiv(%,g))$
                                   %1 b      a       %1 a      b
          (%t3)                 - g     ichr2     - g     ichr2
                                             %1 c              %1 c

 -- 関数: simpmetderiv (<expr>)
 -- 関数: simpmetderiv (<expr>[, <stop>])

     計量テンソルの微分の積を含む式を整理します。 特に、 ‘simpmetderiv’は
     2つの恒等式を知っています:


             ab        ab           ab                 a
            g   g   + g   g     = (g   g  )   = (kdelta )   = 0
             ,d  bc        bc,d         bc ,d          c ,d

     従って、


             ab          ab
            g   g   = - g   g
             ,d  bc          bc,d

     と


            ab          ab
           g   g     = g   g
            ,j  ab,i    ,i  ab,j

     これはChristoffel記号の対称性の結果です。

     ‘simpmetderiv’関数はオプションパラメータを1つ取ります。 それは、与
     えられた時、 積式の中の最初にうまくいった代入の後、関数が停止するよ
     うにします。 ‘simpmetderiv’関数は “正準”順序を積添字に適用する方法
     を決めるグローバル変数 <flipflag>も利用します。

     まとめると、 これらの機能は そうでなければ遂行困難か不可能な強力な
     式整理を達成するのに使うことができます。 これは、 縮約式を得るため
     に‘simpmetderiv’の部分的な整理の特長を明示的に使う 以下の例を通じて
     例示されます:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                                done
          (%i3) ishow(g([],[a,b])*g([],[b,c])*g([a,b],[],d)*g([b,c],[],e))$
                                       a b  b c
          (%t3)                       g    g    g      g
                                                 a b,d  b c,e
          (%i4) ishow(canform(%))$

          errexp1 has improper indices
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) ishow(simpmetderiv(%))$
                                       a b  b c
          (%t5)                       g    g    g      g
                                                 a b,d  b c,e
          (%i6) flipflag:not flipflag;
          (%o6)                                true
          (%i7) ishow(simpmetderiv(%th(2)))$
                                         a b  b c
          (%t7)                         g    g    g    g
                                         ,d   ,e   a b  b c
          (%i8) flipflag:not flipflag;
          (%o8)                                false
          (%i9) ishow(simpmetderiv(%th(2),stop))$
                                         a b  b c
          (%t9)                       - g    g    g      g
                                              ,e   a b,d  b c
          (%i10) ishow(contract(%))$
                                              b c
          (%t10)                           - g    g
                                              ,e   c b,d

     Weylテンソルの縮約を整理するために ‘simpmetderiv’と ‘conmetderiv’を
     一緒に使う例として、 ‘weyl.dem’も参照してください。

 -- 関数: flush1deriv (<expr>, <tensor>)

     <expr>において、 微分添字を1つだけ持つ <tensor>をすべて0にします。

25.2.4 Tensors in curved spaces
-------------------------------

 -- 関数: imetric (<g>)
 -- システム変数: imetric

     変数 ‘imetric:<g>’を割り当てることで計量を指定します。 加えて、 コ
     マンド ‘defcon(<g>),defcon(<g>, <g>, kdelta)’を実行することで 計量
     <g>の縮約プロパティが設定されます。 (デフォルトではバインドされてい
     ない)変数 ‘imetric’は ‘imetric(<g>)’コマンドが割り当てる計量にバイ
     ンドされます。

 -- 関数: idim (<n>)
     計量の次元を設定します。 与えられた次元でLevi-Civita記号の反対称プ
     ロパティも初期化します。

 -- 関数: ichr1 ([<i>, <j>, <k>])
     以下の定義を介して第一種Christoffel記号をもたらします。
                 (g      + g      - g     )/2 .
                   ik,j     jk,i     ij,k
     特定の計量で Christoffel記号を評価するには、 ‘chr2’の下の例のように
     変数 ‘imetric’が名前を割り当てられなければいけません。

 -- 関数: ichr2 ([<i>, <j>], [<k>])
     以下の定義を介して第二種Christoffel記号をもたらします。
                                 ks
             ichr2([i,j],[k]) = g    (g      + g      - g     )/2
                                       is,j     js,i     ij,s

 -- 関数: icurvature ([<i>, <j>, <k>], [<h>])
     第二種Christoffel記号(‘ichr2’)を使った Riemann曲率テンソルをもたら
     します。 以下の表記法が使われます:
                      h             h            h         %1         h
            icurvature     = - ichr2      - ichr2     ichr2    + ichr2
                      i j k         i k,j        %1 j      i k        i j,k
                                      h          %1
                               + ichr2      ichr2
                                      %1 k       i j

 -- 関数: covdiff (<expr>, <v_1>, <v_2>, ...)
     第二種Christoffel記号(‘ichr2’)を使って、 変数 <v_i>に対する <expr>の
     共変微分をもたらします。 これらを評価するには、 ‘ev(<expr>,ichr2)’を
     使わなければ行けません。


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) entertensor()$
          Enter tensor name: a;
          Enter a list of the covariant indices: [i,j];
          Enter a list of the contravariant indices: [k];
          Enter a list of the derivative indices: [];
                                                k
          (%t2)                                a
                                                i j
          (%i3) ishow(covdiff(%,s))$
                       k         %1     k         %1     k
          (%t3)     - a     ichr2    - a     ichr2    + a
                       i %1      j s    %1 j      i s    i j,s

                       k     %1
                + ichr2     a
                       %1 s  i j
          (%i4) imetric:g;
          (%o4)                                  g
          (%i5) ishow(ev(%th(2),ichr2))$
                   %1 %4  k
                  g      a     (g       - g       + g      )
                          i %1   s %4,j    j s,%4    j %4,s
          (%t5) - ------------------------------------------
                                      2
              %1 %3  k
             g      a     (g       - g       + g      )
                     %1 j   s %3,i    i s,%3    i %3,s
           - ------------------------------------------
                                 2
              k %2  %1
             g     a    (g        - g        + g       )
                    i j   s %2,%1    %1 s,%2    %1 %2,s     k
           + ------------------------------------------- + a
                                  2                         i j,s
          (%i6)

 -- 関数: lorentz_gauge (<expr>)
     反変添字と同一の微分添字を持つ <expr>の中で 添字付きオブジェクトす
     べてに0を代入することで、 Lorentz条件を課します。

 -- 関数: igeodesic_coords (<expr>, <name>)

     <expr>内の、未微分 Christoffel記号と 計量テンソルの一階微分を消すよ
     うにします。 ‘igeodesic_coords’関数での <name>は (もし <expr>)の中
     で現れるなら) 計量 <name>を参照します。 一方で、接続係数は 名前
     ‘ichr1’か ‘ichr2’でコールされなければいけません。 以下の例は、
     ‘igeodesic_coords’関数を使った、 Riemann曲率テンソルが満たす巡回恒
     等式の検証を例示します。


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(icurvature([r,s,t],[u]))$
                       u            u         %1         u
          (%t2) - ichr2      - ichr2     ichr2    + ichr2
                       r t,s        %1 s      r t        r s,t

                                                        u         %1
                                                 + ichr2     ichr2
                                                        %1 t      r s
          (%i3) ishow(igeodesic_coords(%,ichr2))$
                                           u            u
          (%t3)                       ichr2      - ichr2
                                           r s,t        r t,s
          (%i4) ishow(igeodesic_coords(icurvature([r,s,t],[u]),ichr2)+
                      igeodesic_coords(icurvature([s,t,r],[u]),ichr2)+
                      igeodesic_coords(icurvature([t,r,s],[u]),ichr2))$
                       u            u            u            u
          (%t4) - ichr2      + ichr2      + ichr2      - ichr2
                       t s,r        t r,s        s t,r        s r,t

                                                       u            u
                                                - ichr2      + ichr2
                                                       r t,s        r s,t
          (%i5) canform(%);
          (%o5)                                  0

25.2.5 Moving frames
--------------------

今ではMaximaは 動標構(moving frame)を使って計算を実行する能力があります
。 これらは直交標構(テトラド、四脚場)か任意系であり得ます。

   標構(frame)を使うには、 最初に‘iframe_flag’を ‘true’に設定しなければ
いけません。 これにより、 計算内で、 Christoffel記号, ‘ichr1’と ‘ichr2’が
もっと一般的な標構(frame)の接続係数 ‘icc1’と ‘icc2’に置き換えられること
になります。 特に、 ‘covdiff’と ‘icurvature’の振る舞いが変わります。

   系は2つのテンソルで定義されます: 逆標枠場 (‘ifri’, 双対基底四脚場)と
標構計量(frame metric) ‘ifg’。 標構計量は直交標構の単位行列、すなわち、
Minkowski時空での直交標構のLorentz計量です。 逆標枠場は標構基底(単位ベク
トル)を定義します。 標枠と標構計量に縮約プロパティが定義されます。

   ‘iframe_flag’がtrueなら、 たくさんの ‘itensor’式が、 ‘imetric’が上付
き添字と下付き添字に関して定義する計量の代わりに 標構計量 ‘ifg’を使いま
す。

   重要: 変数 ‘iframe_flag’を ‘true’に設定することは ‘defcon’や
‘imetric’のコールによって定義された計量の縮約プロパティを 未定義に戻しま
せん。 もし標枠場が使われるなら、 ‘imetric’関数を呼び出さず、 変数
‘imetric’に名前を割り当てて計量を定義することが最良です。

   Maximaはこれら2つのテンソルを使って、 接続係数 (‘icc1’と ‘icc2’)の一
部を形成する 標構係数 (‘ifc1’と ‘ifc2’)を定義します。 以下の例がそれを例
示します:


     (%i1) load("itensor");
     (%o1)      /share/tensor/itensor.lisp
     (%i2) iframe_flag:true;
     (%o2)                                true
     (%i3) ishow(covdiff(v([],[i]),j))$
                                    i        i     %1
     (%t3)                         v   + icc2     v
                                    ,j       %1 j
     (%i4) ishow(ev(%,icc2))$
                                    %1     i       i
     (%t4)                         v   ifc2     + v
                                           %1 j    ,j
     (%i5) ishow(ev(%,ifc2))$
                               %1    i %2                i
     (%t5)                    v   ifg     ifc1        + v
                                              %1 j %2    ,j
     (%i6) ishow(ev(%,ifc1))$
                 %1    i %2
                v   ifg     (ifb        - ifb        + ifb       )
                                j %2 %1      %2 %1 j      %1 j %2     i
     (%t6)      -------------------------------------------------- + v
                                        2                             ,j
     (%i7) ishow(ifb([a,b,c]))$
                                                        %3    %4
     (%t7)               (ifri        - ifri       ) ifr   ifr
                              a %3,%4       a %4,%3     b     c

   もし ‘iframe_bracket_form’フラグが ‘false’に設定されているなら 標構ブ
ラケット(frame bracket) (‘ifb’)を計算するのに代わりの方法が使われます:


     (%i8) block([iframe_bracket_form:false],ishow(ifb([a,b,c])))$
                                     %6    %5        %5      %6
     (%t8)              ifri     (ifr   ifr     - ifr     ifr  )
                            a %5     b     c,%6      b,%6    c

 -- 関数: iframes ()

     Maximaのこのバージョン以来、 ‘ifr’と ‘ifri’に関する縮約恒等式がいつ
     も定義されます。 as is the frame bracket (‘ifb’), この関数は何もし
     ません。

 -- 変数: ifb

     標構ブラケット(frame bracket)。 標構計量の接続係数への寄与が標構ブ
     ラケットを使って表されます:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                  2

     標構ブラケット自身は 標枠と標構計量を使って定義されます。
     ‘frame_bracket_form’の値に依存して 2つの代わりの計算方法が使われま
     す。 もし true (デフォルト)か、もし ‘itorsion_flag’が ‘true’なら:


                    d      e                                      f
          ifb =  ifr    ifr   (ifri      - ifri      - ifri    itr   )
             abc    b      c       a d,e       a e,d       a f    d e


     そうでないなら:


                       e      d        d      e
          ifb    = (ifr    ifr    - ifr    ifr   ) ifri
             abc       b      c,e      b,e    c        a d

 -- 変数: icc1

     第一種接続係数。 ‘itensor’では、以下のように定義されます。


          icc1    = ichr1    - ikt1    - inmc1
              abc        abc       abc        abc

     この式では、 もし ‘iframe_flag’が trueなら、 Christoffel記号
     ‘ichr1’が 標構接続係数 ‘ifc1’に置き換えられます。 もし
     ‘itorsion_flag’が ‘false’なら、 ‘ikt1’は省略されます。 もし標構基底
     が使われるなら、 ねじれが標構ブラケットの一部として既に計算されてい
     るので、 その時にも ‘ikt1’は省略されます。 最後に、 ‘inonmet_flag’が
     ‘false’なら、 ‘inmc1’は存在しません。

 -- 変数: icc2

     第二種接続係数。 ‘itensor’では、以下のように定義されます。


              c         c        c         c
          icc2   = ichr2   - ikt2   - inmc2
              ab        ab       ab        ab

     この式では、 もし ‘iframe_flag’が trueなら、 Christoffel記号
     ‘ichr2’が 標構接続係数 ‘ifc2’に置き換えられます。 もし
     ‘itorsion_flag’が ‘false’なら、 ‘ikt2’は省略されます。 もし標構基底
     が使われるなら、 ねじれが標構ブラケットの一部として既に計算されてい
     るので、 その時にも ‘ikt1’は省略されます。 最後に、 ‘inonmet_flag’が
     ‘false’なら、 ‘inmc1’は存在しません。

 -- 変数: ifc1

     (Ricci回転係数としても知られている)第一種標構係数。 このテンソルは
     標構計量の第一種接続係数への寄与を表します。 以下のように定義されま
     す:


                    - ifb      + ifb      + ifb
                         c a b      b c a      a b c
          ifc1    = --------------------------------
              abc                   2


 -- 変数: ifc2

     第二種標構係数。 このテンソルは標構計量の第一種接続係数への寄与を表
     します。 必要に応じて、標構ブラケット (‘ifb’)の、 適切な上付き、下
     付き添字での置換として定義されます:


              c       cd
          ifc2   = ifg   ifc1
              ab             abd

 -- 変数: ifr

     標枠。 標構計量(‘ifg’)を形成するために 逆標構場 (‘ifri’)を 縮約しま
     す。

 -- 変数: ifri

     逆標構場。 (双対基底ベクトル)標構基底を指定します。 標構計量と一緒
     に、 標構に基づいた計算すべての基底を形成します。

 -- 変数: ifg

     標構計量。 ‘kdelta’のデフォルトですが、 ‘components’を使って変える
     ことができます。

 -- 変数: ifgi

     逆標構計量。 標構計量 (‘ifg’)を ‘kdelta’に縮約します。

 -- オプション変数: iframe_bracket_form
     デフォルト値: ‘true’

     標構ブラケット (‘ifb’)が如何に計算されるか指定します。

25.2.6 Torsion and nonmetricity
-------------------------------

Maximaは今では、ねじれと非計量性を考慮することができます。 フラグ
‘itorsion_flag’が ‘true’に設定されている時、 ねじれの寄与が 接続係数に加
えられます。 同様に、 フラグ ‘inonmet_flag’が trueの時、 非計量性成分が
含まれます。

 -- 変数: inm

     非計量性ベクトル。 共形非計量性は計量テンソルの共変微分を通して定義
     されます。 ‘inonmet_flag’が ‘true’に設定されている時 通常零の計量テ
     ンソルの共変微分は以下のように評価されます:


          g     =- g  inm
           ij;k     ij   k

 -- 変数: inmc1

     非計量ベクトル成分の共変置換。 以下のように定義されます:


                     g   inm  - inm  g   - g   inm
                      ab    c      a  bc    ac    b
          inmc1    = ------------------------------
               abc                 2

     (もし標構計量を使うなら、‘ifg’を ‘g’に代入します。)

 -- 変数: inmc2

     非計量ベクトル成分の反変置換。 もし ‘inonmet_flag’が ‘true’なら 接
     続係数で使われます。 以下のように定義されます:


                                c         c         cd
                    -inm  kdelta  - kdelta  inm  + g   inm  g
               c        a       b         a    b          d  ab
          inmc2   = -------------------------------------------
               ab                        2

     (もし標構計量を使うなら、‘ifg’を ‘g’に代入します。)

 -- 変数: ikt1

     (コントーションとしても知られる)ねじれテンソルの共変置換。 以下のよ
     うに定義されます:


                            d           d       d
                    -g   itr  - g    itr   - itr   g
                      ad    cb    bd    ca      ab  cd
          ikt1    = ----------------------------------
              abc                   2

     (もし標構計量を使うなら、‘ifg’を ‘g’に代入します。)

 -- 変数: ikt2

     (コントーションとしても知られる)ねじれテンソルの共変置換。 以下のよ
     うに定義されます:


              c     cd
          ikt2   = g   ikt1
              ab           abd

     (もし標構計量を使うなら、‘ifg’を ‘g’に代入します。)

 -- 変数: itr

     ねじれテンソル。 以下の例で例示されるように、 ねじれを伴う計量に関
     してスカラー関数上の繰り返される共変微分は計算されません:

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric:g;
          (%o2)                                  g
          (%i3) covdiff( covdiff( f( [], []), i), j)
                                - covdiff( covdiff( f( [], []), j), i)$
          (%i4) ishow(%)$
                                             %4              %2
          (%t4)                    f    ichr2    - f    ichr2
                                    ,%4      j i    ,%2      i j
          (%i5) canform(%);
          (%o5)                                  0
          (%i6) itorsion_flag:true;
          (%o6)                                true
          (%i7) covdiff( covdiff( f( [], []), i), j)
                                - covdiff( covdiff( f( [], []), j), i)$
          (%i8) ishow(%)$
                                     %8             %6
          (%t8)             f    icc2    - f    icc2    - f     + f
                             ,%8     j i    ,%6     i j    ,j i    ,i j
          (%i9) ishow(canform(%))$
                                             %1             %1
          (%t9)                     f    icc2    - f    icc2
                                     ,%1     j i    ,%1     i j
          (%i10) ishow(canform(ev(%,icc2)))$
                                             %1             %1
          (%t10)                    f    ikt2    - f    ikt2
                                     ,%1     i j    ,%1     j i
          (%i11) ishow(canform(ev(%,ikt2)))$
                                %2 %1                    %2 %1
          (%t11)          f    g      ikt1       - f    g      ikt1
                           ,%2            i j %1    ,%2            j i %1
          (%i12) ishow(factor(canform(rename(expand(ev(%,ikt1))))))$
                                     %3 %2            %1       %1
                               f    g      g      (itr    - itr   )
                                ,%3         %2 %1     j i      i j
          (%t12)               ------------------------------------
                                                2
          (%i13) decsym(itr,2,1,[anti(all)],[]);
          (%o13)                               done
          (%i14) defcon(g,g,kdelta);
          (%o14)                               done
          (%i15) subst(g,nounify(g),%th(3))$
          (%i16) ishow(canform(contract(%)))$
                                                     %1
          (%t16)                           - f    itr
                                              ,%1    i j

25.2.7 Exterior algebra
-----------------------

‘itensor’パッケージは 完全反対称共変テンソル場上の 演算を実行できます。
回数 (0,L)の完全反対称テンソル場は 微分L形式に対応します。 これらのオブ
ジェクト上で、 外積やウェッジ積として知られる乗算が定義されます。

   不運にも、 すべての作者がウェッジ積の定義に同意しません。 何人の作者
は反対称の概念に対応した定義を好みます: これらの仕事では、 2つのベクトル
場のウェッジ積は 例えば、以下のように定義されます。

                 a a  - a a
                  i j    j i
      a  /\ a  = -----------
       i     j        2

   もっと一般的に、 p形式や q形式の積は以下のように定義されます。

                            1     k1..kp l1..lq
     A       /\ B       = ------ D              A       B
      i1..ip     j1..jq   (p+q)!  i1..ip j1..jq  k1..kp  l1..lq

   ここで、 ‘D’はKroneckerのデルタを表します。

   しかし、他の作者は容積要素の概念に対応する “幾何的”定義を好みます:

     a  /\ a  = a a  - a a
      i     j    i j    j i

   そいて、一般的な場合，

                            1    k1..kp l1..lq
     A       /\ B       = ----- D              A       B
      i1..ip     j1..jq   p! q!  i1..ip j1..jq  k1..kp  l1..lq

   ‘itensor’はテンソル代数パッケージなので、 これら2つの定義の前者がより
自然なもののようです。 しかし、多くの応用は後者の定義を使います。 このジ
レンマを解決するに、 ウェッジ積の振る舞いを制御するフラグが実装されまし
た: もし ‘igeowedge_flag’が ‘false’ (デフォルト)なら、 前者の "テンソル
的"定義が使われ、 層でないなら，後者の"幾何的"定義が適用されます。

 -- 演算子: ~

     ウェッジ積演算子は ティルデ ‘~’で示されれます。 これは二項演算子で
     す。 引数は、 スカラ、階数1の共変テンソル、 共変添字すべてに関して
     反対称と宣言された階数 ‘l’の共変テンソルを含む式 でなければいけませ
     ん。

     以下の例のように、 ウェッジ積演算子の振る舞いは ‘igeowedge_flag’ フ
     ラグで制御されます:

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(a([i])~b([j]))$
                                           a  b  - b  a
                                            i  j    i  j
          (%t2)                            -------------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(a([i,j])~b([k]))$
                                    a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j
          (%t4)                     ---------------------------
                                                 3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(a([i])~b([j]))$
          (%t6)                            a  b  - b  a
                                            i  j    i  j
          (%i7) ishow(a([i,j])~b([k]))$
          (%t7)                     a    b  + b  a    - a    b
                                     i j  k    i  j k    i k  j

 -- 演算子: |

     縦線 ‘|’は "ベクトルの縮約"二項演算子を示します。 完全反対称共変テ
     ンソルが反変ベクトルと縮約される時、 結果は、どの添字が縮約に使われ
     るかに関わらず同じです。 このように、 添字に無関係な方法で縮約演算
     子を定義することが可能です。

     ‘itensor’パッケージでは、 ベクトルとの縮約は常に 文字通りの並べ順で
     最初の添字に対して実行されます。 これは ‘|’演算子を含む式のより良い
     整理を保証します。 例えば:

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) decsym(a,2,0,[anti(all)],[]);
          (%o2)                                done
          (%i3) ishow(a([i,j],[])|v)$
                                              %1
          (%t3)                              v   a
                                                  %1 j
          (%i4) ishow(a([j,i],[])|v)$
                                               %1
          (%t4)                             - v   a
                                                   %1 j

     ‘|’演算子で使われるテンソルは は共変添字に対して完全反対称と宣言さ
     れなければいけないことが 本質的であることに注意してください。 そう
     でないなら、結果は正しくありません。

 -- 関数: extdiff (<expr>, <i>)

     添字 <i>に対する <expr>の外積を計算します。 外微分は形式的に 偏微分
     演算子のウェッジ積で微分形式として定義されます。 そんなように、 演
     算子も ‘igeowedge_flag’の設定で制御されます。 例えば:

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) ishow(extdiff(v([i]),j))$
                                            v    - v
                                             j,i    i,j
          (%t2)                             -----------
                                                 2
          (%i3) decsym(a,2,0,[anti(all)],[]);
          (%o3)                                done
          (%i4) ishow(extdiff(a([i,j]),k))$
                                     a      - a      + a
                                      j k,i    i k,j    i j,k
          (%t4)                      ------------------------
                                                3
          (%i5) igeowedge_flag:true;
          (%o5)                                true
          (%i6) ishow(extdiff(v([i]),j))$
          (%t6)                             v    - v
                                             j,i    i,j
          (%i7) ishow(extdiff(a([i,j]),k))$
          (%t7)                    - (a      - a      + a     )
                                       k j,i    k i,j    j i,k

 -- 関数: hodge (<expr>)

     <expr>のHodge双対を計算します。 例えば:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) imetric(g);
          (%o2)                            done
          (%i3) idim(4);
          (%o3)                            done
          (%i4) icounter:100;
          (%o4)                             100
          (%i5) decsym(A,3,0,[anti(all)],[])$

          (%i6) ishow(A([i,j,k],[]))$
          (%t6)                           A
                                           i j k
          (%i7) ishow(canform(hodge(%)))$
                                    %1 %2 %3 %4
                         levi_civita            g        A
                                                 %1 %102  %2 %3 %4
          (%t7)          -----------------------------------------
                                             6
          (%i8) ishow(canform(hodge(%)))$
                           %1 %2 %3 %8            %4 %5 %6 %7
          (%t8) levi_civita            levi_civita            g
                                                               %1 %106
                                       g        g        g      A         /6
                                        %2 %107  %3 %108  %4 %8  %5 %6 %7
          (%i9) lc2kdt(%)$

          (%i10) %,kdelta$

          (%i11) ishow(canform(contract(expand(%))))$
          (%t11)                     - A
                                        %106 %107 %108

 -- オプション変数: igeowedge_flag
     デフォルト値: ‘false’

     ウェッジ積と外微分の振る舞いを制御します。 ‘false’ (デフォルト)に設
     定された時、 微分形式の概念は 完全反対称共変テンソル場のそれに対応
     します。 ‘true’に設定された時、 微分形式は容積要素の概念に一致しま
     す。

25.2.8 Exporting TeX expressions
--------------------------------

‘itensor’パッケージは テンソル式をTexにエクスポートするための限定サポー
トを提供します。 ‘itensor’式は関数コールとして現れるので、 いつもの
Maxima ‘tex’コマンドは 期待された出力を生成しません。 代わりに‘tentex’コ
マンドを試すことができます。 これは、テンソル式を適切に添字が付けられた
TeXオブジェクトに翻訳しようとします。

 -- 関数: tentex (<expr>)

     以下の例のように、 ‘tentex’関数を使うには、 最初に‘tentex’をロード
     しなければいけません:


          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) load("tentex");
          (%o2)       /share/tensor/tentex.lisp
          (%i3) idummyx:m;
          (%o3)                                  m
          (%i4) ishow(icurvature([j,k,l],[i]))$
                      m1       i           m1       i           i
          (%t4)  ichr2    ichr2     - ichr2    ichr2     - ichr2
                      j k      m1 l        j l      m1 k        j l,k

                                                                i
                                                         + ichr2
                                                                j k,l
          (%i5) tentex(%)$
          $$\Gamma_{j\,k}^{m_1}\,\Gamma_{l\,m_1}^{i}-\Gamma_{j\,l}^{m_1}\,
           \Gamma_{k\,m_1}^{i}-\Gamma_{j\,l,k}^{i}+\Gamma_{j\,k,l}^{i}$$

     コンパイルエラーに導かれるTeX式でのパーセント符号の出現を避けるため
     の、 ‘idummyx’割り当ての使用に注意してください。

     注意せよ: このバージョンの‘tentex’関数は幾分実験的です。

25.2.9 Interfacing with ctensor
-------------------------------

‘itensor’パッケージは ‘ctensor’パッケージの文脈で実行することができる
Maximaコードを生成する能力があります。 この仕事を実行する関数は
‘ic_convert’です。

 -- 関数: ic_convert (<eqn>)

     ‘itensor’方程式 <eqn>を ‘ctensor’割り当て文に変換します。 添字付き
     オブジェクトが配列に変換される一方で、 ダミー添字上の暗黙の和は明示
     的にされます。

     (配列下付き添字は添字付きオブジェクトの反変添字が続く共変の順です。
     ) 添字付きオブジェクトの微分は、 微分添字で下に添えられた
     ‘ct_coords’に対して取られる ‘diff’の名詞形に 置き換えられます。
     Christoffel記号 ‘ichr1’と ‘ichr2’は それぞれ、‘lcs’と ‘mcs’に翻訳さ
     れます。 もし ‘metricconvert’が ‘true’なら、 2つの共変(反変)添字を
     持つ計量はすべて ‘lg’ (‘ug’)にリネームされます。 更に、 自由添字す
     べての上で足される‘do’ループが導入されます。 なので、 ただ ‘ev’する
     だけで 変換される割り当て分を評価することができます。 以下の例はこ
     の関数の特長を例示します。

          (%i1) load("itensor");
          (%o1)      /share/tensor/itensor.lisp
          (%i2) eqn:ishow(t([i,j],[k])=f([],[])*g([l,m],[])*a([],[m],j)
                *b([i],[l,k]))$
                                       k        m   l k
          (%t2)                       t    = f a   b    g
                                       i j      ,j  i    l m
          (%i3) ic_convert(eqn);
          (%o3) for i thru dim do (for j thru dim do (
                 for k thru dim do
                  t        : f sum(sum(diff(a , ct_coords ) b
                   i, j, k                   m           j   i, l, k

           g    , l, 1, dim), m, 1, dim)))
            l, m
          (%i4) imetric(g);
          (%o4)                                done
          (%i5) metricconvert:true;
          (%o5)                                true
          (%i6) ic_convert(eqn);
          (%o6) for i thru dim do (for j thru dim do (
                 for k thru dim do
                  t        : f sum(sum(diff(a , ct_coords ) b
                   i, j, k                   m           j   i, l, k

           lg    , l, 1, dim), m, 1, dim)))
             l, m

25.2.10 Reserved words
----------------------

以下の Maximaワードは ‘itensor’パッケージで内部的に使われているので、 再
定義してはいけません:

       Keyword    Comments
       ------------------------------------------
       indices2() Internal version of indices()
       conti      Lists contravariant indices
       covi       Lists covariant indices of a indexed object
       deri       Lists derivative indices of an indexed object
       name       Returns the name of an indexed object
       concan
       irpmon
       lc0
       _lc2kdt0
       _lcprod
       _extlc


File: maxima.info,  Node: ctensor,  Next: atensor,  Prev: itensor,  Up: Top

26 ctensor
**********

* Menu:

* Introduction to ctensor::
* Functions and Variables for ctensor::


File: maxima.info,  Node: Introduction to ctensor,  Next: Functions and Variables for ctensor,  Prev: ctensor,  Up: ctensor

26.1 Introduction to ctensor
============================

‘ctensor’は、成分テンソル操作パッケージです。 ‘ctensor’パッケージを使う
には、‘load("ctensor")’をタイプしてください。 ‘ctensor’と対話的セッショ
ンを始めるには、‘csetup()’をタイプしてください。 最初に、多様体の次元を
指定するよう尋ねられます。 もし次元が、2, 3, 4のいずれかなら、 座標のリ
ストがそれぞれ、‘[x,y]’, ‘[x,y,z]’, ‘[x,y,z,t]’に設定されます。 これらの
名前は、座標の新しいリストを(以下で記述する)変数‘ct_coords’ に 割り当て
ることで変えることができ、ユーザーは、これについて尋ねられます。 座標名
が他のオブジェクト定義と衝突することを避けるように、注意が払われなければ
いけません。

   次に、ユーザーは計量を直接、または順序位置(ordinal position)を指定し
てファイルから、入力します。 計量は行列‘lg’に保存されます。 最後に、計量
の逆元が計算され、 行列‘ug’に保存されます。 すべての計算を冪級数で実行す
るオプションがあります。

   サンプルプロトコルは、 例として、(Schwarzschild解に至る)Einsteinの真
空方程式を導出する問題に適用される 静的な球対称計量(標準座標)に関して、
以下のように開始されます。 ‘ctensor’の関数の多くは例のように標準計量に対
して表示されます。

     (%i1) load("ctensor");
     (%o1)      /share/tensor/ctensor.mac
     (%i2) csetup();
     Enter the dimension of the coordinate system:
     4;
     Do you wish to change the coordinate names?
     n;
     Do you want to
     1. Enter a new metric?

     2. Enter a metric from a file?

     3. Approximate a metric with a Taylor series?
     1;

     Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
     Answer 1, 2, 3 or 4
     1;
     Row 1 Column 1:
     a;
     Row 2 Column 2:
     x^2;
     Row 3 Column 3:
     x^2*sin(y)^2;
     Row 4 Column 4:
     -d;

     Matrix entered.
     Enter functional dependencies with the DEPENDS function or 'N' if none
     depends([a,d],x);
     Do you wish to see the metric?
     y;
                               [ a  0       0        0  ]
                               [                        ]
                               [     2                  ]
                               [ 0  x       0        0  ]
                               [                        ]
                               [         2    2         ]
                               [ 0  0   x  sin (y)   0  ]
                               [                        ]
                               [ 0  0       0       - d ]
     (%o2)                                done
     (%i3) christof(mcs);
                                                 a
                                                  x
     (%t3)                          mcs        = ---
                                       1, 1, 1   2 a

                                                  1
     (%t4)                           mcs        = -
                                        1, 2, 2   x

                                                  1
     (%t5)                           mcs        = -
                                        1, 3, 3   x

                                                 d
                                                  x
     (%t6)                          mcs        = ---
                                       1, 4, 4   2 d

                                                   x
     (%t7)                          mcs        = - -
                                       2, 2, 1     a

                                                cos(y)
     (%t8)                         mcs        = ------
                                      2, 3, 3   sin(y)

                                                    2
                                               x sin (y)
     (%t9)                      mcs        = - ---------
                                   3, 3, 1         a

     (%t10)                   mcs        = - cos(y) sin(y)
                                 3, 3, 2

                                                 d
                                                  x
     (%t11)                         mcs        = ---
                                       4, 4, 1   2 a
     (%o11)                               done


File: maxima.info,  Node: Functions and Variables for ctensor,  Prev: Introduction to ctensor,  Up: ctensor

26.2 Functions and Variables for ctensor
========================================

26.2.1 Initialization and setup
-------------------------------

 -- 関数: csetup ()
     パッケージを初期化し、ユーザーに計量を対話的に入力可能にする
     ‘ctensor’(成分テンソル)パッケージの関数 より詳細は‘ctensor’を参照し
     てください。

 -- 関数: cmetric (<dis>)
 -- 関数: cmetric ()
     計量の逆元を計算し、将来の計算のためパッケージを設定する
     ‘ctensor’(成分テンソル)パッケージの関数

     もし‘cframe_flag’が‘false’なら、 関数は逆計量‘ug’を(ユーザー定義の
     )行列‘lg’から計算します。 計量の行列式も計算され、変数‘gdet’に保存
     されます。 更に、パッケージは計量が対角的か調べ、結果に従って
     ‘diagmetric’の値を設定します。 もしオプション引数<dis>が渡されて、
     それが‘false’でないなら、 ユーザーは計量の逆元を見るように促されま
     す。

     もし‘cframe_flag’が‘true’なら、 関数は‘fri’ (逆標構行列)と‘lfg’(標
     構計量)の値が定義されていると考えます。 これらから、標構行列‘fr’と
     逆標構計量‘ufg’が計算されます。

 -- 関数: ct_coordsys (<coordinate_system>, <extra_arg>)
 -- 関数: ct_coordsys (<coordinate_system>)
     あらかじめ定義された座標系と計量を設定します。 引数
     <coordinate_system>は以下のシンボルのいずれかです:


           SYMBOL             Dim Coordinates     Description/comments
           ------------------------------------------------------------------
           cartesian2d           2  [x,y]             Cartesian 2D 座標系
           polar                 2  [r,phi]           極座標系
           elliptic              2  [u,v]             楕円座標系
           confocalelliptic      2  [u,v]             共焦点楕円座標
           bipolar               2  [u,v]             二極座標系
           parabolic             2  [u,v]             放物座標系
           cartesian3d           3  [x,y,z]           Cartesian 3D 座標系
           polarcylindrical      3  [r,theta,z]       円筒z極2D
           ellipticcylindrical   3  [u,v,z]           円筒z楕円2D
           confocalellipsoidal   3  [u,v,w]           共焦点楕円
           bipolarcylindrical    3  [u,v,z]           円筒z二極2D
           paraboliccylindrical  3  [u,v,z]           円筒z放物2D
           paraboloidal          3  [u,v,phi]         Paraboloidal coords.
           conical               3  [u,v,w]           円錐座標
           toroidal              3  [u,v,phi]         環状座標
           spherical             3  [r,theta,phi]     球座標系
           oblatespheroidal      3  [u,v,phi]         偏球座標系
           oblatespheroidalsqrt  3  [u,v,phi]
           prolatespheroidal     3  [u,v,phi]         長形球座標系
           prolatespheroidalsqrt 3  [u,v,phi]
           ellipsoidal           3  [r,theta,phi]     楕円体座標系
           cartesian4d           4  [x,y,z,t]         Cartesian 4D 座標系
           spherical4d           4  [r,theta,eta,phi] 球 4D 座標系
           exteriorschwarzschild 4  [t,r,theta,phi]   Schwarzschild 計量
           interiorschwarzschild 4  [t,z,u,v]         内部 Schwarzschild 計量
           kerr_newman           4  [t,r,theta,phi]   荷電軸対称計量

     ‘coordinate_system’は 座標変数を含むリストが続く変換関数のリストで
     もあり得ます。 例えば、 以下のように球計量を指定できます:


          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o2)                                done
          (%i3) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o3)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]
          (%i4) ct_coords;
          (%o4)                           [r, theta, phi]
          (%i5) dim;
          (%o5)                                  3

     ‘cframe_flag’が ‘true’の時 変換関数も使うことができます:


          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) cframe_flag:true;
          (%o2)                                true
          (%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
                r*sin(theta),[r,theta,phi]]);
          (%o3)                                done
          (%i4) fri;
          (%o4)
           [cos(phi)cos(theta) -cos(phi) r sin(theta) -sin(phi) r cos(theta)]
           [                                                                ]
           [sin(phi)cos(theta) -sin(phi) r sin(theta)  cos(phi) r cos(theta)]
           [                                                                ]
           [    sin(theta)           r cos(theta)                0          ]

          (%i5) cmetric();
          (%o5)                                false
          (%i6) lg:trigsimp(lg);
                                     [ 1  0         0        ]
                                     [                       ]
                                     [     2                 ]
          (%o6)                      [ 0  r         0        ]
                                     [                       ]
                                     [         2    2        ]
                                     [ 0  0   r  cos (theta) ]

     オプションの引数 <extra_arg>は以下のいずれかです:

     ‘cylindrical’は ‘ct_coordsys’に追加の極座標を結びつけるように言いま
     す。

     ‘minkowski’は ‘ct_coordsys’に 負の計量符号を持つ追加の座標を結びつ
     けるように言います。

     ‘all’は ‘ct_coordsys’に 計量を設定した後、 ‘cmetric’と
     ‘christof(false)’をコールするように言います。

     もしグローバル変数 ‘verbose’が ‘true’に設定されているなら、
     ‘ct_coordsys’は、 ‘cframe_flag’の値に依存して、 ‘dim’, ‘ct_coords’と
     、 ‘lg’か ‘lfg’のいずれかと ‘fri’の値を表示します。

 -- 関数: init_ctensor ()
     ‘ctensor’パッケージを初期化します。

     ‘init_ctensor’関数は‘ctensor’パッケージを再初期化します。 それは
     ‘ctensor’が使う配列、行列すべてを削除し、 フラグすべてをリセットし
     、 ‘dim’を4にリセットし、 標構計量を Lorentz標構にリセットします。

26.2.2 The tensors of curved space
----------------------------------

‘ctensor’パッケージの 主な目的は曲がった空間(時間)のテンソル、 最も顕著
には一般相対性理論で使われるテンソルを計算することです。

   計量基底が使われる時、 ‘ctensor’は以下のテンソルを計算できます:


      lg  -- ug
        \      \
         lcs -- mcs -- ric -- uric
                   \      \       \
                    \      tracer - ein -- lein
                     \
                      riem -- lriem -- weyl
                          \
                           uriem


   ‘ctensor’は動標構を使って機能することもできます。 ‘cframe_flag’が
‘true’に設定されている時、 以下のテンソルを計算できます:


      lfg -- ufg
          \
      fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
           \                       |  \      \       \
            lg -- ug               |   weyl   tracer - ein -- lein
                                   |\
                                   | riem
                                   |
                                   \uriem

 -- 関数: christof (<dis>)
     ‘ctensor’ (成分テンソル)パッケージの関数。 各種Christoffel記号を計
     算します。 引数 <dis>は どの結果をすぐに表示するか決めます。 第一種
     と第二種Christoffel記号は それぞれ配列 ‘lcs[i,j,k]’と ‘mcs[i,j,k]’に
     格納され、 最初の2つの添字に対して対称と定義されます。 もし
     ‘christof’の引数が ‘lcs’か ‘mcs’なら それぞれ、‘lcs[i,j,k]’か
     ‘mcs[i,j,k]’の固有の非零値が 表示されます。 もし引数が ‘all’なら、
     ‘lcs[i,j,k]’と ‘mcs[i,j,k]’の固有の非零値が表示されます。 もし引数
     が ‘false’なら、 要素の表示はされません。 配列要素 ‘mcs[i,j,k]’は 最
     後の添字が反変であるような方法で定義されます。

 -- 関数: ricci (<dis>)
     ‘ctensor’ (成分テンソル)パッケージの関数。 ‘ricci’は Ricciテンソル
     の共変(対称)成分 ‘ric[i,j]’を計算します。 もし引数 <dis>が ‘true’な
     ら、 非零成分が表示されます。

 -- 関数: uricci (<dis>)
     この関数は最初にRicciテンソルの共変成分 ‘ric[i,j]’を計算します。 そ
     して、混合 Ricciテンソルが反変計量テンソルを使って計算されます。 も
     し引数 <dis>の値が ‘true’なら これらの(添字 ‘i’は共変で、添字 ‘j’は
     反変の)混合成分 ‘uric[i,j]’ は直接表示されます。 そうでないなら、
     ‘ricci(false)’は 結果を表示することなく、単に配列 ‘uric[i,j]’の要素
     を計算します。

 -- 関数: scurvature ()
     与えられた計量を持つ Riemannian多様体の (Ricciテンソルを縮約するこ
     とで得られる)スカラ曲率を返します。

 -- 関数: einstein (<dis>)
     ‘ctensor’ (成分テンソル)パッケージの関数。 ‘einstein’は、 (関数
     ‘christof’と ‘ricci’を使って) Christoffel記号と Ricciテンソルを得ら
     れた後、 混合 Einsteinテンソルを計算します。 もし引数 <dis>が
     ‘true’なら、 混合 Einsteinテンソル ‘ein[i,j]’の非零値が表示されます
     。 ここで ‘j’は反変添字です。 変数 ‘rateinstein’は これらの成分上の
     有理整理をもたらします。 もし ‘ratfac’が ‘true’なら、 成分は因数分
     解もされます。

 -- 関数: leinstein (<dis>)
     共変 Einsteinテンソル。 ‘leinstein’は 配列 ‘lein’に共変 Einsteinテ
     ンソルの値を格納します。 共変 Einsteinテンソルは、 計量テンソルを掛
     けることで 混合 Einsteinテンソル ‘ein’から計算されます。 もし引数
     <dis>が ‘true’なら、 共変 Einsteinテンソルの非零値が表示されます。

 -- 関数: riemann (<dis>)
     ‘ctensor’ (成分テンソル)パッケージの関数。 ‘riemann’は 与えられた計
     量と対応するChristoffel記号から Riemann曲率テンソルを計算します。 以
     下の添字慣例が使われます:

                          l      _l       _l       _l   _m    _l   _m
           R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                          ijk     ij,k     ik,j     mk   ij    mj   ik

     この表記法は ‘itensor’パッケージとその ‘icurvature’関数で使われる表
     記法と 一致しています。 もしオプション引数 <dis>が ‘true’なら、 固
     有の非零成分 ‘riem[i,j,k,l]’が表示されます。 Einsteinテンソルと同様
     に ユーザーが設定する様々なスイッチが Riemannテンソルの成分の整理を
     制御します。 もし ‘ratriemann’が ‘true’なら、 有理整理がされます。
     もし ‘ratfac’が ‘true’なら、 成分のそれぞれは因数分解もされます。

     もし変数 ‘cframe_flag’が ‘false’なら、 Riemannテンソルは
     Christoffel記号から直接計算されます。 もし ‘cframe_flag’が ‘true’な
     ら、 共変 Riemannテンソルは 標構場係数から最初に計算されます。

 -- 関数: lriemann (<dis>)
     共変 Riemannテンソル (‘lriem[]’).

     配列 ‘lriem’として 共変 Riemannテンソルを計算します。 もし引数
     <dis>が ‘true’なら、 固有の非零値が表示されます。

     もし変数 ‘cframe_flag’が ‘true’なら、 共変 Riemannテンソルは 標構場
     係数から直接計算されます。 そうでないなら、 (3,1) Riemannテンソルが
     最初に計算されます。

     添字順序の情報は ‘riemann’を参照してください。

 -- 関数: uriemann (<dis>)
     配列要素 ‘uriem[i,j,k,l]’として Riemann曲率テンソルの反変成分を計算
     します。 もし <dis>が ‘true’なら、これらが表示されます。

 -- 関数: rinvariant ()
     テンソル
          lriem[i,j,k,l]*uriem[i,j,k,l].
     を縮約することで得られるKretschmann不変量 (‘kinvariant’)を形成しま
     す。

     このオブジェクトは非常に大きくなるかもしれないので、 自動的には整理
     されません。

 -- 関数: weyl (<dis>)
     Weylの共形テンソルを計算します。 もし引数 <dis>が ‘true’なら、 非零
     成分 ‘weyl[i,j,k,l]’がユーザーに表示されます。 そうでないなら、これ
     らの成分は 単に計算され、格納されます。 もしスイッチ ‘ratweyl’が
     ‘true’に設定されているなら、 成分は有理整理されます; もし ‘ratfac’が
     ‘true’なら、 結果は因数分解もされます。

26.2.3 Taylor series expansion
------------------------------

‘ctensor’パッケージは 結果が Taylor級数近似であると仮定することで、結果
を切り詰める機能を持ちます。 この振る舞いは ‘ctayswitch’変数で制御されま
す; trueに設定されている時、 結果を整理する際に ‘ctensor’は内部的に関数
‘ctaylor’を利用します。

   以下の ‘ctensor’関数が ‘ctaylor’関数を呼び出します:


         Function     Comments
         ---------------------------------
         christof()   For mcs only
         ricci()
         uricci()
         einstein()
         riemann()
         weyl()
         checkdiv()

 -- 関数: ctaylor ()

     ‘ctaylor’関数は、 ‘taylor’を使ってその後‘ratdisrep’をコールすること
     で 引数をTaylor級数に変換することで、 引数を切り詰めます。 これは 展
     開変数 ‘ctayvar’に関してより高い項を落とす合わせ効果を持ちます。 落
     とす項の次数は‘ctaypov’で定義されます; 級数展開が実行される点は
     ‘ctaypt’で指定されます。

     例として、 Minkowski計量の置換である簡単な計量を考えます。 追加の制
     約なしでは、 対角計量でさえ はるかに複雑すぎるEinsteinテンソルの式
     を生成します:


          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) derivabbrev:true;
          (%o3)                                true
          (%i4) ct_coords:[t,r,theta,phi];
          (%o4)                         [t, r, theta, phi]
          (%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],
                          [0,0,0,r^2*sin(theta)^2]);
                                  [ - 1  0  0         0        ]
                                  [                            ]
                                  [  0   1  0         0        ]
                                  [                            ]
          (%o5)                   [          2                 ]
                                  [  0   0  r         0        ]
                                  [                            ]
                                  [              2    2        ]
                                  [  0   0  0   r  sin (theta) ]
          (%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                                      [ h11   0    0    0  ]
                                      [                    ]
                                      [  0   h22   0    0  ]
          (%o6)                       [                    ]
                                      [  0    0   h33   0  ]
                                      [                    ]
                                      [  0    0    0   h44 ]
          (%i7) depends(l,r);
          (%o7)                               [l(r)]
          (%i8) lg:lg+l*h;
                [ h11 l - 1      0          0                 0            ]
                [                                                          ]
                [     0      h22 l + 1      0                 0            ]
                [                                                          ]
          (%o8) [                        2                                 ]
                [     0          0      r  + h33 l            0            ]
                [                                                          ]
                [                                    2    2                ]
                [     0          0          0       r  sin (theta) + h44 l ]
          (%i9) cmetric(false);
          (%o9)                                done
          (%i10) einstein(false);
          (%o10)                               done
          (%i11) ntermst(ein);
          [[1, 1], 62]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 24]
          [[2, 3], 0]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 0]
          [[3, 3], 46]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 46]
          (%o12)                               done

     しかし、もしこの例を 変数 ‘l’に対して線形という近似として 再研鑽す
     るなら、 もっと簡潔な式を得ます:


          (%i14) ctayswitch:true;
          (%o14)                               true
          (%i15) ctayvar:l;
          (%o15)                                 l
          (%i16) ctaypov:1;
          (%o16)                                 1
          (%i17) ctaypt:0;
          (%o17)                                 0
          (%i18) christof(false);
          (%o18)                               done
          (%i19) ricci(false);
          (%o19)                               done
          (%i20) einstein(false);
          (%o20)                               done
          (%i21) ntermst(ein);
          [[1, 1], 6]
          [[1, 2], 0]
          [[1, 3], 0]
          [[1, 4], 0]
          [[2, 1], 0]
          [[2, 2], 13]
          [[2, 3], 2]
          [[2, 4], 0]
          [[3, 1], 0]
          [[3, 2], 2]
          [[3, 3], 9]
          [[3, 4], 0]
          [[4, 1], 0]
          [[4, 2], 0]
          [[4, 3], 0]
          [[4, 4], 9]
          (%o21)                               done
          (%i22) ratsimp(ein[1,1]);
                                   2      2  4               2     2
          (%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                                        r               r r

                                      2               2      4    2
                        - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                                 r r                r



     この能力は 例えば、 重力源から遠く、弱い場極限で取り組む時に 役に立
     つかもしれません。

26.2.4 Frame fields
-------------------

変数 ‘cframe_flag’が trueに設定している時、 ‘ctensor’パッケージは 動標構
(moving frame)を使って計算を実行します。

 -- 関数: frame_bracket (<fr>, <fri>, <diagframe>)
     標構(frame)ブラケット (‘fb[]’).

     以下の定義に従って標構ブラケットを計算します:

             c          c         c        d     e
          ifb   = ( ifri    - ifri    ) ifr   ifr
             ab         d,e       e,d      a     b

26.2.5 Algebraic classification
-------------------------------

‘ctensor’の(2004年11月時点で)新しい特長は 4次元時空計量のPetrov分類を計
算する能力です。 この機能のデモンストレーションは、 ファイル
‘share/tensor/petrov.dem’参照してください。

 -- 関数: nptetrad ()
     Newman-Penroseヌルテトラド(null tetrad) (‘np’)と上付き添字対応物
     (‘npi’)を計算します。 例えば、 ‘petrov’を参照してください。

     ヌルテトラドは 計量符号 (-,+,+,+)を持つ4次元直交標構計量が使われい
     るという仮定の上で 構成されます。 ヌルテトラドの成分は、 以下のよう
     に、 逆標構行列に関係します:


          np  = (fri  + fri ) / sqrt(2)
            1       1      2

          np  = (fri  - fri ) / sqrt(2)
            2       1      2

          np  = (fri  + %i fri ) / sqrt(2)
            3       3         4

          np  = (fri  - %i fri ) / sqrt(2)
            4       3         4

 -- 関数: psi (<dis>)
     5つの Newman-Penrose係数 ‘psi[0]’...‘psi[4]’を計算します。 もし
     ‘dis’が ‘true’に設定されているなら、 係数が表示されます。 例は
     ‘petrov’を参照してください。

     これらの係数は 座標基底に関して、Weylテンソルから計算されます。 も
     し標構基底が使われるなら、 最初にWeylテンソルが座標基底に変換されま
     す。 座標基底は計算に関して高価な手続きであり得ます。 この理由で、
     いくつかの場合、 Weylテンソルを計算する前に まず座標基底を使うこと
     はより都合がいいかも知れません。 しかし、 Newman-Penroseヌルテトラ
     ドを構成することは標構基底を要求することに注意してください。 それ故
     に、 重要な一連の計算は、標構基底で始めることができます。 標構基底
     は、後で (‘cmetric’が自動的に計算する) ‘lg’と ‘ug’を計算するのに使
     われます。 この時点で、 Christoffel記号を計算し始める前に
     ‘cframe_flag’を falseに設定することで 座標基底に戻ることができます
     。 後の段階で標構基底に変えることは、 標構基底で計算したいくつか、
     座標基底でのいくつかと 2つを識別する方法がないまま、テンソルの混ざ
     った状態で終わるかもしれないので、 矛盾する結果をもたらすかもしれま
     せん。

 -- 関数: petrov ()
     ‘psi[0]’...‘psi[4]’で特徴付けられる 計量のPetrov分類を計算します。

     例えば、以下は Kerr計量の Petrov分類を得る方法を例示します:

          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) ug:invert(lg)$
          (%i5) weyl(false);
          (%o5)                                done
          (%i6) nptetrad(true);
          (%t6) np =

          [ sqrt(r - 2 m)           sqrt(r)                                 ]
          [---------------   ---------------------    0            0        ]
          [sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                          ]
          [                                                                 ]
          [ sqrt(r - 2 m)            sqrt(r)                                ]
          [---------------  - ---------------------   0            0        ]
          [sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                         ]
          [                                                                 ]
          [                                          r      %i r sin(theta) ]
          [       0                    0          -------   --------------- ]
          [                                       sqrt(2)       sqrt(2)     ]
          [                                                                 ]
          [                                          r       %i r sin(theta)]
          [       0                    0          -------  - ---------------]
          [                                       sqrt(2)        sqrt(2)    ]

                                       sqrt(r)         sqrt(r - 2 m)
          (%t7) npi = matrix([- ---------------------,---------------, 0, 0],
                                sqrt(2) sqrt(r - 2 m) sqrt(2) sqrt(r)

                    sqrt(r)            sqrt(r - 2 m)
          [- ---------------------, - ---------------, 0, 0],
             sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

                     1               %i
          [0, 0, ---------, --------------------],
                 sqrt(2) r  sqrt(2) r sin(theta)

                     1                 %i
          [0, 0, ---------, - --------------------])
                 sqrt(2) r    sqrt(2) r sin(theta)

          (%o7)                                done
          (%i7) psi(true);
          (%t8)                              psi  = 0
                                                0

          (%t9)                              psi  = 0
                                                1

                                                    m
          (%t10)                             psi  = --
                                                2    3
                                                    r

          (%t11)                             psi  = 0
                                                3

          (%t12)                             psi  = 0
                                                4
          (%o12)                               done
          (%i12) petrov();
          (%o12)                                 D

     Petrov分類関数は以下の文献で発表されたアルゴリズムに基づいています
     。

     "Classifying geometries in general relativity: III Classification
     in practice" by Pollney, Skea, and d’Inverno, Class.  Quant.  Grav.
     17 2885-2902 (2000).

     いくつかの簡単なテストケースを除いて、 2004年12月19日時点、実装はテ
     ストされていなく、 エラーを含みそうです。

26.2.6 Torsion and nonmetricity
-------------------------------

‘ctensor’は ねじれ係数と非計量性係数を計算し、接続係数内に含める能力を持
ちます。

   ねじれ係数はゆーざーが供給するテンソル ‘tr’から計算されます。 ‘tr’は
階数 (2,1)テンソルでなければいけません。 これから、 ねじれ係数 ‘kt’は以
下の公式に従って計算されます:


                   m          m      m
            - g  tr   - g   tr   - tr   g
               im  kj    jm   ki     ij  km
     kt   = -------------------------------
       ijk                 2


       k     km
     kt   = g   kt
       ij         ijm

   混合添字テンソルだけが計算され、配列 ‘kt’に格納されることに注意してく
ださい。

   非計量性係数はユーザーが供給する非計量性ベクトル ‘nm’から計算されます
。 これから、 非計量性係数 ‘nmc’は以下のように計算されます:


                  k    k        km
            -nm  D  - D  nm  + g   nm  g
        k      i  j    i   j         m  ij
     nmc  = ------------------------------
        ij                2

   ここで、DはKroneckerのデルタを表します。

   ‘ctorsion_flag’が ‘true’に設定されている時、 ‘kt’の値が ‘christof’で
計算された 混合添字付き接続係数から引かれ、 ‘mcs’に格納されます。 同様に
、もし ‘cnonmet_flag’が ‘true’に設定されているなら、 ‘nmc’の値が 混合添
字付き接続係数から引かれます。

   もし必要なら、 ‘christof’は、 ‘kt’と ‘nm’を計算するために 関数
‘contortion’と ‘nonmetricity’をコールします。

 -- 関数: contortion (<tr>)

     ねじれテンソル <tr>から(2,1)コントーション(contortion)係数を計算し
     ます。

 -- 関数: nonmetricity (<nm>)

     非計量性ベクトル <nm>から(2,1)非計量性係数を計算します。

26.2.7 Miscellaneous features
-----------------------------

 -- 関数: ctransform (<M>)
     任意の平方対称行列 <M>上で座標変換を実行する ‘ctensor’ (成分テンソ
     ル)パッケージの関数。 ユーザーは変換を定義する函数を入力しなければ
     いけません。 (以前‘transform’と呼ばれていました。)

 -- 関数: findde (<A>, <n>)

     <n>次元の平方配列 <A>要素に対応する 独自の(unique)微分方程式(式)の
     リストを返します。 現在、 <n>は2か3を指定できます ‘deindex’は これ
     らの独自の微分方程式に従う <A>の添字を含む グローバルリストです。
     2次元配列であるEinsteinテンソル (‘ein’)に関して、 もし以下の例で計
     量に関して計算するなら、 ‘findde’は以下の独立微分方程式を与えます:

          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) dim:4;
          (%o3)                                  4
          (%i4) lg:matrix([a, 0, 0, 0], [ 0, x^2, 0, 0],
                                        [0, 0, x^2*sin(y)^2, 0], [0,0,0,-d]);
                                    [ a  0       0        0  ]
                                    [                        ]
                                    [     2                  ]
                                    [ 0  x       0        0  ]
          (%o4)                     [                        ]
                                    [         2    2         ]
                                    [ 0  0   x  sin (y)   0  ]
                                    [                        ]
                                    [ 0  0       0       - d ]
          (%i5) depends([a,d],x);
          (%o5)                            [a(x), d(x)]
          (%i6) ct_coords:[x,y,z,t];
          (%o6)                            [x, y, z, t]
          (%i7) cmetric();
          (%o7)                                done
          (%i8) einstein(false);
          (%o8)                                done
          (%i9) findde(ein,2);
                                                      2
          (%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x
                  x                     x x         x        x    x

                                                        2          2
                                    + 2 a d d   - 2 a  d , a  x + a  - a]
                                             x       x      x
          (%i10) deindex;
          (%o10)                     [[1, 1], [2, 2], [4, 4]]

 -- 関数: cograd ()
     スカラ関数の 共変勾配を計算します。 ‘contragrad’が以下で例示する例
     のように ユーザーは対応するベクトル名を選べます。

 -- 関数: contragrad ()

     スカラ関数の反変勾配を計算します。 Computes the contravariant
     gradient of a scalar function allowing Schwarzschild計量に関する以
     下の例が例示するように ユーザーは対応するベクトル名を選べます:

          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(f,r);
          (%o4)                               [f(r)]
          (%i5) cograd(f,g1);
          (%o5)                                done
          (%i6) listarray(g1);
          (%o6)                            [0, f , 0, 0]
                                                r
          (%i7) contragrad(f,g2);
          (%o7)                                done
          (%i8) listarray(g2);
                                         f  r - 2 f  m
                                          r        r
          (%o8)                      [0, -------------, 0, 0]
                                               r

 -- 関数: dscalar ()
     依存性が関数に宣言されるとすぐ、 スカラ関数のテンソルd’Alembert演算
     子を計算します。 例えば:

          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) derivabbrev:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) depends(p,r);
          (%o4)                               [p(r)]
          (%i5) factor(dscalar(p));
                                    2
                              p    r  - 2 m p    r + 2 p  r - 2 m p
                               r r           r r        r          r
          (%o5)               --------------------------------------
                                                 2
                                                r

 -- 関数: checkdiv ()

     ベクトル場(発散)の対応するn個の成分を印字することで (最初の添字が共
     変でなければいけない)混合二階テンソルの共変発散を計算します。 ここ
     でn = ‘dim’です。 もし関数の引数が ‘g’なら、 Einsteinテンソルの発散
     が形成され、零にならなければいけません。 加えて、発散(ベクトル)は 配
     列名 ‘div’を与えられます。

 -- 関数: cgeodesic (<dis>)
     ‘ctensor’ (成分テンソル)パッケージの関数。 ‘cgeodesic’は 与えられた
     計量での運動の測地方程式を計算します。 それらは配列 ‘geod[i]’に格納
     されます。 もし引数 <dis>が ‘true’なら、 これらの方程式が表示されま
     す。

 -- 関数: bdvac (<f>)

     Brans- Dicke重力理論の 真空場の方程式の 共変成分を生成します。 スカ
     ラ場は引数 <f>で指定されます。 <f>は、 例えば、‘'p(x)’のように、 関
     数依存性を持つ(クォートされた)関数名でなければいけません。

     二階共変場テンソルの成分は配列 ‘bd’で表されます。

 -- 関数: invariant1 ()

     R^2の不変密度に関する 混合Euler- Lagrangeテンソル(場の方程式)を生成
     します。 場の方程式は ‘inv1’と名付けられた配列の成分です。

 -- 関数: invariant2 ()

     *** NOT YET IMPLEMENTED ***

     ‘ric[i,j]*uriem[i,j]’の不変密度に関する 混合Euler- Lagrangeテンソル
     (場の方程式)を生成します。 場の方程式は ‘inv2’と名付けられた配列の
     成分です。

 -- 関数: bimetric ()

     *** NOT YET IMPLEMENTED ***

     Rosenの二計量(bimetric)理論の場の方程式を生成します。 場の方程式は
     ‘rosen’と名付けられた配列の成分です。

26.2.8 Utility functions
------------------------

 -- 関数: diagmatrixp (<M>)

     もし <M>が対角行列か対角 (2D) 配列なら ‘true’を返します。

 -- 関数: symmetricp (<M>)

     もし <M>が対称行列か対称 (2D) 配列なら ‘true’を返します。

 -- 関数: ntermst (<f>)
     ユーザーに 二重に下付き添字テンソル(配列) <f>の「サイズ」のquick
     pictureを与えます。 二番目の要素が 一番目の要素が指定する成分の
     NTERMSに対応する2つの要素のリストを印字します。 この方法で、 非零式
     をすばやく見つけて整理を試みることが可能です。

 -- 関数: cdisplay (<ten>)
     多次元配列で表されるように、 テンソル <ten>の要素すべてを表示します
     。 他のタイプの変数はもちろん、 階数0と1のテンソルが ‘ldisplay’を使
     ったように表示されます。 階数2のテンソルは 2次元行列として表示され
     、 より高い階数のテンソルは2次元行列のリストとして表示されます。 例
     えば、 Schwarzschild計量のRiemannテンソルは以下のように見ることがで
     きます:

          (%i1) load("ctensor");
          (%o1)       /share/tensor/ctensor.mac
          (%i2) ratfac:true;
          (%o2)                                true
          (%i3) ct_coordsys(exteriorschwarzschild,all);
          (%o3)                                done
          (%i4) riemann(false);
          (%o4)                                done
          (%i5) cdisplay(riem);
                    [ 0               0                   0           0     ]
                    [                                                       ]
                    [                              2                        ]
                    [      3 m (r - 2 m)   m    2 m                         ]
                    [ 0  - ------------- + -- - ----      0           0     ]
                    [            4          3     4                         ]
                    [           r          r     r                          ]
                    [                                                       ]
          riem    = [                                m (r - 2 m)            ]
              1, 1  [ 0               0              -----------      0     ]
                    [                                     4                 ]
                    [                                    r                  ]
                    [                                                       ]
                    [                                           m (r - 2 m) ]
                    [ 0               0                   0     ----------- ]
                    [                                                4      ]
                    [                                               r       ]

                                          [    2 m (r - 2 m)       ]
                                          [ 0  -------------  0  0 ]
                                          [          4             ]
                                          [         r              ]
                               riem     = [                        ]
                                   1, 2   [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]

                                          [         m (r - 2 m)    ]
                                          [ 0  0  - -----------  0 ]
                                          [              4         ]
                                          [             r          ]
                               riem     = [                        ]
                                   1, 3   [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]
                                          [                        ]
                                          [ 0  0        0        0 ]

                                          [            m (r - 2 m) ]
                                          [ 0  0  0  - ----------- ]
                                          [                 4      ]
                                          [                r       ]
                               riem     = [                        ]
                                   1, 4   [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]
                                          [                        ]
                                          [ 0  0  0        0       ]

                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       2 m               ]
                                         [ - ------------  0  0  0 ]
                              riem     = [    2                    ]
                                  2, 1   [   r  (r - 2 m)          ]
                                         [                         ]
                                         [       0         0  0  0 ]
                                         [                         ]
                                         [       0         0  0  0 ]

                       [     2 m                                         ]
                       [ ------------  0        0               0        ]
                       [  2                                              ]
                       [ r  (r - 2 m)                                    ]
                       [                                                 ]
                       [      0        0        0               0        ]
                       [                                                 ]
            riem     = [                         m                       ]
                2, 2   [      0        0  - ------------        0        ]
                       [                     2                           ]
                       [                    r  (r - 2 m)                 ]
                       [                                                 ]
                       [                                         m       ]
                       [      0        0        0         - ------------ ]
                       [                                     2           ]
                       [                                    r  (r - 2 m) ]

                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [            m          ]
                                          [ 0  0  ------------  0 ]
                               riem     = [        2              ]
                                   2, 3   [       r  (r - 2 m)    ]
                                          [                       ]
                                          [ 0  0       0        0 ]
                                          [                       ]
                                          [ 0  0       0        0 ]

                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [               m       ]
                                          [ 0  0  0  ------------ ]
                               riem     = [           2           ]
                                   2, 4   [          r  (r - 2 m) ]
                                          [                       ]
                                          [ 0  0  0       0       ]
                                          [                       ]
                                          [ 0  0  0       0       ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [ m          ]
                                         3, 1   [ -  0  0  0 ]
                                                [ r          ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                                [ 0  0  0  0 ]
                                                [            ]
                                                [ 0  0  0  0 ]
                                                [            ]
                                     riem     = [    m       ]
                                         3, 2   [ 0  -  0  0 ]
                                                [    r       ]
                                                [            ]
                                                [ 0  0  0  0 ]

                                         [   m                      ]
                                         [ - -   0   0       0      ]
                                         [   r                      ]
                                         [                          ]
                                         [        m                 ]
                                         [  0   - -  0       0      ]
                              riem     = [        r                 ]
                                  3, 3   [                          ]
                                         [  0    0   0       0      ]
                                         [                          ]
                                         [              2 m - r     ]
                                         [  0    0   0  ------- + 1 ]
                                         [                 r        ]

                                              [ 0  0  0    0   ]
                                              [                ]
                                              [ 0  0  0    0   ]
                                              [                ]
                                   riem     = [            2 m ]
                                       3, 4   [ 0  0  0  - --- ]
                                              [             r  ]
                                              [                ]
                                              [ 0  0  0    0   ]

                                          [       0        0  0  0 ]
                                          [                        ]
                                          [       0        0  0  0 ]
                                          [                        ]
                               riem     = [       0        0  0  0 ]
                                   4, 1   [                        ]
                                          [      2                 ]
                                          [ m sin (theta)          ]
                                          [ -------------  0  0  0 ]
                                          [       r                ]

                                          [ 0        0        0  0 ]
                                          [                        ]
                                          [ 0        0        0  0 ]
                                          [                        ]
                               riem     = [ 0        0        0  0 ]
                                   4, 2   [                        ]
                                          [         2              ]
                                          [    m sin (theta)       ]
                                          [ 0  -------------  0  0 ]
                                          [          r             ]

                                        [ 0  0          0          0 ]
                                        [                            ]
                                        [ 0  0          0          0 ]
                                        [                            ]
                             riem     = [ 0  0          0          0 ]
                                 4, 3   [                            ]
                                        [                2           ]
                                        [         2 m sin (theta)    ]
                                        [ 0  0  - ---------------  0 ]
                                        [                r           ]

                     [        2                                             ]
                     [   m sin (theta)                                      ]
                     [ - -------------         0                0         0 ]
                     [         r                                            ]
                     [                                                      ]
                     [                         2                            ]
                     [                    m sin (theta)                     ]
          riem     = [        0         - -------------         0         0 ]
              4, 4   [                          r                           ]
                     [                                                      ]
                     [                                          2           ]
                     [                                   2 m sin (theta)    ]
                     [        0                0         ---------------  0 ]
                     [                                          r           ]
                     [                                                      ]
                     [        0                0                0         0 ]

          (%o5)                                done

 -- 関数: deleten (<L>, <n>)
     <n>番目の要素を削除した<L>から成る新しいリストを返します。

26.2.9 Variables used by ‘ctensor’
----------------------------------

 -- オプション変数: dim
     デフォルト値: 4

     ‘ctensor’ (成分テンソル)パッケージのオプション。 ‘dim’は デフォルト
     4の多様体の次元です。 コマンド ‘dim: n’は 次元を任意の別の値 ‘n’に
     再設定します。

 -- オプション変数: diagmetric
     デフォルト値: ‘false’

     ‘ctensor’ (成分テンソル)パッケージのオプション。 もし ‘diagmetric’が
     ‘true’なら、 特殊なルーチンが 計量の対角性を考慮して (計量テンソル
     を明示的に含む)幾何的オブジェクトすべてを 計算します。 もちろん、実
     行時間短縮になります。 注意: もし対角計量が指定されたら、 ‘csetup’は
     自動的にこのオプションを設定します。

 -- オプション変数: ctrgsimp

     テンソルを計算する時、三角関数整理を使うようにします。 現在、
     ‘ctrgsimp’は 動標構を含む計算だけに影響します。

 -- オプション変数: cframe_flag

     計算を ホロノミック(holonomic)計量と対比して動標構に関係して実行す
     るようにします。 標構は逆標構配列 ‘fri’と標構計量 ‘lfg’で定義されま
     す。 Cartesian標構を使う計算に関して、 ‘lfg’は適切な次元の単位行列
     でなければいけません; Lorentz標構での計算に関して、 ‘lfg’は適切な符
     号を持たなければいけません。

 -- オプション変数: ctorsion_flag

     コントーションテンソルが 接続係数の計算に含まれるようにします。 コ
     ントーションテンソル自体は ユーザーが提供するテンソル ‘tr’から
     ‘contortion’によって計算されます。

 -- オプション変数: cnonmet_flag

     非計量性係数が 接続係数の計算に含まれるようにします。 コントーショ
     ンテンソルは ユーザーが提供する非計量性ベクトル ‘nm’から 関数
     ‘nonmetricity’によって計算されます。

 -- オプション変数: ctayswitch

     もし ‘true’に設定されているなら、 いくつかの ‘ctensor’計算が
     Taylor級数展開を使って実行されるようにします。 現在、 ‘christof’,
     ‘ricci’, ‘uricci’, ‘einstein’, ‘weyl’がこの設定を考慮します。

 -- オプション変数: ctayvar

     ‘ctayswitch’が ‘true’に設定されているなら Taylor級数展開で使われる
     変数。

 -- オプション変数: ctaypov

     ‘ctayswitch’が ‘true’に設定されている時 Taylor級数展開で使われる最
     大べき数

 -- オプション変数: ctaypt

     ‘ctayswitch’が ‘true’に設定されている時 Taylor級数展開が実行される
     点。

 -- システム変数: gdet

     計量テンソル ‘lg’の行列式。 ‘cframe_flag’が ‘false’に設定されている
     時、 ‘cmetric’によって計算されます。

 -- オプション変数: ratchristof

     ‘christof’が有理整理を適用するようにします。

 -- オプション変数: rateinstein
     デフォルト値: ‘true’

     もし ‘true’なら、 Einsteinテンソルの非零成分上で 有理整理が実行され
     ます; もし ‘ratfac’が ‘true’なら、 成分は因数分解もされます。

 -- オプション変数: ratriemann
     デフォルト値: ‘true’

     Riemannテンソルの整理を制御するスイッチの1つです; もし ‘true’なら、
     有理整理がされます; もし ‘ratfac’が ‘true’なら、 成分それぞれは因数
     分解もされます。

 -- オプション変数: ratweyl
     デフォルト値: ‘true’

     もし ‘true’なら、 このスイッチは, ‘weyl’関数が Weylテンソルの値に有
     理整理を適用するようにします。 もし‘ratfac’が ‘true’なら、 成分は因
     数分解もされます。

 -- 変数: lfg
     共変標構計量。 デフォルトでは、 符号 (+,+,+,-)を持つ4次元Lorentz標
     構に初期化されます。 ‘cframe_flag’が ‘true’の時使われます。

 -- 変数: ufg
     逆標構計量。 ‘cframe_flag’が ‘true’に設定されているなら、
     ‘cmetric’がコールされた時 ‘lfg’から計算されます。

 -- 変数: riem
     (3,1) Riemannテンソル。 関数 ‘riemann’が呼び出された時計算されます
     。 添字順序についての情報については、 ‘riemann’の記述を参照してくだ
     さい。

     もし ‘cframe_flag’が ‘true’なら、 ‘riem’は 共変Riemannテンソル
     ‘lriem’から計算されます。

 -- 変数: lriem

     共変Riemannテンソル。 ‘lriemann’が計算します。

 -- 変数: uriem

     反変Riemannテンソル。

 -- 変数: ric

     混合Ricciテンソル。 ‘ricci’が計算します。

 -- 変数: uric

     反変Ricciテンソル。 ‘ricci’が計算します。

 -- 変数: lg

     計量テンソル。 このテンソルは 他の計算が実行される前に (‘dim’掛け
     ‘dim’行列として)指定されなければいけません。

 -- 変数: ug

     計量テンソルの逆元。 ‘cmetric’が計算します。

 -- 変数: weyl

     Weylテンソル。 ‘weyl’が計算します。

 -- 変数: fb

     ‘frame_bracket’によって計算される、 標構ブラケット係数。

 -- 変数: kinvariant

     Kretchmann不変量。 ‘rinvariant’が計算します。

 -- 変数: np

     Newman-Penroseヌルテトラド。 ‘nptetrad’が計算します。

 -- 変数: npi

     上付き添字 Newman-Penroseヌルテトラド。 ‘nptetrad’が計算します。
     ‘ug.np’として定義されます。 積 ‘np.transpose(npi)’は定数です:

          (%i39) trigsimp(np.transpose(npi));
                                        [  0   - 1  0  0 ]
                                        [                ]
                                        [ - 1   0   0  0 ]
          (%o39)                        [                ]
                                        [  0    0   0  1 ]
                                        [                ]
                                        [  0    0   1  0 ]

 -- 変数: tr

     ユーザーが提供するねじれを表す階数3のテンソル ‘contortion’が使いま
     す。

 -- 変数: kt

     コントーションテンソル。 ‘contortion’が ‘tr’から計算します。

 -- 変数: nm

     ユーザーが提供する非計量性ベクトル。 ‘nonmetricity’が使います。

 -- 変数: nmc

     ‘nonmetricity’が ‘nm’から計算する 非計量性係数。

 -- システム変数: tensorkill

     テンソルパッケージが初期化されたかを示す変数。 ‘csetup’が設定し使い
     ます。 ‘init_ctensor’が再設定します。

 -- オプション変数: ct_coords
     デフォルト値: ‘[]’

     ‘ctensor’ (成分テンソル)パッケージのオプション。 ‘ct_coords’は座標
     のリストを含みます。 関数 ‘csetup’がコールされる時通常定義される一
     方、 割り当て ‘ct_coords: [j1, j2, ..., jn]’で座標を再定義できます
     。 ここで、jは新しい座標名です。 ‘csetup’も参照してください。

26.2.10 Reserved names
----------------------

‘ctensor’パッケージによって 以下の名前が内部的に使われます。 なので再定
義してはいけません:

       Name         Description
       ---------------------------------------------------------------------
       _lg()        Evaluates to lfg if frame metric used, lg otherwise
       _ug()        Evaluates to ufg if frame metric used, ug otherwise
       cleanup()    Removes items drom the deindex list
       contract4()  Used by psi()
       filemet()    Used by csetup() when reading the metric from a file
       findde1()    Used by findde()
       findde2()    Used by findde()
       findde3()    Used by findde()
       kdelt()      Kronecker-delta (not generalized)
       newmet()     Used by csetup() for setting up a metric interactively
       setflags()   Used by init_ctensor()
       readvalue()
       resimp()
       sermet()     Used by csetup() for entering a metric as Taylor-series
       txyzsum()
       tmetric()    Frame metric, used by cmetric() when cframe_flag:true
       triemann()   Riemann-tensor in frame base, used when cframe_flag:true
       tricci()     Ricci-tensor in frame base, used when cframe_flag:true
       trrc()       Ricci rotation coefficients, used by christof()
       yesp()

26.2.11 Changes
---------------

2004年11月に ‘ctensor’パッケージは広範囲に渡って書き直されました。 多く
の関数と変数は、パッケージにMacsymaの商用版との互換性を持たせるために、
リネームされました。

       New Name     Old Name        Description
       ---------------------------------------------------------------------
       ctaylor()    DLGTAYLOR()     Taylor-series expansion of an expression
       lgeod[]      EM              Geodesic equations
       ein[]        G[]             Mixed Einstein-tensor
       ric[]        LR[]            Mixed Ricci-tensor
       ricci()      LRICCICOM()     Compute the mixed Ricci-tensor
       ctaypov      MINP            Maximum power in Taylor-series expansion
       cgeodesic()  MOTION          Compute geodesic equations
       ct_coords    OMEGA           Metric coordinates
       ctayvar      PARAM           Taylor-series expansion variable
       lriem[]      R[]             Covariant Riemann-tensor
       uriemann()   RAISERIEMANN()  Compute the contravariant Riemann-tensor
       ratriemann   RATRIEMAN       Rational simplif. of the Riemann-tensor
       uric[]       RICCI[]         Contravariant Ricci-tensor
       uricci()     RICCICOM()      Compute the contravariant Ricci-tensor
       cmetric()    SETMETRIC()     Set up the metric
       ctaypt       TAYPT           Point for Taylor-series expansion
       ctayswitch   TAYSWITCH       Taylor-series setting switch
       csetup()     TSETUP()        Start interactive setup session
       ctransform() TTRANSFORM()    Interactive coordinate transformation
       uriem[]      UR[]            Contravariant Riemann-tensor
       weyl[]       W[]             (3,1) Weyl-tensor


File: maxima.info,  Node: atensor,  Next: Sums Products and Series,  Prev: ctensor,  Up: Top

27 atensor
**********

* Menu:

* Introduction to atensor::
* Functions and Variables for atensor::


File: maxima.info,  Node: Introduction to atensor,  Next: Functions and Variables for atensor,  Prev: atensor,  Up: atensor

27.1 Introduction to atensor
============================

‘atensor’は、代数テンソル操作パッケージです。 ‘atensor’を使うには、
‘load("atensor")’をタイプしてください。 続いて、‘init_atensor’関数コール
してください。

   ‘atensor’の本質は非可換(ドット)積演算子 ("‘.’")の整理ルール一式です
‘atensor’はいくつかの代数型を認識します; ‘init_atensor’関数がコールされ
た時、 対応する整理ルールが有効になります。

   ‘atensor’の能力は、 四元数代数を2つの基底ベクトルを持つClifford代数
Cl(0,2)として 定義することで実演することができます。 3つの四元数虚数単位
は2つの基底ベクトルとその積、すなわち以下の通りです:

         i = v     j = v     k = v  . v
              1         2         1    2

   ‘atensor’パッケージは 四元数代数に関する組み込みの定義を持ちますが、
この例では使わず、四元数乗算表を行列として組むよう試みます:

     (%i1) load("atensor");
     (%o1)       /share/tensor/atensor.mac
     (%i2) init_atensor(clifford,0,0,2);
     (%o2)                                done
     (%i3) atensimp(v[1].v[1]);
     (%o3)                                 - 1
     (%i4) atensimp((v[1].v[2]).(v[1].v[2]));
     (%o4)                                 - 1
     (%i5) q:zeromatrix(4,4);
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%o5)                           [            ]
                                     [ 0  0  0  0 ]
                                     [            ]
                                     [ 0  0  0  0 ]
     (%i6) q[1,1]:1;
     (%o6)                                  1
     (%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
     (%o7)                                done
     (%i8) q[1,4]:q[4,1]:v[1].v[2];
     (%o8)                               v  . v
                                          1    2
     (%i9) for i from 2 thru 4 do for j from 2 thru 4 do
           q[i,j]:atensimp(q[i,1].q[1,j]);
     (%o9)                                done
     (%i10) q;
                        [    1        v         v      v  . v  ]
                        [              1         2      1    2 ]
                        [                                      ]
                        [   v         - 1     v  . v    - v    ]
                        [    1                 1    2      2   ]
     (%o10)             [                                      ]
                        [   v      - v  . v     - 1      v     ]
                        [    2        1    2              1    ]
                        [                                      ]
                        [ v  . v      v        - v       - 1   ]
                        [  1    2      2          1            ]

   ‘atensor’は 添字付きシンボルを基底ベクトルと認識します。 シンボルは
‘asymbol’の中に記憶されたものであり、 添字は1から‘adim’まで間です。 添字
付きシンボルだけに関して 双一次形式 ‘sf’, ‘af’, ‘av’が評価されます。 評
価は ‘fun(v[i],v[j])’に ‘aform[i,j]’の値を代入します ここで、‘v’は
‘asymbol’の値を表し、 ‘fun’は ‘af’か ‘sf’を示します; あるいは、
‘av(v[i],v[j])’に ‘v[aform[i,j]]’を代入します。

   言うまでもなく、関数 ‘sf’, ‘af’, ‘av’は再定義するこができます。

   ‘atensor’パッケージがロードされる時、以下のフラグが設定されます:

     dotscrules:true;
     dotdistrib:true;
     dotexptsimp:false;

   もし非結合代数で実験したいなら、 ‘dotassoc’を ‘false’に設定することも
考えるかもしれません。 しかし、この場合、 ‘atensimp’はいつも 望みの整理
を得ることができるわけではありません。


File: maxima.info,  Node: Functions and Variables for atensor,  Prev: Introduction to atensor,  Up: atensor

27.2 Functions and Variables for atensor
========================================

 -- 関数: init_atensor (<alg_type>, <opt_dims>)
 -- 関数: init_atensor (<alg_type>)

     特定の代数型で ‘atensor’パッケージを初期化します。 <alg_type>は以下
     のいずれかであり得ます:

     ‘universal’: 普遍代数は交換規則を持ちません。

     ‘grassmann’: Grassman代数は交換関係 ‘u.v+v.u=0’で定義されます。

     ‘clifford’: Clifford代数は 交換関係 ‘u.v+v.u=-2*sf(u,v)’で定義され
     ます。 ここで、 ‘sf’は対称スカラ値函数です。 この代数では、
     <opt_dims>は、 代数の正の次元数、縮退次元数、負の次元数をそれぞれ表
     す3つの非負整数までありえます。 もしいずれかの <opt_dims>値が供給さ
     れたら、 ‘atensor’は ‘adim’と ‘aform’の値を適切に構成します。 そう
     でなければ、 ‘adim’はデフォルトが0で、 ‘aform’は未定義です。

     ‘symmetric’: 対称代数は交換関係 ‘u.v-v.u=0’で定義されます。

     ‘symplectic’: シンプレクティック代数は 交換関係
     ‘u.v-v.u=2*af(u,v)’で定義されます。 ここで、 ‘af’は反対称スカラ値函
     数です。 シンプレクティック代数では、 <opt_dims>は 非縮退次元数、縮
     退次元数をそれぞれ表す2つの非負整数までありえます。 もしいずれかの
     <opt_dims>値が供給されたら、 ‘atensor’は ‘adim’と ‘aform’の値を適切
     に構成します。 そうでなければ、 ‘adim’はデフォルトが0で、 ‘aform’は
     未定義です。

     ‘lie_envelop’: Lie包絡代数は交換関係 ‘u.v-v.u=2*av(u,v)’で定義され
     ます。 ここで、 ‘av’は反対称函数です。

     ‘init_atensor’関数はいくつかの予め定義された代数型も認識します:

     ‘complex’は複素数代数をClifford代数 Cl(0,1)として実装します。
     ‘init_atensor(complex)’をコールすることは
     ‘init_atensor(clifford,0,0,1)’と同値です。

     ‘quaternion’は四元数代数を実装します。 ‘init_atensor (quaternion)’を
     コールすることは ‘init_atensor (clifford,0,0,2)’と同値です。

     ‘pauli’はPauliスピノール代数をClifford代数 Cl(3,0)として実装します
     。 ‘init_atensor(pauli)’をコールすることは
     ‘init_atensor(clifford,3)’と同値です。

     ‘dirac’はDiracスピノール代数をClifford代数 Cl(3,1)として実装します
     。 ‘init_atensor(dirac)’をコールすることは
     ‘init_atensor(clifford,3,0,1)’と同値です。

 -- 関数: atensimp (<expr>)

     ‘init_atensor’のコールで構成された規則に従って、 代数テンソル式
     <expr>を整理します。 整理は、 適用可能な場所への 交換関係の再帰的な
     適用と‘sf’, ‘af’, ‘av’のコールの決定を含みます。 複雑な式に関してさ
     え、 関数がいつでも終了することを確実にするために 保護手段が使われ
     ます。

 -- 変数: adim
     デフォルト値: 0

     代数の次元。 ‘atensor’は 添字付きオブジェクトが有効な基底ベクトルか
     決定するのに ‘adim’の値を使います。 ‘abasep’を参照してください。

 -- 変数: aform
     デフォルト値: ‘ident(3)’

     双一次形式‘sf’, ‘af’, ‘av’のデフォルト値。 デフォルトは、単位行列
     ‘ident(3)’です。

 -- 変数: asymbol
     デフォルト値: ‘v’

     基底ベクトルのシンボル。

 -- 関数: sf (<u>, <v>)

     交換関係で使われる対称スカラ関数。 デフォルトの実装は 両方の引数が
     ‘abasep’を使った基底ベクトルかチェックし、 もしそうなら、行列
     ‘aform’から対応する値を代入します。

 -- 関数: af (<u>, <v>)

     交換関係で使われる反対称スカラ関数。 デフォルトの実装は 両方の引数
     が‘abasep’を使った基底ベクトルかチェックし、 もしそうなら、行列
     ‘aform’から対応する値を代入します。

 -- 関数: av (<u>, <v>)

     交換関係で使われる反対称スカラ関数。 デフォルトの実装は 両方の引数
     が‘abasep’を使った基底ベクトルかチェックし、 もしそうなら、行列
     ‘aform’から対応する値を代入します。

     例えば:

          (%i1) load("atensor");
          (%o1)       /share/tensor/atensor.mac
          (%i2) adim:3;
          (%o2)                                  3
          (%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                                         [  0    3   - 2 ]
                                         [               ]
          (%o3)                          [ - 3   0    1  ]
                                         [               ]
                                         [  2   - 1   0  ]
          (%i4) asymbol:x;
          (%o4)                                  x
          (%i5) av(x[1],x[2]);
          (%o5)                                 x
                                                 3

 -- 関数: abasep (<v>)

     引数が ‘atensor’基底ベクトルかチェックします。 すなわち、
     ‘asymbol’の値と同じシンボルと 1と ‘adim’の間の数値の添字を持つ添字
     付きシンボルかどうか、チェックします。


File: maxima.info,  Node: Sums Products and Series,  Next: Number Theory,  Prev: atensor,  Up: Top

28 Sums, Products, and Series
*****************************

* Menu:

* Sums and Products::
* Introduction to Series::      
* Functions and Variables for Series::
* Poisson series::


File: maxima.info,  Node: Sums and Products,  Next: Introduction to Series,  Prev: Sums Products and Series,  Up: Sums Products and Series

28.1 Sums and Products
======================

 -- 関数: bashindices (<expr>)
     それぞれの和や積に独自のインデックスを与えることで、 式<expr>を変換
     します。 これは、 和や積と一緒に機能する時 ‘changevar’によりよい精
     度を与えます。 独自のインデックスの形式は‘j<number>’です。 量
     <number>は、‘gensumnum’に参照することで決定されます。 これを、ユー
     ザーは変更することができます。 例えば、‘gensumnum:0$’はそれを再設定
     します。

 -- 関数: lsum (<expr>, <x>, <L>)

     <L>の中のそれぞれの要素<x>に関する<expr>の和を表します。 もし引数
     <L>がリストに評価されなければ、名詞形‘'lsum’が返されます。

     例:

          (%i1) lsum (x^i, i, [1, 2, 7]);
                                      7    2
          (%o1)                      x  + x  + x
          (%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                               ====
                               \      2
          (%o2)                 >    i
                               /
                               ====
                                             3
                               i in rootsof(x  - 1, x)

 -- 関数: intosum (<expr>)

     和の外側の掛け算因子を内側に移動します。 もし外側の式でインデックス
     が使われているなら、 関数は、‘sumcontract’に関してするのと同じよう
     に、合理的なインデックスを見つけようとします。 これは、本質的に、和
     の‘outative’プロパティの逆の考えですが、 このプロパティを取り除かず
     、ただ無視するだけであることに注意してください。

     いくつかの場合、 ‘intosum’の前に、‘scanmap (multthru, <expr>)’が必
     要になるかもしれません。

 -- 関数: product (<expr>, <i>, <i_0>, <i_1>)

     インデックス<i>が<i_0>から<i_1>まで変えた<expr>の値の積を返します。
     名詞形‘'product’は、大文字Πとして表示されます。

     ‘product’は、<expr>と下限上限<i_0>、<i_1>を評価し、 ‘product’は、イ
     ンデックス<i>をクォートします（評価しません）。

     もし上限と下限が整数差だけ違うなら、 <expr>は、インデックス<i>のそ
     れぞれの値に関して評価され、 結果は陽な積です。

     そうでなければ、インデックスの範囲は不定です。 積を整理するためにい
     くつかの規則が適用されます。 グローバル変数‘simpproduct’が‘true’の
     時、 更なる規則が適用されます。 いくつかの場合、式整理は、積でない
     結果を出力します; そうでなければ、結果は名詞形‘'product’です。

     ‘nouns’と‘evflag’も参照してください。

     例:

          (%i1) product (x + i*(i+1)/2, i, 1, 4);
          (%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
          (%i2) product (i^2, i, 1, 7);
          (%o2)                       25401600
          (%i3) product (a[i], i, 1, 7);
          (%o3)                 a  a  a  a  a  a  a
                                 1  2  3  4  5  6  7
          (%i4) product (a(i), i, 1, 7);
          (%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
          (%i5) product (a(i), i, 1, n);
                                       n
                                     /===\
                                      ! !
          (%o5)                       ! !  a(i)
                                      ! !
                                     i = 1
          (%i6) product (k, k, 1, n);
                                         n
                                       /===\
                                        ! !
          (%o6)                         ! !  k
                                        ! !
                                       k = 1
          (%i7) product (k, k, 1, n), simpproduct;
          (%o7)                          n!
          (%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                                       n
                                     /===\
                                      ! !    1
          (%o8)                       ! !  -----
                                      ! !  k + 1
                                     k = 1
          (%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                                        15  40
          (%o9)                        a   b

 -- オプション変数: simpsum
     デフォルト値: ‘false’

     ‘simpsum’が‘true’の時、 ‘sum’の結果は、整理されます。 この整理は、
     時々、閉形式を生成することができるかもしれません。 もし‘simpsum’が
     ‘false’もしくは、もしクォートされた形‘'sum’が使われたなら、 値は、
     数学で使われるΣ表示の表現である和の名詞形です。

 -- 関数: sum (<expr>, <i>, <i_0>, <i_1>)

     インデックス<i>が<i_0>から<i_1>まで変えた<expr>の値の和を返します。
     名詞形‘'sum’は、大文字Σとして表示されます。

     ‘sum’は、被和<expr>と下限上限<i_0>、<i_1>を評価し、 ‘sum’は、インデ
     ックス<i>をクォートします（評価しません）。

     もし上限と下限が整数差だけ違うなら、 被和<expr>は、インデックス
     <i>のそれぞれの値に関して評価され、 結果は陽な和です。

     そうでなければ、インデックスの範囲は不定です。 積を整理するためにい
     くつかの規則が適用されます。 グローバル変数‘simpsum’が‘true’の時、
     更なる規則が適用されます。 いくつかの場合、式整理は、和でない結果を
     出力します; そうでなければ、結果は名詞形‘'sum’です。

     ‘evflag’(評価フラグ) ‘cauchysum’が‘true’の時、 和の積は、コーシー積
     として表現されます。 コーシー積では、内側の和のインデックスは、独立
     に変化するのではなく、外側の和のインデックスの関数になります。

     グローバル変数‘genindex’は、 和の次のインデックスを生成するのに使わ
     れるアルファベット前置です。

     ‘gensumnum’は、 自動生成されるインデックスが必要な時、 和の次のイン
     デックスを生成するのに使われる数値接尾です。 ‘gensumnum’が‘false’の
     時, 自動生成されるインデックスは、接尾なしの‘genindex’のみです。

     ‘sumcontract’, ‘intosum’, ‘bashindices’, ‘niceindices’, ‘nouns’,
     ‘evflag’, ‘zeilberger’も参照してください。

     例:

          (%i1) sum (i^2, i, 1, 7);
          (%o1)                          140
          (%i2) sum (a[i], i, 1, 7);
          (%o2)           a  + a  + a  + a  + a  + a  + a
                           7    6    5    4    3    2    1
          (%i3) sum (a(i), i, 1, 7);
          (%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
          (%i4) sum (a(i), i, 1, n);
                                      n
                                     ====
                                     \
          (%o4)                       >    a(i)
                                     /
                                     ====
                                     i = 1
          (%i5) sum (2^i + i^2, i, 0, n);
                                    n
                                   ====
                                   \       i    2
          (%o5)                     >    (2  + i )
                                   /
                                   ====
                                   i = 0
          (%i6) sum (2^i + i^2, i, 0, n), simpsum;
                                        3      2
                             n + 1   2 n  + 3 n  + n
          (%o6)             2      + --------------- - 1
                                            6
          (%i7) sum (1/3^i, i, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o7)                        >    --
                                      /      i
                                      ====  3
                                      i = 1
          (%i8) sum (1/3^i, i, 1, inf), simpsum;
                                          1
          (%o8)                           -
                                          2
          (%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                                        inf
                                        ====
                                        \     1
          (%o9)                      30  >    --
                                        /      2
                                        ====  i
                                        i = 1
          (%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                            2
          (%o10)                       5 %pi
          (%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                                      n
                                     ====
                                     \       1
          (%o11)                      >    -----
                                     /     k + 1
                                     ====
                                     k = 1
          (%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
                    10    9    8    7    6    5    4    3    2
          (%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a

 -- 関数: sumcontract (<expr>)
     定数だけ異なる上限と下限を持つ足し算の和すべてを結合します。 結果は
     、 そんな和のそれぞれの集合が、この和を形成するよう抽出されなければ
     ならないすべての適切な余分の項に加えられた１つの和を含む式です。
     ‘sumcontract’は、互換性のある和すべてを結合し、 可能なら和の１つか
     らインデックスの１つを使い、もし供給されたどれもが使えないなら、合
     理的なインデックスを形成するよう試みます。

     ‘sumcontract’の前に、‘intosum (<expr>)’を実行する必要があるかもしれ
     ません。

 -- オプション変数: sumexpand
     デフォルト値: ‘false’

     ‘sumexpand’が‘true’の時、 和の積と、指数和は、入れ子の和に整理され
     ます。

     ‘cauchysum’も参照してください。

     例:

          (%i1) sumexpand: true$
          (%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                               m      n
                              ====   ====
                              \      \
          (%o2)                >      >     f(i1) g(i2)
                              /      /
                              ====   ====
                              i1 = 0 i2 = 0
          (%i3) sum (f (i), i, 0, m)^2;
                               m      m
                              ====   ====
                              \      \
          (%o3)                >      >     f(i3) f(i4)
                              /      /
                              ====   ====
                              i3 = 0 i4 = 0


File: maxima.info,  Node: Introduction to Series,  Next: Functions and Variables for Series,  Prev: Sums and Products,  Up: Sums Products and Series

28.2 Introduction to Series
===========================

Maximaは、微分可能な関数の級数を見つけるために、 関数‘taylor’と
‘powerseries’を含みます。 ある級数の閉形式を見つける性能がある‘nusum’の
ようなツールも持ちます。 足し算や掛け算のような演算は、級数上で普通に機
能します。 この節は、展開を制御するグローバル変数を提供します。


File: maxima.info,  Node: Functions and Variables for Series,  Next: Poisson series,  Prev: Introduction to Series,  Up: Sums Products and Series

28.3 Functions and Variables for Series
=======================================

 -- オプション変数: cauchysum
     デフォルト値: ‘false’

     上限として‘inf’を持つ和同士を掛ける時、 もし‘sumexpand’が‘true’、か
     つ、‘cauchysum’が‘true’なら、 通常の積ではなくCauchy積が使われます
     。 Cauchy積では、 内側の和のインデックスは、独立に変化するのではな
     く、外側のインデックスの関数です。

     例:

          (%i1) sumexpand: false$
          (%i2) cauchysum: false$
          (%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                                inf         inf
                                ====        ====
                                \           \
          (%o3)                ( >    f(i))  >    g(j)
                                /           /
                                ====        ====
                                i = 0       j = 0
          (%i4) sumexpand: true$
          (%i5) cauchysum: true$
          (%i6) ''s;
                           inf     i1
                           ====   ====
                           \      \
          (%o6)             >      >     g(i1 - i2) f(i2)
                           /      /
                           ====   ====
                           i1 = 0 i2 = 0

 -- 関数: deftaylor (<f_1>(<x_1>), <expr_1>, …, <f_n>(<x_n>), <expr_n>)

     ‘deftaylor’は、 ある変数<x_i>の関数<f_i>それぞれに関して、
     <expr_i>をゼロの回りのTaylor級数と定義します。 <expr_i>は、典型的に
     は、<x_i>の多項式か和です; ‘deftaylor’は、もっと一般的な式も問題な
     く受け付けます。

     ‘powerseries (<f_i>(<x_i>), <x_i>, 0)’は、 ‘deftaylor’で定義された
     級数を返します。

     ‘deftaylor’は、 関数<f_1>, ..., <f_n>のリストを返します。
     ‘deftaylor’は、引数を評価します。

     例:

          (%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
          (%o1)                          [f]
          (%i2) powerseries (f(x), x, 0);
                                inf
                                ====      i1
                                \        x         2
          (%o2)                  >     -------- + x
                                /       i1    2
                                ====   2   i1!
                                i1 = 4
          (%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                                2         3          4
                               x    3073 x    12817 x
          (%o3)/T/     1 + x + -- + ------- + -------- + . . .
                               2     18432     307200

 -- オプション変数: maxtayorder
     デフォルト値: ‘true’

     ‘maxtayorder’が‘true’の時、 (切り詰められた)Taylor級数の代数操作の
     間、 ‘taylor’は、厳密とわかっているできるだけ多くの項を保とうとしま
     す。

 -- 関数: niceindices (<expr>)

     <expr>の中の和や積のインデックスを改名します。 ‘niceindices’は、 そ
     の名前が被加数や非積数の中に現れないなら、 インデックスそれぞれを
     ‘niceindicespref[1]’の値に改名しようとします。 現れた場合、
     ‘niceindices’は、 未使用の変数が見つかるまで‘niceindicespref’の次の
     要素を順に試します。 もしリスト全部が使い果たされたら、 例えば,
     ‘i0’, ‘i1’, ‘i2’, ....というように、 ‘niceindicespref[1]’の値に整数
     を追加することで、 追加のインデックスが構成されます。

     ‘niceindices’は式を返します。 ‘niceindices’は引数を評価します。

     例:

          (%i1) niceindicespref;
          (%o1)                  [i, j, k, l, m, n]
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j l + k)
                               ! !  /
                              l = 1 ====
                                    k = 1

 -- オプション変数: niceindicespref
     デフォルト値: ‘[i, j, k, l, m, n]’

     ‘niceindicespref’は、 ‘niceindices’が和や積のインデックスの名前を取
     ってくる リストです。

     The elements of ‘niceindicespref’の要素は、 ‘niceindices’によって強
     制されませんが、 通常、変数名です。

     例:

          (%i1) niceindicespref: [p, q, r, s, t, u]$
          (%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                           inf    inf
                          /===\   ====
                           ! !    \
          (%o2)            ! !     >      f(bar i j + foo)
                           ! !    /
                          bar = 1 ====
                                  foo = 1
          (%i3) niceindices (%);
                               inf  inf
                              /===\ ====
                               ! !  \
          (%o3)                ! !   >    f(i j q + p)
                               ! !  /
                              q = 1 ====
                                    p = 1

 -- 関数: nusum (<expr>, <x>, <i_0>, <i_1>)

     R.W. Gosperによる決定手続きを使って、 <x>に関する<expr>の不定超幾何
     総和を実行します。 <expr>と結果は、 整数べき、階乗、二項式、有理関
     数の積として表現可能でなければいけません。

     用語「定」と「不定和」は、 「定」と「不定積分」へ類似して使われてい
     ます。 不定に和を取ることは、 ただ、例えば0からinfまででなく、 変数
     の長さの区間上の和に関して、シンボリックな結果を与えることを意味し
     ます。 例えば、二項級数の一般的な部分和に関する公式はないので、
     ‘nusum’はそれができません。

     ‘nusum’と‘unsum’は、有限積の和と差について少し知っています。
     ‘unsum’も参照してください。

     例:

          (%i1) nusum (n*n!, n, 0, n);

          Dependent equations eliminated:  (1)
          (%o1)                     (n + 1)! - 1
          (%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o2) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i3) unsum (%, n);
                                        4  n
                                       n  4
          (%o3)                   ----------------
                                  binomial(2 n, n)
          (%i4) unsum (prod (i^2, i, 1, n), n);
                              n - 1
                              /===\
                               ! !   2
          (%o4)              ( ! !  i ) (n - 1) (n + 1)
                               ! !
                              i = 1
          (%i5) nusum (%, n, 1, n);

          Dependent equations eliminated:  (2 3)
                                      n
                                    /===\
                                     ! !   2
          (%o5)                      ! !  i  - 1
                                     ! !
                                    i = 1

 -- 関数: pade (<taylor_series>, <numer_deg_bound>, <denom_deg_bound>)

     分子と分母の次数の和がべき級数の切り詰めレベル以下の 与えられた
     Taylor級数展開、すなわち、「最良」近似を持ち 加えて指定された次数範
     囲を満たす、有理関数すべてのリストを返します。

     <taylor_series>は１変数Taylor級数です。 <numer_deg_bound>と
     <denom_deg_bound>は、 分子と分母上の次数範囲を指定する 正の整数です
     。

     <taylor_series>は Laurent級数も可能です。 次数範囲は、‘inf’も可能で
     、 総次数が、冪級数の長さ以下の有理関数すべてを返すことになります。
     総次数は ‘<numer_deg_bound> + <denom_deg_bound>’として定義されます
     。 べき級数の長さは ‘"truncation level" + 1 - min(0, "order of
     series")’として定義されます。

          (%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                                        2    3
          (%o1)/T/             1 + x + x  + x  + . . .
          (%i2) pade (%, 1, 1);
                                           1
          (%o2)                       [- -----]
                                         x - 1
          (%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                             + 387072*x^7 + 86016*x^6 - 1507328*x^5
                             + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                             + 67108864*x - 134217728)
                 /134217728, x, 0, 10);
                              2    3       4       5       6        7
                       x   3 x    x    15 x    23 x    21 x    189 x
          (%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
                       2    16    32   1024    2048    32768   65536

                                            8         9          10
                                      5853 x    2847 x    83787 x
                                    + ------- + ------- - --------- + . . .
                                      4194304   8388608   134217728
          (%i4) pade (t, 4, 4);
          (%o4)                          []

     このべき級数展開を持つ次数4の 分子/分母の有理関数はありません。 一
     般的に、 解くのに十分な数の未知の係数を持つために、 その和が少なく
     ともべき級数の次数になるまで 分子の次数と分母の次数を増やさなければ
     いけません。

          (%i5) pade (t, 5, 5);
                               5                4                 3
          (%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                            2
           - 1619100813312 x  - 2176885157888 x - 2386516803584)

                         5                 4                  3
          /(47041365435 x  + 381702613848 x  + 1360678489152 x

                            2
           + 2856700692480 x  + 3370143559680 x + 2386516803584)]

 -- 関数: powerseries (<expr>, <x>, <a>)

     変数<x>に関する点<a> (無限大のためには‘inf’かもしれません) の回りの
     <expr>のべき級数展開の一般形式を返します:
                     inf
                     ====
                     \               n
                      >    b  (x - a)
                     /      n
                     ====
                     n = 0

     もし‘powerseries’が<expr>を展開することができないなら、 ‘taylor’が
     、級数の最初のいくつかの項を与えることができます。

     ‘verbose’が‘true’の時、 ‘powerseries’は進捗メッセージを印字します。

          (%i1) verbose: true$
          (%i2) powerseries (log(sin(x)/x), x, 0);
          can't expand
                                           log(sin(x))
          so we'll try again after applying the rule:
                                                  d
                                                / -- (sin(x))
                                                [ dx
                                  log(sin(x)) = i ----------- dx
                                                ]   sin(x)
                                                /
          in the first simplification we have returned:
                                       /
                                       [
                                       i cot(x) dx - log(x)
                                       ]
                                       /
                              inf
                              ====        i1  2 i1             2 i1
                              \      (- 1)   2     bern(2 i1) x
                               >     ------------------------------
                              /                i1 (2 i1)!
                              ====
                              i1 = 1
          (%o2)                -------------------------------------
                                                2

 -- オプション変数: psexpand
     デフォルト値: ‘false’

     ‘psexpand’が‘true’の時、 拡張有理関数展開が完全に展開されて表示され
     ます。 スイッチ‘ratexpand’は同じ効果を持ちます。

     ‘psexpand’が‘false’の時、 多変数式がちょうど有理関数パッケージにあ
     るかのように表示されます。

     ‘psexpand’が‘multi’の時、 変数に関する同じ総次数の項は一緒にまとめ
     られます。

 -- 関数: revert (<expr>, <x>)
 -- 関数: revert2 (<expr>, <x>, <n>)
     これらの関数は、 変数<x>に関するゼロの回りのTaylor級数<expr>の反転
     を返します。 ‘revert’は、 <expr>の最高次数と等しい次数の多項式を返
     します。 ‘revert2’は、次数<n>の多項式を返します。 <n>は、<expr>の次
     数よりも大きい値も小さい値も同じ値も取り得ます。

     ‘load ("revert")’はこれらの関数をロードします。

     例:

          (%i1) load ("revert")$
          (%i2) t: taylor (exp(x) - 1, x, 0, 6);
                             2    3    4    5     6
                            x    x    x    x     x
          (%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                            2    6    24   120   720
          (%i3) revert (t, x);
                         6       5       4       3       2
                     10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
          (%o3)/R/ - --------------------------------------------
                                          60
          (%i4) ratexpand (%);
                               6    5    4    3    2
                              x    x    x    x    x
          (%o4)             - -- + -- - -- + -- - -- + x
                              6    5    4    3    2
          (%i5) taylor (log(x+1), x, 0, 6);
                              2    3    4    5    6
                             x    x    x    x    x
          (%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                             2    3    4    5    6
          (%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
          (%o6)                           0
          (%i7) revert2 (t, x, 4);
                                    4    3    2
                                   x    x    x
          (%o7)                  - -- + -- - -- + x
                                   4    3    2

 -- 関数: taylor (<expr>, <x>, <a>, <n>)
 -- 関数: taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)
 -- 関数: taylor (<expr>, [<x>, <a>, <n>, 'asymp])
 -- 関数: taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...],
          [<n_1>, <n_2>, ...])
 -- 関数: taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
          ...)

     ‘taylor (<expr>, <x>, <a>, <n>)’は、 式<expr>を、変数<x>の<a>の周り
     のTaylorもしくはLaurent級数を ‘(<x> - <a>)^<n>’まで展開します。

     もし<expr>が形式‘<f>(<x>)/<g>(<x>)’ の形であり、 ‘<g>(<x>)’が<n>次
     まで項を持たないなら、 ‘taylor’は‘<g>(<x>)’を‘2 <n>’次まで展開しよ
     うとします。 もしまだ0でない項がないなら、 ‘taylor’は、展開の次数が
     ‘<n> 2^taylordepth’以下である限り ‘<g>(<x>)’の展開の次数を倍にして
     いきます。

     ‘taylor (<expr>, [<x_1>, <x_2>, ...], <a>, <n>)’ は、すべての変数
     <x_1>, <x_2>, ...について 点‘(<a>, <a>, , ...)’の周りで<n>次までの
     べき級数を返します。

     ‘taylor (<expr>, [<x_1>, <a_1>, <n_1>], [<x_2>, <a_2>, <n_2>],
     ...)’は、変数<x_1>, <x_2>, ...について 点‘(<a_1>, <a_2>, ...)’の回
     りで <n_1>次, <n_2>次, ....まで展開したべき級数を返します。

     ‘taylor (<expr>, [<x_1>, <x_2>, ...], [<a_1>, <a_2>, ...], [<n_1>,
     <n_2>, ...])’は、 変数<x_1>, <x_2>, ...について、 点‘(<a_1>, <a_2>,
     ...)’の回りで <n_1>次, <n_2>次, ....まで展開したべき級数を返します
     。

     ‘taylor (<expr>, [<x>, <a>, <n>, 'asymp])’は、 <expr>の‘<x> - <a>’の
     負のべき乗展開を返します。 最高次の項は‘(<x> - <a>)^<-n>’です。

     ‘maxtaylorder’が‘true’の時、 （丸められた）Taylor級数の代数操作の間
     、 ‘talyor’は正確とわかっている限り多くの項を保とうとします。

     ‘psexpand’が‘true’の時、 拡張有理関数式は、フルに展開されて表示され
     ます。 スイッチ‘ratexpand’は同じ効果を持ちます。 ‘psexpand’が
     ‘false’の時、 有理関数パッケージかのように多変数式が表示されます。
     ‘psexpand’が‘multi’なら、同じ総次数の項が一緒にグループ化されます。

     展開を制御するには、‘taylor_logexpand’スイッチも参照してください。

     例:

          (%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                                     2             2
                       (a + 1) x   (a  + 2 a + 1) x
          (%o1)/T/ 1 + --------- - -----------------
                           2               8

                                             3      2             3
                                         (3 a  + 9 a  + 9 a - 1) x
                                       + -------------------------- + . . .
                                                     48
          (%i2) %^2;
                                              3
                                             x
          (%o2)/T/           1 + (a + 1) x - -- + . . .
                                             6
          (%i3) taylor (sqrt (x + 1), x, 0, 5);
                                 2    3      4      5
                            x   x    x    5 x    7 x
          (%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                            2   8    16   128    256
          (%i4) %^2;
          (%o4)/T/                  1 + x + . . .
          (%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                                   inf
                                  /===\
                                   ! !    i     2.5
                                   ! !  (x  + 1)
                                   ! !
                                  i = 1
          (%o5)                   -----------------
                                        2
                                       x  + 1
          (%i6) ev (taylor(%, x,  0, 3), keepfloat);
                                         2           3
          (%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
          (%i7) taylor (1/log (x + 1), x, 0, 3);
                                         2       3
                           1   1   x    x    19 x
          (%o7)/T/         - + - - -- + -- - ----- + . . .
                           x   2   12   24    720
          (%i8) taylor (cos(x) - sec(x), x, 0, 5);
                                          4
                                     2   x
          (%o8)/T/                - x  - -- + . . .
                                         6
          (%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
          (%o9)/T/                    0 + . . .
          (%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                                         2          4
                      1     1       11      347    6767 x    15377 x
          (%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
                       6      4        2   15120   604800    7983360
                      x    2 x    120 x

                                                                    + . . .
          (%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
                         2  2       4      2   4
                        k  x    (3 k  - 4 k ) x
          (%o11)/T/ 1 - ----- - ----------------
                          2            24

                                              6       4       2   6
                                         (45 k  - 60 k  + 16 k ) x
                                       - -------------------------- + . . .
                                                    720
          (%i12) taylor ((x + 1)^n, x, 0, 4);
                                2       2     3      2         3
                              (n  - n) x    (n  - 3 n  + 2 n) x
          (%o12)/T/ 1 + n x + ----------- + --------------------
                                   2                 6

                                         4      3       2         4
                                       (n  - 6 n  + 11 n  - 6 n) x
                                     + ---------------------------- + . . .
                                                    24
          (%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
                         3                 2
                        y                 y
          (%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
                        6                 2

                              3                       2
                         y   y            2      1   y            3
                    + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
                         2   12                  6   12
          (%i14) taylor (sin (y + x), [x, y], 0, 3);
                               3        2      2      3
                              x  + 3 y x  + 3 y  x + y
          (%o14)/T/   y + x - ------------------------- + . . .
                                          6
          (%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
                    1   y              1    1               1            2
          (%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
                    y   6               2   6                3
                                       y                    y

                                                     1            3
                                                + (- -- + . . .) x  + . . .
                                                      4
                                                     y
          (%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                                       3         2       2        3
                      1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
          (%o16)/T/ ----- + ----- + ------------------------------- + . . .
                    x + y     6                   360

 -- オプション変数: taylordepth
     デフォルト値: 3

     もしまだ非ゼロ項がないなら、 展開の次数が‘<n> 2^taylordepth’以下で
     ある限り、 ‘taylor’は、 ‘<g>(<x>)’の展開の次数を倍にします。

 -- 関数: taylorinfo (<expr>)

     Taylor級数<expr>についての情報を返します。 戻り値はリストのリストで
     す。 リストそれぞれは、変数名、展開点、展開次数から成ります。

     もし<expr>がTaylor級数でないなら、 ‘taylorinfo’は‘false’を返します
     。

     例:

          (%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                            2                       2
          (%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

                   2                        2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   2
           + (1 - a  - 2 a (y - a) - (y - a) ) x

                   2                        2   3
           + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
          (%i2) taylorinfo(%);
          (%o2)               [[y, a, inf], [x, 0, 3]]

 -- 関数: taylorp (<expr>)

     もし<expr>がTaylor級数なら、‘true’を、 そうでないなら、‘false’を返
     します。

 -- オプション変数: taylor_logexpand
     デフォルト値: ‘true’

     ‘taylor_logexpand’は、 ‘taylor’級数の中の対数の展開を制御します。

     ‘taylor_logexpand’が‘true’の時、 対数すべては完全に展開されるので、
     対数的恒等式を含むゼロ認識問題は 展開プロセスを邪魔しません。 しか
     しながら、分岐情報を無視するので、この方法はいつも数学的にただしい
     わけではありません。

     ‘taylor_logexpand’が‘false’に設定されている時、 生じる対数の唯一の
     展開は、 形式的なべき級数を得るのに必要なものです。

 -- オプション変数: taylor_order_coefficients
     デフォルト値: ‘true’

     ‘taylor_order_coefficients’は、 Taylor級数の中の係数の順序付けを制
     御します。

     ‘taylor_order_coefficients’が‘true’の時、 Taylor級数の係数は標準に
     順序付けられます。

 -- 関数: taylor_simplifier (<expr>)

     べき級数<expr>の係数を整理します。 ‘taylor’はこの関数をコールします
     。

 -- オプション変数: taylor_truncate_polynomials
     デフォルト値: ‘true’

     ‘taylor_truncate_polynomials’が‘true’の時、 多項式は入力切り詰めレ
     ベルを基礎に切り詰められます。

     そうでないなら、 ‘taylor’への多項式入力は、 不定の精度を持つと考え
     られます。

 -- 関数: taytorat (<expr>)
     ‘taylor’形式から標準有理式(CRE)形式に <expr>を変換します。 効果は
     ‘rat (ratdisrep (<expr>))’と同じですが、より速いです。

 -- 関数: trunc (<expr>)

     一般式<expr>の内部表現をアノテートするので、まるでその和が切り詰め
     られたTaylor級数かのように表示されます。 <expr>は別に変更されません
     。

     例:

          (%i1) expr: x^2 + x + 1;
                                      2
          (%o1)                      x  + x + 1
          (%i2) trunc (expr);
                                          2
          (%o2)                  1 + x + x  + . . .
          (%i3) is (expr = trunc (expr));
          (%o3)                         true

 -- 関数: unsum (<f>, <n>)

     最初の後方差‘<f>(<n>) - <f>(<n> - 1)’を返します。 従って、 ‘unsum’は
     、ある意味、‘sum’の逆です。

     ‘nusum’も参照してください。

     例:

          (%i1) g(p) := p*4^n/binomial(2*n,n);
                                               n
                                            p 4
          (%o1)               g(p) := ----------------
                                      binomial(2 n, n)
          (%i2) g(n^4);
                                        4  n
                                       n  4
          (%o2)                   ----------------
                                  binomial(2 n, n)
          (%i3) nusum (%, n, 0, n);
                               4        3       2              n
                2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
          (%o3) ------------------------------------------------ - ------
                              693 binomial(2 n, n)                 3 11 7
          (%i4) unsum (%, n);
                                        4  n
                                       n  4
          (%o4)                   ----------------
                                  binomial(2 n, n)

 -- オプション変数: verbose
     デフォルト値: ‘false’

     ‘verbose’が‘true’の時、 ‘powerseries’は進捗メッセージを印字します。


File: maxima.info,  Node: Poisson series,  Prev: Functions and Variables for Series,  Up: Sums Products and Series

28.4 Poisson series
===================

 -- 関数: intopois (<a>)
     <a>をPoisson符号に変換します。

 -- 関数: outofpois (<a>)

     <a>をPoisson符号から一般表現に変換します。 もし<a>がPoisson形式でな
     いなら、 ‘outofpois’は変換を実行し、 すなわち、その戻り値は、
     ‘outofpois (intopois (<a>))’です。 例えば、この関数は、 特定のタイ
     プのサインやコサイン項のべきの和に関する 標準整理器です。

 -- 関数: poisdiff (<a>, <b>)

     <a>を<b>に関して微分します。 <b>は三角関数の引数の中だけ、または係
     数の中だけにいなければいけません。

 -- 関数: poisexpt (<a>, <b>)

     関数的に‘intopois (<a>^<b>)’と同一です。 <b>は正の整数でなければい
     けません。

 -- 関数: poisint (<a>, <b>)

     (‘poisdiffと’)似て制限された意味で積分します。 もし<b>が三角関数の
     引数の中にあるなら、 <b>の中の非周期的項は落とされます。

 -- オプション変数: poislim
     デフォルト値: 5

     ‘poislim’は、三角関数の引数の中の係数の領域を決定します。 初期値5は
     区間[-2^(5-1)+1,2^(5-1)]、すなわち[-15,16]に対応しますが、
     [-2^(n-1)+1, 2^(n-1)]に設定することができます。

 -- 関数: poismap (<series>, <sinfn>, <cosfn>)

     関数<sinfn>を与えられたPoisson級数のサイン項に、 <cosfn>をコサイン
     項に マップします。 <sinfn>と <cosfn>は、２引数関数です。 引数それ
     ぞれは、級数の中の項の係数と三角関数部です。

 -- 関数: poisplus (<a>, <b>)

     関数的に‘intopois (a + b)’と同一です。

 -- 関数: poissimp (<a>)

     <a>を、一般表現の<a>に関するPoisson級数に変換します。

 -- 特殊シンボル: poisson

     シンボル‘/P/’は、Poisson級数式の行ラベルに続きます。

 -- 関数: poissubst (<a>, <b>, <c>)

     <a>を<c>の中の<b>に代入します。 <c>はPoisson級数です。

     (1) <b>が変数<u>, <v>, <w>, <x>, <y>, <z>のいずれかの場合、 <a>はそ
     れらの変数に関して線形の式(例えば、‘6*u + 4*v’)でなければいけません
     。

     (2) <b>はそれらの変数以外の場合、 <a>もまたそれらの変数を含んではい
     けなく、さらに、サインもコサインも含んではいけません。

     ‘poissubst (<a>, <b>, <c>, <d>, <n>)’は、 上のタイプ(1)のように
     <a>と<b>に関して演算しますが、 <d>がPoisson級数の場合、 <c>の中で
     <b>に‘<a> + <d>’を代入した結果を供給するために、 ‘cos(<d>)’と
     ‘sin(<d>)’を次数<n>に展開する 特殊なタイプの代入です。 アイデアは、
     <d>が小さなパラメータの項に関する展開だということです。 例えば、
     ‘poissubst (u, v, cos(v), %e, 3)’は‘cos(u)*(1 - %e^2/2) -
     sin(u)*(%e - %e^3/6)’をもたらします。

 -- 関数: poistimes (<a>, <b>)

     ‘intopois (<a>*<b>)’と同じ機能です。

 -- 関数: poistrim ()

     (もしユーザーがそれを定義したら) Poisson乗算の間、適用する予約関数
     です。 項の中の<u>, <v>, ..., <z>の係数を引数とする６引数の述語論理
     関数です。 (この項の係数に関して)‘poistrim’が‘true’の項は、 乗算の
     間に消去されます。

 -- 関数: printpois (<a>)

     可読フォーマットでPoisson級数を印字します。 ‘outofpois’と共通で、 も
     し必要なら、<a>を最初にPoisson符号に変換します。


File: maxima.info,  Node: Number Theory,  Next: Symmetries,  Prev: Sums Products and Series,  Up: Top

29 Number Theory
****************

* Menu:

* Functions and Variables for Number Theory::  


File: maxima.info,  Node: Functions and Variables for Number Theory,  Prev: Number Theory,  Up: Number Theory

29.1 Functions and Variables for Number Theory
==============================================

 -- 関数: bern (<n>)

     整数<n>について<n>番目のBernoulli数を返します。 もし‘zerobern’が
     ‘false’なら ゼロに等しいBernoulli数は抑制されます。

     ‘burn’も参照してください。

          (%i1) zerobern: true$
          (%i2) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                            1  1       1      1        1
          (%o2)       [1, - -, -, 0, - --, 0, --, 0, - --]
                            2  6       30     42       30
          (%i3) zerobern: false$
          (%i4) map (bern, [0, 1, 2, 3, 4, 5, 6, 7, 8]);
                      1  1    1   5     691   7    3617  43867
          (%o4) [1, - -, -, - --, --, - ----, -, - ----, -----]
                      2  6    30  66    2730  6    510    798

 -- 関数: bernpoly (<x>, <n>)

     変数<x>に関する<n>番目のBernoulli多項式を返します。

 -- 関数: bfzeta (<s>, <n>)

     引数<s>に関するRiemannのゼータ関数を返します。 戻り値は多倍長浮動小
     数点(bfloat)です; <n>は戻り値の小数点以下の桁数です。

 -- 関数: bfhzeta (<s>, <h>, <n>)

     引数<s>と<h>に関するHurwitzのゼータ関数を返します。 戻り値は多倍長
     浮動小数点(bfloat)です; <n>は戻り値の小数点以下の桁数です。

     Hurwitzゼータ関数は以下のように定義されます。

                                  inf
                                  ====
                                  \        1
                   zeta (s,h)  =   >    --------
                                  /            s
                                  ====  (k + h)
                                  k = 0

     ‘load ("bffac")’はこの関数をロードします。

 -- 関数: burn (<n>)

     <n>番目のBernoulli数の近似の有理数をを返します。 ‘burn’は、(有理
     )Bernoulli数が まあまあの効率で(超越的)ゼータによって近似できるとい
     う観察を利用します。

                             n - 1  1 - 2 n
                        (- 1)      2        zeta(2 n) (2 n)!
               B(2 n) = ------------------------------------
                                          2 n
                                       %pi

     ‘bern’は、返す前にインデックス<n>までのBernoulli数すべてを計算する
     ので、 ‘burn’は、大きな、孤立した<n>(たぶん105以上の<n>) に対して
     ‘bern’より効率的かもしれません。 ‘burn’は、255よりおおきな偶数<n>に
     対して近似を呼び出します。 奇数と255以下の<n>に対しては、関数
     ‘bern’が呼び出されます。

     ‘load ("bffac")’はこの関数をロードします。‘bern’も参照してください
     。

 -- 関数: cf (<expr>)

     <expr>を連分数に変換します。 <expr>は、 連分数と整数の平方根から成
     る式です。 式の中のオペランドは 代数演算子を組み合わせられます。 連
     分数と平方根は別にして、式の中の因子は整数か有理数でなければいけま
     せん。 Maximaは、 ‘cf’の外側で連分数に関する演算について知りません
     。

     ‘listarith’を‘false’にバインドした後、 ‘cf’は、引数を評価します。
     ‘cf’は、リストとして表現された連分数を返します。

     連分数‘a + 1/(b + 1/(c + ...))’は、 リスト‘[a, b, c, ...]’で表現さ
     れます。 リストの要素‘a’, ‘b’, ‘c’, ...は、 整数に評価されなければ
     いけません。 <expr>は、 may also contain ‘sqrt (n)’も含むかもしれま
     せん。‘n’は整数です。 この場合、‘cf’は、 変数‘cflength’の値掛ける周
     期と同じ数の連分数の項を与えます。

     連分数は、 ‘cfdisrep’が返す代数表現を評価することで、 数に評価する
     ことができます。 連分数を評価する別の方法に関しては、 ‘cfexpand’も
     参照してください。

     ‘cfdisrep’, ‘cfexpand’, ‘cflength’も参照してください。

     例:

        • <expr>は、連分数と整数の平方根から成る式です。

               (%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
               (%o1)               [59, 17, 2, 1, 1, 1, 27]
               (%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
               (%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]

        • ‘cflength’は、 連分数の何周期を代数的無理数のために計算するか
          を制御します。

               (%i1) cflength: 1$
               (%i2) cf ((1 + sqrt(5))/2);
               (%o2)                    [1, 1, 1, 1, 2]
               (%i3) cflength: 2$
               (%i4) cf ((1 + sqrt(5))/2);
               (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
               (%i5) cflength: 3$
               (%i6) cf ((1 + sqrt(5))/2);
               (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

        • 連分数は、‘cfdisrep’が返す代数的表現を評価することによって評価
          されることができます。

               (%i1) cflength: 3$
               (%i2) cfdisrep (cf (sqrt (3)))$
               (%i3) ev (%, numer);
               (%o3)                   1.731707317073171

        • Maximaは、 ‘cf’の外側で連分数に関する演算について知りません。

               (%i1) cf ([1,1,1,1,1,2] * 3);
               (%o1)                     [4, 1, 5, 2]
               (%i2) cf ([1,1,1,1,1,2]) * 3;
               (%o2)                  [3, 3, 3, 3, 3, 6]

 -- 関数: cfdisrep (<list>)

     連分数‘[a, b, c, ...]’のリスト表現から、 形式‘a + 1/(b + 1/(c +
     ...))’の通常の代数式を構成し返します。

          (%i1) cf ([1, 2, -3] + [1, -2, 1]);
          (%o1)                     [1, 1, 1, 2]
          (%i2) cfdisrep (%);
                                            1
          (%o2)                     1 + ---------
                                              1
                                        1 + -----
                                                1
                                            1 + -
                                                2

 -- 関数: cfexpand (<x>)

     連分数<x>のコンバージェントの 最後(列1)とその１つ前(列2)の 分子と分
     母の行列を返します。

          (%i1) cf (rat (ev (%pi, numer)));

          `rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
          (%o1)                  [3, 7, 15, 1, 292]
          (%i2) cfexpand (%);
                                   [ 103993  355 ]
          (%o2)                    [             ]
                                   [ 33102   113 ]
          (%i3) %[1,1]/%[2,1], numer;
          (%o3)                   3.141592653011902

 -- オプション変数: cflength
     デフォルト値: 1

     ‘cflength’は、 値‘cflength’掛ける周期として 関数‘cf’が与える連分数
     の項の数を制御します。 従って、デフォルトは1周期を与えます。

          (%i1) cflength: 1$
          (%i2) cf ((1 + sqrt(5))/2);
          (%o2)                    [1, 1, 1, 1, 2]
          (%i3) cflength: 2$
          (%i4) cf ((1 + sqrt(5))/2);
          (%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
          (%i5) cflength: 3$
          (%i6) cf ((1 + sqrt(5))/2);
          (%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]

 -- 関数: divsum (<n>, <k>)
 -- 関数: divsum (<n>)

     ‘divsum (<n>, <k>)’は、 <n>の約数の<k>乗した和を返します。

     ‘divsum (<n>)’は <n>の約数の和を返します。

          (%i1) divsum (12);
          (%o1)                          28
          (%i2) 1 + 2 + 3 + 4 + 6 + 12;
          (%o2)                          28
          (%i3) divsum (12, 2);
          (%o3)                          210
          (%i4) 1^2 + 2^2 + 3^2 + 4^2 + 6^2 + 12^2;
          (%o4)                          210

 -- 関数: euler (<n>)

     非負の整数<n>に対して <n>番目のEuler数を返します。

     Euler-Mascheroni定数に関しては、‘%gamma’を参照してください。

          (%i1) map (euler, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)    [1, 0, - 1, 0, 5, 0, - 61, 0, 1385, 0, - 50521]

 -- 関数: fib (<n>)
     第<n>項のFibonacci数を返します。 ‘fib(0)’は0に等しく、‘fib(1)’は1に
     等しく、 ‘fib (-<n>)’は‘(-1)^(<n> + 1) * fib(<n>)’に等しい。

     ‘fib’をコールした後， ‘prevfib’は‘fib (<x> - 1)’、 計算された最後の
     １つ前のFibonacci数に等しい。

          (%i1) map (fib, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o1)         [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

 -- 関数: fibtophi (<expr>)

     <expr>に関するFibonacci数を 定数‘%phi’を使って表現します。 ‘%phi’は
     、‘(1 + sqrt(5))/2’, 近似的に1.61803399です。

     例:

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

 -- 関数: ifactors (<n>)

     正の整数<n>に対して、 <n>の素因数分解を返します。 もし
     ‘n=p1^e1..pk^nk’が <n>の素因数への分解なら、 ifactorsは‘[[p1, e1],
     ... , [pk, ek]]’を返します。

     使われる素因数分解法は9973までの素数による試行除算と、 Pollardのロ
     ー法、楕円曲線法です。

          (%i1) ifactors(51575319651600);
          (%o1)     [[2, 4], [3, 2], [5, 2], [1583, 1], [9050207, 1]]
          (%i2) apply("*", map(lambda([u], u[1]^u[2]), %));
          (%o2)                        51575319651600

 -- 関数: igcdex (<n>, <k>)

     リスト ‘[<a>, <b>, <u>]’を返します。 ここで、 <u>は<n>と <k>の最大
     公約数で、 <u>は ‘<a> <n> + <b> <k>’に等しいです。 引数 <n>と <k>は
     整数でなければいけません。

     ‘igcdex’はユークリッドのアルゴリズムを実装します。 ‘gcdex’.も参照し
     てください。

     コマンド ‘load("gcdex")’はこの関数をロードします。

     例:

          (%i1) load("gcdex")$

          (%i2) igcdex(30,18);
          (%o2)                      [- 1, 2, 6]
          (%i3) igcdex(1526757668, 7835626735736);
          (%o3)            [845922341123, - 164826435, 4]
          (%i4) igcdex(fib(20), fib(21));
          (%o4)                   [4181, - 2584, 1]

 -- 関数: inrt (<x>, <n>)

     <x>の絶対値の整数<n>乗根を返します。

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], inrt (10^a, 3)), l);
          (%o2) [2, 4, 10, 21, 46, 100, 215, 464, 1000, 2154, 4641, 10000]

 -- 関数: inv_mod (<n>, <m>)

     <m>を法とする<n>の逆元を計算します。 もし<n>が<m>を法とするゼロ因子
     なら、 ‘inv_mod (n,m)’は‘false’を返します。

          (%i1) inv_mod(3, 41);
          (%o1)                           14
          (%i2) ratsimp(3^-1), modulus=41;
          (%o2)                           14
          (%i3) inv_mod(3, 42);
          (%o3)                          false

 -- 関数: isqrt (<x>)

     整数 <x>の絶対値の「整数平方根」を返します。

 -- 関数: jacobi (<p>, <q>)

     <p>と<q>のJacobi記号を返します。

          (%i1) l: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]$
          (%i2) map (lambda ([a], jacobi (a, 9)), l);
          (%o2)         [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]

 -- 関数: lcm (<expr_1>, ..., <expr_n>)

     引数の最小公倍数を返します。 引数は、整数はもちろん一般式を取り得ま
     す。

     ‘load ("functs")’はこの関数をロードします。

 -- 関数: mod (<x>, <y>)

     もし<x>と<y>が実数で、<y>がゼロでないなら、 ‘<x> - <y> * floor(<x>
     / <y>)’を返します。 さらにすべての実数<x>に関して、‘mod (<x>, 0) =
     <x>’が成り立ちます。 定義‘mod (<x>, 0) = <x>’の議論に関しては、
     Graham, Knuth, Patashnik著の「コンピュータの数学」の3.4節を参照して
     ください。 関数‘mod (<x>, 1)’ は、周期が1で‘mod (1, 1) = 0’、‘mod
     (0, 1) = 0’ののこぎり波関数です。

     複素数の偏角の主値（区間‘(-%pi, %pi]’での数）を見つけるためには、 関
     数‘<x> |-> %pi - mod (%pi - <x>, 2*%pi)’を使います。 <x>は引数です
     。

     <x>と<y>が定数式(例えば、‘10 * %pi’)の時、 ‘mod’は、‘floor’や
     ‘ceiling’が使うのと同じ多倍長浮動小数点評価スキームを 使います。 再
     び同様に、まれですが、‘mod’は間違った値を返すことがありえます。

     数値でない引数<x>や<y>に関して,‘mod’は、いくつかの式整理規則を知っ
     ています:

          (%i1) mod (x, 0);
          (%o1)                           x
          (%i2) mod (a*x, a*y);
          (%o2)                      a mod(x, y)
          (%i3) mod (0, x);
          (%o3)                           0

 -- 関数: next_prime (<n>)

     <n>よりも大きな最も小さな素数を返します。

          (%i1) next_prime(27);
          (%o1)                       29

 -- 関数: partfrac (<expr>, <var>)

     主変数<var>に関する部分分数式<expr>を展開します。 ‘partfrac’は、完
     全な部分分数分解を行います。 利用したアルゴリズムは、 部分分数展開
     (元の分母の因子)の分母は互いに素であるという事実に基づいています。
     分子は分母の線形結合として書け、結果が展開ということになります。

          (%i1) 1/(1+x)^2 - 2/(1+x) + 2/(2+x);
                                2       2        1
          (%o1)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)
          (%i2) ratsimp (%);
                                           x
          (%o2)                 - -------------------
                                   3      2
                                  x  + 4 x  + 5 x + 2
          (%i3) partfrac (%, x);
                                2       2        1
          (%o3)               ----- - ----- + --------
                              x + 2   x + 1          2
                                              (x + 1)

 -- 関数: power_mod (<a>, <n>, <m>)

     ‘a^n mod m’を計算するために 剰余アルゴリズムを使います。 ここで、
     <a>と<n>は整数で、<m>は正の整数です。 もし<n>が負なら、‘inv_mod’が
     剰余逆元を見つけるために使われます。

          (%i1) power_mod(3, 15, 5);
          (%o1)                          2
          <(%i2) mod(3^15,5);
          (%o2)                          2
          (%i3) power_mod(2, -1, 5);
          (%o3)                          3
          (%i4) inv_mod(2,5);
          (%o4)                          3

 -- 関数: primep (<n>)

     素数テスト。 もし‘primep (<n>)’が‘false’を返すなら、 <n>は合成数で
     あり、 もし‘true’を返すなら、<n>は非常に高い確立で素数です。

     341550071728321より小さな<n>に対して、 Miller-Rabinのテストの決定的
     バージョンが使われます。 もし‘primep (<n>)’が‘true’を返すなら、
     <n>は素数です。

     341550071728321よりの大きな<n>に対して、 ‘primep’は、
     ‘primep_number_of_tests’個のMiller-Rabinの疑似素数テストと 1つの
     Lucasの疑似素数テストを使います。 <n>がMiller-Rabinのテスト１つを通
     過する確率は 1/4より小さいです。 ‘primep_number_of_tests’に関してデ
     フォルト値25を使うと、 通過した<n>が合成である確率は 10^-15よりもは
     るかに小さいです。

 -- オプション変数: primep_number_of_tests
     デフォルト値: 25

     ‘primep’の中で使われるMiller-Rabinのテストの回数。

 -- 関数: prev_prime (<n>)

     <n>よりも小さな最大の素数を返します。

          (%i1) prev_prime(27);
          (%o1)                       23

 -- 関数: qunit (<n>)

     実二次数体‘sqrt (<n>)’の基本単数、 すなわち、ノルムが1の要素を返し
     ます。 ここで、<n>は整数です。 これは、結果的にペル方程式‘a^2 - <n>
     b^2 = 1’を解くことになります。

          (%i1) qunit (17);
          (%o1)                     sqrt(17) + 4
          (%i2) expand (% * (sqrt(17) - 4));
          (%o2)                           1

 -- 関数: totient (<n>)

     <n>以下の、 <n>と互いに素な整数の数を返します。

 -- オプション変数: zerobern
     デフォルト値: ‘true’

     ‘zerobern’が‘false’の時、 ‘bern’はBernoulli数を除外し、‘euler’はゼ
     ロに等しいEuler数を除外します。 ‘bern’と‘euler’を参照してください。

 -- 関数: zeta (<n>)

     Riemannのゼータ関数を返します。 もし<x>が負の整数、0, 1,または、正
     の偶数なら、 Reimannのゼータ関数は厳密な値に整理されます。 正の偶数
     に対しては、 加えて、オプション変数‘zeta%pi’は‘true’でなければいけ
     ません。 (‘zeta%pi’を参照してください。) 浮動小数点または多倍長浮動
     小数点数に対して、Reimannゼータ関数は数値的に評価されます。 Maximaは
     、 有理非整数、浮動小数点数、複素数の引数を含む 他の引数すべてに対
     して、また、もし‘zeta%pi’が値‘false’なら偶数に対して、 名詞形‘zeta
     (<n>)’を返します。

     ‘zeta(1)’は未定義ですが、 Maximaは上からと下からの極限
     ‘limit(zeta(x), x, ,1)’を知っています。

     ‘bfzeta’と‘zeta%pi’も参照してください。

     例：

          (%i1) zeta([-2, -1, 0, 0.5, 2, 3, 1+%i]);
                                                       2
                      1     1                       %pi
          (%o1) [0, - --, - -, - 1.460354508809586, ----, zeta(3),
                      12    2                        6
                                                              zeta(%i + 1)]
          (%i2) limit(zeta(x),x,1,plus);
          (%o2)                          inf
          (%i3) limit(zeta(x),x,1,minus);
          (%o3)                         minf

 -- オプション変数: zeta%pi
     デフォルト値: ‘true’

     ‘zeta%pi’が‘true’の時、 偶数‘n’に対して、‘zeta’は‘%pi^n’に比例する
     式を返します。 そうでないなら、 偶数‘n’に対して、‘zeta’は名詞形
     ‘zeta (n)’を返します。

     例:

          (%i1) zeta%pi: true$
          (%i2) zeta (4);
                                           4
                                        %pi
          (%o2)                         ----
                                         90
          (%i3) zeta%pi: false$
          (%i4) zeta (4);
          (%o4)                        zeta(4)


File: maxima.info,  Node: Symmetries,  Next: Groups,  Prev: Number Theory,  Up: Top

30 Symmetries
*************

* Menu:

* Introduction to Symmetries::
* Functions and Variables for Symmetries::


File: maxima.info,  Node: Introduction to Symmetries,  Next: Functions and Variables for Symmetries,  Prev: Symmetries,  Up: Symmetries

30.1 Introduction to Symmetries
===============================

‘sym’は、多項式の対称群を扱うパッケージです。

   これは、 Annick Valibouze (<http://www-calfor.lip6.fr/~avb/>) によっ
て Macsyma-Symbolicsのために書かれました。 アルゴリズムは、以下の論文に
記載されています:

  1. Fonctions symétriques et changements de bases.  Annick Valibouze.
     EUROCAL’87 (Leipzig, 1987), 323–332, Lecture Notes in Comput.  Sci
     378.  Springer, Berlin, 1989.
     <http://www.stix.polytechnique.fr/publications/1984-1994.html>

  2. Résolvantes et fonctions symétriques.  Annick Valibouze.
     Proceedings of the ACM-SIGSAM 1989 International Symposium on
     Symbolic and Algebraic Computation, ISSAC’89 (Portland, Oregon).
     ACM Press, 390-399, 1989.
     <http://www-calfor.lip6.fr/~avb/DonneesTelechargeables/MesArticles/issac89ACMValibouze.pdf>

  3. Symbolic computation with symmetric polynomials, an extension to
     Macsyma.  Annick Valibouze.  Computers and Mathematics (MIT, USA,
     June 13-17, 1989), Springer-Verlag, New York Berlin, 308-320, 1989.
     <http://www.stix.polytechnique.fr/publications/1984-1994.html>

  4. Théorie de Galois Constructive.  Annick Valibouze.  Mémoire
     d’habilitation à diriger les recherches (HDR), Université P. et M.
     Curie (Paris VI), 1994.


File: maxima.info,  Node: Functions and Variables for Symmetries,  Prev: Introduction to Symmetries,  Up: Symmetries

30.2 Functions and Variables for Symmetries
===========================================

30.2.1 Changing bases
---------------------

 -- 関数: comp2pui (<n>, <L>)
     リスト<L>で与えられた与えられた完全対称関数から 0から<n>までの基本
     対称関数にパスすることを実装します。 もしリスト<L>が <n+1>個より少
     ない要素を含むなら、 タイプ<h1>, <h2>などの 形式的な値で完成されま
     す。 もし リスト<L>の最初の要素が存在するなら、 それはアルファベッ
     トのサイズを指定します。 そうでないなら、サイズは<n>に設定されます
     。
          (%i1) comp2pui (3, [4, g]);
                                  2                    2
          (%o1)    [4, g, 2 h2 - g , 3 h3 - g h2 + g (g  - 2 h2)]

 -- 関数: ele2pui (<m>, <L>)
     基本対称関数から完全関数に行きます。 ‘comp2ele’や‘comp2comp’に似て
     います。

     基数を変える他の関数: ‘comp2ele’.

 -- 関数: ele2comp (<m>, <L>)
     基本対称関数から完全関数に行きます。 ‘comp2ele’や‘comp2pui’に似てい
     ます。

     基数を変える他の関数: ‘comp2ele’.

 -- 関数: elem (<ele>, <sym>, <lvar>)
     リスト<lvar>に含まれる変数に関して、 リスト<ele>で与えられた基本対
     称関数を使って、 対称多項式<sym>を分解します。 もし<ele>の最初の要
     素が与えられたら、 アルファベットのサイズで、 そうでないなら、サイ
     ズは多項式<sym>の次数です。 もし値がリスト<ele>になければ、 タイプ
     <e1>, <e2>などの形式的値が加えられます。 多項式<sym>は３つの異なる
     形式で与えられます: contracted (‘elem’はその時、デフォルト値1である
     べきです), partitioned (‘elem’は3であるべきです),または extended(す
     なわち、多項式全体, かつ、‘elem’は2であるべきです)。 関数‘pui’は同
     じ方法で使われます。

     サイズ3のアルファベットと値7を持つ最初の基本対称関数<e1>上で、 (こ
     こで変数の２つにだけ依存する)短縮された形式が<x^4-2*x*y>である 3変
     数の対称多項式が以下のように基本対称関数で分解されます:

          (%i1) elem ([3, 7], x^4 - 2*x*y, [x, y]);
          (%o1) 7 (e3 - 7 e2 + 7 (49 - e2)) + 21 e3

                                                   + (- 2 (49 - e2) - 2) e2
          (%i2) ratsimp (%);
                                        2
          (%o2)             28 e3 + 2 e2  - 198 e2 + 2401

     基数を変える他の関数: ‘comp2ele’.

 -- 関数: mon2schur (<L>)
     リスト<L>は Schur関数S_Lを表します: we have i_1 <= i_2 <= ... <=
     i_q成るL = [i_1, i_2, ..., i_q] を持ちます。 Schur関数S_[i_1, i_2,
     ..., i_q]は、 最初のq個の行と列1 + i_1, 2 + i_2, ..., q + i_q から
     成る無限行列h_[i-j], i <= 1, j <= 1 の小行列式です。

     このSchur関数は ‘treinat’と‘kostka’を使うことで 単項式の項で書かれ
     ることができます。 返される形式は、 変数 x_1,x_2,... の短縮表現の対
     称多項式です。

          (%i1) mon2schur ([1, 1, 1]);
          (%o1)                       x1 x2 x3
          (%i2) mon2schur ([3]);
                                            2        3
          (%o2)                x1 x2 x3 + x1  x2 + x1
          (%i3) mon2schur ([1, 2]);
                                                2
          (%o3)                  2 x1 x2 x3 + x1  x2

     以上は、3つの変数に関してこれが与えることを意味します:

             2 x1 x2 x3 + x1^2 x2 + x2^2 x1 + x1^2 x3 + x3^2 x1
              + x2^2 x3 + x3^2 x2
     基数を変えるための他の関数: ‘comp2ele’.

 -- 関数: multi_elem (<l_elem>, <multi_pc>, <l_var>)
     <l_elem>に含まれる基本対称関数を使って、リスト<l_var>のリストに含ま
     れる 変数のグループに関して、 多重対称多項式を 多重短縮形
     <multi_pc>に分解します。

          (%i1) multi_elem ([[2, e1, e2], [2, f1, f2]], a*x + a^2 + x^3,
                [[x, y], [a, b]]);
                                                            3
          (%o1)         - 2 f2 + f1 (f1 + e1) - 3 e1 e2 + e1
          (%i2) ratsimp (%);
                                   2                       3
          (%o2)         - 2 f2 + f1  + e1 f1 - 3 e1 e2 + e1

     基数を変えるための他の関数: ‘comp2ele’.

 -- 関数: multi_pui
     関数‘multi_elem’が関数‘elem’に対するものであるように、 関数‘pui’に
     対するものです。

          (%i1) multi_pui ([[2, p1, p2], [2, t1, t2]], a*x + a^2 + x^3,
                [[x, y], [a, b]]);
                                                      3
                                          3 p1 p2   p1
          (%o1)              t2 + p1 t1 + ------- - ---
                                             2       2

 -- 関数: pui (<L>, <sym>, <lvar>)
     リスト<L>の中のべき関数を使って、 リスト<lvar>の中の変数に関して、
     対称多項式<sym>を分解します。 もし<L>の最初の要素が与えられるなら、
     アルファベットのサイズです。 そうでないなら、サイズは多項式<sym>の
     次数になります。 もしリスト<L>の中に値がないなら、 タイプ<p1>, <p2>
     , などの形式的な値が加えられます。 多項式<sym>は、 ３つの異なる形式
     で与えられることができます: contracted (‘elem’は1でなければならず、
     デフォルト値です), partitioned (‘elem’は3でなければいけません),
     extended (すなわち、多項式全体、そして‘elem’は2でなければいけません
     )。 関数‘pui’は同じ方法で使われます。

          (%i1) pui;
          (%o1)                           1
          (%i2) pui ([3, a, b], u*x*y*z, [x, y, z]);
                                 2
                             a (a  - b) u   (a b - p3) u
          (%o2)              ------------ - ------------
                                  6              3
          (%i3) ratsimp (%);
                                                 3
                                (2 p3 - 3 a b + a ) u
          (%o3)                 ---------------------
                                          6
     Other functions for changing bases: ‘comp2ele’.

 -- 関数: pui2comp (<n>, <lpui>)
     リスト<lpui>で与えられたべき関数を使って、 (最初に長さを持ち)最初の
     <n>個の完全関数のリストを返します。 もしリスト<lpui>が空なら、 基数
     は<n>で、 そうでないなら、基数は(‘comp2ele’や‘comp2pui’同様) 最初の
     要素です。

          (%i1) pui2comp (2, []);
                                                 2
                                          p2 + p1
          (%o1)                   [2, p1, --------]
                                             2
          (%i2) pui2comp (3, [2, a1]);
                                                      2
                                           a1 (p2 + a1 )
                                   2  p3 + ------------- + a1 p2
                            p2 + a1              2
          (%o2)     [2, a1, --------, --------------------------]
                               2                  3
          (%i3) ratsimp (%);
                                      2                     3
                               p2 + a1   2 p3 + 3 a1 p2 + a1
          (%o3)        [2, a1, --------, --------------------]
                                  2               6
     基数を変えるための他の関数: ‘comp2ele’.

 -- 関数: pui2ele (<n>, <lpui>)
     べき関数から基本対称関数への変転に影響します。 もしフラグ
     ‘pui2ele’が‘girard’なら、 1から<n>までの基本対称関数のリストを返し
     、 もしフラグが‘close’なら、 <n>番目の基本対称関数を返します。

     基数を変えるための他の関数: ‘comp2ele’.

 -- 関数: puireduc (<n>, <lpui>)
     <lpui>は 最初の要素が整数<m>のリストです。 ‘puireduc’は 最初の<m>個
     を使って最初の<n>個のべき関数を与えます。

          (%i1) puireduc (3, [2]);
                                                   2
                                             p1 (p1  - p2)
          (%o1)          [2, p1, p2, p1 p2 - -------------]
                                                   2
          (%i2) ratsimp (%);
                                                     3
                                         3 p1 p2 - p1
          (%o2)              [2, p1, p2, -------------]
                                               2

 -- 関数: schur2comp (<P>, <l_var>)
     <P>はリスト<l_var>の変数の多項式です。 これらの変数のそれぞれは完全
     対称関数を表します。 <l_var>の中で、 <i>番目の完全対称関数は 文字
     ‘h’と整数<i>の連結‘h<i>’によって表されます。 この関数は <P>を
     Schur関数を使って表現します。

          (%i1) schur2comp (h1*h2 - h3, [h1, h2, h3]);
          (%o1)                         s
                                         1, 2
          (%i2) schur2comp (a*h3, [h3]);
          (%o2)                         s  a
                                         3

30.2.2 Changing representations
-------------------------------

 -- 関数: cont2part (<pc>, <lvar>)
     変数が<lvar>の中に含まれている短縮形<pc>に 関連付けられた分割多項式
     を返します。

          (%i1) pc: 2*a^3*b*x^4*y + x^5;
                                     3    4      5
          (%o1)                   2 a  b x  y + x
          (%i2) cont2part (pc, [x, y]);
                                             3
          (%o2)              [[1, 5, 0], [2 a  b, 4, 1]]

 -- 関数: contract (<psym>, <lvar>)
     リスト<lvar>に含まれる変数に関する 多項式<psym>の 短縮形(すなわち、
     対称群の作用の下での単項軌道)を返します。 関数‘explose’は逆演算を実
     行します。 関数‘tcontract’は多項式の対称性をテストします。

          (%i1) psym: explose (2*a^3*b*x^4*y, [x, y, z]);
                   3      4      3      4      3    4        3    4
          (%o1) 2 a  b y z  + 2 a  b x z  + 2 a  b y  z + 2 a  b x  z

                                                     3      4      3    4
                                                + 2 a  b x y  + 2 a  b x  y
          (%i2) contract (psym, [x, y, z]);
                                        3    4
          (%o2)                      2 a  b x  y

 -- 関数: explose (<pc>, <lvar>)
     短縮形<pc>に関連付けられた対称多項式を返します。 リスト<lvar>は変数
     を含みます。

          (%i1) explose (a*x + 1, [x, y, z]);
          (%o1)                  a z + a y + a x + 1

 -- 関数: part2cont (<ppart>, <lvar>)
     対称式を分割形から短縮形に変換します。 短縮形は<lvar>の中の変数で表
     されます。

          (%i1) part2cont ([[2*a^3*b, 4, 1]], [x, y]);
                                        3    4
          (%o1)                      2 a  b x  y

 -- 関数: partpol (<psym>, <lvar>)
     <psym>は リスト<lvar>の変数に関する対称多項式です。 この関数は分割
     表現を返します。

          (%i1) partpol (-a*(x + y) + 3*x*y, [x, y]);
          (%o1)               [[3, 1, 1], [- a, 1, 0]]

 -- 関数: tcontract (<pol>, <lvar>)
     多項式<pol>が リスト<lvar>の変数に関して対称かテストします。 もしそ
     うなら、関数‘contract’のように短縮表現を返します。

 -- 関数: tpartpol (<pol>, <lvar>)
     多項式<pol>が リスト<lvar>の中の変数に関して 対称かテストします。 も
     しそうなら 関数‘partpol’のように 分割表現を返します。

30.2.3 Groups and orbits
------------------------

 -- 関数: direct ([<p_1>, ..., <p_n>], <y>, <f>, [<lvar_1>, ...,
          <lvar_n>])
     変数<lvar_1>, ..., <lvar_n>のリストと 変数<y>についての多項式<p_1>,
     ..., <p_n>に関して、 関数<f>に関連付けられた順像 (M. Giusti, D.
     Lazard et A. Valibouze, ISSAC 1988, Romeを参照してください) を計算
     します。 関数<f>のアリティが計算にとって重要です。 例えば、 <f>につ
     いての式がある変数に依存しないなら、 この変数を含むことは役に立たず
     、含めなければ、 計算量を相当に減らすことにもなるでしょう。

          (%i1) direct ([z^2  - e1* z + e2, z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]);
                 2
          (%o1) y  - e1 f1 y

                                           2            2             2   2
                            - 4 e2 f2 - (e1  - 2 e2) (f1  - 2 f2) + e1  f1
                          + -----------------------------------------------
                                                   2
          (%i2) ratsimp (%);
                        2                2                   2
          (%o2)        y  - e1 f1 y + (e1  - 4 e2) f2 + e2 f1
          (%i3) ratsimp (direct ([z^3-e1*z^2+e2*z-e3,z^2  - f1* z + f2],
                        z, b*v + a*u, [[u, v], [a, b]]));
                 6            5         2                        2    2   4
          (%o3) y  - 2 e1 f1 y  + ((2 e1  - 6 e2) f2 + (2 e2 + e1 ) f1 ) y

                                    3                               3   3
           + ((9 e3 + 5 e1 e2 - 2 e1 ) f1 f2 + (- 2 e3 - 2 e1 e2) f1 ) y

                   2       2        4    2
           + ((9 e2  - 6 e1  e2 + e1 ) f2

                              2       2       2                   2    4
           + (- 9 e1 e3 - 6 e2  + 3 e1  e2) f1  f2 + (2 e1 e3 + e2 ) f1 )

            2          2                      2     3          2
           y  + (((9 e1  - 27 e2) e3 + 3 e1 e2  - e1  e2) f1 f2

                           2            2    3                5
           + ((15 e2 - 2 e1 ) e3 - e1 e2 ) f1  f2 - 2 e2 e3 f1 ) y

                     2                   3           3     2   2    3
           + (- 27 e3  + (18 e1 e2 - 4 e1 ) e3 - 4 e2  + e1  e2 ) f2

                   2      3                   3    2   2
           + (27 e3  + (e1  - 9 e1 e2) e3 + e2 ) f1  f2

                             2    4        2   6
           + (e1 e2 e3 - 9 e3 ) f1  f2 + e3  f1

     根が和a+uである多項式を見つけること。 ただし、aはz^2 - e_1 z + e_2の
     根で、 uはz^2 - f_1 z + f_2の根です。

          (%i1) ratsimp (direct ([z^2 - e1* z + e2, z^2 - f1* z + f2],
                                    z, a + u, [[u], [a]]));
                 4                    3             2
          (%o1) y  + (- 2 f1 - 2 e1) y  + (2 f2 + f1  + 3 e1 f1 + 2 e2

               2   2                              2               2
           + e1 ) y  + ((- 2 f1 - 2 e1) f2 - e1 f1  + (- 2 e2 - e1 ) f1

                            2                     2            2
           - 2 e1 e2) y + f2  + (e1 f1 - 2 e2 + e1 ) f2 + e2 f1  + e1 e2 f1

               2
           + e2

     ‘direct’は２つのフラグを受け付けます: ‘elementaires’と‘puissances’
     (デフォルト) これらは、計算の中に現れる対称多項式を それぞれ基本対
     称関数またはべき関数に分解することを許します。

     この関数で使われる‘sym’の関数は以下の通りです:

     ‘multi_orbit’ (だから‘orbit’), ‘pui_direct’, ‘multi_elem’ (だから
     ‘elem’), ‘multi_pui’ (だから‘pui’), ‘pui2ele’, ‘ele2pui’ (もしフラ
     グ‘direct’が‘puissances’の中にあれば)。

 -- 関数: multi_orbit (<P>, [<lvar_1>, <lvar_2>,..., <lvar_p>])

     <P>は リスト<lvar_1>, <lvar_2>, ..., <lvar_p>に含まれる 変数の集合
     に関する 多項式です。 この関数は これら<p>リストで表された変数の集
     合の対称群の積の作用の下で 多項式<P>の 軌道を返します。

          (%i1) multi_orbit (a*x + b*y, [[x, y], [a, b]]);
          (%o1)                [b y + a x, a y + b x]
          (%i2) multi_orbit (x + y + 2*a, [[x, y], [a, b, c]]);
          (%o2)        [y + x + 2 c, y + x + 2 b, y + x + 2 a]
     以下も参照してください: 単対称群の作用に関する‘orbit’。

 -- 関数: multsym (<ppart_1>, <ppart_2>, <n>)
     次数<n>の対称群の作用を法としてのみ働くことで、 <n>個の変数に関する
     ２つの対称多項式の積を返します。 多項式は分割形式です。

     <x>, <y>に関する鵜２つの対称多項式: 分割形式が‘[[3, 1], [2, 1,
     1]]’と‘[[5, 2]]’である ‘3*(x + y) + 2*x*y’と‘5*(x^2 + y^2)’ が与え
     られたとして、それらの積は、

          (%i1) multsym ([[3, 1], [2, 1, 1]], [[5, 2]], 2);
          (%o1)         [[10, 3, 1], [15, 3, 0], [15, 2, 1]]
     、すなわち、‘10*(x^3*y + y^3*x) + 15*(x^2*y + y^2*x) + 15*(x^3 +
     y^3)’です。

     対称多項式の表現を変える関数は以下の通りです:

     ‘contract’, ‘cont2part’, ‘explose’, ‘part2cont’, ‘partpol’,
     ‘tcontract’, ‘tpartpol’。

 -- 関数: orbit (<P>, <lvar>)
     リスト<lvar>の変数の集合の対称群の作用の下で リスト<lvar>の変数に関
     する多項式<P>の軌道を計算します。

          (%i1) orbit (a*x + b*y, [x, y]);
          (%o1)                [a y + b x, b y + a x]
          (%i2) orbit (2*x + x^2, [x, y]);
                                  2         2
          (%o2)                 [y  + 2 y, x  + 2 x]
     多項式に関する対称群の積の作用に関しては‘multi_orbit’も参照してくだ
     さい。

 -- 関数: pui_direct (<orbite>, [<lvar_1>, ..., <lvar_n>], [<d_1>,
          <d_2>, ..., <d_n>])

     <f>を 変数の<n>個のブロック<lvar_1>, ..., <lvar_n>に関する多項式と
     します。 <c_i>を <lvar_i>の中の変数の数とし、 <SC>を 次数<c_1>,
     ..., <c_n>の <n>個の対称群の積とします。 この群は自然に<f>に作用し
     ます。 リスト<orbite>は <SC>の作用の下での関数<f>の軌道で、
     ‘<SC>(<f>)’を意味します。 (このリストは 関数‘multi_orbit’によって得
     られます。) <di>は c_1 <= d_1, c_2 <= d_2, ..., c_n <= d_n. を満た
     すような整数です。

     <SD>を 対称群 S_[d_1] x S_[d_2] x ... x S_[d_n] の積とします。 関数
     ‘pui_direct’は ‘<SC>(<f>)’のべき関数から演繹された ‘<SD>(<f>)’の 最
     初の<n>個のべき関数を返します。 ここで、<n>は‘<SD>(<f>)’のサイズで
     す。

     結果は<SD>に関する多重短縮された形式です。 すなわち、<SD>の作用の下
     で、軌道毎にただ１つの要素が保持されます。

          (%i1) l: [[x, y], [a, b]];
          (%o1)                   [[x, y], [a, b]]
          (%i2) pui_direct (multi_orbit (a*x + b*y, l), l, [2, 2]);
                                                 2  2
          (%o2)               [a x, 4 a b x y + a  x ]
          (%i3) pui_direct (multi_orbit (a*x + b*y, l), l, [3, 2]);
                                       2  2     2    2        3  3
          (%o3) [2 a x, 4 a b x y + 2 a  x , 3 a  b x  y + 2 a  x ,

              2  2  2  2      3    3        4  4
          12 a  b  x  y  + 4 a  b x  y + 2 a  x ,

              3  2  3  2      4    4        5  5
          10 a  b  x  y  + 5 a  b x  y + 2 a  x ,

              3  3  3  3       4  2  4  2      5    5        6  6
          40 a  b  x  y  + 15 a  b  x  y  + 6 a  b x  y + 2 a  x ]
          (%i4) pui_direct ([y + x + 2*c, y + x + 2*b, y + x + 2*a],
                [[x, y], [a, b, c]], [2, 3]);
                                       2              2
          (%o4) [3 x + 2 a, 6 x y + 3 x  + 4 a x + 4 a ,

                           2                   3        2       2        3
                        9 x  y + 12 a x y + 3 x  + 6 a x  + 12 a  x + 8 a ]

30.2.4 Partitions
-----------------

 -- 関数: kostka (<part_1>, <part_2>)
     P. Esperetによって書かれ、 分割<part_1>と<part_2>のKostka数を計算し
     ます。

          (%i1) kostka ([3, 3, 3], [2, 2, 2, 1, 1, 1]);
          (%o1)                           6

 -- 関数: lgtreillis (<n>, <m>)
     重み<n>と長さ<m>の分割のリストを返します。

          (%i1) lgtreillis (4, 2);
          (%o1)                   [[3, 1], [2, 2]]
     以下も参照してください: ‘ltreillis’, ‘treillis’, ‘treinat’。

 -- 関数: ltreillis (<n>, <m>)
     重み<n>と<m>以下の長さの分割のリストを返します。

          (%i1) ltreillis (4, 2);
          (%o1)               [[4, 0], [3, 1], [2, 2]]
     以下も参照してください: ‘lgtreillis’, ‘treillis’, ‘treinat’。

 -- 関数: treillis (<n>)
     重み<n>の分割すべてを返します。

          (%i1) treillis (4);
          (%o1)    [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]

     以下も参照してください: ‘lgtreillis’, ‘ltreillis’, ‘treinat’。

 -- 関数: treinat (<part>)
     自然な順序に関する分割<part>より低い分割のリストを返します。

          (%i1) treinat ([5]);
          (%o1)                         [[5]]
          (%i2) treinat ([1, 1, 1, 1, 1]);
          (%o2) [[5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1],

                                                           [1, 1, 1, 1, 1]]
          (%i3) treinat ([3, 2]);
          (%o3)                 [[5], [4, 1], [3, 2]]

     以下も参照してください: ‘lgtreillis’, ‘ltreillis’, ‘treillis’。

30.2.5 Polynomials and their roots
----------------------------------

 -- 関数: ele2polynome (<L>, <z>)
     根の基本対称関数が リスト‘<L> = [<n>, <e_1>, ..., <e_n>]’の中にある
     ような <z>に関する多項式を返します。 ここで<n>は多項式の次数であり
     、 <e_i>は<i>番目の基本対称関数です。

          (%i1) ele2polynome ([2, e1, e2], z);
                                    2
          (%o1)                    z  - e1 z + e2
          (%i2) polynome2ele (x^7 - 14*x^5 + 56*x^3  - 56*x + 22, x);
          (%o2)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i3) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o3)            x  - 14 x  + 56 x  - 56 x + 22
     The inverse: ‘polynome2ele (<P>, <z>)’.

     Also see: ‘polynome2ele’, ‘pui2polynome’.

 -- 関数: polynome2ele (<P>, <x>)
     リスト‘<l> = [<n>, <e_1>, ..., <e_n>]’を与えます。 ここで<n>は 変数
     <x>に関する多項式<P>の次数であり、 <e_i>は <P>の根の<i>番目の基本対
     称関数です。

          (%i1) polynome2ele (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x);
          (%o1)          [7, 0, - 14, 0, 56, 0, - 56, - 22]
          (%i2) ele2polynome ([7, 0, -14, 0, 56, 0, -56, -22], x);
                            7       5       3
          (%o2)            x  - 14 x  + 56 x  - 56 x + 22
     逆: ‘ele2polynome (<l>, <x>)’

 -- 関数: prodrac (<L>, <k>)
     <L>は 集合<A>上の基本対称関数を含む リストです。 ‘prodrac’は、 根が
     <A>の要素の <k>掛ける<k>の積の 多項式を返します。

     ‘somrac’も参照してください。

 -- 関数: pui2polynome (<x>, <lpui>)
     根のべき関数がリスト<lpui>で与えられる <x>に関する多項式を計算しま
     す。

          (%i1) pui;
          (%o1)                           1
          (%i2) kill(labels);
          (%o0)                         done
          (%i1) polynome2ele (x^3 - 4*x^2 + 5*x - 1, x);
          (%o1)                     [3, 4, 5, 1]
          (%i2) ele2pui (3, %);
          (%o2)                     [3, 4, 6, 7]
          (%i3) pui2polynome (x, %);
                                  3      2
          (%o3)                  x  - 4 x  + 5 x - 1
     以下も参照してください: ‘polynome2ele’, ‘ele2polynome’。

 -- 関数: somrac (<L>, <k>)
     リスト<L>は 多項式<P>の基本対称関数を含みます。 関数は 根が<P>の根
     の<k>掛ける<k>の別個の和である 多項式を計算します。

     ‘prodrac’も参照してください。

30.2.6 Resolvents
-----------------

 -- 関数: resolvante (<P>, <x>, <f>, [<x_1>,..., <x_d>])
     変数<x_1>, ..., <x_d>で表現された関数<f>によって 次数<n> >= <d>の
     <x>に関する多項式<P> の解核を計算します。 計算の効率のため、 変換関
     数<f>に現れない変数の リスト‘[<x_1>, ..., <x_d>]’に含まれないことが
     重要です。

     計算の効率を増すためには、 適切なアルゴリズムを使うように
     ‘resolvante’に関するフラグを設定することができます:

     もし関数<f>がユニタリなら:
        • 単変数の多項式,
        • 線形,
        • 交互の,
        • 和,
        • 対照的,
        • 積,
        • (次数5まで使用に向く)Cayley解核の関数

               (x1*x2 + x2*x3 + x3*x4 + x4*x5 + x5*x1 -
                    (x1*x3 + x3*x5 + x5*x2 + x2*x4 + x4*x1))^2

          一般的,
     ‘resolvante’のフラグはそれぞれ:
        • unitaire,
        • lineaire,
        • alternee,
        • somme,
        • produit,
        • cayley,
        • generale.

          (%i1) resolvante: unitaire$
          (%i2) resolvante (x^7 - 14*x^5 + 56*x^3 - 56*x + 22, x, x^3 - 1,
                [x]);

          " resolvante unitaire " [7, 0, 28, 0, 168, 0, 1120, - 154, 7840,
                                   - 2772, 56448, - 33880,

          413952, - 352352, 3076668, - 3363360, 23114112, - 30494464,

          175230832, - 267412992, 1338886528, - 2292126760]
            3       6      3       9      6      3
          [x  - 1, x  - 2 x  + 1, x  - 3 x  + 3 x  - 1,

           12      9      6      3       15      12       9       6      3
          x   - 4 x  + 6 x  - 4 x  + 1, x   - 5 x   + 10 x  - 10 x  + 5 x

                 18      15       12       9       6      3
           - 1, x   - 6 x   + 15 x   - 20 x  + 15 x  - 6 x  + 1,

           21      18       15       12       9       6      3
          x   - 7 x   + 21 x   - 35 x   + 35 x  - 21 x  + 7 x  - 1]
          [- 7, 1127, - 6139, 431767, - 5472047, 201692519, - 3603982011]
                 7      6        5         4          3           2
          (%o2) y  + 7 y  - 539 y  - 1841 y  + 51443 y  + 315133 y

                                                        + 376999 y + 125253
          (%i3) resolvante: lineaire$
          (%i4) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante lineaire "
                 24       20         16            12             8
          (%o4) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i5) resolvante: general$
          (%i6) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3]);

          " resolvante generale "
                 24       20         16            12             8
          (%o6) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i7) resolvante (x^4 - 1, x, x1 + 2*x2 + 3*x3, [x1, x2, x3, x4]);

          " resolvante generale "
                 24       20         16            12             8
          (%o7) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i8) direct ([x^4 - 1], x, x1 + 2*x2 + 3*x3, [[x1, x2, x3]]);
                 24       20         16            12             8
          (%o8) y   + 80 y   + 7520 y   + 1107200 y   + 49475840 y

                                                              4
                                                 + 344489984 y  + 655360000
          (%i9) resolvante :lineaire$
          (%i10) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante lineaire "
                                        4
          (%o10)                       y  - 1
          (%i11) resolvante: symetrique$
          (%i12) resolvante (x^4 - 1, x, x1 + x2 + x3, [x1, x2, x3]);

          " resolvante symetrique "
                                        4
          (%o12)                       y  - 1
          (%i13) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante symetrique "
                                     6      2
          (%o13)                    y  - 4 y  - 1
          (%i14) resolvante: alternee$
          (%i15) resolvante (x^4 + x + 1, x, x1 - x2, [x1, x2]);

          " resolvante alternee "
                      12      8       6        4        2
          (%o15)     y   + 8 y  + 26 y  - 112 y  + 216 y  + 229
          (%i16) resolvante: produit$
          (%i17) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante produit "
                  35      33         29        28         27        26
          (%o17) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i18) resolvante: symetrique$
          (%i19) resolvante (x^7 - 7*x + 3, x, x1*x2*x3, [x1, x2, x3]);

          " resolvante symetrique "
                  35      33         29        28         27        26
          (%o19) y   - 7 y   - 1029 y   + 135 y   + 7203 y   - 756 y

                   24           23          22            21           20
           + 1323 y   + 352947 y   - 46305 y   - 2463339 y   + 324135 y

                    19           18             17              15
           - 30618 y   - 453789 y   - 40246444 y   + 282225202 y

                       14              12             11            10
           - 44274492 y   + 155098503 y   + 12252303 y   + 2893401 y

                        9            8            7             6
           - 171532242 y  + 6751269 y  + 2657205 y  - 94517766 y

                      5             3
           - 3720087 y  + 26040609 y  + 14348907
          (%i20) resolvante: cayley$
          (%i21) resolvante (x^5 - 4*x^2 + x + 1, x, a, []);

          " resolvante de Cayley "
                  6       5         4          3            2
          (%o21) x  - 40 x  + 4080 x  - 92928 x  + 3772160 x  + 37880832 x

                                                                 + 93392896

     Cayley解核に関して、最後の2つの引数は中立で、 入力多項式は必然的に
     次数5でなければいけません。

     以下も参照してください:
     ‘resolvante_bipartite’, ‘resolvante_produit_sym’,
     ‘resolvante_unitaire’, ‘resolvante_alternee1’, ‘resolvante_klein’,
     ‘resolvante_klein3’, ‘resolvante_vierer’, ‘resolvante_diedrale’。

 -- 関数: resolvante_alternee1 (<P>, <x>)
     関数 product(x_i - x_j, 1 <= i < j <= n - 1). によって 次数<n>の 変
     換‘<P>(<x>)’を計算します。 以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante’ , ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’, ‘resolvante_bipartite’。

 -- 関数: resolvante_bipartite (<P>, <x>)
     関数 によって 偶次数<n>の‘<P>(<x>)’の変換を計算します。 x_1 x_2 ...
     x_[n/2] + x_[n/2 + 1] ... x_n.

          (%i1) resolvante_bipartite (x^6 + 108, x);
                        10        8           6             4
          (%o1)        y   - 972 y  + 314928 y  - 34012224 y

     以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’, ‘resolvante_alternee1’.

 -- 関数: resolvante_diedrale (<P>, <x>)
     関数‘<x_1> <x_2> + <x_3> <x_4>’によって ‘<P>(<x>)’の変換を計算しま
     す。

          (%i1) resolvante_diedrale (x^5 - 3*x^4 + 1, x);
                 15       12       11       10        9         8         7
          (%o1) x   - 21 x   - 81 x   - 21 x   + 207 x  + 1134 x  + 2331 x

                  6         5          4          3          2
           - 945 x  - 4970 x  - 18333 x  - 29079 x  - 20745 x  - 25326 x

           - 697

     以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante’。

 -- 関数: resolvante_klein (<P>, <x>)
     関数‘<x_1> <x_2> <x_4> + <x_4>’によって ‘<P>(<x>)’の変換を計算しま
     す。

     以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’。

 -- 関数: resolvante_klein3 (<P>, <x>)
     関数‘<x_1> <x_2> <x_4> + <x_4>’によって ‘<P>(<x>)’の変換を計算しま
     す。

     以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’。

 -- 関数: resolvante_produit_sym (<P>, <x>)
     多項式‘<P>(<x>)’のすべての積解核のリストを計算します。

          (%i1) resolvante_produit_sym (x^5 + 3*x^4 + 2*x - 1, x);
                  5      4             10      8       7       6       5
          (%o1) [y  + 3 y  + 2 y - 1, y   - 2 y  - 21 y  - 31 y  - 14 y

              4       3      2       10      8       7    6       5       4
           - y  + 14 y  + 3 y  + 1, y   + 3 y  + 14 y  - y  - 14 y  - 31 y

                 3      2       5      4
           - 21 y  - 2 y  + 1, y  - 2 y  - 3 y - 1, y - 1]
          (%i2) resolvante: produit$
          (%i3) resolvante (x^5 + 3*x^4 + 2*x - 1, x, a*b*c, [a, b, c]);

          " resolvante produit "
                 10      8       7    6        5       4       3     2
          (%o3) y   + 3 y  + 14 y  - y  - 14 y  - 31 y  - 21 y  - 2 y  + 1

     以下も参照してください:
     ‘resolvante’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’,
     ‘resolvante_klein3’, ‘resolvante_vierer’,
     ‘resolvante_diedrale’。

 -- 関数: resolvante_unitaire (<P>, <Q>, <x>)
     多項式‘<Q>(<x>)’によって 多項式‘<P>(<x>)’の解核を計算します。

     以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante_vierer’, ‘resolvante_diedrale’。

 -- 関数: resolvante_vierer (<P>, <x>)
     関数‘<x_1> <x_2> - <x_3> <x_4>’によって ‘<P>(<x>)’の変換を計算しま
     す。

     以下も参照してください:
     ‘resolvante_produit_sym’, ‘resolvante_unitaire’,
     ‘resolvante_alternee1’, ‘resolvante_klein’, ‘resolvante_klein3’,
     ‘resolvante’, ‘resolvante_diedrale’。

30.2.7 Miscellaneous
--------------------

 -- 関数: multinomial (<r>, <part>)
     ここで<r>は分割<part>の重みです。 この関数は、同類の多項係数を返し
     ます: もし<part>の部分が <i_1>, <i_2>, ..., <i_k>なら、 結果は
     ‘<r>!/(<i_1>! <i_2>! ... <i_k>!)’ です。

 -- 関数: permut (<L>)
     リスト<L>の置換のリストを返します。


File: maxima.info,  Node: Groups,  Next: Runtime Environment,  Prev: Symmetries,  Up: Top

31 Groups
*********

* Menu:

* Functions and Variables for Groups::


File: maxima.info,  Node: Functions and Variables for Groups,  Prev: Groups,  Up: Groups

31.1 Functions and Variables for Groups
=======================================

 -- 関数: todd_coxeter (<relations>, <subgroup>)
 -- 関数: todd_coxeter (<relations>)

     G/Hの次数を見つけます。 ここで、Gは法<relations>に関する自由群で、
     Hは、<subgroup>が生成するGの部分群です。 <subgroup>は、オプションの
     引数であり、 省略すると[]になります。 これをする時には、 GのG/H上の
     右作用に関する乗算テーブルを生成します。 ここで、剰余類が
     [H,Hg2,Hg3,...]と数え上げられます。 これは、内部的に変数
     ‘todd_coxeter_state’で見ることができます。

     例:

          (%i1) symet(n):=create_list(
                  if (j - i) = 1 then (p(i,j))^^3 else
                      if (not i = j) then (p(i,j))^^2 else
                          p(i,i) , j, 1, n-1, i, 1, j);
                                                                 <3>
          (%o1) symet(n) := create_list(if j - i = 1 then p(i, j)

                                          <2>
           else (if not i = j then p(i, j)    else p(i, i)), j, 1, n - 1,

          i, 1, j)
          (%i2) p(i,j) := concat(x,i).concat(x,j);
          (%o2)        p(i, j) := concat(x, i) . concat(x, j)
          (%i3) symet(5);
                   <2>           <3>    <2>           <2>           <3>
          (%o3) [x1   , (x1 . x2)   , x2   , (x1 . x3)   , (x2 . x3)   ,

                      <2>           <2>           <2>           <3>    <2>
                    x3   , (x1 . x4)   , (x2 . x4)   , (x3 . x4)   , x4   ]
          (%i4) todd_coxeter(%o3);

          Rows tried 426
          (%o4)                          120
          (%i5) todd_coxeter(%o3,[x1]);

          Rows tried 213
          (%o5)                          60
          (%i6) todd_coxeter(%o3,[x1,x2]);

          Rows tried 71
          (%o6)                          20


File: maxima.info,  Node: Runtime Environment,  Next: Miscellaneous Options,  Prev: Groups,  Up: Top

32 Runtime Environment
**********************

* Menu:

* Introduction for Runtime Environment::  
* Interrupts::                  
* Functions and Variables for Runtime Environment::  


File: maxima.info,  Node: Introduction for Runtime Environment,  Next: Interrupts,  Prev: Runtime Environment,  Up: Runtime Environment

32.1 Introduction for Runtime Environment
=========================================

‘maxima-init.mac’は、Maximaがスタートする時自動的にロードされるファイル
です。 自分のMaxima環境をカスタマイズするために ‘maxima-init.mac’を使う
ことができます。 ‘maxima-init.mac’は、もし存在するなら、 関数
‘file_search’が検索する任意のディレクトリで大丈夫ですが、 通常は、
‘maxima_userdir’で名付けらたディレクトリの中に置かれます。

   これは、‘maxima-init.mac’ファイルの例です:

     setup_autoload ("specfun.mac", ultraspherical, assoc_legendre_p);
     showtime:all;

   この例では、‘setup_autoload’は、Maximaに もし関数(‘ultraspherical’,
‘assoc_legendre_p’)のいずれかがコールされて、まだ定義されていなかったら
、 指定されたファイル(‘specfun.mac’)をロードするように命じます。 このよ
うに、関数をコールする前にファイルをロードすることを覚えておく必要はあり
ません。

   文‘showtime: all’は、Maximaに‘showtime’変数を設定することを命じます。
‘maxima-init.mac’ファイルは、 他の任意の割り当てやMaxima文を含むことがで
きます。


File: maxima.info,  Node: Interrupts,  Next: Functions and Variables for Runtime Environment,  Prev: Introduction for Runtime Environment,  Up: Runtime Environment

32.2 Interrupts
===============

ユーザーは、時間のかかる計算を^C (control-C)文字で止めることができます。
デフォルトの動作は、計算を止めて、別のユーザープロンプトを印字することで
です。 この場合、止められた計算の再開することはできません。

   もし

     :lisp (setq *debugger-hook* nil)

を実行することによって、 Lisp変数‘*debugger-hook*’が‘nil’に設定されてい
るなら、 ^Cを受け取ると、Maximaは、Lispデバッガに入り、 ユーザーは、
Lisp環境を検査するためにデバッガを使うことができます。 止められた計算は
、Lispデバッガの中で、 ‘continue’を入力することで、再開することができま
す。 (計算を完了まで走らせる以外に) LispデバッガからMaximaに戻る方法は、
Lispのバージョンそれぞれで異なります。

   Unixシステム上では、文字^Z (control-Z)は、 Maximaが完全に止まるように
し、 制御は、シェルスクリプトに戻ります。 ‘fg’コマンドは、Maximaが 止め
られた点から再開するようにします。


File: maxima.info,  Node: Functions and Variables for Runtime Environment,  Prev: Interrupts,  Up: Runtime Environment

32.3 Functions and Variables for Runtime Environment
====================================================

 -- 宣言: feature

     Maximaは、システムフィーチャと数学式に適用されるフィーチャの、 ２つ
     の異なるタイプのフィーチャを理解します。 See also システムフィーチ
     ャについての情報に関しては、‘status’も参照してください。 数学的フィ
     ーチャについての情報に関しては、 ‘features’と‘featurep’も参照してく
     ださい。

     ‘feature’それ自身は、関数名でも変数名でもありません。

 -- 関数: featurep (<a>, <f>)

     現在のデータベースの中の事実に基づいて オブジェクト<a>が フィーチャ
     <f>を持つかどうか を決定しようとします。 もしそうなら、‘true’を返し
     、そうでなければ‘false’を返します。

     ‘featurep’は、 <f>も<f>の否定も確立できない時は、 ‘false’を返すこと
     に注意してください。

     ‘featurep’は、引数を評価します。

     ‘declare’と‘features’も参照してください。

          (%i1) declare (j, even)$
          (%i2) featurep (j, integer);
          (%o2)                           true

 -- システム変数: maxima_tempdir

     ‘maxima_tempdir’は、Maximaが一時的なファイルを生成するディレクトリ
     を 指名します。 特に、プロットのための一時ファイルが
     ‘maxima_tempdir’に生成されます。

     ‘maxima_tempdir’の初期値は、 もしMaximaが置くことができるなら、ユー
     ザーのホームディレクトリです; そうでなければ、Maximaは適切なディレ
     クトリについて推量します。

     ‘maxima_tempdir’は、ディレクトリを指名する文字列に割り当てられます
     。

 -- システム変数: maxima_userdir

     ‘maxima_userdir’は、 Maximaが、MaximaやLispファイルを見つけるために
     検索するディレクトリを指名します。 (Maximaは、他のディレクトリも検
     索します; ‘file_search_maxima’と‘file_search_lisp’は、完全なリスト
     です。)

     ‘maxima_userdir’の初期値は、 もしMaximaが置くことができなら、 ユー
     ザーのホームディレクトリのサブディレクトリです; そうでなければ、
     Maximaは適切なディレクトリについて推量します。

     ‘maxima_userdir’は、ディレクトリを指名する文字列に割り当てられます
     。 しかしながら、 ‘maxima_userdir’への割り当ては、自動的には
     ‘file_search_maxima’と‘file_search_lisp’を変えません; それらの変数
     は、別々に変更しなければいけません。

 -- 関数: room ()
 -- 関数: room (true)
 -- 関数: room (false)

     Maximaの記憶装置とスタックマネージメントの状態の描写を印字します。
     ‘room’は、同じ名前のLisp関数をコールします。

        • ‘room ()’は、適度の描写を印字します。
        • ‘room (true)’は、言葉数の多い描写を印字します。
        • ‘room (false)’は、簡潔な描写を印字します。

 -- 関数: sstatus (<keyword>, <item>)

     <keyword>がシンボル‘feature’の時、<item>がシステムフィーチャのリス
     ト上に追加されます。 ‘sstatus (keyword, item)’が実行された後、
     ‘status (feature, item)’は‘true’を返します。 もし<keyword>がシンボ
     ル‘nofeature’なら、 <item>はシステムフィーチャのリストから削除され
     ます。 これはパッケージ作者が、搭載したフィーチャの追跡をするのに役
     に立つかもしれません。

     ‘status’も参照してください。

 -- 関数: status (‘feature’)
 -- 関数: status (‘feature’, <item>)
     いくつかのシステム依存のフィーチャの存在と不在についての情報を返す
     。

        • ‘status (feature)’は、システムフィーチャのリストを返します。 こ
          れらは、Lispのバージョン、オペレーティングシステムのタイプなど
          を含みます。 リストは、１つのLispタイプからもう１つに変わるか
          もしれません。

        • ‘status (feature, item)’は、 もし<item>が‘status (feature)’が
          返す項目のリスト上にあるなら、 ‘true’を返し、そうでなければ、
          ‘false’を返します。 ‘status’は、引数<item>をクォートします。 ク
          ォート-クォート演算子‘''’は、クォーテーションに優先されます。
          名前が、ハイフンのように特殊文字を含むフィーチャは、 文字列引
          数として与えられなければいけません。例えば、 ‘status (feature,
          "ansi-cl")’。

     ‘sstatus’も参照してください。

     変数‘features’は、 数式に適用される フィーチャのリストを含みます。
     もっと情報を知るには、‘features’と‘featurep’を参照してください。

 -- 関数: system (<command>)

     別のプロセスとして<command>を実行します。 コマンドは実行のためデフ
     ォルトのシェルに渡されます。 ‘system’は、オペレーティングシステムす
     べてではサポートされませんが、 一般にUnixとUnixライクな環境では存在
     します。

     ‘_hist.out’が、 ‘xgraph’を使ってバーグラフとしてプロットしたい頻度
     のリストだと仮定します。

          (%i1) (with_stdout("_hist.out",
                     for i:1 thru length(hist) do (
                       print(i,hist[i]))),
                 system("xgraph -bar -brw .7 -nl < _hist.out"));

     プロットをバックグラウンドで（Maximaに制御を戻すように）させるよう
     にし、終了した後、一次ファルを削除するようにするためには、以下のよ
     うにします:

          system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")

 -- 関数: time (%o1, %o2, %o3, …)

     出力行‘%o1’, ‘%o2’, ‘%o3’, …を計算するために使った 時間のリストを秒
     で返します。 返された時間は、内部計算時間のMaximaの概算であって、経
     過時間ではありません。 ‘time’は、出力行変数にだけ適用されます; 他の
     変数に関して、‘time’は‘unknown’を返します。

     Maximaに出力行それぞれに計算時間と経過時間を印字させるには、
     ‘showtime: true’を設定してください。

 -- 関数: timedate ()
 -- 関数: timedate (<T>)

     引数なしの‘timedate()’は現在時刻と日付を表す文字列を返します。 文字
     列は、フォーマット‘YYYY-MM-DD HH:MM:SS[+|-]ZZ:ZZ’を持ちます。 ここ
     で、欄は、年、月、日、時、分、秒、時間と分のタイムゾーンオフセット
     です。

     ‘timedate(<T>)’は フォーマット‘YYYY-MM-DD HH:MM:SS[+|-]ZZ:ZZ’の文字
     列として 時刻<T>を返します。 <T>は ‘absolute_real_time’が返すような
     1990年1月1日の真夜中以来の秒数として解釈されます。

     例:

     引数なしの‘timedate()’は現在時刻と日付を表す文字列を返します。

          (%i1) d : timedate ();
          (%o1)                      2010-06-08 04:08:09+01:00
          (%i2) print ("timedate reports current time", d) $
          timedate reports current time 2010-06-08 04:08:09+01:00

     引数ありの‘timedate’は引数を表す文字列を返します。

          (%i1) timedate (0);
          (%o1)                      1900-01-01 01:00:00+01:00
          (%i2) timedate (absolute_real_time () - 7*24*3600);
          (%o2)                      2010-06-01 04:19:51+01:00

 -- 関数: absolute_real_time ()

     協定世界時で1900年1月1日の深夜以来の 秒数を返します。 戻り値は整数
     です。

     ‘elapsed_real_time’と‘elapsed_run_time’も参照してください。

     例:

          (%i1) absolute_real_time ();
          (%o1)                      3385045277
          (%i2) 1900 + absolute_real_time () / (365.25 * 24 * 3600);
          (%o2)                   2007.265612087104

 -- 関数: elapsed_real_time ()

     Maximaがもっとも最近スタートしたか再スタートして以来の (1秒の小数を
     含む)秒数を返します。 戻り値は浮動小数点数です。

     ‘absolute_real_time’と‘elapsed_run_time’も参照してください。

     例:

          (%i1) elapsed_real_time ();
          (%o1)                       2.559324
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_real_time ();
          (%o3)                       7.552087

 -- 関数: elapsed_run_time ()

     Maximaがもっとも最近スタートしたか再スタートして以来 Maximaが計算に
     費やした (1秒の小数を含む)秒数の概算を返します。 戻り値は浮動小数点
     数です。

     ‘absolute_real_time’と‘elapsed_real_time’も参照してください。

     例:

          (%i1) elapsed_run_time ();
          (%o1)                         0.04
          (%i2) expand ((a + b)^500)$
          (%i3) elapsed_run_time ();
          (%o3)                         1.26


File: maxima.info,  Node: Miscellaneous Options,  Next: Rules and Patterns,  Prev: Runtime Environment,  Up: Top

33 Miscellaneous Options
************************

* Menu:

* Introduction to Miscellaneous Options::  
* Share::                       
* Functions and Variables for Miscellaneous Options::  


File: maxima.info,  Node: Introduction to Miscellaneous Options,  Next: Share,  Prev: Miscellaneous Options,  Up: Miscellaneous Options

33.1 Introduction to Miscellaneous Options
==========================================

この節では、Maximaの操作上、グローバルな効果を持つ様々なオプションが論じ
られます。 すべてのユーザー定義関数のリストのような様々なリストも論じら
れます。


File: maxima.info,  Node: Share,  Next: Functions and Variables for Miscellaneous Options,  Prev: Introduction to Miscellaneous Options,  Up: Miscellaneous Options

33.2 Share
==========

Maximaの「共有」ディレクトリは、Maximaユーザーのためのものですが、
Maximaのコア実装の部分ではない、プログラムと他のファイルを含みます。 こ
れらのプログラムは、通常、 ‘load’や ‘setup_autoload’によってロードされま
す。

   ‘:lisp *maxima-sharedir*’は、 ユーザーのファイルシステム内の共有ディ
レクトリの位置を表示します。

   ‘printfile ("share.usg")’は、 共有パッケージの期限切れリストを印字し
ます。 ユーザーは、 ファイルシステムブラウザを使って共有ディレクトリをブ
ラウズすることがもっと情報が得られることを知るでしょう。


File: maxima.info,  Node: Functions and Variables for Miscellaneous Options,  Prev: Share,  Up: Miscellaneous Options

33.3 Functions and Variables for Miscellaneous Options
======================================================

 -- 宣言: alphabetic

     ‘alphabetic’は、 ‘declare’が認識する宣言タイプです。 式
     ‘declare(<s>, alphabetic)’は、Maximaに <s>―は文字列でなければいけま
     せん―の中の文字のすべてをalphabeticとして認識するように 命じます。

     *note Identifiers::も参照してください。

     例:

          (%i1) xx\~yy\`\@ : 1729;
          (%o1)                         1729
          (%i2) declare ("~`@", alphabetic);
          (%o2)                         done
          (%i3) xx~yy`@ + @yy`xx + `xx@@yy~;
          (%o3)               `xx@@yy~ + @yy`xx + 1729
          (%i4) listofvars (%);
          (%o4)                  [@yy`xx, `xx@@yy~]

 -- オプション変数: genindex
     デフォルト値: ‘i’

     ‘genindex’は、 必要な時、和の次の変数を生成するために使われる アル
     ファベットの接頭辞です。

 -- オプション変数: gensumnum
     デフォルト値: 0

     ‘gensumnum’は、 和の次の変数を生成するために使われる 数値接尾辞です
     。 もし‘false’に設定されているなら、 インデックスは数値接尾辞なしで
     ‘genindex’だけから成ります。

 -- 関数: gensym ()
 -- 関数: gensym (<x>)

     ‘gensym()’は新鮮なシンボルを生成し、返します。

     新しいシンボルの名前は、 デフォルトでは"g"の接頭辞と Lisp内部カウン
     タの値がデフォルトの数の十進表現である接尾辞の連結です。

     もし<x>が供給されて、それが文字列なら、 このgensymへの呼び出しに限
     って、 その文字列は"g"の代わりに接頭辞として使われます。

     もし<x>が供給されて、それが整数なら、 このgensymへの呼び出しに限っ
     て、 内部Lisp整数の値の代わりに接尾辞として使われます。

     もし陽な接尾辞が供給されないなら、また、その時だけ、 Lisp内部整数は
     、使われた後1だけ増分されます。

     例:

          (%i1) gensym();
          (%o1)                         g887
          (%i2) gensym("new");
          (%o2)                        new888
          (%i3) gensym(123);
          (%o3)                         g123

 -- 関数: properties (<a>)

     アトム<a>に関連づけられたプロパティすべての名前のリストを返します。

 -- 特殊シンボル: props

     ‘props’は、 ‘declare’関数で指定されたプロパティはもちろん、
     ‘atvalue’, ‘matchdeclare’, などが指定したような、 ‘infolists’で陽に
     言及されたもの以外の任意のプロパティ、を持つアトムです。

 -- 関数: propvars (<prop>)

     ‘props’リスト上の、 <prop>が示すプロパティを持つアトムのリストを返
     します。 従って， ‘propvars (atvalue)’は、atvalueを持つアトムのリス
     トを返します。

 -- 関数: put (<atom>, <value>, <indicator>)

     <value>を<atom>の(<indicator>が指定する)プロパティに割り当てます。
     <indicator>は、任意のプロパティの名前を取り得ますが、 システム定義
     のプロパティは取りません。

     ‘rem’は‘put’の効果をひっくり返します。

     ‘put’は引数を評価します。 ‘put’は<value>を返します。

     例:

          (%i1) put (foo, (a+b)^5, expr);
                                             5
          (%o1)                       (b + a)
          (%i2) put (foo, "Hello", str);
          (%o2)                         Hello
          (%i3) properties (foo);
          (%o3)            [[user properties, str, expr]]
          (%i4) get (foo, expr);
                                             5
          (%o4)                       (b + a)
          (%i5) get (foo, str);
          (%o5)                         Hello

 -- 関数: qput (<atom>, <value>, <indicator>)

     <value>を<atom>の(<indicator>が指定する)プロパティに割り当てます。
     これは、引数がクォートされることを除いて、‘put’と同じです。

     例:

          (%i1) foo: aa$
          (%i2) bar: bb$
          (%i3) baz: cc$
          (%i4) put (foo, bar, baz);
          (%o4)                          bb
          (%i5) properties (aa);
          (%o5)                [[user properties, cc]]
          (%i6) get (aa, cc);
          (%o6)                          bb
          (%i7) qput (foo, bar, baz);
          (%o7)                          bar
          (%i8) properties (foo);
          (%o8)            [value, [user properties, baz]]
          (%i9) get ('foo, 'baz);
          (%o9)                          bar

 -- 関数: rem (<atom>, <indicator>)

     <atom>から、<indicator>が示すプロパティを取り除きます。 ‘rem’は
     ‘put’の効果をひっくり返します。

     ‘rem’が呼び出された時、もし<atom>が<indicator>プロパティを持ってい
     たなら、‘rem’は‘done’を返します。もしそんなプロパティを持っていなか
     ったら‘false’を返します。

 -- 関数: remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)
 -- 関数: remove ([<a_1>, …, <a_m>], [<p_1>, …, <p_n>], ...)
 -- 関数: remove ("<a>", operator)
 -- 関数: remove (<a>, transfun)
 -- 関数: remove (all, <p>)
     アトムに関連づけられたプロパティを取り除きます。

     ‘remove (<a_1>, <p_1>, ..., <a_n>, <p_n>)’ は、アトム‘a_k’からプロ
     パティ‘p_k’を取り除きます。

     ‘remove ([<a_1>, ..., <a_m>], [<p_1>, ..., <p_n>], ...)’ は、 アト
     ム<a_1>, …, <a_m>から プロパティ‘<p_1>, ..., <p_n>’を 取り除きます
     。 リストのペアは複数を取り得ます。

     ‘remove (all, <p>)’は、 プロパティ<p>を、それを持つアトムすべてから
     取り除きます。

     取り除かれるプロパティは、 ‘function’, ‘macro’, ‘mode_declare’のよ
     うなシステム定義のプロパティ かもしれません。 ‘remove’は‘put’で定義
     されたプロパティを取り除きません。

     翻訳されたLispバージョンの関数を取り除くために プロパティは、
     ‘transfun’を取ることができます。 これを実行した後は、翻訳バージョン
     でなく、Maximaバージョンの関数が実行されます。

     ‘remove ("<a>", operator)’または、同値な, ‘remove ("<a>", op)’ は、
     <a>から ‘prefix’, ‘infix’, ‘nary’, ‘postfix’, ‘matchfix’, ‘nofix’が
     宣言した演算子プロパティを取り除きます。 演算子名はクォートされた文
     字列として書かれなければいけないことに注意してください。

     アトムが指定されたプロパティを持とうが持ちまいが、 ‘remove’は、いつ
     も‘done’を返します。 この振る舞いは、もっと具体的な削除関数
     ‘remvalue’, ‘remarray’, ‘remfunction’, ‘remrule’と似ていません。

     ‘remove’は引数をクォートします。

 -- 関数: remvalue (<name_1>, ..., <name_n>)
 -- 関数: remvalue (all)

     (添字付きもありえる)ユーザー変数<name_1>, ..., <name_n>の値をシステ
     ムから 取り除きます。

     ‘remvalue (all)’は、 removes the values of all variables in
     ‘values’―(Maximaが自動的に割り当てたものと対照的に) ユーザーが名前
     を与えた変数すべてのリスト― の中の変数すべての値を取り除きます。

     ‘values’も参照してください。

 -- 関数: rncombine (<expr>)

     同一の分母や、たがいに数値因子だけことなる分母を持つ <expr>のすべて
     の項を結合することで、 <expr>を変換します。 これは、‘combine’の振る
     舞いとわずかに違います。 ‘combine’は、同一分母を持つ項を集めます。

     ‘pfeformat: true’を設定し、‘combine’を使うことは、 ‘rncombine’を使
     って得られるものと似た結果をもたらしますが、 ‘rncombine’は、 クロス
     積の数値的分母因子のおまけのステップを実行します。 これは、きれいな
     形式と、いくつかの相殺を認識する可能性を生みます。

     ‘load("rncomb")’はこの関数をロードします。

 -- 関数: scalarp (<expr>)

     もし<expr>が、数か、定数、 ‘declare’で‘scalar’と宣言された変数、 数
     と定数とそんな変数から完全に構成され、行列やリストを含まない変数な
     ら、 ‘true’を返します。

 -- 関数: setup_autoload (<filename>, <function_1>, ..., <function_n>)

     もし<function_1>, ..., <function_n>のいずれかが、 参照されたがまだ
     定義されていないなら、 ‘load’を通じて<filename>がロードされるように
     指定します。 <filename>は、 強制はされませんが、普通、指定された関
     数の定義を含みます。

     ‘setup_autoload’は配列関数については機能しません。

     ‘setup_autoload’は引数をクォートします。

     例:

          (%i1) legendre_p (1, %pi);
          (%o1)                  legendre_p(1, %pi)
          (%i2) setup_autoload ("specfun.mac", legendre_p, ultraspherical);
          (%o2)                         done
          (%i3) ultraspherical (2, 1/2, %pi);
          Warning - you are redefining the Macsyma function ultraspherical
          Warning - you are redefining the Macsyma function legendre_p
                                      2
                           3 (%pi - 1)
          (%o3)            ------------ + 3 (%pi - 1) + 1
                                2
          (%i4) legendre_p (1, %pi);
          (%o4)                          %pi
          (%i5) legendre_q (1, %pi);
                                        %pi + 1
                                %pi log(-------)
                                        1 - %pi
          (%o5)                 ---------------- - 1
                                       2


File: maxima.info,  Node: Rules and Patterns,  Next: Sets,  Prev: Miscellaneous Options,  Up: Top

34 Rules and Patterns
*********************

* Menu:

* Introduction to Rules and Patterns::  
* Functions and Variables for Rules and Patterns::  


File: maxima.info,  Node: Introduction to Rules and Patterns,  Next: Functions and Variables for Rules and Patterns,  Prev: Rules and Patterns,  Up: Rules and Patterns

34.1 Introduction to Rules and Patterns
=======================================

この節ではユーザー定義のパターンマッチングと整理ルールを記述します。 幾
分違ったパターンマッチング体系を実装した２つの関数グループがあります。 １
つのグループは、‘tellsimp’, ‘tellsimpafter’, ‘defmatch’, ‘defrule’,
‘apply1’, ‘applyb1’, ‘apply2’です。 他のグループは、‘let’, ‘letsimp’です
。 どちらの体系も、 ‘matchdeclare’が宣言したパターン変数を使ってパターン
を定義します。

   ‘tellsimp’と‘tellsimpafter’が定義するパターンマッチングルールは、
Maximaの整理器によって自動的に適用されます。 ‘defmatch’, ‘defrule’,
‘let’によって定義されたルールは、 明示的に関数をコールすることで適用され
ます。

   更に、‘tellrat’が多項式に適用するルール用メカニズムと、 ‘affine’パッ
ケージの可換/非可換代数用メカニズムがあります。


File: maxima.info,  Node: Functions and Variables for Rules and Patterns,  Prev: Introduction to Rules and Patterns,  Up: Rules and Patterns

34.2 Functions and Variables for Rules and Patterns
===================================================

 -- 関数: apply1 (<expr>, <rule_1>, ..., <rule_n>)

     <rule_1>を <expr>に、失敗するまで繰り返し適用して、 それから同じル
     ールを <expr>の部分式すべてに左から右へ、 部分式すべてで <rule_1>が
     失敗するまで繰り返し適用します。

     この方法で <expr>を変換した結果を <expr_2>と呼ぶことにします。 次に
     、 <rule_2>を <expr_2>の最上部から始めて同じ方法で適用します。
     <rule_n>が最後の部分式上で失敗する時、結果が返されます。

     ‘maxapplydepth’は、 ‘apply1’と ‘apply2’が処理する最も深い部分式の深
     さです。

     ‘applyb1’, ‘apply2’, ‘let’も参照してください。

 -- 関数: apply2 (<expr>, <rule_1>, ..., <rule_n>)

     もし<rule_1>が与えられた部分式上で失敗したら、 <rule_2>が繰り返し適
     用されます、などなど。 すべてのルールが与えられた部分式上で失敗した
     時だけ、 ルールの全組が次の部分式に繰り返し適用されます。 もしルー
     ルの１つが成功したら、 同じ部分式が最初のルールから再処理されます。

     ‘maxapplydepth’は、 ‘apply1’と‘apply2’が処理する最も深い部分式の深
     さです。

     ‘apply1’と‘let’も参照してください。

 -- 関数: applyb1 (<expr>, <rule_1>, ..., <rule_n>)

     失敗するまで、繰り返し <expr>の最も深い部分式に <rule_1>を適用し、
     その後、 <rule_1>がトップレベルの式で失敗するまで、 同じルールを１
     つ高いレベル(すなわち、より大きな部分式)に適用します。 その後、
     <rule_2>が<rule_1>の結果に 同様に適用されます。 <rule_n>がトップレ
     ベルの式に適用された後、結果が返されます。

     ‘applyb1’は ‘apply1’に似ていますが、 トップダウンからの代わりにボト
     ムアップから働きます。

     ‘maxapplyheight’は ‘applyb1’が、あきらめる前に届く 最大の高さです

     ‘apply1’, ‘apply2’, ‘let’も参照してください。

 -- オプション変数: current_let_rule_package
     デフォルト値: ‘default_let_rule_package’

     ‘current_let_rule_package’は、 もし他のルールパッケージが指定されな
     いなら、 (‘letsimp’など)‘let’パッケージの関数で使われる ルールパッ
     ケージの名前です。 この変数は、‘let’コマンドを介して定義された任意
     の規格パッケージの名前を 割り当てられます。

     もし ‘letsimp (expr, rule_pkg_name)’のようなコールがされたら、 ルー
     ルパッケージ‘rule_pkg_name’は その関数コールだけのために使われ、
     ‘current_let_rule_package’の値は変わりません。

 -- オプション変数: default_let_rule_package
     デフォルト値: ‘default_let_rule_package’

     ‘default_let_rule_package’は、 ‘let’でユーザーによって、 また、
     ‘current_let_rule_package’の値を変更することによって、 陽に設定され
     ない時使われる ルールルールの名前です。

 -- 関数: defmatch (<progname>, <pattern>, <x_1>, …, <x_n>)
 -- 関数: defmatch (<progname>, <pattern>)

     <pattern>にマッチするか見るために <expr>をテストする 関数
     ‘<progname>(<expr>, <x_1>, ..., <x_n>)’ を定義します。

     <pattern>は、 (引数として与えられているなら) パターン引数 <x_1>,
     ..., <x_n>を含む式です。 パターン引数は ‘defmatch’の引数として明示
     的に与えます。 一方、‘matchdeclare’関数がパターン変数を宣言します。
     ‘matchdeclare’のパターン変数か ‘defmatch’のパターン引数として宣言さ
     れていない 任意の変数はそれ自身とのみマッチします。

     生成関数<progname>の最初の引数はパターンに対してマッチされる式であ
     り、 他の引数は、パターンの中のダミー変数<x_1>, ..., <x_n>に対応す
     る 実際の引数です。

     もしマッチが成功したなら、 <progname>は、 左辺がパターン引数やパタ
     ーン変数で、右辺がパターン引数や変数がマッチした部分式の 等式のリス
     トを返します。 パターン変数はそれらがマッチした部分式に割り当てられ
     ますが、 パターン引数には割り当てられません。 もしマッチが失敗した
     ら、 <progname>は ‘false’を返します。

     リテラルパターン(すなわち、パターン引数もパターン変数も含まないパタ
     ーン)は、 もしマッチが成功したら、 ‘true’を返します。

     ‘matchdeclare’, ‘defrule’, ‘tellsimp’, ‘tellsimpafter’も 参照してく
     ださい。

     例:

     ‘a’と‘b’は‘x’を含まず、 ‘a’が非ゼロであるような 形式‘a*x + b’かどう
     か見るために ‘expr’をテストする 関数‘linearp(expr, x)’を定義します
     。 パターン引数‘x’が‘defmatch’に与えられているので、 このマッチ関数
     は、 任意の変数に関する線形式にマッチします。

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b, x);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2, z);
                                   2
          (%o3)              [b = y , a = y + 4, x = z]
          (%i4) a;
          (%o4)                         y + 4
          (%i5) b;
                                          2
          (%o5)                          y
          (%i6) x;
          (%o6)                           x

     ‘a’と‘b’は‘x’を含まず、 ‘a’が非ゼロであるような 形式‘a*x + b’かどう
     か見るために ‘expr’をテストする 関数‘linearp(expr, x)’を定義します
     。 ‘defmatch’にパターン引数が与えられていないので、 このマッチ関数
     は、 他の任意の変数ではなく変数‘x’に関する線形式にマッチします。

          (%i1) matchdeclare (a, lambda ([e], e#0 and freeof(x, e)), b,
                              freeof(x));
          (%o1)                         done
          (%i2) defmatch (linearp, a*x + b);
          (%o2)                        linearp
          (%i3) linearp (3*z + (y + 1)*z + y^2);
          (%o3)                         false
          (%i4) linearp (3*x + (y + 1)*x + y^2);
                                       2
          (%o4)                  [b = y , a = y + 4]

     定積分かどうか見るために ‘expr’をテストする 関数
     ‘checklimits(expr)’を定義します。

          (%i1) matchdeclare ([a, f], true);
          (%o1)                         done
          (%i2) constinterval (l, h) := constantp (h - l);
          (%o2)        constinterval(l, h) := constantp(h - l)
          (%i3) matchdeclare (b, constinterval (a));
          (%o3)                         done
          (%i4) matchdeclare (x, atom);
          (%o4)                         done
          (%i5) simp : false;
          (%o5)                         false
          (%i6) defmatch (checklimits, 'integrate (f, x, a, b));
          (%o6)                      checklimits
          (%i7) simp : true;
          (%o7)                         true
          (%i8) 'integrate (sin(t), t, %pi + x, 2*%pi + x);
                                 x + 2 %pi
                                /
                                [
          (%o8)                 I          sin(t) dt
                                ]
                                /
                                 x + %pi
          (%i9) checklimits (%);
          (%o9)    [b = x + 2 %pi, a = x + %pi, x = t, f = sin(t)]

 -- 関数: defrule (<rulename>, <pattern>, <replacement>)

     与えられたパターンに関する置き換えルールを定義し、名付けます。 もし
     <rulename>と名付けられたルールが (‘apply1’, ‘applyb1’, ‘apply2’によ
     って) 式に適用されるなら、 パターンにマッチするすべての部分式は
     replacementで置き換えられます。 パターンマッチが値を割り当てる
     replacementの中の変数すべては その後整理される置き換えの中のそれら
     の値を割り当てられます。

     ルールそれ自身は、 パターンマッチと置き換えの１演算で式を変換する 関
     数として扱うことができます。 マッチが失敗したら、ルール関数は
     ‘false’を返します。

 -- 関数: disprule (<rulename_1>, ..., <rulename_2>)
 -- 関数: disprule (all)

     ‘defrule’, ‘tellsimp’, ‘tellsimpafter’が返すような、または
     ‘defmatch’が定義するパターンのような、 名前<rulename_1>, ...,
     <rulename_n>を持つルールを 表示します。 ルールそれぞれは中間式ラベ
     ル(‘%t’)と一緒に表示されます。

     ‘disprule (all)’は、ルールすべてを表示します。

     ‘disprule’は引数をクォートします。 ‘disprule’は、 表示されたルール
     に対応する中間式ラベルのリストを返します。

     ‘let’が定義したルールを表示する ‘letrules’も参照してください。

     例:

          (%i1) tellsimpafter (foo (x, y), bar (x) + baz (y));
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (x + y, special_add (x, y));
          (%o2)                   [+rule1, simplus]
          (%i3) defmatch (quux, mumble (x));
          (%o3)                         quux
          (%i4) disprule (foorule1, "+rule1", quux);
          (%t4)        foorule1 : foo(x, y) -> baz(y) + bar(x)

          (%t5)          +rule1 : y + x -> special_add(x, y)

          (%t6)                quux : mumble(x) -> []

          (%o6)                    [%t4, %t5, %t6]
          (%i6) ''%;
          (%o6) [foorule1 : foo(x, y) -> baz(y) + bar(x),
               +rule1 : y + x -> special_add(x, y), quux : mumble(x) -> []]

 -- 関数: let (<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>)
 -- 関数: let ([<prod>, <repl>, <predname>, <arg_1>, ..., <arg_n>],
          <package_name>)

     <prod>は<repl>で置き換えられるような ‘letsimp’のための代入ルールを
     定義します。 <prod>は、以下の項の正または負のべきの積です:

        • ‘letsimp’をコールする以前に‘matchdeclare’関数が 述語論理をアト
          ムと関連づけるために使われないなら、 ‘letsimp’が文字通りに検索
          するアトム。 この場合、‘letsimp’はアトムを述語論理を満たす積の
          任意の項にマッチさせます。
        • ‘sin(x)’, ‘n!’, ‘f(x,y)’などのようなカーネル。 上のアトムと同
          様に、 述語論理をカーネルの引数に関連づけるために
          ‘matchdeclare’が使われないなら ‘letsimp’は文字通りのマッチを検
          索します。

     正のべきの項は、少なくともそのべきを持つ項だけにマッチするでしょう
     。 一方、負のべきの項は、少なくとも負としてのべきをもつ項だけにマッ
     チするでしょう。 <prod>の中の負のべきの場合、 スイッチ‘letrat’を
     ‘true’に設定しなければいけません。 ‘letrat’も参照してください。

     もし述語論理が 引数のリストが続く‘let’関数に含まれるなら、
     <arg_i’>が<arg_i>にマッチした値である場合、 ‘predname (arg_1', ...,
     arg_n')’が‘true’に評価される時だけ 試験的なマッチ(すなわち、述語論
     理が省略されたなら受け入れられるもの) が受け入れられます。 <arg_i>は
     、任意のアトム名や <prod>の中に現れる任意の核の引数を取り得ます。
     <repl>は、任意の有理式を取り得ます。 もし 任意のアトムや<prod>から
     の引数が<repl>の中に現れるなら、 適切な代入が行われます。

     グローバルフラグ‘letrat’は、 ‘letsimp’による商の整理を制御します。
     ‘letrat’が‘false’の時、 ‘letsimp’は、 <expr>の分子と分母をそれぞれ
     整理し、章を整理はしません。 ‘n!/n’のような代入は‘(n-1)!’に進み失敗
     します。 ‘letrat’が‘true’の時、 分子、分母、商がその順番で整理され
     ます。

     これらの代入関数は、同時にいくつかのルールパッケージを使うことを許
     します。 ルールパッケージそれぞれは、 任意の数の‘let’ルールを含むこ
     とができ、ユーザー定義名で参照されます。 コマンド‘let ([<prod>,
     <repl>, <predname>, <arg_1>, ..., <arg_n>], <package_name>)’は、 ル
     ール<predname>をルールパッケージ<package_name>に加えます。 コマンド
     ‘letsimp (<expr>, <package_name>)’ は、 <package_name>の中でルール
     を適用します。 ‘letsimp (<expr>, <package_name1>, <package_name2>,
     ...)’は、 ‘letsimp (%, <package_name2>)’, …が続く ‘letsimp (<expr>,
     <package_name1>)’と同値です。

     ‘current_let_rule_package’は、 現在使われているルールパッケージの名
     前です。 この変数は、 ‘let’コマンドを介して定義された任意のルールパ
     ッケージの名前に割れ当てられます。 ‘let’パッケージを構成する関数の
     いずれかがパッケージ名なしでコールされた時はいつでも
     ‘current_let_rule_package’が指定したパッケージが使われます。 もし
     ‘letsimp (<expr>, <rule_pkg_name>)’のようなコールがされたら、 ルー
     ルパッケージ<rule_pkg_name>は、 その‘letsimp’コマンドだけで使われ、
     ‘current_let_rule_package’は変わりません。 もし他に指定されないなら
     、 ‘current_let_rule_package’は‘default_let_rule_package’をデフォル
     ト値とします。

          (%i1) matchdeclare ([a, a1, a2], true)$
          (%i2) oneless (x, y) := is (x = y-1)$
          (%i3) let (a1*a2!, a1!, oneless, a2, a1);
          (%o3)         a1 a2! --> a1! where oneless(a2, a1)
          (%i4) letrat: true$
          (%i5) let (a1!/a1, (a1-1)!);
                                  a1!
          (%o5)                   --- --> (a1 - 1)!
                                  a1
          (%i6) letsimp (n*m!*(n-1)!/m);
          (%o6)                      (m - 1)! n!
          (%i7) let (sin(a)^2, 1 - cos(a)^2);
                                  2               2
          (%o7)                sin (a) --> 1 - cos (a)
          (%i8) letsimp (sin(x)^4);
                                  4           2
          (%o8)                cos (x) - 2 cos (x) + 1

 -- オプション変数: letrat
     デフォルト値: ‘false’

     ‘letrat’が‘false’の時、 ‘letsimp’は 比の分子と分母それぞれを整理し
     、 商を整理しません。

     ‘letrat’が‘true’の時、 分子、分母、商はその順番に整理されます。

          (%i1) matchdeclare (n, true)$
          (%i2) let (n!/n, (n-1)!);
                                   n!
          (%o2)                    -- --> (n - 1)!
                                   n
          (%i3) letrat: false$
          (%i4) letsimp (a!/a);
                                         a!
          (%o4)                          --
                                         a
          (%i5) letrat: true$
          (%i6) letsimp (a!/a);
          (%o6)                       (a - 1)!

 -- 関数: letrules ()
 -- 関数: letrules (<package_name>)

     ルールパッケージのルールを表示します。 ‘letrules ()’は現在のルール
     パッケージのルールを表示します。 ‘letrules (<package_name>)’は
     <package_name>のルールを表示します。

     現在のルールパッケージは ‘current_let_rule_package’によって指名され
     ます。 もし他に指定されないなら、 ‘current_let_rule_package’は
     ‘default_let_rule_package’がデフォルト値になります。

     ‘disprule’も参照してください それは、 ‘tellsimp’と‘tellsimpafter’が
     定義するルールを表示します。

 -- 関数: letsimp (<expr>)
 -- 関数: letsimp (<expr>, <package_name>)
 -- 関数: letsimp (<expr>, <package_name_1>, …, <package_name_n>)

     <expr>に変化がなくなるまで 繰り返し、‘let’が定義する代入ルールを適
     用します。

     ‘letsimp (<expr>)’は ‘current_let_rule_package’からルールを使います
     。

     ‘letsimp (<expr>, <package_name>)’は、 ‘current_let_rule_package’を
     変えることなしに <package_name>からルールを使います。

     ‘letsimp (<expr>, <package_name_1>, ..., <package_name_n>)’は、
     quivalent to ‘letsimp (%, <package_name_2>)’などが続く ‘letsimp
     (<expr>, <package_name_1>’と同値です。

 -- オプション変数: let_rule_packages
     デフォルト値: ‘[default_let_rule_package]’

     ‘let_rule_packages’は、 デフォルトパッケージ
     ‘default_let_rule_package’に加える ユーザー定義のletルールパッケー
     ジすべてのリストです。

 -- 関数: matchdeclare (<a_1>, <pred_1>, ..., <a_n>, <pred_n>)

     述語論理 <pred_k>を変数 <a_k>の変数やリストに関連づけます。 なので
     、 <a_k>は述語論理が ‘false’以外の何かを返す式にマッチします。

     述語論理は関数の名前、ラムダ式、関数コール、最後の引数のないラムダ
     コール、 ‘true’または ‘all’です。 任意の式が ‘true’や ‘all’にマッチ
     します。 もし述語論理が関数コールかラムダコールとして指定されるなら
     、 テストされる式が引数のリストに追加されます; マッチが評価される時
     引数が評価されます。 そうでないなら、述語論理は関数名またはラムダ式
     として指定され、 テストされる式が唯一の引数です。 ‘matchdeclare’が
     コールされた時、述語論理関数は定義されている必要はありません; 述語
     論理はマッチが試みられるまで評価されません。

     述語論理は、 ‘true’か ‘false’はもちろん、ブーリアン式を返すかもしれ
     ません。 ブーリアン式は、構成されたルール関数内で ‘is’によって評価
     されるので、 述語論理内部で ‘is’をコールする必要はありません。

     もし式がマッチ述語論理を満たすなら、 マッチ変数が式に割り当てられま
     す。 例外は足し算 ‘+’や掛け算 ‘*’のオペランドのマッチ変数です。 足
     し算と掛け算だけは特別に扱われます; 他のn項演算子(組み込みもユーザ
     ー定義も)は通常の関数のように扱われます。

     足し算と掛け算の場合、 マッチ変数はマッチ述語論理を満たす唯一の式か
     、 そんな式の(それぞれ)和または積に割り当てられます。 そんな多項マ
     ッチングはどん欲(greedy)です: 述語論理群はそれらの関連変数がマッチ
     パターンの中で現れる順に評価され、 複数の述語論理を満たす項は、それ
     が満たす最初の述語論理によってマッチされます。 述語論理それぞれは、
     次の述語論理が評価される前に 和や積のオペランドすべてに対してテスト
     されます。 加えて、 もし(それぞれ)0か1がマッチ述語論理を満たし、か
     つ、 述語論理を満たす他の項がないなら、 0か1が述語論理の関連マッチ
     変数に割り当てられます。

     足し算と掛け算パターンを処理するアルゴリズムは、 (例えば、「任意の
     ものにマッチする」変数が現れるパターンのように) マッチパターンの中
     やマッチされる式の中の項の順序付けに依存したいくつかのマッチ結果を
     もたらします。 しかしながら、もしマッチ述語論理すべてが相互に排他的
     なら、 １つのマッチ述語論理はべつのものがマッチした項を受け入れられ
     ないので、 マッチ結果は順序付けに影響されません。

     変数 <a>を引数として ‘matchdeclare’をコールすると、 もし既に宣言さ
     れているなら、 <a>に関する ‘matchdeclare’プロパティが変わります: ル
     ールが定義された時、直近の ‘matchdeclare’だけが効果を持ちます。
     (‘matchdeclare’か ‘remove’を介した) ‘matchdeclare’プロパティへの後
     の変更は、存在するルールに影響しません。

     ‘propvars (matchdeclare)’は ‘matchdeclare’プロパティを持つ変数すべ
     てのリストを返します。 ‘printprops (<a>, matchdeclare)’は、 変数
     ‘a’に関する述語論理を返します。 ‘printprops (all, matchdeclare)’は
     、 すべての ‘matchdeclare’変数に関する述語論理のリストを返します。
     ‘remove (<a>, matchdeclare)’は、 <a>から ‘matchdeclare’プロパティを
     削除します。

     関数 ‘defmatch’, ‘defrule’, ‘tellsimp’, ‘tellsimpafter’, ‘let’は、
     パターンに対して式をテストするルールを構成します。

     ‘matchdeclare’は引数をクォートします。 ‘matchdeclare’はいつも
     ‘done’を返します。

     例:

     述語論理は、関数名か、ラムダ式か、最後の引数がない関数コールかラム
     ダコールか、 ‘true’か ‘all’です。

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) matchdeclare (bb, lambda ([x], x > 0));
          (%o2)                         done
          (%i3) matchdeclare (cc, freeof (%e, %pi, %i));
          (%o3)                         done
          (%i4) matchdeclare (dd, lambda ([x, y], gcd (x, y) = 1) (1728));
          (%o4)                         done
          (%i5) matchdeclare (ee, true);
          (%o5)                         done
          (%i6) matchdeclare (ff, all);
          (%o6)                         done

     もし式がマッチ述語論理を満たすなら、 マッチ変数は式に割り当てられま
     す。

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) defrule (r1, bb^aa, ["integer" = aa, "atom" = bb]);
                              aa
          (%o2)        r1 : bb   -> [integer = aa, atom = bb]
          (%i3) r1 (%pi^8);
          (%o3)               [integer = 8, atom = %pi]

     足し算と掛け算の場合、 マッチ変数は、マッチ述語論理を満たす１つの式
     か、 そんな式の(それぞれ)和か積に割り当てられるかもしれません。

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + sin(x));
          (%o3)     [all atoms = 8, all nonatoms = sin(x) + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * sin(x));
          (%o5)    [all atoms = 8, all nonatoms = (b + a) sin(x)]

     ‘+’と ‘*’の引数をマッチする時、 もしマッチ述語論理すべてが相互に排
     他的なら、 １つのマッチ述語論理は別のものがマッチした項を受け入れら
     れないので、 マッチ結果は順序付けに影響されません。

          (%i1) matchdeclare (aa, atom, bb, lambda ([x], not atom(x)));
          (%o1)                         done
          (%i2) defrule (r1, aa + bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb + aa partitions `sum'
          (%o2)  r1 : bb + aa -> [all atoms = aa, all nonatoms = bb]
          (%i3) r1 (8 + a*b + %pi + sin(x) - c + 2^n);
                                                               n
          (%o3) [all atoms = %pi + 8, all nonatoms = sin(x) + 2  - c + a b]
          (%i4) defrule (r2, aa * bb, ["all atoms" = aa, "all nonatoms" =
                         bb]);
          bb aa partitions `product'
          (%o4)   r2 : aa bb -> [all atoms = aa, all nonatoms = bb]
          (%i5) r2 (8 * (a + b) * %pi * sin(x) / c * 2^n);
                                                            n
                                                   (b + a) 2  sin(x)
          (%o5) [all atoms = 8 %pi, all nonatoms = -----------------]
                                                           c

     関数 ‘propvars’と ‘printprops’はマッチ変数についての情報を返します
     。

          (%i1) matchdeclare ([aa, bb, cc], atom, [dd, ee], integerp);
          (%o1)                         done
          (%i2) matchdeclare (ff, floatnump, gg, lambda ([x], x > 100));
          (%o2)                         done
          (%i3) propvars (matchdeclare);
          (%o3)             [aa, bb, cc, dd, ee, ff, gg]
          (%i4) printprops (ee, matchdeclare);
          (%o4)                    [integerp(ee)]
          (%i5) printprops (gg, matchdeclare);
          (%o5)              [lambda([x], x > 100, gg)]
          (%i6) printprops (all, matchdeclare);
          (%o6) [lambda([x], x > 100, gg), floatnump(ff), integerp(ee),
                                integerp(dd), atom(cc), atom(bb), atom(aa)]

 -- オプション変数: maxapplydepth
     デフォルト値: 10000

     ‘maxapplydepth’は ‘apply1’と ‘apply2’が探索する 最大深さです。

 -- オプション変数: maxapplyheight
     デフォルト値: 10000

     ‘maxapplyheight’は ‘applyb1’があきらめる前に到達する 最大高さです。

 -- 関数: remlet (<prod>, <name>)
 -- 関数: remlet ()
 -- 関数: remlet (all)
 -- 関数: remlet (all, <name>)

     ‘let’関数で直近に定義された 代入ルール<prod> –> replを削除します。
     もし名前が供給されるなら、ルールはルールパッケージ名から削除されま
     す。

     ‘remlet()’や‘remlet(all)’は 現在のルールパッケージから代入ルールす
     べてを削除します。 もし例えば、‘remlet (all, <name>)’にように、ルー
     ルパッケージ名が供給されるなら、 ルールパッケージ<name>も削除されま
     す。

     もし代入が同じ積を使って変更されるなら、 ‘remlet’はコールされる必要
     はなく、 ‘let’関数と新しい置き換え かつ/または述語論理名で、文字通
     りに同じ積を使って代入を再定義だけです。 さて、‘remlet (<prod>)’が
     コールされると、 元の代入ルールが生き返ります。

     ‘remrule’も参照してください。 ‘tellsimp’や‘tellsimpafter’で定義され
     たルールを削除します。

 -- 関数: remrule (<op>, <rulename>)
 -- 関数: remrule (<op>, all)

     ‘tellsimp’や‘tellsimpafter’で定義されたルールを削除します。

     ‘remrule (<op>, <rulename>)’は、 演算子<op>から 名前<rulename>を持
     つ ルールを削除します。 <op>が組み込みか (‘infix’, ‘prefix’, などで
     定義されたような)ユーザー定義演算子の時、 <op>と<rulename>はダブル
     クォートマークでくくられないといけません。

     ‘remrule (<op>, all)’は 演算子<op>に関するルールすべてを削除します
     。

     ‘remlet’も参照してください。 ‘let’で定義されたルールを削除します。

     例:

          (%i1) tellsimp (foo (aa, bb), bb - aa);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (aa + bb, special_add (aa, bb));
          (%o2)                   [+rule1, simplus]
          (%i3) infix ("@@");
          (%o3)                          @@
          (%i4) tellsimp (aa @@ bb, bb/aa);
          (%o4)                   [@@rule1, false]
          (%i5) tellsimpafter (quux (%pi, %e), %pi - %e);
          (%o5)                  [quuxrule1, false]
          (%i6) tellsimpafter (quux (%e, %pi), %pi + %e);
          (%o6)             [quuxrule2, quuxrule1, false]
          (%i7) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                 quux (%e, %pi)];
                                               bb
          (%o7) [bb - aa, special_add(aa, bb), --, %pi - %e, %pi + %e]
                                               aa
          (%i8) remrule (foo, foorule1);
          (%o8)                          foo
          (%i9) remrule ("+", ?\+rule1);
          (%o9)                           +
          (%i10) remrule ("@@", ?\@\@rule1);
          (%o10)                         @@
          (%i11) remrule (quux, all);
          (%o11)                        quux
          (%i12) [foo (aa, bb), aa + bb, aa @@ bb, quux (%pi, %e),
                  quux (%e, %pi)];
          (%o12) [foo(aa, bb), bb + aa, aa @@ bb, quux(%pi, %e),
                                                   quux(%e, %pi)]

 -- 関数: tellsimp (<pattern>, <replacement>)

     ‘tellsimpafter’に似ていますが、 古いものの前に新しい情報を置くので
     、 組み込み整理ルールの前に適用されます。

     整理器が働く前に式を変更することが重要な時 例えば、整理器が式につい
     て何か「知っている」が、それが返すものが好みでないなら、
     ‘tellsimp’が使われます。 もし整理器が式の主演算子について何かを「知
     っている」が、単に十分でないなら、 たぶん‘tellsimpafter’を使いたい
     でしょう。

     パターンは和、積、変数１つ、または、数は取れません。

     システム変数‘rules’は、 ‘defrule’, ‘defmatch’, ‘tellsimp’,
     ‘tellsimpafter’で 定義されたルールのリストです。

     例:

          (%i1) matchdeclare (x, freeof (%i));
          (%o1)                         done
          (%i2) %iargs: false$
          (%i3) tellsimp (sin(%i*x), %i*sinh(x));
          (%o3)                 [sinrule1, simp-%sin]
          (%i4) trigexpand (sin (%i*y + x));
          (%o4)         sin(x) cos(%i y) + %i cos(x) sinh(y)
          (%i5) %iargs:true$
          (%i6) errcatch(0^0);
           0
          0  has been generated
          (%o6)                          []
          (%i7) ev (tellsimp (0^0, 1), simp: false);
          (%o7)                  [^rule1, simpexpt]
          (%i8) 0^0;
          (%o8)                           1
          (%i9) remrule ("^", %th(2)[1]);
          (%o9)                           ^
          (%i10) tellsimp (sin(x)^2, 1 - cos(x)^2);
          (%o10)                 [^rule2, simpexpt]
          (%i11) (1 + sin(x))^2;
                                                2
          (%o11)                    (sin(x) + 1)
          (%i12) expand (%);
                                             2
          (%o12)               2 sin(x) - cos (x) + 2
          (%i13) sin(x)^2;
                                            2
          (%o13)                     1 - cos (x)
          (%i14) kill (rules);
          (%o14)                        done
          (%i15) matchdeclare (a, true);
          (%o15)                        done
          (%i16) tellsimp (sin(a)^2, 1 - cos(a)^2);
          (%o16)                 [^rule3, simpexpt]
          (%i17) sin(y)^2;
                                            2
          (%o17)                     1 - cos (y)

 -- 関数: tellsimpafter (<pattern>, <replacement>)

     組み込み整理ルールの後、適Maxima整理器が適用する 整理ルールを定義し
     ます。 <pattern>は (‘matchdeclare’で宣言された) パターン変数や他の
     アトムや演算子から成る、 パターンマッチングの目的でリテラルと考えら
     れる式です。 <replacement>は、 <pattern>にマッチする実際の式に代入
     されます; <replacement>の中のパターン変数は 実際の式の中でマッチし
     た値に割り当てられます。

     <pattern>は、 主演算子がパターン変数でない任意の非アトム式を取り得
     ます; 整理ルールは主演算子に関連付けられます。 (以下で記述する１つ
     の例外がありますが、)関数、リスト、配列の名前が、 (パターン変数でな
     く)ただリテラルとして、 主演算子として<pattern>の中で現れることがで
     きます; これは、 パターンとして もし‘aa’や‘bb’がパターン変数なら
     ‘aa(x)’や‘bb[y]’のような式を除外します。 パターン変数である関数、リ
     スト、配列の名前は、 <pattern>の中で、主演算子以外の演算子として現
     れることができます。

     上の関数名に関するルールに１つ例外があります。 ‘aa[x](y)’のような式
     の中の添字付き関数の名前は 主演算子が‘aa’でなくLispアトム
     ‘mqapply’だから、 パターン変数にできます。 これは、添字付き関数を含
     む式の表現の結果です。

     (もしクォートやフラグ‘noeval’を通して抑制されないなら) 整理ルールは
     、 評価の後、適用されます。 ‘tellsimpafter’で確立されたルールは、 組
     み込みルールの後、それらが定義された順に適用されます。 ルールはボト
     ムアップに適用されます。すなわち、 式全体への適用の前に、最初、部分
     式に適用されます。 ルールすべてが適用されることを保証するために、
     (例えば、クォートクォート演算子‘''’やフラグ‘infeval’を介して) 結果
     を繰り返し整理する必要があるかもしれません。

     パターン変数は、整理ルールの中でローカル変数として扱われます。 一旦
     ルールが定義されると、パターン変数の値は、 ルールに影響せず、ルール
     によって影響されません。 成功したルールマッチの結果となるパターン変
     数への割り当ては、 パターン変数の現在の割り当て(またはその欠落)に影
     響しません。 しかしながら、Maximaの中のアトムすべてで、 (‘put’や関
     連関数で定義された)パターン変数のプロパティはグローバルです。

     ‘tellsimpafter’によって構成されたルールは、 <pattern>の主演算子に由
     来します。 組み込み演算子や ‘infix’, ‘prefix’, ‘postfix’,
     ‘matchfix’, ‘nofix’で 定義されたユーザー定義演算子に関するルールは
     、 Lisp識別子である名前を持ちます。 他の関数に関するルールは、
     Maxima識別子である名前を持ちます。

     名詞と動詞形の扱いは少し混乱しています。 もしルールが名詞(または動
     詞)形に関して定義されて、 対応する動詞(または名詞)形に関するルール
     が既に存在しているなら、 新しく定義されたルールは両方の形式(名詞と
     動詞)に適用されます。 もし対応する動詞(名詞)形に関するルールが存在
     しないなら、 新しく定義されたルールは名詞(または動詞)形にだけ適用さ
     れます。

     ‘tellsimpafter’で構成されたルールは通常のLisp関数です。 もしルール
     名が‘$foorule1’なら、 構成子‘:lisp (trace $foorule1)’は関数をトレー
     スし、 ‘:lisp (symbol-function '$foorule1)’は定義を表示します。

     ‘tellsimpafter’は引数をクォートします。 ‘tellsimpafter’は 新しく確
     立されたルールを含む、 <pattern>の主演算子に関する ルールのリストを
     返します。

     ‘matchdeclare’, ‘defmatch’, ‘defrule’, ‘tellsimp’, ‘let’, ‘kill’,
     ‘remrule’, ‘clear_rules’も参照してください。

     例:

     <pattern>は、 主演算子がパターン変数でない任意の非アトム式を取り得
     ます。

          (%i1) matchdeclare (aa, atom, [ll, mm], listp, xx, true)$
          (%i2) tellsimpafter (sin (ll), map (sin, ll));
          (%o2)                 [sinrule1, simp-%sin]
          (%i3) sin ([1/6, 1/4, 1/3, 1/2, 1]*%pi);
                              1  sqrt(2)  sqrt(3)
          (%o3)              [-, -------, -------, 1, 0]
                              2     2        2
          (%i4) tellsimpafter (ll^mm, map ("^", ll, mm));
          (%o4)                  [^rule1, simpexpt]
          (%i5) [a, b, c]^[1, 2, 3];
                                          2   3
          (%o5)                      [a, b , c ]
          (%i6) tellsimpafter (foo (aa (xx)), aa (foo (xx)));
          (%o6)                   [foorule1, false]
          (%i7) foo (bar (u - v));
          (%o7)                    bar(foo(u - v))

     ルールはそれらが定義された順に適用されます。 もし２つのルールが式に
     マッチできるなら、 最初に定義されたルールが適用されます。

          (%i1) matchdeclare (aa, integerp);
          (%o1)                         done
          (%i2) tellsimpafter (foo (aa), bar_1 (aa));
          (%o2)                   [foorule1, false]
          (%i3) tellsimpafter (foo (aa), bar_2 (aa));
          (%o3)              [foorule2, foorule1, false]
          (%i4) foo (42);
          (%o4)                       bar_1(42)

     整理ルールの中で、パターン変数はローカル変数として扱われます。
     (‘defmatch’と比較してください。 パターン変数をグローバル変数として
     扱います。)

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) bb: 12345;
          (%o3)                         12345
          (%i4) foo (42, %e);
          (%o4)                 bar(aa = 42, bb = %e)
          (%i5) bb;
          (%o5)                         12345

     アトムすべてには、 パターン変数のプロパティは、たとえ値がローカルで
     も、 グローバルです。 この例では、割り当てプロパティは
     ‘define_variable’を介して宣言されます。 Maximaの至る所で、これはア
     トム‘bb’のプロパティです。

          (%i1) matchdeclare (aa, integerp, bb, atom);
          (%o1)                         done
          (%i2) tellsimpafter (foo(aa, bb), bar('aa=aa, 'bb=bb));
          (%o2)                   [foorule1, false]
          (%i3) foo (42, %e);
          (%o3)                 bar(aa = 42, bb = %e)
          (%i4) define_variable (bb, true, boolean);
          (%o4)                         true
          (%i5) foo (42, %e);
          Error: bb was declared mode boolean, has value: %e
           -- an error.  Quitting.  To debug this try debugmode(true);

     ルールは主演算子に由来します。 組み込みやユーザー定義の演算子に関す
     るルール名はLisp識別子で、 一方、他の関数に関する名前はMaxima識別子
     です。

          (%i1) tellsimpafter (foo (%pi + %e), 3*%pi);
          (%o1)                   [foorule1, false]
          (%i2) tellsimpafter (foo (%pi * %e), 17*%e);
          (%o2)              [foorule2, foorule1, false]
          (%i3) tellsimpafter (foo (%i ^ %e), -42*%i);
          (%o3)         [foorule3, foorule2, foorule1, false]
          (%i4) tellsimpafter (foo (9) + foo (13), quux (22));
          (%o4)                   [+rule1, simplus]
          (%i5) tellsimpafter (foo (9) * foo (13), blurf (22));
          (%o5)                  [*rule1, simptimes]
          (%i6) tellsimpafter (foo (9) ^ foo (13), mumble (22));
          (%o6)                  [^rule1, simpexpt]
          (%i7) rules;
          (%o7) [foorule1, foorule2, foorule3, +rule1, *rule1, ^rule1]
          (%i8) foorule_name: first (%o1);
          (%o8)                       foorule1
          (%i9) plusrule_name: first (%o4);
          (%o9)                        +rule1
          (%i10) remrule (foo, foorule1);
          (%o10)                         foo
          (%i11) remrule ("^", ?\^rule1);
          (%o11)                          ^
          (%i12) rules;
          (%o12)        [foorule2, foorule3, +rule1, *rule1]

     加工された例: 反可換乗算。

          (%i1) gt (i, j) := integerp(j) and i < j;
          (%o1)           gt(i, j) := integerp(j) and i < j
          (%i2) matchdeclare (i, integerp, j, gt(i));
          (%o2)                         done
          (%i3) tellsimpafter (s[i]^^2, 1);
          (%o3)                 [^^rule1, simpncexpt]
          (%i4) tellsimpafter (s[i] . s[j], -s[j] . s[i]);
          (%o4)                   [.rule1, simpnct]
          (%i5) s[1] . (s[1] + s[2]);
          (%o5)                    s  . (s  + s )
                                    1     2    1
          (%i6) expand (%);
          (%o6)                      1 - s  . s
                                          2    1
          (%i7) factor (expand (sum (s[i], i, 0, 9)^^5));
          (%o7) 100 (s  + s  + s  + s  + s  + s  + s  + s  + s  + s )
                      9    8    7    6    5    4    3    2    1    0

 -- 関数: clear_rules ()

     ‘kill (rules)’を実行し、 足し算‘+’, 掛け算‘*’, べき‘^’に関して 次の
     ルール番号を1に再設定します。

