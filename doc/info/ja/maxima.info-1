This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.

This is a Texinfo Maxima Manual

   Copyright 1994,2001 William F. Schelter

INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* Maxima: (maxima).     A computer algebra system.
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Top,  Next: Introduction to Maxima,  Prev: (dir),  Up: (dir)

Maxima 5.46.0 Manual
********************

Maximaはコンピュータ代数システムです。Lispで実装されています。

   MaximaはMacsymaシステムから派生したものです。 Macsymaシステムは、
MITで1968年から1982年にかけてプロジェクトMACの一部として開発されました。
MITは、1982年にMacsymaソースコードのコピーをエネルギー省に引き渡しました
; そのバージョンは現在、DOE Macsymaとして知られています。 DOE Macsymaの
コピーは、テキサス大学のWilliam F. Schelter教授によって、 1982年から教授
がなくなる2001年まで保守されました。 1998年にSchelterは、 エネルギー省か
らDOE MacsymaソースコードをGNU Public Licenseの下で公開する許可を得て、
2000年に彼は、 DOE Macsymaを保守・開発するために、Maximaプロジェクトを
SourceForgeで始めました。 だから、Maximaと呼ばれています。

* Menu:

Maximaの基盤

* Introduction to Maxima::      Maximaセッションの実例
* Bug Detection and Reporting:: Maximaのバグの発見と報告
* Help::                        Maximaセッションの中でヘルプを見る
* Command Line::                Maximaコマンドライン構文法、入出力
* Data Types and Structures::   数、文字列、リスト、配列、構造体
* Expressions::                 Maximaにおける式
* Operators::                   Maxima式の中で使われる演算子
* Evaluation::                  式の評価
* Simplification::              式の整理
* Mathematical Functions::      Maximaの数学的関数
* Maximas Database::            宣言、文脈、事実、プロパティ
* Plotting::                    2次元と3次元のグラフィカル出力
* File Input and Output::       ファイル入出力

数学の特定分野のサポート

* Polynomials::                 多項式の標準形と操作関数
* Special Functions::           特殊函数
* Elliptic Functions::          楕円函数と楕円積分
* Limits::                      式の極限
* Differentiation::             微分法
* Integration::                 積分法
* Equations::                   方程式の定義と解法
* Differential Equations::      微分方程式の定義と解法
* Numerical::                   数値積分、Fourier変換など
* Matrices and Linear Algebra:: 行列演算
* Affine::                      
* itensor::                     添字テンソル操作
* ctensor::                     成分テンソル操作
* atensor::                     代数テンソル操作
* Sums Products and Series::    和、積、Tayler級数とべき級数
* Number Theory::               数論
* Symmetries::                  
* Groups::                      抽象代数

上級用機能とプログラミング

* Runtime Environment::         Maxima環境のカスタム化
* Miscellaneous Options::       Maximaでグローバルな効果を持つオプション
* Rules and Patterns::          ユーザー定義のパターンマッチングと整理ルール
* Sets::                        集合の操作
* Function Definition::         関数定義
* Program Flow::                Maximaプログラムの定義
* Debugging::                   Maximaプログラムのデバッグ

その他のパッケージ

* asympa::                      漸近解析パッケージ
* augmented_lagrangian::        拡張Lagrangeパッケージ
* Bernstein::                   ‘Bernstein’多項式
* bode::                        Bode線図
* cobyla::                      不等式制約を持つ非線形最適化
* contrib_ode::                 ODEのための追加ルーチン
* descriptive::                 記述統計
* diag::                        Jordan行列
* distrib::                     確率分布
* draw::                        Maxima-Gnuplotインターフェイス
* drawdf::                      Gnuplotを使った方向場
* dynamics::                    力学系とフラクタルのグラフィックス
* ezunits::                     次元量
* f90::                         MaximaからFortranへの翻訳器
* finance::                     金融パッケージ
* fractals::                    フラクタル
* ggf::                         数列の母函数
* graphs::                      グラフ理論パッケージ
* grobner::                     Groebner基底を扱う関数
* impdiff::                     陰導函数
* implicit_plot::               陰プロットパッケージ
* interpol::                    内挿バッケージ
* lapack::                      線形代数のためのLAPACK関数
* lbfgs::                       L-BFGS無制約最小化パッケージ
* lindstedt::                   Lindstedtパッケージ
* linearalgebra::               線形代数のための関数
* lsquares::                    最小二乗
* makeOrders::                  多項式ユーティリティ
* minpack::                     最小化と根のためのMINPACK関数
* mnewton::                     Newton法
* numericalio::                 ファイルの読み書き
* opsubst::                     代入ユーティリティ
* orthopoly::                   直交多項式
* plotdf::                      方向場プロット
* romberg::                     数値積分のRomberg法
* simplex::                     線形計画
* simplification::              整理のルールと関数
* solve_rec::                   線形漸化式
* stats::                       統計的推定パッケージ
* stirling::                    Stirling公式
* stringproc::                  文字列処理
* to_poly_solve::               ‘to_poly_solve’パッケージ
* unit::                        単位と次元パッケージ
* zeilberger::                  超幾何総和に関する関数


索引

* Function and Variable Index:: インデックス

訳者後書き

* Translator's Comments::       訳者のコメント

 — The Detailed Node Listing —

手引き

* Introduction to Maxima::

バグ

* Bug Detection and Reporting::

ヘルプ

* Documentation::               
* Functions and Variables for Help::        

コマンドライン

* Introduction to Command Line::  
* Functions and Variables for Command Line::  
* Functions and Variables for Display::

データ型と構造体

* Numbers::
* Strings::
* Constants::
* Lists::
* Arrays::
* Structures::

式

* Introduction to Expressions::  
* Nouns and Verbs::
* Identifiers::
* Inequality::                  
* Functions and Variables for Expressions::  

演算子

* Introduction to operators::
* Arithmetic operators::
* Relational operators::
* Logical operators::
* Operators for Equations::
* Assignment operators::
* User defined operators::

評価

* Functions and Variables for Evaluation::

式整理

* Functions and Variables for Simplification::  

数学的関数

* Functions for Numbers::
* Functions for Complex Numbers::
* Combinatorial Functions::
* Root Exponential and Logarithmic Functions::
* Trigonometric Functions::
* Random Numbers::

Maximaのデータベース

* Introduction to Maximas Database::
* Functions and Variables for Properties::
* Functions and Variables for Facts::
* Functions and Variables for Predicates::

プロット

* Introduction to Plotting::
* Plotting Formats::
* Functions and Variables for Plotting::
* Plotting Options::
* Gnuplot Options::
* Gnuplot_pipes Format Functions::

ファイル入出力

* Comments::
* Files::                       
* Functions and Variables for File Input and Output::  

多項式

* Introduction to Polynomials::  
* Functions and Variables for Polynomials::  

特殊函数

* Introduction to Special Functions:: 
* Bessel Functions::
* Airy Functions::
* Gamma and factorial Functions::
* Exponential Integrals::
* Error Function::
* Struve Functions::
* Hypergeometric Functions::
* Parabolic Cylinder Functions::
* Functions and Variables for Special Functions::  

楕円函数

* Introduction to Elliptic Functions and Integrals::
* Functions and Variables for Elliptic Functions::
* Functions and Variables for Elliptic Integrals::

極限

* Functions and Variables for Limits::      

微分

* Functions and Variables for Differentiation::  

積分

* Introduction to Integration::  
* Functions and Variables for Integration::  

方程式

* Functions and Variables for Equations::   

微分方程式

* Introduction to Differential Equations::  
* Functions and Variables for Differential Equations::  

数値

* Introduction to fast Fourier transform::                     
* Functions and Variables for fast Fourier transform::
* Introduction to Fourier series::
* Functions and Variables for Fourier series::

行列と線形代数

* Introduction to Matrices and Linear Algebra::  
* Dot::                         
* Vectors::                     
* eigen::
* Functions and Variables for Matrices and Linear Algebra::  

アフィン

* Introduction to Affine::
* Functions and Variables for Affine::      

指標テンソル

* Introduction to itensor::      
* Functions and Variables for itensor::      

成分テンソル

* Introduction to ctensor::     
* Functions and Variables for ctensor::     

代数テンソル

* Introduction to atensor::     
* Functions and Variables for atensor::     

和、積、級数

* Sums and Products::
* Introduction to Series::
* Functions and Variables for Series::
* Poisson series::

数論

* Functions and Variables for Number Theory::  

対称群

* Introduction to Symmetries::
* Functions and Variables for Symmetries::  

群

* Functions and Variables for Groups::      

ランタイム環境

* Introduction for Runtime Environment::  
* Interrupts::                  
* Functions and Variables for Runtime Environment::  

様々なオプション

* Introduction to Miscellaneous Options::  
* Share::                       
* Functions and Variables for Miscellaneous Options::  

規則とパターン

* Introduction to Rules and Patterns::  
* Functions and Variables for Rules and Patterns::  

集合

* Introduction to Sets::       
* Functions and Variables for Sets::       

関数定義

* Introduction to Function Definition::  
* Function::                    
* Macros::                      
* Functions and Variables for Function Definition::  

プログラムフロー

* Lisp and Maxima::
* Garbage Collection::
* Introduction to Program Flow::  
* Functions and Variables for Program Flow::  

デバッグ

* Functions and Variables for Debugging::   

asympa

* Introduction to asympa::
* Functions and variables for asympa::

augmented_lagrangian

* Functions and Variables for augmented_lagrangian::

Bernstein

* Functions and Variables for Bernstein::

bode

* Functions and Variables for bode::

cobyla

* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::

contrib_ode

* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::

descriptive

* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for statistical graphs::

diag

* Functions and Variables for diag::

distrib

* Introduction to distrib::
* Functions and Variables for continuous distributions::
* Functions and Variables for discrete distributions::

draw

* Introduction to draw::
* Functions and Variables for draw::
* Functions and Variables for pictures::
* Functions and Variables for worldmap::

drawdf

* Introduction to drawdf::
* Functions and Variables for drawdf::

dynamics

* Introduction to dynamics::
* Functions and Variables for dynamics::

ezunits

* Introduction to ezunits::
* Introduction to physical_constants::
* Functions and Variables for ezunits::

f90

* Functions and Variables for f90::

finance

* Introduction to finance::
* Functions and Variables for finance::

fractals

* Introduction to fractals::
* Definitions for IFS fractals::
* Definitions for complex fractals::
* Definitions for Koch snowflakes::
* Definitions for Peano maps::

ggf

* Functions and Variables for ggf::

graphs

* Introduction to graphs::
* Functions and Variables for graphs::

grobner

* Introduction to grobner::
* Functions and Variables for grobner::

impdiff

* Functions and Variables for impdiff::

implicit_plot

* Functions and Variables for implicit_plot::

interpol

* Introduction to interpol::
* Functions and Variables for interpol::

lapack

* Introduction to lapack::
* Functions and Variables for lapack::

lbfgs

* Introduction to lbfgs::
* Functions and Variables for lbfgs::

lindstedt

* Functions and Variables for lindstedt::

linearalgebra

* Introduction to linearalgebra::
* Functions and Variables for linearalgebra::

lsquares

* Introduction to lsquares::
* Functions and Variables for lsquares::

makeOrders

* Functions and Variables for makeOrders::

minpack

* Introduction to minpack::
* Functions and Variables for minpack::

mnewton

* Introduction to mnewton::
* Functions and Variables for mnewton::

numericalio

* Introduction to numericalio::
* Functions and Variables for plain-text input and output::
* Functions and Variables for binary input and output::

opsubst

* Functions and Variables for opsubst::

orthopoly

* Introduction to orthogonal polynomials::
* Functions and Variables for orthogonal polynomials::

plotdf

* Introduction to plotdf::
* Functions and Variables for plotdf::

romberg

* Functions and Variables for romberg::

simplex

* Introduction to simplex::
* Functions and Variables for simplex::

simplification

* Introduction to simplification::
* Package absimp::
* Package facexp::
* Package functs::
* Package ineq::
* Package rducon::
* Package scifac::
* Package sqdnst::

solve_rec

* Introduction to solve_rec::
* Functions and Variables for solve_rec::

stats

* Introduction to stats::
* Functions and Variables for inference_result::
* Functions and Variables for stats::
* Functions and Variables for special distributions::

stirling

* Functions and Variables for stirling::

stringproc

* Introduction to string processing::
* Functions and Variables for input and output::
* Functions and Variables for characters::
* Functions and Variables for strings::

to_poly_solve

* Functions and Variables for to_poly_solve::

unit

* Introduction to Units::       
* Functions and Variables for Units::

zeilberger

* Introduction to zeilberger::
* Functions and Variables for zeilberger::


File: maxima.info,  Node: Introduction to Maxima,  Next: Bug Detection and Reporting,  Prev: Top,  Up: Top

1 Introduction to Maxima
************************

コマンド"maxima"でMaximaを起動してください。 Maximaがバージョン情報とプ
ロンプトを表示します。 それぞれのMaximaコマンドにはセミコロンを終わりに
付けてください。 コマンド"quit();"でセッションが終了します。 以下は、セ
ッションのサンプルです。

     [wfs@chromium]$ maxima
     Maxima 5.9.1 http://maxima.sourceforge.net
     Using Lisp CMU Common Lisp 19a
     Distributed under the GNU Public License. See the file COPYING.
     Dedicated to the memory of William Schelter.
     This is a development version of Maxima. The function bug_report()
     provides bug reporting information.
     (%i1) factor(10!);
                                 8  4  2
     (%o1)                      2  3  5  7
     (%i2) expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o2) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i3) factor (x^6 - 1);
                                   2            2
     (%o3)       (x - 1) (x + 1) (x  - x + 1) (x  + x + 1)
     (%i4) quit();
     [wfs@chromium]$

   Maximaはインフォページを検索できます。 コマンドの情報や、文字列を含む
コマンドや変数すべてを表示させるには、 ‘describe’コマンドを使ってくださ
い。 クエスチョンマーク‘?’ (完全一致検索)と 二重クエスチョンマーク
‘??’(部分一致検索)は‘describe’の省略形です:

     (%i1) ?? integ
      0: Functions and Variables for Elliptic Integrals
      1: Functions and Variables for Integration
      2: Introduction to Elliptic Functions and Integrals
      3: Introduction to Integration
      4: askinteger  (Functions and Variables for Simplification)
      5: integerp  (Functions and Variables for Miscellaneous Options)
      6: integer_partitions  (Functions and Variables for Sets)
      7: integrate  (Functions and Variables for Integration)
      8: integrate_use_rootsof  (Functions and Variables for Integration)
      9: integration_constant_counter  (Functions and Variables for
         Integration)
      10: nonnegintegerp  (Functions and Variables for linearalgebra)
     Enter space-separated numbers, `all' or `none': 5 4

      -- Function: integerp (<expr>)
          Returns `true' if <expr> is a literal numeric integer, otherwise
          `false'.

          `integerp' returns false if its argument is a symbol, even if the
          argument is declared integer.

          Examples:

               (%i1) integerp (0);
               (%o1)                         true
               (%i2) integerp (1);
               (%o2)                         true
               (%i3) integerp (-17);
               (%o3)                         true
               (%i4) integerp (0.0);
               (%o4)                         false
               (%i5) integerp (1.0);
               (%o5)                         false
               (%i6) integerp (%pi);
               (%o6)                         false
               (%i7) integerp (n);
               (%o7)                         false
               (%i8) declare (n, integer);
               (%o8)                         done
               (%i9) integerp (n);
               (%o9)                         false

      -- Function: askinteger (<expr>, integer)
      -- Function: askinteger (<expr>)
      -- Function: askinteger (<expr>, even)
      -- Function: askinteger (<expr>, odd)
          `askinteger (<expr>, integer)' attempts to determine from the
          `assume' database whether <expr> is an integer.  `askinteger'
          prompts the user if it cannot tell otherwise, and attempt to
          install the information in the database if possible.  `askinteger
          (<expr>)' is equivalent to `askinteger (<expr>, integer)'.

          `askinteger (<expr>, even)' and `askinteger (<expr>, odd)'
          likewise attempt to determine if <expr> is an even integer or odd
          integer, respectively.

     (%o1)                                true

   結果を後で使うには、結果を変数に割り当てるか、 自動的に供給されるラベ
ルで参照することができます。 加えて、‘%’は直前の計算結果を示します:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (u, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) factor (%o2);
                                         5
     (%o3)                      6 (y + x)

   Maximaは複素数や数値定数について知っています:

     (%i1) cos(%pi);
     (%o1)                          - 1
     (%i2) exp(%i*%pi);
     (%o2)                          - 1

   Maximaは微積分法ができます:

     (%i1) u: expand ((x + y)^6);
            6        5       2  4       3  3       4  2      5      6
     (%o1) y  + 6 x y  + 15 x  y  + 20 x  y  + 15 x  y  + 6 x  y + x
     (%i2) diff (%, x);
              5         4       2  3       3  2       4        5
     (%o2) 6 y  + 30 x y  + 60 x  y  + 60 x  y  + 30 x  y + 6 x
     (%i3) integrate (1/(1 + x^3), x);
                                       2 x - 1
                     2            atan(-------)
                log(x  - x + 1)        sqrt(3)    log(x + 1)
     (%o3)    - --------------- + ------------- + ----------
                       6             sqrt(3)          3

   Maximaは1次方程式系や3次方程式を解くことができます:

     (%i1) linsolve ([3*x + 4*y = 7, 2*x + a*y = 13], [x, y]);
                             7 a - 52        25
     (%o1)              [x = --------, y = -------]
                             3 a - 8       3 a - 8
     (%i2) solve (x^3 - 3*x^2 + 5*x = 15, x);
     (%o2)       [x = - sqrt(5) %i, x = sqrt(5) %i, x = 3]

   Maximaは非線形方程式系を解くことができます。 もし結果を表示させたくな
ければ、コマンドの終わりに‘;’の代わりに‘$’をつければよいことに注意してく
ださい:

     (%i1) eq_1: x^2 + 3*x*y + y^2 = 0$
     (%i2) eq_2: 3*x + y = 1$
     (%i3) solve ([eq_1, eq_2]);
                   3 sqrt(5) + 7      sqrt(5) + 3
     (%o3) [[y = - -------------, x = -----------],
                         2                 2

                                    3 sqrt(5) - 7        sqrt(5) - 3
                               [y = -------------, x = - -----------]]
                                          2                   2

   Maximaは関数のプロットが生成できます:

     (%i1) plot2d (sin(x)/x, [x, -20, 20])$
     (%i2) plot2d ([atan(x), erf(x), tanh(x)], [x, -5, 5], [y, -1.5, 2])$
     (%i3) plot3d (sin(sqrt(x^2 + y^2))/sqrt(x^2 + y^2),
              [x, -12, 12], [y, -12, 12])$


File: maxima.info,  Node: Bug Detection and Reporting,  Next: Help,  Prev: Introduction to Maxima,  Up: Top

2 Bug Detection and Reporting
*****************************

* Menu:

* Functions and Variables for Bug Detection and Reporting::


File: maxima.info,  Node: Functions and Variables for Bug Detection and Reporting,  Up: Bug Detection and Reporting

2.1 Functions and Variables for Bug Detection and Reporting
===========================================================

 -- 関数: run_testsuite ([<options>])

     Maximaのテストスイートを走らせます。 望みの答えを生成したテストは「
     パス」とみなされます。 望みの答えを生成しないテストも同様ですが、既
     知のバグとしてマークされています。

     ‘run_testsuite’は、以下のオプションキーワード引数を取ります。

     ‘display_all’
          テストすべてを表示します。 通常は、テストが失敗しない限りテス
          トを表示しません。 （デフォルトでは ‘false’に設定されます。）
     ‘display_known_bugs’
          既知のバグとしてマークされているテストを表示します。 （デフォ
          ルトでは ‘false’に設定されます。）
     ‘tests’
          これは、実行するテストのリストです。 それぞれのテストは文字列
          かシンボルで指定することができます。 デフォルトではテストすべ
          てを実行します。 テストの完全な組は ‘testsuite_files’で指定さ
          れています。
     ‘time’
          時間情報を表示します。 もし ‘true’ならそれぞれのテストファイル
          にかかった時間を表示します。 もし ‘all’なら ‘display_all’が
          ‘true’の時、 それぞれ個々のテストにかかった時間を示します。 デ
          フォルトは‘false’で、時間情報を示しません。

     例えば、 ‘run_testsuite(display_known_bugs = true,
     tests=[rtest5])’は、 テスト ‘rtest5’だけを走らせ、既知のバグとして
     マークされているテストを表示します。

     ‘run_testsuite(display_all = true, tests=["rtest1", rtest1a])’は、
     テスト ‘rtest1’と ‘rtest2’を走らせ、 テストそれぞれを表示します。

     ‘run_testsuite’は、Maxima環境を変更します。 通常は、テストスクリプ
     トは 既知の環境（すなわちユーザー定義の関数や変数のない環境）を確立
     するために ‘kill’を実行し、 それからテストにふさわしい関数や変数を
     定義します。

     ‘run_testsuite’は ‘done’を返します。

 -- オプション変数: testsuite_files

     ‘testsuite_files’は ‘run_testsuite’が実行するテスト一式です。 それ
     は実行するテストを含むファイル名のリストです。 もしファイルの中のテ
     ストのいくつかが失敗することが既知なら、 ファイル名をリストする代わ
     りに、 ファイル名と失敗するテスト番号を含むリストを使います。

     例えば、以下はデフォルトのテスト一式の一部です:

           ["rtest13s", ["rtest14", 57, 63]]

     これは、ファイル"rtest13s", "rtest14"から成るテストスイートを指定し
     ますが、 "rtest14" は失敗することが既知の２つのテスト57と63を含みま
     す。

 -- 関数: bug_report ()

     MaximaとLispのバージョン番号を表示し、Maximaプロジェクトのバグレポ
     ートウェブサイトへのリンクを与えます。 バージョン情報は
     ‘build_info’がレポートするものと同じです。

     バグをレポートする時、 MaximaとLispのバージョン情報をバグレポートに
     コピーしてもらえると助かります。

     ‘bug_report’は空の文字列 ‘""’を返します。

 -- 関数: build_info ()

     Maximaビルドのパラメータのまとめを表示します。

     ‘build_info’は空の文字列 ‘""’を返します。 ‘bug_report’.も参照してく
     ださい。


File: maxima.info,  Node: Help,  Next: Command Line,  Prev: Bug Detection and Reporting,  Up: Top

3 Help
******

* Menu:

* Documentation::
* Functions and Variables for Help::        


File: maxima.info,  Node: Documentation,  Next: Functions and Variables for Help,  Prev: Help,  Up: Help

3.1 Documentation
=================

このMaximaのオンラインユーザーズマニュアルは、違った形でも見ることができ
ます。 Maximaの対話プロンプトから‘?’コマンド（すなわち‘describe’関数）を
使うと、テキスト形式でユーザーズマニュアルが表示されます。‘info’ビューア
を使うと、ユーザーズマニュアルは、‘info’ハイパーテキストとして表示され、
通常のウェブブラウザを使えば、ウェブページとして表示されます。

   ‘example’はたくさんのMaxima関数の使用例を表示します。 例えば、

     (%i1) example (integrate);

   は、

     (%i2) test(f):=block([u],u:integrate(f,x),ratsimp(f-diff(u,x)))
     (%o2) test(f) := block([u], u : integrate(f, x),
                                              ratsimp(f - diff(u, x)))
     (%i3) test(sin(x))
     (%o3)                           0
     (%i4) test(1/(x+1))
     (%o4)                           0
     (%i5) test(1/(x^2+1))
     (%o5)                           0

   という感じでさらに出力を表示します。


File: maxima.info,  Node: Functions and Variables for Help,  Prev: Documentation,  Up: Help

3.2 Functions and Variables for Help
====================================

 -- 関数: apropos (<string>)

     <string>を含むMaxima上の名前を検索します。 例えば、‘apropos
     ("exp")’は、 （‘expand’, ‘exp’, ‘exponentialize’のように） ‘exp’を
     名前の一部として含むフラグ、関数すべてのリストを返します。 このよう
     に、もしなにかの名前の一部だけ覚えていたなら、 このコマンドを使って
     名前の残りを見つけることができます。 同様に、 ‘apropos ("tr_")’とす
     れば、翻訳器に関係した多くのスイッチのリストを 見つけることができま
     す。翻訳器に関係したスイッチのほとんどは‘tr_’で始まります。

     ‘apropos("")’は、Maximaの名前すべてのリストを返します。

     もし名前が見つからなければ、‘apropos’は空のリスト‘[]’を返します。

     例:

     ‘"gamma"’を含むMaximaシンボルすべてを表示します:

          (%i1) apropos("gamma");
          (%o1) [%gamma, gamma, gammalim, gamma_expand, gamma_incomplete_lower,
          gamma_incomplete, gamma_incomplete_generalized,
          gamma_incomplete_regularized, Gamma, log_gamma, makegamma,
          prefer_gamma_incomplete,
          gamma_incomplete_generalized_regularized]

 -- 関数: demo (<filename>)

     <filename>の中のMaxima式を評価し、結果を表示します。 ‘demo’はそれぞ
     れの式を評価した後 停止し、 ユーザーがリターンキーを入力すると続き
     を実行します。 (Xmaximaで走らせている場合、 ‘demo’はセミコロン‘;’に
     続けて改行を入力する必要があります。)

     ‘demo’は、<filname>のファイルを探すため、 ディレクトリ
     ‘file_search_demo’のリストを検索します。 もしファイルの拡張子が
     ‘.dem’なら、拡張子は省略できます。 ‘file_search’も参照してください
     。

     ‘demo’は引数を評価します。 ‘demo’はデモンストレーションファイルの名
     前を返します。

     例:

          (%i1) demo ("disol");

          batching /home/wfs/maxima/share/simplification/disol.dem
           At the _ prompt, type ';' followed by enter to get next demo
          (%i2)                      load("disol")

          _
          (%i3)           exp1 : a (e (g + f) + b (d + c))
          (%o3)               a (e (g + f) + b (d + c))

          _
          (%i4)                disolate(exp1, a, b, e)
          (%t4)                         d + c

          (%t5)                         g + f

          (%o5)                   a (%t5 e + %t4 b)

          _

 -- 関数: describe (<string>)
 -- 関数: describe (<string>, exact)
 -- 関数: describe (<string>, inexact)

     ‘describe(<string>)’は‘describe(<string>, exact)’と同値です。

     ‘describe(<string>, exact)’は（大文字小文字は区別せず）<string>に等
     しいタイトルを持った項目があれば、それを見つけます。

     ‘describe(<string>, inexact)’はタイトルの中に<string>を含むすべての
     項目を見つけます。 もし複数あれば、Maximaはユーザーに項目を選択する
     よう尋ねます。

     対話プロンプトでは、 ‘? foo’(‘?’と‘foo’の間にスペース)は
     ‘describe("foo", exact)’と同値であり、 ‘?? foo’は‘describe("foo",
     inexact)’と同値です。

     ‘describe("", inexact)’は、オンラインマニュアルでドキュメント化され
     たすべてのトピックのリストを出力します。

     ‘describe’は引数をクォートします。 ‘describe’は、ドキュメントが見つ
     かれば‘true’を返し、見つからなければ‘false’を返します。

     *note Documentation::も参照してください。

     例:

          (%i1) ?? integ
           0: Functions and Variables for Elliptic Integrals
           1: Functions and Variables for Integration
           2: Introduction to Elliptic Functions and Integrals
           3: Introduction to Integration
           4: askinteger  (Functions and Variables for Simplification)
           5: integerp  (Functions and Variables for Miscellaneous Options)
           6: integer_partitions  (Functions and Variables for Sets)
           7: integrate  (Functions and Variables for Integration)
           8: integrate_use_rootsof  (Functions and Variables for
              Integration)
           9: integration_constant_counter  (Functions and Variables for
              Integration)
           10: nonnegintegerp  (Functions and Variables for linearalgebra)
          Enter space-separated numbers, `all' or `none': 7 8

           -- Function: integrate (<expr>, <x>)
           -- Function: integrate (<expr>, <x>, <a>, <b>)
               Attempts to symbolically compute the integral of <expr> with
               respect to <x>.  `integrate (<expr>, <x>)' is an indefinite
               integral, while `integrate (<expr>, <x>, <a>, <b>)' is a
               definite integral, [...]

           -- Option variable: integrate_use_rootsof
               Default value: `false'

               When `integrate_use_rootsof' is `true' and the denominator of
               a rational function cannot be factored, `integrate' returns
               the integral in a form which is a sum over the roots (not yet
               known) of the denominator.
               [...]

     この例では、項目7と8を選択しました。 （‘[...]’でほのめかされている
     ように出力は省略されています。） ‘all’や‘none’を入力すると、項目す
     べてを選択したり、１つも選ばなかったりできます。 それぞれ‘a’もしく
     は‘n’と省略形を使うことができます。

 -- 関数: example (<topic>)
 -- 関数: example ()

     ‘example (<topic>)’は、<topic>の例をいくつか表示します。 <topic>は
     シンボルもしくは文字列です。 ‘if’や‘do’、‘lambda’のような演算子の例
     を得るには、引数は文字列でなければなりません。例えば、 ‘example
     ("do")’。 ‘example’は、大文字小文字を区別しません。トピックのほとん
     どは関数名です。

     ‘example ()’はわかっているトピックすべてのリストを表示します。

     例を含むファイル名は、グローバル変数‘manual_demo’で与えられます。デ
     フォルトは‘"manual.demo"’です。

     ‘example’は引数をクォートします。 ‘example’はエラーがあったり引数が
     なかったりしなければ‘done’を返します。 引数がない場合には わかって
     いるトピックすべてのリストを表示します。

     例:

          (%i1) example(append);
          (%i2) append([x+y,0,-3.2],[2.5e+20,x])
          (%o2)                    [y + x, 0, - 3.2, 2.5e+20, x]
          (%o2)                                done
          (%i3) example("lambda");

          (%i4) lambda([x,y,z],z^2+y^2+x^2)
                                                     2    2    2
          (%o4)                   lambda([x, y, z], z  + y  + x )
          (%i5) %(1,2,a)
                                               2
          (%o5)                               a  + 5
          (%i6) a+2+1
          (%o6)                                a + 3
          (%o6)                                done

 -- オプション変数: manual_demo
     デフォルト値: ‘"manual.demo"’

     ‘manual_demo’は、 関数‘example’のための例が入っているファイルの名前
     を指定します。 ‘example’を参照してください。


File: maxima.info,  Node: Command Line,  Next: Data Types and Structures,  Prev: Help,  Up: Top

4 Command Line
**************

* Menu:

* Introduction to Command Line::
* Functions and Variables for Command Line::
* Functions and Variables for Display::


File: maxima.info,  Node: Introduction to Command Line,  Next: Functions and Variables for Command Line,  Prev: Command Line,  Up: Command Line

4.1 Introduction to Command Line
================================


File: maxima.info,  Node: Functions and Variables for Command Line,  Next: Functions and Variables for Display,  Prev: Introduction to Command Line,  Up: Command Line

4.2 Functions and Variables for Command Line
============================================

 -- システム変数: __

     ‘__’は、現在評価中の入力式です。 すなわち、入力式 <expr>が評価され
     ている間、 ‘__’は <expr>です。

     ‘__’は、入力が整理されたり評価されたりする前に入力式に割り当てられ
     ます。 しかし表示される時、‘__’の値は（評価はされませんが）整理され
     ます。

     ‘batch’と ‘load’は ‘__’を認識します。 ‘batch’が処理するファイル内で
     は、 ‘__’は対話プロンプトでのそれと同じ意味になります。 ‘load’が処
     理するファイル内では、 ‘__’は対話プロンプトやバッチファイルの中で直
     前に入力された入力式にバインドされています; ‘__’は処理中のファイル
     内の入力式にはバインドされません。 特に、 ‘load (<filename>)’が対話
     プロンプトからコールされた時、 ‘__’は、ファイルが処理されている間、
     ‘load (<filename>)’にバインドされます。

     ‘_’や ‘%’も参照してください。

     例:

          (%i1) print ("I was called as", __);
          I was called as print(I was called as, __)
          (%o1)              print(I was called as, __)
          (%i2) foo (__);
          (%o2)                     foo(foo(__))
          (%i3) g (x) := (print ("Current input expression =", __), 0);
          (%o3) g(x) := (print("Current input expression =", __), 0)
          (%i4) [aa : 1, bb : 2, cc : 3];
          (%o4)                       [1, 2, 3]
          (%i5) (aa + bb + cc)/(dd + ee + g(x));
                                      cc + bb + aa
          Current input expression = --------------
                                     g(x) + ee + dd
                                          6
          (%o5)                        -------
                                       ee + dd

 -- システム変数: _

     ‘_’は直前の入力式です。 (例えば、‘%i1’, ‘%i2’, ‘%i3’, …)

     ‘_’は、入力が整理されたり評価されたりする前に、入力式に割り当てられ
     ます。 しかし、 ‘_’の値は、表示される時（評価はされませんが）整理さ
     れます。

     ‘batch’と ‘load’は ‘_’を認識します。 ‘batch’が処理するファイル内で
     は、 ‘_’は対話プロンプトでのそれと同じ意味になります。 ‘load’が処理
     するファイル内では、 ‘_’は、対話プロンプトやバッチファイルの中で、
     直前に入力された入力式にバインドされます; ‘_’は処理中のファイル内の
     入力式にはバインドされません。

     ‘__’や ‘%’も参照してください。

     例:

          (%i1) 13 + 29;
          (%o1)                          42
          (%i2) :lisp $_
          ((MPLUS) 13 29)
          (%i2) _;
          (%o2)                          42
          (%i3) sin (%pi/2);
          (%o3)                           1
          (%i4) :lisp $_
          ((%SIN) ((MQUOTIENT) $%PI 2))
          (%i4) _;
          (%o4)                           1
          (%i5) a: 13$
          (%i6) b: 29$
          (%i7) a + b;
          (%o7)                          42
          (%i8) :lisp $_
          ((MPLUS) $A $B)
          (%i8) _;
          (%o8)                         b + a
          (%i9) a + b;
          (%o9)                          42
          (%i10) ev (_);
          (%o10)                         42

 -- システム変数: %

     ‘%’はMaximaが直前に計算した出力式です。 (例えば、 ‘%o1’, ‘%o2’,
     ‘%o3’, …) 出力の表示には無関係です。

     ‘batch’と ‘load’は‘%’を認識します。 ‘batch’が処理するファイル内では
     、 ‘%’は対話プロンプトでのそれと同じ意味になります。 ‘load’が処理す
     るファイル内では、 ‘%’は、対話プロンプトやバッチファイルの中で、直
     前に計算された出力式にバインドされます; ‘%’は、処理中のファイル内の
     出力式にはバインドされません。

     ‘_’, ‘%%’, ‘%th’も参照してください。

 -- システム変数: %%

     合成文、すなわち‘block’, ‘lambda’, もしくは‘(<s_1>, ..., <s_n>)’の
     中で、 ‘%%’は前の文の値です。

     合成文の最初の文もしくは合成文の外側では‘%%’は未定義です。

     ‘%%’は、‘batch’や ‘load’で認識され、 対話プロンプトでのそれと同じ意
     味になります。

     ‘%’も参照してください。

     例:

     以下の二つの例は同じ結果になります。

          (%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                                         21
          (%o1)                          --
                                         2
          (%i2) block ([prev], prev: integrate (x^5, x),
                         ev (prev, x=2) - ev (prev, x=1));
                                         21
          (%o2)                          --
                                         2

     合成文は他の合成文を含むかもしれません。 文が単文か合成文かに関係な
     く、 ‘%%’は前の文の値です。

          (%i3) block (block (a^n, %%*42), %%/6);
                                           n
          (%o3)                         7 a

     合成文の中ではブレイクプロンプトで‘%%’の値を検査することができます
     。 ブレイクプロンプトは ‘break’関数を実行することで開きます。 例え
     ば、以下の例で‘%%;’を入力すると、‘42’が出力されます。

          (%i4) block (a: 42, break ())$

          Entering a Maxima break point. Type 'exit;' to resume.
          _%%;
          42
          _

 -- 関数: %th (<i>)

     <i>番前の出力式の値。 すなわち、計算される次の式を<n>番目の出力とす
     ると ‘%th (<m>)’は、(<n> - <m>)番目の出力です。

     ‘batch’と‘load’は‘%th’を認識されます。 ‘batch’が処理するファイル内
     では、 ‘%th’は、対話プロンプトでのそれと同じ意味になります。
     ‘load’が処理するファイル内では、 ‘%th’は、対話プロンプトやバッチフ
     ァイルの中で、直前に計算された出力式にバインドされます; ‘%th’は、処
     理中のファイル内の出力式にはバインドされません。

     ‘%’と ‘%%’も参照してください。

     例:

     ‘batch’ファイルの中でとか、出力式のグループを参照する時‘%th’は役立
     ちます。 この例は‘s’を最後の5つの出力式の和に設定します。

          (%i1) 1;2;3;4;5;
          (%o1)                           1
          (%o2)                           2
          (%o3)                           3
          (%o4)                           4
          (%o5)                           5
          (%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
          (%o6)                          15

 -- 特殊シンボル: ?

     関数名や変数名の前置としての‘?’は、 名前が、Maximaの名前ではなく
     Lispの名前であることを意味します。 例えば、‘?round’は、Lisp関数
     ‘ROUND’を意味します。 この点に関して更に知るには*note Lisp and
     Maxima::を参照してください。

     表記‘? word’ (空白を空けて単語が続くクエスチョンマーク)は
     ‘describe("word")’と同値です。 クエスチョンマークは入力ラインの先頭
     になければいけません; そうでなければドキュメンテーションのリクエス
     トとして認識されません。 ‘describe’も参照してください。

 -- 特殊シンボル: ??

     表記‘?? word’(空白を空けて単語が続く‘??’)は ‘describe("word",
     inexact)’と同値です。 クエスチョンマークは入力行の先頭になければい
     けません; そうでなければドキュメンテーションのリクエストとして認識
     されません。 ‘describe’も参照してください。

 -- オプション変数: inchar
     デフォルト値: ‘%i’

     ‘inchar’はユーザーが入力した式のラベルの前置です。 Maximaは、
     ‘inchar’と‘linenum’を連結することで、 入力式それぞれのラベルを自動
     的に構成します。

     ‘inchar’は単一文字である必要はなく、 任意の文字列もしくはシンボルを
     割り当てられます。 Maximaは内部的に前置の最初の文字だけを考慮するの
     で、 前置‘inchar’, ‘outchar’, ‘linechar’は異なる最初の文字を持たな
     ければいけません。 そうでなければ‘kill(inlables)’のようないくつかの
     コマンドは期待通りに動きません。

     ‘labels’も参照してください。

     例:

          (%i1) inchar: "input";
          (%o1)                         input
          (input2) expand((a+b)^3);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (input3)

 -- システム変数: infolists
     デフォルト値: ‘[]’

     ‘infolists’はMaximaに関する情報リストすべての名前のリストです。 こ
     れらは以下の通りです:

     ‘labels’
          すべてのバインドされた‘%i’, ‘%o’, ‘%t’ラベル
     ‘values’
          ‘:’や‘::’や関数バインドが生成する、 ユーザー変数であって、
          Maximaオプションやスイッチでない、 すべてのバインドされたアト
          ム
     ‘functions’
          ‘:=’や‘define’が生成するすべてのユーザー定義関数
     ‘arrays’
          ‘:’, ‘::’, または‘:=’が生成するすべての宣言配列と未宣言配列
     ‘macros’
          ‘::=’が生成したすべてのユーザー定義マクロ関数
     ‘myoptions’
          (それらが後にデフォルト値に再設定されようがされまいが) ユーザ
          ーが再設定したすべてのオプション
     ‘rules’
          ‘tellsimp’, ‘tellsimpafter’, ‘defmatch’, または‘defrule’が生成
          するすべてのユーザー定義パターンマッチングと整理規則
     ‘aliases’
          ‘alias’, ‘ordergreat’, ‘orderless’関数が生成するか、
          ‘declare’を使ってアトムを‘noun’として宣言することで生成された
          、 ユーザー定義エーリアスを持つすべてのアトム
     ‘dependencies’
          ‘depends’や‘gradef’関数が生成する関数依存性を持つすべてのアト
          ム
     ‘gradefs’
          ‘gradef’関数が生成するユーザー定義の導関数を持つすべての関数
     ‘props’
          ‘declare’関数で確立されるプロパティはもちろん、 ‘atvalue’や
          ‘matchdeclare’などが確立するプロパティで、 上で述べたもの以外
          の任意のプロパティを持つすべてのアトム
     ‘let_rule_packages’
          特別パッケージ‘default_let_rule_package’に加えて すべてのユー
          ザー定義‘let’規則パッケージ (‘default_let_rule_package’は、 ユ
          ーザーが陽に設定していない時使われる規則パッケージの名前です。
          )

 -- 関数: kill (<a_1>, …, <a_n>)
 -- 関数: kill (labels)
 -- 関数: kill (inlabels, outlabels, linelabels)
 -- 関数: kill (<n>)
 -- 関数: kill ([<m>, <n>])
 -- 関数: kill (values, functions, arrays, …)
 -- 関数: kill (all)
 -- 関数: kill (allbut (<a_1>, …, <a_n>))

     引数<a_1>, …, <a_n>からすべてのバインド（値、関数、配列、ルール）を
     解除します。 引数<a_k>はシンボルか配列要素を取り得ます。 <a_k>が配
     列要素の時、‘kill’は配列の他の要素には影響することなくその要素をア
     ンバインドします。

     いくつかの特殊な引数が認識されます。 例えば、‘kill (inlabels,
     functions, allbut (foo, bar))’のように、異なる引数の種類が組み合わ
     されます。

     ‘kill (labels)’はそれまでに作られた入力、出力、中間式のラベルすべて
     をアンバインドします。 ‘kill (inlabels)’は ‘inchar’の現在の値で始ま
     る入力ラベルのみをアンバインドします。 同様に、 ‘kill (outlabels)’は
     ‘outchar’の現在の値で始まる出力ラベルのみをアンバインドし、 ‘kill
     (linelabels)’は ‘linechar’の現在の値で始まる中間式ラベルのみをアン
     バインドします。

     ‘kill (’_n_‘)’（nは整数）は入力、出力ラベルの最近のn個をアンバイン
     ドします。

     ‘kill ([<m>, <n>])’は入力、出力ラベル<m>から<n>までをアンバインドし
     ます。

     ‘kill (<infolist>)’は <infolist>の中のすべての項目をアンバインドし
     ます。 ここで、<infolist>は（‘values’, ‘functions’, ‘arrays’のよう
     な) ‘infolists’の中の任意の項目です。 ‘infolists’も参照してください
     。

     ‘kill (all)’はinfolistsのすべての項目をアンバインドします。 ‘kill
     (all)’はグローバル変数をデフォルト値にリセットしません; この点に関
     しては‘reset’を参照してください。

     ‘kill (allbut (<a_1>, ..., <a_n>))’は、 <a_1>, ..., <a_n>を除いて す
     べてのinfolistsの中のすべての項目をアンバインドします。 ‘kill
     (allbut (<infolist>))’は <infolist>（<infolist>は‘values’,
     ‘functions’, ‘arrays’など） 上の項目を除いてすべての項目をアンバイ
     ンドします。

     バインドされたプロパティによって使われたメモリは、すべてのシンボル
     がプロパティからアンバインドされるまで解放されません。 特に、シンボ
     ルの値によって使われているメモリを解放するには、 シンボルそのものの
     アンバインドだけでなく、バインドされた値を表示する出力ラベルをアン
     バインドします。

     ‘kill’は引数をクォートします。 引数を評価するにはクォートクォート演
     算子‘''’を使います。

     ‘kill (<symbol>)’はシンボルのすべてのプロパティをアンバインドします
     。 対照的に、関数‘remvalue’, ‘remfunction’, ‘remarray’, ‘remrule’は
     特定のプロパティをアンバインドします。

     ‘kil’は常に、たとえ引数がバインドされていなくても、‘done’を返します
     。

 -- 関数: labels (<symbol>)
 -- システム変数: labels

     <symbol>で始まる入力、出力、中間式ラベルのリストを返します。
     <symbol>は、‘inchar’, ‘outchar’, もしくは‘linechar’の値が典型的です
     。 ラベル文字はパーセント記号ありでもあしでもかまいませんので、 例
     えば、‘i’と‘%i’は同じ結果になります。

     もし<symbol>で始まるラベルがなければ、‘labels’は空のリストを返しま
     す。

     関数‘labels’は引数をクォートします。 引数を評価するにはクォートクォ
     ート演算子‘''’を使います。 例えば， ‘labels (''inchar)’は、現在の入
     力ラベル文字で始まる入力ラベルを返します。

     変数‘labels’は入力、出力、中間式ラベルのリストです。 ‘inchar’,
     ‘outchar’, もしくは‘linechar’が再定義されても、以前のラベルすべてを
     含みます。

     デフォルトで、Maximaはそれぞれのユーザー入力式の結果を表示し、結果
     に出力ラベルが与えられます。 入力を‘;’(セミコロン)の代わりに‘$’(ド
     ル記号)で終了することで、出力表示は抑制されます。 出力ラベルが構成
     され、結果にバインドされますが、表示されません。 ラベルは表示された
     出力ラベルと同じ方法で参照できます。 ‘%’や‘%%’, ‘%th’も参照してくだ
     さい。

     いくつかの関数では中間式ラベルが生成されることがあります。 フラグ
     ‘programmode’は ‘solve’や他の関数が式のリストを返す代わりに中間式ラ
     ベルを生成するかどうかを制御します。 ‘ldisplay’のようないくつかの他
     の関数は常に中間式ラベルを生成します。

     ‘inchar’や‘outchar’, ‘linechar’, ‘infolists’も参照してください。

 -- オプション変数: linechar
     デフォルト値: ‘%t’

     ‘linechar’は Maximaが生成する中間式のラベルの前置です。 Maximaは（
     もし表示されるなら） ‘linechar’と‘linenum’を連結することで 中間式そ
     れぞれのラベルを構成します。

     ‘linechar’は単一文字である必要はなく、 任意の文字列もしくはシンボル
     を割り当てられます。 Maximaは内部的に 前置の最初の文字だけを考慮す
     るので、 前置‘inchar’, ‘outchar’, ‘linechar’は異なる最初の文字を持
     たなければいけません。 そうでなければ ‘kill(inlables)’のようないく
     つかのコマンドは期待通りに動きません。

     中間式は表示されるかもしれませんし、表示されないかもしれません。
     ‘programmode’と‘labels’も参照してください。

 -- システム変数: linenum

     入力出力式の現在のペアの行番号。

 -- システム変数: myoptions
     デフォルト値: ‘[]’

     ‘myoptions’はユーザーが再設定したオプションすべてのリストです。 初
     期値に再設定されたか否かに関わらずです。

 -- オプション変数: nolabels
     デフォルト値: ‘false’

     ‘nolabels’は‘true’であれば、 入力と出力結果のラベル（それぞれ‘%i’と
     ‘%o’）は表示されますが、 ラベルは結果にバインドされず、‘labels’リス
     トにも追加されません。 ラベルは結果にバインドされないので、 ガーベ
     ッジコレクションは結果が使ったメモリを回復することができます。

     そうでなければ、入力と出力の結果のラベルは結果にバインドされ、
     ‘labels’リストに追加されます。

     中間式ラベル(‘%t’)は‘nolabels’に影響されません; ‘nolabels’が
     ‘true’でも‘false’でも、中間式ラベルはバインドされ、‘labels’リストに
     追加されます。

     ‘batch’や‘load’、 ‘labels’も参照してください。

 -- オプション変数: optionset
     デフォルト値: ‘false’

     ‘optionset’が‘true’の時、Maximaは、Maximaオプションが再設定されると
     いつでも、メッセージを表示します。 もしユーザーがあるオプションの綴
     りが怪しく、割り当てた変数が本当にオプション変数か確認したいなら便
     利です。

     例:

          (%i1) optionset:true;
          assignment: assigning to option optionset
          (%o1)                         true
          (%i2) gamma_expand:true;
          assignment: assigning to option gamma_expand
          (%o2)                         true

 -- オプション変数: outchar
     デフォルト値: ‘%o’

     ‘outchar’はMaximaが計算した式のラベルの前置です。 ‘outchar’と
     ‘linenum’を連結することで、 Maximaは計算された式それぞれのラベルを
     自動的に構成します。 ‘outchar’は、単一文字である必要はなく、 任意の
     文字列もしくはシンボルを割り当てられます。 Maximaは内部的に前置の最
     初の文字だけを考慮するので、 前置‘inchar’, ‘outchar’, ‘linechar’は
     異なる最初の文字を持たなければいけません。 そうでなければ、
     ‘kill(inlables)’のようないくつかのコマンドは期待通りに動きません。

     ‘labels’も参照してください。

     例:

          (%i1) outchar: "output";
          (output1)                    output
          (%i2) expand((a+b)^3);
                               3        2      2      3
          (output2)           b  + 3 a b  + 3 a  b + a
          (%i3)

 -- 関数: playback ()
 -- 関数: playback (<n>)
 -- 関数: playback ([<m>, <n>])
 -- 関数: playback ([<m>])
 -- 関数: playback (input)
 -- 関数: playback (slow)
 -- 関数: playback (time)
 -- 関数: playback (grind)

     入力、出力、中間式を表示します。再計算はしません。 ‘playback’はラベ
     ルにバインドされた式表示するだけです; （‘print’や‘describe’で表示さ
     れたテキストやエラーメッセージなど）他の出力は表示されません。
     ‘labels’も参照してください。

     ‘playback’は引数をクォートします。 引数を評価するにはクォートクォー
     ト演算子‘''’を使います。 ‘playback’は常に‘done’を返します。

     ‘playback ()’（引数なし）は今までに生成された入力、出力、中間式すべ
     てを表示します。 たとえ計算時に‘$’終端子で出力が抑制されていても、
     出力式は表示されます。

     ‘playback (<n>)’は最近の<n>個の式を表示します。 入力、出力、中間式
     それぞれを１と数えます。

     ‘playback ([<m>, <n>])’は <m>番目から<n>番目までの入力、出力、中間
     式を表示します。

     ‘playback ([<m>])’は ‘playback ([<m>, <m>])’と同値です; これは普通
     、入力と出力の式のペアを１つ表示します。

     ‘playback (input)’は今までに生成された入力式をすべて表示します。

     ‘playback (slow)’は式の間でポーズし、ユーザーが ‘enter’を入力するの
     を待ちます。 これは ‘demo’と似たような振る舞いです。 ‘playback
     (slow)’は、‘save’や‘stringout’と関連して、 役立つ式を取り出すために
     ２次記憶ファイルを生成するときに便利です。

     ‘playback (time)’はそれぞれの式の計算時間を表示します。

     ‘playback (grind)’は入力式を ‘grind’関数と同じ形式で表示します。 出
     力式は ‘grind’オプションで影響を受けません。 ‘grind’を参照してくだ
     さい。

     例えば、‘playback ([5, 10], grind, time, slow)’のように、 引数を組
     み合わせられます。

 -- オプション変数: prompt
     デフォルト値: ‘_’

     ‘prompt’は、‘demo’関数や‘playback (slow)’モード、 （‘break’で呼び出
     された）Maximaブレイクループのプロンプトシンボルです。

 -- 関数: quit ()

     Maximaセッションを終了します。 関数は、‘quit’ではなく、‘quit();’も
     しくは‘quit()$’として呼び出さなければいけないことに注意してください
     。

     長い計算を中断するには ‘control-C’をタイプしてください。 デフォルト
     の動作では Maximaプロンプトに戻ります。 もし‘*debugger-hook*’が
     ‘nil’なら、 ‘control-C’はLispデバッガを開きます。 ‘debugging’も参照
     してください。

 -- 関数: read (<expr_1>, …, <expr_n>)

     <expr_1>, …, <expr_n>を表示し、 コンソールから式１つを読み込み、評
     価された式を返します。 式はセミコロン‘;’もしくはドル記号‘$’で終了し
     ます。

     ‘readonly’も参照してください。

          (%i1) foo: 42$
          (%i2) foo: read ("foo is", foo, " -- enter new value.")$
          foo is 42  -- enter new value.
          (a+b)^3;
          (%i3) foo;
                                               3
          (%o3)                         (b + a)

 -- 関数: readonly (<expr_1>, …, <expr_n>)

     <expr_1>, …, <expr_n>を表示し、 コンソールから式を１つ読み込み、 式
     を（評価せずに）返します。 式はセミコロン‘;’もしくはドル記号‘$’で終
     了します。

     ‘read’も参照してください。

     例:

          (%i1) aa: 7$
          (%i2) foo: readonly ("Enter an expression:");
          Enter an expression:
          2^aa;
                                            aa
          (%o2)                            2
          (%i3) foo: read ("Enter an expression:");
          Enter an expression:
          2^aa;
          (%o3)                            128

 -- 関数: reset ()

     多くのグローバル変数やオプション、いくつかの他の変数をデフォルト値
     に再設定します。

     ‘reset’は Lispリスト‘*variable-initial-values*’上の変数を処理します
     。 Lispマクロ‘defmvar’は（他の動作の間に）このリストに変数を置きま
     す。 すべてではありませんが多くのグローバル変数やオプションが
     defmvarによって定義されており、 また、‘defmvar’で定義されたいくつか
     の変数はグローバル変数でもオプションでもありません。

 -- オプション変数: showtime
     デフォルト値: ‘false’

     ‘showtime’が‘true’の時、出力式と一緒に計算時間と経過時間を表示しま
     す。

     計算時間は常に記録されており、 ‘showtime’が‘false’の時でも、
     ‘time’や‘playback’で計算時間を表示することができます。

     ‘timer’も参照してください。

 -- 関数: to_lisp ()

     Maximaの下のLispシステムに入ります。‘(to-maxima)’でMaximaに戻ります
     。

     例:

     関数を定義し、Maximaの下のLispシステムに入ります。 定義をプロパティ
     リスト上で検査します。そして、関数定義を抽出し、因数分解し、 変数
     $resultに格納します。 変数はMaximaに戻った後、Maximaで使うことがで
     きます。

          (%i1) f(x):=x^2+x;
                                            2
          (%o1)                    f(x) := x  + x
          (%i2) to_lisp();
          Type (to-maxima) to restart, ($quit) to quit Maxima.

          MAXIMA> (symbol-plist '$f)
          (MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X)
                                       ((MPLUS) ((MEXPT) $X 2) $X))))
          MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
          ((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
          MAXIMA> (to-maxima)
          Returning to Maxima
          (%o2)                         true
          (%i3) result;
          (%o3)                       x (x + 1)

 -- システム変数: values
     初期値: ‘[]’

     ‘values’は（Maximaのオプションやスイッチではなく）バインドされたユ
     ーザー変数すべてのリストです。 リストは、‘:’や‘::’でバインドされた
     シンボルを含みます。

     もし変数の値がコマンド‘kill’や, ‘remove’, ‘remvalue’で削除されたら
     、 変数は‘values’から削除されます。

     ユーザー定義関数のリストに関しては ‘functions’を参照してください。

     例:

     最初、‘values’はシンボル‘a’, ‘b’, ‘c’を示しますが、 ‘d’も―それは値
     にバインドされていません―ユーザー関数‘f’も示しません。 値は変数から
     削除されます。‘values’は空のリストです。

          (%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                     2
          (%o1)              [99, 9, 90, d, f(x) := x ]
          (%i2) values;
          (%o2)                       [a, b, c]
          (%i3) [kill(a), remove(b,value), remvalue(c)];
          (%o3)                   [done, done, [c]]
          (%i4) values;
          (%o4)                          []


File: maxima.info,  Node: Functions and Variables for Display,  Prev: Functions and Variables for Command Line,  Up: Command Line

4.3 Functions and Variables for Display
=======================================

 -- オプション変数: %edispflag
     デフォルト値: ‘false’

     ‘%edispflag’が‘true’の時、 Maximaは ‘%e’の負の指数乗を商として表示
     します。 例えば、‘%e^-x’は ‘1/%e^x’と表示されます。 ‘exptdispflag’も
     参照してください。

     例:

          (%i1) %e^-10;
                                         - 10
          (%o1)                        %e
          (%i2) %edispflag:true$
          (%i3) %e^-10;
                                         1
          (%o3)                         ----
                                          10
                                        %e

 -- オプション変数: absboxchar
     デフォルト値: ‘!’

     ‘absboxchar’は１行より広い式の回りに絶対値記号を描くのに使われる文
     字です。

     例:

          (%i1) abs((x^3+1));
                                      ! 3    !
          (%o1)                       !x  + 1!

 -- 関数: disp (<expr_1>, <expr_2>, …)

     ‘display’のようですが、 等式ではなく引数の値だけが表示されます。 こ
     れは名前を持たない複雑な引数や引数の値だけに興味があって 名前には興
     味がない引数に役立ちます。

     ‘ldisp’と‘print’も参照してください。

     例:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) disp(x, b[1,2], sin(1.0));
                                         123

                                            2
                                       x - x

                                  .8414709848078965

          (%o3)                         done

 -- 関数: display (<expr_1>, <expr_2>, …)

     左辺が未評価の<expr_i>で、右辺が式の値の等式を行の中央に表示します
     。 この関数は、中間結果を表示するのにブロックや‘for’文の中で役立ち
     ます。 ‘display’の引数は、通常アトムや、添字付き変数、関数コールで
     す。 ‘disp’も参照してください。

     ‘ldisplay’, ‘disp’, ‘ldisp’も参照してください。

     例:

          (%i1) b[1,2]:x-x^2$
          (%i2) x:123$
          (%i3) display(x, b[1,2], sin(1.0));
                                       x = 123

                                                2
                                   b     = x - x
                                    1, 2

                            sin(1.0) = .8414709848078965

          (%o3)                         done

 -- オプション変数: display2d
     デフォルト値: ‘true’

     ‘display2d’が‘false’の時、 コンソール表示は（２次元）形式ではなく文
     字列（１次元）形式です。

     例:

          (%i1) x/(x^2+1);
                                         x
          (%o1)                        ------
                                        2
                                       x  + 1
          (%i2) display2d:false$
          (%i3) x/(x^2+1);
          (%o3) x/(x^2+1)

 -- オプション変数: display_format_internal
     デフォルト値: ‘false’

     ‘display_format_internal’が‘true’の時、 式は数学的内部表現を隠すよ
     うに変換されることなく表示されます。 表示は‘part’ではなく‘inpart’が
     返すものに対応します。

     例:

          User     part       inpart
          a-b;      a - b     a + (- 1) b

                     a            - 1
          a/b;       -         a b
                     b
                                 1/2
          sqrt(x);   sqrt(x)    x

                    4 X        4
          X*4/3;    ---        - X
                     3         3

 -- 関数: dispterms (<expr>)
     <expr>をパーツ毎に一行ずつ使って表示します。 すなわち、最初に
     <expr>の演算子が表示され、 それぞれの項が別々に表示されます。 もし
     <expr>が他の方法で表示するには大きすぎるなら、 これは役に立ちます。
     例えば、もし‘P1’, ‘P2’, ...が非常に大きな式なら、 ‘P1 + P2 + ...’を
     一度に表示しようとする場合、 表示プログラムは保存の空き領域を使い尽
     くすかもしれません。 しかしながら、 ‘dispterms (P1 + P2 + ...)’は、
     ‘P1’を表示し、その下に‘P2’を表示し、という具合です。 ‘dispterms’を
     使わない時、 もし指数式が‘A^B’のように表示するには広すぎるなら、 そ
     れは‘expt (A, B)’ (もしくは‘A^^B’の場合、‘ncexpt (A, B)’）のように
     現れます。

 -- 関数: expt (<a>, <b>)
 -- 関数: ncexpt (<a>, <b>)

     もし指数式が‘<a>^<b>’のように表示するには広すぎるなら、 ‘expt (<a>,
     <b>)’ (もしくは、‘<a>^^<b>’の場合、‘ncexpt (<a>, <b>)’ のように現れ
     ます。

     ‘expt’や‘ncexpt’は入力では認識されません。

 -- オプション変数: exptdispflag
     デフォルト値: ‘true’

     ‘exptdispflag’が‘true’の時、 Maximaは式を商を使って負の指数の式を表
     示します。

     例:

          (%i1) exptdispflag:true;
          (%o1)                         true
          (%i2) 10^-x;
                                          1
          (%o2)                          ---
                                           x
                                         10
          (%i3) exptdispflag:false;
          (%o3)                         false
          (%i4) 10^-x;
                                          - x
          (%o4)                         10

 -- 関数: grind (<expr>)
 -- オプション変数: grind

     関数‘grind’は コンソールにMaximaへの入力に適した形で<expr>を印刷し
     ます。 ‘grind’はいつも‘done’を返します。

     <expr>が関数名やマクロ名の時、 ‘grind’は、名前だけでなく関数やマク
     ロ定義を出力します。

     ‘string’も参照してください。 それは出力を印刷する代わりに文字列を返
     します。 ‘grind’は ‘string’の出力より若干読みやすい方法で 式を印刷
     しようとします。

     変数‘grind’が‘true’の時、 ‘string’や‘stringout’の出力は ‘grind’のそ
     れと同じフォーマットです; そうでなければ、それらの関数の出力を特別
     にフォーマットしようとはしません。 変数‘grind’のデフォルト値は
     ‘false’です。

     ‘grind’は ‘playback’の引数としても指定できます。 ‘grind’が存在する
     時、 ‘playback’は ‘grind’関数と同じフォーマットで入力式を印刷します
     。 そうでなければ、入力式を特にフォーマットしようとはしません。

     ‘grind’は引数を評価します。

     例:

          (%i1) aa + 1729;
          (%o1)                       aa + 1729
          (%i2) grind (%);
          aa+1729$
          (%o2)                         done
          (%i3) [aa, 1729, aa + 1729];
          (%o3)                 [aa, 1729, aa + 1729]
          (%i4) grind (%);
          [aa,1729,aa+1729]$
          (%o4)                         done
          (%i5) matrix ([aa, 17], [29, bb]);
                                     [ aa  17 ]
          (%o5)                      [        ]
                                     [ 29  bb ]
          (%i6) grind (%);
          matrix([aa,17],[29,bb])$
          (%o6)                         done
          (%i7) set (aa, 17, 29, bb);
          (%o7)                   {17, 29, aa, bb}
          (%i8) grind (%);
          {17,29,aa,bb}$
          (%o8)                         done
          (%i9) exp (aa / (bb + 17)^29);
                                          aa
                                      -----------
                                               29
                                      (bb + 17)
          (%o9)                     %e
          (%i10) grind (%);
          %e^(aa/(bb+17)^29)$
          (%o10)                        done
          (%i11) expr: expand ((aa + bb)^10);
                   10           9        2   8         3   7         4   6
          (%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
                   5   5         6   4         7   3        8   2
           + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
                  9        10
           + 10 aa  bb + aa
          (%i12) grind (expr);
          bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
               +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
               +10*aa^9*bb+aa^10$
          (%o12)                        done
          (%i13) string (expr);
          (%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
          +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
          bb+aa^10
          (%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
            p : makelist (0, i, 1, length (A))], for i thru n do
            for j : i thru n do
            (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1),
            if i = j then p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]),
            for i thru n do L[i, i] : 1 / p[i],
            for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
          (%i15) grind (cholesky);
          cholesky(A):=block(
                   [n:length(A),L:copymatrix(A),
                    p:makelist(0,i,1,length(A))],
                   for i thru n do
                       (for j from i thru n do
                            (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                             if i = j then p[i]:1/sqrt(x)
                                 else L[j,i]:x*p[i])),
                   for i thru n do L[i,i]:1/p[i],
                   for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
          (%o15)                        done
          (%i16) string (fundef (cholesky));
          (%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
          t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
          [i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
          ) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
          n do (for j from i+1 thru n do L[i,j]:0),L)

 -- オプション変数: ibase
     デフォルト値: ‘10’

     ‘ibase’は Maximaが読む整数の基数です。

     ‘ibase’は2から(十進数で)36までの任意の整数を割り当てられます。
     ‘ibase’が10よりも大きい時、 数値は十進数字0から9に加えて、 ‘ibase’デ
     ィジットに必要なアルファベットA, B, C, …で構成されます。 最初のディ
     ジットが0から9の時だけ文字はディジットとして解釈されます。 大文字小
     文字は区別されません。 許容される最も大きな基数36の数値は0から9まで
     とAからZまでから構成されます。

     ‘ibase’の値がいくつでも、 整数が小数点で終了する時は基数10として解
     釈されます。

     ‘obase’も参照してください。

     例:

     ‘ibase’ less than 10.

          (%i1) ibase : 2 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1111111111111111;
          (%o3)                         65535

     10より大きな‘ibase’。 最初のディジットが0から9までの時だけ文字はデ
     ィジットとして解釈されます。

          (%i1) ibase : 16 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1000;
          (%o3)                         4096
          (%i4) abcd;
          (%o4)                         abcd
          (%i5) symbolp (abcd);
          (%o5)                         true
          (%i6) 0abcd;
          (%o6)                         43981
          (%i7) symbolp (0abcd);
          (%o7)                         false

     整数が小数点で終了する時、基数10として解釈されます。

          (%i1) ibase : 36 $
          (%i2) obase;
          (%o2)                          10
          (%i3) 1234;
          (%o3)                         49360
          (%i4) 1234.;
          (%o4)                         1234

 -- 関数: ldisp (<expr_1>, …, <expr_n>)

     式<expr_1>, ..., <expr_n>をコンソールに印刷出力として表示します。
     ‘ldisp’は 引数それぞれに中間式ラベルを割り当て、ラベルのリストを返
     します。

     ‘disp’, ‘display’, ‘ldisplay’も参照してください。

     例:

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisp (e, f);
                                             3
          (%t3)                       (b + a)

                               3        2      2      3
          (%t4)               b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                             3
          (%o4)                       (b + a)
          (%i5) %t4;
                               3        2      2      3
          (%o5)               b  + 3 a b  + 3 a  b + a

 -- 関数: ldisplay (<expr_1>, …, <expr_n>)

     式<expr_1>, ..., <expr_n>をコンソールに印刷出力として表示します。 式
     それぞれは、 ‘lhs’が‘ldisplay’の引数の１つで、‘rhs’がその値の、 形
     式‘lhs = rhs’の等式として表示されます。 典型的には引数それぞれは変
     数です。 ‘ldisp’は式それぞれに中間式ラベルを割り当て、ラベルのリス
     トを返します。

     ‘display’, ‘disp’も参照してください。

     例:

          (%i1) e: (a+b)^3;
                                             3
          (%o1)                       (b + a)
          (%i2) f: expand (e);
                               3        2      2      3
          (%o2)               b  + 3 a b  + 3 a  b + a
          (%i3) ldisplay (e, f);
                                               3
          (%t3)                     e = (b + a)

                                 3        2      2      3
          (%t4)             f = b  + 3 a b  + 3 a  b + a

          (%o4)                      [%t3, %t4]
          (%i4) %t3;
                                               3
          (%o4)                     e = (b + a)
          (%i5) %t4;
                                 3        2      2      3
          (%o5)             f = b  + 3 a b  + 3 a  b + a

 -- オプション変数: linel
     デフォルト値: ‘79’

     ‘linel’はコンソールディスプレイの仮定された(文字単位の)幅です。
     ‘linel’はユーザーによって任意の値に割り当てられます。 非常に小さい
     値や非常に大きな値は実用的ではありませんが。 エラーメッセージや
     ‘describe’の出力のように、 Maximaの組み込み関数が表示するテキストは
     ‘linel’の影響を受けません。

 -- オプション変数: lispdisp
     デフォルト値: ‘false’

     ‘lispdisp’が‘true’の時、 Lispシンボルはクエスチョンマーク‘?’を先頭
     文字として表示されます。 そうでなければ、Lispシンボルは先頭文字を持
     ちません。

     例:

          (%i1) lispdisp: false$
          (%i2) ?foo + ?bar;
          (%o2)                       foo + bar
          (%i3) lispdisp: true$
          (%i4) ?foo + ?bar;
          (%o4)                      ?foo + ?bar

 -- オプション変数: negsumdispflag
     デフォルト値: ‘true’

     ‘negsumdispflag’が‘true’の時、 ‘x - y’は ‘- y + x’でなく‘x - y’と表
     示されます。 ‘false’に設定すると、 ２つの式の違いに関する表示での特
     殊なチェックがされないようになります。 １つの応用は、例えば、‘a +
     %i*b’と‘a - %i*b’を同じ表示にすることです。

 -- オプション変数: obase
     デフォルト値: ‘10’

     ‘obase’はMaximaが表示する整数の基数です。

     ‘obase’は2から(十進数で)36までの任意の整数を割り当てられます。
     ‘obase’が10よりも大きい時、 数値は十進数字0から9に加えて、 必要な大
     文字アルファベットA, B, C, ...で構成されます。 もし先頭ディジットが
     そうでなければ文字なら、0ディジットが先頭に表示されます。 許容され
     る最も大きな基数36の数値は0から9までとAからZまでから構成されます。

     ‘ibase’も参照してください。

     例:

          (%i1) obase : 2;
          (%o1)                          10
          (%i2) 2^8 - 1;
          (%o10)                      11111111
          (%i3) obase : 8;
          (%o3)                          10
          (%i4) 8^8 - 1;
          (%o4)                       77777777
          (%i5) obase : 16;
          (%o5)                          10
          (%i6) 16^8 - 1;
          (%o6)                       0FFFFFFFF
          (%i7) obase : 36;
          (%o7)                          10
          (%i8) 36^8 - 1;
          (%o8)                       0ZZZZZZZZ

 -- オプション変数: pfeformat
     デフォルト値: ‘false’

     ‘pfeformat’が‘true’の時、 整数の比は斜線（スラッシュ）文字で表示さ
     れ、 整数分母‘n’は掛け算項‘1/n’として先に表示されます。

          (%i1) pfeformat: false$
          (%i2) 2^16/7^3;
                                        65536
          (%o2)                         -----
                                         343
          (%i3) (a+b)/8;
                                        b + a
          (%o3)                         -----
                                          8
          (%i4) pfeformat: true$
          (%i5) 2^16/7^3;
          (%o5)                       65536/343
          (%i6) (a+b)/8;
          (%o6)                      1/8 (b + a)

 -- オプション変数: powerdisp
     デフォルト値: ‘false’

     ‘powerdisp’が‘true’の時、 べきを増やす順に項を使って和が表示されま
     す。 例えば、 多項式は切り詰められたべき級数として表示され、 最初に
     定数項最後に最高次項となります。

     デフォルトでは和の項はべきを減らす順に表示されます。

 -- 関数: print (<expr_1>, …, <expr_n>)

     <expr_1>, …, <expr_n>を１つ１つ、左から右へ評価し、 コンソールディ
     スプレイの左端から表示します。

     ‘print’が返す値は最後の引数の値です。 ‘print’は中間式ラベルを生成し
     ません。

     ‘display’, ‘disp’, ‘ldisplay’, ‘ldisp’も参照してください。 これらの
     関数は一行ずつ１つの式を表示しますが、 ‘print’は一行に２つ以上の式
     を表示しようとします。

     ファイルの中身を表示するには ‘printfile’を参照してください。

     例:

          (%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                      3        2      2      3
          (a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is

                                                        10 log(a) - log(b)
          (%i2) r;
          (%o2)                  10 log(a) - log(b)
          (%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
                radcan (log (a^10/b)))$
                                     (a+b)^3 is

                               3        2      2      3
                              b  + 3 a b  + 3 a  b + a

                                   log (a^10/b) is

                                 10 log(a) - log(b)

 -- オプション変数: sqrtdispflag
     デフォルト値: ‘true’

     ‘sqrtdispflag’が‘false’の時、 ‘sqrt’を指数1/2で表示するようにします
     。

 -- オプション変数: stardisp
     デフォルト値: ‘false’

     ‘stardisp’が‘true’の時 掛け算はオペランドの間のアスタリスク‘*’で表
     示されます。

 -- オプション変数: ttyoff
     デフォルト値: ‘false’

     ‘ttyoff’が‘true’の時、 出力式は表示されません。 出力式は計算され、
     ラベルに割り当てられます。 ‘labels’を参照してください。

     エラーメッセージや‘describe’の出力のように、組み込みMaxima関数によ
     って出力されたテキストは ‘ttyoff’の影響を受けません。


File: maxima.info,  Node: Data Types and Structures,  Next: Expressions,  Prev: Command Line,  Up: Top

5 Data Types and Structures
***************************

* Menu:

* Numbers::
* Strings::
* Constants::
* Lists::
* Arrays::
* Structures::


File: maxima.info,  Node: Numbers,  Next: Strings,  Prev: Data Types and Structures,  Up: Data Types and Structures

5.1 Numbers
===========

* Menu:

* Introduction to Numbers::
* Functions and Variables for Numbers::


File: maxima.info,  Node: Introduction to Numbers,  Next: Functions and Variables for Numbers,  Prev: Numbers,  Up: Numbers

5.1.1 Introduction to Numbers
-----------------------------

Complex numbers
---------------

Maximaでは複素数式を式の実部と‘%i’かける虚部の足し算で指定します。 例え
ば、等式 ‘x^2 - 4*x + 13 = 0’の根は ‘2 + 3*%i’と ‘2 - 3*%i’です。 複素数
式の積の整理は積を展開することで影響を受けるかもしれないことに注意してく
ださい。 複素数式の商や根、他の関数の整理は普通、 ‘realpart’,
‘imagpart’, ‘rectform’, ‘polarform’, ‘abs’, ‘carg’関数を使って達成するこ
とができます。


File: maxima.info,  Node: Functions and Variables for Numbers,  Prev: Introduction to Numbers,  Up: Numbers

5.1.2 Functions and Variables for Numbers
-----------------------------------------

 -- 関数: bfloat (<expr>)
     <expr>の中のすべての数や数の関数を多倍長浮動小数点に変換します。 戻
     り値の多倍長浮動小数点の有効桁数は、 グローバル変数‘fpprec’によって
     規定されます。

     ‘float2bf’が‘false’の場合、 浮動小数点が多倍長浮動小数点に変換され
     る時 （精度が落ちることを意味するので）警告メッセージが出力されます
     。

 -- 関数: bfloatp (<expr>)

     もし<expr>が多倍長浮動小数点数なら‘true’を、そうでなければ‘false’を
     返します。

 -- オプション変数: bftorat
     デフォルト値: ‘false’

     ‘bftorat’は多倍長浮動小数点の有理数への変換を制御します。
     ‘bftorat’が‘false’の時、 ‘ratepsilon’が変換を制御するのに使われます
     。 (これは比較的小さな有理数になります。) ‘bftorat’が‘true’の時、 生
     成された有理数は多倍長浮動小数点を正確に表します。

 -- オプション変数: bftrunc
     デフォルト値: ‘true’

     ‘bftrunc’は、非ゼロの多倍長浮動小数点数の中のずるずる続くゼロを表示
     しないようにします。 例えば、もし‘bftrunc’が‘false’なら、 ‘bfloat
     (1)’は‘1.000000000000000B0’と表示されます。 そうでなければ、これは
     、‘1.0B0’と表示されます。

 -- 関数: evenp (<expr>)

     もし<expr>が偶数なら‘true’を返します。 他の場合には‘false’を返しま
     す。

 -- 関数: float (<expr>)

     <expr>の中の整数、有理数、多倍長浮動小数点を浮動小数点に変換します
     。 ‘float’は‘evflag’でもあり、 非整数有理数と多倍長浮動小数点を浮動
     小数点に変換します。

 -- オプション変数: float2bf
     デフォルト値: ‘true’

     ‘float2bf’が‘false’の場合、 浮動小数点が多倍長浮動小数点に変換され
     る時、 （これは精度の無駄使いとなるかもしれないので、） 警告メッセ
     ージが表示されます。 デフォルト値は‘true’です。

 -- 関数: floatnump (<expr>)
     もし<expr>が浮動小数点なら ‘true’を返し、そうでないなら ‘false’を返
     します。

 -- オプション変数: fpprec
     デフォルト値: 16

     ‘fpprec’は多倍長浮動小数点上の代数のための有効桁数です。 ‘fpprec’は
     通常の浮動小数点上の計算に影響を与えません。

     ‘bfloat’と‘fpprintprec’も参照してください。

 -- オプション変数: fpprintprec
     デフォルト値: 0

     ‘fpprintprec’は、通常の浮動小数点もしくは多倍長浮動小数点を表示する
     時の 表示する桁数です。

     通常の浮動小数点に関しては、 ‘fpprintprec’が2から16までの値を持つ時
     、 表示されるディジット数は‘fpprintprec’に等しいです。 そうでなけれ
     ば、‘fpprintprec’は0もしくは16より大きく、 表示されるディジット数は
     16です。

     多倍長浮動小数点に関しては、 ‘fpprintprec’が2から‘fpprec’までの値を
     持つ時、 表示される桁数は、‘fpprintprec’に等しいです。 そうでなけれ
     ば、‘fpprintprec’は、0もしくは‘fpprec’より大きく、 表示される桁数は
     ‘fpprec’に等しいです。

     ‘fpprintprec’は1にはできません。

 -- 関数: integerp (<expr>)
     もし<expr>が整数リテラルなら ‘true’を、 そうでないなら ‘false’を返
     します。

     もし引数がシンボルならたとえ引数が宣言された整数でも、 ‘integerp’は
     ‘false’を返します。

     例:

          (%i1) integerp (0);
          (%o1)                         true
          (%i2) integerp (1);
          (%o2)                         true
          (%i3) integerp (-17);
          (%o3)                         true
          (%i4) integerp (0.0);
          (%o4)                         false
          (%i5) integerp (1.0);
          (%o5)                         false
          (%i6) integerp (%pi);
          (%o6)                         false
          (%i7) integerp (n);
          (%o7)                         false
          (%i8) declare (n, integer);
          (%o8)                         done
          (%i9) integerp (n);
          (%o9)                         false

 -- オプション変数: m1pbranch
     デフォルト値: ‘false’

     ‘m1pbranch’は ‘-1’のべき乗の主枝です。 ‘(-1)^(1/3)’(すなわち、「奇
     」の有理指数)や ‘(-1)^(1/4)’(すなわち、「偶」の有理指数) のような量
     は以下のように扱われます:
                        domain:real

          (-1)^(1/3):      -1
          (-1)^(1/4):   (-1)^(1/4)

                       domain:complex
          m1pbranch:false          m1pbranch:true
          (-1)^(1/3)               1/2+%i*sqrt(3)/2
          (-1)^(1/4)              sqrt(2)/2+%i*sqrt(2)/2

 -- 関数: nonnegintegerp (<n>)

     ‘<n> >= 0’かつ <n>が整数の時だけ‘true’を返します。

 -- 関数: numberp (<expr>)

     もし<expr>が文字リテラルか、有理数か、浮動小数点数か、多倍長浮動小
     数点なら ‘true’を、 そうでなければ ‘false’を返します。

     もし引数がシンボルなら、 たとえ引数が‘%pi’や‘%i’のようなシンボリッ
     クな数でも、また、 ‘even’, ‘odd’, ‘integer’, ‘rational’,
     ‘irrational’, ‘real’, ‘imaginary’, ‘complex’のいずれかに宣言されて
     いても、 ‘numberp’は ‘false’を返します。

     例:

          (%i1) numberp (42);
          (%o1)                         true
          (%i2) numberp (-13/19);
          (%o2)                         true
          (%i3) numberp (3.14159);
          (%o3)                         true
          (%i4) numberp (-1729b-4);
          (%o4)                         true
          (%i5) map (numberp, [%e, %pi, %i, %phi, inf, minf]);
          (%o5)      [false, false, false, false, false, false]
          (%i6) declare (a, even, b, odd, c, integer, d, rational,
               e, irrational, f, real, g, imaginary, h, complex);
          (%o6)                         done
          (%i7) map (numberp, [a, b, c, d, e, f, g, h]);
          (%o7) [false, false, false, false, false, false, false, false]

 -- 特殊シンボル: numer

     ‘numer’は数値の引数を持つ（指数関数を含む）いくつかの数学関数を 浮
     動小数点に評価するようにします。 数値が与えられた‘expr’の中の変数を
     値に置き換えるようにします。 それは ‘float’スイッチをオンにもします
     。

     ‘%enumer’も参照してください。

     例:

          (%i1) [sqrt(2), sin(1), 1/(1+sqrt(3))];
                                                  1
          (%o1)            [sqrt(2), sin(1), -----------]
                                             sqrt(3) + 1
          (%i2) [sqrt(2), sin(1), 1/(1+sqrt(3))],numer;
          (%o2) [1.414213562373095, .8414709848078965, .3660254037844387]

 -- オプション変数: numer_pbranch
     デフォルト値: ‘false’

     オプション変数‘numer_pbranch’は 負の整数、有理数、または浮動小数点
     数のべきの数値評価を制御します。 ‘numer_pbranch’が‘true’でかつ、指
     数が浮動小数点数であるか オプション変数‘numer’も‘true’の時、
     Maximaは主枝を使って数値結果を評価します。 そうでなければ、式整理さ
     れたが未評価の結果が返されます。

     例:

          (%i1) (-2)^0.75;
          (%o1) (-2)^0.75

          (%i2) (-2)^0.75,numer_pbranch:true;
          (%o2) 1.189207115002721*%i-1.189207115002721

          (%i3) (-2)^(3/4);
          (%o3) (-1)^(3/4)*2^(3/4)

          (%i4) (-2)^(3/4),numer;
          (%o4) 1.681792830507429*(-1)^0.75

          (%i5) (-2)^(3/4),numer,numer_pbranch:true;
          (%o5) 1.189207115002721*%i-1.189207115002721

 -- 関数: numerval (<x_1>, <expr_1>, …, <x_n>, <expr_n>)
     変数‘x_1’, …, ‘x_n’を ‘expr_1’, …, ‘expr_n’に等しい数値を持つ変数だ
     と宣言します。 もし ‘numer’フラグが ‘true’なら、 変数が現れる任意の
     式にて、数値は評価され、変数に代入されます。 ‘ev’も参照してください
     。

     式‘expr_1’, …, ‘expr_n’は、任意の式を取り得ます。数値である必要はあ
     りません。

 -- 関数: oddp (<expr>)
     もしも<exp>が奇数であれば‘true’を返し、 それ以外では‘false’を返しま
     す。

 -- オプション変数: ratepsilon
     デフォルト値: 2.0e-8

     ‘ratepsilon’は浮動小数点数を有理数に変換する際に使われる許容誤差で
     す。

 -- 関数: rationalize (<expr>)

     Maximaの式<expr>の中の倍精度浮動小数点やビッグフローすべてを同値の
     有理数に変換します。 もし浮動小数点の２値表現に詳しくなれば、
     ‘rationalize (0.1)’が1/10に等しくないことに 驚くかもしれません。 こ
     の振る舞いはMaximaに特別なわけではありません。―1/10は２値の循環小数
     表現を持ちます。

          (%i1) rationalize (0.5);
                                          1
          (%o1)                           -
                                          2
          (%i2) rationalize (0.1);
                                         1
          (%o2)                          --
                                         10
          (%i3) fpprec : 5$
          (%i4) rationalize (0.1b0);
                                       209715
          (%o4)                        -------
                                       2097152
          (%i5) fpprec : 20$
          (%i6) rationalize (0.1b0);
                               236118324143482260685
          (%o6)                ----------------------
                               2361183241434822606848
          (%i7) rationalize (sin (0.1*x + 5.6));
                                        x    28
          (%o7)                     sin(-- + --)
                                        10   5

     使用例:

          (%i1) unitfrac(r) := block([uf : [], q],
              if not(ratnump(r)) then
                 error("The input to 'unitfrac' must be a rational number"),
              while r # 0 do (
                  uf : cons(q : 1/ceiling(1/r), uf),
                  r : r - q),
              reverse(uf))$
          (%o1) unitfrac(r) := block([uf : [], q],
          if not ratnump(r) then
             error("The input to 'unitfrac' must be a rational number"),
                                            1
          while r # 0 do (uf : cons(q : ----------, uf), r : r - q),
                                                1
                                        ceiling(-)
                                                r
          reverse(uf))
          (%i2) unitfrac (9/10);
                                      1  1  1
          (%o2)                      [-, -, --]
                                      2  3  15
          (%i3) apply ("+", %);
                                         9
          (%o3)                          --
                                         10
          (%i4) unitfrac (-9/10);
                                            1
          (%o4)                       [- 1, --]
                                            10
          (%i5) apply ("+", %);
                                          9
          (%o5)                         - --
                                          10
          (%i6) unitfrac (36/37);
                                  1  1  1  1    1
          (%o6)                  [-, -, -, --, ----]
                                  2  3  8  69  6808
          (%i7) apply ("+", %);
                                         36
          (%o7)                          --
                                         37

 -- 関数: ratnump (<expr>)
     もし<expr>が整数リテラルもしくは整数リテラルの比なら ‘true’を返し、
     そうでなければ ‘false’を返します。


File: maxima.info,  Node: Strings,  Next: Constants,  Prev: Numbers,  Up: Data Types and Structures

5.2 Strings
===========

* Menu:

* Introduction to Strings::
* Functions and Variables for Strings::


File: maxima.info,  Node: Introduction to Strings,  Next: Functions and Variables for Strings,  Prev: Strings,  Up: Strings

5.2.1 Introduction to Strings
-----------------------------

文字列(クォートされた文字の列)は入力の際にはダブルクォートマーク ‘"’で括
り、 グローバル変数 ‘stringdisp’に依存して、クォートマークありだったりな
しだったりで 表示されます。

   文字列は、埋め込みタブ、改行、キャリッジリターン文字を含む任意の文字
を含み得ます。 列 ‘\"’は文字通りダブルクォートとして認識され、 ‘\\’は文
字通りバックスラッシュとして認識されます。 バックスラッシュが行の終わり
に現れる時、 バックスラッシュと(改行かキャリッジリターンと改行かいずれか
の)行終端を無視します。 そして、文字列は次の行に続きます。 他にバックス
ラッシュともう一つの文字の組み合わせで特殊なものはありません; ‘"’か,
‘\’, 行終端以外の任意の文字の前にバックスラッシュが現れる時、 バックスラ
ッシュは無視されます。 文字列の中に文字リテラルを埋め込むことを除いて (タ
ブ、改行、キャリッジリターンのような)特殊文字を表す方法はありません。

   Maximaでは文字タイプはありません; 文字単体は1文字の文字列として表され
ます。

   ‘stringproc’アドオンパッケージは文字列に機能する多くの関数を含みます
。

   例:

     (%i1) s_1 : "This is a string.";
     (%o1)               This is a string.
     (%i2) s_2 : "Embedded \"double quotes\" and backslash \\ characters.";
     (%o2) Embedded "double quotes" and backslash \ characters.
     (%i3) s_3 : "Embedded line termination
     in this string.";
     (%o3) Embedded line termination
     in this string.
     (%i4) s_4 : "Ignore the \
     line termination \
     characters in \
     this string.";
     (%o4) Ignore the line termination characters in this string.
     (%i5) stringdisp : false;
     (%o5)                         false
     (%i6) s_1;
     (%o6)                   This is a string.
     (%i7) stringdisp : true;
     (%o7)                         true
     (%i8) s_1;
     (%o8)                  "This is a string."


File: maxima.info,  Node: Functions and Variables for Strings,  Prev: Introduction to Strings,  Up: Strings

5.2.2 Functions and Variables for Strings
-----------------------------------------

 -- 関数: concat (<arg_1>, <arg_2>, …)

     引数を連結します。 引数はアトムに評価されなければいけません。 もし
     最初の引数がシンボルなら戻り値はシンボルで、 そうでなければ文字列で
     す。

     ‘concat’は引数を評価します。 シングルクォート‘'’は評価を抑制します
     。

          (%i1) y: 7$
          (%i2) z: 88$
          (%i3) concat (y, z/2);
          (%o3)                          744
          (%i4) concat ('y, z/2);
          (%o4)                          y44

     ‘concat’によって組み立てられたシンボルは値に割り当てられたり、式の
     中に現れたりします。 ‘::’ (ダブルコロン)割り当て演算子は左辺を評価
     します。

          (%i5) a: concat ('y, z/2);
          (%o5)                          y44
          (%i6) a:: 123;
          (%o6)                          123
          (%i7) y44;
          (%o7)                          123
          (%i8) b^a;
                                         y44
          (%o8)                         b
          (%i9) %, numer;
                                         123
          (%o9)                         b

     ‘concat (1, 2)’は数のように見えますが、文字列であることに注意してく
     ださい。

          (%i10) concat (1, 2) + 3;
          (%o10)                       12 + 3

 -- 関数: sconcat (<arg_1>, <arg_2>, ...)

     引数を文字列に連結します。 ‘concat’と違い、引数はアトムである必要は
     ありません。

          (%i1) sconcat ("xx[", 3, "]:", expand ((x+y)^3));
          (%o1)               xx[3]:y^3+3*x*y^2+3*x^2*y+x^3

 -- 関数: string (<expr>)

     ‘expr’を、ただまるでタイプされたようにMaximaの線形表記に変換します
     。

     ‘string’の戻り値は文字列であり、 計算の中で使うことはできません。

 -- オプション変数: stringdisp
     デフォルト値: ‘false’

     ‘stringdisp’が‘true’の時、 文字列はダブルクォートマークで囲まれて表
     示されます。 そうでなければクォートマークは表示されません。

     関数定義を表示する時はいつも、‘stringdisp’は ‘true’です。

     例:

          (%i1) stringdisp: false$
          (%i2) "This is an example string.";
          (%o2)              This is an example string.
          (%i3) foo () :=
                print ("This is a string in a function definition.");
          (%o3) foo() :=
                        print("This is a string in a function definition.")
          (%i4) stringdisp: true$
          (%i5) "This is an example string.";
          (%o5)             "This is an example string."


File: maxima.info,  Node: Constants,  Next: Lists,  Prev: Strings,  Up: Data Types and Structures

5.3 Constants
=============

* Menu:

* Functions and Variables for Constants::


File: maxima.info,  Node: Functions and Variables for Constants,  Prev: Constants,  Up: Constants

5.4 Functions and Variables for Constants
=========================================

 -- 定数: %e
     ‘%e’はEuler数としても知られる自然対数の基数を表します。 ‘%e’の数値
     は倍精度浮動小数点数2.718281828459045d0です。

 -- 定数: %i

     ‘%i’は虚数単位sqrt(- 1)を表します。

 -- 定数: false

     ‘false’は同じ名前のブーリアン定数を表します。 Maximaは、Lispの値
     ‘NIL’で‘false’を実装しています。

 -- 定数: %gamma

     Euler-Macheroni定数0.5772156649015329 ....

 -- 定数: ind

     ‘ind’は有界で不定の結果を表します。

     ‘limit’も参照してください。

     例:

          (%i1) limit (sin(1/x), x, 0);
          (%o1)                          ind

 -- 定数: inf

     ‘inf’は実数の正の無限大を表します。

 -- 定数: infinity

     ‘infinity’は複素数の無限大を表します。

 -- 定数: minf

     ‘minf’は実数のマイナスの（すなわち負の）無限大を表します。

 -- 定数: %phi

     ‘%phi’は黄金比と呼ばれる(1 + sqrt(5))/2を表します。 ‘%phi’の数値は
     倍精度浮動小数点数1.618033988749895d0です。

     ‘fibtophi’は、‘%phi’を使って フィボナッチ数‘fib(n)’を表現します。

     デフォルトでは、Maximaは ‘%phi’の代数的プロパティを知りません。
     ‘tellrat(%phi^2 - %phi - 1)’と‘algebraic: true’を評価した後、
     ‘ratsimp’は ‘%phi’を含むいくつかの式を整理できます。

     例:

     ‘fibtophi’は、‘%phi’を使って フィボナッチ数‘fib(n)’を表現します。

          (%i1) fibtophi (fib (n));
                                     n             n
                                 %phi  - (1 - %phi)
          (%o1)                  -------------------
                                     2 %phi - 1
          (%i2) fib (n-1) + fib (n) - fib (n+1);
          (%o2)          - fib(n + 1) + fib(n) + fib(n - 1)
          (%i3) fibtophi (%);
                      n + 1             n + 1       n             n
                  %phi      - (1 - %phi)        %phi  - (1 - %phi)
          (%o3) - --------------------------- + -------------------
                          2 %phi - 1                2 %phi - 1
                                                    n - 1             n - 1
                                                %phi      - (1 - %phi)
                                              + ---------------------------
                                                        2 %phi - 1
          (%i4) ratsimp (%);
          (%o4)                           0

     デフォルトでは、Maximaは ‘%phi’の代数的プロパティを知りません。
     ‘tellrat(%phi^2 - %phi - 1)’と‘algebraic: true’を評価した後、
     ‘ratsimp’は ‘%phi’を含むいくつかの式を整理できます。

          (%i1) e : expand ((%phi^2 - %phi - 1) * (A + 1));
                           2                      2
          (%o1)        %phi  A - %phi A - A + %phi  - %phi - 1
          (%i2) ratsimp (e);
                            2                     2
          (%o2)        (%phi  - %phi - 1) A + %phi  - %phi - 1
          (%i3) tellrat (%phi^2 - %phi - 1);
                                      2
          (%o3)                  [%phi  - %phi - 1]
          (%i4) algebraic : true;
          (%o4)                         true
          (%i5) ratsimp (e);
          (%o5)                           0

 -- 定数: %pi

     ‘%pi’は直径に体する円周の比を表します。 ‘%pi’の数値は倍精度浮動小数
     点数3.141592653589793d0です。

 -- 定数: true

     ‘true’は同じ名前のブーリアン定数を表します。 MaximaはLispの値‘T’で
     ‘true’を実装しています。

 -- 定数: und

     ‘und’は未定義の結果を表します。

     ‘limit’も参照してください。

     例:

          (%i1) limit (x*sin(x), x, inf);
          (%o1)                          und

 -- 定数: zeroa

     ‘zeroa’はゼロの上の無限小を表します。 ‘zeroa’は式の中で使うことがで
     きます。 ‘limit’は無限小を含む式を整理します。

     ‘zerob’と‘limit’も参照してください。

     例:

     ‘limit’は無限小を含む式を整理します:

          (%i1) limit(zeroa);
          (%o1)                           0
          (%i2) limit(x+zeroa);
          (%o2)                           x

 -- 定数: zerob

     ‘zerob’はゼロの下の無限小を表します。 ‘zerob’は式の中で使うことがで
     きます。 ‘limit’は無限小を含む式を整理します。

     ‘zeroa’と‘limit’も参照してください。


File: maxima.info,  Node: Lists,  Next: Arrays,  Prev: Constants,  Up: Data Types and Structures

5.5 Lists
=========

* Menu:

* Introduction to Lists::
* Functions and Variables for Lists::


File: maxima.info,  Node: Introduction to Lists,  Next: Functions and Variables for Lists,  Prev: Lists,  Up: Lists

5.5.1 Introduction to Lists
---------------------------

リストはMaximaとLispにとって基本的な構成要素です。 配列、ハッシュテーブ
ル、数以外のデータタイプすべてはLispのリストとして表現されます。 これら
のLispのリストは 式 ‘a+2’を示すために以下の形式を取ります。

     ((MPLUS) $A 2)

   Maximaレベルでは中置表記‘a+2’を見ることになるでしょう。 Maximaには、
以下のようにプリントされるリストもあります。

     [1, 2, 7, x+y]

これは4要素のリストの場合の例です。 内部的には、これは以下の形式のLispの
リストに対応します。

     ((MLIST) 1  2  7  ((MPLUS)  $X $Y ))

   Maxima式のタイプフィールドを意味するフラグはそれ自体リストです。 整理
器を通った後、上のリストは以下のようになるでしょう。

     ((MLIST SIMP) 1 2 7 ((MPLUS SIMP) $X $Y))


File: maxima.info,  Node: Functions and Variables for Lists,  Prev: Introduction to Lists,  Up: Lists

5.5.2 Functions and Variables for Lists
---------------------------------------

 -- 特殊シンボル: [
 -- 特殊シンボル: ]

     先頭が‘[’で終わりが‘]’のマークはリストです。

     ‘[’と‘]’は、リスト、配列、ハッシュ配列、配列関数の添字もくくります
     。

     例:

          (%i1) x: [a, b, c];
          (%o1)                       [a, b, c]
          (%i2) x[3];
          (%o2)                           c
          (%i3) array (y, fixnum, 3);
          (%o3)                           y
          (%i4) y[2]: %pi;
          (%o4)                          %pi
          (%i5) y[2];
          (%o5)                          %pi
          (%i6) z['foo]: 'bar;
          (%o6)                          bar
          (%i7) z['foo];
          (%o7)                          bar
          (%i8) g[k] := 1/(k^2+1);
                                            1
          (%o8)                     g  := ------
                                     k     2
                                          k  + 1
          (%i9) g[10];
                                          1
          (%o9)                          ---
                                         101

 -- 関数: append (<list_1>, …, <list_n>)
     <list_1>の要素のあとに <list_2>の要素が続き、… という１つのリストを
     返します。 ‘append’は一般式上でも機能します。 例えば、 ‘append
     (f(a,b), f(c,d,e));’は ‘f(a,b,c,d,e)’をもたらします。

     例を見るには、 ‘example(append);’を実行してください。

 -- 関数: assoc (<key>, <list>, <default>)
 -- 関数: assoc (<key>, <list>)

     この関数は 形式 ‘[x,y,z,...]’の入力 <list>の左辺の中で <key>を探し
     ます。 ここで <list>の要素のそれぞれは二項演算子と２つの要素の式で
     す。 例えば、 ‘x=1’, ‘2^3’, ‘[a,b]’など。 最初のオペランドに対して
     <key>がチェックされます。 もし ‘key’が見つかったら、 ‘assoc’は二番
     目のオペランドを返します。 もし ‘key’が見つからなかったら、
     <default>値を返します。 <default>はオプションで、省略すると
     ‘false’に設定されます。

 -- 関数: cons (<expr>, <list>)

     最初の要素として要素 <expr>で構成され、 <list>の要素が続く新しいリ
     ストを返します。 ‘cons’は他の式上でも機能します。 例えば、 ‘cons(x,
     f(a,b,c));’ -> ‘f(x,a,b,c)’。

 -- 関数: copylist (<list>)

     リスト <list>のコピーを返します。

 -- 関数: create_list (<form>, <x_1>, <list_1>, …, <x_n>, <list_n>)

     <list_1>の要素それぞれにバインドされた <x_1>で、 また、それぞれのバ
     インドに対して、 <x_2>を <list_2>の要素それぞれにバインドして、...
     それらのバインドを使って <form>を評価することによって リストを生成
     します。 結果の要素の数はそれぞれのリストの要素の数の積です。 それ
     ぞれの変数 <x_i>は実際に、シンボルでなければいけません。ーそれは評
     価されません。 リスト引数は繰り返しの始めに一度だけ評価されます。

          (%i1) create_list(x^i,i,[1,3,7]);
                           3   7
          (%o1)       [x, x , x ]

     二重の繰り返しで:

          (%i1) create_list([i,j],i,[a,b],j,[e,f,h]);
          (%o1) [[a, e], [a, f], [a, h], [b, e], [b, f], [b, h]]

     <list_i>の代わりに、 それぞれが数に評価される２つの引数を供給するこ
     ともできます。 これらは繰り返しの下限と上限になります。

          (%i1) create_list([i,j],i,[1,2,3],j,1,i);
          (%o1) [[1, 1], [2, 1], [2, 2], [3, 1], [3, 2], [3, 3]]

     ‘j’変数の範囲やリストは ‘i’の現在値に依存することができることに注意
     してください。

 -- 関数: delete (<expr_1>, <expr_2>)
 -- 関数: delete (<expr_1>, <expr_2>, <n>)

     ‘delete(<expr_1>, <expr_2>)’は、 <expr_2>から そのトップレベル演算
     子の引数のうち、 <expr_1>と("="で決定される意味で)同じ引数を取り除
     きます。 "="は、同値ではなく、形式的な同一をテストすることに注意し
     てください。 部分式の引数には影響しないことにも注意してください。

     <expr_1>はアトムか、非アトムの式を取り得ます。 <expr_2>は任意の非ア
     トムの式を取り得ます。 ‘delete’は新しい式を返します; <expr_2>を変更
     しません。

     ‘delete(<expr_1>, <expr_2>, <n>)’は、

     <expr_2>から そのトップレベル演算子の引数のうち、 <expr_1>と同じ最
     初の <n>個の引数を取り除きます。 もしそんな引数が <n>個より少ないな
     ら、 該当するすべての引数が取り除かれます。

     例:

     リストから要素を削除。

          (%i1) delete (y, [w, x, y, z, z, y, x, w]);
          (%o1)                  [w, x, z, z, x, w]

     和から項を削除。

          (%i1) delete (sin(x), x + sin(x) + y);
          (%o1)                         y + x

     積から因子を削除。

          (%i1) delete (u - x, (u - w)*(u - x)*(u - y)*(u - z));
          (%o1)                (u - w) (u - y) (u - z)

     任意の式から引数を削除。

          (%i1) delete (a, foo (a, b, c, d, a));
          (%o1)                     foo(b, c, d)

     削除する引数の数を制限。

          (%i1) delete (a, foo (a, b, a, c, d, a), 2);
          (%o1)                    foo(b, c, d, a)

     引数が <expr_1>と同じかどうかは"="で決定されます。 ‘equal’ですが、
     "="でない引数は取り除かれません。

          (%i1) [is(equal(0, 0)), is(equal(0, 0.0)), is(equal(0, 0b0))];

          `rat' replaced 0.0 by 0/1 = 0.0
          `rat' replaced 0.0B0 by 0/1 = 0.0B0
          (%o1)                  [true, true, true]
          (%i2) [is (0 = 0), is (0 = 0.0), is (0 = 0b0)];
          (%o2)                 [true, false, false]
          (%i3) delete (0, [0, 0.0, 0b0]);
          (%o3)                     [0.0, 0.0b0]
          (%i4) is (equal ((x + y)*(x - y), x^2 - y^2));
          (%o4)                         true
          (%i5) is ((x + y)*(x - y) = x^2 - y^2);
          (%o5)                         false
          (%i6) delete ((x + y)*(x - y), [(x + y)*(x - y), x^2 - y^2]);
                                        2    2
          (%o6)                       [x  - y ]

 -- 関数: eighth (<expr>)

     式またはリスト <expr>の8番目の項を返します。 詳細は ‘first’を参照し
     てください。

 -- 関数: endcons (<expr>, <list>)

     <expr>が続く ‘list’の要素から成る新しいリストを返します。
     ‘endcons’は一般式上でも機能します。 例えば、 ‘endcons(x,
     f(a,b,c));’ -> ‘f(a,b,c,x)’。

 -- 関数: fifth (<expr>)

     式またはリスト <expr>の5番目の項を返します。 詳細は ‘first’を参照し
     てください。

 -- 関数: first (<expr>)

     リストの最初の要素、行列の最初の行、和の最初の項などに帰着する、
     <expr>の最初の部分を返します。 ‘first’とその関連関数 ‘rest’と
     ‘last’は、 入力時にタイプした形式ではなく、 <expr>の表示形式上で機
     能することに注意してください。 しかしながら、もし変数 ‘inflag’が
     ‘true’に設定されているなら、 これらの関数は <expr>の内部形式を見ま
     す。 整理器は式を再配置することに注意してください。 例えば、
     ‘first(x+y)’は、 もし ‘inflag’が ‘true’なら ‘x’で、 もし ‘inflag’が
     ‘false’なら ‘y’ です。 (‘first(y+x)’は同じ結果を与えます。) 関数
     ‘second’ ..  ‘tenth’は 入力引数の二番目から十番目の部分をもたらしま
     す。

 -- 関数: fourth (<expr>)

     式またはリスト <expr>の4番目の項を返します。 詳細は ‘first’を参照し
     てください。

 -- 関数: join (<l>, <m>)

     リスト<l>と<m>の要素を交互に含む新しいリストを生成します。 結果は、
     要素 ‘[<l>[1], <m>[1], <l>[2], <m>[2], ...]’を持ちます。 リスト
     <l>と <m>は、任意のタイプの要素を含めます。

     もしリストの長さが違ったら、 ‘join’は長いリストの要素を無視します。

     もし <l>か <m>がリストでなかったら、 Maximaは文句を言います。

     例:

          (%i1) L1: [a, sin(b), c!, d - 1];
          (%o1)                [a, sin(b), c!, d - 1]
          (%i2) join (L1, [1, 2, 3, 4]);
          (%o2)          [a, 1, sin(b), 2, c!, 3, d - 1, 4]
          (%i3) join (L1, [aa, bb, cc, dd, ee, ff]);
          (%o3)        [a, aa, sin(b), bb, c!, cc, d - 1, dd]

 -- 関数: last (<expr>)
     <expr>最後の(項、行、要素など）部分を返します。

 -- 関数: length (<expr>)

     (デフォルトでは) <expr>の外部(表示)形式の部分の数を返します。 リス
     トに関しては、これは要素の数を返し、 行列に関しては行数であり、 和
     に関しては項数です。 (‘dispform’を参照してください。)

     ‘length’コマンドは ‘inflag’スイッチに影響されます。 だから例えば、
     ‘length(a/(b*c));’は、 (‘exptdispflag’が ‘true’と仮定して) もし
     ‘inflag’が ‘false’なら2を与えますが、 もし ‘inflag’が ‘true’なら3を
     与えます。 (内部表現は本質的には ‘a*b^-1*c^-1’です。)

 -- オプション変数: listarith
     デフォルト値: ‘true’ - もし ‘false’なら、 リストを伴う任意の算術演
     算が抑制されるようになります; ‘true’の時、リスト-行列演算では、 リ
     ストが行列に変換されるようになり、いつも行列の結果をもたらすよう連
     鎖します。 しかしながら、リスト-リスト演算はリストを返します。

 -- 関数: listp (<expr>)

     もし <expr>がリストなら ‘true’、 そうでなければ ‘false’を返します。

 -- 関数: makelist (<expr>, <i>, <i_0>, <i_1>)
 -- 関数: makelist (<expr>, <x>, <list>)

     要素それぞれが <expr>から生成されたリストを構成し、返します。

     ‘makelist (<expr>, <i>, <i_0>, <i_1>)’は、 <i_0>から <i_1>に等しい
     ‘j’に対して ‘j’番目の要素が ‘ev (<expr>, <i>=j)’に等しい リストを返
     します。

     ‘makelist (<expr>, <x>, <list>)’は、 1から ‘length (<list>)’に等し
     い ‘j’に対して、 ‘j’番目の要素が ‘ev (<expr>, <x>=<list>[j])’に等し
     い リストを返します。

     例:

          (%i1) makelist(concat(x,i),i,1,6);
          (%o1)               [x1, x2, x3, x4, x5, x6]
          (%i2) makelist(x=y,y,[a,b,c]);
          (%o2)                 [x = a, x = b, x = c]

 -- 関数: member (<expr_1>, <expr_2>)

     もし ‘args(<expr_2>)’の中のある要素<a>に対して ‘is(<expr_1> =
     <a>)’なら ‘true’を返し、 そうでなければ ‘false’を返します。

     ‘expr_2’は通常リストです。 その場合、 ‘args(<expr_2>) = <expr_2>’か
     つ ‘expr_2’の中のある要素 <a>に対して、 ‘is(<expr_1> = <a>)’である
     ことがテストです。

     ‘member’は ‘expr_2’の引数の部分を検査しません。 だから、 たとえ
     ‘expr_1’が ‘expr_2’のある引数の部分であっても ‘false’を返すかもしれ
     ません。

     ‘elementp’も参照してください。

     例:

          (%i1) member (8, [8, 8.0, 8b0]);
          (%o1)                         true
          (%i2) member (8, [8.0, 8b0]);
          (%o2)                         false
          (%i3) member (b, [a, b, c]);
          (%o3)                         true
          (%i4) member (b, [[a, b], [b, c]]);
          (%o4)                         false
          (%i5) member ([b, c], [[a, b], [b, c]]);
          (%o5)                         true
          (%i6) F (1, 1/2, 1/4, 1/8);
                                         1  1  1
          (%o6)                     F(1, -, -, -)
                                         2  4  8
          (%i7) member (1/8, %);
          (%o7)                         true
          (%i8) member ("ab", ["aa", "ab", sin(1), a + b]);
          (%o8)                         true

 -- 関数: ninth (<expr>)

     式またはリスト <expr>の9番目の項を返します。 詳細は ‘first’を参照し
     てください。

 -- 関数: pop (<list>)

     ‘pop’は、リスト <list>から最初の要素を取り除き、この要素を返します
     。 <list>はリストそのものではなく、リストにバインドされたシンボルで
     なければいけません。

     もし引数 <list>がリストにバインドされていないかリストが空なら、
     Maximaはエラーメッセージを生成します。

     例には ‘push’も参照してください。

     ‘load("basic")’はこの関数をロードします。

 -- 関数: push (<item>, <list>)

     ‘push’は項目 <item>をリスト <list>の先頭に追加し、 新しいリストのコ
     ピーを返します。 <list>はリストそのものではなく、リストにバインドさ
     れたシンボルでなければいけません。 <item>は任意のMaximaシンボルや式
     が使えます。

     もし引数 <list>がリストにバインドされていないかリストが空なら、
     Maximaはエラーメッセージを生成します。

     リストから最初の項目を取り除くには ‘pop’も参照してください。

     ‘load("basic")’はこの関数をロードします。

     例:

          (%i1) ll:[];
          (%o1)                          []
          (%i2) push(x,ll);
          (%o2)                          [x]
          (%i3) push(x^2+y,ll);
                                           2
          (%o3)                      [y + x , x]
          (%i4) a:push("string",ll);
                                               2
          (%o4)                  [string, y + x , x]
          (%i5) pop(ll);
          (%o5)                        string
          (%i6) pop(ll);
                                            2
          (%o6)                        y + x
          (%i7) pop(ll);
          (%o7)                           x
          (%i8) ll;
          (%o8)                          []
          (%i9) a;
                                               2
          (%o9)                  [string, y + x , x]

 -- 関数: rest (<expr>, <n>)
 -- 関数: rest (<expr>)

     もし <n>が正なら、 頭の <n>個の要素を取り除いた <expr>を返し、 もし
     <n>が負なら、 お尻の ‘- <n>’個の要素を取り除いた <expr>を返します。
     もし <n>が1なら、省略できます。 <expr>は、リスト、行列、他の式を取
     り得ます。

 -- 関数: reverse (<list>)

     <list> のメンバーの順序を逆にします。 (メンバー自身は変えません。)
     ‘reverse’は、一般式でも機能します。 例えば、 ‘reverse(a=b);’は
     ‘b=a’を与えます。

 -- 関数: second (<expr>)

     式またはリスト <expr>の二番目の項を返します。 詳細は ‘first’を参照
     してください。

 -- 関数: seventh (<expr>)

     式またはリスト <expr>の7番目の項を返します。 詳細は ‘first’を参照し
     てください。

 -- 関数: sixth (<expr>)

     式またはリスト <expr>の6番目の項を返します。 詳細は ‘first’を参照し
     てください。

 -- 関数: sort (<L>, <P>)
 -- 関数: sort (<L>)

     任意の隣り合う要素について‘<P> (<L>[k], <L>[k + 1])’が‘true’ になる
     ように ２つの引数の述語論理‘P’に従ってリスト<L>をソートします。 述
     語論理は関数や２値中値演算子の名前として、‘lambda’式として指定され
     るかもしれません。 もし演算子名として指定されたなら、名前は「ダブル
     クォート」でくくられます。

     ソートされたリストは新しいオブジェクトとして返されます; <L>は変更さ
     れません。 戻り値を構成するために、 ‘sort’は、<L>の要素の浅いコピー
     を実行します。

     もし述語論理<P>が<L>の要素の総順序でなければ、 ‘sort’は、エラーなし
     に実行を完了するかもしれませんが、結果は未定義です。 もし述語論理が
     ‘true’もしくは‘false’以外の何かに評価されるなら、 ‘sort’はエラーを
     出力します。

     ‘sort (<L>)’は ‘sort (<L>, orderlessp)’と同値です。 すなわち、デフ
     ォルトソート順序は昇順です。‘orderlessp’で決められているように。

     述語論理‘ordergreatp’はリストを降順にソートします。 述語論理
     ‘ordermagnitudep’はMaxima数や数値を持つ定数シンボル、 定数に評価さ
     れることができる式を大きさによってソートします。 リスト<L>の他のす
     べての要素は‘orderlessp’によってソートされます。 述語論理‘"<"’も大
     きさによる順序付けを許しますが、 もしリスト<L>の要素が‘"<"’の下で比
     較可能でないなら完全には並べません。

     例:

          (%i1) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9 * c,
                19 - 3 * x]);
                         5
          (%o1) [- 17, - -, 3, 7.55, 11, 2.9b1, b + a, 9 c, 19 - 3 x]
                         2
          (%i2) sort ([11, -17, 29b0, 7.55, 3, -5/2, b + a, 9*c, 19 - 3*x],
                ordergreatp);
                                                             5
          (%o2) [19 - 3 x, 9 c, b + a, 2.9b1, 11, 7.55, 3, - -, - 17]
                                                             2
          (%i3) sort ([%pi, 3, 4, %e, %gamma]);
          (%o3)                [3, 4, %e, %gamma, %pi]
          (%i4) sort ([%pi, 3, 4, %e, %gamma], "<");
          (%o4)                [%gamma, %e, 3, %pi, 4]
          (%i5) my_list: [[aa,hh,uu], [ee,cc], [zz,xx,mm,cc], [%pi,%e]];
          (%o5) [[aa, hh, uu], [ee, cc], [zz, xx, mm, cc], [%pi, %e]]
          (%i6) sort (my_list);
          (%o6) [[%pi, %e], [aa, hh, uu], [ee, cc], [zz, xx, mm, cc]]
          (%i7) sort (my_list, lambda ([a, b], orderlessp (reverse (a),
                reverse (b))));
          (%o7) [[%pi, %e], [ee, cc], [zz, xx, mm, cc], [aa, hh, uu]]

     Maxima数と定数、定数式を大きさ順に並べ、他のすべての要素を降順で並
     べます:

          (%i8) sort([%i,1+%i,2*x,minf,inf,%e,sin(1),0,1,2,3,1.0,1.0b0],
                ordermagnitudep);
          (%o8)  [minf, 0, sin(1), 1, 1.0, 1.0b0, 2, %e, 3, inf, %i,
                                                                %i + 1, 2 x]

 -- 関数: sublist (<list>, <p>)

     述語論理‘p’が‘true’を返す<list>の要素のリストを返します。

     例:

          (%i1) L: [1, 2, 3, 4, 5, 6];
          (%o1)                  [1, 2, 3, 4, 5, 6]
          (%i2) sublist (L, evenp);
          (%o2)                       [2, 4, 6]

 -- 関数: sublist_indices (<L>, <P>)

     述語論理 ‘maybe(<P>(x))’が ‘true’を返す、 リスト <L>の要素 ‘x’のイ
     ンデックスを返します; これは ‘false’はもちろん ‘unknown’も除外しま
     す。 <P>は関数名かラムダ式を取り得ます。 <L>はリストリテラルでなけ
     ればいけません。

     例:

          (%i1) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b],
                                 lambda ([x], x='b));
          (%o1)                     [2, 3, 7, 9]
          (%i2) sublist_indices ('[a, b, b, c, 1, 2, b, 3, b], symbolp);
          (%o2)                  [1, 2, 3, 4, 7, 9]
          (%i3) sublist_indices ([1 > 0, 1 < 0, 2 < 1, 2 > 1, 2 > 0],
                                 identity);
          (%o3)                       [1, 4, 5]
          (%i4) assume (x < -1);
          (%o4)                       [x < - 1]
          (%i5) map (maybe, [x > 0, x < 0, x < -2]);
          (%o5)                [false, true, unknown]
          (%i6) sublist_indices ([x > 0, x < 0, x < -2], identity);
          (%o6)                          [2]

 -- 関数: unique (<L>)

     リスト <L>の重複しない要素を返します。

     <L>の要素すべてが重複しない時、 ‘unique’は、 <L>自身ではなく、 <L>の
     浅いコピーを返します。

     もし <L>がリストでないなら、 ‘unique’は<L>を返します。

     例:

          (%i1) unique ([1, %pi, a + b, 2, 1, %e, %pi, a + b, [1]]);
          (%o1)              [1, 2, %e, %pi, [1], b + a]

 -- 関数: tenth (<expr>)

     式またはリスト <expr>の10番目の項を返します。 詳細は ‘first’を参照
     してください。

 -- 関数: third (<expr>)

     式またはリスト <expr>の三番目の項を返します。 詳細は ‘first’を参照
     してください。


File: maxima.info,  Node: Arrays,  Next: Structures,  Prev: Lists,  Up: Data Types and Structures

5.6 Arrays
==========

* Menu:

* Functions and Variables for Arrays::  


File: maxima.info,  Node: Functions and Variables for Arrays,  Prev: Arrays,  Up: Arrays

5.7 Functions and Variables for Arrays
======================================

 -- 関数: array (<name>, <dim_1>, …, <dim_n>)
 -- 関数: array (<name>, <type>, <dim_1>, …, <dim_n>)
 -- 関数: array ([<name_1>, …, <name_m>], <dim_1>, …, <dim_n>)

     n次元の配列を生成します。 nは5以下を取り得ます。 i番目の次元のため
     の添字は0から<dim_i>まで動く整数です。

     ‘array (<name>, <dim_1>, ..., <dim_n>)’は 一般的な配列を生成します
     。

     ‘array (<name>, <type>, <dim_1>, ..., <dim_n>)’は 指定されたタイプ
     の要素を持つ配列を生成します。 <type>には 制限されたサイズの整数に
     は‘fixnum’が使え、 また、浮動小数点には‘flonum’が使えます。

     ‘array ([<name_1>, ..., <name_m>], <dim_1>, ..., <dim_n>)’ は同じ次
     元のm個の配列を生成します。

     もしユーザーが対応する配列を宣言する前に添字付き変数に割り当てたら
     、 未宣言配列が生成されます。 (ハッシュコーディングが添字上でされる
     ので)別名ハッシュド配列と知られる未宣言配列は、 宣言配列よりもっと
     一般的です。 ユーザーは最大サイズを宣言せず、さらなる要素が値に割り
     当てられる時、ハッシュすることで それらは動的に成長します。 未宣言
     配列の添字は数である必要すらありません。 しかしながら、 配列がむし
     ろ疎でないなら、 未宣言のまま放っておくより、可能な時に宣言した方が
     おそらく効率的です。 ‘array’関数は未宣言配列を宣言配列に変換するの
     に使うことができます。

 -- 関数: arrayapply (<A>, [<i_1>, … <i_n>])
     ‘<A> [<i_1>, ..., <i_n>]’を評価します。 ここで、<A>は配列、<i_1>,
     …, <i_n>は整数です。

     これは、最初の引数が関数の代わりに配列だということを除いて、
     ‘apply’を連想させます。

 -- 関数: arrayinfo (<A>)

     配列<A>に関する情報を返します。 引数<A>は、宣言配列、未宣言(ハッシ
     ュド)配列、配列関数、または添字付き関数を取り得ます。

     宣言配列では、 ‘arrayinfo’は、 アトム‘declared’と、次元数、それぞれ
     の次元のサイズを含むリストを返します。 配列の要素は、バインドされた
     ものもそうでないものも、‘listarray’で返されます。

     未宣言配列(ハッシュド配列)では、 ‘arrayinfo’は、 アトム‘hashed’と、
     添字の数、値を持つすべての要素の添字を含むリストを返します。 値は
     ‘listarray’で返されます。

     配列関数では、 ‘arrayinfo’は、 アトム‘hashed’と、添字の数、 記憶さ
     れた関数値がある添字の値すべてを含むリストを返します。 記憶された関
     数値は、‘listarray’で返されます。

     添字付き関数では、、 ‘arrayinfo’は、 returns a list comprising the
     アトム‘hashed’と、添字の数、 ラムダ式がある添字の値すべてを含むリス
     トを返します。 ラムダ式は ‘listarray’で返されます。

     ‘listarray’も参照してください。

     例:

     宣言配列に適用された‘arrayinfo’と‘listarray’。

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) arrayinfo (aa);
          (%o4)                 [declared, 2, [2, 3]]
          (%i5) listarray (aa);
          (%o5) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]

     未宣言(ハッシュド)配列に適用された‘arrayinfo’と‘listarray’。

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) arrayinfo (bb);
          (%o3)               [hashed, 1, [BAR], [FOO]]
          (%i4) listarray (bb);
                                        3         2
          (%o4)                 [(c - d) , (b + a) ]

     配列関数に適用された‘arrayinfo’と‘listarray’。

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) arrayinfo (cc);
          (%o4)              [hashed, 2, [4, z], [u, v]]
          (%i5) listarray (cc);
                                        z  v
          (%o5)                        [-, -]
                                        4  u

     添字付き関数に適用された‘arrayinfo’と‘listarray’。

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) arrayinfo (dd);
          (%o4)             [hashed, 1, [b + a], [v - u]]
          (%i5) listarray (dd);
                                   b + a                v - u
          (%o5)      [lambda([y], y     ), lambda([y], y     )]

 -- 関数: arraymake (<A>, [<i_1>, …, <i_n>])
     式‘<A>[<i_1>, ..., <i_n>]’を返します。 結果は未評価の配列参照です。

     ‘arraymake’は、 戻り値は、未評価関数コールの代わりに未評価の配列参
     照だということを除いて、 ‘funmake’を連想させます。

     例:
          (%i1) arraymake (A, [1]);
          (%o1)                          A
                                          1
          (%i2) arraymake (A, [k]);
          (%o2)                          A
                                          k
          (%i3) arraymake (A, [i, j, 3]);
          (%o3)                       A
                                       i, j, 3
          (%i4) array (A, fixnum, 10);
          (%o4)                           A
          (%i5) fillarray (A, makelist (i^2, i, 1, 11));
          (%o5)                           A
          (%i6) arraymake (A, [5]);
          (%o6)                          A
                                          5
          (%i7) ''%;
          (%o7)                          36
          (%i8) L : [a, b, c, d, e];
          (%o8)                    [a, b, c, d, e]
          (%i9) arraymake ('L, [n]);
          (%o9)                          L
                                          n
          (%i10) ''%, n = 3;
          (%o10)                          c
          (%i11) A2 : make_array (fixnum, 10);
          (%o11)          {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i12) fillarray (A2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o12)          {Array:  #(1 2 3 4 5 6 7 8 9 10)}
          (%i13) arraymake ('A2, [8]);
          (%o13)                         A2
                                           8
          (%i14) ''%;
          (%o14)                          9

 -- システム変数: arrays
     デフォルト値: ‘[]’

     ‘arrays’は割り当てられた配列のリストです。 これらは、‘array’で宣言
     された配列、 (なにかw配列要素に割り当てられた)陰の定義で構成された
     ハッシュド配列、 ‘:=’と‘define’で定義された配列関数を含みます。
     ‘make_array’で定義された配列は含まれません。

     ‘array’, ‘arrayapply’, ‘arrayinfo’, ‘arraymake’, ‘fillarray’,
     ‘listarray’, ‘rearray’も参照してください。

     例:

          (%i1) array (aa, 5, 7);
          (%o1)                          aa
          (%i2) bb [FOO] : (a + b)^2;
                                             2
          (%o2)                       (b + a)
          (%i3) cc [x] := x/100;
                                             x
          (%o3)                      cc  := ---
                                       x    100
          (%i4) dd : make_array ('any, 7);
          (%o4)       {Array:  #(NIL NIL NIL NIL NIL NIL NIL)}
          (%i5) arrays;
          (%o5)                     [aa, bb, cc]

 -- 関数: fillarray (<A>, <B>)

     配列<A>を<B>から埋めます。 ここで、<B>はリストか配列です。

     もし生成時に特定のタイプが<A>のために宣言されたら、 その同じタイプ
     の要素でだけ埋めることができます; もし違ったタイプの要素をコピーす
     る試みがなされたらエラーです。

     もし配列<A>と<B>の次元が違ったら、 <A>は行優先順で埋められます。 も
     し<B>の中の要素が十分でないなら、 <A>の残りを埋めるのに最後の要素が
     使われます。 もし多すぎるなら、残りは無視されます。

     ‘fillarray’は最初の引数を返します。

     例:

     9個の要素の配列を生成し、リストから埋めます。
          (%i1) array (a1, fixnum, 8);
          (%o1)                          a1
          (%i2) listarray (a1);
          (%o2)              [0, 0, 0, 0, 0, 0, 0, 0, 0]
          (%i3) fillarray (a1, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
          (%o3)                          a1
          (%i4) listarray (a1);
          (%o4)              [1, 2, 3, 4, 5, 6, 7, 8, 9]

     配列を埋めるのに要素が足らない時、 最後の要素が繰り返されます。 要
     素が多すぎる時、余分の要素は無視されます。
          (%i1) a2 : make_array (fixnum, 8);
          (%o1)             {Array:  #(0 0 0 0 0 0 0 0)}
          (%i2) fillarray (a2, [1, 2, 3, 4, 5]);
          (%o2)             {Array:  #(1 2 3 4 5 5 5 5)}
          (%i3) fillarray (a2, [4]);
          (%o3)             {Array:  #(4 4 4 4 4 4 4 4)}
          (%i4) fillarray (a2, makelist (i, i, 1, 100));
          (%o4)             {Array:  #(1 2 3 4 5 6 7 8)}

     多次元配列は行優先順に埋められます。

          (%i1) a3 : make_array (fixnum, 2, 5);
          (%o1)        {Array:  #2A((0 0 0 0 0) (0 0 0 0 0))}
          (%i2) fillarray (a3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
          (%o2)        {Array:  #2A((1 2 3 4 5) (6 7 8 9 10))}
          (%i3) a4 : make_array (fixnum, 5, 2);
          (%o3)     {Array:  #2A((0 0) (0 0) (0 0) (0 0) (0 0))}
          (%i4) fillarray (a4, a3);
          (%o4)     {Array:  #2A((1 2) (3 4) (5 6) (7 8) (9 10))}

 -- 関数: listarray (<A>)

     配列<A>の要素のリストを返します。 引数<A>は、宣言配列、未宣言(ハッ
     シュド)配列、配列関数、添字付き関数を取り得ます。

     要素は行優先順にリストされます。 すなわち、要素は、最初のインデック
     スに従って振り分けられ、次に二番目のインデックスに従って、などなど
     。 インデックス値の振り分け順は、 ‘orderless’が確立する順と同じです
     。

     未宣言配列や、配列関数、添字付き関数では、 要素は‘arrayinfo’が返す
     インデックス値に対応します。

     宣言された一般配列のバインドされていない要素(すなわち、‘fixnum’でも
     ‘flonum’でもない要素)は、 ‘#####’として返されます。 宣言された
     ‘fixnum’配列または‘flonum’配列のバイドされていない要素は、 それぞれ
     0または0.0として返されます。 未宣言配列、配列関数、添字付き関数のバ
     インドされていない要素は返されません。

     例:

     宣言配列に適用された‘listarray’と‘arrayinfo’。

          (%i1) array (aa, 2, 3);
          (%o1)                          aa
          (%i2) aa [2, 3] : %pi;
          (%o2)                          %pi
          (%i3) aa [1, 2] : %e;
          (%o3)                          %e
          (%i4) listarray (aa);
          (%o4) [#####, #####, #####, #####, #####, #####, %e, #####,
                                                  #####, #####, #####, %pi]
          (%i5) arrayinfo (aa);
          (%o5)                 [declared, 2, [2, 3]]

     未宣言(ハッシュド)配列に適用された‘listarray’と‘arrayinfo’。

          (%i1) bb [FOO] : (a + b)^2;
                                             2
          (%o1)                       (b + a)
          (%i2) bb [BAR] : (c - d)^3;
                                             3
          (%o2)                       (c - d)
          (%i3) listarray (bb);
                                        3         2
          (%o3)                 [(c - d) , (b + a) ]
          (%i4) arrayinfo (bb);
          (%o4)               [hashed, 1, [BAR], [FOO]]

     配列関数に適用された‘listarray’と‘arrayinfo’。

          (%i1) cc [x, y] := y / x;
                                               y
          (%o1)                      cc     := -
                                       x, y    x
          (%i2) cc [u, v];
                                          v
          (%o2)                           -
                                          u
          (%i3) cc [4, z];
                                          z
          (%o3)                           -
                                          4
          (%i4) listarray (cc);
                                        z  v
          (%o4)                        [-, -]
                                        4  u
          (%i5) arrayinfo (cc);
          (%o5)              [hashed, 2, [4, z], [u, v]]

     添字付き関数に適用された‘listarray’と‘arrayinfo’。

          (%i1) dd [x] (y) := y ^ x;
                                               x
          (%o1)                     dd (y) := y
                                      x
          (%i2) dd [a + b];
                                              b + a
          (%o2)                  lambda([y], y     )
          (%i3) dd [v - u];
                                              v - u
          (%o3)                  lambda([y], y     )
          (%i4) listarray (dd);
                                   b + a                v - u
          (%o4)      [lambda([y], y     ), lambda([y], y     )]
          (%i5) arrayinfo (dd);
          (%o5)             [hashed, 1, [b + a], [v - u]]

 -- 関数: make_array (<type>, <dim_1>, ..., <dim_n>)

     Lisp配列を生成し、返します。 <type>は、‘any’, ‘flonum’, ‘fixnum’,
     ‘hashed’, ‘functional’を取り得ます。 n個のインデックスがあり、 i番
     目のインデックスは0から<dim_i> - 1まで動きます。

     ‘make_array’の‘array’に対する利点は、 戻り値が名前を持たないことで
     あり、 一旦、それへのポインタが消えると、それも消えます。 例えば、
     もし‘y: make_array (...)’なら、 ‘y’は領域を取るオブジェクトを指しま
     すが、 ‘y: false’の後、‘y’はそのオブジェクトをもはや指さないので、
     オブジェクトはガーベッジコレクトされることができます。

     例:

          (%i1) A1 : make_array (fixnum, 10);
          (%o1)           {Array:  #(0 0 0 0 0 0 0 0 0 0)}
          (%i2) A1 [8] : 1729;
          (%o2)                         1729
          (%i3) A1;
          (%o3)          {Array:  #(0 0 0 0 0 0 0 0 1729 0)}
          (%i4) A2 : make_array (flonum, 10);
          (%o4) {Array:  #(0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i5) A2 [2] : 2.718281828;
          (%o5)                      2.718281828
          (%i6) A2;
          (%o6)
               {Array:  #(0.0 0.0 2.718281828 0.0 0.0 0.0 0.0 0.0 0.0 0.0)}
          (%i7) A3 : make_array (any, 10);
          (%o7) {Array:  #(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)}
          (%i8) A3 [4] : x - y - z;
          (%o8)                      - z - y + x
          (%i9) A3;
          (%o9) {Array:  #(NIL NIL NIL NIL ((MPLUS SIMP) $X ((MTIMES SIMP)\
           -1 $Y) ((MTIMES SIMP) -1 $Z))
            NIL NIL NIL NIL NIL)}
          (%i10) A4 : make_array (fixnum, 2, 3, 5);
          (%o10) {Array:  #3A(((0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0)) ((0 0 \
          0 0 0) (0 0 0 0 0) (0 0 0 0 0)))}
          (%i11) fillarray (A4, makelist (i, i, 1, 2*3*5));
          (%o11) {Array:  #3A(((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15))
              ((16 17 18 19 20) (21 22 23 24 25) (26 27 28 29 30)))}
          (%i12) A4 [0, 2, 1];
          (%o12)                         12

 -- 関数: rearray (<A>, <dim_1>, ..., <dim_n>)

     配列の次元を変えます。 新しい配列は 行優先順に古いものの配列で埋め
     られます。 もし古い配列が小さすぎるなら、 残りの要素は、 配列のタイ
     プに依って、 ‘false’, ‘0.0’または‘0’で埋められます。 配列のタイプは
     変えられません。

 -- 関数: remarray (<A_1>, ..., <A_n>)
 -- 関数: remarray (all)

     配列と関数に関連づけられた配列を削除し、占められた領域を開放します
     。 引数は、宣言配列、未宣言(ハッシュド)配列、配列関数、添字付き関数
     を取り得ます。

     ‘remarray (all)’は、 グローバルリスト‘arrays’の中の項目すべてを削除
     します。

     もしハッシュド配列の中の値を再定義することが望ましいなら、この関数
     を使うことが必要になるかもしれません。

     ‘remarray’は削除された配列のリストを返します。

     ‘remarray’はクォートします。

 -- 関数: subvar (<x>, <i>)

     添字付き式‘<x>[<i>]’を評価します。

     ‘subvar’は引数を評価します。

     ‘arraymake (<x>, [<i>]’は 式‘<x>[<i>]’を構成しますが、 それを評価は
     しません。

     例:

          (%i1) x : foo $
          (%i2) i : 3 $
          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$
          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc

 -- 関数: subvarp (<expr>)

     もし<expr>が例えば‘a[i]’のように添字された変数なら、‘true’を返しま
     す。

 -- オプション変数: use_fast_arrays

     もし‘true’なら、配列の２つのタイプだけが認識されます:

       1. 整数でインデックスされたいくつかの次元を持つができ、 情報入力
          としてLispまたはMaximaオブジェクトを保てるart-q配列(Common
          Lispでのt)。 そんな配列を構成するには、
          ‘a:make_array(any,3,4);’を入力してください。 ‘a’は、12個の枠を
          持つ配列を値として持ち、インデックスはゼロベースです

       2. もし‘b[x+1]:y^2’を実行したら、生成された配列のデフォルト値でハ
          ッシュテーブル配列 (‘b’はまだ配列でもリストでも行列でもありま
          せん – もしこれらの１つなら、‘x+1’は、art-q配列やリスト、行列
          の有効な添字ではないので 、エラーが起こります。) (キーとしても
          知られている)インデックスは、任意のオブジェクトを取り得ます。
          一度の１つのキーだけを取ります((‘b[x+1,u]:y’は‘u’を無視します
          。)。 参照は、‘b[x+1] ==> y^2’によってされます。 もちろん、キ
          ーは、例えば、 ‘b[[x+1,u]]:y’が有効なように リストを取り得ます
          。 これは古いMaximaハッシュ配列と非互換ですが、コンシングを保
          ちます。

     配列をシンボルの値として記憶することの利点は、 関数のローカル変数に
     ついての普通の慣例が配列にも適用することです。 ハッシュテーブルタイ
     プは、 Maximaハッシャの古いタイプよりも 少ないコンシングを使い、も
     っと効率的です。 翻訳され、コンパイルされたコードに関する一貫した振
     る舞いを得るためには、 ‘translate_fast_arrays’を‘true’に設定してく
     ださい。


File: maxima.info,  Node: Structures,  Prev: Arrays,  Up: Data Types and Structures

5.8 Structures
==============

* Menu:

* Introduction to Structures::       
* Functions and Variables for Structures::       


File: maxima.info,  Node: Introduction to Structures,  Next: Functions and Variables for Structures,  Prev: Structures,  Up: Structures

5.8.1 Introduction to Structures
--------------------------------

Maximaは構造体と呼ばれる簡単なデータ集合体を提供します。 構造体は 引数が
名前(フィールド名)によって識別され、式全体が演算子(構造体名)によって識別
される式です。 フィールド名は任意の式を取り得ます。

   構造体は‘defstruct’関数によって定義されます; グローバル変数
‘structures’はユーザー定義の構造体のリストです。 関数‘new’は構造体のイン
スタンスを生成します。 ‘@’演算子はフィールドを参照します。 ‘kill(<S>)’は
構造体定義<S>を取り除き、 ‘kill(<x>@ <a>)’は 構造体インスタンス<x>のフィ
ールド<a>をアンバインドします。

   (‘display2d’を‘true’で使う)プリティプリンティングのコンソール表示では
、 構造体インスタンスは、 左辺側にフィールド名、右辺側に値の式として表さ
れたそれぞれのフィールドの値と一緒に 表示されます。 (等式は単に表示物で
す; 値だけが実際に保存されます。) (‘grind’を介してか、‘display2d’を
‘false’で使う)1次元表示では 構造体はフィールド名ないで表示されます。

   フィールド値はラムダ式でありえますが、フィールド名を関数名として使う
方法はありません。 フィールドの値はあるタイプに制約することもできません;
任意のフィールドにはどんな種類の式に割り当てることができます。 フィール
ドを、違った文脈でアクセス可能にしたり不可能する方法はありません; すべて
のフィールドはいつも可視です。


File: maxima.info,  Node: Functions and Variables for Structures,  Prev: Introduction to Structures,  Up: Structures

5.8.2 Functions and Variables for Structures
--------------------------------------------

 -- グローバル変数: structures

     ‘structures’は ‘defstruct’で定義されたユーザー定義の構造体のリスト
     です。

 -- 関数: defstruct (<S>(<a_1>, …, <a_n>))
 -- 関数: defstruct (<S>(<a_1> = <v_1>, …, <a_n> = <v_n>))

     構造体を定義します。 構造体はシンボル<S>と関連付けられた名前フィー
     ルドのリスト<a_1>, …, <a_n>です。

     構造体のインスタンスは演算子<S>と正確に‘n’個の引数を持つただの式で
     す。 ‘new(<S>)’は構造体<S>の新しいインスタンスを生成します。

     ただのシンボル<a>である引数はフィールド名を指定します。 等式‘<a> =
     <v>’である引数は フィールド名<a>とデフォルト値<v>を指定します。 デ
     フォルト値は任意の式を取り得ます。

     ‘defstruct’は ユーザー定義の構造体のリスト‘structures’上に<S>を入れ
     ます。

     ‘kill(<S>)’は ユーザー定義の構造体のリストから<S>を取り除き、構造体
     定義を取り除きます。

     例:

          (%i1) defstruct (foo (a, b, c));
          (%o1)                    [foo(a, b, c)]
          (%i2) structures;
          (%o2)                    [foo(a, b, c)]
          (%i3) new (foo);
          (%o3)                     foo(a, b, c)
          (%i4) defstruct (bar (v, w, x = 123, y = %pi));
          (%o4)             [bar(v, w, x = 123, y = %pi)]
          (%i5) structures;
          (%o5)      [foo(a, b, c), bar(v, w, x = 123, y = %pi)]
          (%i6) new (bar);
          (%o6)              bar(v, w, x = 123, y = %pi)
          (%i7) kill (foo);
          (%o7)                         done
          (%i8) structures;
          (%o8)             [bar(v, w, x = 123, y = %pi)]

 -- 関数: new (<S>)
 -- 関数: new (<S> (<v_1>, …, <v_n>))

     ‘new’は構造体の新しいインスタンスを生成します。

     ‘new(<S>)’は 構造体<S>の新しいインスタンスを生成します。 それぞれの
     フィールドは、もしデフォルト値があればデフォルト値を割り当てられ、
     もしデフォルト値が構造体定義で指定されなかったなら、割り当てなしに
     なります。

     ‘new(<S>(<v_1>, ..., <v_n>))’は フィールドが値<v_1>, …, <v_n>に割り
     当てられた 構造体<S>の新しいインスタンスを生成します。

     例:

          (%i1) defstruct (foo (w, x = %e, y = 42, z));
          (%o1)              [foo(w, x = %e, y = 42, z)]
          (%i2) new (foo);
          (%o2)               foo(w, x = %e, y = 42, z)
          (%i3) new (foo (1, 2, 4, 8));
          (%o3)            foo(w = 1, x = 2, y = 4, z = 8)

 -- 演算子: @

     ‘@’構造体フィールドアクセス演算子です。 式‘<x>@ <a>’は 構造体インス
     タンス<x>のフィールド<a>の値を参照します。 フィールド名は評価されま
     せん。

     もし<x>のフィールド<a>が値を割り当てられていないなら、 ‘<x>@ <a>’は
     それ自身に評価されます。

     ‘kill(<x>@ <a>)’は <x>のフィールド値<a>を値を取り除きます。

     例:

          (%i1) defstruct (foo (x, y, z));
          (%o1)                    [foo(x, y, z)]
          (%i2) u : new (foo (123, a - b, %pi));
          (%o2)           foo(x = 123, y = a - b, z = %pi)
          (%i3) u@z;
          (%o3)                          %pi
          (%i4) u@z : %e;
          (%o4)                          %e
          (%i5) u;
          (%o5)            foo(x = 123, y = a - b, z = %e)
          (%i6) kill (u@z);
          (%o6)                         done
          (%i7) u;
          (%o7)              foo(x = 123, y = a - b, z)
          (%i8) u@z;
          (%o8)                          u@z

     フィールド名は評価されません。

          (%i1) defstruct (bar (g, h));
          (%o1)                      [bar(g, h)]
          (%i2) x : new (bar);
          (%o2)                       bar(g, h)
          (%i3) x@h : 42;
          (%o3)                          42
          (%i4) h : 123;
          (%o4)                          123
          (%i5) x@h;
          (%o5)                          42
          (%i6) x@h : 19;
          (%o6)                          19
          (%i7) x;
          (%o7)                    bar(g, h = 19)
          (%i8) h;
          (%o8)                          123


File: maxima.info,  Node: Expressions,  Next: Operators,  Prev: Data Types and Structures,  Up: Top

6 Expressions
*************

* Menu:

* Introduction to Expressions::
* Nouns and Verbs::
* Identifiers::
* Inequality::
* Functions and Variables for Expressions::


File: maxima.info,  Node: Introduction to Expressions,  Next: Nouns and Verbs,  Prev: Expressions,  Up: Expressions

6.1 Introduction to Expressions
===============================

変数名として使えないたくさんの予約語があります。 これらを使うと、不可解
な構文法エラーの原因となります。

     integrate            next           from                 diff
     in                   at             limit                sum
     for                  and            elseif               then
     else                 do             or                   if
     unless               product        while                thru
     step

   Maximaのほとんどのものは式です。 括弧で囲み、コンマで区切ることで、式
の列が構成できます。 これは、C言語のコンマ式に似ています。

     (%i1) x: 3$
     (%i2) (x: x+1, x: x^2);
     (%o2)                          16
     (%i3) (if (x > 17) then 2 else 4);
     (%o3)                           4
     (%i4) (if (x > 17) then x: 2 else y: 4, y+x);
     (%o4)                          20

   ループが返す値はあまり役に立たない‘done’ですが、Maximaではループでさ
え式です。

     (%i1) y: (x: 1, for i from 1 thru 10 do (x: x*i))$
     (%i2) y;
     (%o2)                         done

   ところが、本当に欲しいものは、たぶん、実際に値を戻すコンマ式の３番目
の項を含むことで得られます。

     (%i3) y: (x: 1, for i from 1 thru 10 do (x: x*i), x)$
     (%i4) y;
     (%o4)                        3628800


File: maxima.info,  Node: Nouns and Verbs,  Next: Identifiers,  Prev: Introduction to Expressions,  Up: Expressions

6.2 Nouns and Verbs
===================

Maximaは「名詞(Noun)」演算子と「動詞(Verb)」演算子を区別します。 動詞は
実行される演算子です。 名詞は式の中で、実行されずシンボルとして現れる演
算子です。 デフォルトでは、関数名は動詞です。 動詞は、関数名をクォートす
ることで、また、‘nounify’関数を適用することで、 名詞に変えることができま
す。 名詞は、‘verbify’関数を適用することで動詞に変えることができます。 評
価フラグ‘nouns’は、‘ev’を式の中の名詞を評価するようにします。

   動詞形は、対応するLispシンボル上では、先頭のドル記号‘$’で区別されます
。 対照的に、 名詞形は、対応するLispシンボル上では、先頭のパーセント記号
‘%’で区別されます。 ‘'integrate’や（‘diff’が返す）‘'derivative’のように
、 いくつかの名詞は特別な表示プロパティを持ちますが、ほとんどは特別な表
示を持ちません。 デフォルトでは、表示される時、関数の名詞と動詞形は同一
です。 グローバルフラグ‘noundisp’は、 Maximaに、先頭のクォートマーク
‘'’で名詞形を表示させます。

   ‘noun’, ‘nouns’, ‘nounify’, や‘verbify’も参照してください。

   例:

     (%i1) foo (x) := x^2;
                                          2
     (%o1)                     foo(x) := x
     (%i2) foo (42);
     (%o2)                         1764
     (%i3) 'foo (42);
     (%o3)                        foo(42)
     (%i4) 'foo (42), nouns;
     (%o4)                         1764
     (%i5) declare (bar, noun);
     (%o5)                         done
     (%i6) bar (x) := x/17;
                                          x
     (%o6)                    ''bar(x) := --
                                          17
     (%i7) bar (52);
     (%o7)                        bar(52)
     (%i8) bar (52), nouns;
                                    52
     (%o8)                          --
                                    17
     (%i9) integrate (1/x, x, 1, 42);
     (%o9)                        log(42)
     (%i10) 'integrate (1/x, x, 1, 42);
                                  42
                                 /
                                 [   1
     (%o10)                      I   - dx
                                 ]   x
                                 /
                                  1
     (%i11) ev (%, nouns);
     (%o11)                       log(42)


File: maxima.info,  Node: Identifiers,  Next: Inequality,  Prev: Nouns and Verbs,  Up: Expressions

6.3 Identifiers
===============

Maximaの識別子は、アルファベット文字と、0から9までの数詞と、 バックスラ
ッシュ‘\’文字に続く任意の特別文字で構成されます。

   もしバックスラッシュが先行するなら、数詞は、識別子の最初の文字となる
ことができます。 ２番目や後の文字の数詞は、バックスラッシュが先行する必
要はありません。

   文字は、‘declare’関数によってアルファベットと宣言することができます。
もし宣言されたら、識別子の中でバックスラッシュで先行する必要はありません
。 アルファベット文字は、‘A’から‘Z’まで, ‘a’から ‘z’まで, ‘%’,と‘_’が初
期設定です。

   Maximaは大文字小文字を区別します。 識別子‘foo’, ‘FOO’, と‘Foo’は別の
物です。 この点に関して*note Lisp and Maxima::を参照してください。

   Maximaの識別子は、ドル記号‘$’で始まるLispのシンボルです。 Maximaの中
で現れる時、他の任意のLispシンボルは、クエスチョンマーク‘?’で始まります
。 この点に関して*note Lisp and Maxima::を参照してください。

   例:

     (%i1) %an_ordinary_identifier42;
     (%o1)               %an_ordinary_identifier42
     (%i2) embedded\ spaces\ in\ an\ identifier;
     (%o2)           embedded spaces in an identifier
     (%i3) symbolp (%);
     (%o3)                         true
     (%i4) [foo+bar, foo\+bar];
     (%o4)                 [foo + bar, foo+bar]
     (%i5) [1729, \1729];
     (%o5)                     [1729, 1729]
     (%i6) [symbolp (foo\+bar), symbolp (\1729)];
     (%o6)                     [true, true]
     (%i7) [is (foo\+bar = foo+bar), is (\1729 = 1729)];
     (%o7)                    [false, false]
     (%i8) baz\~quux;
     (%o8)                       baz~quux
     (%i9) declare ("~", alphabetic);
     (%o9)                         done
     (%i10) baz~quux;
     (%o10)                      baz~quux
     (%i11) [is (foo = FOO), is (FOO = Foo), is (Foo = foo)];
     (%o11)                [false, false, false]
     (%i12) :lisp (defvar *my-lisp-variable* '$foo)
     *MY-LISP-VARIABLE*
     (%i12) ?\*my\-lisp\-variable\*;
     (%o12)                         foo


File: maxima.info,  Node: Inequality,  Next: Functions and Variables for Expressions,  Prev: Identifiers,  Up: Expressions

6.4 Inequality
==============

Maximaは、不等式演算子‘<’, ‘<=’, ‘>=’, ‘>’, ‘#’, ‘notequal’を持ちます。
条件式の記述に関しては、‘if’を参照してください。


File: maxima.info,  Node: Functions and Variables for Expressions,  Prev: Inequality,  Up: Expressions

6.5 Functions and Variables for Expressions
===========================================

 -- 関数: alias (<new_name_1>, <old_name_1>, …, <new_name_n>,
          <old_name_n>)

     (利用者もしくはシステム)関数や変数、配列等に対して別名を与えます。
     任意の偶数個の引数を取ります。

 -- システム変数: aliases
     デフォルト値: ‘[]’

     ‘aliases’は、 (‘alias’, ‘ordergreat’, ‘orderless’関数によって、もし
     くは、 ‘declare’で アトムを‘noun’に宣言することで、設定される) ユー
     ザー定義のエーリアスを持つ アトムのリストです。

 -- キーワード: allbut

     ‘part’コマンド(すなわち、‘part’,‘inpart’,‘substpart’,
     ‘substinpart’,‘dpart’, ‘lpart’)と共に動作します。例えば、

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, [2, 5]);
          (%o2)                         d + a

     一方、

          (%i1) expr : e + d + c + b + a;
          (%o1)                   e + d + c + b + a
          (%i2) part (expr, allbut (2, 5));
          (%o2)                       e + c + b

     ‘kill’も‘allbut’を認識します。

          (%i1) [aa : 11, bb : 22, cc : 33, dd : 44, ee : 55];
          (%o1)                 [11, 22, 33, 44, 55]
          (%i2) kill (allbut (cc, dd));
          (%o0)                         done
          (%i1) [aa, bb, cc, dd];
          (%o1)                   [aa, bb, 33, 44]

     ‘kill(allbut(<a_1>, <a_2>, ...))’は、 シンボル<a_1>, <a_2>, …をキル
     しないよう除外して ‘kill(all)’を実行します。

 -- 関数: args (<expr>)

     ‘expr’の引数のリストを返します。 ここで、‘expr’アトム以外のいかなる
     種類の式を取り得ます。 トップレベル演算子の引数だけが抽出されます;
     ‘expr’の部分式は、要素として、または、引数のリストの要素の部分式と
     して現れます。

     リストの中の項目の順序は、グローバルフラグ‘inflag’に依存するかもし
     れません。

     ‘args (<expr>)’は、‘substpart ("[", <expr>, 0)’と同値です。
     ‘substpart’と‘op’も参照してください。

 -- 関数: atom (<expr>)

     もし <expr>がアトム(すなわち、数や名前や文字)なら、 ‘true’、そうで
     なければ ‘false’を返します。 例えば、 ‘atom(5)’は ‘true’ですが、
     (‘a[1]’と ‘x’はバインドされていないと仮定して) ‘atom(a[1])’や
     ‘atom(sin(x))’は ‘false’です。

 -- 関数: box (<expr>)
 -- 関数: box (<expr>, <a>)

     枠で囲んだ<expr>を返します。 返り値は、演算子として‘box’を持ち、引
     数として<expr>を持つ式です。 ‘display2d’が‘true’の時、ディスプレイ
     上に枠が描かれます。

     ‘box (<expr>, <a>)’は、 シンボル<a>でラベルされた枠で<expr>を囲みま
     す。 もし枠の幅より長ければ、ラベルは切りつめられます。

     ‘box’は引数を評価します。 しかしながら、枠に入れられた式は中身に評
     価されないので、 枠に入れられた式は、計算から効果的に除外されます。

     ‘boxchar’は、‘box’, ‘dpart’, ‘lpart’関数において 枠を描くのに使われ
     る文字です。

     例:

          (%i1) box (a^2 + b^2);
                                      """""""""
                                      " 2    2"
          (%o1)                       "b  + a "
                                      """""""""
          (%i2) a : 1234;
          (%o2)                         1234
          (%i3) b : c - d;
          (%o3)                         c - d
          (%i4) box (a^2 + b^2);
                                """"""""""""""""""""
                                "       2          "
          (%o4)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i5) box (a^2 + b^2, term_1);
                                term_1""""""""""""""
                                "       2          "
          (%o5)                 "(c - d)  + 1522756"
                                """"""""""""""""""""
          (%i6) 1729 - box (1729);
                                           """"""
          (%o6)                     1729 - "1729"
                                           """"""
          (%i7) boxchar: "-";
          (%o7)                           -
          (%i8) box (sin(x) + cos(y));
                                  -----------------
          (%o8)                   -cos(y) + sin(x)-
                                  -----------------

 -- オプション変数: boxchar
     デフォルト値: ‘"’

     ‘boxchar’は、‘box’, ‘dpart’, ‘lpart’関数において 枠を描くのに使われ
     る文字です。

     式の中の枠すべては、‘boxchar’の現在値で描かれます; 描画文字は枠式に
     保存されていません。

 -- 関数: collapse (<expr>)

     共通の（すなわち等しい）部分式の全てを共用と（すなわち、同じセルを
     使用）させることで、 <expr>を縮約し、スペースを節約します。
     (‘collapse’は、‘optimize’コマンドによって使われるサブルーチンです。
     ） 例えば，‘collapse’をコールすることは、 ‘save’ファイルに積んだ後
     役に立つかもしれません。 ‘collapse ([<expr_1>, ..., <expr_n>])’を使
     うことで、いくつかの式を 一緒に縮約できます。 同様に、‘collapse
     (listarray ('A))’を実行することで、配列‘A’の要素を縮約できます。

 -- 関数: disolate (<expr>, <x_1>, …, <x_n>)

     ユーザーに１つ以上の変数を同時にisolate可能にさせることを除いて、
     ‘isolate (<expr>, <x>)’に似ています。 例えば、もし多重積分の中で変
     数を変えようとしていて、それが２つ以上の積分変数を含んだ変数変換な
     ら、これは役立つかもしれません。 この関数は、
     ‘simplification/disol.mac’から自動ロードされます。
     ‘demo("disol")$’でデモが入手可能です。

 -- 関数: dispform (<expr>)
 -- 関数: dispform (<expr>, all)

     <expr>の外部表現を返します。

     ‘dispform(<expr>)’は、主（トップレベル）演算子に関して外部表現を返
     します。 ‘dispform(<expr>, all)’は、<expr>の中の演算子すべてに関し
     て 外部表現を返します。

     ‘part’, ‘inpart’, ‘inflag’も参照してください。

     例:

     ‘- x’の内部表現は、「-1掛ける‘x’」ですが、 外部表現は、「マイナス
     ‘x’」です。

          (%i1) - x;
          (%o1)                          - x
          (%i2) ?format (true, "~S~%", %);
          ((MTIMES SIMP) -1 $X)
          (%o2)                         false
          (%i3) dispform (- x);
          (%o3)                          - x
          (%i4) ?format (true, "~S~%", %);
          ((MMINUS SIMP) $X)
          (%o4)                         false

     ‘sqrt(x)’の内部表現は、「‘x’の1/2乗」ですが、 外部表現は、「‘x’の平
     方根」です。

          (%i1) sqrt (x);
          (%o1)                        sqrt(x)
          (%i2) ?format (true, "~S~%", %);
          ((MEXPT SIMP) $X ((RAT SIMP) 1 2))
          (%o2)                         false
          (%i3) dispform (sqrt (x));
          (%o3)                        sqrt(x)
          (%i4) ?format (true, "~S~%", %);
          ((%SQRT SIMP) $X)
          (%o4)                         false

     オプション引数‘all’の使用。

          (%i1) expr : sin (sqrt (x));
          (%o1)                     sin(sqrt(x))
          (%i2) freeof (sqrt, expr);
          (%o2)                         true
          (%i3) freeof (sqrt, dispform (expr));
          (%o3)                         true
          (%i4) freeof (sqrt, dispform (expr, all));
          (%o4)                         false

 -- 関数: dpart (<expr>, <n_1>, …, <n_k>)

     ‘part’と同じ部分式を選択しますが、 その部分式を値として返すだけの代
     わりに、 枠の中に表示されて選択された部分式を持つ式全体を返します。
     枠は実際に式の一部です。

          (%i1) dpart (x+y/z^2, 1, 2, 1);
                                       y
          (%o1)                       ---- + x
                                         2
                                      """
                                      "z"
                                      """

 -- オプション変数: exptisolate
     デフォルト値: ‘false’

     ‘exptisolate’が‘true’の時、 ‘isolate (expr, var)’は、 ‘var’を含む
     (‘%e’のような)アトムの指数を検査します。

 -- オプション変数: exptsubst
     デフォルト値: ‘false’

     ‘exptsubst’が‘true’の時、 ‘%e^(a x)’の中の‘%e^x’へ‘y’を代入するよう
     な代入を許します。

 -- 関数: freeof (<x_1>, …, <x_n>, <expr>)

     もし<x_1>と等しい<expr>の部分式がないか、 <x_1>が<expr>の中でダミー
     変数としてのみ現れるか、 <x_1>が<expr>の中で任意の演算子の名詞形で
     も動詞形でもないなら、 ‘freeof (<x_1>, <expr>)’は、‘true’を返します
     。 そうでなければ、‘false’を返します。

     ‘freeof (<x_1>, ..., <x_n>, <expr>)’は、 ‘freeof (<x_1>, <expr>)か
     つ、 ...かつfreeof (<x_n>, <expr>)’と同値です。

     引数<x_1>, …, <x_n> は、 関数や変数の名前、添字付き名前、（ダブルク
     ォートでくくられた）演算子、もしくは一般式 を取り得ます。 ‘freeof’は
     引数を評価します。

     ‘freeof’は、そのままは（整理と評価の後）<expr>上でのみ演算し、 ある
     同値の表現が違った結果を与えるかどうかを決定しようとはしません。 特
     に、整理は、同値ですが、<expr>の原型とは違った要素を含む異なる式を
     生成するかもしれません。

     もし式の外部にバインドを持たなければ、変数は、式の中のダミー変数で
     す。 ‘freeof’によって認識されたダミー変数は、 和や積のインデックス
     、‘limit’の中の極限変数、 ‘integrate’の定積分形の中の積分変数、
     ‘laplace’の中のオリジナル変数、 ‘at’式の中の形式変数、 ‘lambda’式の
     中の引数です。

     ‘integrate’の不定積分形は、積分変数から自由ではありません。

     例:

     引数は、関数、変数、添字付き名前、演算子、式の名前です。 ‘freeof
     (a, b, expr)’は ‘freeof (a, expr) and freeof (b, expr)’と同値です。

          (%i1) expr: z^3 * cos (a[1]) * b^(c+d);
                                           d + c  3
          (%o1)                   cos(a ) b      z
                                       1
          (%i2) freeof (z, expr);
          (%o2)                         false
          (%i3) freeof (cos, expr);
          (%o3)                         false
          (%i4) freeof (a[1], expr);
          (%o4)                         false
          (%i5) freeof (cos (a[1]), expr);
          (%o5)                         false
          (%i6) freeof (b^(c+d), expr);
          (%o6)                         false
          (%i7) freeof ("^", expr);
          (%o7)                         false
          (%i8) freeof (w, sin, a[2], sin (a[2]), b*(c+d), expr);
          (%o8)                         true

     ‘freeof’は引数を評価します。

          (%i1) expr: (a+b)^5$
          (%i2) c: a$
          (%i3) freeof (c, expr);
          (%o3)                         false

     ‘freeof’は、同値の式を考慮しません。 整理は、同値ですが異なる式を生
     成します。

          (%i1) expr: (a+b)^5$
          (%i2) expand (expr);
                    5        4       2  3       3  2      4      5
          (%o2)    b  + 5 a b  + 10 a  b  + 10 a  b  + 5 a  b + a
          (%i3) freeof (a+b, %);
          (%o3)                         true
          (%i4) freeof (a+b, expr);
          (%o4)                         false
          (%i5) exp (x);
                                           x
          (%o5)                          %e
          (%i6) freeof (exp, exp (x));
          (%o6)                         true

     和や定積分はダミー変数から自由です。 不定積分は積分変数から自由では
     ありません。

          (%i1) freeof (i, 'sum (f(i), i, 0, n));
          (%o1)                         true
          (%i2) freeof (x, 'integrate (x^2, x, 0, 1));
          (%o2)                         true
          (%i3) freeof (x, 'integrate (x^2, x));
          (%o3)                         false

 -- オプション変数: inflag
     デフォルト値: ‘false’

     ‘inflag’が‘true’の時、 部分抽出のための関数は、‘expr’の内部形式を検
     査します。

     整理器は式を再順序付けすることに注意してください。 例えば、 もし
     ‘inflag’が‘true’なら、 ‘first (x + y)’は、‘x’を返し、 もしif
     ‘inflag’が‘false’なら、‘y’を返します。 (‘first (y + x)’は同じ結果を
     与えます。)

     また、‘inflag’を‘true’に設定し、‘part’や‘substpart’をコールすること
     は、 ‘inpart’や‘substinpart’をコールすることと同じです。

     ‘inflag’の設定に影響される関数は以下の通りです: ‘part’,
     ‘substpart’, ‘first’, ‘rest’, ‘last’, ‘length’, ‘for’ ...  ‘in’構成
     子, ‘map’, ‘fullmap’, ‘maplist’, ‘reveal’, ‘pickapart’。

 -- 関数: inpart (<expr>, <n_1>, ..., <n_k>)

     ‘part’に似ていますが、表示形式ではなく内部表現上で機能し、 フォーマ
     ットが実行されないのでより速いかもしれません。 （内部形式での変数の
     順序はしばしば表示形式でのそれと異なるので） 和や積の中の部分式の順
     序や、 （以下の演算子は式から取り除かれるので）単項マイナス、引き算
     、割り算を扱う際の部分式の順序 に関して注意が必要です。 ‘part (x+y,
     0)’や‘inpart (x+y, 0)’は、 ‘+’を返しますが、 演算子を参照するため、
     "で囲まれたものになります。 例えば、‘... if inpart (%o9,0) = "+"
     then ...’.

     例:

          (%i1) x + y + w*z;
          (%o1)                      w z + y + x
          (%i2) inpart (%, 3, 2);
          (%o2)                           z
          (%i3) part (%th (2), 1, 2);
          (%o3)                           z
          (%i4) 'limit (f(x)^g(x+1), x, 0, minus);
                                            g(x + 1)
          (%o4)                 limit   f(x)
                                x -> 0-
          (%i5) inpart (%, 1, 2);
          (%o5)                       g(x + 1)

 -- 関数: isolate (<expr>, <x>)
     和であり、中間式ラベル(それらは‘%t1’, ‘%t2’, ...のようなアトムなシ
     ンボルです) で置き換えられた<x>を含まない部分式を含む<expr>を返しま
     す。 興味のある変数を含まない部分式の不必要な展開を避けるのに、これ
     はしばしば役立ちます。 中間ラベルは部分式にバインドされているので、
     それらが現れた式を評価することで、それらをすべて元に代入することが
     できます。

     もし‘exptisolate’ (デフォルト値: ‘false’)が‘true’なら、 ‘isolate’は
     、<x>を含むか、(‘%e’のような)アトムの指数を検査します。

     もし‘isolate_wrt_times’が‘true’なら、 ‘isolate’は積に関しても
     isolateします。 ‘isolate_wrt_times’を参照してください。

     サンプルを見るには、‘example (isolate)’を実行してください。

 -- オプション変数: isolate_wrt_times
     デフォルト値: ‘false’

     ‘isolate_wrt_times’が‘true’の時, ‘isolate’は、積に関してもisolateし
     ます。 例えば、スイッチの両方の設定を比較すると、

          (%i1) isolate_wrt_times: true$
          (%i2) isolate (expand ((a+b+c)^2), c);

          (%t2)                          2 a


          (%t3)                          2 b


                                    2            2
          (%t4)                    b  + 2 a b + a

                               2
          (%o4)               c  + %t3 c + %t2 c + %t4
          (%i4) isolate_wrt_times: false$
          (%i5) isolate (expand ((a+b+c)^2), c);
                               2
          (%o5)               c  + 2 b c + 2 a c + %t4

 -- オプション変数: listconstvars
     デフォルト値: ‘false’

     ‘listconstvars’が‘true’の時、 ‘listofvars’は、‘%e’, ‘%pi’, ‘%i’や 定
     数と宣言された任意の変数を、 もしそれらが、‘listofvars’がコールされ
     た式の中で現れたなら、 戻り値のリストの中に含みます。 デフォルトは
     これらを省略します。

 -- オプション変数: listdummyvars
     デフォルト値: ‘true’

     ‘listdummyvars’が‘false’の時、 式の中の「ダミー変数」は、
     ‘listofvars’が返すリストの中に含まれません。 （「ダミー変数」の意味
     は‘freeof’で与えられているものです。 「ダミー変数」は、和や積のイン
     デックスや、極限変数、定積分変数のように数学的なものです。）

     例:

          (%i1) listdummyvars: true$
          (%i2) listofvars ('sum(f(i), i, 0, n));
          (%o2)                        [i, n]
          (%i3) listdummyvars: false$
          (%i4) listofvars ('sum(f(i), i, 0, n));
          (%o4)                          [n]

 -- 関数: listofvars (<expr>)

     <expr>の中の変数のリストを返します。

     もし‘listconstvars’が‘true’なら、 ‘listofvars’は、‘%e’, ‘%pi’,
     ‘%i’や 定数と宣言された任意の変数を、 もしそれらが、<expr>の中で現
     れたなら、 戻り値のリストの中に含みます。 デフォルトはこれらを省略
     します。

     変数のリストのなかの「ダミー変数」を除外したり含めたりするには、オ
     プション変数 ‘listdummyvars’も参照してください。

          (%i1) listofvars (f (x[1]+y) / g^(2+a));
          (%o1)                     [g, a, x , y]
                                            1

 -- 関数: lfreeof (<list>, <expr>)

     <list>のそれぞれのメンバー<m>に関して、 ‘freeof (<m>, <expr>)’をコ
     ールします。 もし‘freeof’のコールのいずれかが‘false’を返すなら、
     ‘false’を返し、そうでなければ、‘true’を返します。

 -- 関数: lpart (<label>, <expr>, <n_1>, …, <n_k>)

     ‘dpart’に似ていますが、ラベルされた枠を使います。 ラベルされた枠は
     、‘dpart’によって生成されたものに似ていますが、 トップラインの中で
     の名前を持ちます。

 -- 宣言: mainvar

     変数を‘mainvar’に宣言することができます。 アトムに関する順序付けス
     ケールは本質的に以下の通りです: 数 < 定数 (例えば、‘%e’, ‘%pi’) < ス
     カラー < 他の変数 < mainvars。 例えば、‘(declare (x, mainvar),
     expand ((x+y)^4))’を伴う ‘expand ((X+Y)^4)’。 （上の特長を使うこと
     を選択したなら注意が必要なことに注意してください。 例えば、もし、
     ‘mainvar’である‘x’を含む式を、‘mainvar’でない‘x’を含む式から引くな
     ら、 もし打ち消しが起こるようにするなら、 例えば‘ev (expr, simp)’の
     ような再整理が必要かもしれません。 また、‘mainvar’である‘x’を含む式
     を保存するなら、 ‘x’もまた保存すべきです。）

 -- 宣言: noun

     ‘noun’は、‘declare’コマンドのオプションの１つです。 関数を「名詞」
     に宣言するのに使います。 「名詞」は、自動的には評価されないことを意
     味します。

 -- オプション変数: noundisp
     デフォルト値: ‘false’

     ‘noundisp’が‘true’の時、 名詞は、単一クォートで表示されます。 この
     スイッチは、関数定義を表示する時には、常に‘true’です。

 -- 関数: nounify (<f>)

     関数名<f>の名詞形を返します。 もし動詞関数の名前をまるで名詞のよう
     に参照したいなら、これが必要とされます。 もしある引数に関して関数が
     評価されないなら、 いくつかの動詞関数は名詞形を返すことに注意してく
     ださい。 これは、クォートに関数コールが続く時、返される形式でもあり
     ます。

     ‘verbify’も参照してください。

 -- 関数: nterms (<expr>)

     もし完全に展開されて、項の打ち消しや結合が起こらない場合の、
     <expr>が持つ 項の数を返します。 ‘sin (<expr>)’, ‘sqrt (<expr>)’,
     ‘exp (<expr>)’, などのような式は、 <expr>が（もしそれが和なら） ど
     んなにたくさんの項を持とうと、１項と数えます。

 -- 関数: op (<expr>)

     式<expr>のメインの演算子を返します。 ‘op (<expr>)’は‘part (<expr>,
     0)’と同値です。

     ‘op’は、 もしメインの演算子が組み込みもしくはユーザー定義の前置、二
     項もしくはn項中置、後置、マッチフィックスもしくは無項演算子なら、文
     字列を返します。 そうでなければ、 もし<expr>が添字付き関数式なら、
     ‘op’は添字付き関数を返します; この場合、戻り値はアトムではありませ
     ん。 そうでなければ、 <expr>は配列関数もしくは通常の関数式であり、
     ‘op’はシンボルを返します。

     ‘op’はグローバルフラグ‘inflag’の値を見ています。

     ‘op’は引数を評価します。

     ‘args’も参照してください。

     例:

          (%i1) stringdisp: true$
          (%i2) op (a * b * c);
          (%o2)                          "*"
          (%i3) op (a * b + c);
          (%o3)                          "+"
          (%i4) op ('sin (a + b));
          (%o4)                          sin
          (%i5) op (a!);
          (%o5)                          "!"
          (%i6) op (-a);
          (%o6)                          "-"
          (%i7) op ([a, b, c]);
          (%o7)                          "["
          (%i8) op ('(if a > b then c else d));
          (%o8)                         "if"
          (%i9) op ('foo (a));
          (%o9)                          foo
          (%i10) prefix (foo);
          (%o10)                        "foo"
          (%i11) op (foo a);
          (%o11)                        "foo"
          (%i12) op (F [x, y] (a, b, c));
          (%o12)                        F
                                         x, y
          (%i13) op (G [u, v, w]);
          (%o13)                          G

 -- 関数: operatorp (<expr>, <op>)
 -- 関数: operatorp (<expr>, [<op_1>, …, <op_n>])

     もし<op>が<expr>の演算子に等しければ、 ‘operatorp (<expr>, <op>)’は
     ‘true’を返します。

     もしある要素<op_1>, ..., <op_n>が<expr>に等しければ、 ‘operatorp
     (<expr>, [<op_1>, …, <op_n>])’は‘true’を返します。

 -- オプション変数: opsubst
     デフォルト値: ‘true’

     ‘opsubst’が‘false’の時、 ‘subst’は、式の中の演算子に代入を試みませ
     ん。 例えば、 ‘(opsubst: false, subst (x^2, r, r+r[0]))’は機能しま
     す。

 -- 関数: optimize (<expr>)

     <expr>と同じ値と副作用を生成する式を返しますが、 共通の部分式の再計
     算を避けることによってより効率的に行います。 ‘optimize’は、共通の部
     分式すべてが共用されるように引数を縮約する副作用も持ちます。 例を見
     るには、‘example (optimize)’を実行してください。

 -- オプション変数: optimprefix
     デフォルト値: ‘%’

     ‘optimprefix’は‘optimize’コマンドによって生成されたシンボルのために
     使われる前置です。

 -- 関数: ordergreat (<v_1>, …, <v_n>)
 -- 関数: orderless (<v_1>, …, <v_n>)

     ‘ordergreat’は、 <v_1>が<v_2>に続き、<v_2>は、…, <v_n>に続き、 そし
     て<v_n>は 引数として言及されなかった他の任意のシンボルに続くという
     ように、 Maximaの式の標準の順序付けを変えます。

     ‘orderless’は、 <v_1>が<v_2>に先行し、<v_2>は、…, <v_n>に先行し、 そ
     して<v_n>は 引数として言及されなかった他の任意のシンボルに先行する
     というように、 Maximaの式の標準の順序付けを変えます。

     ‘ordergreat’や‘orderless’によって確立される順序は、 ‘unorder’によっ
     て解消されます。 ‘ordergreat’や‘orderless’は、 ‘unorder’がコールさ
     れるまで、 それぞれ一度だけコールすることができます; ‘ordergreat’の
     ‘orderless’の最後のコールだけが効果を持ちます。

     ‘ordergreatp’も参照してください。

 -- 関数: ordergreatp (<expr_1>, <expr_2>)
 -- 関数: orderlessp (<expr_1>, <expr_2>)

     もしMaximaの式の標準の順序付けの中で、<expr_1>が<expr_2>に続くなら
     、 ‘ordergreatp’は、‘true’を返し、 そうでなければ、‘false’を返しま
     す。

     もしMaximaの式の標準の順序付けの中で、<expr_1>が<expr_2>に先行する
     なら、 ‘orderlessp’は、‘true’を返し、 そうでなければ、‘false’を返し
     ます。

     Maximaのアトムや式のすべては、‘ordergreatp’と‘orderlessp’の下で比較
     可能です。これらの述語論理が推移的でないような式の孤立した例はある
     けれども; それはバグです。

     アトム（シンボル、数リテラル、文字列）の標準の順序付けは以下の通り
     です。

     (整数と浮動小数点)は以下に先行 (多倍長浮動小数点)は以下に先行 (宣言
     された定数)は以下に先行 (文字列)は以下に先行 (宣言されたスカラー)は
     以下に先行 (‘orderless’の最初の引数)は以下に先行 …は以下に先行
     (‘orderless’の最後の引数) は以下に先行 (他のシンボル) は以下に先行
     (‘ordergreat’の最後の引数)は以下に先行 …は以下に先行 (‘ordergreat’の
     最初の引数)は以下に先行 (宣言されたメイン変数)

     アトムでない式に関して、標準の順序付けはアトムの順序付けから演繹さ
     れます。 組み込みの‘+’ ‘*’ ‘^’演算子に関しては、 順序付けは簡単には
     まとめられません。 他の組み込み演算子と他の半数や演算子、式すべてに
     関しては、 （最初の引数から始めて）それらの引数によって順序付けされ
     、 それから演算子や関数の名前によって順序付けされます。 添字付き式
     の場合、 添字付きのシンボルは演算子と、添字は引数と考えられます。

     式の標準の順序付けは、関数‘ordergreat’と‘orderless’と、 ‘mainvar’,
     ‘constant’, ‘scalar’宣言によって変更されます。

     ‘sort’も参照してください。

     例:

     通常のシンボルや定数の順序付け。 ‘%pi’は数値に従って順序付けされな
     いことに注意してください。

          (%i1) stringdisp : true;
          (%o1)                         true
          (%i2) sort([%pi, 3b0, 3.0, x, X, "foo", 3, a, 4, "bar", 4.0, 4b0]);
          (%o2) [3, 3.0, 4, 4.0, 3.0b0, 4.0b0, %pi, "bar", "foo", a, x, X]

     ‘ordergreat’、‘orderless’関数の効果。

          (%i1) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o1)           [A, E, G, H, J, K, M, P, S, T, W]
          (%i2) ordergreat (S, J);
          (%o2)                         done
          (%i3) orderless (M, H);
          (%o3)                         done
          (%i4) sort ([M, H, K, T, E, W, G, A, P, J, S]);
          (%o4)           [M, H, A, E, G, K, P, T, W, J, S]

     ‘mainvar’, ‘constant’, ‘scalar’宣言の効果

          (%i1) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o1)   [aa, bar, baz, bb, cc, dd, foo, quux, A1, B1, C1]
          (%i2) declare (aa, mainvar);
          (%o2)                         done
          (%i3) declare ([baz, quux], constant);
          (%o3)                         done
          (%i4) declare ([A1, B1], scalar);
          (%o4)                         done
          (%i5) sort ([aa, foo, bar, bb, baz, quux, cc, dd, A1, B1, C1]);
          (%o5)   [baz, quux, A1, B1, bar, bb, cc, dd, foo, C1, aa]

     アトムでない式の順序付け

          (%i1) sort ([1, 2, n, f(1), f(2), f(2, 1), g(1), g(1, 2), g(n),
                       f(n, 1)]);
          (%o1) [1, 2, f(1), g(1), g(1, 2), f(2), f(2, 1), n, g(n),
                                                                   f(n, 1)]
          (%i2) sort ([foo(1), X[1], X[k], foo(k), 1, k]);
          (%o2)            [1, foo(1), X , k, foo(k), X ]
                                        1              k

 -- 関数: part (<expr>, <n_1>, …, <n_k>)

     ‘expr’の表示形式のパーツを返します。 ‘expr’の最初のパーツ<n_1>、そ
     れから、パーツ<n_2>などなど、 結果は、‘expr’のパーツ<n_1>のパーツ
     <n_2>の, ...パーツ<n_k>です。 もし添字が指定されないなら、‘expr’を
     返します。

     ‘part’はリストの要素や行列の行を得るのに使うことができます。

     もし‘part’関数の最後の引数がインデックスのリストなら、 それぞれがリ
     ストのインデックスに対応するいくつかの部分式が抽出されます。 従って
     、‘part (x + y + z, [1, 3])’は‘z+x’です。

     ‘piece’は、‘part’関数を使ったとき、選択された最後の式を保持します。
     それは関数の実行中にセットされ、以下で示すように、関数自身の中で参
     照されることもあります。

     もし‘partswitch’が‘true’に設定されているなら、 式の選択されたパーツ
     が存在しないとき、‘end’が返されます。 そうでなければ、エラーメッセ
     ージが出力されます。

     ‘inpart’, ‘substpart’, ‘substinpart’, ‘dpart’, ‘lpart’も参照してく
     ださい。

     例:

          (%i1) part(z+2*y+a,2);
          (%o1)                                 2 y
          (%i2) part(z+2*y+a,[1,3]);
          (%o2)                                z + a
          (%i3) part(z+2*y+a,2,1);
          (%o3)                                  2

     ‘example (part)’でさらに例を見ることができます。

 -- 関数: partition (<expr>, <x>)

     ２つの式のリストを返します。 それらは、 (1)（積なら）<expr>の因子、
     （和なら）<expr>項、 もしくは、（リストなら）<x>を含まないリストと
     、 (2)<x>を含む因子、項、リスト、 です。

     例:

          (%i1) partition (2*a*x*f(x), x);
          (%o1)                     [2 a, x f(x)]
          (%i2) partition (a+b, x);
          (%o2)                      [b + a, 0]
          (%i3) partition ([a, b, f(a), c], a);
          (%o3)                  [[b, c], [a, f(a)]]

 -- オプション変数: partswitch
     デフォルト値: ‘false’

     ‘partswitch’が‘true’の時、 式の選択された部分が存在しない時、
     ‘end’が返されます。 そうでない時は、エラーメッセージが出力されます
     。

 -- 関数: pickapart (<expr>, <n>)

     中間式ラベルを、深さが整数<n>での<expr>の部分式に割り当てます。 よ
     り大きなもしくは小さな深さでの部分式はラベルに割り当てられません。
     ‘pickapart’は、元の式<expr>と同値の中間式の項による式を返します。

     ‘part’, ‘dpart’, ‘lpart’, ‘inpart’, ‘reveal’も参照してください。

     例:

          (%i1) expr: (a+b)/2 + sin (x^2)/3 - log (1 + sqrt(x+1));
                                                    2
                                               sin(x )   b + a
          (%o1)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%i2) pickapart (expr, 0);
                                                    2
                                               sin(x )   b + a
          (%t2)       - log(sqrt(x + 1) + 1) + ------- + -----
                                                  3        2
          (%o2)                          %t2
          (%i3) pickapart (expr, 1);

          (%t3)                - log(sqrt(x + 1) + 1)


                                            2
                                       sin(x )
          (%t4)                        -------
                                          3


                                        b + a
          (%t5)                         -----
                                          2

          (%o5)                    %t5 + %t4 + %t3
          (%i5) pickapart (expr, 2);

          (%t6)                 log(sqrt(x + 1) + 1)


                                            2
          (%t7)                        sin(x )


          (%t8)                         b + a

                                   %t8   %t7
          (%o8)                    --- + --- - %t6
                                    2     3
          (%i8) pickapart (expr, 3);

          (%t9)                    sqrt(x + 1) + 1


                                          2
          (%t10)                         x

                            b + a              sin(%t10)
          (%o10)            ----- - log(%t9) + ---------
                              2                    3
          (%i10) pickapart (expr, 4);

          (%t11)                     sqrt(x + 1)
                                2
                           sin(x )   b + a
          (%o11)           ------- + ----- - log(%t11 + 1)
                              3        2
          (%i11) pickapart (expr, 5);

          (%t12)                        x + 1

                             2
                        sin(x )   b + a
          (%o12)        ------- + ----- - log(sqrt(%t12) + 1)
                           3        2
          (%i12) pickapart (expr, 6);
                            2
                       sin(x )   b + a
          (%o12)       ------- + ----- - log(sqrt(x + 1) + 1)
                          3        2

 -- システム変数: piece

     ‘part’関数を使った時選択された最後の式を返します。 関数の実行中に設
     定され、関数そのものの中で参照されることもあります。

 -- 関数: psubst (<list>, <expr>)
 -- 関数: psubst (<a>, <b>, <expr>)

     ‘psubst(<a>, <b>, <expr>)’は‘subst’に似ています。 ‘subst’を参照して
     ください。

     ‘subst’とは違って、 もし最初の引数<list>が等式のリストなら、 関数
     ‘psubst’は平行代入します。

     並列代入するには、‘sublis’も参照してください。

     例:

     最初の例は、 ‘psubst’を使った平行代入を示します。 二番目の例は、 関
     数‘subst’での結果を示します。それは逐次代入します。

          (%i4) psubst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o4)                           sin(b) + sin(a)
          (%i5) subst ([a^2=b, b=a], sin(a^2) + sin(b));
          (%o5)                              2 sin(a)

 -- 関数: rembox (<expr>, unlabelled)
 -- 関数: rembox (<expr>, <label>)
 -- 関数: rembox (<expr>)
     <expr>から枠を取り除きます。

     ‘rembox (<expr>, unlabelled)’は、 <expr>からラベルされていない枠す
     べてを取り除きます。

     ‘rembox (<expr>, <label>)’は、 <label>を負う枠のみを取り除きます。

     ‘rembox (<expr>)’は、ラベルされているか否か問わず、 枠すべてを取り
     除きます。

     枠は、‘box’, ‘dpart’, ‘lpart’関数によって描画されます。

     例:

          (%i1) expr: (a*d - b*c)/h^2 + sin(%pi*x);
                                            a d - b c
          (%o1)                sin(%pi x) + ---------
                                                2
                                               h
          (%i2) dpart (dpart (expr, 1, 1), 2, 2);
                                  """""""    a d - b c
          (%o2)               sin("%pi x") + ---------
                                  """""""      """"
                                               " 2"
                                               "h "
                                               """"
          (%i3) expr2: lpart (BAR, lpart (FOO, %, 1), 2);
                            FOO"""""""""""   BAR""""""""
                            "    """"""" "   "a d - b c"
          (%o3)             "sin("%pi x")" + "---------"
                            "    """"""" "   "  """"   "
                            """"""""""""""   "  " 2"   "
                                             "  "h "   "
                                             "  """"   "
                                             """""""""""
          (%i4) rembox (expr2, unlabelled);
                                            BAR""""""""
                             FOO"""""""""   "a d - b c"
          (%o4)              "sin(%pi x)" + "---------"
                             """"""""""""   "    2    "
                                            "   h     "
                                            """""""""""
          (%i5) rembox (expr2, FOO);
                                            BAR""""""""
                                 """""""    "a d - b c"
          (%o5)              sin("%pi x") + "---------"
                                 """""""    "  """"   "
                                            "  " 2"   "
                                            "  "h "   "
                                            "  """"   "
                                            """""""""""
          (%i6) rembox (expr2, BAR);
                             FOO"""""""""""
                             "    """"""" "   a d - b c
          (%o6)              "sin("%pi x")" + ---------
                             "    """"""" "     """"
                             """"""""""""""     " 2"
                                                "h "
                                                """"
          (%i7) rembox (expr2);
                                            a d - b c
          (%o7)                sin(%pi x) + ---------
                                                2
                                               h

 -- 関数: reveal (<expr>, <depth>)

     指定された整数<depth>の<expr>の部分を 記述的な要約で 置き換えます。

        • 和と差分は、‘Sum(<n>)’で置き換えられます。 ここで、<n>は、和の
          オペランドの数です。
        • 積は‘Product(<n>)’で置き換えられます。 ここで、<n>は、積のオペ
          ランドの数です。
        • 指数は、‘Expt’で置き換えられます。
        • 商は、‘Quotient’で置き換えられます。
        • 単項マイナスは、‘Negterm’で置き換えられます。
        • リストは‘List(<n>)’で置き換えられます ここで、<n>はリストの要
          素の数です。

     <depth>が<expr>の最大深さ以上の時、 ‘reveal (<expr>, <depth>)’は、
     <expr>をそのまま返します。

     ‘reveal’は、引数を評価します。 ‘reveal’は、要約された式を返します。

     例:


          (%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                                    2            2
                                   b  - 2 a b + a
          (%o1)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e
          (%i2) reveal (e, 1);
          (%o2)                       Quotient
          (%i3) reveal (e, 2);
                                       Sum(3)
          (%o3)                        ------
                                       Sum(3)
          (%i4) reveal (e, 3);
                               Expt + Negterm + Expt
          (%o4)               ------------------------
                              Product(2) + Expt + Expt
          (%i5) reveal (e, 4);
                                 2                 2
                                b  - Product(3) + a
          (%o5)         ------------------------------------
                                   Product(2)     Product(2)
                        2 Expt + %e           + %e
          (%i6) reveal (e, 5);
                                   2            2
                                  b  - 2 a b + a
          (%o6)              --------------------------
                                 Sum(2)     2 b     2 a
                             2 %e       + %e    + %e
          (%i7) reveal (e, 6);
                                    2            2
                                   b  - 2 a b + a
          (%o7)               -------------------------
                                  b + a     2 b     2 a
                              2 %e      + %e    + %e

 -- 関数: sublis (<list>, <expr>)

     式に対して多重平行代入を行います。 <list>は等式のリストです。 等式
     の左辺はアトムでなければいけません。

     変数‘sublis_apply_lambda’は‘sublis’の後の式整理を制御します。

     平行代入を行うには、‘psubst’も参照してください。

     例:

          (%i1) sublis ([a=b, b=a], sin(a) + cos(b));
          (%o1)                    sin(b) + cos(a)

 -- オプション変数: sublis_apply_lambda
     デフォルト値: ‘true’

     ‘lambda’の代入が‘sublis’が使われた後の式整理の中で適用されるか 、も
     しくは、ユーザーが、ものに適用されるように‘ev’を実行しなければいけ
     ないかを決めます。 ‘true’は適用を意味します。

 -- オプション変数: subnumsimp
     デフォルト値: ‘false’

     もし‘true’なら、シンボル‘f’が与えられた時だけ、 関数‘subst’と
     ‘psubst’は添字付き変数‘f[x]’に数を代入できます。

     ‘subst’も参照してください。

          (%i1) subst(100,g,g[x]+2);

          subst: cannot substitute 100 for operator g in expression g
                                                                     x
           -- an error. To debug this try: debugmode(true);

          (%i2) subst(100,g,g[x]+2),subnumsimp:true;
          (%o2)                          102

 -- 関数: subst (<a>, <b>, <c>)

     <c>の中の<b>に<a>を代入します。 <b>はアトムもしくは<c>の完全な部分
     式でなければなりません。 例えば、‘x+y+z’は‘2*(x+y+z)’の完全な部分式
     である一方、‘x+y’は完全な部分式ではありません。 <b>がこれらの性質を
     持たない時は、‘substpart’もしくは‘ratsubst’が使える時があります（下
     記参照）。 代わりに、もし<b>が‘e/f’形式なら、‘subst (a*f, e, c)’が
     使えますし、 もし<b>が‘e^(1/f)’形式なら、‘subst (a^f, e, c)’が使え
     ます。 ‘subst’コマンドは‘x^-y’の中の‘x^y’も認識するので、 ‘subst
     (a, sqrt(x), 1/sqrt(x))’は‘1/a’を出力します。 <a>と<b>はダブルクォ
     ート‘"’で囲まれた式の演算子でも、関数名でも問題ありません。 導関数
     形式の独立変数に代入したいなら、‘at’関数（下記参照）を使うべきです
     。

     ‘subst’は‘substitute’のエーリアスです。

     コマンド‘subst (<eq_1>, <expr>)’もしくは‘subst ([<eq_1>, ...,
     <eq_k>], <expr>)’も許されている形式です。 <eq_i>はされるべき代入を
     指示する等式です。 それぞれの等式において、右辺が、式<expr>の中の左
     辺に代入されます。 等式は、<expr>に、左から右へ逐次に代入されます。
     平行代入するには、関数‘sublis’と‘psubst’を参照してください。

     ‘exptsubst’が‘true’なら、 ‘%e^(a*x)’の中の‘%e^x’が‘y’に置き換えられ
     るような代入が許されます。

     ‘opsubst’が‘false’の時、 ‘subst’は式の演算子への代入を行いません。
     例えば、‘(opsubst: false, subst (X^2, r, r+r[9]))’は意図通り動作し
     ます。

     例:

          (%i1) subst (a, x+y, x + (x+y)^2 + y);
                                              2
          (%o1)                      y + x + a
          (%i2) subst (-%i, %i, a + b*%i);
          (%o2)                       a - %i b

     代入は、等式のリストに関して逐次になされます。 これを並列代入と比較
     してください。

          (%i3) subst([a=b, b=c], a+b);
          (%o3)                                 2 c
          (%i4) sublis([a=b, b=c], a+b);
          (%o4)                                c + b

     もっと例を見るには、‘example (subst)’を実行してください。

 -- 関数: substinpart (<x>, <expr>, <n_1>, ..., <n_k>)

     ‘substpart’と同様ですが、‘substinpart’は<expr>の内部表現上で 働きま
     す。

     例:

          (%i1) x . 'diff (f(x), x, 2);
                                        2
                                       d
          (%o1)                   x . (--- (f(x)))
                                         2
                                       dx
          (%i2) substinpart (d^2, %, 2);
                                            2
          (%o2)                        x . d
          (%i3) substinpart (f1, f[1](x + 1), 0);
          (%o3)                       f1(x + 1)

     もし‘part’関数の最後の引数がインデックスのリストなら、 複数の部分式
     が選ばれます。それぞれはリストのインデックスに対応します。 例えば、

          (%i1) part (x + y + z, [1, 3]);
          (%o1)                         z + x

     ‘part’関数を使った時、‘piece’は、最後の式の値を保持します。 関数の
     実行の間に設定され、以下で示すように関数自身の中で参照されることも
     あります。 もし‘partswitch’が‘true’に設定されたら、 式の選択された
     部分が存在しない時には‘end’が返されます。 そうでなければ、エラーメ
     ッセージが出力されます。

          (%i1) expr: 27*y^3 + 54*x*y^2 + 36*x^2*y + y + 8*x^3 + x + 1;
                        3         2       2            3
          (%o1)     27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1
          (%i2) part (expr, 2, [1, 3]);
                                            2
          (%o2)                         54 y
          (%i3) sqrt (piece/54);
          (%o3)                        abs(y)
          (%i4) substpart (factor (piece), expr, [1, 2, 3, 5]);
                                         3
          (%o4)               (3 y + 2 x)  + y + x + 1
          (%i5) expr: 1/x + y/x - 1/z;
                                       1   y   1
          (%o5)                      - - + - + -
                                       z   x   x
          (%i6) substpart (xthru (piece), expr, [2, 3]);
                                      y + 1   1
          (%o6)                       ----- - -
                                        x     z

     また、 オプション ‘inflag’を ‘true’に設定し ‘part’か ‘substpart’を
     コールすることは ‘inpart’か ‘substinpart’をコールすることと同じです
     。

 -- 関数: substpart (<x>, <expr>, <n_1>, …, <n_k>)

     <x>を、残りの引数を‘part’に食わせた結果の部分式に代入します。
     <expr>の新しい値を返します。 <x>は<expr>の演算子に代入される演算子
     でも問題ありません。 いくつかの場合、<x>はダブルクォート‘"’で囲まれ
     る必要があります。 （例えば、‘substpart ("+", a*b, 0)’は‘b + a’を返
     します。）

     例:

          (%i1) 1/(x^2 + 2);
                                         1
          (%o1)                        ------
                                        2
                                       x  + 2
          (%i2) substpart (3/2, %, 2, 1, 2);
                                         1
          (%o2)                       --------
                                       3/2
                                      x    + 2
          (%i3) a*x + f(b, y);
          (%o3)                     a x + f(b, y)
          (%i4) substpart ("+", %, 1, 0);
          (%o4)                    x + f(b, y) + a

     また、オプション‘inflag’を‘true’に設定し、 ‘part’や‘substpart’をコ
     ールすることは、 ‘inpart’や‘substinpart’をコールすることと同じにな
     ります。

 -- 関数: symbolp (<expr>)

     もし<expr>がシンボルなら‘true’、そうでないなら‘false’を返します。 事
     実上、‘symbolp(x)’は、述語論理‘atom(x) and not numberp(x)’と同値で
     す。

     *note Identifiers::も参照してください。

 -- 関数: unorder ()

     順序付けコマンド‘ordergreat’と‘orderless’の最後の使用で生成されたエ
     ーリアシングを使用不可にします。 ‘ordergreat’と‘orderless’は、
     ‘unorder’を呼び出さずに、一回以上使えないかもしれません。
     ‘unorder’は、 ‘ordergreat’と‘orderless’で導入されたエーリアスに 元
     のシンボルを式に再代入しません。 それ故に、‘unorder’の実行後、以前
     の式にエーリアスが現れます。

     ‘ordergreat’と‘orderless’も参照してください。

     例s:

     ‘ordergreat(a)’はシンボル‘a’のエーリアスを導入します。 それ故に、
     ‘%o2’と‘%o4’の違いは消えません。 ‘unorder’はシンボル‘a’を再代入しな
     いし、 出力‘%o7’にエーリアスが現れます。

          (%i1) unorder();
          (%o1)                          []
          (%i2) b*x+a^2;
                                             2
          (%o2)                       b x + a
          (%i3) ordergreat(a);
          (%o3)                         done
          (%i4) b*x+a^2;
                                       2
          (%o4)                       a  + b x
          (%i5) %th(1)-%th(3);
                                        2    2
          (%o5)                        a  - a
          (%i6) unorder();
          (%o6)                          [a]
          (%i7) %th(2);
                                          2    2
          (%o7)                      _101a  - a

 -- 関数: verbify (<f>)

     関数名<f>の動詞形を返します。 ‘verb’, ‘noun’, ‘nounify’も参照してく
     ださい。

     例:

          (%i1) verbify ('foo);
          (%o1)                          foo
          (%i2) :lisp $%
          $FOO
          (%i2) nounify (foo);
          (%o2)                          foo
          (%i3) :lisp $%
          %FOO


File: maxima.info,  Node: Operators,  Next: Evaluation,  Prev: Expressions,  Up: Top

7 Operators
***********

* Menu:

* Introduction to operators::      
* Arithmetic operators::
* Relational operators::
* Logical operators::
* Operators for Equations::
* Assignment operators::
* User defined operators::


File: maxima.info,  Node: Introduction to operators,  Next: Arithmetic operators,  Prev: Operators,  Up: Operators

7.1 Introduction to operators
=============================

指定された優先順位を持つ新しい演算子を定義したり、 既存の演算子を未定義
にしたり、既存の演算子の優先順位を再定義することが可能です。 演算子は単
項前置、単項後置、二項中置、n項中置、マッチフィックスか無項でありえます
。 「マッチフィックス」は引数を括るシンボルの対を意味し、 「無項」は引数
を取らない演算子を意味します。 異なるタイプの演算子の例として、以下があ
ります。

unary prefix
     negation ‘- a’
unary postfix
     factorial ‘a!’
binary infix
     exponentiation ‘a^b’
n-ary infix
     addition ‘a + b’
matchfix
     list construction ‘[a, b]’

   (組み込みの無項演算子はありません; そんな演算子の例は、‘nofix’を参照
してください。.)

   新しい演算子を定義するメカニズムはわかりやすいものです。 関数を演算子
として宣言することだけが必要です; 演算子関数は定義されることもされないこ
ともあります。

   ユーザー定義の演算子の例は以下の通りです。 明示的な関数コール ‘"dd"
(a)’は ‘dd a’と同値であり、また、 ‘"<-" (a, b)’は ‘a <- b’と同値であるこ
とに注意してください。 この例で、 ‘"dd"’と ‘"<-"’は未定義です。

     (%i1) prefix ("dd");
     (%o1)                          dd
     (%i2) dd a;
     (%o2)                         dd a
     (%i3) "dd" (a);
     (%o3)                         dd a
     (%i4) infix ("<-");
     (%o4)                          <-
     (%i5) a <- dd b;
     (%o5)                      a <- dd b
     (%i6) "<-" (a, "dd" (b));
     (%o6)                      a <- dd b

   新しい演算子を定義するMaxima関数はこの表にまとめられます。 デフォルト
の左と右の結合力(それぞれlbpとrbp)を記載します。 (結合力は演算子の優先順
位を決めます。 しかしながら、左と右の結合力は異なることがあり、 結合力は
優先順位より幾分複雑です。) 演算定義関数のいくつかは追加の引数を取ります
; 詳細は関数記述を参照してください。

‘prefix’
     rbp=180
‘postfix’
     lbp=180
‘infix’
     lbp=180, rbp=180
‘nary’
     lbp=180, rbp=180
‘matchfix’
     (binding power not applicable)
‘nofix’
     (binding power not applicable)

   比較のために、いくつかの組み込み演算子と左右結合力を上げます。

     Operator   lbp     rbp

       :        180     20
       ::       180     20
       :=       180     20
       ::=      180     20
       !        160
       !!       160
       ^        140     139
       .        130     129
       *        120
       /        120     120
       +        100     100
       -        100     134
       =        80      80
       #        80      80
       >        80      80
       >=       80      80
       <        80      80
       <=       80      80
       not              70
       and      65
       or       60
       ,        10
       $        -1
       ;        -1

   ‘remove’と ‘kill’は演算子プロパティをアトムから削除します。 ‘remove
("<a>", op)’は <a>の演算子プロパティだけを削除します。 ‘kill ("<a>")’は
演算子プロパティを含む<a>のすべてのロパティを削除します。 演算子名はクォ
ーテーションマークで括らないといけないことに注意してください。

     (%i1) infix ("##");
     (%o1)                          ##
     (%i2) "##" (a, b) := a^b;
                                          b
     (%o2)                     a ## b := a
     (%i3) 5 ## 3;
     (%o3)                          125
     (%i4) remove ("##", op);
     (%o4)                         done
     (%i5) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i5) "##" (5, 3);
     (%o5)                          125
     (%i6) infix ("##");
     (%o6)                          ##
     (%i7) 5 ## 3;
     (%o7)                          125
     (%i8) kill ("##");
     (%o8)                         done
     (%i9) 5 ## 3;
     Incorrect syntax: # is not a prefix operator
     5 ##
       ^
     (%i9) "##" (5, 3);
     (%o9)                       ##(5, 3)


File: maxima.info,  Node: Arithmetic operators,  Next: Relational operators,  Prev: Introduction to operators,  Up: Operators

7.2 Arithmetic operators
========================

 -- 演算子: +
 -- 演算子: -
 -- 演算子: *
 -- 演算子: /
 -- 演算子: ^

     シンボル ‘+’ ‘*’ ‘/’ ‘^’はそれぞれ、 足し算、かけ算、割り算、べき乗
     を表します。 これらの演算子の名前は ‘"+"’ ‘"*"’ ‘"/"’ ‘"^"’です。 こ
     れらは関数や演算子の名前が求められるところで使います。

     シンボル ‘+’や ‘-’はそれぞれ、プラスとマイナスの単項演算子を示し、
     それらの名前はそれぞれ ‘"+"’と‘"-"’です。

     引き算 ‘a - b’はMaximaの中では足し算 ‘a + (- b)’として表されます。
     ‘a + (- b)’のような式は引き算として表示されます。 Maximaは ‘"-"’を
     足し算の単項逆元演算子の名前としてのみ認識して、 二項引き算演算子と
     しては認識しません。

     Maximaの中では割り算‘a / b’をかけ算‘a * b^(- 1)’として表現します。
     ‘a * b^(- 1)’のような式は割り算として表示されます。 Maximaは‘"/"’を
     割り算演算子の名前として認識します。

     足し算とかけ算はn項可換演算子です。 割り算とべき乗は二項の非可換演
     算子です。

     Maximaは正準表現を構成するために可換演算子のオペランド(訳注：引数
     )を並べ替えます。 順序は内部的には ‘orderlessp’で決定します。 表示
     のためには、足し算の順序は ‘ordergreatp’で決定し、 かけ算は内部的な
     順序と同じです。

     算術計算は、数リテラル（整数、有理数、通常の浮動小数点、多倍長浮動
     小数点）上で実行されます。 べき乗を除いて、数に対するすべての算術演
     算子は数に整理されます。 べき乗は、オペランドが通常の浮動小数点か多
     倍長浮動小数点の時、もしくは結果が厳密に整数もしくは有理数の時、数
     に整理されます; そうでなければ、べき乗は ‘sqrt’か他のべき乗に整理さ
     れるか、そのまま残されます。

     浮動小数点の伝搬が算術計算に適用されます: もしどれか１つでもオペラ
     ンドが多倍長浮動小数点なら、結果は多倍長浮動小数点です; そうでなけ
     れば、もしどれか１つでもオペランドが通常の浮動小数点なら、結果は通
     常の浮動小数点です; そうでなければオペランドは有理数か整数であり、
     結果は有理数か整数です。

     算術計算は式整理であって、評価ではありません。 従って、クォートされ
     た（しかし整理される）式の中で算術計算は実行されます。

     算術演算は、 グローバルフラグ ‘listarith’が ‘true’の時 リストに対し
     て要素毎に適用され、 行列に対しては常に要素毎に適用されます。 オペ
     ランドの１つがリストか行列であり、もう１つのオペランドが別のタイプ
     の時、 他のオペランドはリストか行列の要素のそれぞれに組み合わされま
     す。

     例:

     足し算とかけ算は、n項可換演算子です。 Maximaは、正準表現を構成する
     ために、可換演算子のオペランドを並べ替えます。 それらの名前はそれぞ
     れ ‘"+"’と ‘"*"’です。

          (%i1) c + g + d + a + b + e + f;
          (%o1)               g + f + e + d + c + b + a
          (%i2) [op (%), args (%)];
          (%o2)              [+, [g, f, e, d, c, b, a]]
          (%i3) c * g * d * a * b * e * f;
          (%o3)                     a b c d e f g
          (%i4) [op (%), args (%)];
          (%o4)              [*, [a, b, c, d, e, f, g]]
          (%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
          (%o5)                    3 x + 2 a + 19
          (%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                           2  3
          (%o6)                       144 a  x

     割り算とべき乗は、二項の非可換演算子です。 それらの名前はそれぞれ
     ‘"/"’と ‘"^"’です。

          (%i1) [a / b, a ^ b];
                                        a   b
          (%o1)                        [-, a ]
                                        b
          (%i2) [map (op, %), map (args, %)];
          (%o2)              [[/, ^], [[a, b], [a, b]]]
          (%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                                        a   b
          (%o3)                        [-, a ]
                                        b

     引き算と割り算は内部的にはそれぞれ、足し算とかけ算を使って表現され
     ます。

          (%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
          (%o1)                      [+, a, - b]
          (%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                             1
          (%o2)                       [*, a, -]
                                             b

     計算は数リテラルに対して実行されます。 浮動小数点伝搬が適用されます
     。

          (%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                                 5
          (%o1)                   b + sqrt(11) + -
                                                 2
          (%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
          (%o2)                   [46, 46.0, 4.6b1]

     算術計算は式整理であって、評価ではありません。

          (%i1) simp : false;
          (%o1)                         false
          (%i2) '(17 + 29*11/7 - 5^3);
                                        29 11    3
          (%o2)                    17 + ----- - 5
                                          7
          (%i3) simp : true;
          (%o3)                         true
          (%i4) '(17 + 29*11/7 - 5^3);
                                          437
          (%o4)                         - ---
                                           7

     算術計算は（‘listarith’に依存して）リストや行列に対して要素毎に実行
     されます。

          (%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
                                  [ a - 1  x - 2 ]
          (%o1)                   [              ]
                                  [ h - 3  u - 4 ]
          (%i2) 5 * matrix ([a, x], [h, u]);

                                    [ 5 a  5 x ]
          (%o2)                     [          ]
                                    [ 5 h  5 u ]
          (%i3) listarith : false;
          (%o3)                         false
          (%i4) [a, c, m, t] / [1, 7, 2, 9];
                                    [a, c, m, t]
          (%o4)                     ------------
                                    [1, 7, 2, 9]
          (%i5) [a, c, m, t] ^ x;
                                                x
          (%o5)                     [a, c, m, t]
          (%i6) listarith : true;
          (%o6)                         true
          (%i7) [a, c, m, t] / [1, 7, 2, 9];
                                        c  m  t
          (%o7)                     [a, -, -, -]
                                        7  2  9
          (%i8) [a, c, m, t] ^ x;
                                    x   x   x   x
          (%o8)                   [a , c , m , t ]

 -- 演算子: **

     べき乗演算子。 Maximaは入力の中で ‘**’を ‘^’と同じ演算子と認識し、
     1次元出力の中では ‘^’として表示し、 また、2次元出力の中では指数を上
     付き添字として配置します。

     ‘fortran’関数は、入力が ‘**’でも ‘^’でも、 べき乗演算子を ‘**’とし
     て表示します。

     例:

          (%i1) is (a**b = a^b);
          (%o1)                         true
          (%i2) x**y + x^z;
                                        z    y
          (%o2)                        x  + x
          (%i3) string (x**y + x^z);
          (%o3)                        x^z+x^y
          (%i4) fortran (x**y + x^z);
                x**z+x**y
          (%o4)                         done

 -- 演算子: ^^

     非可換べき乗演算子。 ちょうど可換なかけ算 ‘*’に通常のべき乗演算子
     ‘^’が対応するように、 ‘^^’は非可換かけ算 ‘.’に対応するべき乗演算子
     です。

     非可換べき乗演算子は、１次元出力では ‘^^’で表示され、 ２次元出力で
     は、指数をかっこ ‘< >’で囲まれた上付き添字として置きます。

     例:

          (%i1) a . a . b . b . b + a * a * a * b * b;
                                  3  2    <2>    <3>
          (%o1)                  a  b  + a    . b
          (%i2) string (a . a . b . b . b + a * a * a * b * b);
          (%o2)                  a^3*b^2+a^^2 . b^^3

 -- 演算子: .

     行列（非可換）かけ算のためのドット演算子。 ‘"."’をこの意味で用いる
     時、 例えば ‘A . B’のように両側にスペースを置かなければいけません。
     これで浮動小数点の小数点と区別します。

     ‘dot’や ‘dot0nscsimp’, ‘dot0simp’, ‘dot1simp’, ‘dotassoc’,
     ‘dotconstrules’, ‘dotdistrib’, ‘dotexptsimp’, ‘dotident’,
     ‘dotscrules’. も参照してください。


File: maxima.info,  Node: Relational operators,  Next: Logical operators,  Prev: Arithmetic operators,  Up: Operators

7.3 Relational operators
========================

 -- 演算子: <
 -- 演算子: <=
 -- 演算子: >=
 -- 演算子: >

     シンボル ‘<’ ‘<=’ ‘>=’ ‘>’はそれぞれ、小なり、以下、以上、大なり、
     を表します。 これらの演算子の名前は、 ‘"<"’、 ‘"<="’、 ‘">="’、
     ‘">"’です。 それらは関数や演算子の名前が求められるところで使われま
     す。

     これらの関係演算子はすべて二項演算子です; ‘a < b < c’のような構成を
     Maximaは認識しません。

     関数 ‘is’や ‘maybe’、 プログラミング構成子 ‘if’, ‘while’, ‘unless’が
     関係式をブーリアン値に評価します。 そうでなければ、関係式はブーリア
     ン値に評価されたり整理されたりしませんが、 関係式の引数は（評価がク
     ォーテーションによって妨げられないかぎり）評価されます。

     関係式が ‘true’もしくは ‘false’に評価できない時、 ‘is’や ‘if’の振る
     舞いは、グローバルフラグ ‘prederror’が決定します。 ‘prederror’が
     ‘true’の時、 ‘is’や ‘if’はエラーをトリガーします。 ‘prederror’が
     ‘false’の時、 ‘is’は ‘unknown’を返し、 ‘if’は部分的に評価された条件
     式を返します。

     ‘maybe’はいつも、 ‘prederror’が ‘false’であるかのように振る舞い、
     ‘while’や ‘unless’はいつも、 ‘prederror’が ‘true’であるかのように振
     る舞います。

     関係演算子はリストやほかの集合上で展開されることはありません。

     ‘=’や ‘#’、 ‘equal’、 ‘notequal’も参照してください。

     例:

     いくつかの関数やプログラミング構成子が関係式をブーリアン値に評価し
     ます。

          (%i1) [x, y, z] : [123, 456, 789];
          (%o1)                    [123, 456, 789]
          (%i2) is (x < y);
          (%o2)                         true
          (%i3) maybe (y > z);
          (%o3)                         false
          (%i4) if x >= z then 1 else 0;
          (%o4)                           0
          (%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i,
                       return (S));
          (%o5)                         5050

     そうでなければ関係式はブーリアン値に評価されたり整理されたりしませ
     んが、 関係式の引数は評価されます。

          (%o1)                    [123, 456, 789]
          (%i2) [x < y, y <= z, z >= y, y > z];
          (%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
          (%i3) map (is, %);
          (%o3)               [true, true, true, false]


File: maxima.info,  Node: Logical operators,  Next: Operators for Equations,  Prev: Relational operators,  Up: Operators

7.4 Logical operators
=====================

 -- 演算子: and

     論理積演算子。 ‘and’は、n項中置演算子です; オペランドはブーリアン値
     で、結果もブーリアン値です。

     ‘and’は、（‘is’のように）１以上のオペランドの評価を強制し、 すべて
     のオペランドの評価を強制するかもしれません。

     オペランドは、出現順に評価されます。 ‘and’は、結果を決定するのに必
     要なだけオペランドを評価します。 もし任意のオペランドが‘false’なら
     、結果は‘false’であり、 ほかのオペランドは評価されません。

     グローバルフラグ‘prederror’は、 評価されたオペランドが‘true’か
     ‘false’に決定できない時の‘and’の振る舞いを決定します。 ‘prederror’が
     ‘true’の時、‘and’は、エラーメッセージを出力します。 そうでなければ
     、‘true’か‘false’に評価されないオペランドを受け付け、 結果はブーリ
     アン式になります。

     ‘and’は可換ではありません: ‘a and b’は、不定のオペランドの扱いのた
     め、‘b and a’と同値ではないかもしれません。

 -- 演算子: not

     論理否定演算子。 ‘not’は、接頭演算子です; オペランドはブーリアン値
     で、結果もブーリアン値です。

     ‘or’は、（‘is’のように）オペランドの評価を強制します。

     グローバルフラグ‘prederror’は、 評価されたオペランドが‘true’か
     ‘false’に決定できない時の‘not’の振る舞いを決定します。 ‘prederror’が
     ‘true’の時、‘not’は、エラーメッセージを出力します。 そうでなければ
     、‘true’か‘false’に評価されないオペランドを受け付け、 結果はブーリ
     アン式になります。

 -- 演算子: or

     論理和演算子。 ‘or’は、n項中置演算子です; オペランドはブーリアン値
     で、結果もブーリアン値です。

     ‘or’は、（‘is’のように）１以上のオペランドの評価を強制し、 すべての
     オペランドの評価を強制するかもしれません。

     オペランドは、出現順に評価されます。 ‘and’は、結果を決定するのに必
     要なだけオペランドを評価します。 もし任意のオペランドが‘true’なら、
     結果は‘true’であり、 ほかのオペランドは評価されません。

     グローバルフラグ‘prederror’は、 評価されたオペランドが‘true’か
     ‘false’に決定できない時の‘or’の振る舞いを決定します。 ‘prederror’が
     ‘true’の時、‘or’は、エラーメッセージを出力します。 そうでなければ、
     ‘true’か‘false’に評価されないオペランドを受け付け、 結果はブーリア
     ン式になります。

     ‘or’は可換ではありません: ‘a or b’は、不定のオペランドの扱いのため
     、‘b or a’と同値ではないかもしれません。


File: maxima.info,  Node: Operators for Equations,  Next: Assignment operators,  Prev: Logical operators,  Up: Operators

7.5 Operators for Equations
===========================

 -- 演算子: #
     構文的等号‘=’の否定を表します。

     述語論理式の評価のルールのため （特に ‘not <expr>’は <expr>の評価を
     伴うので）、 ‘not <a> = <b>’は、 ‘<a> # <b>’ではなく、 ‘is(<a> #
     <b>)’と同値です。

     例:

          (%i1) a = b;
          (%o1)                         a = b
          (%i2) is (a = b);
          (%o2)                         false
          (%i3) a # b;
          (%o3)                         a # b
          (%i4) not a = b;
          (%o4)                         true
          (%i5) is (a # b);
          (%o5)                         true
          (%i6) is (not a = b);
          (%o6)                         true

 -- 演算子: =

     等式演算子。

     式‘<a> = <b>’は、それ自身、未評価の等式を表します。 等式は成り立つ
     かもしれませんし、成り立たないかもしれません。 未評価の等式は、
     ‘solve’や‘algsys’や他の関数の引数として用いられます。

     関数‘is’は、‘=’をブーリアン値に評価します。 ‘is(<a> = <b>)’は、
     <a>と<b>が同一のとき、 ‘<a> = <b>’を‘true’に評価します。 すなわち、
     <a>と<b>が同一のアトムであるか、もしくは、それらはアトムではなく、
     それらの演算子が同一で、演算子の引数が同一です。 そうでなければ、
     ‘is(<a> = <b>)’は‘false’に評価されます; 決して、‘unknown’には評価さ
     れません。 ‘is(<a> = <b>)’が‘true’の時、 <a>と<b>は、同値の式と対照
     的に、構文法的に等しいと言われます。 同値の式は、‘is(equal(<a>,
     <b>))’が‘true’の式です。 式は、同値だが構文法的に等しくないことが起
     こりえます。

     ‘=’の否定は、‘#’で表されます。 ‘=’と同様、式‘<a> # <b>’は、それ自身
     、評価されません。 ‘is(<a> # <b>)’は、‘<a> # <b>’を‘true’もしくは
     ‘false’に評価します。

     ‘is’に加えて、他のいくつかの演算子が‘=’と‘#’を‘true’もしくは
     ‘false’に評価します。‘if’, ‘and’, ‘or’, ‘not’という演算子です。

     述語論理式の評価規則のため （特に、‘not <expr>’は<expr>の評価を起こ
     すため）、 ‘not <a> = <b>’は、‘<a> # <b>’ではなく、 ‘is(<a> #
     <b>)’と同値になります。

     ‘rhs’と‘lhs’は、それぞれ、等式、不等式の右辺と左辺を返します。

     ‘equal’や‘notequal’も参照してください。

     例:

     式‘<a> = <b>’は、それ自身、未評価の等式であり、成り立つことも成り立
     たないこともあります。

          (%i1) eq_1 : a * x - 5 * y = 17;
          (%o1)                    a x - 5 y = 17
          (%i2) eq_2 : b * x + 3 * y = 29;
          (%o2)                    3 y + b x = 29
          (%i3) solve ([eq_1, eq_2], [x, y]);
                                  196         29 a - 17 b
          (%o3)          [[x = ---------, y = -----------]]
                               5 b + 3 a       5 b + 3 a
          (%i4) subst (%, [eq_1, eq_2]);
                   196 a     5 (29 a - 17 b)
          (%o4) [--------- - --------------- = 17,
                 5 b + 3 a      5 b + 3 a
                                            196 b     3 (29 a - 17 b)
                                          --------- + --------------- = 29]
                                          5 b + 3 a      5 b + 3 a
          (%i5) ratsimp (%);
          (%o5)                  [17 = 17, 29 = 29]

     ‘is(<a> = <b>)’は、 <a>と<b>が構文法的に等しい（すなわち、同一の）
     時 式は、同値だが構文法的に等しくないことがありえます。

          (%i1) a : (x + 1) * (x - 1);
          (%o1)                    (x - 1) (x + 1)
          (%i2) b : x^2 - 1;
                                        2
          (%o2)                        x  - 1
          (%i3) [is (a = b), is (a # b)];
          (%o3)                     [false, true]
          (%i4) [is (equal (a, b)), is (notequal (a, b))];
          (%o4)                     [true, false]

     いくつかの演算子は、‘=’と‘#’を‘true’もしくは‘false’に評価します。

          (%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
                BAR;
          (%o1)                          FOO
          (%i2) eq_3 : 2 * x = 3 * x;
          (%o2)                       2 x = 3 x
          (%i3) eq_4 : exp (2) = %e^2;
                                        2     2
          (%o3)                       %e  = %e
          (%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
          (%o4)                  [false, true, true]

     ‘not <expr>’は<expr>の評価をするので、 ‘not <a> = <b>’は、‘is(<a> #
     <b>)’と同値です。

          (%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
          (%o1)                   [2 x # 3 x, true]
          (%i2) is (2 * x # 3 * x);
          (%o2)                         true


File: maxima.info,  Node: Assignment operators,  Next: User defined operators,  Prev: Operators for Equations,  Up: Operators

7.6 Assignment operators
========================

 -- 演算子: :

     割り当て演算子。

     左辺が（添字のない）単純変数の時、 ‘:’は右辺を評価し、その値を左辺
     に関連づけます。

     左辺がリストや行列、宣言されたMaxima配列、Lisp配列の添字指定された
     要素の時、 右辺がその要素に割り当てられます。 添字は存在している要
     素を示していなければなりません; 先に列挙した対象は、存在していない
     要素を名付けることで拡張することはできません。

     左辺が未宣言のMaxima配列の添字指定された要素の時、 もし既に存在して
     いるなら、右辺はその要素に割り当てられ、 もしまだ存在していなければ
     新しい要素が確保されます。

     左辺が単純変数や添字あり変数のリストの時、 右辺はリストに評価されな
     ければなりません。 そして、右辺の要素が左辺の要素に平行に割り当てら
     れます。

     ‘kill’や‘remvalue’も参照してください。 それらは左辺とその値の関連を
     アンドゥします。

     例:

     単純変数への割り当て

          (%i1) a;
          (%o1)                           a
          (%i2) a : 123;
          (%o2)                          123
          (%i3) a;
          (%o3)                          123

     リストの要素への割り当て

          (%i1) b : [1, 2, 3];
          (%o1)                       [1, 2, 3]
          (%i2) b[3] : 456;
          (%o2)                          456
          (%i3) b;
          (%o3)                      [1, 2, 456]

     割り当ては未宣言配列を生成する。

          (%i1) c[99] : 789;
          (%o1)                          789
          (%i2) c[99];
          (%o2)                          789
          (%i3) c;
          (%o3)                           c
          (%i4) arrayinfo (c);
          (%o4)                   [hashed, 1, [99]]
          (%i5) listarray (c);
          (%o5)                         [789]

     多重割り当て

          (%i1) [a, b, c] : [45, 67, 89];
          (%o1)                     [45, 67, 89]
          (%i2) a;
          (%o2)                          45
          (%i3) b;
          (%o3)                          67
          (%i4) c;
          (%o4)                          89

     多重割り当ては平行に実行されます。 この例では‘a’と‘b’の値が置換され
     ます。

          (%i1) [a, b] : [33, 55];
          (%o1)                       [33, 55]
          (%i2) [a, b] : [b, a];
          (%o2)                       [55, 33]
          (%i3) a;
          (%o3)                          55
          (%i4) b;
          (%o4)                          33

 -- 演算子: ::

     割り当て演算子。

     ‘::’は、‘::’は右辺はもちろん左辺も評価することを除いて、‘:’と同じで
     す。

     例:

          (%i1) x : 'foo;
          (%o1)                          foo
          (%i2) x :: 123;
          (%o2)                          123
          (%i3) foo;
          (%o3)                          123
          (%i4) x : '[a, b, c];
          (%o4)                       [a, b, c]
          (%i5) x :: [11, 22, 33];
          (%o5)                     [11, 22, 33]
          (%i6) a;
          (%o6)                          11
          (%i7) b;
          (%o7)                          22
          (%i8) c;
          (%o8)                          33

 -- 演算子: ::=

     マクロ関数定義の演算子。 ‘::=’は、引数をクォートする関数（歴史的理
     由によりマクロと呼ばれる）を定義します。 そして、それが返す式（マク
     ロ展開と呼ばれる）はマクロが呼ばれた文脈の中で評価されます。 それ以
     外はマクロ関数は通常の関数と同じです。

     ‘macroexpand’は（評価せずに）マクロ展開を返します。 ‘foo’がマクロ関
     数の時、 ‘macroexpand (foo (x))’に続けて ‘``%’を実行すると、 それは
     ‘foo (x)’と同値です。

     ‘::=’は、新しいマクロ関数の名前をグローバルリスト ‘macros’に追加し
     ます。 ‘kill’や ‘remove’, ‘remfunction’は、マクロ関数定義をアンバイ
     ンドし、 ‘macros’から名前を削除します。

     ‘fundef’や ‘dispfun’はそれぞれマクロ関数定義を返し、 それをラベルに
     割り当てます。

     評価対象となる式を構成するために、 マクロ関数は一般的に‘buildq’,
     ‘splice’式を含みます。

     例

     マクロ関数は引数をクォートします。 だから、メッセージ(1)は ‘y - z’の
     値ではなく、 ‘y - z’を示します。 マクロ展開（クォートされた式
     ‘'(print ("(2) x is equal to", x)’）は、 マクロが呼ばれた文脈（表示
     メッセージ(2)）の中で評価されます。

          (%i1) x: %pi$
          (%i2) y: 1234$
          (%i3) z: 1729 * w$
          (%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)))$
          (%i5) printq1 (y - z);
          (1) x is equal to y - z
          (2) x is equal to %pi
          (%o5)                                 %pi

     通常の関数は引数を評価します。だから、メッセージ(1)は ‘y - z’の値を
     示します。 戻り値は評価されず、従って、メッセージ(2)は ‘``%’で陽に
     評価されるまで出力されません。

          (%i1) x: %pi$
          (%i2) y: 1234$
          (%i3) z: 1729 * w$
          (%i4) printe1 (x) := block (print ("(1) x is equal to", x),
                '(print ("(2) x is equal to", x)))$
          (%i5) printe1 (y - z);
          (1) x is equal to 1234 - 1729 w
          (%o5)                     print((2) x is equal to, x)
          (%i6) ''%;
          (2) x is equal to %pi
          (%o6)                                 %pi

     ‘macroexpand’はマクロ展開を返します。 ‘foo’がマクロ関数の時、
     ‘macroexpand (foo (x))’の後 ‘``%’を実行すると、‘foo (x)’と同値です
     。

          (%i1) x: %pi$
          (%i2) y: 1234$
          (%i3) z: 1729 * w$
          (%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$
          (%i5) macroexpand (g (y - z));
          (%o5)                     print(x is equal to, y - z)
          (%i6) ''%;
          x is equal to 1234 - 1729 w
          (%o6)                            1234 - 1729 w
          (%i7) g (y - z);
          x is equal to 1234 - 1729 w
          (%o7)                            1234 - 1729 w

 -- 演算子: :=

     関数定義の演算子。 ‘f(<x_1>, .., <x_n>) := <expr>’は、 引数が<x_1>,
     ..., <x_n>で関数本体が<expr>の、<f>という名前の関数を定義します。
     ‘:=’は（クォートクォート‘``’で陽に評価されない限り）関数本体は評価
     しません。 定義される関数は（引数をかっこでくくる）通常のMaxima関数
     か、（引数をかぎかっこでくくる）配列関数です。

     最後の引数<x_n>が要素１つのリストの時、‘:=’で定義された関数は可変の
     数の引数をとります。 実際の引数は、形式的な引数<x_1>, …, <x_(n -
     1)>に一対一に割り当てられ、 さらに引数があれば、<x_n>にリストとして
     割り当てられます。

     関数定義すべては、同じ名前空間を使います; 別の関数‘g’の中で関数
     ‘f’を定義することは、‘f’のスコープを‘g’に限定しません。 しかし、
     ‘local(f)’は、関数‘f’の定義を‘local’が現れたブロックや他の合成式内
     に限定します。

     もしある形式引数<x_k>がクォートされたシンボルなら、‘:=’で定義された
     関数は対応する実際の引数を評価しません。 それ以外の場合、実際の引数
     はすべて評価されます。

     ‘define’や‘::=’も参照してください。

     例:

     ‘:=’は（クォートクォートで陽に評価されない限り）関数本体を評価しま
     せん。

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) F1 (x, y) := expr;
          (%o2)                   F1(x, y) := expr
          (%i3) F1 (a, b);
          (%o3)                    cos(y) - sin(x)
          (%i4) F2 (x, y) := ''expr;
          (%o4)              F2(x, y) := cos(y) - sin(x)
          (%i5) F2 (a, b);
          (%o5)                    cos(b) - sin(a)

     ‘:=’で定義された関数は、通常のMaxima関数か、配列関数です。

          (%i1) G1 (x, y) := x.y - y.x;
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) G2 [x, y] := x.y - y.x;
          (%o2)                G2     := x . y - y . x
                                 x, y

     最後の引数<x_n>が要素１つのリストの時、 ‘:=’で定義された関数は、可
     変の数の引数を取ります。

          (%i1) H ([L]) := apply ("+", L);
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     ‘local’はローカル関数定義を可能にします。

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99


File: maxima.info,  Node: User defined operators,  Prev: Assignment operators,  Up: Operators

7.7 User defined operators
==========================

 -- 関数: infix (<op>)
 -- 関数: infix (<op>, <lbp>, <rbp>)
 -- 関数: infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)

     <op>を中置演算子に宣言します。 中置演算子は２つの引数の関数で、引数
     の間に関数名が来ます。 例えば、引き算演算子‘-’は中置演算子です。

     ‘infix (<op>)’は、デフォルトの結合力（左右両方とも180）と品詞 （左
     右両方とも‘any’)に等しい）で<op>を中置演算子に宣言します。

     ‘infix (<op>, <lbp>, <rbp>)’は、 記述された左右の結合力 とデフォル
     トの品詞（左右両方とも‘any’)に等しい）で、 <op>を中置演算子に宣言し
     ます。

     ‘infix (<op>, <lbp>, <rbp>, <lpos>, <rpos>, <pos>)’は、 記述された
     左右の結合力と、 左オペランド、右オペランド、演算子結果それぞれにつ
     いて、 品詞を<lpos>, <rpos>, <pos>に設定して、 <op>を中置演算子に宣
     言します。

     （演算子宣言に関係して）「品詞」は、式のタイプを意味します。 ３つの
     タイプが認識されます; ‘expr’, ‘clause’, ‘any’。それぞれは、 代数式
     、ブーリアン式、任意の種類の式を示します。 Maximaは、宣言された品詞
     を実際の式に比較することで、 いくつかの構文法エラーを検出します。

     他の演算子に関する<op>の優先順位は、問題となっている演算子の左右結
     合力から演繹されます。 もし<op>の左右結合力のどちらもある他の演算子
     の左右結合力より大きいなら、 <op>は、他の演算子より高い優先順位をと
     ります。 もし結合力がどちらも大きくも、どちらも小さくもなければ、 あ
     るもっと複雑な関係が成り立ちます。

     <op>の結合性は結合力に依存します。 より大きな左結合力(<lbp>)は、
     <op>のインスタンスが 式の中で左にある他の演算子の前に評価されること
     を示し、 より大きな右結合力(<rbp>)は、<op>のインスタンスが 式の中で
     右にある他の演算子の前に評価されることを示します。 このように、より
     大きな<lbp>は<op>を右結合にし、 より大きな<rbp>は<op>を左結合にしま
     す。 もし<lbp>が<rbp>と等しいなら、 <op>は左結合です。

     ‘Syntax’も参照してください。

     例:

     もし<op>左右結合力それぞれが、他の演算子のそれより大きいなら、
     <op>は他の演算子より高い優先順位をとります。

          (%i1) :lisp (get '$+ 'lbp)
          100
          (%i1) :lisp (get '$+ 'rbp)
          100
          (%i1) infix ("##", 101, 101);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
          (%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
          (%i3) 1 + a ## b + 2;
          (%o3)                       (a,b) + 3
          (%i4) infix ("##", 99, 99);
          (%o4)                          ##
          (%i5) 1 + a ## b + 2;
          (%o5)                       (a+1,b+2)

     より大きな<lbp>は<op>を右結合にし、 より大きな<rbp>は<op>を左結合に
     します。

          (%i1) infix ("##", 100, 99);
          (%o1)                          ##
          (%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
          (%i3) foo ## bar ## baz;
          (%o3)                    (foo,(bar,baz))
          (%i4) infix ("##", 100, 101);
          (%o4)                          ##
          (%i5) foo ## bar ## baz;
          (%o5)                    ((foo,bar),baz)

     Maximaは、宣言された品詞を実際の式と比較することで、 いくつかの構文
     法エラーを検出します。

          (%i1) infix ("##", 100, 99, expr, expr, expr);
          (%o1)                          ##
          (%i2) if x ## y then 1 else 0;
          Incorrect syntax: Found algebraic expression where logical
          expression expected
          if x ## y then
                       ^
          (%i2) infix ("##", 100, 99, expr, expr, clause);
          (%o2)                          ##
          (%i3) if x ## y then 1 else 0;
          (%o3)                if x ## y then 1 else 0

 -- 関数: matchfix (<ldelimiter>, <rdelimiter>)
 -- 関数: matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)

     左と右の区切り記号<ldelimiter>と<rdelimiter>を持つ matchfix演算子を
     宣言します 区切り記号は文字列として指定されます。

     "matchfix"演算子は、 任意の数の引数の関数で、引数は左と右の区切り記
     号をマッチする間で現れます。 パーサがオペランドや他の式や演算子から
     区切り記号を区別できる限り 区切り記号は任意の文字列を取り得ます。 実
     際には、これは、‘%’, ‘,’, ‘$’, ‘;’のような パースできない区切り記号
     を除外し、空白を持つ区切り記号を分離することを要求するかもしれませ
     ん。 右区切り記号は、左区切り記号と同じかもしれませんし、違うかもし
     れません。

     左区切り記号は、たった１つの右区切り記号と関連づけられることができ
     ます; ２つの異なるmatchfix演算子は同じ左区切り記号を持つことはでき
     ません。

     存在する演算子は、 他のプロパティを変えることなく、 matchfix演算子
     として再宣言することができます。 特に、足し算‘+’のような組み込み演
     算子が matchfixに宣言されることが可能ですが、 演算子関数は組み込み
     演算子に関して定義できません。

     コマンド‘matchfix (<ldelimiter>, <rdelimiter>, <arg_pos>, <pos>)’ は
     、 引数品詞<arg_pos>と結果品詞<pos>、区切り記号 <ldelimiter>と
     <rdelimiter>を宣言します。

     演算子宣言に関して、「品詞」は式のタイプを意味します。 ３つのタイプ
     が認識されます: それぞれ、代数式、ブーリアン式、任意の種類の式を示
     す、 ‘expr’, ‘clause’, ‘any’。 Maximaは、 宣言された品詞を実際の式
     と比較することで、 いくつかの構文法エラーを検知します。

     matchfix演算を実行する関数は通常のユーザー定義関数です。 演算子関数
     は、 関数定義演算子‘:=’や‘define’を使って 普通の方法で定義されます
     。 引数は、区切り記号の間に書かれるか、 クォートされた文字列として
     の左区切り記号と括弧の中で続く引数を使って書かれます。 ‘dispfun
     (<ldelimiter>)’は関数定義を表示します。

     唯一の組み込みmatchfix演算子はリスト構成子‘[ ]’です。 括弧‘( )’とダ
     ブルクォート‘" "’はmatchfix演算子のように振る舞いますが、 Maximaパ
     ーサによってそのようには扱われません。

     ‘matchfix’は引数を評価します。 ‘matchfix’は最初の引数<ldelimiter>を
     返します。

     例:

     区切り記号はほとんど任意の文字列を取り得ます。

          (%i1) matchfix ("@@", "~");
          (%o1)                          @@
          (%i2) @@ a, b, c ~;
          (%o2)                      @@a, b, c~
          (%i3) matchfix (">>", "<<");
          (%o3)                          >>
          (%i4) >> a, b, c <<;
          (%o4)                      >>a, b, c<<
          (%i5) matchfix ("foo", "oof");
          (%o5)                          foo
          (%i6) foo a, b, c oof;
          (%o6)                     fooa, b, coof
          (%i7) >> w + foo x, y oof + z << / @@ p, q ~;
                               >>z + foox, yoof + w<<
          (%o7)                ----------------------
                                      @@p, q~

     Matchfix演算子は通常のユーザー定義関数です。

          (%i1) matchfix ("!-", "-!");
          (%o1)                         "!-"
          (%i2) !- x, y -! := x/y - y/x;
                                              x   y
          (%o2)                   !-x, y-! := - - -
                                              y   x
          (%i3) define (!-x, y-!, x/y - y/x);
                                              x   y
          (%o3)                   !-x, y-! := - - -
                                              y   x
          (%i4) define ("!-" (x, y), x/y - y/x);
                                              x   y
          (%o4)                   !-x, y-! := - - -
                                              y   x
          (%i5) dispfun ("!-");
                                              x   y
          (%t5)                   !-x, y-! := - - -
                                              y   x

          (%o5)                         done
          (%i6) !-3, 5-!;
                                          16
          (%o6)                         - --
                                          15
          (%i7) "!-" (3, 5);
                                          16
          (%o7)                         - --
                                          15

 -- 関数: nary (<op>)
 -- 関数: nary (<op>, <bp>, <arg_pos>, <pos>)

     ‘nary’演算子は 任意の数の引数の関数を示すのに使われます。 引数それ
     ぞれは、例えば、A+BやA+B+Cように演算子の出現で分離されます。
     ‘nary("x")’関数は ‘x’を ‘nary’演算子に宣言する構文拡張関数です。 関
     数は ‘nary’であると宣言されるかもしれません。 もし
     ‘declare(j,nary);’が実行されたら、 これは整理器に 例えば、
     ‘j(j(a,b),j(c,d))’を ‘j(a, b, c, d)’に整理するよう指示します。

     *note Introduction to operators::も参照してください。

 -- 関数: nofix (<op>)
 -- 関数: nofix (<op>, <pos>)

     ‘nofix’演算子は引数のない関数を示すのに使われます。 コマンドにそん
     な演算子が存在すると、 対応する関数が評価されるだけです。 例えば、
     Maximaブレイクから抜けるために"exit;"とタイプする時、 "exit"は
     ‘nofix’演算子と似たように振る舞います。 関数 ‘nofix("x")’は ‘x’を
     ‘nofix’演算子に宣言する構文拡張関数です。

     *note Introduction to operators::も参照してください。

 -- 関数: postfix (<op>)
 -- 関数: postfix (<op>, <lbp>, <lpos>, <pos>)

     ‘prefix’変種のような‘postfix’演算子は引数一つの関数を示しますが、 こ
     の場合、例えば3!のように、入力文字列の中で引数が演算子に先行します
     。 ‘postfix("x")’関数は ‘x’を‘postfix’演算子に宣言する構文拡張関数
     です。

     *note Introduction to operators::も参照してください。

 -- 関数: prefix (<op>)
 -- 関数: prefix (<op>, <rbp>, <rpos>, <pos>)

     ‘prefix’演算子は引数一つの関数であり、 その引数は演算子のすぐ後ろに
     置かれます。 ‘prefix("x")’は ‘x’を‘prefix’演算子に宣言する構文拡張
     関数です。

     *note Introduction to operators::も参照してください。


File: maxima.info,  Node: Evaluation,  Next: Simplification,  Prev: Operators,  Up: Top

8 Evaluation
************

* Menu:

* Functions and Variables for Evaluation::


File: maxima.info,  Node: Functions and Variables for Evaluation,  Prev: Evaluation,  Up: Evaluation

8.1 Functions and Variables for Evaluation
==========================================

 -- 演算子: '

     シングルクォート演算子‘'’は評価を抑制します。

     シンボルにシングルクォートを用いると、シンボルが評価されません。

     関数コールにシングルクォートを用いると、 関数の引数は（抑制されない
     限り）評価されますが、関数コールは評価されません。結果は、関数コー
     ルの名詞形です。

     括弧でくくられた式にシングルクォートを用いると、 式の中のすべてのシ
     ンボルと関数コールは評価されません。 例えば、‘'(f(x))’は、式
     ‘f(x)’を評価しないことを意味します。 ‘'f(x)’（‘f(x)’ではなく‘f’へ適
     用されたシングルクォート）は‘[x]’に適用された‘f’の名詞形を返します
     。

     シングルクォートは式整理を抑制しません。

     グローバルフラグ ‘noundisp’が ‘true’の時、名詞はシングルクォート付
     きで表示されます。 このスイッチは関数定義を表示するときには、常に
     ‘true’です。

     クォートクォート演算子 ‘''’と ‘nouns’も参照ください。

     例:

     シンボルにシングルクォートを用いると、シンボルが評価されません。

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) aa^2;
          (%o2)                        1048576
          (%i3) 'aa^2;
                                           2
          (%o3)                          aa
          (%i4) ''%;
          (%o4)                        1048576

     関数コールにシングルクォートを用いると、関数の引数は評価されますが
     、関数コールが評価されません。 結果は、関数コールの名詞形です。

          (%i1) x0: 5;
          (%o1)                           5
          (%i2) x1: 7;
          (%o2)                           7
          (%i3) integrate (x^2, x, x0, x1);
                                         218
          (%o3)                          ---
                                          3
          (%i4) 'integrate (x^2, x, x0, x1);
                                       7
                                      /
                                      [   2
          (%o4)                       I  x  dx
                                      ]
                                      /
                                       5
          (%i5) %, nouns;
                                         218
          (%o5)                          ---
                                          3

     括弧でくくられた式にシングルクォートを用いると、式の中のすべてのシ
     ンボルと関数コールは評価されません。

          (%i1) aa: 1024;
          (%o1)                         1024
          (%i2) bb: 19;
          (%o2)                          19
          (%i3) sqrt(aa) + bb;
          (%o3)                          51
          (%i4) '(sqrt(aa) + bb);
          (%o4)                     bb + sqrt(aa)
          (%i5) ''%;
          (%o5)                          51

     シングルクォートは式整理を抑制しません。

          (%i1) sin (17 * %pi) + cos (17 * %pi);
          (%o1)                          - 1
          (%i2) '(sin (17 * %pi) + cos (17 * %pi));
          (%o2)                          - 1

     Maximaは組み込み数学関数による浮動小数点演算を整理とみなします。

          (%i1) sin(1.0);
          (%o1)                          .8414709848078965
          (%i2) '(sin(1.0));
          (%o2)                          .8414709848078965

 -- 演算子: ''
     クォートクォート演算子‘''’(シングルクォートマーク２つ）は、入力式の
     中の評価を部分修正します。

     一般式<expr>にクォートクォートを用いると、入力式の中の<expr>に
     <expr>の値を代入します。

     式の演算子にクォートクォートを用いると、（もし動詞でないなら）演算
     子は名詞から動詞に変わります。

     クォートクォート演算子は入力パーサが適用します; クォートクォート演
     算子はパースされた入力式の一部としては格納されません。 クォートクォ
     ート演算子は、パースされるといつもすぐに適用され、クォートできませ
     ん。 このように、関数定義やラムダ式、シングルクォート‘'’でクォート
     された式の中のように通常評価が抑制される時も、 クォートクォートがあ
     ると評価を実行します。

     ‘batch’や‘load’はクォートクォートを認識します。

     シングルクォート演算子 ‘'’と ‘nouns’も参照ください。

     例:

     一般式<expr>にクォートクォートを用いると、入力式の中の<expr>に
     <expr>の値を代入します。

          (%i1) expand ((a + b)^3);
                               3        2      2      3
          (%o1)               b  + 3 a b  + 3 a  b + a
          (%i2) [_, ''_];
                                   3    3        2      2      3
          (%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i3) [%i1, ''%i1];
                                   3    3        2      2      3
          (%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
          (%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
          (%o4)                   [cc, dd, 17, 29]
          (%i5) foo_1 (x) := aa - bb * x;
          (%o5)                 foo_1(x) := aa - bb x
          (%i6) foo_1 (10);
          (%o6)                      cc - 10 dd
          (%i7) ''%;
          (%o7)                         - 273
          (%i8) ''(foo_1 (10));
          (%o8)                         - 273
          (%i9) foo_2 (x) := ''aa - ''bb * x;
          (%o9)                 foo_2(x) := cc - dd x
          (%i10) foo_2 (10);
          (%o10)                        - 273
          (%i11) [x0 : x1, x1 : x2, x2 : x3];
          (%o11)                    [x1, x2, x3]
          (%i12) x0;
          (%o12)                         x1
          (%i13) ''x0;
          (%o13)                         x2
          (%i14) '' ''x0;
          (%o14)                         x3

     式の演算子にクォートクォートを用いると、（もし動詞でないなら）演算
     子は名詞から動詞に変わります。

          (%i1) declare (foo, noun);
          (%o1)                         done
          (%i2) foo (x) := x - 1729;
          (%o2)                 ''foo(x) := x - 1729
          (%i3) foo (100);
          (%o3)                       foo(100)
          (%i4) ''foo (100);
          (%o4)                        - 1629

     クォートクォート演算子は入力パーサが適用します； クォートクォート演
     算子はパースされた入力式の一部としては格納されません。

          (%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
          (%o1)                 [bb, dd, 1234, 5678]
          (%i2) aa + cc;
          (%o2)                        dd + bb
          (%i3) display (_, op (_), args (_));
                                     _ = cc + aa

                                   op(cc + aa) = +

                              args(cc + aa) = [cc, aa]

          (%o3)                         done
          (%i4) ''(aa + cc);
          (%o4)                         6912
          (%i5) display (_, op (_), args (_));
                                     _ = dd + bb

                                   op(dd + bb) = +

                              args(dd + bb) = [dd, bb]

          (%o5)                         done

     関数定義やラムダ式、シングルクォート‘'’でクォートされた式の中のよう
     に 通常評価が抑制される時も、 クォートクォートがあると評価を実行し
     ます。

          (%i1) foo_1a (x) := ''(integrate (log (x), x));
          (%o1)               foo_1a(x) := x log(x) - x
          (%i2) foo_1b (x) := integrate (log (x), x);
          (%o2)           foo_1b(x) := integrate(log(x), x)
          (%i3) dispfun (foo_1a, foo_1b);
          (%t3)               foo_1a(x) := x log(x) - x

          (%t4)           foo_1b(x) := integrate(log(x), x)

          (%o4)                      [%t3, %t4]
          (%i5) integrate (log (x), x);
          (%o5)                     x log(x) - x
          (%i6) foo_2a (x) := ''%;
          (%o6)               foo_2a(x) := x log(x) - x
          (%i7) foo_2b (x) := %;
          (%o7)                    foo_2b(x) := %
          (%i8) dispfun (foo_2a, foo_2b);
          (%t8)               foo_2a(x) := x log(x) - x

          (%t9)                    foo_2b(x) := %

          (%o9)                      [%t7, %t8]
          (%i10) F : lambda ([u], diff (sin (u), u));
          (%o10)             lambda([u], diff(sin(u), u))
          (%i11) G : lambda ([u], ''(diff (sin (u), u)));
          (%o11)                  lambda([u], cos(u))
          (%i12) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
          (%o12)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                              k                  k
          (%i13) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
          (%o13)             b  + a  + b  + a  + b  + a
                              3    3    2    2    1    1

 -- 関数: alias (<new_name_1>, <old_name_1>, ..., <new_name_n>,
          <old_name_n>)
     (利用者もしくはシステム)関数や変数、配列等に対して別名を与えます。
     任意の偶数個の引数を取ります。

 -- 関数: ev (<expr>, <arg_1>, …, <arg_n>)

     引数<arg_1>, …, <arg_n>で指定された環境下で 式<expr>を評価します。
     引数は、スイッチ（ブーリアンフラグ）だったり、割り当てだったり、 等
     式だったり、関数だったりします。 <ev>は評価の結果（別の式）を返しま
     す。

     評価は以下のようにステップを追って実行されます。

       1. 最初に、以下の任意のもしくはすべての引数をスキャンして環境を準
          備します。

             • ‘simp’を引数に指定すると<expr>を整理します。‘false’なら整
               理を抑制するスイッチ‘simp’の設定に関わらずです。
             • ‘noeval’を引数に指定すると‘ev’の評価フェイズを抑制します
               。 （以下のステップ(4)を参照してください。） これは、他の
               スイッチとの連携時や、<expr>を再評価せずに再整理をさせる
               時に役に立ちます。
             • ‘nouns’を引数に指定すると<expr>の中の名詞形式 （典型的に
               は、‘'integrate’や‘'diff’のような未評価関数）を評価します
               。
             • ‘expand’を引数に指定すると展開します。
             • ‘expand (<m>, <n>)’を引数に指定すると、 ‘maxposex’と
               ‘maxnegex’の値をそれぞれ<m>と<n>に設定して、展開します。
             • ‘detout’を引数に指定すると、<expr>の中で計算されるどんな
               逆行列も、逆行列の外側に行列式を保つようにします。
             • ‘diff’を引数に指定すると<expr>の中のすべての微分を実行し
               ます。
             • ‘derivlist (<x>, <y>, <z>, ...)’を引数に指定すると指定さ
               れた変数に関する微分のみを実行します。
             • ‘risch’を引数に指定すると <expr>の中の積分をRischアルゴリ
               ズムを使って評価します。 ‘risch’を参照してください。 特殊
               なシンボル‘nouns’を使った時には標準の積分ルーチンが呼び出
               されます。
             • ‘float’を引数に指定すると非整数有理数を浮動小数点に変換し
               ます。
             • ‘numer’を引数に指定すると数値引数が指定された（指数関数を
               含む）いくつかの数学関数を浮動小数点に評価します。 また、
               <expr>の中の numerval宣言された変数は、宣言された値に置き
               換えられます。 また、‘float’スイッチをオンにします。
             • ‘pred’を引数に指定すると述語（‘true’もしくは‘false’に評価
               される式）を評価します。
             • ‘eval’を引数に指定すると<expr>の特別な後評価をします。（
               ステップ(5)を参照。） ‘eval’は複数回起こるかもしれません
               。‘eval’のそれぞれのインスタンスのために、式は再評価され
               ます。
             • 評価フラグ（‘evflag’を参照）として宣言されたアトム‘A’を引
               数に指定すると、 <expr>の評価の最中、‘A’が‘true’にバイン
               ドされます。
             • ‘V: expression’（もしくは代わりに‘V=expression’）を引数に
               指定すると、 <expr>の評価の最中、‘V’が‘expression’の値に
               バインドされます。 もし‘V’がMaximaオプションなら、
               <expr>の評価の最中、‘V’の値に‘expression’が使われることに
               注意してください。 もし‘ev’の複数の引数がこのタイプの場合
               、並列してバインドされます。 もし‘V’が非アトムの式なら、
               バインドではなく、代入が実行されます。
             • 関数名 ‘F’が評価関数(‘evfun’参照)として宣言されている場合
               、 ‘F’を引数に指定すると ‘F’が <expr>に適用されます。
             • 他のどんな関数名（例えば、‘sum’)でも引数に指定すると、
               <expr>の中にそれらの名前が現れた時それらが動詞であるかの
               ように評価します。
             • 加えて、exprの中で出現する関数（‘F(x)’としましょう）を、
               <expr>の今回の評価の目的のため、 ‘F(X) := expression’を
               ‘ev’の引数に与えて、局所的に定義することができます。
             • もし以上で言及しなかったアトム、添字付き変数、または、添
               字付き式が引数として与えられたら、 それを評価して、 もし
               その結果が等式もしくは割り当てであったら、示されたバイン
               ドもしくは代入を実行します。 もしその結果がリストなら、リ
               ストのメンバが、 ‘ev’に与えられた追加の引数であるかのよう
               に扱います。 これにより、 ‘solve’が返すような、与えられた
               等式のリスト （例えば、 ‘[X=1,Y=A**2]’)や 等式の名前のリ
               スト（例えば、 ‘[%t1, %t2]’。ここで ‘%t1’, ‘%t2’は等式）
               が使えます。

          ‘ev’の引数は、代入等式と評価関数以外はどんな順序で与えてもかま
          いません。 代入等式は左から右へ順に扱われ、 評価関数は、例えば
          、 ‘ev (<expr>, ratsimp, realpart)’は ‘realpart (ratsimp
          (<expr>))’と扱われるように、合成されます。

          ‘simp’, ‘numer’, ‘float’スイッチは、ブロックの中でローカルにも
          、 またMaximaの中でグローバルにも設定でき、その場合，リセット
          されるまで効果を保ちます。

          ‘numer’と‘float’スイッチがともに‘true’でない場合、 もし
          <expr>が標準有理式(CRE)なら、‘ev’が返す式もまたCREです。

       2. step (1)の最中に、引数の中のもしくは引数の値の、等式の左辺に現
          れる添字なしの変数のリストを作ります。 <expr>の中の変数（添字
          なし変数や配列関数に関連づけられていない添字付き変数）は、 先
          のリストに現れるものを除いて、グローバルな値に置き換えられます
          。 普通、 <expr>は、ただのラベルだったり (以下の例の ‘%i2’のよ
          うに） ‘%’だったりするので、 その場合，このステップは単にラベ
          ルされた式を取り出し、 ‘ev’はその式に対して機能することになり
          ます。

       3. 引数で指定されたどんな代入文もすぐ実行されます。

       4. （引数で‘noeval’が指定されていない限り）結果の式は再評価され、
          引数に従って整理されます。 <expr>の中のどんな関数コールもその
          中の変数が評価された後実行されること、 ‘ev(F(x))’は
          ‘F(ev(x))’のように振る舞うことに注意してください。

       5. 引数の中の‘eval’のそれぞれのインスタンスのために、step (3)(4)を
          繰り返します。

     例:

          (%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                               d                    2
          (%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                               dw
          (%i2) ev (%, numer, expand, diff, x=2, y=1);
                                       2
          (%o2)              cos(w) + w  + 2 w + cos(1) + 2.449599732693821

     ‘ev’のために、代わりのトップレベルの文法が提供されています。 それに
     よって、‘ev()’なしに引数をタイプして入力するだけでよくなります。 す
     なわち、単に以下のように書けます。

          <expr>, <arg_1>, ..., <arg_n>

     これは、例えば、関数やブロックの中など、他の式の一部としては許され
     ません。

     以下の例では並列のバインドプロセスに注意してください。

          (%i3) programmode: false;
          (%o3)                                false
          (%i4) x+y, x: a+y, y: 2;
          (%o4)                              y + a + 2
          (%i5) 2*x - 3*y = 3$
          (%i6) -3*x + 2*y = -4$
          (%i7) solve ([%o5, %o6]);
          Solution

                                                    1
          (%t7)                               y = - -
                                                    5

                                                   6
          (%t8)                                x = -
                                                   5
          (%o8)                            [[%t7, %t8]]
          (%i8) %o6, %o8;
          (%o8)                              - 4 = - 4
          (%i9) x + 1/x > gamma (1/2);
                                             1
          (%o9)                          x + - > sqrt(%pi)
                                             x
          (%i10) %, numer, x=1/2;
          (%o10)                      2.5 > 1.772453850905516
          (%i11) %, pred;
          (%o11)                               true

 -- 特殊シンボル: eval

     ‘ev (<expr>)’のコールの引数として、 ‘eval’は <expr>の追加の評価をも
     たらします。 ‘ev’を参照してください。

     例:

          (%i1) [a:b,b:c,c:d,d:e];
          (%o1)                            [b, c, d, e]
          (%i2) a;
          (%o2)                                  b
          (%i3) ev(a);
          (%o3)                                  c
          (%i4) ev(a),eval;
          (%o4)                                  e
          (%i5) a,eval,eval;
          (%o5)                                  e

 -- プロパティ: evflag

     シンボル‘x’が‘evflag’プロパティを持つ時、 式‘ev(<expr>, <x>)’や対話
     プロンプトでの‘<expr>, <x>’は、 ‘ev(<expr>, <x> = true)’と同値です
     。 すなわち、<expr>が評価される間、<x>は‘true’にバインドされます。

     式‘declare(<x>, evflag)’は、変数<x>に‘evflag’プロパティを与えます。

     デフォルトで‘evflag’プロパティを持つフラグは以下の通りです:

        algebraic          cauchysum       demoivre
        dotscrules         %emode          %enumer
        exponentialize     exptisolate     factorflag
        float              halfangles      infeval
        isolate_wrt_times  keepfloat       letrat
        listarith          logabs          logarc
        logexpand          lognegint       lognumer
        m1pbranch          numer_pbranch   programmode
        radexpand          ratalgdenom     ratfac
        ratmx              ratsimpexpons   simp
        simpproduct        simpsum         sumexpand
        trigexpand

     例:

          (%i1) sin (1/2);
                                           1
          (%o1)                        sin(-)
                                           2
          (%i2) sin (1/2), float;
          (%o2)                   0.479425538604203
          (%i3) sin (1/2), float=true;
          (%o3)                   0.479425538604203
          (%i4) simp : false;
          (%o4)                         false
          (%i5) 1 + 1;
          (%o5)                         1 + 1
          (%i6) 1 + 1, simp;
          (%o6)                           2
          (%i7) simp : true;
          (%o7)                         true
          (%i8) sum (1/k^2, k, 1, inf);
                                      inf
                                      ====
                                      \     1
          (%o8)                        >    --
                                      /      2
                                      ====  k
                                      k = 1
          (%i9) sum (1/k^2, k, 1, inf), simpsum;
                                           2
                                        %pi
          (%o9)                         ----
                                         6
          (%i10) declare (aa, evflag);
          (%o10)                        done
          (%i11) if aa = true then YES else NO;
          (%o11)                         NO
          (%i12) if aa = true then YES else NO, aa;
          (%o12)                         YES

 -- プロパティ: evfun

     関数<F>が‘evfun’プロパティを持つ時、 式‘ev(<expr>, <F>)’や（対話プ
     ロンプトでの）‘<expr>, <F>’は、 ‘<F>(ev(<expr>))’と同値です。

     もし２つ以上の‘evfun’関数<F>, <G>などが指定されたなら、関数は指定さ
     れた順に適用されます。

     式‘declare(<F>, evfun)’は、関数<F>に‘evfun’プロパティを与えます。

     デフォルトで‘evfun’プロパティを持つ関数は以下の通りです:

        bfloat          factor       fullratsimp
        logcontract     polarform    radcan
        ratexpand       ratsimp      rectform
        rootscontract   trigexpand   trigreduce

     例:

          (%i1) x^3 - 1;
                                        3
          (%o1)                        x  - 1
          (%i2) x^3 - 1, factor;
                                          2
          (%o2)                 (x - 1) (x  + x + 1)
          (%i3) factor (x^3 - 1);
                                          2
          (%o3)                 (x - 1) (x  + x + 1)
          (%i4) cos(4 * x) / sin(x)^4;
                                      cos(4 x)
          (%o4)                       --------
                                         4
                                      sin (x)
          (%i5) cos(4 * x) / sin(x)^4, trigexpand;
                           4           2       2         4
                        sin (x) - 6 cos (x) sin (x) + cos (x)
          (%o5)         -------------------------------------
                                          4
                                       sin (x)
          (%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                                     2         4
                                6 cos (x)   cos (x)
          (%o6)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                                     2         4
                                6 cos (x)   cos (x)
          (%o7)               - --------- + ------- + 1
                                    2          4
                                 sin (x)    sin (x)
          (%i8) declare ([F, G], evfun);
          (%o8)                         done
          (%i9) (aa : bb, bb : cc, cc : dd);
          (%o9)                          dd
          (%i10) aa;
          (%o10)                         bb
          (%i11) aa, F;
          (%o11)                        F(cc)
          (%i12) F (aa);
          (%o12)                        F(bb)
          (%i13) F (ev (aa));
          (%o13)                        F(cc)
          (%i14) aa, F, G;
          (%o14)                      G(F(cc))
          (%i15) G (F (ev (aa)));
          (%o15)                      G(F(cc))

 -- オプション変数: infeval

     「無限評価」モードにします。‘ev’は、値が変わらなくなるまで式を繰り
     返し評価します。 このモードで変数(‘X’とします）が評価されることを避
     けるには、単に‘X='X’を‘ev’の引数として含めます。 ‘ev (X, X=X+1,
     infeval)’のような式は、もちろん、無限ループを引き起こします。

 -- 特殊シンボル: noeval

     ‘noeval’は、‘ev’の評価フェイズを抑制します。 これは、他のスイッチと
     の関連や、 式を再評価することなしに再整理するのに役に立ちます。

 -- 特殊シンボル: nouns

     ‘nouns’は‘evflag’の１つです。 ‘ev’コマンドのオプションとして使われ
     る時、 ‘nouns’は、式の中に現れる「名詞」形すべてを「動詞」に‘ev’し
     ます。すなわち、それらを評価します。 ‘noun’, ‘nounify’, ‘verb’,
     ‘verbify’も参照してください。

 -- 特殊シンボル: pred

     ‘ev (<expr>)’のコールでの引数として、 ‘pred’は、 述語論理(‘true’ま
     たは‘false’に評価される式)を評価するようにします。 ‘ev’を参照してく
     ださい。

     例:

          (%i1) 1<2;
          (%o1)                                1 < 2
          (%i2) 1<2,pred;
          (%o2)                                true

