This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Sets,  Next: Function Definition,  Prev: Rules and Patterns,  Up: Top

35 Sets
*******

* Menu:

* Introduction to Sets::       
* Functions and Variables for Sets::       


File: maxima.info,  Node: Introduction to Sets,  Next: Functions and Variables for Sets,  Prev: Sets,  Up: Sets

35.1 Introduction to Sets
=========================

Maximaは、 陽な列挙によって定義された有限集合のために、 積集合や和集合の
ような、集合関数を提供します。 Maximaは、リストと集合を別のオブジェクト
として扱います。 この特長は、 リストまたは集合であるメンバーがリストであ
ったり集合であったりする集合を扱うことを可能にします。

   有限集合のための関数に加えて、 Maximaは、 組み合わせ論に関係したいく
つかの関数を提供します; これらは、第一種と第二種スターリング数、ベル数、
第一種と第二種の多項係数、 非負整数の分割、と2,3の他の関数です。 Maximaは
、クロネッカーのデルタ関数も定義します。

35.1.1 Usage
------------

メンバー‘a_1, ..., a_n’の集合を構成するには、 ‘set(a_1, ..., a_n)’または
‘{a_1, ..., a_n}’を書いてください; 空集合を構成するには、 ‘set()’または
‘{}’を書いてください。 入力では、 ‘set(...)’と‘{ ... }’は同値です。 集合
は、いつも中括弧で表示されます。

   もしメンバーが一度以上リストされているなら、 整理は、冗長なメンバーを
消去します。

     (%i1) set();
     (%o1)                          {}
     (%i2) set(a, b, a);
     (%o2)                        {a, b}
     (%i3) set(a, set(b));
     (%o3)                       {a, {b}}
     (%i4) set(a, [b]);
     (%o4)                       {a, [b]}
     (%i5) {};
     (%o5)                          {}
     (%i6) {a, b, a};
     (%o6)                        {a, b}
     (%i7) {a, {b}};
     (%o7)                       {a, {b}}
     (%i8) {a, [b]};
     (%o8)                       {a, [b]}

   ２つの要素志望<x>と<y>は、 ‘is(<x> = <y>)’が‘true’をもたらす (すなわ
ち、集合構成の目的で同じと見なされる) 時だけ 冗長です。 ‘is(<x> = <y>)’が
‘false’をもたらす一方、 ‘is(equal(<x>, <y>))’は、‘true’をもたらす可能性
があることに 注意してください; その場合、要素<x>と<y>は異なったものと見
なされます。

     (%i1) x: a/c + b/c;
                                   b   a
     (%o1)                         - + -
                                   c   c
     (%i2) y: a/c + b/c;
                                   b   a
     (%o2)                         - + -
                                   c   c
     (%i3) z: (a + b)/c;
                                   b + a
     (%o3)                         -----
                                     c
     (%i4) is (x = y);
     (%o4)                         true
     (%i5) is (y = z);
     (%o5)                         false
     (%i6) is (equal (y, z));
     (%o6)                         true
     (%i7) y - z;
                                b + a   b   a
     (%o7)                    - ----- + - + -
                                  c     c   c
     (%i8) ratsimp (%);
     (%o8)                           0
     (%i9) {x, y, z};
                               b + a  b   a
     (%o9)                    {-----, - + -}
                                 c    c   c

   リストの要素から集合を構成するには、‘setify’を使ってください。

     (%i1) setify ([b, a]);
     (%o1)                        {a, b}

   もし‘is(x = y)’が‘true’に評価されるなら、 集合の元‘x’と‘y’は等しいで
す。 従って、‘rat(x)’と‘x’は集合の元として等しいです; 結果として、

     (%i1) {x, rat(x)};
     (%o1)                          {x}

   さらに、 ‘is((x - 1)*(x + 1) = x^2 - 1)’は‘false’に評価されるので、
‘(x - 1)*(x + 1)’と‘x^2 - 1’は集合の異なる元です; 従って、

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}

   この集合を1元集合に縮小するには、 ‘rat’を集合の元それぞれに適用してく
ださい:

     (%i1) {(x - 1)*(x + 1), x^2 - 1};
                                            2
     (%o1)               {(x - 1) (x + 1), x  - 1}
     (%i2) map (rat, %);
                                   2
     (%o2)/R/                    {x  - 1}

   他の集合から冗長性を取り除くために、 他の整理関数を使う必要があるかも
しれません。 以下は、‘trigsimp’を使った例です:

     (%i1) {1, cos(x)^2 + sin(x)^2};
                                 2         2
     (%o1)                {1, sin (x) + cos (x)}
     (%i2) map (trigsimp, %);
     (%o2)                          {1}

   元が、冗長でなく、並べ換えられている時 集合は整理されてます。 集合関
数の現在のバージョンは、 集合を順に並べるためにMaxima関数‘orderlessp’を
使います; しかしながら、 集合関数の将来のバージョンは、違う並び替え関数
を使うかもしれません。

   代入のような、集合に関するいくつかの演算は、 再整理を自動的に強制しま
す; 例えば、

     (%i1) s: {a, b, c}$
     (%i2) subst (c=a, s);
     (%o2)                        {a, b}
     (%i3) subst ([a=x, b=x, c=x], s);
     (%o3)                          {x}
     (%i4) map (lambda ([x], x^2), set (-1, 0, 1));
     (%o4)                        {0, 1}

   Maximaは、リストと集合を異なるオブジェクトとして扱います; ‘union’や
‘intersection’のような関数は、 もし引数のいずれかがしゅうごうでないなら
、文句を言います。 もしリストに集合関数を適用する必要があるなら、 集合に
変換するために、 ‘setify’関数を使ってください。 例えば、

     (%i1) union ([1, 2], {a, b});
     Function union expects a set, instead found [1,2]
      -- an error.  Quitting.  To debug this try debugmode(true);
     (%i2) union (setify ([1, 2]), {a, b});
     (%o2)                     {1, 2, a, b}

   集合‘s’の集合要素のうち述語論理‘f’を満たすすべての要素を抽出するため
には、 use ‘subset(s, f)’を使ってください。 (述語論理はブーリアン値関数
です。) 例えば、 与えられた集合の中で、変数‘z’に依存しない等式を見つける
には、 以下を使ってください。

     (%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                         lambda ([e], freeof (z, e)));
     (%o1)               {- y + x + 4, y + x - 5}

   節*note Functions and Variables for Sets::は、 Maximaの集合関数の完全
なリストを持ちます。

35.1.2 Set Member Iteration
---------------------------

集合の元上を反復する２つの方法があります。 １つの方法は‘map’の使用です;
例えば:

     (%i1) map (f, {a, b, c});
     (%o1)                  {f(a), f(b), f(c)}

   他の方法は、 ‘for <x> in <s> do’を使うことです。

     (%i1) s: {a, b, c};
     (%o1)                       {a, b, c}
     (%i2) for si in s do print (concat (si, 1));
     a1
     b1
     c1
     (%o2)                         done

   Maxima関数‘first’と‘rest’は、 集合に対して正しく機能します。 集合に適
用されると、 ‘first’は、最初に表示される集合の要素を返します; それは、実
装依存かもしれません。 もし‘s’が集合なら ‘rest(s)’は、‘disjoin(first(s),
s)’と同値です。 現在、 集合に対して正しく機能する他のMaxima関数がありま
す。 集合関数の将来のバージョンでは、 ‘first’と‘rest’は、違うように機能
するかもしれませんし、そうでないかもしれません。

35.1.3 Bugs
-----------

集合関数は、 集合の元を並び換えるために、 Maxima関数‘orderlessp’を使い、
集合の元の同一性をテストするために(Lispレベルの)関数‘like’を使います。 こ
れらの関数の両方は、 もし標準有理式(CRE)形式の式を含むリストや行列が元の
集合を使おうとするなら、現れる既知のバグを持ちます。 例は以下の通りです
。

     (%i1) {[x], [rat (x)]};
     Maxima encountered a Lisp error:

       The value #:X1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   この式は、Maximaがエラーで停止する原因となります。 (エラーメッセージ
はMaximaが使うLispのバージョンに依ります。) もう１つの例は、以下の通りで
す。

     (%i1) setify ([[rat(a)], [rat(b)]]);
     Maxima encountered a Lisp error:

       The value #:A1440 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.

   これらのバグは、 ‘orderlessp’と‘like’の中にあるバグに原因します; それ
らは、集合関数の中のバグが原因ではありません。 例証するには、以下の式を
試してください。

     (%i1) orderlessp ([rat(a)], [rat(b)]);
     Maxima encountered a Lisp error:

       The value #:B1441 is not of type LIST.

     Automatically continuing.
     To reenable the Lisp debugger set *debugger-hook* to nil.
     (%i2) is ([rat(a)] = [rat(a)]);
     (%o2)                         false

   これらのバグが直されるまで、 CRE形式の式を含むリストや行を元に持つ集
合を構成しないでください; しかしながら、CRE形式の元を持つ集合は、問題な
いはずです:

     (%i1) {x, rat (x)};
     (%o1)                          {x}

   Maximaの‘orderlessp’は、 集合関数で問題の原因となる可能性がある もう
１つのバグを持ちます。 それは、すなわち、順序付け述語論理‘orderlessp’が
推移的でないことです。 これを示す最も簡単な既知の例は、以下の通りです。

     (%i1) q: x^2$
     (%i2) r: (x + 1)^2$
     (%i3) s: x*(x + 2)$
     (%i4) orderlessp (q, r);
     (%o4)                         true
     (%i5) orderlessp (r, s);
     (%o5)                         true
     (%i6) orderlessp (q, s);
     (%o6)                         false

   このバグは、一般的にMaximaの関数はもちろん、集合関数すべてにおいて、
問題の原因となる可能性があります。 確実ではありませんが、 もし集合の元す
べてがCRE形式であるか、‘ratsimp’を使って整理されていれば、 このバグはた
ぶん避けられます。

   Maximaの‘orderless’と‘ordergreat’メカニズムは、 集合関数と互換性があ
りません。 もし、‘orderless’か‘ordergreat’のいずれかを使う必要があるなら
、 いかなる集合を構成する前に、これらの関数をコールしてください。 そして
、‘unorder’をコールしないでください。

   もし集合関数のバグかもしれないと思う何かを見つけたら、 どうかMaximaの
バグデータベースに報告してください。 ‘bug_report’を参照してください。

35.1.4 Authors
--------------

マサチューセッツ州ケンブリッジ市のStavros Macrakisと、 ネブラスカ大学カ
ーニー校(UNK)のBarton Willisが、 Maximaの集合関数とそれらのドキュメンテ
ーションを書きました。


File: maxima.info,  Node: Functions and Variables for Sets,  Prev: Introduction to Sets,  Up: Sets

35.2 Functions and Variables for Sets
=====================================

 -- 関数: adjoin (<x>, <a>)

     集合<a>に要素‘{<x>}’を加えた集合を返します。

     もし<a>が集合リテラルでないなら、 ‘adjoin’は文句を言います。

     ‘adjoin(<x>, <a>)’と‘union(set(<x>), <a>)’は同値です; しかしながら
     、‘adjoin’は‘union’より幾分早いかもしれません。

     ‘disjoin’も参照してください。

     例:

          (%i1) adjoin (c, {a, b});
          (%o1)                       {a, b, c}
          (%i2) adjoin (a, {a, b});
          (%o2)                        {a, b}

 -- 関数: belln (<n>)

     n番目のベル数を返します。 ‘belln(n)’は<n>個のメンバーを持つ集合の分
     割の数です。

     非負整数<n>に対して、 ‘belln(<n>)’はn番目のベル数に整理されます。
     ‘belln’は他のいかなる引数に関して整理されません。

     ‘belln’は等式、リスト、行列、集合上に分配されます。

     例:

     非負整数に適用された‘belln’。

          (%i1) makelist (belln (i), i, 0, 6);
          (%o1)               [1, 1, 2, 5, 15, 52, 203]
          (%i2) is (cardinality (set_partitions ({})) = belln (0));
          (%o2)                         true
          (%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                                 belln (6));
          (%o3)                         true

     非負整数でない引数に適用された‘belln’。

          (%i1) [belln (x), belln (sqrt(3)), belln (-9)];
          (%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]

 -- 関数: cardinality (<a>)

     集合<a>の異なる要素の数を返します。

     整理がディセーブルされた時でも、 ‘cardinality’は冗長な要素を無視し
     ます。

     例:

          (%i1) cardinality ({});
          (%o1)                           0
          (%i2) cardinality ({a, a, b, c});
          (%o2)                           3
          (%i3) simp : false;
          (%o3)                         false
          (%i4) cardinality ({a, a, b, c});
          (%o4)                           3

 -- 関数: cartesian_product (<b_1>, ... , <b_n>)
     Returns a set of lists of the form 形式‘[<x_1>, ..., <x_n>]’のリス
     トの集合を返します。 ここで、<x_1>, ..., <x_n>はそれぞれ、 集合
     <b_1>, ...  , <b_n>の要素です。

     もし任意の引数が集合リテラルでないなら、 ‘cartesian_product’は文句
     を言います。

     例:

          (%i1) cartesian_product ({0, 1});
          (%o1)                      {[0], [1]}
          (%i2) cartesian_product ({0, 1}, {0, 1});
          (%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
          (%i3) cartesian_product ({x}, {y}, {z});
          (%o3)                      {[x, y, z]}
          (%i4) cartesian_product ({x}, {-1, 0, 1});
          (%o4)              {[x, - 1], [x, 0], [x, 1]}

 -- 関数: disjoin (<x>, <a>)
     元<x>を持たない集合<a>を返します。 もし<x>が<a>のメンバーでないなら
     、 変更なしに<a>を返します。

     もし<a>が集合リテラルでないなら、 ‘disjoin’は文句を言います。

     ‘disjoin(<x>, <a>)’, ‘delete(<x>, <a>)’, ‘setdifference(<a>,
     set(<x>))’はすべて同値です。 これらの中で、 ‘disjoin’は一般的に他よ
     り速いです。

     例:

          (%i1) disjoin (a, {a, b, c, d});
          (%o1)                       {b, c, d}
          (%i2) disjoin (a + b, {5, z, a + b, %pi});
          (%o2)                      {5, %pi, z}
          (%i3) disjoin (a - b, {5, z, a + b, %pi});
          (%o3)                  {5, %pi, b + a, z}

 -- 関数: disjointp (<a>, <b>)

     集合<a>と<b>がばらばらなら、 ‘true’を返します。

     もし<a>か<b>が集合リテラルでないなら、 ‘disjointp’は文句を言います
     。

     例:

          (%i1) disjointp ({a, b, c}, {1, 2, 3});
          (%o1)                         true
          (%i2) disjointp ({a, b, 3}, {1, 2, 3});
          (%o2)                         false

 -- 関数: divisors (<n>)

     <n>の約数の集合を表します。

     <n>がゼロでない整数の時、 ‘divisors(<n>)’は整数の集合に整理されます
     。 約数の集合は元1と<n>を含みます。 負の整数の約数は、その絶対値の
     約数です。

     ‘divisors’は、等式、リスト、行列、集合上に分配されます。

     例:

     28は完全数であることを検証できます: (自身を除いた)約数が28です。

          (%i1) s: divisors(28);
          (%o1)                 {1, 2, 4, 7, 14, 28}
          (%i2) lreduce ("+", args(s)) - 28;
          (%o2)                          28

     ‘divisors’は整理関数です。 ‘divisors(a)’の中で‘a’に8を代入すること
     は、 ‘divisors(8)’を再評価せずに約数をもたらします。

          (%i1) divisors (a);
          (%o1)                      divisors(a)
          (%i2) subst (8, a, %);
          (%o2)                     {1, 2, 4, 8}

     ‘divisors’は、等式、リスト、行列、集合上に分配されます。

          (%i1) divisors (a = b);
          (%o1)               divisors(a) = divisors(b)
          (%i2) divisors ([a, b, c]);
          (%o2)        [divisors(a), divisors(b), divisors(c)]
          (%i3) divisors (matrix ([a, b], [c, d]));
                            [ divisors(a)  divisors(b) ]
          (%o3)             [                          ]
                            [ divisors(c)  divisors(d) ]
          (%i4) divisors ({a, b, c});
          (%o4)        {divisors(a), divisors(b), divisors(c)}

 -- 関数: elementp (<x>, <a>)
     <x>が集合<a>の元の時だけ‘true’を返します。

     もし<a>が集合リテラルでないなら、 ‘elementp’は文句を言います。

     例:

          (%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
          (%o1)                         true
          (%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
          (%o2)                         false

 -- 関数: emptyp (<a>)

     <a>が空の集合か空のリストの時だけ、‘true’を返します。

     例:

          (%i1) map (emptyp, [{}, []]);
          (%o1)                     [true, true]
          (%i2) map (emptyp, [a + b, {{}}, %pi]);
          (%o2)                 [false, false, false]

 -- 関数: equiv_classes (<s>, <F>)
     集合<s>の 同値関係<F>に関する 同値クラスの集合を返します。

     <F>は<s>の<s>との直積集合上の２変数関数です。 The return value of
     <F>の戻り値は、‘true’か‘false’、もしくは、 ‘is(<expr>)’が‘true’か
     ‘false’のような 式<expr>です。

     <F>が同値関数でない時、 ‘equiv_classes’は不平なくそれを受け入れます
     が、 その場合、結果は、一般に正しくありません。

     例:

     同値関係が ‘true’か‘false’を返すラムダ式です。

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                                  lambda ([x, y], is (equal (x, y))));
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     同値関係が、‘is’が‘true’か‘false’に評価される 関係関数の名前です。

          (%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
          (%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}

     同値クラスが3の倍数だけ違う数です。

          (%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                               lambda ([x, y], remainder (x - y, 3) = 0));
          (%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}

 -- 関数: every (<f>, <s>)
 -- 関数: every (<f>, <L_1>, ..., <L_n>)

     もし述語論理<f>が与えられた引数すべてで‘true’なら、 ‘true’を返しま
     す。

     ある集合が二番目の引数として与えられたとして、 もし
     ‘is(<f>(<a_i>))’が <s>の中の<a_i>すべてに関して ‘true’を返すなら
     ‘every(<f>, <s>)’は‘true’です。 ‘every’は、 <s>の中の<a_i>すべてに
     関して<f>を評価するかもしれないししないかもしれません。 集合は順序
     付けされていないので、 ‘every’は任意の順序で‘<f>(<a_i>)’を評価しま
     す。

     非キスとして１つか複数のリストが与えられたとして、 もし
     ‘is(<f>(<x_1>, ..., <x_n>))’が <L_1>, ..., <L_n>それぞれの中の
     <x_1>, ..., <x_n>すべてに対して ‘true’を返すなら、 ‘every(<f>,
     <L_1>, ..., <L_n>)’は‘true’を返します。 ‘every’は、 <x_1>, ...,
     <x_n>のすべての組み合わせに対して<f>を評価するかもしれないししない
     かもしれません。 ‘every’はインデックスを増やす順序でリストを評価し
     ます。

     空の集合‘{}’または空のリスト‘[]’が引数として与えられたとして、
     ‘every’は‘false’を返します。

     グローバルフラグ‘maperror’が‘true’の時、 リスト<L_1>, ..., <L_n>す
     べては等しい長さを持たなければいけません。 ‘maperror’が‘false’の時
     、 リスト引数は、最短のリストの長さに効果的に切り詰められます。

     (‘is’を介して) ‘true’か‘false’以外の何かに評価される述語論理<f>の戻
     り値は、 ‘prederror’によって決定されます。 ‘prederror’が‘true’の時
     、 そんな値は‘false’として扱われ、 ‘every’の戻り値は‘false’です。
     ‘prederror’が‘false’の時、 そんな値は‘unknown’として扱われ、
     ‘every’の戻り値は‘unknown’です。

     例:

     １つの集合に適用された‘every’。 述語論理は１引数関数です。

          (%i1) every (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         false

     ２つのリストに適用された‘every’。 述語論理は２引数関数です。

          (%i1) every ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) every ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     ‘true’か‘false’以外の何かに評価される 述語論理<f>の戻り値は、 グロ
     ーバルフラグ‘prederror’によって決定されます。

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                             [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) prederror : true;
          (%o4)                         true
          (%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o5)                         false

 -- 関数: extremal_subset (<s>, <f>, max)
 -- 関数: extremal_subset (<s>, <f>, min)

     関数<f>が最大または最小値を取る、 <s>の部分集合を返します。

     ‘extremal_subset(<s>, <f>, max)’は、 実数値関数<f>が最大値を取る、
     集合またはリスト<s>の部分集合を返します。

     ‘extremal_subset(<s>, <f>, min)’は、 実数値関数<f>が最小値を取る、
     集合またはリスト<s>の部分集合を返します。

     例:

          (%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
          (%o1)                       {- 2, 2}
          (%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
          (%o2)                       {sqrt(2)}

 -- 関数: flatten (<expr>)

     <expr>と同じ演算子を持つ部分式の引数を集め、 これらの集めた引数から
     式を構成します。

     ‘expr’の主演算子と違った演算子の部分式は、 たとえそれらが、逆に
     ‘expr’に関するものと同じ演算子の部分式を含んだとしても、 変更なしに
     コピーされます。

     引数の数が演算子に関して宣言された引数と違う 式を‘flatten’が構成す
     る可能性があるかもしれません; これは、整理器や評価器からのエラーメ
     ッセージを起こさせるかもしれません。 ‘flatten’はそんな状況を検出し
     ようとしません。

     特別な表現の式、例えば、標準有理式(CRE)、はflattenできません; そん
     な場合、‘flatten’は引数を変更なしに返します。

     例:

     リストに適用すると、‘flatten’はリストの要素すべてを集めます。

          (%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
          (%o1)            [a, b, c, d, e, f, g, h, i, j]

     集合に適用すると、‘flatten’は集合の元すべてを集めます。

          (%i1) flatten ({a, {b}, {{c}}});
          (%o1)                       {a, b, c}
          (%i2) flatten ({a, {[a], {a}}});
          (%o2)                       {a, [a]}

     ‘flatten’は、主演算子をn項に宣言する効果に似ています。 しかしながら
     、‘flatten’は、 主演算子と違う演算子を持つ部分式上に影響を持ちませ
     ん。 一方、n項宣言はそれらに影響します。

          (%i1) expr: flatten (f (g (f (f (x)))));
          (%o1)                     f(g(f(f(x))))
          (%i2) declare (f, nary);
          (%o2)                         done
          (%i3) ev (expr);
          (%o3)                      f(g(f(x)))

     ‘flatten’は、他の任意の演算子と同じように添字付き関数を扱います。

          (%i1) flatten (f[5] (f[5] (x, y), z));
          (%o1)                      f (x, y, z)
                                      5

     引数の数が演算子に関して宣言された引数と違う 式を‘flatten’が構成す
     る可能性があるかもしれません;

          (%i1) 'mod (5, 'mod (7, 4));
          (%o1)                   mod(5, mod(7, 4))
          (%i2) flatten (%);
          (%o2)                     mod(5, 7, 4)
          (%i3) ''%, nouns;
          Wrong number of arguments to mod
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- 関数: full_listify (<a>)
     <a>の中のすべての集合演算子をリスト演算子で置き換え、 結果を返しま
     す。 ‘full_listify’は、 たとえ主演算子が‘set’でなくても 入れ子の部
     分式の中の集合演算子を置き換えます。

     ‘listify’は主演算子だけを置き換えます。

     例:

          (%i1) full_listify ({a, b, {c, {d, e, f}, g}});
          (%o1)               [a, b, [c, [d, e, f], g]]
          (%i2) full_listify (F (G ({a, b, H({c, d, e})})));
          (%o2)              F(G([a, b, H([c, d, e])]))

 -- 関数: fullsetify (<a>)
     <a>がリストの時、 リスト演算子を集合演算子で置き換え、
     ‘fullsetify’を集合であるメンバーそれぞれに適用します。 <a>がリスト
     でない時、変更なしで返します。

     ‘setify’は主演算子だけを置き換えます。

     例:

     ‘f([b])’の主演算子はリストでないので、 行‘(%o2)’で、 ‘f’の引数は集
     合に変換されません。

          (%i1) fullsetify ([a, [a]]);
          (%o1)                       {a, {a}}
          (%i2) fullsetify ([a, f([b])]);
          (%o2)                      {a, f([b])}

 -- 関数: identity (<x>)

     任意の引数<x>に対して<x>を返します。

     例:

     ‘identity’は、 引数が既にブーリアン値の時、 述語論理として使うこと
     ができます。

          (%i1) every (identity, [true, true]);
          (%o1)                         true

 -- 関数: integer_partitions (<n>)
 -- 関数: integer_partitions (<n>, <len>)

     <n>の整数分割を返します。 すなわち、和が<n>になる整数のリストです。

     ‘integer_partitions(<n>)’は、 整数<n>の分割すべての集合を返します。
     分割それぞれは、大きい順に並べられたリストです。

     ‘integer_partitions(<n>, <len>)’は、 長さ<len>以下の分割すべてを返
     します; この場合、 <len>より少ない項を持つ分割それぞれには、 厳密に
     <len>項持つ分割にするように、ゼロが足されます。 分割それぞれは、大
     きい順に並べられたリストです。

     リスト[a_1, ..., a_m]は、 (1) a_iそれぞれが非ゼロ整数、かつ、 (2)
     a_1 + ... + a_m = n. の時、非負整数nの分割です。 従って0は分割を持
     ちません。

     例:

          (%i1) integer_partitions (3);
          (%o1)               {[1, 1, 1], [2, 1], [3]}
          (%i2) s: integer_partitions (25)$
          (%i3) cardinality (s);
          (%o3)                         1958
          (%i4) map (lambda ([x], apply ("+", x)), s);
          (%o4)                         {25}
          (%i5) integer_partitions (5, 3);
          (%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
          (%i6) integer_partitions (5, 2);
          (%o6)               {[3, 2], [4, 1], [5, 0]}

     条件を満たす分割すべてを見つけるには、 関数‘subset’を使ってください
     ; 以下は素数から成る10の分割すべてを見つける例です。

          (%i1) s: integer_partitions (10)$
          (%i2) cardinality (s);
          (%o2)                          42
          (%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
          (%i4) subset (s, lambda ([x], every (xprimep, x)));
          (%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}

 -- 関数: intersect (<a_1>, ..., <a_n>)

     ‘intersect’は、以下に見る‘intersection’と同じです。

 -- 関数: intersection (<a_1>, ..., <a_n>)
     集合<a_1>から<a_n>までに共通な 要素を含む 集合を返します。

     もし引数のいずれかが集合リテラルでないなら、 ‘intersection’は文句を
     言います。

     例:

          (%i1) S_1 : {a, b, c, d};
          (%o1)                     {a, b, c, d}
          (%i2) S_2 : {d, e, f, g};
          (%o2)                     {d, e, f, g}
          (%i3) S_3 : {c, d, e, f};
          (%o3)                     {c, d, e, f}
          (%i4) S_4 : {u, v, w};
          (%o4)                       {u, v, w}
          (%i5) intersection (S_1, S_2);
          (%o5)                          {d}
          (%i6) intersection (S_2, S_3);
          (%o6)                       {d, e, f}
          (%i7) intersection (S_1, S_2, S_3);
          (%o7)                          {d}
          (%i8) intersection (S_1, S_2, S_3, S_4);
          (%o8)                          {}

 -- 関数: kron_delta (<x>, <y>, …, <xp>)

     クロネッカーのデルタ関数を表します。

     ‘kron_delta’は、 <xi>と<yj>が引数のすべての対で等しい時 1に整理され
     、 <xi>と<yj>が引数のある対で等しくない時 0に整理されます。 等号は
     ‘is(equal(xi,j))’を使って決定され、 不等号は‘is(notsqual(xi,xj))’を
     使って決定されます。 厳密に1つの引数に対して、‘kron_delta’はエラー
     をシグナルします。

     例:

          (%i1) kron_delta(a,a);
          (%o1)                                  1
          (%i2) kron_delta(a,b,a,b);
          (%o2)                          kron_delta(a, b)
          (%i3) kron_delta(a,a,b,a+1);
          (%o3)                                  0
          (%i4) assume(equal(x,y));
          (%o4)                            [equal(x, y)]
          (%i5) kron_delta(x,y);
          (%o5)                                  1

 -- 関数: listify (<a>)

     <a>が集合の時、 <a>の元を含む リストを返します。 そうでなければ、
     ‘listify’は<a>を返します。

     ‘full_listify’は <a>の中の集合演算子をリスト演算子に置き換えます。

     例:

          (%i1) listify ({a, b, c, d});
          (%o1)                     [a, b, c, d]
          (%i2) listify (F ({a, b, c, d}));
          (%o2)                    F({a, b, c, d})

 -- 関数: lreduce (<F>, <s>)
 -- 関数: lreduce (<F>, <s>, <s_0>)

     二項関数<F>を合成によってn項関数に拡張します。 ここで<s>はリストで
     す。

     ‘lreduce(<F>, <s>)’は‘F(... F(F(s_1, s_2), s_3), ... s_n)’を返しま
     す。

     オプション引数<s_0>が存在する時、 結果は‘lreduce(<F>, cons(<s_0>,
     <s>))’と同値です。

     関数<F>は、最初のleftmostの元に適用されます。 だから、"lreduce"と名
     付けられています。

     ‘rreduce’, ‘xreduce’, ‘tree_reduce’も参照してください。

     例:

     オプション引数なしの‘lreduce’。

          (%i1) lreduce (f, [1, 2, 3]);
          (%o1)                     f(f(1, 2), 3)
          (%i2) lreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(f(f(1, 2), 3), 4)

     オプション引数ありの‘lreduce’。

          (%i1) lreduce (f, [1, 2, 3], 4);
          (%o1)                  f(f(f(4, 1), 2), 3)

     組み込み二項演算子に適用された‘lreduce’。 ‘/’は割り算演算子。

          (%i1) lreduce ("^", args ({a, b, c, d}));
                                         b c d
          (%o1)                       ((a ) )
          (%i2) lreduce ("/", args ({a, b, c, d}));
                                          a
          (%o2)                         -----
                                        b c d

 -- 関数: makeset (<expr>, <x>, <s>)

     式<expr>から生成された元を持つ集合を返します。 ここで、<x>は
     <expr>の中の変数のリストであり、 <s>はリストの集合かリストです。 集
     合の元それぞれを生成するために、 <expr>は、 <s>の元に並列にバインド
     された変数<x>で評価されます。

     <s>の元それぞれは <x>と同じ長さを持たなければいけません。 変数<x>の
     リストは、添字の付かないシンボルのリストでなければいけません。 たと
     えシンボルが１つしかない場合でも、<x>は１要素のリストでなければいけ
     なく、 <s>の元それぞれは１要素のリストでなければいけません。

     ‘makelist’も参照してください。

     例:

          (%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                                     1  2  3  4
          (%o1)                     {-, -, -, -}
                                     a  b  c  d
          (%i2) S : {x, y, z}$
          (%i3) S3 : cartesian_product (S, S, S);
          (%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
          [x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
          [y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
          [y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
          [z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
          [z, z, y], [z, z, z]}
          (%i4) makeset (i + j + k, [i, j, k], S3);
          (%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                                 z + 2 y, 2 z + x, 2 z + y}
          (%i5) makeset (sin(x), [x], {[1], [2], [3]});
          (%o5)               {sin(1), sin(2), sin(3)}

 -- 関数: moebius (<n>)

     メビウス関数を表します。

     <n>がk個の異なる素数の積の時、 ‘moebius(<n>)’は(-1)^kに整理されます
     ; <n> = 1の時、1に整理されます; 他の正の数すべてに対して、0に整理さ
     れます。

     ‘moebius’は等式、リスト、行列、集合上に分配されます。

     例:

          (%i1) moebius (1);
          (%o1)                           1
          (%i2) moebius (2 * 3 * 5);
          (%o2)                          - 1
          (%i3) moebius (11 * 17 * 29 * 31);
          (%o3)                           1
          (%i4) moebius (2^32);
          (%o4)                           0
          (%i5) moebius (n);
          (%o5)                      moebius(n)
          (%i6) moebius (n = 12);
          (%o6)                    moebius(n) = 0
          (%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
          (%o7)                      [- 1, 1, 1]
          (%i8) moebius (matrix ([11, 12], [13, 14]));
                                     [ - 1  0 ]
          (%o8)                      [        ]
                                     [ - 1  1 ]
          (%i9) moebius ({21, 22, 23, 24});
          (%o9)                      {- 1, 0, 1}

 -- 関数: multinomial_coeff (<a_1>, ..., <a_n>)
 -- 関数: multinomial_coeff ()

     多項係数を返します。

     <a_k>それぞれが非負の整数の時、 多項係数は、 ‘<a_1> + ... + <a_n>’個
     の別々のオブジェクトを k番目の枠の中に<a_k>の要素を持つn個の枠に置
     く方法の数を与えます。

     一般に、‘multinomial_coeff (<a_1>, ..., <a_n>)’は ‘(<a_1> + ... +
     <a_n>)!/(<a_1>! ... <a_n>!)’と同値です。

     ‘multinomial_coeff()’ (引数なし)は1に評価されます。

     ‘minfactorial’は‘multinomial_coeff’が返す値を整理することができます
     。

     例:

          (%i1) multinomial_coeff (1, 2, x);
                                      (x + 3)!
          (%o1)                       --------
                                        2 x!
          (%i2) minfactorial (%);
                               (x + 1) (x + 2) (x + 3)
          (%o2)                -----------------------
                                          2
          (%i3) multinomial_coeff (-6, 2);
                                       (- 4)!
          (%o3)                       --------
                                      2 (- 6)!
          (%i4) minfactorial (%);
          (%o4)                          10

 -- 関数: num_distinct_partitions (<n>)
 -- 関数: num_distinct_partitions (<n>, list)

     <n>が非負の整数の時、 <n>の異なる整数分割の数を返します。 そうでな
     ければ、‘num_distinct_partitions’は名詞形を返します。

     ‘num_distinct_partitions(<n>, list)’は、 1, 2, 3, ..., <n>の異なる
     分割の数のリストを返します。

     <n>の異なる分割は、 <n> = k_1 + ... + k_mとなるような 異なる正の整
     数k_1, ..., k_mのリストです。

     例:

          (%i1) num_distinct_partitions (12);
          (%o1)                          15
          (%i2) num_distinct_partitions (12, list);
          (%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
          (%i3) num_distinct_partitions (n);
          (%o3)              num_distinct_partitions(n)

 -- 関数: num_partitions (<n>)
 -- 関数: num_partitions (<n>, list)

     <n>が非負の整数の時、 <n>の整数分割の数を返します。 そうでなければ
     、‘num_partitions’は名詞式を返します。

     ‘num_partitions(<n>, list)’は、 1, 2, 3, ..., <n>の整数分割の数のリ
     ストを返します。

     非負の整数<n>に対して、 ‘num_partitions(<n>)’は
     ‘cardinality(integer_partitions(<n>))’と等しいです; しかしながら、
     ‘num_partitions’は、 分割の集合を実際には構成しないので、はるかに速
     いです。

     例:

          (%i1) num_partitions (5) = cardinality (integer_partitions (5));
          (%o1)                         7 = 7
          (%i2) num_partitions (8, list);
          (%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
          (%i3) num_partitions (n);
          (%o3)                   num_partitions(n)

 -- 関数: partition_set (<a>, <f>)

     集合<a>を述語論理<f>に従って分割します。

     ‘partition_set’は２つの集合のリストを返します。 最初の集合は <f>が
     ‘false’に評価される <a>の要素から成り、 二番目は<a>の他の要素すべて
     から成ります。 ‘partition_set’は ‘is’を<f>の戻り値に適用しません。

     もし<a>が集合リテラルなら ‘partition_set’は文句を言います。

     ‘subset’も参照してください。

     例:

          (%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
          (%o1)                   [{1, 7}, {2, 8}]
          (%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                               lambda ([x], ratp(x)));
          (%o2)/R/              [{1, x}, {y, y + z}]

 -- 関数: permutations (<a>)

     リストまたは集合<a>の元の異なる順列すべての集合を返します。 順列そ
     れぞれは、集合でなくリストです。

     <a>がリストの時、 <a>の重複した元が順列の中に含まれます。

     もし<a>がリストリテラルや集合リテラルでないなら、 ‘permutations’は
     文句を言います。

     ‘random_permutation’も参照してください。

     例:

          (%i1) permutations ([a, a]);
          (%o1)                       {[a, a]}
          (%i2) permutations ([a, a, b]);
          (%o2)           {[a, a, b], [a, b, a], [b, a, a]}

 -- 関数: powerset (<a>)
 -- 関数: powerset (<a>, <n>)

     <a>の部分集合すべての集合、または、その集合の部分集合を返します。

     ‘powerset(<a>)’は 集合<a>の部分集合すべての集合を返します。
     ‘powerset(<a>)’は‘2^cardinality(<a>)’個の元を持ちます。

     ‘powerset(<a>, <n>)’は、 濃度<n>を持つ<a>の部分集合すべての集合を返
     します。

     もし<a>が集合リテラルでないか、 <n>が非負の整数でないなら、
     ‘powerset’は文句を言います。

     例:

          (%i1) powerset ({a, b, c});
          (%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
          (%i2) powerset ({w, x, y, z}, 4);
          (%o2)                    {{w, x, y, z}}
          (%i3) powerset ({w, x, y, z}, 3);
          (%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
          (%i4) powerset ({w, x, y, z}, 2);
          (%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
          (%i5) powerset ({w, x, y, z}, 1);
          (%o5)                 {{w}, {x}, {y}, {z}}
          (%i6) powerset ({w, x, y, z}, 0);
          (%o6)                         {{}}

 -- 関数: random_permutation (<a>)

     クヌースのシャッフルアルゴリズムで構成されるような、 集合またはリス
     ト<a>のランダムな順列を返します。

     戻り値は、たとえ要素すべてが偶然同じでも 引数とは別の新しいリストで
     す。 しかしながら、引数の要素はコピーされません。

     例:

          (%i1) random_permutation ([a, b, c, 1, 2, 3]);
          (%o1)                  [c, 1, 2, 3, a, b]
          (%i2) random_permutation ([a, b, c, 1, 2, 3]);
          (%o2)                  [b, 3, 1, c, a, 2]
          (%i3) random_permutation ({x + 1, y + 2, z + 3});
          (%o3)                 [y + 2, z + 3, x + 1]
          (%i4) random_permutation ({x + 1, y + 2, z + 3});
          (%o4)                 [x + 1, y + 2, z + 3]

 -- 関数: rreduce (<F>, <s>)
 -- 関数: rreduce (<F>, <s>, <s_{n + 1}>)

     合成によって二項関数<F>をn項関数に拡張します。 ここで、<s>はリスト
     です。

     ‘rreduce(<F>, <s>)’は ‘F(s_1, ... F(s_{n - 2}, F(s_{n - 1},
     s_n)))’を返します。 オプション引数<s_{n + 1}>が存在する時、 結果は
     、‘rreduce(<F>, endcons(<s_{n + 1}>, <s>))’ と同値です。

     関数<F>は、最初rightmostのリスト要素に適用されます。 だから名前が
     "rreduce"です。

     ‘lreduce’, ‘tree_reduce’, ‘xreduce’も参照してください。

     例:

     オプション引数なしの‘rreduce’。

          (%i1) rreduce (f, [1, 2, 3]);
          (%o1)                     f(1, f(2, 3))
          (%i2) rreduce (f, [1, 2, 3, 4]);
          (%o2)                  f(1, f(2, f(3, 4)))

     オプション引数ありの‘rreduce’。

          (%i1) rreduce (f, [1, 2, 3], 4);
          (%o1)                  f(1, f(2, f(3, 4)))

     組み込み二項演算子に適用された‘rreduce’。 ‘/’は割り算演算子。

          (%i1) rreduce ("^", args ({a, b, c, d}));
                                           d
                                          c
                                         b
          (%o1)                         a
          (%i2) rreduce ("/", args ({a, b, c, d}));
                                         a c
          (%o2)                          ---
                                         b d

 -- 関数: setdifference (<a>, <b>)

     集合<a>の中の、集合<b>にない要素を含む集合を返します。

     もし<a>か<b>が集合リテラルでないなら、 ‘setdifference’は文句を言い
     ます。

     例:

          (%i1) S_1 : {a, b, c, x, y, z};
          (%o1)                  {a, b, c, x, y, z}
          (%i2) S_2 : {aa, bb, c, x, y, zz};
          (%o2)                 {aa, bb, c, x, y, zz}
          (%i3) setdifference (S_1, S_2);
          (%o3)                       {a, b, z}
          (%i4) setdifference (S_2, S_1);
          (%o4)                     {aa, bb, zz}
          (%i5) setdifference (S_1, S_1);
          (%o5)                          {}
          (%i6) setdifference (S_1, {});
          (%o6)                  {a, b, c, x, y, z}
          (%i7) setdifference ({}, S_1);
          (%o7)                          {}

 -- 関数: setequalp (<a>, <b>)

     集合<a>と<b>が同じ要素数を持ち、 ‘listify’が決定した順序で考えて
     <a>の要素の中の‘x’と <b>の要素の中の‘y’に対して ‘is(<x> = <y>)’が
     ‘true’なら、 ‘true’を返します。 そうでなければ、‘setequalp’は
     ‘false’を返します。

     例:

          (%i1) setequalp ({1, 2, 3}, {1, 2, 3});
          (%o1)                         true
          (%i2) setequalp ({a, b, c}, {1, 2, 3});
          (%o2)                         false
          (%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
          (%o3)                         false

 -- 関数: setify (<a>)

     リスト<a>の要素から集合を構成します。 リスト<a>の重複した要素は削除
     され、 要素は、述語論理‘orderlessp’に従って並び替えられます。

     もし<a>が集合リテラルでないなら、 ‘setify’は文句を言います。

     例:

          (%i1) setify ([1, 2, 3, a, b, c]);
          (%o1)                  {1, 2, 3, a, b, c}
          (%i2) setify ([a, b, c, a, b, c]);
          (%o2)                       {a, b, c}
          (%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
          (%o3)                {1, 3, 5, 7, 9, 11, 13}

 -- 関数: setp (<a>)

     <a>がMaximaの集合の時だけ、‘true’を返します。

     ‘setp’は、 整理された集合はもちろん、未整理の集合(すなわち、冗長な
     元を持つ集合)に対して、 ‘true’を返します。

     ‘setp’はMaxima関数 ‘setp(a) := not atom(a) and op(a) = 'set’ と同値
     です。

     例:

          (%i1) simp : false;
          (%o1)                         false
          (%i2) {a, a, a};
          (%o2)                       {a, a, a}
          (%i3) setp (%);
          (%o3)                         true

 -- 関数: set_partitions (<a>)
 -- 関数: set_partitions (<a>, <n>)

     <a>の分割すべての集合、または、その集合の部分集合を返します。

     ‘set_partitions(<a>, <n>)’は <n>個の空でないばらばらの部分集合への
     <a>の分解すべての集合を返します。

     ‘set_partitions(<a>)’は分割すべての集合を返します。

     ‘stirling2’は集合の分割の集合の濃度を返します。

     集合の集合Pは

       1. Pの元それぞれが空でない集合
       2. Pの別の元はばらばらである。
       3. Pの元の和集合がSに等しい
     時、 集合Sの分割です。

     例:

     条件1と2が空ゆえに真なので、空集合はそれ自身の分割です。

          (%i1) set_partitions ({});
          (%o1)                         {{}}

     集合の分割の集合の濃度は、 ‘stirling2’を使って見つけられます。

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) cardinality(p) = stirling2 (6, 3);
          (%o3)                        90 = 90

     ‘p’の元それぞれは <n> = 3個の元を持たなければいけません; チェックし
     ましょう。

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (cardinality, p);
          (%o3)                          {3}

     最後に、 ‘p’の元それぞれに対して、 元の和集合は‘s’に等しくなければ
     いけません; チェックしましょう。

          (%i1) s: {0, 1, 2, 3, 4, 5}$
          (%i2) p: set_partitions (s, 3)$
          (%i3) map (lambda ([x], apply (union, listify (x))), p);
          (%o3)                 {{0, 1, 2, 3, 4, 5}}

 -- 関数: some (<f>, <a>)
 -- 関数: some (<f>, <L_1>, ..., <L_n>)

     もし与えられた引数のうち１つ以上で述語論理<f>が‘true’なら ‘true’を
     返します。

     二番目の引数として集合１つが与えられたとして、 もし <s>の中の１つ以
     上の<a_i>に対して ‘is(<f>(<a_i>))’が‘true’を返すなら、 ‘some(<f>,
     <s>)’は‘true’を返します。 ‘some’は <s>の中の<a_i>すべてに対して
     <f>を評価するかどうかわかりません。 集合は順序がないので、 ‘some’は
     任意の順序で‘<f>(<a_i>)’評価するかもしれません。

     引数として２つ以上のリストが与えられたとして、 ‘some(<f>, <L_1>,
     ..., <L_n>)’は‘true’を返します。 もし <L_1>, ..., <L_n>それぞれの中
     の１つ以上の<x_1>, ..., <x_n>で ‘is(<f>(<x_1>, ..., <x_n>))’が
     ‘true’を返すなら、 ‘some’は いくつかの組み合わせ<x_1>, ..., <x_n>に
     対して <f>を評価するかどうかわかりません。 ‘some’はインデックスを増
     加する順序でリストを評価します。

     引数として空集合‘{}’または空のリスト‘[]’が与えられたとして、
     ‘some’は‘false’を返します。

     グローバルフラグ‘maperror’が‘true’の時、 すべてのリスト<L_1>, ...,
     <L_n>は同じ長さを持たなければいけません。 ‘maperror’が‘false’の時、
     リスト引数は、最短のリストの長さに効果的に切り詰められます。

     (‘is’を介して)‘true’か‘false’以外の何かに評価される 述語論理<f>の戻
     り値は、 グローバルフラグ‘prederror’によって決定されます。
     ‘prederror’が‘true’の時、 そんな値は‘false’として扱われます。
     ‘prederror’が‘false’の時、 そんな値は‘unknown’として扱われます。

     例:

     集合１つに適用された‘some’。 述語論理は引数１つの関数です。

          (%i1) some (integerp, {1, 2, 3, 4, 5, 6});
          (%o1)                         true
          (%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
          (%o2)                         true

     ２つのリストに適用された‘some’。 述語論理は引数２つの関数です。

          (%i1) some ("=", [a, b, c], [a, b, c]);
          (%o1)                         true
          (%i2) some ("#", [a, b, c], [a, b, c]);
          (%o2)                         false

     ‘true’か‘false’以外の何かに評価される述語論理<f>の戻り値は、 グロー
     バルフラグ‘prederror’によって決定されます。

          (%i1) prederror : false;
          (%o1)                         false
          (%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
          (%o2)              [unknown, unknown, unknown]
          (%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o3)                        unknown
          (%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o4)                         true
          (%i5) prederror : true;
          (%o5)                         true
          (%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
          (%o6)                         false
          (%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
          (%o7)                         true

 -- 関数: stirling1 (<n>, <m>)

     第一種のスターリング数を表します。

     <n>と<m>が非負の整数の時、 ‘stirling1 (<n>, <m>)’の大きさは <m>個の
     巡回置換を持つ<n>個の元を持つ集合の順列の数です。 詳細はGraham,
     Knuth and Patashnik Concrete Mathematicsを参照してください。
     Maximaは、 0より小さい<m>に対して ‘stirling1 (<n>, <m>)’を定義する
     ために 再帰関係を使います; 0より小さい<n>と非整数引数に対して未定義
     です。

     ‘stirling1’は整理関数です。 Maximaは以下の恒等式を知っています。

       1. stirling1(0, n) = kron_delta(0, n) (Ref.  [1])
       2. stirling1(n, n) = 1 (Ref.  [1])
       3. stirling1(n, n - 1) = binomial(n, 2) (Ref.  [1])
       4. stirling1(n + 1, 0) = 0 (Ref.  [1])
       5. stirling1(n + 1, 1) = n! (Ref.  [1])
       6. stirling1(n + 1, 2) = 2^n - 1 (Ref.  [1])

     これらの恒等式は 引数が、整数リテラルまたは整数と宣言されたシンボル
     で、かつ、 最初の引数が非負の時、 適用されます。 ‘stirling1’は、非
     整数引数に対して整理しません。

     参考文献:

     [1] Donald Knuth, The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     例:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n, n);
          (%o3)                           1

     ‘stirling1’は非整数引数に対して整理しません。

          (%i1) stirling1 (sqrt(2), sqrt(2));
          (%o1)              stirling1(sqrt(2), sqrt(2))

     Maximaは ‘stirling1’に恒等式を適用します。

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling1 (n + 1, n);
                                      n (n + 1)
          (%o3)                       ---------
                                          2
          (%i4) stirling1 (n + 1, 1);
          (%o4)                          n!

 -- 関数: stirling2 (<n>, <m>)

     第二種スターリング数を表します。

     <n>と<m>が非負の整数の時、 ‘stirling2 (<n>, <m>)’は、 濃度<n>の集合
     が<m>個のばらばらの部分集合に分割できる方法の数です。 Maximaは、 0よ
     り小さい<m>に対して ‘stirling2 (<n>, <m>)’を定義するために 再帰関係
     を使います; 0より小さい<n>と非整数の引数に対して未定義です。

     ‘stirling2’は整理関数です。 Maximaは以下の恒等式を知っています。

       1. stirling2(0, n) = kron_delta(0, n) (Ref.  [1])
       2. stirling2(n, n) = 1 (Ref.  [1])
       3. stirling2(n, n - 1) = binomial(n, 2) (Ref.  [1])
       4. stirling2(n + 1, 1) = 1 (Ref.  [1])
       5. stirling2(n + 1, 2) = 2^n - 1 (Ref.  [1])
       6. stirling2(n, 0) = kron_delta(n, 0) (Ref.  [2])
       7. stirling2(n, m) = 0 when m > n (Ref.  [2])
       8. stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) /
          m! when m and n are integers, and n is nonnegative.  (Ref.
          [3])

     引数が整数リテラルまたは整数と宣言されたシンボルで、かつ、最初の引
     数が非負の時、 これらの恒等式が適用されます。 ‘stirling2’は非整数引
     数に対して整理されません。

     参考文献:

     [1] Donald Knuth.  The Art of Computer Programming, third edition,
     Volume 1, Section 1.2.6, Equations 48, 49, and 50.

     [2] Graham, Knuth, and Patashnik.  Concrete Mathematics, Table 264.

     [3] Abramowitz and Stegun.  Handbook of Mathematical Functions,
     Section 24.1.4.

     例:

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n, n);
          (%o3)                           1

     ‘stirling2’は非整数引数に対して整理されません。

          (%i1) stirling2 (%pi, %pi);
          (%o1)                  stirling2(%pi, %pi)

     Maximaは ‘stirling2’に恒等式を適用します。

          (%i1) declare (n, integer)$
          (%i2) assume (n >= 0)$
          (%i3) stirling2 (n + 9, n + 8);
                                   (n + 8) (n + 9)
          (%o3)                    ---------------
                                          2
          (%i4) stirling2 (n + 1, 2);
                                        n
          (%o4)                        2  - 1

 -- 関数: subset (<a>, <f>)

     述語論理<f>を満たす 集合<a>の部分集合を返します。

     ‘subset’は、 <f>が‘false’以外の何かを返す、<a>の要素から成る集合を
     返します。 ‘subset’は ‘is’を<f>の戻り値に適用しません。

     もし<a>が集合リテラルでないなら ‘subset’は文句を言います。

     ‘partition_set’も参照してください。

     例:

          (%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
          (%o1)                     {1, 2, x, z}
          (%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
          (%o2)                      {2, 8, 14}

 -- 関数: subsetp (<a>, <b>)

     集合<a>が<b>の部分集合の時だけ、 ‘true’を返します。

     もし<a>か<b>のいずれかが集合リテラルでないなら、 ‘subsetp’は文句を
     言います。

     例:

          (%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
          (%o1)                         true
          (%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
          (%o2)                         false

 -- 関数: symmdifference (<a_1>, …, <a_n>)

     集合<a_1>, …, <a_n>の対称差を返します。

     ２つの引数が与えられたとして、 ‘symmdifference ( <a>, <b>)’は
     ‘union (setdifference ( <a>, <b>), setdifference (<b>, <a>))’と同じ
     です。

     もし引数が集合リテラルでないなら、 ‘symmdifference’は文句を言います
     。

     例:

          (%i1) S_1 : {a, b, c};
          (%o1)                       {a, b, c}
          (%i2) S_2 : {1, b, c};
          (%o2)                       {1, b, c}
          (%i3) S_3 : {a, b, z};
          (%o3)                       {a, b, z}
          (%i4) symmdifference ();
          (%o4)                          {}
          (%i5) symmdifference (S_1);
          (%o5)                       {a, b, c}
          (%i6) symmdifference (S_1, S_2);
          (%o6)                        {1, a}
          (%i7) symmdifference (S_1, S_2, S_3);
          (%o7)                        {1, b, z}
          (%i8) symmdifference ({}, S_1, S_2, S_3);
          (%o8)                        {1,b, z}

 -- 関数: tree_reduce (<F>, <s>)
 -- 関数: tree_reduce (<F>, <s>, <s_0>)

     合成によって二項関数<F>をn項関数に拡張します。 ここで<s>は集合かリ
     ストです。

     ‘tree_reduce’は以下と同値です: 新しいリスト‘[<F>(<s_1>, <s_2>),
     <F>(<s_3>, <s_4>), ...]’を形成するために <F>を要素の連続する対に適
     用します。 もし奇数個の要素があるなら、 最後の要素は変化なしに通過
     させます。 そして、リストが１つの要素になるまで繰り返します。１つの
     要素になった時、それが戻り値です。

     オプションの引数<s_0>がある時， 結果は ‘tree_reduce(<F>,
     cons(<s_0>, <s>)’と同値です。

     浮動小数点数の足し算に関して、 ‘tree_reduce’は、 ‘rreduce’や
     ‘lreduce’よりも小さな丸め誤差を持つ和を返します。

     <s>の要素と部分的な結果は 最小深度の二項木の中に配列されます。 だか
     ら名前が"tree_reduce"です。

     例:

     偶数個の要素を持つリストに適用された‘tree_reduce’。

          (%i1) tree_reduce (f, [a, b, c, d]);
          (%o1)                  f(f(a, b), f(c, d))

     奇数個の要素を持つリストに適用された‘tree_reduce’。

          (%i1) tree_reduce (f, [a, b, c, d, e]);
          (%o1)               f(f(f(a, b), f(c, d)), e)

 -- 関数: union (<a_1>, ..., <a_n>)
     集合<a_1>から<a_n>の和集合を返します。

     ‘union()’ (引数なし)は空集合を返します。

     もし引数が集合リテラルでないなら、 ‘union’は文句を言います。

     例:

          (%i1) S_1 : {a, b, c + d, %e};
          (%o1)                   {%e, a, b, d + c}
          (%i2) S_2 : {%pi, %i, %e, c + d};
          (%o2)                 {%e, %i, %pi, d + c}
          (%i3) S_3 : {17, 29, 1729, %pi, %i};
          (%o3)                {17, 29, 1729, %i, %pi}
          (%i4) union ();
          (%o4)                          {}
          (%i5) union (S_1);
          (%o5)                   {%e, a, b, d + c}
          (%i6) union (S_1, S_2);
          (%o6)              {%e, %i, %pi, a, b, d + c}
          (%i7) union (S_1, S_2, S_3);
          (%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
          (%i8) union ({}, S_1, S_2, S_3);
          (%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}

 -- 関数: xreduce (<F>, <s>)
 -- 関数: xreduce (<F>, <s>, <s_0>)

     合成によって関数<F>をn項関数に拡張します。 または、もし<F>が既にn項
     関数なら<F>を<s>に適用します。 <F>がn項関数でない時、 ‘xreduce’は
     ‘lreduce’と同じです。 引数<s>はリストです。

     n項関数として知られている関数は、 足し算‘+’, 掛け算‘*’, ‘and’,
     ‘or’, ‘max’, ‘min’, ‘append’を含みます。 関数は、 ‘declare(<F>,
     nary)’によってもn項と宣言されるかもしれません。 これらの関数に対し
     て、 ‘xreduce’は ‘rreduce’や‘lreduce’よりも速いことが期待されます。

     オプション引数<s_0>がある時、 結果は、‘xreduce(<s>, cons(<s_0>,
     <s>))’と同値です。

     浮動小数点の足し算は、厳密には結合的ではありません; そうはそうかも
     しれませんが、 <s>が浮動小数点を含む時、 ‘xreduce’はMaximaのn項足し
     算を適用します。

     例:

     n項と知られている関数に適用された‘xreduce’。 ‘F’は引数すべてで、一
     度コールされます。

          (%i1) declare (F, nary);
          (%o1)                         done
          (%i2) F ([L]) := L;
          (%o2)                      F([L]) := L
          (%i3) xreduce (F, [a, b, c, d, e]);
          (%o3)         [[[[[("[", simp), a], b], c], d], e]

     n項とわかっていない関数に適用された‘xreduce’。 ‘G’は、 毎回２つの引
     数で複数回コールされます。

          (%i1) G ([L]) := L;
          (%o1)                      G([L]) := L
          (%i2) xreduce (G, [a, b, c, d, e]);
          (%o2)         [[[[[("[", simp), a], b], c], d], e]
          (%i3) lreduce (G, [a, b, c, d, e]);
          (%o3)                 [[[[a, b], c], d], e]


File: maxima.info,  Node: Function Definition,  Next: Program Flow,  Prev: Sets,  Up: Top

36 Function Definition
**********************

* Menu:

* Introduction to Function Definition::  
* Function::                    
* Macros::                      
* Functions and Variables for Function Definition::  


File: maxima.info,  Node: Introduction to Function Definition,  Next: Function,  Prev: Function Definition,  Up: Function Definition

36.1 Introduction to Function Definition
========================================


File: maxima.info,  Node: Function,  Next: Macros,  Prev: Introduction to Function Definition,  Up: Function Definition

36.2 Function
=============

36.2.1 Ordinary functions
-------------------------

Maximaの中で関数を定義するためには、 ‘:=’演算子を使います。 例えば、

     f(x) := sin(x)

は関数 ‘f’を定義します。 匿名関数も ‘lambda’を使って生成することができま
す。 例えば、

     f(i,j) := block ([], ...);
     map (lambda ([i], i+1), l)

は、項それぞれに1を足したリストを返しますが、

     lambda ([i, j], ...)

を‘f’の代わりに使うことができます。

   (訳注: 元マニュアルの編集ミスでしょうか。以下の内容が一貫すると思いま
す。
     f(i) := i+1;
     map (f, l)

は、項それぞれに1を足したリストを返しますが、

     lambda ([i], i+1)

を‘f’の代わりに使うことができます。)

   余分な引数のリストに割り当てられる最後の引数を持つことで、 引数が可変
の関数も定義できます:

   (訳注: 最後の引数変数を‘[]’でくくると、残りの引数のリストがその引数変
数に割り当てられます。)

     (%i1) f ([u]) := u;
     (%o1)                      f([u]) := u
     (%i2) f (1, 2, 3, 4);
     (%o2)                     [1, 2, 3, 4]
     (%i3) f (a, b, [u]) := [a, b, u];
     (%o3)               f(a, b, [u]) := [a, b, u]
     (%i4) f (1, 2, 3, 4, 5, 6);
     (%o4)                 [1, 2, [3, 4, 5, 6]]

   関数の右辺は式です。 従って、もし一連の式が欲しいなら、

     f(x) := (expr1, expr2, ...., exprn);

   とします。 <exprn>の値が関数が返すものになります。

   もし関数内部のある式から‘return’したいなら、 ‘block’と‘return’を使わ
なければいけません。

     block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)

   はそれ自身式で、関数定義の右辺にとって代わることができます。 この際、
最後の式よりも早くreturnが起こるかもしれません。

   ブロックの中の最初の‘[]’は、 ‘[a: 3, b, c: []]’のように、変数と変数割
り当てのリストを含むかもしれません。 ‘[a: 3, b, c: []]’は、３つの変数
‘a’,‘b’,‘c’が コードが、‘block’内部や‘block’内部からコールされた関数内部
で実行される限り、 グローバル値を参照しないように、しかしむしろ特別な値
を持つようにします。 変数がブロックの開始から抜ける時間まで続くので、こ
れは、動的バインドと呼ばれます。 一旦‘block’から戻るか、そこから出ると、
(もし存在するなら）変数の古い値が戻されます。 この方法で変数を保護するこ
とは確かによい考えです。 ブロック変数に関する割り当ては、並列に行われる
ことに注意してください。 これは、もし先に‘c: a’を使ったら、‘c’の値はブロ
ックにちょうど入った時、まだ ‘a’がバインドされる前の‘a’の値であることを
意味します。 例えば、

     block ([a: a], expr1, ... a: a+3, ..., exprn)

   のような何かを実行することは、 ‘a’の外部の値を変更されないよう保護し
ますが、その値がなんだったかアクセス可能にします。 割り当ての右辺は、バ
インドが起こる前に入る文脈の中で評価されます。 Using just ただ‘block
([x], ...’を使うことは、 ちょうどまるで新しいMaximaセッションに入ったか
のように、‘x’がそれ自身を値として持つようにします。

   関数の実際の引数は、ブロックの変数と厳密に同じ方法で扱われます。 例え
ば、

     f(x) := (expr1, ..., exprn);

   と

     f(1);

   では、式の評価に関して、まるで

     block ([x: 1], expr1, ..., exprn)

   を実行したかのような類似の文脈を持ちます。

   定義の右辺がランタイムで計算される時、 関数内部では、‘define’とたぶん
‘buildq’を使うことが役に立ちます。

   Inside functions, when the right hand side of a definition, may be
computed at runtime, it is useful to use ‘define’ and possibly ‘buildq’.

36.2.2 Array functions
----------------------

配列関数は、初めて与えられた引数でコールされた時、関数値を記憶し、 同じ
引数が与えられた時、再計算することなしに記憶した値を返します。 そんな関
数はしばしばメモ化関数と呼ばれます。

   配列関数名は、(グローバルリスト‘functions’ではなく) グローバルリスト
‘arrays’に追加されます。

   ‘arrayinfo’は 記憶された値を持つ引数のリストを返し、 ‘listarray’は記
憶された値を返します。 ‘dispfun’と‘fundef’は配列関数の定義を返します。

   ‘arraymake’は、通常の関数に対する‘funmake’のように、 配列関数コールを
構成します。 ‘arrayapply’は、 通常の関数に対する‘apply’のように、 配列関
数をその引数に適用します。 配列関数に対して、‘map’に厳密に似たものはあり
ません。 ‘map(lambda([<x>], <a>[<x>]), <L>)’または ‘makelist(<a>[<x>],
<x>, <L>)’ ―<L>はリストです―は、目的からそれほど遠くありませんけれども。

   ‘remarray’は、 通常の関数に対する‘remfunction’のように、 (記憶された
関数値も含めて、)配列関数の定義を削除します。

   ‘kill(<a>[<x>])’は、配列関数<a>の引数<x>に関して記憶された 値を削除し
ます; 次回、引数<x>で<a>がコールされた時、 関数値は再計算されます。 しか
しながら、 関数定義も削除する‘kill(<a>)’または‘remarray(<a>)’を除いて、
記憶された値すべてを一度に削除する方法はありません。


File: maxima.info,  Node: Macros,  Next: Functions and Variables for Function Definition,  Prev: Function,  Up: Function Definition

36.3 Macros
===========

 -- 関数: buildq (<L>, <expr>)

     リスト<L>で指名された変数を式 <expr>に 並列に代入します。<expr>は評
     価しません。 ‘buildq’が代入を実行した後、 結果の式は整理はされます
     が、評価されません。

     <L>の要素はシンボルまたは割り当て式‘<symbol>: <value>’です。 割り当
     て式は並列に評価されます。 すなわち、ある変数が割り当ての右辺へバイ
     ンドされるのは、 ‘buildq’がコールされた文脈でのバインドです。 変数
     リスト<L>内でその変数がバインドされるのではありません。 もし<L>の中
     のある変数に明示的な割り当てがないなら、 ‘buildq’でのバインドは、
     ‘buildq’がコールされた文脈でのそれと同じです。

     そして、<L>で指名された変数は並列に<expr>に代入されます。 すなわち
     、すべての変数への代入は他の代入がされる前に決まります。 だから、１
     つの変数の代入は他には一切効果を持ちません。

     もし 任意の変数 <x>が <expr>の中で ‘splice (<x>)’のように現れるなら
     、 <x>はリストにバインドされなければいけませんし、 リストは、代入の
     代わりに<expr> に接合(内挿)されます。

     <expr>の中の<L>に現れない任意の変数は、 たとえそれらが‘buildq’がコ
     ールされた文脈の中でバインドを持っていても、 逐語的に結果に繰り越さ
     れます。

     例

     ‘a’は明示的に ‘x’にバインドされ、 一方で ‘b’は、コールする文脈で同
     じバインド(すなわち29)を持ち、 ‘c’は逐語的に繰り越されます。 結果の
     式は、明示的な評価 ‘''%’まで評価されません。

          (%i1) (a: 17, b: 29, c: 1729)$
          (%i2) buildq ([a: x, b], a + b + c);
          (%o2)                      x + c + 29
          (%i3) ''%;
          (%o3)                       x + 1758

     ‘e’はリストにバインドされ、 ‘foo’の引数の中でそのように現れ、
     ‘bar’の引数の中に内挿されます。

          (%i1) buildq ([e: [a, b, c]], foo (x, e, y));
          (%o1)                 foo(x, [a, b, c], y)
          (%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
          (%o2)                  bar(x, a, b, c, y)

     代入の後、結果は整理されます。 もし代入の前に整理が適用されたら、こ
     れら２つの結果は同じになったはずです。
          (%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
          (%o1)                    2 c + 2 b + 2 a
          (%i2) buildq ([e: [a, b, c]], 2 * splice (e));
          (%o2)                        2 a b c

     <L>の中の変数は並列にバインドされます; もし順次バインドされたなら、
     最初の結果は、‘foo (b, b)’になったはずです。 代入は並列に実行されま
     す; 二番目の結果を‘subst’の結果と比較してください。 ‘subst’は代入を
     順次実行します。

          (%i1) buildq ([a: b, b: a], foo (a, b));
          (%o1)                       foo(b, a)
          (%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
                        bar (u, v, w, x, y, z));
          (%o2)                 bar(v, w, x, y, z, u)
          (%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
                       bar (u, v, w, x, y, z));
          (%o3)                 bar(u, u, u, u, u, u)

     変数や式が左辺に、それらの値が右辺にある等式のリストを構成します。
     ‘macroexpand’は‘show_values’が返す式を表示します。

          (%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
          (%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
          (%i2) (a: 17, b: 29, c: 1729)$
          (%i3) show_values (a, b, c - a - b);
          (%o3)          [a = 17, b = 29, c - b - a = 1683]
          (%i4) macroexpand (show_values (a, b, c - a - b));
          (%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])

     複数の引数を持つ関数が与えられたとして、 引数のいくつかが固定された
     もう１つの関数を生成します。

          (%i1) curry (f, [a]) :=
                  buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
          (%i2) by3 : curry ("*", 3);
          (%o2)        lambda([[x]], apply(*, append([3], x)))
          (%i3) by3 (a + b);
          (%o3)                       3 (b + a)

 -- 関数: macroexpand (<expr>)

     ‘expr’がマクロ関数コールの時、 <expr>のマクロ展開を、評価はせずに、
     返します。 そうでなければ、‘macroexpand’は<expr>を返します。

     もし<expr>の展開が別のマクロ関数コールをもたらすなら、 そのマクロ関
     数コールも展開されます。

     ‘macroexpand’は引数をクォートします。 しかしながら、もしマクロ関数
     コールの展開が副作用を持つなら， それらの副作用が実行されます。

     ‘::=’, ‘macros’, ‘macroexpand1’も参照してください。

     例

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand (h (y));
                                        y - a
          (%o4)                         -----
                                         99
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- 関数: macroexpand1 (<expr>)

     ‘expr’がマクロ関数コールの時、 <expr>のマクロ展開を、評価せずに、返
     します。 そうでなければ、‘macroexpand1’は<expr>を返します。

     ‘macroexpand’は引数をクォートします。 しかしながら、もしマクロ関数
     コールの展開が副作用を持つなら， それらの副作用が実行されます。

     もし<expr>の展開が別のマクロ関数コールをもたらすなら、 そのマクロ関
     数コールは展開されません。

     ‘::=’, ‘macros’, ‘macroexpand’も参照してください。

     例

          (%i1) g (x) ::= x / 99;
                                              x
          (%o1)                      g(x) ::= --
                                              99
          (%i2) h (x) ::= buildq ([x], g (x - a));
          (%o2)            h(x) ::= buildq([x], g(x - a))
          (%i3) a: 1234;
          (%o3)                         1234
          (%i4) macroexpand1 (h (y));
          (%o4)                       g(y - a)
          (%i5) h (y);
                                      y - 1234
          (%o5)                       --------
                                         99

 -- Global variable: macros
     デフォルト値: ‘[]’

     ‘macros’は、ユーザー定義のマクロ関数のリストです。 マクロ関数定義演
     算子‘::=’は、このリストに新しいマクロ関数を入れ、 ‘kill’, ‘remove’,
     ‘remfunction’はリストからマクロ関数を削除します。

     ‘infolists’も参照してください。

 -- 関数: splice (<a>)

     ‘splice’が‘buildq’内部に現れた時だけ、 アトム<a>で指名されたリスト
     を式に接合(内挿)します; そうでなければ、‘splice’は未定義関数として
     扱われます。 もし ‘buildq’内部で <a>単独として(‘splice’なしに)現れ
     たら、 <a>はリストとして、結果の中に代入されます(内挿されません)。
     ‘splice’の引数はアトムだけを取り得ます; リストリテラルやリストをも
     たらす式を取ることはできません。

     通常、‘splice’は、関数や演算子の引数を提供します。 関数‘f’に対して
     、 ‘buildq’内部の式‘f (splice (<a>))’は、 ‘f (<a>[1], <a>[2],
     <a>[3], ...)’に展開されます。 演算子‘o’に対して、 ‘buildq’内部の式
     ‘"o" (splice (<a>)’は、 ‘"o" (<a>[1], <a>[2], <a>[3], ...)’に展開さ
     れます。 ここで‘o’は、任意のタイプの演算子を取り得ます(通常は複数の
     引数を取るものです)。 演算子はダブルクォート‘"’でくくられなければい
     けないことに注意してください。

     例

          (%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                                 foo(1, %pi, z - y)
          (%o1)                -----------------------
                               length([1, %pi, z - y])
          (%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                          1
          (%o2)                          ---
                                         %pi
          (%i3) matchfix ("<>", "<>");
          (%o3)                          <>
          (%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
          (%o4)                   <>1, %pi, z - y<>


File: maxima.info,  Node: Functions and Variables for Function Definition,  Prev: Macros,  Up: Function Definition

36.4 Functions and Variables for Function Definition
====================================================

 -- 関数: apply (<F>, [<x_1>, ..., <x_n>])

     ‘<F>(<x_1>, ..., <x_n>)’を構成、評価します。

     ‘apply’は、配列関数を通常の関数と区別しようとはしません; <F>が配列
     関数の名前の時、‘apply’は‘<F>(...)’(カギ括弧の代わりに括弧での関数
     コール）を評価します。 ‘arrayapply’は、この場合、カギ括弧ありで関数
     コールを評価します。

     例:

     ‘apply’は、引数を評価します。 この例では、‘min’が‘L’の値に適用され
     ます。

          (%i1) L : [1, 5, -10.2, 4, 3];
          (%o1)                 [1, 5, - 10.2, 4, 3]
          (%i2) apply (min, L);
          (%o2)                        - 10.2

     ‘apply’は、たとえ関数<F>が引数をクォートする場合でも、引数を評価し
     ます。

          (%i1) F (x) := x / 1729;
                                             x
          (%o1)                     F(x) := ----
                                            1729
          (%i2) fname : F;
          (%o2)                           F
          (%i3) dispfun (F);
                                             x
          (%t3)                     F(x) := ----
                                            1729

          (%o3)                         [%t3]
          (%i4) dispfun (fname);
          fname is not the name of a user function.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) apply (dispfun, [fname]);
                                             x
          (%t5)                     F(x) := ----
                                            1729
          (%o5)                         [%t5]

     ‘apply’は関数名<F>を評価します。 シングルクオート‘'’は評価を無効に
     します。 ‘demoivre’はグローバル変数の名前であり、また、関数でもあり
     ます。

          (%i1) demoivre;
          (%o1)                         false
          (%i2) demoivre (exp (%i * x));
          (%o2)                  %i sin(x) + cos(x)
          (%i3) apply (demoivre, [exp (%i * x)]);
          demoivre evaluates to false
          Improper name or value in functional position.
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) apply ('demoivre, [exp (%i * x)]);
          (%o4)                  %i sin(x) + cos(x)

 -- 関数: block ([<v_1>, ..., <v_m>], <expr_1>, ..., <expr_n>)
 -- 関数: block (<expr_1>, ..., <expr_n>)

     ‘block’は<expr_1>, ..., <expr_n>を順に評価し、評価された最後の式の
     値を返します。 順序は‘go’, ‘throw’, ‘return’関数によって変更するこ
     とができます。 最後の式は、‘return’もしくは‘throw’を含む式が評価さ
     れないなら、<expr_n>です。 いくつかの変数<v_1>, ..., <v_m>がブロッ
     クにローカルに宣言できます; これらは同じ名前のグローバル変数と区別
     されます。 変数がローカルに宣言されないなら、リストは省略できます。
     ブロック内では、<v_1>, ..., <v_m>以外の変数はグローバル変数です。

     ‘block’は（存在するなら）変数<v_1>, ..., <v_m>の現在の値を保存し、
     変数がそれ自身に評価されるよう変数のバインドを解除します。 ローカル
     変数はブロック内部で任意の値にバインドできますが、 ブロックが終了す
     るとき保存された値が戻され、 ブロック内で割り当てられた値は失われま
     す。

     ‘block’内部の宣言‘local(<v_1>, ..., <v_m>)’は シンボル<v_1>, ...,
     <v_m>に関連付けられた性質を保存し、 他の式を評価する前に、性質を取
     り除き、ブロック終了時に元に戻します。 いくつかの宣言は、‘:=’、
     ‘array’, ‘dependencies’, ‘atvalue’, ‘matchdeclare’, ‘atomgrad’,
     ‘constant’, ‘nonscalar’その他を含むシンボルの性質として実装されます
     。 ‘local’の効果は、ブロック内部のみで有効な宣言を作ります; そうで
     なければ、ブロック内部の宣言は実際にグローバル宣言となります。

     ‘block’は他の‘block’内部でも現れます。 ローカル変数が、新しいブロッ
     クが評価されるたびに確立されます。 ローカル変数は、内包するブロック
     ではグローバルです。 ブロックの中で、変数がローカルでないなら、その
     値は内包するブロックによって割り当てられた最新の値です。 そうでなけ
     れば、グローバル環境の変数の値になります。 このポリシーは「動的スコ
     ープ」の普通の理解と一致します。

     ブロックの値は、最後の文もしくはブロックから陽に終了するのに使われ
     る関数‘function’の引数の値です。 関数‘go’は、‘go’の引数でタグされた
     ブロックの文に制御を移すのに使われます。 例えば、‘block ([x], x:1,
     loop, x: x+1, ..., go(loop), ...)’。 ‘go’の引数はブロック内部に現れ
     るタグの名前でなければなりません。 ‘go’を含んだブロック以外のブロッ
     ク内部のタグへ飛ぶのに‘go’を使うことはできません。

     ブロックは、典型的な場合、関数定義の右辺に現れますが、他の場所でも
     使うことができます。

 -- 関数: break (<expr_1>, ..., <expr_n>)

     <expr_1>, ..., <expr_n>を評価し、印字し、それから ユーザーが環境を
     検査し変更できるところでMaximaブレイクを引き起こします。 ‘exit;’を
     タイプすると、計算が再開されます。

 -- 関数: catch (<expr_1>, ..., <expr_n>)

     <expr_1>, ..., <expr_n>を１つずつ評価します; もしどれかが形式‘throw
     (arg)’の式の評価に至るなら、 ‘catch’の値は‘throw (arg)’の値であり、
     もう式は評価されません。 これの「非局所的リターン」は 入れ子の任意
     の深さを通過して、‘throw’を含む最も近い‘catch’に飛びます。 もし
     ‘throw’を含む‘catch’がないなら、 エラーメッセージが印字されます。

     もし引数の評価が いかなる‘throw’の評価にも至らないなら、 ‘catch’の
     値は<expr_n>の値です。

          (%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
          (%i2) g(l) := catch (map (''%, l))$
          (%i3) g ([1, 2, 3, 7]);
          (%o3)               [f(1), f(2), f(3), f(7)]
          (%i4) g ([1, 2, -3, 7]);
          (%o4)                          - 3

     もし‘l’が非負数だけから成るなら、 ‘l’の要素それぞれの‘f’のリストを
     返します; そうでなければ、‘g’は "catches" the first negative
     element of ‘l’の最初の負の要素を「キャッチ」して、それを「スロー」
     します。

 -- 関数: compfile (<filename>, <f_1>, …, <f_n>)
 -- 関数: compfile (<filename>, functions)
 -- 関数: compfile (<filename>, all)

     Maxima関数をLispに翻訳し、翻訳したコードをファイル<filename>に書き
     込みます。

     ‘compfile(<filename>, <f_1>, ..., <f_n>)’は 指定された関数を翻訳し
     ます。 ‘compfile (<filename>, functions)’と ‘compfile (<filename>,
     all)’はユーザー定義関数をすべて翻訳します。

     Lisp翻訳は評価されず、出力ファイルはLispコンパイラによって処理もさ
     れません。 ‘translate’はLisp翻訳を生成し評価します。
     ‘compile_file’はMaximaをLispに翻訳し、Lispコンパイラを実行します。

     ‘translate’, ‘translate_file’, ‘compile_file’も参照してください。

 -- 関数: compile (<f_1>, ..., <f_n>)
 -- 関数: compile (functions)
 -- 関数: compile (all)

     Maxima関数<f_1>, ..., <f_n>をLispに翻訳し、 Lisp翻訳を評価し、 翻訳
     された関数それぞれについてLisp関数‘COMPILE’をコールします。
     ‘compile’は、コンパイルされた関数名のリストを返します。

     ‘compile (all)’や‘compile (functions)’は、 ユーザー定義関数すべてを
     コンパイルします。

     ‘compile’は引数をクォートします; クォートクォート演算子‘''’はクォー
     トに優先します。

 -- 関数: define (<f>(<x_1>, …, <x_n>), <expr>)
 -- 関数: define (<f>[<x_1>, …, <x_n>], <expr>)
 -- 関数: define (funmake (<f>, [<x_1>, …, <x_n>]), <expr>)
 -- 関数: define (arraymake (<f>, [<x_1>, …, <x_n>]), <expr>)
 -- 関数: define (ev (<expr_1>), <expr_2>)

     引数<x_1>, …, <x_n>を持ち、 <expr>の中身を持つ<f>という名前の関数を
     定義します。 ‘define’は、いつも（陽にクオートされていない限り）、２
     番目の引数を評価します。 定義された関数は、（かっこでくくられた引数
     を持つ）通常のMaxima関数 もしくは（カギ括弧でくくられた引数を持つ）
     配列関数です。

     最後の関数の引数<x_n>が要素１つのリストの時、 ‘define’によって定義
     される関数は、可変な数の引数を受け入れます。 実際の引数は、形式的な
     引数, <x_1>, ..., <x_(n - 1)>に１対１に割り当てられます。 実際の引
     数がさらに存在するなら<x_n>にリストとして割り当てられます。

     ‘define’の最初の引数が‘<f>(<x_1>, ..., <x_n>)’もしくは ‘<f>[<x_1>,
     ..., <x_n>]’の形の式の時、 関数の引数は評価されますが、既にその名前
     の関数や変数があったとしても<f>は評価されません。

     最初の引数が演算子‘funmake’もしくは‘arraymake’, ‘ev’を伴う式の時、
     最初の引数は評価されます；これは、本体だけでなく、関数名が計算され
     ることを許します。

     すべての関数定義は同じ名前空間で現れます; 関数gの中で関数‘f’を定義
     することは、‘f’のスコープを‘g’に自動的に限定することにはなりません
     。 しかしながら、‘local(f)’は、関数‘f’の定義を、 ‘local’が現れたブ
     ロックや他の合成式内部でのみ有効とします。

     もしある形式的な引数<x_k>が（評価の後）クォートされたシンボルならば
     、 ‘define’によって定義される関数は、対応する実際の引数を評価しませ
     ん。 そうでければ、すべての実際の引数は評価されます。

     ‘:=’や‘::=’も参照してください。

     例:

     ‘define’は、(陽にクォートされない限り)いつも二番目の引数を評価しま
     す

          (%i1) expr : cos(y) - sin(x);
          (%o1)                    cos(y) - sin(x)
          (%i2) define (F1 (x, y), expr);
          (%o2)              F1(x, y) := cos(y) - sin(x)
          (%i3) F1 (a, b);
          (%o3)                    cos(b) - sin(a)
          (%i4) F2 (x, y) := expr;
          (%o4)                   F2(x, y) := expr
          (%i5) F2 (a, b);
          (%o5)                    cos(y) - sin(x)

     ‘define’が定義する関数は、通常のMaxima関数も配列関数も取り得ます。

          (%i1) define (G1 (x, y), x.y - y.x);
          (%o1)               G1(x, y) := x . y - y . x
          (%i2) define (G2 [x, y], x.y - y.x);
          (%o2)                G2     := x . y - y . x
                                 x, y

     最後の、または唯一の引数<x_n>が１要素のリストの時、 ‘define’が定義
     した関数は可変の数の引数を受け付けます。

          (%i1) define (H ([L]), '(apply ("+", L)));
          (%o1)                H([L]) := apply("+", L)
          (%i2) H (a, b, c);
          (%o2)                       c + b + a

     最初の引数が 演算子‘funmake’, ‘arraymake’, または‘ev’を含む式なら、
     最初の引数は評価されます。

          (%i1) [F : I, u : x];
          (%o1)                        [I, x]
          (%i2) funmake (F, [u]);
          (%o2)                         I(x)
          (%i3) define (funmake (F, [u]), cos(u) + 1);
          (%o3)                  I(x) := cos(x) + 1
          (%i4) define (arraymake (F, [u]), cos(u) + 1);
          (%o4)                   I  := cos(x) + 1
                                   x
          (%i5) define (foo (x, y), bar (y, x));
          (%o5)                foo(x, y) := bar(y, x)
          (%i6) define (ev (foo (x, y)), sin(x) - cos(y));
          (%o6)             bar(y, x) := sin(x) - cos(y)

 -- 関数: define_variable (<name>, <default_value>, <mode>)

     グローバル変数をMaxima環境に導入します。 ‘define_variable’は、ユー
     ザーが書いたパッケージで役に立ちます。 パッケージはしばしば翻訳され
     たりコンパイルされたりします。

     ‘define_variable’は以下のステップを実行します:

       1. ‘mode_declare (<name>, <mode>)’は、 <name>のモードを翻訳器に宣
          言します。 可能なモードのリストについては、‘mode_declare’を参
          照してください。

       2. もし変数がバインドされていなければ、<default_value>が<name>に
          割り当てられます。

       3. ‘declare (<name>, special)’はそれをspecialと宣言します。

       4. <name>が宣言されたモードのただ１つの割り当てられた値であること
          を 保証するために、 <name>をテスト関数に関連づけます。

     ‘value_check’プロパティは、 ‘define_variable’を介して ‘any’以外のモ
     ードに定義された任意の変数に割り当てられることができます。
     ‘value_check’プロパティは、１変数のラムダ式または関数名です。 それ
     は値を変数に割り当てようとする時にコールされます。 ‘value_check’関
     数の引数は期待値です。

     ‘define_variable’は‘default_value’を評価し、 ‘name’と‘mode’をクォー
     トします。 ‘define_variable’は‘name’の現在値を返します。 それは、も
     し‘name’がそこでバインドされてないなら‘default_value’で そうでない
     なら‘name’の以前の値です。

     例:

     ‘foo’はブーリアン変数で、初期値‘true’を持ちます。

          (%i1) define_variable (foo, true, boolean);
          (%o1)                         true
          (%i2) foo;
          (%o2)                         true
          (%i3) foo: false;
          (%o3)                         false
          (%i4) foo: %pi;
          Error: foo was declared mode boolean, has value: %pi
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i5) foo;
          (%o5)                         false

     ‘bar’は整数変数で、素数でなければいけません。

          (%i1) define_variable (bar, 2, integer);
          (%o1)                           2
          (%i2) qput (bar, prime_test, value_check);
          (%o2)                      prime_test
          (%i3) prime_test (y) := if not primep(y) then
                                     error (y, "is not prime.");
          (%o3) prime_test(y) := if not primep(y)

                                             then error(y, "is not prime.")
          (%i4) bar: 1439;
          (%o4)                         1439
          (%i5) bar: 1440;
          1440 is not prime.
          #0: prime_test(y=1440)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) bar;
          (%o6)                         1439

     ‘baz_quux’は、値を割り当てられない変数です。 モード‘any_check’は
     ‘any’のようですが、 ‘any_check’は‘value_check’メカニズムを可能にし
     ますが、 ‘any’はそうしません。

          (%i1) define_variable (baz_quux, 'baz_quux, any_check);
          (%o1)                       baz_quux
          (%i2) F: lambda ([y], if y # 'baz_quux then
                           error ("Cannot assign to `baz_quux'."));
          (%o2) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i3) qput (baz_quux, ''F, value_check);
          (%o3) lambda([y], if y # 'baz_quux

                                  then error(Cannot assign to `baz_quux'.))
          (%i4) baz_quux: 'baz_quux;
          (%o4)                       baz_quux
          (%i5) baz_quux: sqrt(2);
          Cannot assign to `baz_quux'.
          #0: lambda([y],if y # 'baz_quux then
                           error("Cannot assign to `baz_quux'."))(y=sqrt(2))
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i6) baz_quux;
          (%o6)                       baz_quux

 -- 関数: dispfun (<f_1>, …, <f_n>)
 -- 関数: dispfun (all)

     ユーザー定義関数<f_1>, ..., <f_n>の定義を表示します。 引数それぞれ
     は、(‘::=’で定義された)マクロ名、 (‘:=’や‘define’で定義された)通常
     の関数、 (‘:=’y‘define’で定義された、しかし引数をカギ括弧‘[ ]’でく
     くった) 配列関数、 (‘:=’y‘define’で定義された、しかしいくつかの引数
     をカギ括弧‘[ ]’で、他の引数を括弧‘( )’でくくった)添字付き関数、 特
     別な添字の値で選択された添字付き関数の族の１つ、 定数添字で定義され
     た添字付き関数、 のいずれかを取り得ます。

     ‘dispfun (all)’は、 ‘functions’, ‘arrays’, ‘macros’リストで与えられ
     た中で、 定数添字で定義された添字付き関数を除いたユーザー定義関数す
     べてを表示します。

     ‘dispfun’は 表示された関数それぞれのために (‘%t1’, ‘%t2’, など) 中
     間式ラベルを生成し、関数定義をラベルに割り当てます。 対照的に、
     ‘fundef’は関数定義を返します。

     ‘dispfun’は引数をクォートします; クォートクォート演算子‘''’はクォー
     トに優先します。 ‘dispfun’は表示された関数に対応する中間式ラベルの
     リストを返します。

     例:

          (%i1) m(x, y) ::= x^(-y);
                                               - y
          (%o1)                   m(x, y) ::= x
          (%i2) f(x, y) :=  x^(-y);
                                               - y
          (%o2)                    f(x, y) := x
          (%i3) g[x, y] :=  x^(-y);
                                              - y
          (%o3)                     g     := x
                                     x, y
          (%i4) h[x](y) :=  x^(-y);
                                              - y
          (%o4)                     h (y) := x
                                     x
          (%i5) i[8](y) :=  8^(-y);
                                              - y
          (%o5)                     i (y) := 8
                                     8
          (%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                               - y
          (%t6)                   m(x, y) ::= x
                                               - y
          (%t7)                    f(x, y) := x

                                              - y
          (%t8)                     g     := x
                                     x, y

                                              - y
          (%t9)                     h (y) := x
                                     x

                                              1
          (%t10)                     h (y) := --
                                      5        y
                                              5

                                               1
          (%t11)                    h  (y) := ---
                                     10         y
                                              10

                                              - y
          (%t12)                    i (y) := 8
                                     8

          (%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
          (%i12) ''%;
                               - y              - y            - y
          (%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                                      x, y
                            - y           1              1             - y
                  h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
                   x              5        y   10         y   8
                                          5             10

 -- 関数: fullmap (<f>, <expr_1>, …)

     ‘map’と似ていますが、‘fullmap’は、主演算子が同じでなくなるまで、 部
     分式すべてに再帰的にマッピングを続けます。

     ‘fullmap’は、ある行列操作のための整理に使われています; このように、
     Maximaは時々、たとえ‘fullmap’がユーザーに陽にコールされなくても、
     ‘fullmap’に関係したエラーメッセージを生成します。

     例:

          (%i1) a + b * c;
          (%o1)                        b c + a
          (%i2) fullmap (g, %);
          (%o2)                   g(b) g(c) + g(a)
          (%i3) map (g, %th(2));
          (%o3)                     g(b c) + g(a)

 -- 関数: fullmapl (<f>, <list_1>, …)

     ‘fullmap’に似ていますが、‘fullmapl’はリストや行列にのみマップします
     。

     例:

          (%i1) fullmapl ("+", [3, [4, 5]], [[a, 1], [0, -1.5]]);
          (%o1)                [[a + 3, 4], [4, 3.5]]

 -- システム変数: functions
     デフォルト値: ‘[]’

     ‘functions’は、現在のセッションでの通常のMaxima関数のリストです。 通
     常の関数は、‘define’や‘:=’で構成された関数であり、 括弧‘()’でコール
     されます。 関数はMaximaプロンプトで定義することができ、また、
     ‘load’や‘batch’がロードするMaximaファイルの中で定義することができま
     す。

     (例えば‘F[x]’のように、カギ括弧でコールされる)配列関数と (例えば
     ‘F[x](y)’のように、カギ括弧と括弧でコールされる)添字付き関数は、
     ‘functions’ではなくグローバル変数‘arrays’にリストされます。

     Lisp関数はどのリストにも保持されません。

     例:

          (%i1) F_1 (x) := x - 100;
          (%o1)                   F_1(x) := x - 100
          (%i2) F_2 (x, y) := x / y;
                                                x
          (%o2)                    F_2(x, y) := -
                                                y
          (%i3) define (F_3 (x), sqrt (x));
          (%o3)                   F_3(x) := sqrt(x)
          (%i4) G_1 [x] := x - 100;
          (%o4)                    G_1  := x - 100
                                      x
          (%i5) G_2 [x, y] := x / y;
                                               x
          (%o5)                     G_2     := -
                                       x, y    y
          (%i6) define (G_3 [x], sqrt (x));
          (%o6)                    G_3  := sqrt(x)
                                      x
          (%i7) H_1 [x] (y) := x^y;
                                                y
          (%o7)                     H_1 (y) := x
                                       x
          (%i8) functions;
          (%o8)              [F_1(x), F_2(x, y), F_3(x)]
          (%i9) arrays;
          (%o9)                 [G_1, G_2, G_3, H_1]

 -- 関数: fundef (<f>)

     関数<f>の定義を返します。

     引数は、(‘::=’で定義された）マクロの名前か、 (‘:=’もしくは
     ‘define’で定義された）通常の関数か、 (‘:=’や‘define’で定義され、引
     数がカギ括弧でくくられた）配列関数か、 (‘:=’や‘define’で定義され、
     いくつかの引数がカギ括弧でくくられ、残りがかっこでくくられた）添字
     関数か、 特別な添字の値によって選択された添字関数族の１つか、一定の
     添字で定義された添字関数です。

     ‘fundef’は引数をクォートします; クォートクォート演算子‘''’はクォー
     トに優先します。

     ‘fundef (<f>)’は<f>の定義を返します。 対照的に、‘dispfun (<f>)’は中
     間式ラベルを生成し、ラベルに定義を割り当てます。

 -- 関数: funmake (<F>, [<arg_1>, …, <arg_n>])

     式‘<F>(<arg_1>, ..., <arg_n>)’を返します。 戻り値は整理されますが、
     評価されません。 だから関数<F>はたとえ存在してもコールされません。

     ‘funmake’は配列関数と通常の関数を区別しようとしません; <F>が配列関
     数名の時、 ‘funmake’は‘<F>(...)’を返します (すなわち、カギ括弧の代
     わりに括弧での関数コール)。 ‘arraymake’は、この場合，カギ括弧での関
     数コールを返します。

     ‘funmake’は引数を評価します。

     例:

     通常のMaxima関数に適用された‘funmake’。

          (%i1) F (x, y) := y^2 - x^2;
                                             2    2
          (%o1)                  F(x, y) := y  - x
          (%i2) funmake (F, [a + 1, b + 1]);
          (%o2)                    F(a + 1, b + 1)
          (%i3) ''%;
                                        2          2
          (%o3)                  (b + 1)  - (a + 1)

     マクロに適用された‘funmake’。

          (%i1) G (x) ::= (x - 1)/2;
                                            x - 1
          (%o1)                    G(x) ::= -----
                                              2
          (%i2) funmake (G, [u]);
          (%o2)                         G(u)
          (%i3) ''%;
                                        u - 1
          (%o3)                         -----
                                          2

     添字付き関数に適用された‘funmake’。

          (%i1) H [a] (x) := (x - 1)^a;
                                                  a
          (%o1)                   H (x) := (x - 1)
                                   a
          (%i2) funmake (H [n], [%e]);
                                                 n
          (%o2)               lambda([x], (x - 1) )(%e)
          (%i3) ''%;
                                              n
          (%o3)                       (%e - 1)
          (%i4) funmake ('(H [n]), [%e]);
          (%o4)                        H (%e)
                                        n
          (%i5) ''%;
                                              n
          (%o5)                       (%e - 1)

     いかなる種類の関数にも定義されていないシンボルへ適用された
     ‘funmake’

          (%i1) funmake (A, [u]);
          (%o1)                         A(u)
          (%i2) ''%;
          (%o2)                         A(u)

     ‘funmake’は引数を評価しますが、戻り値を評価しません。

          (%i1) det(a,b,c) := b^2 -4*a*c;
                                              2
          (%o1)              det(a, b, c) := b  - 4 a c
          (%i2) (x : 8, y : 10, z : 12);
          (%o2)                          12
          (%i3) f : det;
          (%o3)                          det
          (%i4) funmake (f, [x, y, z]);
          (%o4)                    det(8, 10, 12)
          (%i5) ''%;
          (%o5)                         - 284

     Maximaは‘funmake’の戻り値を整理します。

          (%i1) funmake (sin, [%pi / 2]);
          (%o1)                           1

 -- 関数: lambda ([<x_1>, ..., <x_m>], <expr_1>, ..., <expr_n>)
 -- 関数: lambda ([[<L>]], <expr_1>, ..., <expr_n>)
 -- 関数: lambda ([<x_1>, ..., <x_m>, [<L>]], <expr_1>, ..., <expr_n>)
     ラムダ式 (すなわち、匿名関数)を定義し返します。 関数は要求された引
     数<x_1>, ..., <x_m>を持ち、 また、オプション引数<L>を持つかもしれま
     せん。オプション引数は関数本体の中にリストとして現れます。 関数の戻
     り値は<expr_n>です。 ラムダ式は変数に割り当てることができ、通常の関
     数のように評価できます。 ラムダ式は関数名が期待されるいくつかのコン
     テキストで現れるかもしれません。

     関数が評価される時、 バインドされていないローカル変数<x_1>, ...,
     <x_m>が生成されます。 ‘lambda’は ‘block’の中や別の‘lambda’の中で現
     れるかもしれません; ローカル変数は、別の‘block’や‘lambda’が評価され
     る度に毎回確立されます。 ローカル変数は内包する‘block’や‘lambda’に
     はグローバルのように見えます。 もし変数がローカルでないなら、 その
     値は、(もし割り当てられたなら)内包する‘block’や‘lambda’で直近に割り
     当てられた値です。 そうでなければ、グローバル環境での変数の値です。
     このポリシーは「動的スコープ」の普通の理解と一致するかもしれません
     。

     ローカル変数が確立された後、 <expr_1>から<expr_n>までが順に評価され
     ます。 特殊変数‘%%’―直前の式の値を表します―が認識されます。
     ‘throw’と‘catch’も式のリストの中に現れるかもしれません。

     ‘block’で囲まれない限り ‘return’はラムダ式の中には現れません。
     ‘block’で囲まれた場合、 ブロックがたまたま <expr_n>に至るということ
     でない限り、 ‘return’はラムダ式の戻り値ではなくブロックの戻り値を定
     義します。 同様に、‘go’は、‘block’で囲まれない限りラムダ式の中に現
     れません。

     ‘lambda’は引数をクォートします; クォートクォート演算子‘''’はクォー
     トに優先します。

     例:

        • ラムダ式は変数に割り当てることができ、通常の関数のように評価で
          きます。

          (%i1) f: lambda ([x], x^2);
                                                2
          (%o1)                    lambda([x], x )
          (%i2) f(a);
                                          2
          (%o2)                          a
        • ラムダ式は 関数評価が期待される文脈で現れるかもしれません。

          (%i3) lambda ([x], x^2) (a);
                                          2
          (%o3)                          a
          (%i4) apply (lambda ([x], x^2), [a]);
                                          2
          (%o4)                          a
          (%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                                  2   2   2   2   2
          (%o5)                 [a , b , c , d , e ]
        • 引数変数はローカル変数です。 他の変数はグローバル変数のように
          見えます。 ある特殊な評価が‘''’のようにある方法で強制されない
          限り、 グローバル変数はラムダ式が評価される時評価されます。

          (%i6) a: %pi$
          (%i7) b: %e$
          (%i8) g: lambda ([a], a*b);
          (%o8)                   lambda([a], a b)
          (%i9) b: %gamma$
          (%i10) g(1/2);
                                       %gamma
          (%o10)                       ------
                                         2
          (%i11) g2: lambda ([a], a*''b);
          (%o11)                lambda([a], a %gamma)
          (%i12) b: %e$
          (%i13) g2(1/2);
                                       %gamma
          (%o13)                       ------
                                         2
        • ラムダ式は入れ子にできます。 外側のラムダ式の中のローカル変数
          は、 同じ名前のローカル変数がマスクしない限り、 内側の式にはグ
          ローバルに見えます。

          (%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                             1
          (%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                             2
          (%i15) h(%pi, %gamma);
                                       %gamma
          (%o15)                       ------
                                         2
        • ‘lambda’は引数をクォートするので、 以下のラムダ式‘i’は "‘a’を
          掛ける"関数を定義しません。 以下のラムダ式‘i2’のように、 そん
          な関数は‘buildq’を介して定義することができます。

          (%i16) i: lambda ([a], lambda ([x], a*x));
          (%o16)            lambda([a], lambda([x], a x))
          (%i17) i(1/2);
          (%o17)                  lambda([x], a x)
          (%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
          (%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
          (%i19) i2(1/2);
                                               x
          (%o19)                   lambda([x], -)
                                               2
          (%i20) i2(1/2)(%pi);
                                         %pi
          (%o20)                         ---
                                          2
        • ラムダ式は、可変の数の引数を取ることができます。 それは、唯一
          のまたは最後の引数として‘[<L>]’で指定されます。 引数は関数本体
          の中にリストとして現れます。

          (%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
          (%o1)          lambda([aa, bb, [cc]], aa cc + bb)
          (%i2) f (foo, %i, 17, 29, 256);
          (%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
          (%i3) g : lambda ([[aa]], apply ("+", aa));
          (%o3)             lambda([[aa]], apply(+, aa))
          (%i4) g (17, 29, x, y, z, %e);
          (%o4)                  z + y + x + %e + 46

 -- 関数: local (<v_1>, …, <v_n>)

     シンボル<v_1>, ..., <v_n>に関連付けられた性質を保存し、 他の式を評
     価する前にすべての性質を取り除き、 ‘local’が現れたブロックや他の合
     成式の終了時に保存した性質を元に戻します。

     いくつかの宣言は、‘:=’、‘array’, ‘dependencies’, ‘atvalue’,
     ‘matchdeclare’, ‘atomgrad’, ‘constant’, ‘nonscalar’その他を含むシン
     ボルの性質として実装されます。 ‘local’の効果は、ブロック内部のみで
     有効な宣言を作ります; そうでなければ、ブロック内部の宣言は実際にグ
     ローバル宣言となります。

     ‘local’は、‘block’や関数定義の本体や‘lambda’式の中に現れます。 それ
     ぞれの中で１カ所だけ許されます。

     ‘local’は引数をクォートします。 ‘local’は‘done’を返します。

     例:

     ローカル関数定義。

          (%i1) foo (x) := 1 - x;
          (%o1)                    foo(x) := 1 - x
          (%i2) foo (100);
          (%o2)                         - 99
          (%i3) block (local (foo), foo (x) := 2 * x, foo (100));
          (%o3)                          200
          (%i4) foo (100);
          (%o4)                         - 99

 -- オプション変数: macroexpansion
     デフォルト値: ‘false’

     ‘macroexpansion’は マクロ関数コールを マクロ関数の展開(すなわち戻り
     値)で 置き換えるかどうかを制御します。 展開を記憶する代価で、置き換
     えは次の式評価をスピードアップするかもしれません。

     ‘false’
          マクロ関数コールをマクロ関数の展開で置き換えられません。

     ‘expand’
          マクロ関数コールが初めて評価された時、展開が記憶されます。 展
          開は次のコール時に再計算されません; (‘print’やグローバル変数へ
          の割り当てのような)いかなる副作用も 最初にマクロ関数コールが評
          価された時だけ起こります。 式の中の展開は、同じマクロ関数コー
          ルを持つ他の式に影響を与えません。
     ‘displace’
          マクロ関数コールが初めて評価された時、展開でコールを置き換え、
          マクロ関数がコールされた式を変更します。 展開は次のコールで再
          計算されません; (‘print’やグローバル変数への割り当てのような
          )いかなる副作用も 最初にマクロ関数コールが評価された時だけ起こ
          ります。 式の中の展開は、同じマクロ関数コールを持つ他の式に影
          響を与えません。

     例

     ‘macroexpansion’が‘false’の時、 コールする式が評価される時毎回マク
     ロ関数がコールされ、 コールする式は変更されません。

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: false;
          (%o4)                         false
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     ‘macroexpansion’が‘expand’の時、 マクロ関数は一度コールされ、 コー
     ルする式は変更されません。

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: expand;
          (%o4)                        expand
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                            h(x)
          (%t6)                     f(x) := ----
                                            g(x)

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

     ‘macroexpansion’が‘expand’の時、 マクロ関数は一度コールされ、 コー
     ルする式が変更されます。

          (%i1) f (x) := h (x) / g (x);
                                            h(x)
          (%o1)                     f(x) := ----
                                            g(x)
          (%i2) g (x) ::= block (print ("x + 99 is equal to", x),
                                 return (x + 99));
          (%o2) g(x) ::= block(print("x + 99 is equal to", x),
                                                            return(x + 99))
          (%i3) h (x) ::= block (print ("x - 99 is equal to", x),
                                 return (x - 99));
          (%o3) h(x) ::= block(print("x - 99 is equal to", x),
                                                            return(x - 99))
          (%i4) macroexpansion: displace;
          (%o4)                       displace
          (%i5) f (a * b);
          x - 99 is equal to x
          x + 99 is equal to x
                                      a b - 99
          (%o5)                       --------
                                      a b + 99
          (%i6) dispfun (f);
                                           x - 99
          (%t6)                    f(x) := ------
                                           x + 99

          (%o6)                         done
          (%i7) f (a * b);
                                      a b - 99
          (%o7)                       --------
                                      a b + 99

 -- オプション変数: mode_checkp
     デフォルト値: ‘true’

     ‘mode_checkp’が‘true’の時、 ‘mode_declare’はバインドされた変数のモ
     ードをチェックします。

 -- オプション変数: mode_check_errorp
     デフォルト値: ‘false’

     ‘mode_check_errorp’が‘true’の時、 ‘mode_declare’はエラーをコールし
     ます。

 -- オプション変数: mode_check_warnp
     デフォルト値: ‘true’

     ‘mode_check_warnp’が‘true’の時、 モードエラーが記述されます。

 -- 関数: mode_declare (<y_1>, <mode_1>, …, <y_n>, <mode_n>)

     ‘mode_declare’は、 その後の関数の翻訳やコンパイルのために 変数と関
     数のモードを宣言するのに使われます。 ‘mode_declare’は、通常、 関数
     定義の始めやMaximaスクリプトの始めに置かれたり、対話プロンプトで実
     行されたりします。

     ‘mode_declare’の引数は、 変数とモードから成る対です。 モードは
     ‘boolean’, ‘fixnum’, ‘number’, ‘rational’, ‘float’のいずれか１つで
     す。 変数それぞれは、 同じモードを持つように宣言される変数すべての
     リストも取り得ます。

     もし変数が配列で、かつ、参照される配列のすべての要素が値を持つなら
     、 なら、
          array(yi, dim1, dim2, ...)
     よりむしろ‘array (yi, complete, dim1, dim2, …)’を 最初に配列のバイ
     ンドを宣言する時に使うべきです。 もし配列の要素すべてが モード
     ‘fixnum’ (‘float’)なら、 ‘complete’の代わりに‘fixnum’ (‘float’)を使
     ってください。 もし配列のすべての要素が同じモード―‘m’としましょう
     ―なら、 効率的な翻訳のためには、

          mode_declare (completearray (yi), m))

     を使うべきです。

     配列を使う数値コードは、例えば、10 x 10の浮動小数点配列のために

          mode_declare (completearray (a [10, 10]), float)

     というように、期待される配列サイズを宣言することでより速く実行され
     るかもしれません

     引数として‘function (f_1, f_2, ...)’を使うことで 関数の結果のモード
     を宣言することができます; ここで‘f_1’, ‘f_2’, …は関数名です。 例え
     ば、式

          mode_declare ([function (f_1, f_2, ...)], fixnum)

     は、 ‘f_1’, ‘f_2’, ...が返す値が1ワード整数であることを宣言します。

     ‘modedeclare’は‘mode_declare’と同義です。

 -- 関数: mode_identity (<arg_1>, <arg_2>)

     ‘mode_declare’と‘macros’で 例えば、flonumsのリストのリストや他の合
     成データオブジェクトを宣言するのに 使われる特殊形式。
     ‘mode_identity’の最初の引数は、‘mode_declare’に与えられるような プ
     リミティブな値モード名(すなわち、‘float’, ‘fixnum’, ‘number’,
     ‘list’, ‘any’のいずれか)であり、 二番目の引数は、評価され、
     ‘mode_identity’の値として返される式です。 しかしながら、もし戻り値
     が最初の引数で宣言されたモードによって許されていないなら、 エラーか
     警告がシグナルされます。 重要なことは、MaximaによってLisp翻訳器に命
     じた式のモードが、二番目の引数のなかで続く一切から独立して、最初の
     引数として与えられるそれだということです。 例えば、‘x: 3.3;
     mode_identity (fixnum, x);’はエラーをもたらします。 ‘mode_identity
     (flonum, x)’は3.3を返します。 これは多くの使い道があります。例えば
     、もし‘first (l)’が数を返すと知っていたなら、 ‘mode_identity
     (number, first (l))’と書くかもしれません。 しかしながら、それをする
     もっと効率的な方法は、

          firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));

     のように新しいプリミティブを定義し、 そして数のリストの最初の要素を
     取る時毎回‘firstnumb’を使うことです。

 -- 関数: remfunction (<f_1>, ..., <f_n>)
 -- 関数: remfunction (all)

     シンボル<f_1>, ..., <f_n>の関数定義をアンバインドします。 引数は、
     （‘:=’もしくは‘define’で生成された）通常の関数名もしくは（‘::=’で生
     成された）マクロ関数をとります。

     ‘remfunction (all)’は関数定義すべてをアンバインドします。

     ‘remfunction’は引数をクォートします。

     ‘remfunction’は、関数定義はアンバインドされたシンボルのリストを返し
     ます。 シンボルに関数定義がなければ、シンボルの代わりに‘false’を返
     します。

     ‘remfunction’は配列関数すなわち添字付き関数には適用されません。 こ
     れらのタイプの関数には‘remarray’を適用します。

 -- オプション変数: savedef
     デフォルト値: ‘true’

     ‘savedef’が‘true’の時、 関数が解釈される時に ユーザー関数のMaximaバ
     ージョンが保持されます。 これは、定義が‘dispfun’によって表示される
     ことを許し、 関数が編集されることを許します。

     ‘savedef’が‘false’の時、 解釈された関数の名前は、‘functions’リスト
     から取り除かれます。

 -- オプション変数: transcompile
     デフォルト値: ‘true’

     ‘transcompile’が‘true’の時、 ‘translate’と‘translate_file’は 翻訳コ
     ードをコンパイルにより適したものにする宣言を生成します。

     ‘compfile’は実行中‘transcompile: true’を設定します。

 -- 関数: translate (<f_1>, …, <f_n>)
 -- 関数: translate (functions)
 -- 関数: translate (all)

     ユーザー定義関数<f_1>, …, <f_n>をMaxima言語からLispに翻訳し、 Lisp翻
     訳を評価します。 通常、翻訳された関数は元の関数より速く実行されます
     。

     ‘translate (all)’や‘translate (functions)’は、 ユーザー定義関数すべ
     てを翻訳します。

     翻訳される関数は、 より効率的なコードを生成するために可能な時は 先
     頭に‘mode_declare’コールを含むべきです。 例えば:

          f (x_1, x_2, ...) := block ([v_1, v_2, ...],
              mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)

     ここで、<x_1>, <x_2>, ... は関数のパラメータであり、 <v_1>, <v_2>,
     ...はローカル変数です。

     もし‘savedef’が‘false’なら(以下を参照してください) 翻訳された関数の
     名前は、‘functions’リストから削除され、 ‘props’リストに加えられます
     。

     完全にデバッグされない限り、関数は翻訳すべきではありません。

     式は整理されていると仮定されます; もしされていないなら、厳密ですが
     、最適でないコードが生成されます。 従って、 ユーザーは ‘simp’スイッ
     チを‘false’―翻訳される式の整理を抑制します― に設定すべきではありま
     せん。

     スイッチ‘translate’は、もし‘true’なら、 ユーザー関数のLispへの自動
     翻訳をもたらします。

     LispとMaximaのバージョンの間である非互換性が存在する可能性があるの
     で、 翻訳された関数は 翻訳前にした方法を同一に動作するわけではない
     ことに注意してください。 原則として、 もし変数のいずれかが
     ‘mode_declare’された標準有理式(CRE)なら 複数の引数を取る‘rat’関数と
     ‘ratvars’関数は使うべきではありません。 また、 ‘prederror: false’設
     定は翻訳されません。

     ‘savedef’ - もし‘true’なら、 関数が‘translate’された時、Maximaバー
     ジョンのユーザー関数を残すようにします。 これは、定義を‘dispfun’で
     表示することを可能にし、 関数を編集することを可能にします。

     ‘transrun’ - もし‘false’なら、 すべての関数について、翻訳バージョン
     ではなく、 インタープリトされるバージョン(まだあると仮定して)が実行
     されるようにします。

     ‘translate’が返す結果は、翻訳された関数名のリストです。

 -- 関数: translate_file (<maxima_filename>)
 -- 関数: translate_file (<maxima_filename>, <lisp_filename>)

     MaximaコードのファイルをLispコードのファイルに翻訳します。
     ‘translate_file’は３つのファイル名のリストを返します: Maximaファイ
     ル名、Lispファイル名、翻訳についての追加情報を含むファイル名。
     ‘translate_file’は引数を評価します。

     ‘translate_file ("foo.mac"); load("foo.LISP")’は、 例えば、‘''’と
     ‘%’の利用といった若干の制約を除いて、 コマンド‘batch ("foo.mac")’と
     同じです。

     ‘translate_file (<maxima_filename>)’は Maximaファイル
     <maxima_filename>を 同様に名付けらたLispファイルに翻訳します。 例え
     ば、‘foo.mac’は‘foo.LISP’に翻訳されます。 Maximaのファイル名はディ
     レクトリ名を含むかもしれません。 その場合、Lisp出力ファイルは、
     Maxima入力が来たのと同じディレクトリに書かれます。

     ‘translate_file (<maxima_filename>, <lisp_filename>)’は、 Maximaフ
     ァイル<maxima_filename>をLispファイル<lisp_filename>に翻訳します。
     ‘translate_file’は、どんなものでも、‘lisp_filename’の ファイル名の
     拡張子を無視します; Lisp出力ファイルのファイル名の拡張子は、いつも
     ‘LISP’です。 Lispファイル名はディレクトリ名を含むかもしれません。 そ
     の場合、Lisp出力ファイルは指定されたディレクトリに書かれます。

     ‘translate_file’は、翻訳器のファイル 様々な度合いの厳しさの翻訳器警
     告メッセージのファイルも書き出します。 このファイルのファイル名拡張
     子は ‘UNLISP’です。 このファイルは、翻訳されたコードの中のバグを追
     跡するために、 あいまいかもしれませんが、価値ある情報を含むかもしれ
     ません。 ‘UNLISP’ファイルはいつもMaxima入力が来るのと同じディレクト
     リに書かれます。

     ‘translate_file’は Lispコードがコンパイルされるすぐに宣言や定義が効
     力を発揮するようにするLispコードを発行します。 このトピックに関して
     さらに知るには‘compile_file’を参照してください。

     ‘tr_array_as_ref’,
     ‘tr_bound_function_applyp’,
     ‘tr_exponent’,
     ‘tr_file_tty_messagesp’,
     ‘tr_float_can_branch_complex’,
     ‘tr_function_call_default’,
     ‘tr_numer’,
     ‘tr_optimize_max_loop’,
     ‘tr_semicompile’,
     ‘tr_state_vars’,
     ‘tr_warnings_get’,
     ‘tr_warn_bad_function_calls’,
     ‘tr_warn_fexpr’,
     ‘tr_warn_meval’,
     ‘tr_warn_mode’,
     ‘tr_warn_undeclared’,
     ‘tr_warn_undefined_variable’
     も参照してください。

 -- オプション変数: transrun
     デフォルト値: ‘true’

     ‘transrun’が‘false’の時、 すべての関数について、翻訳バージョンでは
     なく、 インタープリトされるバージョン(まだあると仮定して)が実行され
     るようにします。

 -- オプション変数: tr_array_as_ref
     デフォルト値: ‘true’

     もし‘translate_fast_arrays’が‘false’なら、 ‘translate_file’が発行す
     るLispコードの中の配列参照は、 ‘tr_array_as_ref’によって影響されま
     す。 ‘tr_array_as_ref’が‘true’の時、 配列名は評価されます。 そうで
     なければ、配列名は翻訳されたコードの中で文字リテラルとして現れます
     。

     もし‘translate_fast_arrays’が‘true’なら、 ‘tr_array_as_ref’は効果を
     持ちません。

 -- オプション変数: tr_bound_function_applyp
     デフォルト値: ‘true’

     ‘tr_bound_function_applyp’が‘true’の時、 もし(関数引数のような)バイ
     ンドされた変数が関数として使われていることが見つかったら Maximaは警
     告を与えます。 ‘tr_bound_function_applyp’は、 そんな場合に生成され
     たコードに影響しません。

     例えば、 ‘g (f, x) := f (x+1)’のような式は警告メッセージをトリガー
     します。

 -- オプション変数: tr_file_tty_messagesp
     デフォルト値: ‘false’

     ‘tr_file_tty_messagesp’が‘true’の時、 ファイルの翻訳中に
     ‘translate_file’が生成するメッセージがコンソールに表示され、
     ‘false’の時、ファイルの翻訳に関するメッセージは UNLISPファイルに挿
     入されるだけです。

 -- オプション変数: tr_float_can_branch_complex
     デフォルト値: ‘true’

     Maxima-to-Lisp翻訳器に translator to assume that 関数‘acos’,
     ‘asin’, ‘asec’, ‘acsc’が複素数の結果を返すことができることを仮定す
     るように命じます。

     ‘tr_float_can_branch_complex’の表面上の効果は以下の通りです。 しか
     しながら、このフラグは翻訳器出力上の効果を持ちません。

     ‘true’の時、 たとえ (‘mode_declare’が設定したように)‘x’がモード
     ‘float’でも ‘acos(x)’はモード‘any’です。 ‘false’の時、 ‘x’がモード
     ‘float’の時だけ ‘acos(x)’はモード‘float’です。

 -- オプション変数: tr_function_call_default
     デフォルト値: ‘general’

     ‘false’は、あきらめて‘meval’をコールすることを意味し、 ‘expr’は、引
     数が固定されたLisp関数を仮定することを意味します。 ‘general’、デフ
     ォルトは ‘mexprs’や‘mlexprs’にはよいが‘macros’にはよくないコードを
     与えます。 ‘general’は、コンパイルされたコードの中で変数バインドが
     正確であることを保証します。 ‘general’モードでは、 F(X)を翻訳する時
     、もしFがバインドされた変数なら、 ‘apply (f, [x])’を意味すると仮定
     され、適切な警告と合わせてそのように翻訳されます。 これをオフにする
     必要はありません。 デフォルト設定で警告メッセージがないことは、
     Maximaインタープリタと、翻訳、コンパイルされたコードの完全互換性を
     意味します。

 -- オプション変数: tr_numer
     デフォルト値: ‘false’

     ‘tr_numer’が‘true’の時、 ‘numer’プロパティは それらを持つアトム、例
     えば、‘%pi’に使われます。

 -- オプション変数: tr_optimize_max_loop
     デフォルト値: 100

     ‘tr_optimize_max_loop’は、 翻訳器のマクロ展開と最適化パスが形式を検
     討する際繰り返す最大回数です。 これはマクロ展開エラーや終了しない最
     適化プロパティをキャッチします。

 -- オプション変数: tr_semicompile
     デフォルト値: ‘false’

     ‘tr_semicompile’が‘true’の時、 ‘translate_file’と‘compfile’は、 マ
     クロ展開されたが、Lispコンパイラによって機械語にコンパイルされない
     形式を出力します。

 -- システム変数: tr_state_vars
     デフォルト値:
          [transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
          tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
          tr_function_call_default, tr_array_as_ref,tr_numer]

     翻訳された出力の形式に影響するスイッチのリスト。 翻訳器をデバッグし
     ようとする時 この情報はシステムの人たちに役に立ちます。 翻訳された
     生成物を与えられた状態で生成されるべきだったものと比較することによ
     って、 バグを追跡することが可能です。

 -- 関数: tr_warnings_get ()

     現在の翻訳の間に翻訳器が与える警告のリストを印字します。

 -- オプション変数: tr_warn_bad_function_calls
     デフォルト値: ‘true’

     - 翻訳時にされた不適切な宣言のせいで正確でないかもしれない関数コー
     ルが行われている時、 警告を与えます。

 -- オプション変数: tr_warn_fexpr
     デフォルト値: ‘compfile’

     - もしFEXPRに遭遇したら、警告を与えます。 FEXPRは、通常、翻訳コード
     の中で出力されるべきではありません。 合法で特殊なプログラム形式はす
     べて翻訳されます。

 -- オプション変数: tr_warn_meval
     デフォルト値: ‘compfile’

     - もし関数‘meval’がコールされたら、警告を与えます。 もし‘meval’がコ
     ールされたら、それは翻訳の中の問題を示します。

 -- オプション変数: tr_warn_mode
     デフォルト値: ‘all’

     - 変数がそのモードに不適切な値を割り当てられた時、警告を与えます。

 -- オプション変数: tr_warn_undeclared
     デフォルト値: ‘compile’

     - 未宣言変数についての警告をいつTTYに送るかを決めます。

 -- オプション変数: tr_warn_undefined_variable
     デフォルト値: ‘all’

     - 未定義のグローバル変数が見られた時、警告を与えます。

 -- 関数: compile_file (<filename>)
 -- 関数: compile_file (<filename>, <compiled_filename>)
 -- 関数: compile_file (<filename>, <compiled_filename>,
          <lisp_filename>)

     Maximaファイル<filename>をLispに翻訳し、Lispコンパイラを実行し、 も
     し翻訳とコンパイルが成功したら、コンパイルされたコードをMaximaにロ
     ードします。

     ‘compile_file’は４つのファイル名のリストを返します: 元のMaximaファ
     イル、Lisp翻訳、翻訳時ノート、コンパイルされたコード。 もしコンパイ
     ルが失敗したら、4番目の項目は‘false’です。

     Lispコードがコンパイルされると(コンパイルされたコードをロードするこ
     となしに)すぐに いくつかの宣言と定義は効力を発揮します。 これらは
     ‘:=’演算子で定義された関数、 ‘::=’演算子で定義されたマクロ、
     ‘alias’, ‘declare’, ‘define_variable’, ‘mode_declare’, ‘infix’,
     ‘matchfix’, ‘nofix’, ‘postfix’, ‘prefix’, ‘compfile’ を含みます。

     コンパイルされたコードがロードされるまで 割り当てと関数コールは評価
     されません。 特に、Maximaファイルの中で、 (‘tr_numer’, など)翻訳フ
     ラグへの割り当ては翻訳時に効果を持ちません。

     <filename>は‘:lisp’文を含むことができません。

     ‘compile_file’は引数を評価します。

 -- 関数: declare_translated (<f_1>, <f_2>, …)

     MaximaコードのファイルをLispに翻訳する時、 ファイルの中で見る関数が
     翻訳された関数としてコールされるか、コンパイルされた関数としてコー
     ルされるか、また、どの関数がMaxima関数か未定義なのか、翻訳器が知る
     ことは重要です。 この宣言をファイルの先頭に置くことは、 たとえまだ
     Lisp関数値を持たないシンボルがコール時にそれを持つだろうが、 それを
     知らせます。 ‘fn’がLisp関数になるつもりであることを翻訳器が知らない
     時、 ‘(MFUNCTION-CALL fn arg1 arg2 ...)’が生成されます。


File: maxima.info,  Node: Program Flow,  Next: Debugging,  Prev: Function Definition,  Up: Top

37 Program Flow
***************

* Menu:

* Lisp and Maxima::
* Garbage Collection::
* Introduction to Program Flow::  
* Functions and Variables for Program Flow::  


File: maxima.info,  Node: Lisp and Maxima,  Next: Garbage Collection,  Prev: Program Flow,  Up: Program Flow

37.1 Lisp and Maxima
====================

MaximaはLispで書かれており、 Lisp関数や変数をMaximaからアクセスしたり、
その逆が簡単にできます。 LispとMaximaのシンボルは命名の慣例で区別されま
す。 ドル記号‘$’で始まるLispシンボルは、ドル記号なしのMaximaシンボルに対
応します。 クエスチョンマーク‘?’で始まるMaximaシンボルは、クエスチョンマ
ークなしのLispシンボルに対応します。 例えば、Maximaシンボル‘foo’はLispシ
ンボル‘$FOO’に対応し、 Maximaシンボル‘?foo’はLispシンボル‘FOO’に対応しま
す。 ‘?foo’は、‘?’と‘foo’の間にスペースを入れずに書くことに注意してくだ
さい。でないと、それは‘describe ("foo")’に間違えられます。

   Lispシンボルの中に、ハイフン‘-’やアスタリスク‘*’、他の特殊文字があれ
ば、 Maximaのコードの中では、バックスラッシュ‘\’でエスケープしないといけ
ません。 例えば、Lispの識別子 ‘*foo-bar*’は、Maximaでは、
‘?\*foo\-bar\*’と書きます。

   Maximaセッションの中で、Lispコードを実行できます。 特殊コマンド
‘:lisp’を使って、 （１つか複数のフォームを含む）Lispの一行を実行できます
。例えば、

     (%i1) :lisp (foo $x $y)

は、Lisp関数‘foo’をMaxima変数‘x’, ‘y’を引数としてコールします。 ‘:lisp’構
成子は 対話プロンプトや‘batch’や‘demo’によって処理されるファイルの中で使
えますが、 ‘load’, ‘batchload’, ‘translate_file’, ‘compile_file’が 処理
するファイルの中では使えません。

   関数‘to_lisp()’を実行すると、対話的なLispセッションが始まります。
‘(to-maxima)’を入力すると、Lispセッションを終了してMaximaに戻ります。

   Lispの関数や変数を、Maximaで通常の関数名、変数名(特殊な句読点のない名
前)に見せるには、 Lispの名前をドル記号‘$’で始めなければなりません。

   Maximaでは、識別子の中の大文字、小文字が区別されます。 LispとMaximaの
間の名前変換を決めるルールがあります。

  1. 縦棒で囲まれていないLisp識別子は、Maximaの小文字の識別子に対応しま
     す。 Lisp識別子が大文字でも小文字でも混ざっていても無視されます。 例
     えば、Lispの‘$foo’や‘$FOO’、‘$Foo’はすべて Maximaの‘foo’に対応しま
     す。 でも、これはデフォルトで、 Lispリーダが‘$foo’, ‘$FOO’, ‘$Foo’を
     Lispシンボル‘$FOO’に変換するからです。
  2. すべて大文字かすべて小文字で、縦棒で囲まれたLisp識別子は、大文字小
     文字を逆にしたMaximaの識別子に対応します。 例えば、Lispの‘|$FOO|’,
     ‘|$foo|’はそれぞれ、Maximaの‘foo’, ‘FOO’に対応します。
  3. 大文字小文字が混ざっていて、縦棒で囲まれたLisp識別子は、そのまま
     Maximaの識別子に対応します。 例えば、Lispの‘|$Foo|’はMaximaの
     ‘Foo’に対応します。

   ‘#$’Lispマクロを使うと、Maximaの式をLispコードの中で使うことができま
す。 ‘#$<expr>$’はMaximaの式<expr>と同値なLispの式に展開されます。

     (msetq $foo #$[x, y]$)

これは以下のように入力するのと同じ効果です。

     (%i1) foo: [x, y];

Lisp関数‘displa’は、Maximaフォーマットで式を表示します。

     (%i1) :lisp #$[x, y, z]$
     ((MLIST SIMP) $X $Y $Z)
     (%i1) :lisp (displa '((MLIST SIMP) $X $Y $Z))
     [x, y, z]
     NIL

   Maximaで定義された関数は、通常のLisp関数ではありません。 Lisp関数
‘mfuncall’は、Maxima関数をコールします。 例えば:

     (%i1) foo(x,y) := x*y$
     (%i2) :lisp (mfuncall '$foo 'a 'b)
     ((MTIMES SIMP) A B)

   以下のLisp関数は、Maximaパッケージの中でシャドウされています。

   complement     continue      //
   float          functionp     array
   exp            listen        signum
   atan           asin          acos
   asinh          acosh         atanh
   tanh           cosh          sinh
   tan            break         gcd


File: maxima.info,  Node: Garbage Collection,  Next: Introduction to Program Flow,  Prev: Lisp and Maxima,  Up: Program Flow

37.2 Garbage Collection
=======================

数式処理は膨大なゴミ(最終的には使われない一時的な、もしくは中間の結果)を
生む傾向があり、 ゴミの効率的な取り扱いは、プログラムをうまく完了させる
ために非常に重要な場合があります。

   (SunOS 4.0やBSDの幾つかを含む)mprotectシステムコールが利用可能な
UNIXシステム 上でのGCLでは、階層化(stratified)ガーベッジコレクションが利
用可能です。 これは、ガーベッジコレクションを最近書き込まれたページに限
定します。 GCLドキュメントのALLOCATEやGBCを参照してください。 Lispレベル
で(setq si::*notify-gbc* t)を実行すると、どの領域がより多くの空間を必要
としているか決めるのに役立つでしょう。

   Maximaを走らせる他のLispについては、 そのLispのGCの制御の仕方に関する
ドキュメントを調べてください。


File: maxima.info,  Node: Introduction to Program Flow,  Next: Functions and Variables for Program Flow,  Prev: Garbage Collection,  Up: Program Flow

37.3 Introduction to Program Flow
=================================

Maximaは、 ‘go’のようなもっとプリミティブな構成子はもちろん、 繰り返しの
ために‘do’ループを提供します。


File: maxima.info,  Node: Functions and Variables for Program Flow,  Prev: Introduction to Program Flow,  Up: Program Flow

37.4 Functions and Variables for Program Flow
=============================================

 -- 関数: backtrace ()
 -- 関数: backtrace (<n>)

     コールスタック、すなわち、 現在アクティブな関数をコールした関数のリ
     スト、を印字します。

     ‘backtrace()’はコールスタック全体を印字します。

     ‘backtrace (<n>)’は、 現在アクティブな関数を含めて、<n>個の直近の関
     数を印字します。

     ‘backtrace’は、 (デバッグの文脈でだけでなく、) スクリプト、関数、対
     話プロンプトからコールすることができます。

     例:

        • ‘backtrace()’はコールスタック全体を印字します。

               (%i1) h(x) := g(x/7)$
               (%i2) g(x) := f(x-11)$
               (%i3) f(x) := e(x^2)$
               (%i4) e(x) := (backtrace(), 2*x + 13)$
               (%i5) h(10);
               #0: e(x=4489/49)
               #1: f(x=-67/7)
               #2: g(x=10/7)
               #3: h(x=10)
                                             9615
               (%o5)                         ----
                                              49

        • ‘backtrace (<n>)’は、 現在アクティブな関数を含めて、<n>個の直
          近の関数を印字します。

               (%i1) h(x) := (backtrace(1), g(x/7))$
               (%i2) g(x) := (backtrace(1), f(x-11))$
               (%i3) f(x) := (backtrace(1), e(x^2))$
               (%i4) e(x) := (backtrace(1), 2*x + 13)$
               (%i5) h(10);
               #0: h(x=10)
               #0: g(x=10/7)
               #0: f(x=-67/7)
               #0: e(x=4489/49)
                                             9615
               (%o5)                         ----
                                              49

 -- 特殊演算子: do

     ‘do’文は繰り返しを実行するために使われます。 その強力な一般性のため
     に、 ‘do’文は２編で記述されます。 最初、通常の形式が (Fortran,
     Algol, PL/I, など)いくつかの他のプログラミング言語の中で使われるそ
     れ との類似で与えられます; それから、他の特長が言及されます。

     この形式の、終了条件に関してだけ違う３つの別形があります。 それらは
     :

        • ‘for <variable>: <initial_value> step <increment> thru <limit>
          do <body>’
        • ‘for <variable>: <initial_value> step <increment> while
          <condition> do <body>’
        • ‘for <variable>: <initial_value> step <increment> unless
          <condition> do <body>’

     (代わりに、‘step’は終了条件や範囲の後与えられるかもしれません。)

     <initial_value>, <increment>, <limit>, <body>は、 任意の式を取り得
     ます。 もし増分が1なら、 "‘step 1’"は省略できます。

     ‘do’文の実行は、最初 <initial_value>を <variable> (今後、制御変数と
     呼びます) に割り当てることによって処理されます。 そして: (1) もし制
     御変数が ‘thru’指定の範囲を越えたら、もしくは、 ‘unless’の条件が
     ‘true’なら、 もしくは、 ‘while’の条件が ‘false’なら、 ‘do’は終了し
     ます。 (2) <body>が評価されます。 (3) 増分が制御変数に足されます。
     終了条件が満たされるまで、 いずれかが満たされる時 ‘do’が終了する複
     数の終了条件を与えることもできます。

     一般的に、 ‘thru’テストは、 もし <increment>が非負なら、制御変数が
     <limit>よりも大きい時、 または、もし <increment>が負なら、制御変数
     が <limit>よりも小さい時、 満たされます。 <increment>と <limit>は、
     この不等式が決定できる限り、数値でない式も取り得ます。 しかしながら
     、 ‘do’文が入力された時 <increment>が構文法的に負(例えば負の数)でな
     い限り、 Maximaは、 ‘do’が実行される時、正と仮定します。 もし正でな
     いなら、 ‘do’は適切に終了しないかもしれません。

     <limit>, <increment>, 終了条件は、ループを通して毎回評価されること
     に注意してください。 もしこれらのいずれかがおおくの計算を含み、
     <body>の実行中すべてで変わらない結果をもたらすなら、 ‘do’に先立って
     変数をそれらの値に設定し、その変数を ‘do’形式の中で使うことはもっと
     効率的です。

     ‘do’文が通常返す値は、アトム ‘done’です。 しかしながら、 早い時点で
     ‘do’から抜けて任意の望みの値を与えるために、 関数 ‘return’を
     <body>の中で使うことができます。 しかしながら、 ‘block’の中で起こる
     ‘do’の中の ‘return’は、 ‘do’だけから抜けて、 ‘block’からは抜けない
     ことに注意してください。 ‘do’から囲んでいる ‘block’に抜けるために、
     ‘go’関数は使えないことにも注意してください。

     制御変数はいつも ‘do’にローカルです。

     従って、 ‘do’の外側の同じ名前を持つ変数の値に影響することなく、任意
     の変数が使えます。 制御変数は、 ‘do’が終了した後、バインドされてい
     ません。

          (%i1) for a:-3 thru 26 step 7 do display(a)$
                                       a = - 3

                                        a = 4

                                       a = 11

                                       a = 18

                                       a = 25

          (%i1) s: 0$
          (%i2) for i: 1 while i <= 10 do s: s+i;
          (%o2)                         done
          (%i3) s;
          (%o3)                          55

     条件‘while i <= 10’は、 ‘unless i > 10’と、また、‘thru 10’と同値で
     あることに注意してください。

          (%i1) series: 1$
          (%i2) term: exp (sin (x))$
          (%i3) for p: 1 unless p > 7 do
                    (term: diff (term, x)/p,
                     series: series + subst (x=0, term)*x^p)$
          (%i4) series;
                            7    6     5    4    2
                           x    x     x    x    x
          (%o4)            -- - --- - -- - -- + -- + x + 1
                           90   240   15   8    2

     以上は、‘e^sin(x)’のTaylor級数の8項を与えます。

          (%i1) poly: 0$
          (%i2) for i: 1 thru 5 do
                    for j: i step -1 thru 1 do
                        poly: poly + i*x^j$
          (%i3) poly;
                            5      4       3       2
          (%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
          (%i4) guess: -3.0$
          (%i5) for i: 1 thru 10 do
                    (guess: subst (guess, x, 0.5*(x + 10/x)),
                     if abs (guess^2 - 10) < 0.00005 then return (guess));
          (%o5)                  - 3.162280701754386

     この例は、 Newton-Raphson反復を最大10回使って、 10の負の平方根を計
     算します。 もし収束基準が満たされないなら、 戻り値は‘done’になりま
     す。

     いつもある量を制御変数に加える代わりに、 繰り返しそれぞれで量をある
     他の方法で換えたい時があるかもしれません。 この場合、 ‘step
     <increment>’の代わりに ‘next <expression>’を使うことができます。 こ
     れは、ループの間、 制御変数が毎回<expression>の評価結果に設定される
     ようにします。

          (%i6) for count: 2 next 3*count thru 20 do display (count)$
                                      count = 2

                                      count = 6

                                     count = 18

     ‘for <variable>: <value> ...do...’の代わりとして、 構文法‘for
     <variable> from <value> ...do...’が使えます。 これは、 ‘from
     <value>’を ‘step’や‘next’値の後や終了条件の後に置くことを許します。
     もし‘from <value>’が省略されたら、 初期値として1が使われます。

     制御変数が実際には決して使われないような繰り返しを実行することに興
     味があることがあるかもしれません。 それゆえに、 貧弱な初期推測を使
     って5の平方根を計算する以下の例にあるように、 初期化と更新情報を省
     略して終了条件だけ与えることが許されます。

          (%i1) x: 1000$
          (%i2) thru 20 do x: 0.5*(x + 5.0/x)$
          (%i3) x;
          (%o3)                   2.23606797749979
          (%i4) sqrt(5), numer;
          (%o4)                   2.23606797749979

     もし望むなら、終了条件さえ完全に省略し、 無限に<body>を評価し続ける
     ‘do <body>’だけを与えることもできます。 この場合、関数‘return’が
     ‘do’の実行を終了するのに使われるべきです。

          (%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
                    do (y: ev(df), x: x - f(x)/y,
                        if abs (f (x)) < 5e-6 then return (x)))$
          (%i2) sqr (x) := x^2 - 5.0$
          (%i3) newton (sqr, 1000);
          (%o3)                   2.236068027062195

     (‘return’が実行された時、 ‘x’の現在値を ‘do’の値として返そうとする
     ことに注意してください。 ‘do’がブロックの最後の文なので、 ‘block’か
     ら抜けて、 ‘do’の値が ‘block’の値として返されます。)

     ‘do’のもう１つ別の形式がMaximaで利用可能です。構文法は:

          for <variable> in <list> <end_tests> do <body>

     <list>の要素は、 <body>の繰り返しのそれぞれで ‘variable’に連続的に
     割り当てられる任意の式です。 オプションの終了テスト<end_tests>は、
     ‘do’の実行を終了するのに使うことができます; そうでなければ、
     <list>が使い果たされた時、または、 <body>の中で ‘return’が実行され
     た時、 終了します。 (実際には、‘list’は非アトムの任意の式を取り得え
     て、連続的な部分が取られます。)

          (%i1)  for f in [log, rho, atan] do ldisp(f(1))$
          (%t1)                                  0
          (%t2)                                rho(1)
                                               %pi
          (%t3)                                 ---
                                                4
          (%i4) ev(%t3,numer);
          (%o4)                             0.78539816

 -- 関数: errcatch (<expr_1>, …, <expr_n>)

     <expr_1>, …, <expr_n>を１つずつ評価し、 もしエラーが起こらないなら
     、‘[<expr_n>]’ (リスト)を返します。 もしいずれかの引数の評価中にエ
     ラーが起こったら、 ‘errcatch’ はエラーが伝搬することを抑制し、 引数
     をこれ以上評価せずに空のリスト‘[]’を返します。

     ‘errcatch’は もしエラーがチャッチされないなら‘batch’を終了させるエ
     ラーが起こるかもしれないと疑うような ‘batch’ファイルで役立ちます。

 -- 関数: error (<expr_1>, ..., <expr_n>)
 -- システム変数: error

     <expr_1>, ..., <expr_n>を評価して印字します。 そして、エラーがあれ
     ば、トップレベルMaximaか直近の‘errcatch’に戻るようにします。

     変数‘error’はエラーを記述するリストに設定されます。 ‘error’の最初の
     要素はフォーマット文字列です。 引数<expr_1>, ..., <expr_n>の中の文
     字列すべてを結合したものです。 残りの要素は文字列でない引数の値です
     。

     ‘errormsg()’は‘error’をフォーマットし印字します。 これは直近のエラ
     ーメッセージを効果的に再印字します。

 -- オプション変数: error_size
     デフォルト値: 10

     ‘error_size’は、 現れる式のサイズに従って、エラーメッセージを変更し
     ます。 もし式のサイズが、Lisp関数‘ERROR-SIZE’によって決定されるよう
     に） ‘error_size’より大きいなら、 式は、メッセージの中で、シンボル
     で置き換えられ、 シンボルは式に割り当てられます。 シンボルはリスト
     ‘error_syms’から取られます。

     そうでなければ、式は‘error_size’より小さく、 メッセージの中に式が表
     示されます。

     ‘error’と‘error_syms’も参照してください。

     例:

     ‘U’のサイズは、‘ERROR-SIZE’で決められるように、24です。

          (%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

          (%i2) error_size: 20$

          (%i3) error ("Example expression is", U);

          Example expression is errexp1
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i4) errexp1;
                                      E
                                     D
                                    C   + B + A
          (%o4)                    --------------
                                   cos(X - 1) + 1
          (%i5) error_size: 30$

          (%i6) error ("Example expression is", U);

                                   E
                                  D
                                 C   + B + A
          Example expression is --------------
                                cos(X - 1) + 1
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- オプション変数: error_syms
     デフォルト値: ‘[errexp1, errexp2, errexp3]’

     エラーメッセージの中で、 ‘error_size’より大きな式はシンボルで置き換
     えられ、 シンボルは式に設定されます。 シンボルはリスト
     ‘error_syms’から取られます。 最初の大きすぎる式は、
     ‘error_syms[1]’で置き換えられ、 ２番目は、‘error_syms[2]’で置き換え
     られ、などなど。

     もし大きすぎる式が‘error_syms’の要素よりもあれば、 シンボルは自動的
     に構成されます。 <n>番目のシンボルは‘concat ('errexp, <n>)’と同値で
     す。

     ‘error’と‘error_size’も参照してください。

 -- 関数: errormsg ()

     直近のエラーメッセージを再印字します。 変数‘error’はメッセージを保
     持し、 ‘errormsg’はそれをフォーマットし印字します。

 -- オプション変数: errormsg
     デフォルト値: ‘true’

     ‘false’の時、エラーメッセージの出力は抑制されます。

     オプション変数‘errormsg’は ブロックの中でローカル値に設定することは
     できません。 ‘errormsg’のグローバル値が常に存在します。

          (%i1) errormsg;
          (%o1)                                true
          (%i2) sin(a,b);
          Wrong number of arguments to sin
           -- an error. To debug this try: debugmode(true);
          (%i3) errormsg:false;
          (%o3)                                false
          (%i4) sin(a,b);

           -- an error. To debug this try: debugmode(true);

     オプション変数‘errormsg’はブロックの中でローカル値に設定できません
     。

          (%i1) f(bool):=block([errormsg:bool],
                               print ("value of errormsg is",errormsg))$
          (%i2) errormsg:true;
          (%o2)                                true
          (%i3) f(false);
          value of errormsg is true
          (%o3)                                true
          (%i4) errormsg:false;
          (%o4)                                false
          (%i5) f(true);
          value of errormsg is false
          (%o5)                                false

 -- 特殊演算子: for

     繰り返しで使われます。 Maximaの繰り返し機能の記述に関しては、‘do’を
     参照してください。

 -- 関数: go (<tag>)

     制御を ‘go’の引数でタグ付けされたブロックの文に移すために ‘block’内
     部で使われます。 文をタグ付けするには、 その文の前に、 アトムの引数
     を ‘block’の中の別の文として 先行させてください。 例えば:

          block ([x], x:1, loop, x+1, ..., go(loop), ...)

     ‘go’の引数は、同じ‘block’の中に現れるタグの名前でなければいけません
     。 ‘go’を含む‘block’以外の‘block’の中のタグに移るために、 ‘go’を使
     うことはできません。

 -- 特殊演算子: if

     条件評価を表します。 ‘if’式の様々な形が認識されます。

     ‘if <cond_1> then <expr_1> else <expr_0>’ は、 もし<cond_1>が
     ‘true’評価されたら<expr_1>に*評*価*され、 そうでなければ式は
     <expr_0>に評価されます。

     コマンド ‘if <cond_1> then <expr_1> elseif <cond_2> then <expr_2>
     elseif ... else <expr_0>’は、 もし<cond_k>が‘true’、かつ、先行する
     条件がすべて‘false’なら、 <expr_k>に評価されます。 もし条件のいずれ
     も‘true’でないなら、式は‘expr_0’に評価されます。

     もし‘else’がないなら、 最後に‘else false’が仮定されます。 すなわち
     、コマンド ‘if <cond_1> then <expr_1>’は、 ‘if <cond_1> then
     <expr_1> else false’と同値で、 コマンド ‘if <cond_1> then <expr_1>
     elseif ... elseif <cond_n> then <expr_n>’は、 ‘if <cond_1> then
     <expr_1> elseif ... elseif <cond_n> then <expr_n> else false’と同値
     です。

     選択肢<expr_0>, …, <expr_n>は、任意のMaxima式を取り得ます。 入れ子
     の‘if’式もあり得ます。 選択肢は、 対応する条件が‘true’でない限り、
     整理も評価もされません。

     条件<cond_1>, ..., <cond_n>は、潜在的に、また、実際に ‘true’か
     ‘false’に評価される式です。 条件が実際には‘true’にも‘false’にも評価
     されない時、 ‘if’の振る舞いはグローバルフラグ‘prederror’で決定され
     ます。 ‘prederror’が‘true’の時、 もし評価された条件のいずれかが
     ‘true’にも‘false’にもならなかったら 、エラーになります。 そうでなけ
     れば、‘true’にも‘false’にも評価されない条件が受け入れられ、 結果は
     条件式になります。

     条件は以下のように、他の要素間の関係演算子と論理演算子からなります
     。

          演算                 シンボル     タイプ

          小なり                <           関係 中置
          以下                  <=          関係 中置
          等号 (構文法的)        =           関係 中置
          不等号 (構文法的)      #           関係 中置
          等号 (値)             equal       関係 関数
          不等号 (値)           notequal    関係 関数
          以上                  >=          関係 中置
          大なり                >           関係 中置
          かつ                  and         論理 中置
          または                or          論理 中置
          否定                  not         論理 前置

 -- 関数: map (<f>, <expr_1>, …, <expr_n>)

     ‘map’は、主演算子（訳注：内部表現の最上位階層のリストに対応する演算
     子）は 式<expr_1>, ..., <expr_n>のそれと同じ演算子を使い、 そのサブ
     パーツは、引数式の対応するサブパーツに<f>を適用した結果である式を返
     します。 <f>はn個の引数の関数名か、n個の引数のラムダ形式です。 (訳
     注：また、<expr_1>, …, <expr_n>は内部表現に階層リスト構造を持つ式で
     す。）

     ‘maperror’ - もし‘maperror’が‘fals’eなら、 マッピング関数のすべては
     、(1)もし<expr_i>のすべてが同じ長さでなければ、 最も短い<expr_i>が
     完了した時点で停止し、 (2)もし<expr_i>が同じタイプのオブジェクトで
     なければ、 <f>をリスト[<expr_1>, <expr_2>, ...]に適用します。 もし
     ‘maperror’が‘true’なら、上の２つの場合、エラーメッセージを出力しま
     す。

     この関数の用法の１つは、ある関数（例えば、‘partfrac’)を非常に長い式
     に適用する際、 計算の間にリスト保存領域を枯渇させるため式全体に適応
     するのが不可能な場合に、 それぞれの項に関数をマップすることです。

          (%i1) map(f,x+a*y+b*z);
          (%o1)                        f(b z) + f(a y) + f(x)
          (%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                                     1       1        1
          (%o2)                     ----- - ----- + -------- + x
                                   x + 2   x + 1          2
                                                   (x + 1)
          (%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                                1
          (%o3)                            y + ----- + 1
                                              x + 1
          (%i4) map("=",[a,b],[-0.5,3]);
          (%o4)                          [a = - 0.5, b = 3]


 -- 関数: mapatom (<expr>)

     <expr>がマップルーチンでアトムとして扱われる時だけ‘true’を返します
     。 "Mapatoms"はアトム、(有理数を含む)数、添字付き変数です。

 -- オプション変数: maperror
     デフォルト値: ‘true’

     ‘maperror’が‘false’の時は、 マップ関数すべてに、以下の例のようにさ
     せます。

          map (<f>, <expr_1>, <expr_2>, …)

     に対しては、 (1) もし<expr_i>のすべてが同じ長さでないなら、 最も短
     い<expr_i>の終わりまで完了した時、停止するようにさせ、 (2) もし
     <expr_i>すべてが同じタイプのオブジェクトでないなら、 <f>を
     [<expr_1>, <expr_2>, ...]に適用するようにさせます。

     もし‘maperror’が‘true’なら、 上の２つの例に関して、エラーメッセージ
     が表示されます。

 -- オプション変数: mapprint
     デフォルト値: ‘true’

     ‘mapprint’が‘true’の時、 ‘map’, ‘mapl’, ‘fullmap’からの様々な情報メ
     ッセージが 一定の状況で生成されます。 これらは ‘map’が‘apply’を使っ
     たり、‘map’が 最短のリストで切り詰めているような状況を含みます。

     もし‘mapprint’が‘false’なら、これらのメッセージは抑制されます

 -- 関数: maplist (<f>, <expr_1>, …, <expr_n>)
     式<expr_1>, …, <expr_n>のパーツに<f>を適用した結果のリストを返しま
     す。 <f>は、関数名かラムダ式です。

     ‘maplist’は‘map (<f>, <expr_1>, ..., <expr_n>)’とは違います。 mapは
     主演算子が<expr_i>と同じ式を返します。 (整理と‘map’が‘apply’を行う
     場合は例外です。)

 -- オプション変数: prederror
     デフォルト値: ‘false’

     ‘prederror’が‘true’の時、 ‘if’文の述語論理か‘is’関数が ‘true’か
     ‘false’に評価されるのに失敗した時はいつでも エラーメッセージが表示
     されます。

     もし‘false’なら、この場合，代わりに‘unknown’が返されます。
     ‘prederror: false’モードは翻訳コードではサポートされません; しかし
     ながら、‘maybe’は翻訳コードでサポートされます。

     ‘is’と‘maybe’も参照してください。

 -- 関数: return (<value>)
     引数を連れて、陽にブロックから抜けるために使われます。 もっと情報を
     知るには、‘block’も参照してください。

 -- 関数: scanmap (<f>, <expr>)
 -- 関数: scanmap (<f>, <expr>, bottomup)
     トップダウン法で、<f>を<expr>に再帰的に適用します。 完全な因数分解
     が望まれる時、これは最も役に立ちます。 例えば:

          (%i1) exp:(a^2+2*a+1)*y + x^2$
          (%i2) scanmap(factor,exp);
                                              2      2
          (%o2)                         (a + 1)  y + x

     Note the way in which ‘scanmap’が与えられた関数‘factor’を <expr>の
     構成部分式に適用する方法に注意してください; もし <expr>の別の形が
     scanmapに適用されるなら、結果は異なるかもしれません。 従って、
     ‘scanmap’が ‘exp’の展開形に適用される時、 ‘%o2’が再現されません:

          (%i3) scanmap(factor,expand(exp));
                                     2                  2
          (%o3)                      a  y + 2 a y + y + x

     ‘scanmap’が 与えられた関数を指数関数を含む部分式すべてに再帰的に適
     用する方法の別の例です:

          (%i4) expr : u*v^(a*x+b) + c$
          (%i5) scanmap('f, expr);
                              f(f(f(a) f(x)) + f(b))
          (%o5) f(f(f(u) f(f(v)                      )) + f(c))

     ‘scanmap (<f>, <expr>, bottomup)’は、 ボトムアップ法で <f>を
     <expr>に適用します。 例えば、未定義‘f’に関して、

          scanmap(f,a*x+b) ->
             f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
          scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
              -> f(f(a)*f(x))+f(b) ->
               f(f(f(a)*f(x))+f(b))

     この場合、両方の方法で同じ答えを得ます。

 -- 関数: throw (<expr>)

     <expr>を評価し、 直近の‘catch’に値を投げ戻します。 ‘throw’は、
     ‘catch’と一緒に、非ローカルリターンメカニズムとして使われます。

 -- 特殊演算子: while
 -- 特殊演算子: unless
     ‘do’を参照してください。

 -- 関数: outermap (<f>, <a_1>, …, <a_n>)

     関数<f>を 外積<a_1>掛ける<a_2> ... 掛ける<a_n>の要素のそれぞれに適
     用します。

     <f>は n個の引数の関数の名前か、 n個の引数のラムダ式 です。

     それぞれの引数<a_k>は、 リストか、入れ子のリストか、行列か、他の任
     意の種類の式を取り得ます。

     ‘outermap’戻り値は、入れ子の構造です。 <x>を戻り値とします。 すると
     、 <x>は最初のリストか入れ子のリストか行列引数と同じ構造を持ち、
     ‘<x>[i_1]...[i_m]’は、 二番目のリストか入れ子のリストか行列引数と同
     じ構造を持ち、 ‘<x>[i_1]...[i_m][j_1]...[j_n]’は、 三番目のリストか
     入れ子のリストか行列引数と同じ構造を持ち、 以下同様。 ここで、<m>,
     <n>, ...は、 引数それぞれの要素 をアクセスするために要求される イン
     デックスの数(リストには１つ、行列には２つ、入れ子のリストには１つ以
     上)です。 リストや行列でない引数は戻り値の構造に影響を与えません。

     Note that the effect of ‘outermap’の効果は <f>を
     ‘cartesian_product’によって返される 外積の要素のそれぞれに適用する
     ことのそれと違います。

     ‘outermap’は、戻り値で引数の構造を保ちますが、 ‘cartesian_product’は
     違います。

     ‘outermap’は引数を評価します。

     ‘map’, ‘maplist’, ‘apply’も参照してください。

     例:

     ‘outermap’の初等的な例。 よりはっきり引数の組み合わせを示すために、
     ‘F’は未定義のままです。

          (%i1) outermap(F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) outermap(F, matrix([a, b],[c, d]), matrix([1, 2],[3, 4]));
                   [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
          (%o2)    [                                            ]
                   [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
                   [ [                  ]  [                  ] ]
                   [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
          (%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
                 [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
          (%o3) [[                        ], [                        ]]
                 [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
          (%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
                 [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
          (%o4) [[ [            ]  [            ] ],
                 [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                                        [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                                        [ [            ]  [            ] ]]
                                        [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
          (%i5) outermap ("+", [a, b, c], [1, 2, 3]);
          (%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3],
                                                     [c + 1, c + 2, c + 3]]

     ‘outermap’の戻り値のより密な検査。 最初の、二番目の、三番目の引数は
     、それぞれ、行列、リスト、行列です。 戻り値は行列です。 その行列の
     要素それぞれはリストで、 それぞれのリストの要素それぞれは行列です。

          (%i1) arg_1 :  matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) arg_2 : [11, 22];
          (%o2)                       [11, 22]
          (%i3) arg_3 : matrix ([xx, yy]);
          (%o3)                      [ xx  yy ]
          (%i4) xx_0 : outermap(lambda([x, y, z], x / y + z), arg_1,
                                                             arg_2, arg_3);
                         [  [      a        a  ]  [      a        a  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
          (%o4)  Col 1 = [                                              ]
                         [  [      c        c  ]  [      c        c  ]  ]
                         [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                         [  [      11       11 ]  [      22       22 ]  ]
                           [  [      b        b  ]  [      b        b  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
                   Col 2 = [                                              ]
                           [  [      d        d  ]  [      d        d  ]  ]
                           [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                           [  [      11       11 ]  [      22       22 ]  ]
          (%i5) xx_1 : xx_0 [1][1];
                     [      a        a  ]  [      a        a  ]
          (%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
                     [      11       11 ]  [      22       22 ]
          (%i6) xx_2 : xx_0 [1][1] [1];
                                [      a        a  ]
          (%o6)                 [ xx + --  yy + -- ]
                                [      11       11 ]
          (%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                            a
          (%o7)                        xx + --
                                            11
          (%i8) [op (arg_1), op (arg_2), op (arg_3)];
          (%o8)                  [matrix, [, matrix]
          (%i9) [op (xx_0), op (xx_1), op (xx_2)];
          (%o9)                  [matrix, [, matrix]

     ‘outermap’は、戻り値の中で引数の構造を保持します。
     ‘cartesian_product’は保持しません。

          (%i1) outermap (F, [a, b, c], [1, 2, 3]);
          (%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)],
                                               [F(c, 1), F(c, 2), F(c, 3)]]
          (%i2) setify (flatten (%));
          (%o2) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i3) map(lambda([L], apply(F, L)),
                               cartesian_product({a, b, c}, {1, 2, 3}));
          (%o3) {F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3),
                                                 F(c, 1), F(c, 2), F(c, 3)}
          (%i4) is (equal (%, %th (2)));
          (%o4)                         true


File: maxima.info,  Node: Debugging,  Next: asympa,  Prev: Program Flow,  Up: Top

38 Debugging
************

* Menu:

* Source Level Debugging::
* Keyword Commands::
* Functions and Variables for Debugging::   


File: maxima.info,  Node: Source Level Debugging,  Next: Keyword Commands,  Up: Debugging

38.1 Source Level Debugging
===========================

Maximaは、組み込みのソースレベルデバッガを持っています。 ユーザーは、関
数にブレイクポイントを設定でき、 そこから行毎に実行することができます。
そのレベルでバインドされた変数と一緒にコールスタックを検査することができ
ます。

   コマンド‘:help’または‘:h’は、 デバッガーコマンドのリストを示します。
(一般的に、 もし略字がただ１つなら、コマンドは略せます。 もしただ１つで
ないなら、選択肢がリストされます。) デバッガー内では、 変数と式を検査し
、定義し、操作するために、ユーザーは任意の通常のMaxima関数も使うことがで
きます。

   Maximaプロンプトで、 ‘:br’コマンドで ブレイクポイントが設定できます。
デバッガー内では、 ユーザーは、 ‘:n’ (“next”)コマンドを使って１度に１行
進むことができます。 ‘:bt’ (“backtrace”)コマンドは、スタックフレームのリ
ストを示します。 ‘:r’ (“resume”)コマンドは、デバッガーから抜けて、実行を
続けます。 以下の例で、これらのコマンドを例示します。

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                        <-- :bt typed here gives a backtrace
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                         <-- Here type :n to advance line
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                         <-- Investigate value of u
     28

     (dbm:1) u: 33;                     <-- Change u to be 33
     33

     (dbm:1) :r                         <-- Type :r to resume the computation

     (%o2)                                1094

   ファイル‘/tmp/foobar.mac’は以下の通りです:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   EMACSを通してのデバッガーの使用

   もしユーザーがシェルウィンドウ(dblシェル)で、GNU emacsの下でコードを
走らせているか、 グラフィカルならインターフェイスバージョンXmaximaを走ら
せているなら、 もしブレイクポイントで停止させたら、 ウィンドウの他の半面
に表示されるソースファイルの中に、 赤でハイライトされたか、右行を示す小
さな矢印で 現在位置を見るでしょう。 M-n (Alt-n)をタイプすることで、一度
に一行進めることができます。

   Emacsの下では、 ‘dbl’シェルの中で走らせなければいけません。 ‘dbl’シェ
ルは、elispディレクトリの中に ‘dbl.el’ファイルを要求します。 elispファイ
ルをインストールしたか、Maxima elispディレクトリをパスに足したかを確認し
てください: 例えば、以下を ‘.emacs’ファイルか‘site-init.el’に足してくだ
さい。

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   すると、emacsの中で、

     M-x dbl

   は、例えば、Maxima, gcl, gbbなどのプログラムを走らせることができるシ
ェルウィンドウを開始するでしょう。 このシェルウィンドウはソースレベルデ
バッグや 他のウィンドウのソースコードの表示についても知っています。

   ユーザーは、 ‘C-x space’をタイプすることで ファイルのある行に ブレイ
クポイントを設定できます。 これは、カーソルがどの関数の中かがわかり、 カ
ーソルが示すその関数のどの行かわかります。 もしカーソルが、例えば、
‘foo’の行2なら、 ‘foo’を二番目の行でブレイクするために、 他のウィンドウ
の中で、コマンド“‘:br foo 2’”を挿入します。 これをイネーブルにするには、
ユーザーは ファイル‘foobar.mac’が訪れるウィンドウの中で maxima-mode.elを
機能させなければいけません。 ‘Alt-Control-x’をタイプすることで 関数を
Maximaに評価ような、 そのファイルウィンドウで利用可能な追加のコマンドが
あります。


File: maxima.info,  Node: Keyword Commands,  Next: Functions and Variables for Debugging,  Prev: Source Level Debugging,  Up: Debugging

38.2 Keyword Commands
=====================

キーワードコマンドは、Maxima式として解釈(interpret)されない特殊キーワー
ドです。 キーワードコマンドは、ブレイクプロンプトではできませんが、
Maximaプロンプトやデバッガープロンプトで入力できます。 キーワードコマン
ドはコロン’‘:’’で始まります。 例えば、Lisp形を評価するには、 may type
‘:lisp’の後に評価される形式をタイプします。

     (%i1) :lisp (+ 2 3)
     5

   取られる引数の数は、特定のコマンドに依存します。 コマンド全体をタイプ
する必要はありません、ただブレイクキーワードの中で唯一であれば十分です。
例えば、‘:br’は ‘:break’のために十分です。

   キーワードコマンドは以下にリストされます。

‘:break F n’
     関数‘F’の中に関数の頭から行オフセット‘n’で ブレイクポイントを設定し
     ます。 もし‘F’が文字列として与えられたら、 ファイルと仮定され、
     ‘n’はファイルの頭からのオフセットです。 オフセットはオプションです
     。 もし与えられないなら、ゼロと仮定されます。 (関数かファイルの最初
     の行。)
‘:bt’
     スタックフレームのバックトレイスを印字します。
‘:continue’
     計算を継続します。
‘:delete’
     指定されたブレイクポイントを、もし指定されないならすべてのブレイク
     ポイントを削除します。
‘:disable’
     指定されたブレイクポイントを、もし指定されないならすべてのブレイク
     ポイントをディセーブルにします。
‘:enable’
     指定されたブレイクポイントを、もし指定されないならすべてのブレイク
     ポイントをイネーブルにします。
‘:frame n’
     スタックフレーム‘n’を、もし指定されないなら現在のフレームを印字しま
     す。
‘:help’
     デバッガーコマンドに関するヘルプを印字します。 もし指定されないなら
     、コマンドすべてのヘルプを印字します。
‘:info’
     項目についての情報を印字します。
‘:lisp some-form’
     ‘some-form’をLisp形式として評価します。
‘:lisp-quiet some-form’
     Lisp形式‘some-form’を出力せずに評価します。
‘:next’
     ‘:next’は関数コールをステップオーバーする点を除いて、 ‘:step’のよう
     なものです。
‘:quit’
     計算を完了せずに、 現在のデバッガーレベルから抜けます。
‘:resume’
     計算を継続します。
‘:step’
     新しいソー行に至るまで計算を継続します。
‘:top’
     計算を完了せずに(任意のデバッガーレベルから)Maximaプロンプトに戻り
     ます。


File: maxima.info,  Node: Functions and Variables for Debugging,  Prev: Keyword Commands,  Up: Debugging

38.3 Functions and Variables for Debugging
==========================================

 -- オプション変数: debugmode
     デフォルト値: ‘false’

     もし‘debugmode’が ‘true’なら、 Maximaのエラーが起こった時Maximaはデ
     バッガーを開始します。 ユーザーはコールバックを検査したり、ブレイク
     ポイントを設定したり、Maximaコードをステップ実行したりなど コマンド
     を入力することができます。 デバッガーコマンドのリストに関しては、
     ‘debugging’を参照してください。

     ‘debugmode’をイネーブルにしても、Lispのエラーは捕らえられません。

 -- オプション変数: refcheck
     デフォルト値: ‘false’

     ‘refcheck’が‘true’の時、 Maximaは 計算の中で、バイドされた変数が最
     初に使われる度にメッセージを印字します。

 -- オプション変数: setcheck
     デフォルト値: ‘false’

     もし‘setcheck’が(添字付きでもよい)変数のリストに設定されているなら
     、 Maximaは 変数またはそれらの添字付き出現が通常の割り当て演算子
     ‘:’、‘::’割り当て演算子、 または関数引数バインドでバインドされた時
     (しかし関数割り当て‘:=’やマクロ割り当て‘::=’演算子でバインドされた
     時以外) はいつでも、 メッセージを印字します。 メッセージは変数名と
     バインドされた値から構成されます。

     ‘setcheck’は、 ‘all’または‘true’に設定することができ、 それによって
     、すべての変数を含みます。

     ‘setcheck’の新しい要素のそれぞれは、 チェックする変数の新しいリスト
     を確立し、 以前‘setcheck’に割り当てられたいかなる変数も忘れられます
     。

     もし自身以外の何かに評価されるなら、 ‘setcheck’に割り当てられた名前
     はクォートしなければいけません。 例えば、もし‘x’, ‘y’, ‘z’が既にバ
     インドされているなら、 チェックする変数のリストに置くには、

          setcheck: ['x, 'y, 'z]$

     をタイプしてください。

     ‘setcheck’リスト上の変数が、例えば、‘X: 'X’のように、 それ自身に割
     り当てられた時は、なにも印字されません。

 -- オプション変数: setcheckbreak
     デフォルト値: ‘false’

     ‘setcheckbreak’が‘true’の時、 ‘setcheck’リスト上の変数が新しい値を
     割り当てられた時はいつでも Maximaはブレイクプロンプトを出します。 ブ
     レイクは、割り当てが実行される前に起こります。 この時点で、
     ‘setval’が変数が割り当てられようとしている値を保持します。 ゆえに、
     ‘setval’に割り当てることで、違う値を割り当てることができます。

     ‘setcheck’と‘setval’も参照してください。

 -- システム変数: setval

     ‘setcheckbreak’が起こった時、変数が設定されようとしている値を保持し
     ます。 ゆえに、 ‘setval’に割り当てることで、違う値を割り当てること
     ができます。

     ‘setcheck’と‘setcheckbreak’も参照してください。

 -- 関数: timer (<f_1>, …, <f_n>)
 -- 関数: timer (all)
 -- 関数: timer ()

     ‘timer’は、 タイミング統計が収集される関数のリストに与えられた関数
     <f_1>, …, <f_n> それぞれを入れます。 ‘timer(f)$ timer(g)$’は、リス
     トに‘f’を入れ、その後‘g’を入れます; リストはあるコールから次へ累積
     されます。

     ‘timer(all)’は、計測される関数のリストに (グローバル変数
     ‘functions’で指名されたように) ユーザー定義関数すべてを入れます。

     引数なしでは、 ‘timer’は計測される関数のリストを返します。

     Maximaは、計測される関数のリストに関して、 関数それぞれを実行するの
     に費やされる時間を記録します。 ‘timer_info’は、タイミング統計を返し
     ます。 関数コール毎に経過した平均時間、コール回数、総経過時間を含み
     ます。 ‘untimer’は、計測される関数のリストから関数を削除します。

     ‘timer’は引数をクォートします。 ‘f(x) := x^2$ g:f$ timer(g)$’は、
     ‘f’をタイマーリストに入れません。

     もし‘trace(f)’が有効なら、‘timer(f)’は有効ではないです; ‘trace’と
     ‘timer’が同時に有効にはできません。

     ‘timer_devalue’も参照してください。

 -- 関数: untimer (<f_1>, …, <f_n>)
 -- 関数: untimer ()

     ‘untimer’はタイマーリストから 与えられた関数<f_1>, …, <f_n>それぞれ
     を削除します。

     引数なしの時、 ‘untimer’は、現在、タイマーリスト上の関数すべてを削
     除します。

     ‘untimer (f)’が実行された後、 ‘timer_info()’ (引数なし)は、 現在タ
     イマーリスト上にない関数についての情報を返しませんけれども、
     ‘timer_info (f)’は、まだ以前に集計されたタイミング統計を返します。
     ‘timer (f)’は、 タイミング統計すべてをゼロに再設定し、 ‘f’をタイマ
     ーリストに再び入れます。

 -- オプション変数: timer_devalue
     デフォルト値: ‘false’

     ‘timer_devalue’が‘true’の時、 Maximaは、計られる関数から 他の計測さ
     れる関数で費やされた時間を引きます。 そうでなければ、関数それぞれに
     ついて報告された時間は、 他の関数で計測される時間を含みます。 計測
     されない関数で費やされた時間は、総時間から引かれないことに注意して
     ください。

     ‘timer’と‘timer_info’も参照してください。

 -- 関数: timer_info (<f_1>, ..., <f_n>)
 -- 関数: timer_info ()

     与えられた関数<f_1>, ..., <f_n>, ‘timer_info’は、 関数それぞれのタ
     イミング情報を含む 行列を返します。 引数なしでは、 ‘timer_info’は、
     現在タイマーリスト上の関数すべてについての タイミング情報を返します
     。 The matrix returned by ‘timer_info’が返す行列は、関数名、 関数コ
     ール毎の時間、関数コールの回数、総時間、 ‘gctime’ を含みます。
     ‘gctime’は、元のMacymaの「ガーベッジコレクション時間」を意味しまし
     たが、 今はいつもゼロです。

     ‘timer_info’が戻り値を構成するデータは、 ‘get’関数によっても得られ
     ることができます:

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     ‘timer’も参照してください。

 -- 関数: trace (<f_1>, …, <f_n>)
 -- 関数: trace (all)
 -- 関数: trace ()

     関数 <f_1>, …, <f_n>が与えられたとして、 ‘trace’は、Maximaに、 それ
     らの関数がコールされたときはいつでも デバッグ情報を印字するよう指示
     します。 ‘trace(f)$ trace(g)$’は、トレースする関数のリストに ‘f’を
     、それから‘g’を入れます; リストは１回のコールから次へ累積します。

     ‘trace(all)’は、(グローバル変数‘functions’で指名されたように) ユー
     ザー定義関数すべてをトレースする関数のリストに入れます。

     引数なしでは、 ‘trace’は、現在とレースする関数すべてのリストを返し
     ます。

     ‘untrace’関数はトレースをディセーブルします。 ‘trace_options’も参照
     してください。

     ‘trace’は引数をクォートします。 例えば、 ‘f(x) := x^2$ g:f$
     trace(g)$’は、 ‘f’をトレースリストに入れません。

     関数が再定義された時、 タイマーリストから削除されます。 例えば、
     ‘timer(f)$ f(x) := x^2$’の後、 関数‘f’はもはやタイマーリストにあり
     ません。

     もし‘timer (f)’が有効なら、 ‘trace (f)’は有効ではありません;
     ‘trace’と‘timer’は、同じ関数で同時には有効にできません。

 -- 関数: trace_options (<f>, <option_1>, …, <option_n>)
 -- 関数: trace_options (<f>)

     関数<f>についてトレースオプションを設定します。 いかなる以前のオプ
     ションも破棄されます。 ‘trace_options (<f>, ...)’は、 もし
     (‘trace_options’の前でも後でも).  ‘trace (<f>)’もコールされないなら
     、 有効になりません。

     ‘trace_options (<f>)’は、 オプションすべてをデフォルト値に再設定し
     ます。

     オプションキーワードは以下の通りです:

        • ‘noprint’ 関数の入り口と出口でメッセージを印字しません。
        • ‘break’ 関数に入る前と関数を抜けた後、ブレイクポイントを置きま
          す。 ‘break’を参照してください。
        • ‘lisp_print’ 引数を表示し、Lispオブジェクトとして値を返します
          。
        • ‘info’ 関数の入れ口と出口で‘-> true’を印字します
        • ‘errorcatch’ エラーをチャッチし、 エラーを知らせるためのオプシ
          ョンに応じて、 関数コールを再試行するか、戻り値を指定します。

     トレースオプションは、２つの形式で指定されます。 オプションキーワー
     ド単体の存在は、 オプションを無条件に実行します。 (‘<foo>: true’か
     似た形式を指定することでは、 オプション<foo>は実行されないことに注
     意してください; キーワードはクォートする必要はないことにも注意して
     ください。) オプションキーワードを述語論理関数で指定することは、 オ
     プションを述語論理上の条件付きにします。

     述語論理関数の引数リストは、いつも ‘[level, direction, function,
     item]’です。 ここで、‘level’は関数の再帰レベルで、 ‘direction’は
     ‘enter’か‘exit’、‘function’は、 関数名、 name of the function, and
     ‘item’は(入るときの)引数リストか(出るときの)戻り値です。

     以下は無条件とレースオプションの例です:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     以下は述語論理上の条件の‘break’オプションを持つ同じ関数です:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);

 -- 関数: untrace (<f_1>, …, <f_n>)
 -- 関数: untrace ()

     ‘untrace’は、 与えられた関数<f_1>, …, <f_n>について、 ‘trace’関数で
     イネーブルされたトレースをディセーブルします。 引数なしでは、
     ‘untrace’は関数すべてのトレースをディセーブルします。

     ‘untrace’はトレースをディセーブルした関数のリストを返します。


File: maxima.info,  Node: asympa,  Next: augmented_lagrangian,  Prev: Debugging,  Up: Top

39 asympa
*********

* Menu:

* Introduction to asympa::
* Functions and variables for asympa::


File: maxima.info,  Node: Introduction to asympa,  Next: Functions and variables for asympa,  Prev: asympa,  Up: asympa

39.1 Introduction to asympa
===========================

 -- 関数: asympa
     ‘asympa’は漸近解析パッケージです。 パッケージは、 複雑性解析と数値
     解析で広く使われている“ビッグO”と“リトルo”関数を含む、 漸近解析のた
     めの式整理関数を含みます。

     ‘load ("asympa")’はこのパッケージをロードします。


File: maxima.info,  Node: Functions and variables for asympa,  Prev: Introduction to asympa,  Up: asympa

39.2 Functions and variables for asympa
=======================================


File: maxima.info,  Node: augmented_lagrangian,  Next: Bernstein,  Prev: asympa,  Up: Top

40 augmented_lagrangian
***********************

* Menu:

* Functions and Variables for augmented_lagrangian::


File: maxima.info,  Node: Functions and Variables for augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

40.1 Functions and Variables for augmented_lagrangian
=====================================================

 -- 関数: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>)
 -- 関数: augmented_lagrangian_method (<FOM>, <xx>, <C>, <yy>,
          optional_args)
 -- 関数: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>, <yy>)
 -- 関数: augmented_lagrangian_method ([<FOM>, <grad>], <xx>, <C>, <yy>,
          optional_args)

     ゼロに等しい制約<C>を保ちながら、 式<FOM>の変数<xx>に関する近似最小
     を返します。 <yy>は <xx>の初期推量のリストです。 利用した方法は拡張
     Lagrange法です。(文献[1]と[2]を参照してください。)

     もしあるなら、<grad>は <FOM>の<xx>に関するグラディエントであり、
     <xx>の変数それぞれに関する式のリストとして表されます。 もしないなら
     、グラディエントは自動的に構成されます。

     <FOM>と、もしあるなら<grad>の要素それぞれは、 関数名やラムダ式では
     なく、通常の式でなければいけません。

     ‘optional_args’は、 ‘<symbol> = <value>’として指定される、 追加の引
     数を表します。 認識されるオプション引数は以下の通りです:

     ‘niter’
          拡張Lagrangeアルゴリズムの繰り返しの回数
     ‘lbfgs_tolerance’
          LBFGSに供給される許容誤差
     ‘iprint’
          LBFGSに供給される IPRINTパラメータ(メッセージ出力を制御する２
          つの整数のリスト)
     ‘%lambda’
          拡張Lagrangeを計算するために使われる ‘%lambda’の初期値

     この実装は 擬似Newtonアルゴリズムであるメモリ制限付きBFGS (LBFGS)ア
     ルゴリズムを適用することで 拡張Lagraneを最小化します。

     ‘load("augmented_lagrangian")’はこの関数をロードします。

     ‘lbfgs’も参照してください。

     参考文献:

     [1]
     <http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html>

     [2] <http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf>

     例:

          (%i1) load ("lbfgs");
          (%o1)     /maxima/share/lbfgs/lbfgs.mac
          (%i2) load ("augmented_lagrangian");
          (%o2)
             /maxima/share/contrib/augmented_lagrangian.mac
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) xx: [x, y];
          (%o4)                        [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                      [y + x - 1]
          (%i6) yy: [1, 1];
          (%o6)                        [1, 1]
          (%i7) augmented_lagrangian_method(FOM, xx, C, yy, iprint=[-1,0]);
          (%o7) [[x = 0.66665984108002, y = 0.33334027245545],
                                           %lambda = [- 1.333337940892525]]

     前と同じ例ですが、今回は グラディエントが引数として供給されます。

          (%i1) load ("lbfgs")$
          (%i2) load ("augmented_lagrangian")$
          (%i3) FOM: x^2 + 2*y^2;
                                         2    2
          (%o3)                       2 y  + x
          (%i4) FOM: x^2 + 2*y^2;
                                         2    2
          (%o4)                       2 y  + x
          (%i5) xx: [x, y];
          (%o5)                        [x, y]
          (%i6) grad : [2*x, 4*y];
          (%o6)                      [2 x, 4 y]
          (%i7) C: [x + y - 1];
          (%o7)                      [y + x - 1]
          (%i8) yy: [1, 1];
          (%o8)                        [1, 1]
          (%i9) augmented_lagrangian_method ([FOM, grad], xx, C, yy,
                                             iprint = [-1, 0]);
          (%o9) [[x = 0.666659841080025, y = .3333402724554462],
                                           %lambda = [- 1.333337940892543]]


File: maxima.info,  Node: Bernstein,  Next: bode,  Prev: augmented_lagrangian,  Up: Top

41 Bernstein
************

* Menu:

* Functions and Variables for Bernstein::


File: maxima.info,  Node: Functions and Variables for Bernstein,  Prev: Bernstein,  Up: Bernstein

41.1 Functions and Variables for Bernstein
==========================================

 -- 関数: bernstein_poly (<k>, <n>, <x>)

     ‘k’が負の整数でないと仮定すると、 Bernstein多項式は
     ‘bernstein_poly(k,n,x) = binomial(n,k) x^k (1-x)^(n-k)’で定義されま
     す; 負の整数‘k’に対しては、Bernstein多項式 ‘bernstein_poly(k,n,x)’は
     零です。 ‘k’か ‘n’のどちらかが非整数の時、 オプション変数
     ‘bernstein_explicit’は Bernstein多項式の明示形式への展開を制御しま
     す。 例:

          (%i1) load("bernstein")$

          (%i2) bernstein_poly(k,n,x);
          (%o2)                bernstein_poly(k, n, x)
          (%i3) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o3)            binomial(n, k) (1 - x)      x

     Bernstein多項式はgradefプロパティとintegrateプロパティの両方を持ち
     ます:

          (%i4) diff(bernstein_poly(k,n,x),x);
          (%o4) (bernstein_poly(k - 1, n - 1, x)
                                           - bernstein_poly(k, n - 1, x)) n
          (%i5) integrate(bernstein_poly(k,n,x),x);
          (%o5)
                                                                      k + 1
           hypergeometric([k + 1, k - n], [k + 2], x) binomial(n, k) x
           ----------------------------------------------------------------
                                        k + 1

     実数と複素数両方の数値入力に対して、 Bernstein多項式は数値結果に評
     価されます:

          (%i6) bernstein_poly(5,9, 1/2 + %i);
                                  39375 %i   39375
          (%o6)                   -------- + -----
                                    128       256
          (%i7) bernstein_poly(5,9, 0.5b0 + %i);
          (%o7)           3.076171875b2 %i + 1.5380859375b2

     ‘bernstein_poly’を使うには、最初に ‘load("bernstein")’。

 -- 変数: bernstein_explicit
     デフォルト値: ‘false’

     ‘k’か ‘n’のどちらかが非整数の時、 オプション変数
     ‘bernstein_explicit’は Bernstein多項式の明示形式への展開を制御しま
     す; 例えば:

          (%i1) bernstein_poly(k,n,x);
          (%o1)                bernstein_poly(k, n, x)
          (%i2) bernstein_poly(k,n,x), bernstein_explicit : true;
                                                 n - k  k
          (%o2)            binomial(n, k) (1 - x)      x
     ‘k’と ‘n’の両方が明示的に整数の時、 ‘bernstein(k,n,x)’は _いつも_明
     示形式に展開されます。

 -- 関数: multibernstein_poly (<[k1,k2,…, kp]>, <[n1,n2,…, np]>,
          <[x1,x2,…, xp]>)

     マルチBernstein多項式 ‘multibernstein_poly (<[k1, k2, ..., kp]>,
     <[n1, n2, ..., np]>, <[x1, x2, ..., xp]>)’ Bernstein多項式
     ‘bernstein_poly(k1, n1, x1) bernstein_poly(k2, n2, x2) ...
     bernstein_poly(kp, np, xp)’の積です。

     ‘multibernstein_poly’を使うには、最初に ‘load("bernstein")’。

 -- 関数: bernstein_approx (<f>, <[x1, x1, …, xn]>, n)

     関数 ‘(x1, x2, ..., xn) |--> f’の ‘n’次の一様Bernstein多項式近似を
     返します。

     例

          (%i1) bernstein_approx(f(x),[x], 2);
                           2       1                          2
          (%o1)      f(1) x  + 2 f(-) (1 - x) x + f(0) (1 - x)
                                   2
          (%i2) bernstein_approx(f(x,y),[x,y], 2);
                         2  2       1                2
          (%o2) f(1, 1) x  y  + 2 f(-, 1) (1 - x) x y
                                    2
                            2  2          1   2
           + f(0, 1) (1 - x)  y  + 2 f(1, -) x  (1 - y) y
                                          2
                 1  1                               1         2
           + 4 f(-, -) (1 - x) x (1 - y) y + 2 f(0, -) (1 - x)  (1 - y) y
                 2  2                               2
                      2        2       1                      2
           + f(1, 0) x  (1 - y)  + 2 f(-, 0) (1 - x) x (1 - y)
                                       2
                            2        2
           + f(0, 0) (1 - x)  (1 - y)

     ‘bernstein_approx’を使うには、最初に ‘load("bernstein")’。

 -- 関数: bernstein_expand (<e>, <[x1, x1, …, xn]>)

     _多項式_ ‘e’を 多変数Bernstein多項式の線形結合として厳密に表します
     。

          (%i1) bernstein_expand(x*y+1,[x,y]);
          (%o1)    2 x y + (1 - x) y + x (1 - y) + (1 - x) (1 - y)
          (%i2) expand(%);
          (%o2)                        x y + 1

     一番目の引数が多項式でない時、Maximaはエラーをシグナルします。

     ‘bernstein_expand’を使うには、最初に ‘load("bernstein")’。


File: maxima.info,  Node: bode,  Next: cobyla,  Prev: Bernstein,  Up: Top

42 bode
*******

* Menu:

* Functions and Variables for bode::


File: maxima.info,  Node: Functions and Variables for bode,  Prev: bode,  Up: bode

42.1 Functions and Variables for bode
=====================================

 -- 関数: bode_gain (<H>, <range>, ...<plot_opts>...)
     Bodeのゲイン線図を描く関数。

     例 (1から7までは
          <http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html>,
     から、8はRon Crummettから):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     この関数を使うためには、最初に‘load("bode")’を書いてください。
     ‘bode_phase’も参照してください。

 -- 関数: bode_phase (<H>, <range>, ...<plot_opts>...)
     Bodeの位相線図を描く関数。

     例 (1から7までは
          <http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html>,
     から、8はRon Crummettから):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     この関数を使うためには、最初に‘load("bode")’を書いてください。
     ‘bode_gain’も参照してください。


File: maxima.info,  Node: cobyla,  Next: contrib_ode,  Prev: bode,  Up: Top

43 cobyla
*********

* Menu:

* Introduction to cobyla::
* Functions and Variables for cobyla::
* Examples for cobyla::  


File: maxima.info,  Node: Introduction to cobyla,  Next: Functions and Variables for cobyla,  Prev: cobyla,  Up: cobyla

43.1 Introduction to cobyla
===========================

‘fmin_cobyla’は Powell[1][2][3]による Fortran制約最適化ルーチンCOBYLAの
(‘f2cl’による)Common Lisp翻訳です。

   COBYLAは X上の形式g(X) >= 0のM個の不等式制約を条件として目的函数
F(X)を最小化します。 ここで、XはN個の成分を持つ変数のベクトルです。

   等式制約g(X)=0は、 よく、不等式制約の組g(X)>=0と-g(X)>= 0で実装するこ
とができます。 MaximaのCOBYLAインターフェースは等式制約を受け入れ、 内部
的に等式制約を不等式制約の組に変換します。

   アルゴリズムは目的函数や制約函数の線形近似を用います。 変数空間内の
N+1点での線形補間で形成された近似です。 補間点は単体の頂点としてみなされ
ます。 パラメータRHOは単体のサイズを制御し、 RHOBEGからEHOENDに自動的に
減らされます。 それぞれのRHOで、 サブルーチンは 現在のサイズにとって変数
の良いベクトルを達成しようとし、 そして、RHOは値RHOENDに達するまで減らさ
れます。 それゆえに、RHOBEGとRHOENDはそれぞれ、変数への合理的な初期変化
と 変数に要求される精度に設定されるべきですが、 この精度は、保証はないの
で、実験の対象として見るべきです。 ルーチンは、 変数の変化を計算する時、
制約を単一のペナルティ函数にひとまとめにせずに、 制約それぞれを個別に扱
います。 サブルーチン名は the phrase Constrained Optimization BY Linear
Approximations(線形近似による位相制約下最適化)に由来します。

   参考文献:

   [1] Fortran Codeは<http://plato.asu.edu/sub/nlores.html#general>から

   [2] M. J. D. Powell, "A direct search optimization method that models
the objective and constraint functions by linear interpolation," in
Advances in Optimization and Numerical Analysis, eds.  S. Gomez and
J.-P. Hennart (Kluwer Academic: Dordrecht, 1994), p.  51-67.

   [3] M. J. D. Powell, "Direct search algorithms for optimization
calculations," Acta Numerica 7, 287-336 (1998).  Also available as
University of Cambridge, Department of Applied Mathematics and
Theoretical Physics, Numerical Analysis Group, Report NA1998/04 from
<http://www.damtp.cam.ac.uk/user/na/reports.html>


File: maxima.info,  Node: Functions and Variables for cobyla,  Next: Examples for cobyla,  Prev: Introduction to cobyla,  Up: cobyla

43.2 Functions and Variables for cobyla
=======================================

 -- 関数: fmin_cobyla (<F>, <X>, <Y>)
 -- 関数: fmin_cobyla (<F>, <X>, <Y>, optional_args)

     オプションの制約の組を条件として多変数<X>に関する式<F>の近似的最小
     を返します。 <Y>は<X>に対する初期推測のリストです。

     <F>は関数名やラムダ式ではなく、通常の式でなければいけません。

     ‘optional_args’は、 ‘<symbol> = <value>’のように指定される付加的な
     引数を表します。 認識されるオプションの引数は以下の通りです:

     ‘constraints’
          <X>が満たさなければいけない不等式と等式の制約のリスト。 不等式
          制約は、 形式‘g(<X>) >= h(<X>)’もしくは‘g(<X>) <= h(<X>)’の 実
          際の不等式でなければいけません。 等式制約は 形式‘g(<X>) =
          h(<X>)’のものでなければいけません。
     ‘rhobeg’
          単体のサイズを制御する内部RHO変数の初期値(デフォルトは1.0)。
     ‘rhoend’
          要望される最終値rhoパラメータ。 近似的に変数の精度です。(デフ
          ォルトは1d-6)
     ‘iprint’
          冗長な出力レベル(デフォルトは0)。
             • 0 - 出力なし
             • 1 - 計算終了時にまとめ
             • 2 - 変数のベクトルやRHOが減らされる時のある函数情報と一緒
               に、 RHOとSIGMAのそれぞれの新しい値が印字されます。
             • 3 - 2と同様ですが、F(X)が計算される時情報が印字されます。
     ‘maxfun’
          函数評価の最大回数(デフォルトは1000)。

     返す時、ベクトルが与えられます:
       1. 最小を与える変数の値。 これは <X>の中にリストされた変数のそれ
          ぞれに関する 形式‘<var> = <value>’の 要素のリストです。
       2. 最小化された函数値
       3. 函数評価の回数
       4. 以下の意味を持つリターンコード
            1. 0 - エラーなし。
            2. 1 - 函数評価の最大回数の上限に到達した。
            3. 2 - 進行を妨げる丸め誤差。

     ‘load("fmin_cobyla")’はこの関数をロードします。

 -- 関数: bf_fmin_cobyla (<F>, <X>, <Y>)
 -- 関数: bf_fmin_cobyla (<F>, <X>, <Y>, optional_args)

     この関数は、 多倍長浮動小数点演算が使われること、 <rhoend>のデフォ
     ルト値が‘10^(fpprec/2)’であることを除いて、 ‘fmin_cobyla’と同一です
     。

     更に知るには‘fmin_cobyla’を参照してください。

     ‘load("fmin_cobyla")’はこの関数をロードします。


File: maxima.info,  Node: Examples for cobyla,  Prev: Functions and Variables for cobyla,  Up: cobyla

43.3 Examples for cobyla
========================

x1*x2を1-x1^2-x2^2 >= 0の条件で最小化します。 理論的解はx1 = 1/sqrt(2),
x2 = -1/sqrt(2)です。

     (%i1) load("fmin_cobyla")$
     (%i2) fmin_cobyla(x1*x2, [x1, x2], [1,1],
                       constraints = [x1^2+x2^2<=1], iprint=1);
        Normal return from subroutine COBYLA

        NFVALS =   66   F =-5.000000E-01    MAXCV = 1.999845E-12
        X = 7.071058E-01  -7.071077E-01
     (%o2) [[x1 = 0.70710584934848, x2 = - 0.7071077130248],
            - 0.49999999999926, [[-1.999955756559757e-12],[]], 66]

   追加の例はshare/cobyla/exディレクトリにあります。


File: maxima.info,  Node: contrib_ode,  Next: descriptive,  Prev: cobyla,  Up: Top

44 contrib_ode
**************

* Menu:

* Introduction to contrib_ode::
* Functions and Variables for contrib_ode::
* Possible improvements to contrib_ode::
* Test cases for contrib_ode::
* References for contrib_ode::


File: maxima.info,  Node: Introduction to contrib_ode,  Next: Functions and Variables for contrib_ode,  Prev: contrib_ode,  Up: contrib_ode

44.1 Introduction to contrib_ode
================================

Maximaの常微分方程式(ODE)ソルバ‘ode2’は 一階と二階の初等線形ODEを解きま
す。 関数‘contrib_ode’は 線形と非線形一階ODEと線形斉次二階ODEに関する追
加の方法で ‘ode2’を拡張します。 コードは、まだ開発中で、コールの順序は将
来のリリースで変わるかもしれません。 一旦コードが安定化したら、投稿ディ
レクトリから移して、Maximaに統合されるかもしれません。

   このパッケージは、 使用前に コマンド‘load("contrib_ode")’でロードしな
ければいけません。

   ‘contrib_ode’のコール取り決めは ‘ode2’と同一です。 ３つの引数を取りま
す: ODE (右辺が0なら左辺だけでもいいです)、 従属変数、独立変数。 成功し
た時、解のリストを返します。

   解の形式は ‘ode2’と異なります。 非線形方程式は複数解を持つので、
‘contrib_ode’は解のリストを返します。 解それぞれは複数の形式を持ちます:
   • 従属変数の陽解、

   • 従属変数の陰解、

   • 変数‘%t’を使ったパラメトリック解、または、

   • 変数‘%u’に関する別のODEへの変換

   ‘%c’は 一階方程式の積分定数を表すのに使われます。 ‘%k1’と‘%k2’は 二階
方程式の定数を表すのに使われます。 もし‘contrib_ode’が いかなる理由でも
解を得られないなら、 たぶんエラーメッセージを印字した後、 ‘false’を返し
ます。

   一階非線形ODEは複数解を持ち得るので、 解のリストを返す必要があります
。 例えば:

     (%i1) load("contrib_ode")$

     (%i2) eqn:x*'diff(y,x)^2-(1+x*y)*'diff(y,x)+y=0;

                         dy 2             dy
     (%o2)            x (--)  - (x y + 1) -- + y = 0
                         dx               dx
     (%i3) contrib_ode(eqn,y,x);

                                                  x
     (%o3)             [y = log(x) + %c, y = %c %e ]
     (%i4) method;

     (%o4)                        factor

   以下の例の二番目の解のように、 非線形ODEは積分定数を持たない特異解を
持ち得ます:

     (%i1) load("contrib_ode")$

     (%i2) eqn:'diff(y,x)^2+x*'diff(y,x)-y=0;

                            dy 2     dy
     (%o2)                 (--)  + x -- - y = 0
                            dx       dx
     (%i3) contrib_ode(eqn,y,x);

                                                2
                                      2        x
     (%o3)              [y = %c x + %c , y = - --]
                                               4
     (%i4) method;

     (%o4)                       clairault

   以下のODEは ダミー変数‘%t’を使った ２つのパラメトリック解を持ちます。
この場合、パラメトリック解を操作して、陽解を与えることができます。

     (%i1) load("contrib_ode")$

     (%i2) eqn:'diff(y,x)=(x+y)^2;

                               dy          2
     (%o2)                     -- = (y + x)
                               dx
     (%i3) contrib_ode(eqn,y,x);

     (%o3) [[x = %c - atan(sqrt(%t)), y = - x - sqrt(%t)],
                          [x = atan(sqrt(%t)) + %c, y = sqrt(%t) - x]]
     (%i4) method;

     (%o4)                       lagrange

   以下の例(Kamke 1.112)は、陰解を例示します。

     (%i1) load("contrib_ode")$

     (%i2) assume(x>0,y>0);

     (%o2)                    [x > 0, y > 0]
     (%i3) eqn:x*'diff(y,x)-x*sqrt(y^2+x^2)-y;

                          dy           2    2
     (%o3)              x -- - x sqrt(y  + x ) - y
                          dx
     (%i4) contrib_ode(eqn,y,x);

                                       y
     (%o4)                  [x - asinh(-) = %c]
                                       x
     (%i5) method;

     (%o5)                          lie

   以下のRiccati方程式は 変数‘%u’に関する線形二階ODEに変換されます。
Maximaは 新しいODEを解くことができません。 だから、未評価で返されます。
     (%i1) load("contrib_ode")$

     (%i2) eqn:x^2*'diff(y,x)=a+b*x^n+c*x^2*y^2;

                         2 dy      2  2      n
     (%o2)              x  -- = c x  y  + b x  + a
                           dx
     (%i3) contrib_ode(eqn,y,x);

                    d%u
                    ---                            2
                    dx        2     n - 2   a     d %u
     (%o3)  [[y = - ----, %u c  (b x      + --) + ---- c = 0]]
                    %u c                     2      2
                                            x     dx
     (%i4) method;

     (%o4)                        riccati

   一階ODEに対して、‘contrib_ode’は‘ode2’をコールします。 その後、以下の
方法を試します: 因数分解、Clairault, Lagrange, Riccati, Abel, Lie対称性
を使った方法 もしAbel方法が失敗したら、 Lie方法はAbel方程式には試みられ
ませんが、 もしRiccati方法が未解決二階ODEを返したら、 Lie方法が試みられ
ます。

   二階ODEに対して、‘contrib_ode’は‘ode2’をコールし、その後‘odelin’をコ
ールします。

   もしコマンド ‘put('contrib_ode,true,'verbose)’が実行されたら、 長いデ
バッグトレースとメッセージが表示されます。


File: maxima.info,  Node: Functions and Variables for contrib_ode,  Next: Possible improvements to contrib_ode,  Prev: Introduction to contrib_ode,  Up: contrib_ode

44.2 Functions and Variables for contrib_ode
============================================

 -- 関数: contrib_ode (<eqn>, <y>, <x>)

     独立変数<x>と従属変数<y>に関するODE <eqn>の解のリストを返します。

 -- 関数: odelin (<eqn>, <y>, <x>)

     ‘odelin’は 独立変数<x>と従属変数<y>に関する 一階および二階線形斉次
     ODEを解きます。 ODEの基本的な解一式を返します。

     二階ODEに対して、‘odelin’は、 与えられた特殊関数を使って解を探索す
     る BronsteinとLafailleによる方法 を使います。

          (%i1) load("contrib_ode");

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x

 -- 関数: ode_check (<eqn>, <soln>)

     可能な解<soln>を代入した後、 ODE <eqn>の値を返します。 もし<soln>が
     <eqn>の解なら 値はゼロと同値です。

          (%i1) load("contrib_ode")$

          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);

          (%o4)                           0

 -- システム変数: method

     変数‘method’は成功した解法に設定されます。

 -- 変数: %c

     ‘%c’は一階ODEの積分定数です。

 -- 変数: %k1

     ‘%k1’は二階ODEの最初の積分定数です。

 -- 変数: %k2

     ‘%k2’は二階ODEの二番目の積分定数です。

 -- 関数: gauss_a (<a>, <b>, <c>, <x>)

     ‘gauss_a(a,b,c,x)’と‘gauss_b(a,b,c,x)’は2F1幾何関数です。 それらは
     超幾何微分方程式 ‘x(1-x) diff(y,x,2) + [c-(a+b+1)x diff(y,x) - aby
     = 0’ の任意の２つの独立解を表します(A&S 15.5.1)。

     これらの関数は ‘odelin’と‘contrib_ode’が返すODEの解の中でだけ使われ
     ます。 これらの関数の定義と使用はMaimaの将来のリリースで変わるかも
     しれません。

     ‘gauss_b’, ‘dgauss_a’, ‘gauss_b’も参照してください。

 -- 関数: gauss_b (<a>, <b>, <c>, <x>)
     See ‘gauss_a’.

 -- 関数: dgauss_a (<a>, <b>, <c>, <x>)
     ‘gauss_a(<a>, <b>, <c>, <x>)’の<x>に関する導関数。

 -- 関数: dgauss_b (<a>, <b>, <c>, <x>)
     ‘gauss_b(<a>, <b>, <c>, <x>)’の<x>に関する導関数。

 -- 関数: kummer_m (<a>, <b>, <x>)

     Abramowitz and Stegun, Handbook of Mathematical Functions, Section
     13.1.2の中で定義される KummerのM関数

     この関数は ‘odelin’と‘contrib_ode’が返すODEの解の中でだけ使われます
     。 この関数の定義と使用はMaimaの将来のリリースで変わるかもしれませ
     ん。

     ‘kummer_u’, ‘dkummer_m’, ‘dkummer_u’も参照してください。

 -- 関数: kummer_u (<a>, <b>, <x>)

     Abramowitz and Stegun, Handbook of Mathematical Functions, Section
     13.1.3の中で定義される KummerのU関数

     ‘kummer_m’を参照してください。

 -- 関数: dkummer_m (<a>, <b>, <x>)
     ‘kummer_m(<a>, <b>, <x>)’の<x>に関する導関数。

 -- 関数: dkummer_u (<a>, <b>, <x>)
     ‘kummer_u(<a>, <b>, <x>)’の<x>に関する導関数。


File: maxima.info,  Node: Possible improvements to contrib_ode,  Next: Test cases for contrib_ode,  Prev: Functions and Variables for contrib_ode,  Up: contrib_ode

44.3 Possible improvements to contrib_ode
=========================================

これらのルーチンは開発進行中です。まだ以下をする必要があります:

   • FACTOR方法‘ode1_factor’を多重根で機能するように拡張すること。

   • FACTOR方法‘ode1_factor’を より高次因子を解こうとするように拡張する
     こと。 現在、線形因子を解こうとするだけです。

   • LAGRANGEルーチン‘ode1_lagrange’を複素根より実根を優先するように直す
     こと。

   • Riccati方程式のための他の方法を追加すること。

   • 第二種Abel方程式の検出を改善すること。 今のパターンマッチングは弱い
     です。

   • Work on the Lie対称群ルーチン‘ode1_lie’に関する仕事。 2,3の相当な問
     題があります: いくつかの部分が未実装です; いくつかのテストケースが
     無限ループのようです; 他のテストケースではクラッシュします; さらに
     他では非常に複雑な「解」を返します。 本当にリリースの準備ができてい
     たか疑っています。

   • もっとテストケースを追加すること。


File: maxima.info,  Node: Test cases for contrib_ode,  Next: References for contrib_ode,  Prev: Possible improvements to contrib_ode,  Up: contrib_ode

44.4 Test cases for contrib_ode
===============================

Murphy, Kamke, Zwillingerと他で ルーチンはおおよそ千のテストケース上でテ
ストされています。 これらはテストサブディレクトリに含まれています。

   • The Clairaultルーチン‘ode1_clairault’は、 特異解を含み、 Murphyと
     Kamkeの中のClairault方程式の 知られている解すべてを見つけます。

   • 他のルーチンは、多重解が存在する時に しばしば単一界を返します。

   • ‘ode1_lie’の「解」のいくつかは過度に複雑でチェックが不可能です。

   • いくつかのクラッシュがあります。


File: maxima.info,  Node: References for contrib_ode,  Prev: Test cases for contrib_ode,  Up: contrib_ode

44.5 References for contrib_ode
===============================

  1. E. Kamke, Differentialgleichungen Losungsmethoden und Losungen, Vol
     1, Geest & Portig, Leipzig, 1961

  2. G. M. Murphy, Ordinary Differential Equations and Their Solutions,
     Van Nostrand, New York, 1960

  3. D. Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F. Schwarz, Symmetry Analysis of Abel’s Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F. Schwarz, Algorithmic Solution of Abel’s Equation, Computing 61,
     39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order ODE
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (<http://lie.uwaterloo.ca/papers/ode_vii.pdf>)

  7. E. S. Cheb-Terrab, T. Kolokolnikov, First Order ODEs, Symmetries
     and Linear Transformations, European Journal of Applied
     Mathematics, Vol.  14, No.  2, pp.  231-246 (2003).
     (<http://arxiv.org/abs/math-ph/0007023>,
     <http://lie.uwaterloo.ca/papers/ode_iv.pdf>)

  8. G. W. Bluman, S. C. Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M. Bronstein, S. Lafaille, Solutions of linear ordinary
     differential equations in terms of special functions, Proceedings
     of ISSAC 2002, Lille, ACM Press, 23-28.
     (<http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/issac2002.pdf>)


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

45 descriptive
**************

* Menu:

* Introduction to descriptive::
* Functions and Variables for data manipulation::
* Functions and Variables for descriptive statistics::
* Functions and Variables for statistical graphs::


File: maxima.info,  Node: Introduction to descriptive,  Next: Functions and Variables for data manipulation,  Prev: descriptive,  Up: descriptive

45.1 Introduction to descriptive
================================

パッケージ‘descriptive’は記述統計計算とグラフ作成を行うための関数一式を
含みます。 ソースコードと一緒にMaximaツリーに３つのデータセットがありま
す: ‘pidigits.data’, ‘wind.data’, ‘biomed.data’

   パッケージ‘descriptive’の関数の参考文献として、 どんな統計マニュアル
でも使うことができます。

   コメント、バグ、提案は、 <’mario AT edu DOT xunta DOT es’>にコンタク
トしてください。

   以下は、 ‘descriptive’の中の記述関数が 引数やリスト、行列の性質に依存
して如何に機能するかを示す 簡単な例です。

     (%i1) load ("descriptive")$
     (%i2) /* univariate sample */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* multivariate sample */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

   多変数標本では、平均は列それぞれに関して計算されることに注意してくだ
さい。

   異なるサイズかもしれない複数の標本の場合、 Maxima関数‘map’が標本それ
ぞれに対して望みの結果を得るのに使うことができます。

     (%i1) load ("descriptive")$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

   この場合、サイズ３と２の２つの標本がリストに格納されました。

   １変数標本は以下のようにリストに格納されなければいけません。

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

   多変数標本は以下のように行列に格納されなければいけません。

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

   この場合、 列の数は確率変数次元に等しく、行の数はサプルのサイズです。

   データは手で入力することができますが、 大きな標本は普通プレインテキス
トファイルの中に格納されています。 例えば、ファイル‘pidigits.data’は 数
‘%pi’の最初の100桁を含みます:
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

   Maximaでこれらの桁をロードするためには、

     (%i1) s1 : read_list (file_search ("pidigits.data"))$
     (%i2) length (s1);
     (%o2)                          100

   他方、ファイル‘wind.data’は アイルランド共和国の５つの気象台の毎日の
平均風速を含みます。 (これは１２の気象台で取得されたデータセットの一部で
す。 元のファイルはStatLib Data Repositoryから無料でダウンロードでき、 そ
の分析はHaslett, J., Raftery, A. E. (1989) <Space-time Modelling with
Long-memory Dependence: Assessing Ireland’s Wind Power Resource, with
Discussion>.  Applied Statistics 38, 1-50 で議論されてます。) 以下ではデ
ータをロードします:

     (%i1) s2 : read_matrix (file_search ("wind.data"))$
     (%i2) length (s2);
     (%o2)                          100
     (%i3) s2 [%]; /* last record */
     (%o3)            [3.58, 6.0, 4.58, 7.62, 11.25]

   いくつかの標本は数値でないデータを含みます。 例えば、ファイル
‘biomed.data’ (StatLib Data Repositoryからダウンロードされた別のもっと大
きなものの一部)は、 異なる年齢の、２つのグループ‘A’と‘B’の患者から測定さ
れた４つの血圧を含みます。

     (%i1) s3 : read_matrix (file_search ("biomed.data"))$
     (%i2) length (s3);
     (%o2)                          100
     (%i3) s3 [1]; /* first record */
     (%o3)            [A, 30, 167.0, 89.0, 25.6, 364]

   最初の個人はグループ‘A’に属し、30歳で、血圧は167.0, 89.0, 25.6 and
364でした。

   カテゴリデータを扱う時には気をつけなければいけません。 次の例では、シ
ンボル‘a’が以前のある時点で値に割り当てられ、 その後、カテゴリ値‘a’を持
つ標本が取られます。

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Functions and Variables for data manipulation,  Next: Functions and Variables for descriptive statistics,  Prev: Introduction to descriptive,  Up: descriptive

45.2 Functions and Variables for data manipulation
==================================================

 -- 関数: continuous_freq (<list>)
 -- 関数: continuous_freq (<list>, <m>)
     ‘continuous_freq’の引数は数のリストでなければいけません。 範囲を区
     間に分割し、それらの中に値がいくつあるか数えます。 二番目の引数はオ
     プションで、 欲しいクラス数(デフォルトが10)か、 クラス境界と欲しい
     クラスを含むリストか 境界だけ含むリストのいずれかです。 引数
     <list>は(2個か3個の)実数のリストでなければいけません。 もしサンプル
     値がすべて等しいなら、この関数は振幅2の1クラスだけ返します。

     例:

     オプション引数は欲しいクラス数を示します。 出力の最初のリストは区間
     境界を含み、二番目は対応する個数を含みます: 区間‘[0, 1.8]’すなわち
     0か1である桁が16あり、 ‘(1.8, 3.6]’すなわち2か3である桁が24あり、な
     ど。

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, 5);
          (%o3) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     オプション引数は、境界-2と12を持つクラスを7個欲しいことを示します。

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12,7]);
          (%o3) [[- 2, 0, 2, 4, 6, 8, 10, 12], [8, 20, 22, 17, 20, 13, 0]]

     オプション引数は、境界-2と12を持つクラスをデフォルト個欲しいことを
     示します:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12]);
                          3  4  11  18     32  39  46  53
          (%o3)  [[- 2, - -, -, --, --, 5, --, --, --, --, 12],
                          5  5  5   5      5   5   5   5
                         [0, 8, 20, 12, 18, 9, 8, 25, 0, 0]]

 -- 関数: discrete_freq (<list>)
     数値的、記述的両方の離散標本の中の絶対頻度を数えます。 唯一の引数は
     リストです。

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) discrete_freq (s1);
          (%o3) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     最初のリストは標本値を与え、二番目はそれらの絶対頻度を与えます。 コ
     マンド‘? col’と‘? transpose’は最後の入力を理解するのを助けるはずで
     す。

 -- 関数: subsample (<data_matrix>, <predicate_function>)
 -- 関数: subsample (<data_matrix>, <predicate_function>, <col_num1>,
          <col_num2>, ...)
     これはMaxima ‘submatrix’関数の変形の一種です。 最初の引数はデータ行
     列であり、二番目は述語関数であり、 オプションの付加引数は返す列の番
     号です。 その振る舞いは例を使ってよりよく理解されます。

     以下は最初の測候所での風速が18より大きかった多変量レコードです。 ラ
     ムダ式の中で<i>番目の成分は‘v[i]’として参照されることを参考にしてく
     ださい。
          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) subsample (s2, lambda([v], v[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o3)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     以下の例では、測候所番号1で16以上で、かつ、測候所番号4で25ノットよ
     り小さな風速 のレコードの一番目、二番目、五番目の成分だけをリクエス
     トします。 標本は、測候所1, 2, 5からのデータだけを含みます。 この場
     合、述語関数は通常のMaxima関数として定義されます。
          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) g(x):= x[1] >= 16 and x[4] < 25$
          (%i4) subsample (s2, g, 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     以下は‘biomed.data’のカテゴリ変数の例です。 38歳より年上のグループ
     ‘B’の患者に対応するレコードが欲しいです。
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) h(u):= u[1] = B and u[2] > 38 $
          (%i4) subsample (s3, h);
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     統計解析には血圧だけを使うかもしれません。
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) subsample (s3, lambda([v], v[1] = B and v[2] > 38),
                           3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o3)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     いかは‘s3’の多変量平均です。
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) mean (s3);
                 65 B + 35 A  317          6 NA + 8144.999999999999
          (%o3) [-----------, ---, 87.178, ------------------------,
                     100      10                     100
                                                              3 NA + 19587
                                                      18.123, ------------]
                                                                  100

     ここで、一番目の成分は、‘A’と‘B’はカテゴリなので意味がなく、 二番目
     の成分は個々人の平均の歳の有理表現であり、 四番目と最後の値はある奇
     妙な振る舞いを示しています。 これは、 This is because symbol シンボ
     ル‘NA’が<non available>データを示すようにここで使われているからで、
     二つの平均は無意味です。 情報のある種の喪失を意味しますが、 可能な
     解は‘NA’シンボルを持つ行を行列から取り除くことです。
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) g(v):= v[4] # NA and v[6] # NA $
          (%i4) mean (subsample (s3, g, 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Functions and Variables for descriptive statistics,  Next: Functions and Variables for statistical graphs,  Prev: Functions and Variables for data manipulation,  Up: descriptive

45.3 Functions and Variables for descriptive statistics
=======================================================

 -- 関数: mean (<list>)
 -- 関数: mean (<matrix>)
     これは標本平均です。以下のように定義されます。
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean (s1);
                                         471
          (%o3)                          ---
                                         100
          (%i4) %, numer;
          (%o4)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean (s2);
          (%o6)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- 関数: var (<list>)
 -- 関数: var (<matrix>)
     これは標本分散です。以下のように定義されます。
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var (s1), numer;
          (%o3)                   8.425899999999999

     関数‘var1’も参照してください。

 -- 関数: var1 (<list>)
 -- 関数: var1 (<matrix>)
     これは標本分散です。以下のように定義されます。
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var1 (s1), numer;
          (%o3)                    8.5110101010101
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) var1 (s2);
          (%o5) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     関数‘var’も参照してください。

 -- 関数: std (<list>)
 -- 関数: std (<matrix>)
     これは分母nの分散である関数‘var’の平方根です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std (s1), numer;
          (%o3)                   2.902740084816414
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std (s2);
          (%o5) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     関数‘var’と‘std1’も参照してください。

 -- 関数: std1 (<list>)
 -- 関数: std1 (<matrix>)
     これは分母n-1の分散である関数‘var1’の平方根です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std1 (s1), numer;
          (%o3)                   2.917363553109228
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std1 (s2);
          (%o5) [4.170835096721089, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     See also functions ‘var1’ and ‘std’.

 -- 関数: noncentral_moment (<list>, <k>)
 -- 関数: noncentral_moment (<matrix>, <k>)
     次数kの非中心モーメントです。以下のように定義されます。
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) noncentral_moment (s1, 1), numer; /* the mean */
          (%o3)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) noncentral_moment (s2, 5);
          (%o6) [319793.8724761505, 320532.1923892463,
                391249.5621381556, 2502278.205988911, 1691881.797742255]

     関数‘central_moment’も参照してください。

 -- 関数: central_moment (<list>, <k>)
 -- 関数: central_moment (<matrix>, <k>)
     次数kの中心モーメントです。以下のように定義されます。
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) central_moment (s1, 2), numer; /* the variance */
          (%o3)                   8.425899999999999
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) central_moment (s2, 3);
          (%o6) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     関数‘noncentral_moment’と‘mean’も参照してください。

 -- 関数: cv (<list>)
 -- 関数: cv (<matrix>)
     変動係数は標本標準偏差(‘std’)を平均‘mean’で割った商です。
          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) cv (s1), numer;
          (%o3)                   .6193977819764815
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cv (s2);
          (%o5) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     関数‘std’と‘mean’も参照してください。

 -- 関数: smin (<list>)
 -- 関数: smin (<matrix>)
     これは標本<list>の最小値です。 引数が行列の時、 ‘smin’は 統計変数に
     関連付けられた列の最小値を含むリストを返します。

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smin (s1);
          (%o3)                           0
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smin (s2);
          (%o5)             [0.58, 0.5, 2.67, 5.25, 5.17]

     See also function ‘smax’.

 -- 関数: smax (<list>)
 -- 関数: smax (<matrix>)
     これは標本<list>の最大値です。 引数が行列の時、 ‘smax’は 統計変数に
     関連付けられた列の最大値を含むリストを返します。

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smax (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smax (s2);
          (%o5)          [20.25, 21.46, 20.04, 29.63, 27.63]

     関数‘smin’も参照してください。

 -- 関数: range (<list>)
 -- 関数: range (<matrix>)
     範囲は極値の差です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) range (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) range (s2);
          (%o5)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- 関数: quantile (<list>, <p>)
 -- 関数: quantile (<matrix>, <p>)
     これは標本<list>の<p>分位数です。<p>は[0, 1]の範囲の数です。 標本分
     位数にはいくつかの定義がありますが (Hyndman, R. J., Fan, Y. (1996)
     <Sample quantiles in statistical packages>.  American Statistician,
     50, 361-365)、 パッケージ‘descriptive’では線形内挿に基づいたものが
     実装されています。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) /* 1st and 3rd quartiles */
                   [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o3)                      [2.0, 7.25]
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quantile (s2, 1/4);
          (%o5)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- 関数: median (<list>)
 -- 関数: median (<matrix>)
     一旦標本が順に並べられると、 もし標本サイズが奇数ならメジアンは中央
     値であり、 そうでなければ2つの中央値の平均です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median (s1);
                                          9
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median (s2);
          (%o5)         [10.06, 9.855, 10.73, 15.48, 14.105]

     メジアンは1/2分位数です。

     関数‘quantile’も参照してください。

 -- 関数: qrange (<list>)
 -- 関数: qrange (<matrix>)
     四分位範囲は 三番目と一番目の分位数の差 ‘quantile(<list>,3/4) -
     quantile(<list>,1/4)’ です。

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) qrange (s1);
                                         21
          (%o3)                          --
                                         4
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) qrange (s2);
          (%o5) [5.385, 5.572499999999998, 6.022500000000001,
                                      8.729999999999999, 6.649999999999999]

     関数‘quantile’も参照してください。

 -- 関数: mean_deviation (<list>)
 -- 関数: mean_deviation (<matrix>)
     平均偏差です。以下のように定義されます。
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean_deviation (s1);
                                         51
          (%o3)                          --
                                         20
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mean_deviation (s2);
          (%o5) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     関数‘mean’も参照してください。

 -- 関数: median_deviation (<list>)
 -- 関数: median_deviation (<matrix>)
     メジアン偏差です。以下のように定義されます。
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     ここで‘med’は<list>のメジアンです。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median_deviation (s1);
                                          5
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median_deviation (s2);
          (%o5)           [2.75, 2.755, 3.08, 4.315, 3.31]

     関数‘mean’も参照してください。

 -- 関数: harmonic_mean (<list>)
 -- 関数: harmonic_mean (<matrix>)
     調和平均です。以下のように定義されます。
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) harmonic_mean (y), numer;
          (%o3)                   3.901858027632205
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) harmonic_mean (s2);
          (%o5) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     関数‘mean’と‘geometric_mean’も参照してください。

 -- 関数: geometric_mean (<list>)
 -- 関数: geometric_mean (<matrix>)
     幾何平均です。以下のように定義されます。
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     例:

          (%i1) load ("descriptive")$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) geometric_mean (y), numer;
          (%o3)                   4.454845412337012
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) geometric_mean (s2);
          (%o5) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     関数‘mean’と‘harmonic_mean’も参照してください。

 -- 関数: kurtosis (<list>)
 -- 関数: kurtosis (<matrix>)
     尖度係数です。以下のように定義されます。
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) kurtosis (s1), numer;
          (%o3)                  - 1.273247946514421
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) kurtosis (s2);
          (%o5) [- .2715445622195385, 0.119998784429451,
               - .4275233490482861, - .6405361979019522, - .4952382132352935]

     関数‘mean’, ‘var’, ‘skewness’も参照してください。

 -- 関数: skewness (<list>)
 -- 関数: skewness (<matrix>)
     歪度係数です。以下のように定義されます。
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) skewness (s1), numer;
          (%o3)                  .009196180476450424
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) skewness (s2);
          (%o5) [.1580509020000978, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890831]

     関数‘mean’, ‘var’, ‘kurtosis’も参照してください。

 -- 関数: pearson_skewness (<list>)
 -- 関数: pearson_skewness (<matrix>)
     Pearsonの歪度係数です。以下のように定義されます。
                          _
                       3 (x - med)
                       -----------
                            s
     ここで <med>は<list>のメジアンです。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) pearson_skewness (s1), numer;
          (%o3)                   .2159484029093895
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) pearson_skewness (s2);
          (%o5) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     関数‘mean’, ‘var’, ‘median’も参照してください。

 -- 関数: quartile_skewness (<list>)
 -- 関数: quartile_skewness (<matrix>)
     分位歪度係数です。以下のように定義されます。
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     ここでc_pは標本<list>の<p>分位数です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) quartile_skewness (s1), numer;
          (%o3)                  .04761904761904762
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quartile_skewness (s2);
          (%o5) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, .2105263157894735]

     関数‘quantile’も参照してください。

 -- 関数: cov (<matrix>)
     多変量標本の共分散行列です。以下のように定義されます。
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     ここでX_jは標本行列のj番目の行です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
          (%i4) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     関数‘cov1’も参照してください。

 -- 関数: cov1 (<matrix>)
     多変量標本の共分散行列です。以下のように定義されます。
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     ここでX_jは標本行列のj番目の行です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
          (%i4) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     関数‘cov’も参照してください。

 -- 関数: global_variances (<matrix>)
 -- 関数: global_variances (<matrix>, <logical_value>)
     関数‘global_variances’は大域分散尺度のリストを返します:

        • <total variance>: ‘trace(S_1)’,
        • <mean variance>: ‘trace(S_1)/p’,
        • <generalized variance>: ‘determinant(S_1)’,
        • <generalized standard deviation>: ‘sqrt(determinant(S_1))’,
        • <efective variance> ‘determinant(S_1)^(1/p)’, (以下の文献で定
          義されています: Peña, D. (2002) <Análisis de datos
          multivariantes>; McGraw-Hill, Madrid.)
        • <efective standard deviation>: ‘determinant(S_1)^(1/(2*p))’.
     ここで<p>は多変量確率変数の次元であり、 S_1は‘cov1’が返す共分散行列
     です。

     例:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608501, 6.636590811800795, 2.576158149609762]

     関数‘global_variances’はオプションの論理引数を取ります:
     ‘global_variances(x,true)’は、 Maximaに‘x’がデータ行列であることを
     伝え、‘global_variances(x)’と同様に作られます。 一方、
     ‘global_variances(x,false)’は ‘x’がデータ行列ではなく、共分散行列で
     あることを意味し、再計算は避けられます。

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608501, 6.636590811800795, 2.576158149609762]

     ‘cov’と‘cov1’も参照してください。

 -- 関数: cor (<matrix>)
 -- 関数: cor (<matrix>, <logical_value>)
     多変量標本の相関行列です。

     例:

          (%i1) load ("descriptive")$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     関数‘cor’はオプションの論理引数を取ります: ‘cor(x,true)’は、
     Maximaに‘x’がデータ行列であることを伝え、‘cor(x)’と同様に作られます
     。 一方、‘cor(x,false)’は ‘x’がデータ行列ではなく、共分散行列である
     ことを意味し、再計算は避けられます。

          (%i1) load ("descriptive")$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     ‘cov’と‘cov1’も参照してください。

 -- 関数: list_correlations (<matrix>)
 -- 関数: list_correlations (<matrix>, <logical_value>)
     関数‘list_correlations’は相関尺度のリストを返します:

        • <precision matrix>: 共分散行列S_1の逆行列,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        • <multiple correlation vector>: (R_1^2, R_2^2, ..., R_p^2),
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          変数の残りが独立変数として使われるとき これらはX_i上の線形多変
          量回帰モデルの適合度の指標です。

        • <partial correlation matrix>: (i, j)成分が以下の行列
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /

     例:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
          (%i5) z[1];  /* precision matrix */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i6) z[2];  /* multiple correlation vector */
          (%o6)      [.85063, .80634, .86474, .71867, .72675]
          (%i7) z[3];  /* partial correlation matrix */
                [  - 1.0     .38244   .36627   .49908   - .13049 ]
                [                                                ]
                [  .38244    - 1.0    .37927  - .19907   .23492  ]
                [                                                ]
          (%o7) [  .36627    .37927   - 1.0    .10911    .37956  ]
                [                                                ]
                [  .49908   - .19907  .10911   - 1.0     .26719  ]
                [                                                ]
                [ - .13049   .23492   .37956   .26719    - 1.0   ]

     関数‘list_correlations’もオプションの論理引数を取ります:
     ‘list_correlations(x,true)’は、 Maximaに‘x’がデータ行列であることを
     伝え、 ‘list_correlations(x)’と同様に作られます。 一方、
     ‘list_correlations(x,false)’は ‘x’がデータ行列ではなく、共分散行列
     であることを意味し、再計算は避けられます。

     ‘cov’と‘cov1’も参照してください。

