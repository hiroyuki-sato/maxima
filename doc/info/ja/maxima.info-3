This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Exponential Integrals,  Next: Error Function,  Prev: Gamma and factorial Functions,  Up: Special Functions

15.5 Exponential Integrals
==========================

指数積分と、関連した関数は、 Abramowitz and Stegun, Handbook of
Mathematical Functions, 5章の中で定義されています。

 -- 関数: expintegral_e1 (<z>)
     指数積分E1(z) (A&S 5.1.1)

 -- 関数: expintegral_ei (<z>)
     指数積分Ei(z) (A&S 5.1.2)

 -- 関数: expintegral_li (<z>)
     指数積分Li(z) (A&S 5.1.3)

 -- 関数: expintegral_e (<n>,<z>)
     指数積分 En(z) (A&S 5.1.4)

 -- 関数: expintegral_si (<z>)
     指数積分 Si(z) (A&S 5.2.1)

 -- 関数: expintegral_ci (<z>)
     指数積分 Ci(z) (A&S 5.2.2)

 -- 関数: expintegral_shi (<z>)
     指数積分 Shi(z) (A&S 5.2.3)

 -- 関数: expintegral_chi (<z>)
     指数積分 Chi(z) (A&S 5.2.4)

 -- オプション変数: expintrep
     デフォルト値: false

     指数積分の表現を、 gamma_incomplete, expintegral_e1,
     expintegral_ei, expintegral_li, expintegral_trig, expintegral_hyp に
     変えます。

 -- オプション変数: expintexpand
     デフォルト値: false

     Expand the Exponential Integral 半整数値の指数積分E[n](z)をErfcもし
     くはErfの項で展開し、 整数値のそれをEiの項で展開します。


File: maxima.info,  Node: Error Function,  Next: Struve Functions,  Prev: Exponential Integrals,  Up: Special Functions

15.6 Error Function
===================

誤差関数と、関連した関数は、 Abramowitz and Stegun, Handbook of
Mathematical Functions, 7章で定義されています。

 -- 関数: erf (<z>)
     誤差関数erf(z) (A&S 7.1.1)

     See also flag ‘erfflag’.

 -- 関数: erfc (<z>)
     相補誤差関数erfc(z) (A&S 7.1.2)

     ‘erfc(z) = 1-erf(z)’

 -- 関数: erfi (<z>)
     虚数誤差関数

     ‘erfi(z) = -%i*erf(%i*z)’

 -- 関数: erf_generalized (<z1>,<z2>)
     一般化誤差関数Erf(z1,z2)

 -- 関数: fresnel_c (<z>)
     フレネル積分C(z) = integrate(cos((%pi/2)*t^2),t,0,z) (A&S 7.3.1)

     フラグ‘trigsign’が‘true’の時、 整理 fresnel_c(-x) = -fresnel_c(x) が
     適用されます。

     フラグ‘%iargs’が‘true’の時、 整理 fresnel_c(%i*x) = %i*fresnel_c(x)
     が適用されます。

     フラグ‘erf_representation’と‘hypergeometric_representation’を参照し
     てください。

 -- 関数: fresnel_s (<z>)
     フレネル積分S(z) = integrate(sin((%pi/2)*t^2),t,0,z).  (A&S 7.3.2)

     フラグ‘trigsign’が‘true’の時、 整理fresnel_s(-x) = -fresnel_s(x) が
     適用されます。

     フラグ‘%iargs’が‘true’の時、 整理 fresnel_s(%i*x) = %i*fresnel_s(x)
     が適用されます。

     フラグ‘erf_representation’と‘hypergeometric_representation’を参照し
     てください。

 -- オプション変数: erf_representation
     デフォルト値: false

     ‘true’の時、 erfc, erfi, erf_generalized, fresnel_s, fresnel_c は、
     erfに変換されます。

 -- オプション変数: hypergeometric_representation
     デフォルト値: false

     fresnel_sとfresnel_cに関して超幾何表現への変換を可能にします。


File: maxima.info,  Node: Struve Functions,  Next: Hypergeometric Functions,  Prev: Error Function,  Up: Special Functions

15.7 Struve Functions
=====================

シュトルーベ関数はAbramowitz and Stegun, Handbook of Mathematical
Functions, 12章で定義されています。

   Maximaは、これらの関数の非常に限られた知識を持っています。 それらは、
関数‘hgfred’から返されることができます。

 -- 関数: struve_h (<v>, <z>)
     次数v, 独立変数zのシュトルーベ関数H (A&S 12.1.1)

 -- 関数: struve_l (<v>, <z>)
     次数v、独立変数zの変形シュトルーベ関数L (A&S 12.2.1)


File: maxima.info,  Node: Hypergeometric Functions,  Next: Parabolic Cylinder Functions,  Prev: Struve Functions,  Up: Special Functions

15.8 Hypergeometric Functions
=============================

超幾何関数はAbramowitz and Stegun, Handbook of Mathematical Functions,
13章15章で定義されています。

   Maximaは、これらの関数の非常に限られた知識を持っています。 それらは、
関数‘hgfred’から返されることができます。

 -- 関数: %m [<k>,<u>] (<z>)
     Whittaker M関数 ‘M[k,u](z) =
     exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)’.  (A&S 13.1.32)

 -- 関数: %w [<k>,<u>] (<z>)
     Whittaker W関数 (A&S 13.1.33)

 -- 関数: %f [<p>,<q>] (<[a],[b],z>)
     pFq(a1,a2,..ap;b1,b2,..bq;z)超幾何関数。 ここで、‘a’は長さ‘p’のリス
     トで、 ‘b’は長さ‘q’のリストです。

 -- 関数: hypergeometric ([<a1>, ..., <ap>],[<b1>, ... ,<bq>], x)
     超幾何関数。 Maximaの‘%f’超幾何関数と違って， 関数
     ‘hypergeometric’は整理関数です; ‘hypergeometric’は複素倍精度と多倍
     長浮動小数点評価もサポートします。 ガウスの超幾何関数、すなわち、p
     = 2かつq = 1、 に関しては、 単位円の外側の浮動小数点評価はサポート
     されていますが、 一般にはサポートされていません。

     オプション変数‘expand_hypergeometric’がtrue(デフォルトはfalse)で、
     独立変数‘a1’から‘ap’の１つが負の整数の時(多項式の場合)、
     ‘hypergeometric’は展開された多項式を返します。

     例:

          (%i1)  hypergeometric([],[],x);
          (%o1) %e^x

     ‘expand_hypergeometric’がtrueの時、多項式の場合は自動的に展開されま
     す:

          (%i2) hypergeometric([-3],[7],x);
          (%o2) hypergeometric([-3],[7],x)

          (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
          (%o3) -x^3/504+3*x^2/56-3*x/7+1

     倍精度と多倍長浮動小数点評価の両方がサポートされています:

          (%i4) hypergeometric([5.1],[7.1 + %i],0.42);
          (%o4)       1.346250786375334 - 0.0559061414208204 %i
          (%i5) hypergeometric([5,6],[8], 5.7 - %i);
          (%o5)     .00737582400977495 - 0.001049813688578674 %i
          (%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
          (%o6) 7.37582400977494674506442010824b-3
                                    - 1.04981368857867315858055393376b-3 %i


File: maxima.info,  Node: Parabolic Cylinder Functions,  Next: Functions and Variables for Special Functions,  Prev: Hypergeometric Functions,  Up: Special Functions

15.9 Parabolic Cylinder Functions
=================================

放物円筒関数はAbramowitz and Stegun, Handbook of Mathematical Functions,
19章で定義されています。

   Maximaは、これらの関数の非常に限られた知識を持っています。 それらは、
関数‘hgfred’から返されることができます。

 -- 関数: parabolic_cylinder_d (<v>, <z>)
     放物円筒関数‘parabolic_cylinder_d(v,z)’.  (A&s 19.3.1)


File: maxima.info,  Node: Functions and Variables for Special Functions,  Prev: Parabolic Cylinder Functions,  Up: Special Functions

15.10 Functions and Variables for Special Functions
===================================================

 -- 関数: specint (exp(- s*<t>) * <expr>, <t>)

     <expr>の変数<t>に関するラプラス変換を計算します。 以下の特殊関数は
     ‘specint’で扱われます: 不完全ベータ関数、誤差関数 （誤差関数
     ‘erfi’ではないです。‘erfi’は例えば、‘erf’に変換することは簡単です。
     ）、 指数積分、（ベッセル関数の積を含む）ベッセル関数、ハンケル関数
     、エルミートおよびラーゲル多項式。

     更に、‘specint’は、超幾何関数‘%f[p,q]([],[],z)’、 第一種Whittaker関
     数‘%m[u,k](z)’第二種Whittaker関数‘%w[u,k](z)’を 扱うことができます
     。

     結果は、特殊関数の項になるかもしれませんし、未整理の超幾何関数を含
     むかもしれません。

     ‘laplace’がラプラス変換を見つけることに失敗した時、 ‘specint’がコー
     ルされます。 ‘laplace’はラプラス変換に関するもっと一般的な規則を知
     っているので、 ‘specint’ではなく‘laplace’を使うのが望ましいです。

     ‘demo(hypgeo)’は、‘specint’によって計算されたラプラス変換のいくつか
     の例を表示します。

     例:

          (%i1) assume (p > 0, a > 0)$
          (%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                                     sqrt(%pi)
          (%o2)                     ------------
                                           a 3/2
                                    2 (p + -)
                                           4
          (%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
                        * exp(-p*t), t);
                                             - a/p
                                   sqrt(a) %e
          (%o3)                    ---------------
                                          2
                                         p

     指数積分の例:

          (%i4) assume(s>0,a>0,s-a>0)$
          (%i5) ratsimp(specint(%e^(a*t)
                                *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                                       log(s)
          (%o5)                        ------
                                       s - a
          (%i6) logarc:true$

          (%i7) gamma_expand:true$

          (%i8) radcan(specint((cos(t)*expintegral_si(t)
                               -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                                       log(s)
          (%o8)                        ------
                                        2
                                       s  + 1
          (%i9) ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                                -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                                         2    2
                                    log(s  + a )
          (%o9)                     ------------
                                          2
                                         s

     ‘gamma_incomplete’の展開を使った時と、 ‘expintegral_e1’への表現の変
     形を使った時のの結果:

          (%i10) assume(s>0)$
          (%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                                      1
                                      gamma_incomplete(-, k s)
                                                      2
          (%o11)                      ------------------------
                                         sqrt(%pi) sqrt(s)

          (%i12) gamma_expand:true$
          (%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                        erfc(sqrt(k) sqrt(s))
          (%o13)                        ---------------------
                                               sqrt(s)

          (%i14) expintrep:expintegral_e1$
          (%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                                        a s
                                  a s %e    expintegral_e1(a s) - 1
          (%o15)                - ---------------------------------
                                                  a

 -- 関数: hgfred (<a>, <b>, <t>)

     一般化超幾何関数を他のより簡単な形式に整理します。 <a>は分子パラメ
     ータのリストで、<b>は分母パラメータのリストです。

     もし‘hgfred’が超幾何関数を整理できなければ、 形式‘%f[p,q]([a], [b],
     x)’の式を返します。 ここで<p>は<a>の中の要素の数で、 <q>は<b>の中の
     要素の数です。 これは、通常の‘pFq’一般化超幾何関数です。

          (%i1) assume(not(equal(z,0)));
          (%o1)                          [notequal(z, 0)]
          (%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                               v/2                               %i z
                              4    bessel_j(v, z) gamma(v + 1) %e
          (%o2)               ---------------------------------------
                                                 v
                                                z
          (%i3) hgfred([1,1],[2],z);

                                             log(1 - z)
          (%o3)                            - ----------
                                                 z
          (%i4) hgfred([a,a+1/2],[3/2],z^2);

                                         1 - 2 a          1 - 2 a
                                  (z + 1)        - (1 - z)
          (%o4)                   -------------------------------
                                           2 (1 - 2 a) z

     以下の例が示すように、orthopolyもロードすることは有益なことがありま
     す。 <L>は、一般化ラーゲル多項式であることに注意してください。

          (%i5) load("orthopoly")$
          (%i6) hgfred([-2],[a],z);

                                              (a - 1)
                                           2 L       (z)
                                              2
          (%o6)                            -------------
                                             a (a + 1)
          (%i7) ev(%);

                                            2
                                           z        2 z
          (%o7)                         --------- - --- + 1
                                        a (a + 1)    a

 -- 関数: lambert_w (<z>)
     ランバートW関数W(z)の主枝、 ‘z = W(z) * exp(W(z))’の解。

 -- 関数: nzeta (<z>)
     プラズマ分散関数 ‘nzeta(z) = %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))’

 -- 関数: nzetar (<z>)
     ‘realpart(nzeta(z))’を返します。

 -- 関数: nzetai (<z>)
     ‘imagpart(nzeta(z))’を返します。


File: maxima.info,  Node: Elliptic Functions,  Next: Limits,  Prev: Special Functions,  Up: Top

16 Elliptic Functions
*********************

* Menu:

* Introduction to Elliptic Functions and Integrals::
* Functions and Variables for Elliptic Functions::
* Functions and Variables for Elliptic Integrals::


File: maxima.info,  Node: Introduction to Elliptic Functions and Integrals,  Next: Functions and Variables for Elliptic Functions,  Up: Top

16.1 Introduction to Elliptic Functions and Integrals
=====================================================

Maximaは、Jacobiの楕円関数と不完全楕円積分のサポートを含みます。 これは
、数値評価はもちろんこれらの関数のシンボル操作を含みます。 これらの関数
の定義と、プロパティの多くは Abramowitz and Stegun, 16–17章にあります。
可能な限り、そこれで与えられた定義と関係を使います。

   特に、すべての楕円関数と積分は、 法kや率角\alphaの代わりにパラメータ
mを使います。

   これは、 楕円関数のために率角を使うAbramowitz and Stegunと違っている
ところです。 以下の関係は真です: m = k^2 and k = \sin(\alpha)

   楕円関数と積分は、主としてシンボル計算をサポートするように意図されて
います。 それ故に、関数と積分の導関数のほとんどが知られています。 しかし
ながら、もし浮動小数点値が与えられたなら、 浮動小数点の結果が返されます
。

   楕円関数と積分の他の性質のほとんどのサポートはまだ書かれていません。

   楕円関数のいくつかの例:
     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   楕円積分のいくつかの例:
     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   楕円関数と積分のサポートは、Raymond Toyによって書かれました。 Maximaの
配布を管理するGeneral Public License (GPL)の条件のもと置かれています。


File: maxima.info,  Node: Functions and Variables for Elliptic Functions,  Next: Functions and Variables for Elliptic Integrals,  Prev: Introduction to Elliptic Functions and Integrals,  Up: Top

16.2 Functions and Variables for Elliptic Functions
===================================================

 -- 関数: jacobi_sn (<u>, <m>)
     Jacobiの楕円関数sn(u,m)

 -- 関数: jacobi_cn (<u>, <m>)
     Jacobiの楕円関数cn(u,m).

 -- 関数: jacobi_dn (<u>, <m>)
     Jacobiの楕円関数dn(u,m).

 -- 関数: jacobi_ns (<u>, <m>)
     Jacobiの楕円関数ns(u,m) = 1/sn(u,m).

 -- 関数: jacobi_sc (<u>, <m>)
     Jacobiの楕円関数sc(u,m) = sn(u,m)/cn(u,m).

 -- 関数: jacobi_sd (<u>, <m>)
     Jacobiの楕円関数sd(u,m) = sn(u,m)/dn(u,m).

 -- 関数: jacobi_nc (<u>, <m>)
     Jacobiの楕円関数nc(u,m) = 1/cn(u,m).

 -- 関数: jacobi_cs (<u>, <m>)
     Jacobiの楕円関数cs(u,m) = cn(u,m)/sn(u,m).

 -- 関数: jacobi_cd (<u>, <m>)
     Jacobiの楕円関数cd(u,m) = cn(u,m)/dn(u,m).

 -- 関数: jacobi_nd (<u>, <m>)
     Jacobiの楕円関数nc(u,m) = 1/cn(u,m).

 -- 関数: jacobi_ds (<u>, <m>)
     Jacobiの楕円関数ds(u,m) = dn(u,m)/sn(u,m).

 -- 関数: jacobi_dc (<u>, <m>)
     Jacobiの楕円関数dc(u,m) = dn(u,m)/cn(u,m).

 -- 関数: inverse_jacobi_sn (<u>, <m>)
     Jacobiの楕円関数の逆関数sn(u,m).

 -- 関数: inverse_jacobi_cn (<u>, <m>)
     Jacobiの楕円関数の逆関数cn(u,m).

 -- 関数: inverse_jacobi_dn (<u>, <m>)
     Jacobiの楕円関数の逆関数dn(u,m).

 -- 関数: inverse_jacobi_ns (<u>, <m>)
     Jacobiの楕円関数の逆関数ns(u,m).

 -- 関数: inverse_jacobi_sc (<u>, <m>)
     Jacobiの楕円関数の逆関数sc(u,m).

 -- 関数: inverse_jacobi_sd (<u>, <m>)
     Jacobiの楕円関数の逆関数sd(u,m).

 -- 関数: inverse_jacobi_nc (<u>, <m>)
     Jacobiの楕円関数の逆関数nc(u,m).

 -- 関数: inverse_jacobi_cs (<u>, <m>)
     Jacobiの楕円関数の逆関数cs(u,m).

 -- 関数: inverse_jacobi_cd (<u>, <m>)
     Jacobiの楕円関数の逆関数cd(u,m).

 -- 関数: inverse_jacobi_nd (<u>, <m>)
     Jacobiの楕円関数の逆関数nc(u,m).

 -- 関数: inverse_jacobi_ds (<u>, <m>)
     Jacobiの楕円関数の逆関数ds(u,m).

 -- 関数: inverse_jacobi_dc (<u>, <m>)
     Jacobiの楕円関数の逆関数dc(u,m).


File: maxima.info,  Node: Functions and Variables for Elliptic Integrals,  Prev: Functions and Variables for Elliptic Functions,  Up: Top

16.3 Functions and Variables for Elliptic Integrals
===================================================

 -- 関数: elliptic_f (<phi>, <m>)
     以下のように定義された第一種不完全楕円積分

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     *note elliptic_e::と*note elliptic_kc::も参照してください。

 -- 関数: elliptic_e (<phi>, <m>)
     以下のように定義された第二種不完全楕円積分

     elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     *note elliptic_e::と*note elliptic_ec::も参照してください。

 -- 関数: elliptic_eu (<u>, <m>)
     以下のように定義された第二種不完全楕円積分

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     ここで、tau = sn(u,m).

     これは、

     elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m) によって
     elliptic_eと関連付けられます。

     *note elliptic_e::も参照してください。

 -- 関数: elliptic_pi (<n>, <phi>, <m>)
     以下のように定義された第三種不完全楕円積分

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Maximaが知っているphiに関する唯一の導関数

 -- 関数: elliptic_kc (<m>)
     以下のように定義された第一種完全楕円積分

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     mのある値に関して 積分の値はGamma関数で表されることが知られています
     。 それらを評価するには‘makegamma’を使ってください。

 -- 関数: elliptic_ec (<m>)
     以下のように定義された第二種完全楕円積分

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     mのある値に関して 積分の値はGamma関数で表されることが知られています
     。 それらを評価するには‘makegamma’を使ってください。


File: maxima.info,  Node: Limits,  Next: Differentiation,  Prev: Elliptic Functions,  Up: Top

17 Limits
*********

* Menu:

* Functions and Variables for Limits::


File: maxima.info,  Node: Functions and Variables for Limits,  Prev: Limits,  Up: Limits

17.1 Functions and Variables for Limits
=======================================

 -- オプション変数: lhospitallim
     Default: 4

     ‘lhospitallim’は、 ‘limit’の中で使われるロピタルの規則の回数の最大
     数です。 これは ‘limit (cot(x)/csc(x), x, 0)’のような場合の 無限ル
     ープを防ぎます。

 -- 関数: limit (<expr>, <x>, <val>, <dir>)
 -- 関数: limit (<expr>, <x>, <val>)
 -- 関数: limit (<expr>)

     実変数<x>が値<val>に方向<dir>に近づく時の <expr>の極限を計算します
     。 <dir>は、上からの極限には値‘plus’を、下からの極限には‘minus’を持
     ち、 また、 (両側極限が計算されることを暗示して)省略することもあり
     ます。

     ‘limit’は以下の特殊シンボルを使います: ‘inf’ (正の無限大)と‘minf’
     (負の無限大) 出力時には、‘und’ (未定義), ‘ind’ (不定しかし有界),
     ‘infinity’ (複素無限大)も使うことがあります。

     式の絶対値の極限は正の無限大ですが、式自体の極限は正の無限大でも負
     の無限大でもない時、 ‘infinity’(複素数の無限大)が返されます。 これ
     は、‘limit(log(x), x, minf)’のように複素偏角の極限が定数である場合
     、 ‘limit((-2)^x, x, inf)’のように複素偏角が振動する場合、
     ‘limit(1/x, x, 0)’や‘limit(log(x), x, 0)’のように複素偏角が左右の極
     限のいずれかで異なる場合を、 を含みます。

     ‘lhospitallim’は、 ‘limit’の中で使われるロピタルの規則の回数の最大
     数です。 これは ‘limit (cot(x)/csc(x), x, 0)’のような場合の 無限ル
     ープを防ぎます。

     ‘tlimswitch’が‘true’の時、 必要な時‘limit’コマンドがテイラー級数展
     開を使うことを許します。

     ‘limsubst’は、 ‘limit’が未知の形式の上の代入を試みることを防ぎます
     。 これは、1を与える‘limit (f(n)/f(n+1), n, inf)’のようなバグを避け
     るためです。 ‘limsubst’を‘true’に設定することはそんな代入を許します
     。

     例えば、‘limit (inf-1)’のように、 定数式を整理するために、引数１つ
     の‘limit’がしばしばコールされます。

     ‘example (limit)’はいくつかの例を表示します。

     方法に関して、 Wang, P., "Evaluation of Definite Integrals by
     Symbolic Manipulation", Ph.D. thesis, MAC TR-92, October 1971を参照
     してください。

 -- オプション変数: limsubst
     デフォルト値: ‘false’ - ‘limit’が未知の形式の上の代入を試みることを
     防ぎます。

     これは、1を与える‘limit (f(n)/f(n+1), n, inf)’のようなバグを避ける
     ためです。 ‘limsubst’を‘true’に設定することはそんな代入を許します。
     ‘limit’が未知の形式上で代入をしようとするのを防ぎます。

 -- 関数: tlimit (<expr>, <x>, <val>, <dir>)
 -- 関数: tlimit (<expr>, <x>, <val>)
 -- 関数: tlimit (<expr>)

     ‘expr’の‘x’に関する‘val’ でのテイラー級数展開の方向‘dir’からの極限
     を取ります。

 -- オプション変数: tlimswitch
     デフォルト値: ‘true’

     ‘tlimswitch’が‘true’の時、 ‘limit’コマンドは もし入力式が直接計算で
     きないなら、 テイラー級数展開を使います。 これは、
     ‘limit(x/(x-1)-1/log(x),x,1,plus)’のような 極限の評価を許します。
     ‘tlimswitch’が‘false’で、 入力式の極限は直接には計算できない時は、
     ‘limit’は、未評価の極限式を返します。


File: maxima.info,  Node: Differentiation,  Next: Integration,  Prev: Limits,  Up: Top

18 Differentiation
******************

* Menu:

* Functions and Variables for Differentiation::  


File: maxima.info,  Node: Functions and Variables for Differentiation,  Prev: Differentiation,  Up: Differentiation

18.1 Functions and Variables for Differentiation
================================================

 -- 関数: antid (<expr>, <x>, <u(x)>)

     <expr>の<x>に関する不定積分がリストから構成できるような、 ２要素リ
     ストを返します。 式<expr>は、未知の関数<u>とその導関数を含むことが
     できます。

     Let ２要素リスト<L>が‘antid’の戻り値だとします。 ‘<L>[1] +
     'integrate (<L>[2], <x>)’は <expr>の<x>に関する不定積分です。

     ‘antid’が完全に成功した時、 戻り値の２番目の要素はゼロです。 そうで
     なければ、２番目の要素は非ゼロで、最初の要素は非ゼロまたはゼロです
     。 もし‘antid’が全く進展できなければ、 最初の要素はゼロで、２番目は
     非ゼロです。

     ‘load ("antid")’はこの関数をロードします。 ‘antid’パッケージは、関
     数‘nonzeroandfreeof’と‘linear’も定義します。

     ‘antid’は、以下のように‘antidiff’と関係します。 ２要素リスト<L>が
     ‘antid’の戻り値とします。 ‘antidiff’の戻り値は、‘<L>[1] +
     'integrate (<L>[2], <x>)’に 等しいです。 ここで、<x>は積分変数です
     。

     例:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- 関数: antidiff (<expr>, <x>, <u>(<x>))

     <expr>の<x>に関する不定積分を返します。 式<expr>は、未知の関数<u>と
     その導関数を含むことができます。

     ‘antidiff’が完全に成功した時、 結果の式は、積分記号を含みません(す
     なわち、‘integrate’名詞を含みません)。 そうでなければ、‘antidiff’は
     部分的にまたは完全に積分記号内にある式を返します。 もし‘antidiff’が
     全く進展ができないなら、 戻り値は完全に積分記号内にあります。

     ‘load ("antid")’はこの関数をロードします。 ‘antid’パッケージは、関
     数‘nonzeroandfreeof’と‘linear’も定義します。

     ‘antidiff’は、以下のように‘antid’と関係します。 ２要素リスト<L>が
     ‘antid’の戻り値とします。 ‘antidiff’の戻り値は、‘<L>[1] +
     'integrate (<L>[2], <x>)’に 等しいです。 ここで、<x>は積分変数です
     。

     例:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /

 -- 関数: at (<expr>, [<eqn_1>, …, <eqn_n>])
 -- 関数: at (<expr>, <eqn>)
     等式のリスト‘[<eqn_1>, ..., <eqn_n>]’ もしくは１つの等式<eqn>の中で
     指定されたように値を仮定された変数で、 式<expr>を評価します。

     もしも部分式が、値が指定される変数のいずれかに依存するが 指定の
     ‘atvalue’がなく、他の方法で評価できないなら、 ‘at’の名詞形が返され
     、２次元形式で表示されます。

     ‘at’は多重代入を並列に実行します。

     ‘atvalue’も参照してください。 代入を実行する他の関数に関しては、
     ‘subst’や‘ev’も参照してください。

     例:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x, y)^2 - u(x, y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- Property: atomgrad

     ‘atomgrad’は、式のアトムのグラディエントプロパティです。 このプロパ
     ティは‘gradef’で割り当てられます。

 -- 関数: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- 関数: atvalue (<expr>, <x_1> = <a_1>, <c>)

     値<c>を 点‘<x> = <a>’の<expr>に割り当てます。 典型的には、境界値は
     このメカニズムによって確立されます。

     <expr>は、関数引数が陽に現れる 関数評価 ‘<f>(<x_1>, ..., <x_m>)’ま
     たは 導関数 ‘diff (<f>(<x_1>, ..., <x_m>), <x_1>, <n_1>, ...,
     <x_n>, <n_m>)’ です。 <n_i>は、<x_i>に関する微分の階数です。

     atvalueが確立される点は、等式のリスト‘[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]’ によって与えられます。 もし１変数<x_1>なら、 リストとしてく
     くられることなしに１つの等式は与えられます。

     ‘printprops ([<f_1>, <f_2>, ...], atvalue)’は ‘atvalue’コールによっ
     て指定されるような 関数‘<f_1>, <f_2>, ...’のatvalueを表示します。

     ‘printprops (<f>, atvalue)’は、 １関数<f>のatvalueを表示します。
     ‘printprops (all, atvalue)’は、 atvaluesが定義された関数すべての
     atvalueを表示します。

     atvaluesが表示される時、 シンボル‘@1’, ‘@2’, … は 変数<x_1>, <x_2>,
     …を表します。

     ‘atvalue’は引数を評価します。 ‘atvalue’はatvalue<c>を返します。

     例:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1

 -- 関数: cartan

     微分形式の外積代数は エリーカルタンによって開発された微分幾何の基本
     ツールであり、 偏微分方程式論での有用な応用を持ちます。 ‘cartan’パ
     ッケージは、 演算子‘~’ (ウェッジ積)と‘|’ (形式のベクトルとの縮約)と
     一緒に、 関数‘ext_diff’と‘lie_diff’を実装します。 例と一緒にこれら
     のコマンドの簡潔な記述を見るには、‘demo (tensor)’を実行してください
     。

     ‘cartan’は、F.B. EstabrookとH.D. Wahlquistによって実装されました。

 -- 関数: del (<x>)

     ‘del (<x>)’は、変数xの微分を表します。

     もし独立変数が指定されないなら、 ‘diff’は、‘del’を含む式を返します
     。 この場合、戻り値は「全微分」と呼ばれるものです。

     例:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)

 -- 関数: delta (<t>)

     Diracのデルタ関数

     今のところ、‘laplace’だけが‘delta’を知っています。

     例:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e

 -- システム変数: dependencies
     デフォルト値: ‘[]’

     ‘dependencies’は、 ‘depends’や‘gradef’によって割り当てられた、関数
     依存を持つアトムのリストです。 ‘dependencies’リストは累積的です:
     each call to ‘depends’や‘gradef’のコールそれぞれは、上乗せの項目を
     追加します。

     ‘depends’と‘gradef’を参照してください。

 -- 関数: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)

     導関数を計算するために、変数の間の関数依存を宣言します。 宣言された
     依存関係なしでは、 ‘diff (f, x)’はゼロをもたらします。 もし‘depends
     (f, x)’が宣言されたら、 ‘diff (f, x)’はシンボリックな導関数(すなわ
     ち、‘diff’名詞)をもたらします。

     それぞれの引数<f_1>, <x_1>, などは、 変数や配列の名前、または名前の
     リストをとり得ます。 <f_i> (多分ただ１つの要素)のすべての要素は、
     <x_i> (多分ただ１つの要素)のすべての要素に依存するように宣言されま
     す。 もしいくつかの<f_i>が、配列名だったり、配列名を含むなら、 配列
     の要素すべては<x_i>に依存します。

     ‘diff’は、‘depends’によって確立された間接的依存関係を認識し、 これ
     らの場合に連鎖規則を適用します。

     ‘remove (<f>, dependency)’は、<f>に関して宣言された 依存関係すべて
     を取り除きます。

     ‘depends’は、確立された依存関係のリストを返します。 依存関係はグロ
     ーバル変数‘dependencies’に適用されます。 ‘depends’は引数を評価しま
     す。

     ‘diff’は、 ‘depends’によって確立された依存関係を認識する唯一の
     Maximaコマンドです。 他の関数(‘integrate’, ‘laplace’, など)は、 引
     数によって陽に表現された依存関係だけを認識します。 例えば、
     ‘integrate’は、 ‘integrate (f(x), x)’のように陽に表現されないなら、
     ‘f’の‘x’への依存性を認識しません。

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt

 -- オプション変数: derivabbrev
     デフォルト値: ‘false’

     ‘derivabbrev’が‘true’の時、 シンボリックな導関数(すなわち、‘diff’名
     詞)が下付き添字として表示されます。 そうでなければ、導関数はライプ
     ニッツ表記‘dy/dx’で表示されます。

 -- 関数: derivdegree (<expr>, <y>, <x>)

     <expr>に現れる独立変数<x>に関する 従属変数<y>の微分の最高階数を返し
     ます。

     例:

          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2

 -- 関数: derivlist (<var_1>, …, <var_k>)

     ‘ev’コマンド内にて、指摘された変数に関する微分のみを起こします。

 -- オプション変数: derivsubst
     デフォルト値: ‘false’

     ‘derivsubst’が‘true’の時、 ‘subst (x, 'diff (y, t), 'diff (y, t,
     2))’ のような非構文法的代入は‘'diff (x, t)’をもらします。

 -- 関数: diff (<expr>, <x_1>, <n_1>, …, <x_m>, <n_m>)
 -- 関数: diff (<expr>, <x>, <n>)
 -- 関数: diff (<expr>, <x>)
 -- 関数: diff (<expr>)

     <expr>の中のすべての変数の中のいくつかに関する、<expr>の導関数すな
     わち微分を返します。

     ‘diff (<expr>, <x>, <n>)’は<x>に関する<expr>の<n>階微分を返します。

     ‘diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)’は <x_1>, ...,
     <x_m>に関する<expr>の偏微分を返します。 これは、‘diff (... (diff
     (<expr>, <x_m>, <n_m>) ...), <x_1>, <n_1>)’と同値です。

     ‘diff (<expr>, <x>)’は変数<x>に関する<expr>の1階微分を返します。

     ‘diff (<expr>)’は<expr>の全微分を返します。 すなわち、それぞれの変
     数に関する<expr>の微分に変数それぞれの微分‘del’を掛けたものの和を返
     します。 ‘del’の更なる整理は提供されません。

     ‘diff’の名詞形式が、微分方程式を記述する時など、いくつかの文脈で要
     求されます。 これらの場合、‘diff’は、微分が実行される代わりに名詞形
     式を出力するために (‘'diff’として)クォートされるかもしれません。

     ‘derivabbrev’が‘true’の時、導関数は下付き添字として表示されます。 そ
     うでなければ、導関数はライブニツ記法の‘dy/dx’で表示されます。

     例:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     テンソルパッケージのために、以下の変更が取り込まれています:

     (1) <expr>の中の任意のインデックスされたオブジェクトの導関数は、追
     加された引数として添えられた変数<x_i>を持ちます。 そして導関数のイ
     ンデックスはすべてソートされます。

     (2) <x_i>は、1から変数‘dimension’ [デフォルト値: 4]の値までの整数を
     取ります。 これにより、例えば ‘[x, y, z, t]’など 座標名のリストして
     設定されたリスト‘coordinates’の<x_i>番目のメンバーに関する微分が実
     行されます。 もし‘coordinates’がアトムの変数にバインドされているな
     ら、<x_i>で下付き添字された変数が、微分の変数として使われます。 こ
     れにより、座標名や‘X[1]’, ‘X[2]’, …のような下付き添字された名前の配
     列が使えることになります。 もし‘coordinates’に値が割り当てられてい
     ないなら、変数は上の(1)のように扱われます。

 -- 特殊シンボル: diff

     ‘ev’コールの中で、‘evflag’として‘diff’が存在する時、 ‘expr’の中で表
     現されたすべての微分は実行されます。

 -- 関数: dscalar (<f>)

     スカラーのダランベルシアンをスカラー関数に<f>に適用します。

     ‘load ("ctensor")’はこの関数をロードします。

 -- 関数: express (<expr>)

     微分演算子名詞を偏微分を使った式に展開します。 ‘express’は、演算子
     ‘grad’, ‘div’, ‘curl’, ‘laplacian’を 認識します。 ‘express’は、外積
     ‘~’も展開します。

     expressの戻り値の中のシンボリックな導関数(すなわち、‘diff’名詞)は、
     ‘ev’関数コールまたはコマンドラインに‘diff’を含むことによって、評価
     されることができます。 この文脈では、‘diff’は‘evfun’として振る舞い
     ます。

     ‘load ("vect")’はこの関数をロードします。

     例:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]

 -- 関数: gradef (<f>(<x_1>, …, <x_n>), <g_1>, ..., <g_m>)
 -- 関数: gradef (<a>, <x>, <expr>)

     関数<f>もしくは変数<a>の偏微分（すなわち、勾配の成分）を定義します
     。

     ‘gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)’は、
     ‘d<f>/d<x_i>’を<g_i>として定義します。 ここで、<g_i>は式です;
     <g_i>は関数コールでもあり得ますが、関数名ではありません。 偏微分の
     数<m>は、引数の数<n>よりもちいさいかもしれません。 その場合、微分は
     <x_1>から<x_m>までのみに関して定義されます。

     ‘gradef (<a>, <x>, <expr>)’は、 変数<a>の<x>に関する微分を<expr>と
     定義します。 これは、 (‘depends (<a>, <x>)’を介して) <a>の<x>への依
     存性を確立もします。

     最初の引数‘<f>(<x_1>, ..., <x_n>)’または<a>はクォートされますが、 残
     りの引数<g_1>, ..., <g_m>は評価されます。 ‘gradef’は偏微分が定義さ
     れた関数や変数を返します。

     ‘gradef’は、Maximaの組み込み関数の微分を再定義できます。 例えば、
     ‘gradef (sin(x), sqrt (1 - sin(x)^2))’は、 ‘sin’の微分を再定義しま
     す。

     ‘gradef’は、添字付き関数の偏微分を定義できません。

     ‘printprops ([<f_1>, ..., <f_n>], gradef)’は、 関数<f_1>, ...,
     <f_n>の偏微分を ‘gradef’で定義されたように、表示します。

     ‘printprops ([<a_n>, ..., <a_n>], atomgrad)’は、 変数<a_n>, ...,
     <a_n>の偏微分を ‘gradef’で定義されたように、表示します。

     ‘gradefs’は、偏微分が‘gradef’によって定義された 関数のリストです。
     ‘gradefs’は、 偏微分が‘gradef’によって定義されたいかなる変数も含み
     ません。

     例えば、関数が陽に知られていないが、一階微分が知られていて、 高階の
     微分を得ることが望まれる時、勾配が必要です。

 -- システム変数: gradefs
     デフォルト値: ‘[]’

     ‘gradefs’は、偏微分が‘gradef’によって定義された 関数のリストです。
     ‘gradefs’は、 偏微分が‘gradef’によって定義されたいかなる変数も含み
     ません。

 -- 関数: laplace (<expr>, <t>, <s>)

     変数<t>に関するラブラス変換<expr>を計算し、パラメータ<s>に変換しよ
     うとします。

     ‘laplace’は、 <expr>の中で、 ‘derivative’, ‘integrate’, ‘sum’,
     ‘ilt’はもちろん、 関数‘delta’, ‘exp’, ‘log’, ‘sin’, ‘cos’, ‘sinh’,
     ‘cosh’, and ‘erf’ を認識します。 もし、laplaceが変換を見つけられな
     かったら、 関数‘specint’がコールされます。 ‘specint’は、 ベッセル関
     数‘bessel_j’, ‘bessel_i’, …のような 特殊関数を含む式のラプラス変換
     を見つけることができ、 ‘unit_step’関数を扱うことができます。
     ‘specint’も参照してください。

     もし‘specint’も解を見つけられないなら、 名詞‘laplace’が返されます。

     <expr>は、従属変数の‘atvalue’が使われる線形定数係数微分方程式である
     かもしれません。 要求されるatvalueは、 変換が計算される前か後に供給
     されるかもしれません。 初期条件がゼロで指定されなければいけないので
     、 もし他に課される境界条件を持つなら 一般解にそれらを課すことがで
     き、それらに関して一般解を解き、それらの値を代入し返すことによって
     、 定数を消去できます。

     ‘laplace’は、形式 ‘integrate (f(x) * g(t - x), x, 0, t)’の畳み込み
     積分を認識します; 他の種類の畳み込みは認識されません。

     関数関係は、 <expr>で陽に表現されなければいけません; ‘depends’で確
     立した暗黙の関係は認識されません。 例えば、もし<f>が<x>と<y>に依存
     するなら、 ‘f (x, y)’が<expr>の中に現れなければいけません。

     逆ラプラス変換‘ilt’も参照してください。

     例:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0
          (%i5) assume(a>0)$
          (%i6) laplace(gamma_incomplete(a,t),t,s),gamma_expand:true;
                                                        - a - 1
                                   gamma(a)   gamma(a) s
          (%o6)                    -------- - -----------------
                                      s            1     a
                                                  (- + 1)
                                                   s
          (%i7) factor(laplace(gamma_incomplete(1/2,t),t,s));
                                                        s + 1
                                sqrt(%pi) (sqrt(s) sqrt(-----) - 1)
                                                          s
          (%o7)                 -----------------------------------
                                          3/2      s + 1
                                         s    sqrt(-----)
                                                     s
          (%i8) assume(exp(%pi*s)>1)$
          (%i9) laplace(sum((-1)^n*unit_step(t-n*%pi)*sin(t),n,0,inf),t,s),
                   simpsum;
                                   %i                         %i
                        ------------------------ - ------------------------
                                        - %pi s                    - %pi s
                        (s + %i) (1 - %e       )   (s - %i) (1 - %e       )
          (%o9)         ---------------------------------------------------
                                                 2
          (%i9) factor(%);
                                                %pi s
                                              %e
          (%o9)                   -------------------------------
                                                       %pi s
                                  (s - %i) (s + %i) (%e      - 1)


File: maxima.info,  Node: Integration,  Next: Equations,  Prev: Differentiation,  Up: Top

19 Integration
**************

* Menu:

* Introduction to Integration::
* Functions and Variables for Integration::
* Introduction to QUADPACK::
* Functions and Variables for QUADPACK::


File: maxima.info,  Node: Introduction to Integration,  Next: Functions and Variables for Integration,  Prev: Integration,  Up: Integration

19.1 Introduction to Integration
================================

Maximaは、積分を扱うためのいくつかのルーチンを持っています。
‘integrate’関数はそれらのほとんどを利用します。 指定されていない関数（と
もちろんその導関数）を扱う‘antid’パッケージもあります。 数値目的のために
は、 ‘quad_qag’, ‘quad_qags’などと名付けられたQUADPACKから適応積分器一式
があります。 それらは見出し‘QUADPACK’の下で記述されています。 超幾何関数
を扱うことができます。詳細は‘specint’を参照してください。 一般的に言って
、Maximaは 「初等関数」（有理関数、三角関数、対数、指数関数、根号など）
と２、３の拡張（誤差関数、二重対数関数）を使った積分可能な積分だけを扱い
ます。 ‘g(x)’や‘h(x)’と言った未知の関数を使った積分を扱いません。


File: maxima.info,  Node: Functions and Variables for Integration,  Next: Introduction to QUADPACK,  Prev: Introduction to Integration,  Up: Integration

19.2 Functions and Variables for Integration
============================================

 -- 関数: changevar (<expr>, <f(x,y)>, <y>, <x>)

     <x>に関する積分を含む<expr>の中に現れるすべての積分に関して、
     ‘<f(x,y)> = 0’で与えられる変数変換を生成します。 新しい変数は<y>で
     す。

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     上の‘'integrate’のインスタンスのように、名詞形を含む式は ‘nouns’フ
     ラグありの‘ev’によって評価されるかもしれません。 例えば、上の
     ‘changevar’が返す式は‘ev (%o3, nouns)’で評価することができます。

     ‘changevar’は、 和や積のインデックスに関する変更にも使えます。 しか
     しながら、 変更が和や積の中でなされる時、 この変更はシフトすなわち
     ‘i = j+ ...’ でなければならず、高階関数ではなことをはっきり理解しな
     ければいけません。 例えば、

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2

 -- 関数: dblint (<f>, <r>, <s>, <a>, <b>)

     トップレベルMaximaで書かれ、翻訳され機械語にコンパイルされた二重積
     分ルーチン。 このパッケージをアクセスするには‘load ("dblint")’を使
     ってください。 以下を計算するため、xとy方向に関して シンプソンの規
     則方法を使います。

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     関数<f>は、２つの変数の翻訳されコンパイルされた関数でなければいけな
     く、 <r>と<s>はそれぞれ、翻訳されコンパイルされた変数でなければいけ
     ません。 一方で、<a>と<b>は浮動小数点数でなければいけません。 ルー
     チンは、 xとyの区間の分割の数を決める２つのグローバル変数を持ちます
     : ‘dblint_x’と‘dblint_y’, 両方とも初期は10で、他の整数値（x方向に計
     算される‘2*dblint_x+1’点があり、 y方向に計算される‘2*dblint_y+1’点
     があります）に独立に変えることができます。 ルーチンは、X軸を更に分
     割します。 Xのそれぞれの値に関して、最初、 ‘<r>(x)’と‘<s>(x)’を計算
     します; そして‘<r>(x)’と‘<s>(x)’の間でY軸が更に分割され、 シンプソ
     ン規則を使ってY軸に沿っての積分が実行されます; そして、 シンプソン
     規則を使って Y積分である関数値を用いてX軸に沿っての積分が実行されま
     す; この手続きは、様々な理由のため数値的に不安定かもしれませんが、
     かなり速いです: 非常に振動的な関数や特異点（領域内の極や分岐点）を
     持つ関数にこれを使うことは避けてください。 Y積分は、‘<r>(x)’と
     ‘<s>(x)’がどこくらい離れているかに依存します。 だから、もし距離
     ‘<s>(x) - <r>(x)’がXに関して急速に変化するなら、 様々なY積分での異
     なるステップサイズでの切り詰めから起こる本質的なエラーがあるかもし
     れません。 領域の範囲を改善するために、計算時間という犠牲を払って、
     ‘dblint_x’と‘dblint_y’を増やすことができます。 関数値は保存されない
     ので、もし関数が非常に時間がかかるものなら、 もし何か変えたら再計算
     を待たなければいけません（すいません）。 関数<f>, <r>, <s>は、
     ‘dblint’コールの前に、翻訳されるかコンパイルされるかどちらかが要求
     されます。 これは、多くの場合、インタープリタコードに対して桁違いの
     速度改善がなされるでしょう！

     ‘demo (dblint)’は、 例の問題に適用された‘dblint’のデモンストレーシ
     ョンを実行します。

 -- 関数: defint (<expr>, <x>, <a>, <b>)

     定積分を計算しようとします。 ‘integrate’は、 積分の範囲が指定されて
     いる時、 すなわち、‘integrate’が ‘integrate (<expr>, <x>, <a>,
     <b>)’としてコールされた時、 ‘defint’をコールします。

     このように、ユーザーの観点からは、‘integrate’をコールすることは十分
     です。

     ‘defint’は、シンボリック式、計算された積分または積分の名詞形、 を返
     します。 定積分の数値近似に関しては、‘quad_qag’と関連関数を参照して
     ください。

 -- オプション変数: erfflag
     デフォルト値: ‘true’

     ‘erfflag’が‘false’の時、 ‘risch’が もしまず第一に被積分になにもない
     なら、 答えの中に‘erf’関数を導入することを妨げます。

 -- 関数: ilt (<expr>, <s>, <t>)

     <expr>の<s>とパラメータ<t>に関する逆ラプラス変換を計算します。
     <expr>は、 分子は線形２次因子だけを持つ多項式の比でなければいけませ
     ん。 ‘solve’または‘linsolve’と合わせて 関数‘laplace’や‘ilt’を使うこ
     とによって ユーザーは１つの微分または畳み込み積分方程式やそれらの組
     を解くことができます。

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a

 -- オプション変数: intanalysis
     デフォルト値: ‘true’

     ‘true’の時、定積分は、積分区間内の被積分関数の極を見つけようとしま
     す。 もしあれば、積分は主値積分として適切に評価されます。 もし
     intanalysisが‘false’なら、 このチェックは実行されず、積分は極がない
     ことを仮定して実行されます。

     ‘ldefint’も参照してください。

     例:

     ‘intanalysis’が‘false’に設定されている時 Maximaは以下の積分を解くこ
     とができます:

          (%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                          1
                                         /
                                         [       1
          (%o1)                          I  ----------- dx
                                         ]  sqrt(x) + 1
                                         /
                                          0

          (%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
          (%o2)                            2 - 2 log(2)

          (%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
          The number 1 isn't in the domain of atanh
           -- an error. To debug this try: debugmode(true);

          (%i4) intanalysis:false$
          (%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                                %pi
          (%o5)                                 ---
                                                 2

 -- 関数: integrate (<expr>, <x>)
 -- 関数: integrate (<expr>, <x>, <a>, <b>)
     <x>に関する<expr>の積分をシンボリックに計算しようとします。
     ‘integrate (<expr>, <x>)’は不定積分で、 ‘integrate (<expr>, <x>,
     <a>, <b>)’は<a>,<b>の上限下限を持つ定積分です。 ‘integrate’はこの制
     限を強制しませんが、上限下限は<x>を含んではいけません。 <a>は<b>よ
     り小さい必要はありません。 <b>が<a>と等しいなら、‘integrate’は0を返
     します。

     定積分の数値近似に関しては‘quad_qag’と関連関数を参照してください。
     （複素積分）留数の計算に関しては‘residue’を参照してください。 不定
     積分の代替計算方法に関しては‘antid’を参照してください。

     ‘integrate’が成功すれば、積分（‘integrate’を含まない式）を返します
     。 そうでなければ、積分の名詞形式（クォートされた演算子
     ‘'integrate’)もしくは１つ以上の名詞形式を含む式を返します。
     ‘integrate’の名詞形式は積分記号で表示されます。

     いくつかの環境では、（例えば、‘'integrate (<expr>, <x>)’のように、
     シングルクオートされた‘integrate’で手動で名詞形式を構成することが役
     に立ちます。 例えば、積分が、また計算されていないいくつかのパラメー
     タに依存しているかもしれません。 名詞は、<i>が注目の名詞形式である
     ところの‘ev (<i>, nouns)’によって、引数に適用されるかもしれません。

     ‘integrate’は不定積分とは別に、定積分を扱います。 それぞれの場合を
     扱うため、ある範囲の発見法を用意しています。 定積分の特別な場合は、
     0や無限大に等しい積分の下限上限を含んだり、 0や‘%pi’や‘2 %pi’に等し
     い下限上限を持つ三角関数を含んだり、 有理関数やベータやプサイ関数の
     定義に関連した積分やいくつかの対数的な積分、三角関数積分を含んだり
     します。 有理関数の処理は、留数の計算を含むかもしれません。 もし適
     用可能な特殊な場合が見つからなければ、不定積分を計算し、下限上限で
     それを評価しようとするでしょう。 これは、下限上限に無限大の極限を取
     ることを含みます。‘ldefint’も参照してください。

     不定積分の特殊な場合は、三角関数、指数対数関数、有理関数を含みます
     。 ‘integrate’は初等積分の短いテーブルもまた利用しています。

     もし非積分関数が形式‘f(g(x)) * diff(g(x), x)’を持つなら、
     ‘integrate’は、変数の交換を実行します。 ‘integrate’は、‘g(x)’の導関
     数が非積分関数を割るような部分式‘g(x)’を見つけようとします。 この探
     索は、‘gradef’関数によって定義された導関数を利用します。
     ‘changevar’や‘antid’も参照ください。

     もしこれまでの発見法のどれも不定積分を見つけられなければ、リッシュ
     のアルゴリズムが実行されます。 フラグ‘risch’が、‘ev’のコールやコマ
     ンドライン上で‘evflag’として設定されるかもしれません。 例えば、‘ev
     (integrate (<expr>, <x>), risch)’や ‘integrate (<expr>, <x>),
     risch’というように。 もし‘risch’が‘true’なら、‘integrate’は、発見法
     を最初に試さずに、‘risch’関数をコールします。 ‘risch’も参照ください
     。

     ‘integrate’は‘f(x)’記法で陽に表現された関数関係のみに動作します。
     ‘integrate’は‘depends’関数で規定された陰の依存性を考慮しません。

     ‘integrate’は非積分関数のパラメータのある性質を知っている必要がある
     場合があります。 ‘integrate’は‘assume’データベースを最初に参照し、
     注目の変数がそこになければ、‘integrate’はユーザーに問い合わせます。
     質問に依存して、適切な応答は、‘yes;’や‘no;’や‘pos;’, ‘zero;’,
     ‘neg;’など。

     ‘integrate’は線形には宣言されていません。‘declare’と‘linear’を参照
     ください。

     ‘integrate’は２、３の特集な場合だけ、部分積分を企てます。

     例:

        • 初等不定積分、定積分

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        • ‘assume’と対話的問い合わせの利用

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        • 変数変換。この例では２回変数変換があります。 ‘gradef’で規定さ
          れた導関数を使ったものと未知関数‘r(x)’の微分‘diff(r(x))’を使っ
          たもの。

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        • ‘'integrate’名詞形を含む戻り値。 この例では、Maximaは有理関数
          の分母の因子を抽出できますが、剰余を因数分解できないか積分をみ
          つけられません。 ‘grind’は、結果として名詞形‘'integrate’を示し
          ます。 積分や有理関数について更に知るには
          ‘integrate_use_rootsof’も参照ください。

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        • 積分を使った関数の定義。 関数の本体は、関数が定義された時には
          評価されません。 この例では、‘f_1’の本体は、‘integrate’の名詞
          形を含みます。 クォートクォート演算子‘''’があると、積分が評価
          され、結果が‘f_2’の本体になります。

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600

 -- システム変数: integration_constant
     デフォルト値: ‘%c’

     積分定数は、等式の不定積分によって導入され、 定数名は、
     ‘integration_constant’と‘integration_constant_counter’を連結するこ
     とで構成されます。

     ‘integration_constant’は、任意のシンボルに割り当てられます。

     例:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integration_constant : 'k;
          (%o2)                           k
          (%i3) integrate (x^2 = 1, x);
                                      3
                                     x
          (%o3)                      -- = x + k2
                                     3

 -- システム変数: integration_constant_counter
     デフォルト値: 0

     積分定数が等式の不定積分によって導入された時、 定数名は、
     ‘integration_constant’と‘integration_constant_counter’を連結するこ
     とで構成されます。

     ‘integration_constant_counter’は、 次の積分定数を構成する前に増分さ
     れます。

     例:

          (%i1) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o1)                     -- = x + %c1
                                    3
          (%i2) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o2)                     -- = x + %c2
                                    3
          (%i3) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o3)                     -- = x + %c3
                                    3
          (%i4) reset (integration_constant_counter);
          (%o4)            [integration_constant_counter]
          (%i5) integrate (x^2 = 1, x);
                                     3
                                    x
          (%o5)                     -- = x + %c1
                                    3

 -- オプション変数: integrate_use_rootsof
     デフォルト値: ‘false’

     ‘integrate_use_rootsof’が‘true’かつ有理関数の分子が因数分解できない
     時、 ‘integrate’は、 分子の（まだ知られていない）根上の和という形式
     で積分を返します。

     例えば、 ‘integrate_use_rootsof’を‘false’に設定すると、
     ‘integrate’は、有理関数の未解決積分を名詞形で返します:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     さて、フラグを‘true’に設定し、 積分の未解決部分を 有理関数の分子の
     根上の和として表現しましょう:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                  3      2
                %r4 in rootsof(%r4  - %r4  + 1, %r4)
          (%o4) ----------------------------------------------------------
                         7

                                                                2 x + 1
                                            2            5 atan(-------)
                                       log(x  + x + 1)          sqrt(3)
                                     - --------------- + ---------------
                                             14             7 sqrt(3)

     代わりにユーザーは別々に分子の根を計算できます。 例えば、もし分子が
     3次多項式なら ‘1/((x - a)*(x - b)*(x - c))’または‘1/((x^2 - (a+b)*x
     + a*b)*(x - c))’ というように これらの根を使って被積分関数を表現で
     きます。 時々、これはMaximaがもっと役立つ結果を得るのを助けます。

 -- 関数: ldefint (<expr>, <x>, <a>, <b>)

     <expr>の<x>に関する不定積分を上限<b>と下限<a>で評価するために
     ‘limit’を使うことによって<expr>の定積分を計算しようとします。 もし
     定積分を計算するのに失敗したなら、 ‘ldefint’は、名詞形として極限を
     含む式を返します。

     ‘ldefint’は、‘integrate’からコールされないので、 o executing
     ‘ldefint (<expr>, <x>, <a>, <b>)’ を実行することは、 ‘integrate
     (<expr>, <x>, <a>, <b>)’ とは違った結果をもたらすかもしれません。
     ‘ldefint’は、定積分を評価するためにいつも同じ方法を使いますが、
     ‘integrate’は、様々な発見的方法を利用し、いくつかの特殊な場合を認識
     することもあります。

 -- 関数: potential (<givengradient>)

     計算は、 ‘nonlist’または形式
          [indeterminatej=expressionj, indeterminatek=expressionk, ...]
     でなければならないグローバル変数‘potentialzeroloc[0]’を利用します。
     ここで、前者は後者の中のすべての右辺のnonlist式と同値です（訳者無理
     解）。 示された右辺は、積分の下限として使われます。 積分の成功は、
     それらの値と順序に依存するかもしれません。 ‘potentialzeroloc’は、
     0に初期化されます。

 -- 関数: residue (<expr>, <z>, <z_0>)

     変数<z>が値<z_0>を仮定する時、 式<expr>の複素平面での留数を計算しま
     す。 留数は、 <expr>のローラン級数における ‘(<z> - <z_0>)^(-1)’の係
     数です。

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6

 -- 関数: risch (<expr>, <x>)

     リッシュアルゴリズムの超越な場合を使って、 <expr>を <x>に関して積分
     します。 （リッシュアルゴリズムの代数的な場合は実装されていません。
     ） これは、現在、‘integrate’の主要部ができない入れ子の指数関数や対
     数関数の場合を扱います。 ‘integrate’は、これらの場合が与えられたな
     ら、自動的に‘risch’を適用します。

     ‘erfflag’がもし‘false’なら、 もしまず第一に被積分関数になにもないな
     ら、 ‘risch’が 答えの中に‘erf’関数を導入することを妨げます。

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)

 -- 関数: tldefint (<expr>, <x>, <a>, <b>)

     ‘tlimswitch’が‘true’に設定されている‘ldefint’と同値です。


File: maxima.info,  Node: Introduction to QUADPACK,  Next: Functions and Variables for QUADPACK,  Prev: Functions and Variables for Integration,  Up: Integration

19.3 Introduction to QUADPACK
=============================

QUADPACKは、１次元定積分の数値計算のための関数のコレクションです。 R.
Piessens (1), E. de Doncker (2), C. Ueberhuber (3), D. Kahaner (4). の合
同プロジェクトから始まりました。

   Maximaに含まれるQUADPACKライブラリは、 SLATEC共通数学ライブラリ バー
ジョン4.1(5) に現れる QUADPACKのFortranのソースコードの (プログラム
‘f2cl’による)自動翻訳です。

   SLATECライブラリは1993年7月付ですが、QUADPACK関数は何年か前に書かれま
した。 QUADPACKももう１つのバージョンが Netlib (6)に あります; このバー
ジョンがSLATECバージョンとどう違うのかはっきりしません。

   Maximaに含まれるQUADPACK関数は、 これらの関数が、不特定の回数の関数の
評価を要求し、 指定された精度まで結果を計算しようとする意味で、 すべて自
動的です。 Maximaの、QUADPACKのLisp翻訳は、いくつかの自動的でない関数も
含みますが、 それらは、Maximaレベルで公開されていません。

   QUADPACKについての更なる情報は、 QUADPACK本 (7) の中に見つけることが
できます。

19.3.1 Overview
---------------

‘quad_qag’
     一般関数の有限の区間上の積分。 ‘quad_qag’は、Aind(Piessens, 1973)の
     戦略を使った 簡単な大域的適応積分器を実装しています。 呼び出し側は
     、ルール評価コンポーネントのための ガウスークロンロッドの求積公式の
     6つのペアの中から選ぶことができます。 強く振動する非積分関数には高
     次のルールが適切です。

‘quad_qags’
     一般関数の有限の区間上の積分。 ‘quad_qags’は、イプシロンアルゴリズ
     ム(Wynn, 1956)による外挿(de Doncker,1978)を 使った大域的適応積分器
     を実装しています。

‘quad_qagi’
     一般関数の無限のもしくは半無限の区間上の積分。 区間は、有限の区間上
     に写像され、‘quad_qags’の中で使われるのと同じ戦略が適用されます。

‘quad_qawo’
     cos(omega x) f(x) や sin(omega x) f(x) の有限の区間上の積分。 ここ
     で、 omega は定数です。 規則評価構成要素は、変形Clenshaw-Curtis手法
     に基づいています。 ‘quad_qawo’は、 ‘quad_qags’に似て、外挿とともに
     適応再分割を適用します。

‘quad_qawf’
     フーリエコサイン変換またはフーリエサイン変換を半無限区間上で計算し
     ます。 ‘quad_qawo’で使われるのと同じアプローチが、連続する区間に適
     用され、 イプシロンアルゴリズム(Wynn, 1956)を使った収束の促進が積分
     寄与の級数に適用されます。

‘quad_qaws’
     w(x) f(x) の有限区間 [a, b] 上の積分。 ここで、 w は形式 (x -
     a)^alpha (b - x)^beta v(x) の関数で、 v(x) は、 1, log(x - a),
     log(b - x), log(x - a) log(b - x) のいずれかであり、 alpha > -1 か
     つ beta > -1 です。

     大域的適応再分割戦略が適用され、 aまたはbを含む部分区間上では、 変
     形Clenshaw-Curtis積分を使います。

‘quad_qawc’
     f(x)/(x - c)のコーシーの主値を 有限の区間(a, b)上で指定されたcを用
     いて 計算します。 戦略は、大域的適応的で、 点x = cを含む部分範囲上
     で変形Clenshaw-Curtis積分が使われます。

   ---------- Footnotes ----------

   (1) Applied Mathematics and Programming Division, K.U. Leuven

   (2) Applied Mathematics and Programming Division, K.U. Leuven

   (3) Institut für Mathematik, T.U. Wien

   (4) National Bureau of Standards, Washington, D.C., U.S.A

   (5) <http://www.netlib.org/slatec>

   (6) <http://www.netlib.org/quadpack>

   (7) R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K.
Kahaner.  QUADPACK: A Subroutine Package for Automatic Integration.
Berlin: Springer-Verlag, 1983, ISBN 0387125531.


File: maxima.info,  Node: Functions and Variables for QUADPACK,  Prev: Introduction to QUADPACK,  Up: Integration

19.4 Functions and Variables for QUADPACK
=========================================

 -- 関数: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])
 -- 関数: quad_qag (<f>, <x>, <a>, <b>, <key>, [<epsrel>, <epsabs>,
          <limit>])

     一般関数の有限の区間上の積分。 ‘quad_qag’は、Aind(Piessens, 1973)の
     戦略を使った 簡単な大域的適応積分器を実装しています。 呼び出し側は
     、ルール評価コンポーネントのための ガウスークロンロッドの求積公式の
     6つのペアの中から選ぶことができます。 強く振動する非積分関数には高
     次のルールが適切です。

     quad_qagは積分 integrate (f(x), x, a, b) を計算します。

     非積分関数は依存変数<x>の<f(x)>であり、 関数は下限<a>上限<b>の間で
     積分されます。 <key>は利用される積分器で、1から6までのいずれかの整
     数でなければなりません。 <key>の値は、ガウスークロンロッドの積分ル
     ールの次数を選びます。 高次のルールが、強く振動する非積分関数には適
     切です。

     非積分関数は、MaximaもしくはLisp関数もしくは演算子の名前もしく
     Maximaのラムダ式か、 一般的なMaximaの式として指定されます。

     数値積分は、望まれる精度が達成されるまで、 積分領域を部分区間に分割
     することによって適応的に実行されます。

     キーワード引数はオプションで、どの次数においても指定できます。 それ
     らは形式‘key=val’を取ります。キーワード引数は：

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフ
          ォルトは200。

     ‘quad_qag’は４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード（戻り値の４番目の要素）は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- 関数: quad_qags (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- 関数: quad_qags (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>, <limit>])

     一般関数の有限の区間上の積分。 ‘quad_qags’は、イプシロンアルゴリズ
     ム(Wynn, 1956)による外挿(de Doncker,1978)を 使った大域的適応積分器
     を実装しています。

     ‘quad_qags’は、積分

     integrate (f(x), x, a, b) を計算します。

     非積分関数は依存変数<x>の<f(x)>であり、 関数は下限<a>上限<b>の間で
     積分されます。

     非積分関数は、MaximaもしくはLisp関数もしくは演算子の名前もしく
     Maximaのラムダ式か、一般的なMaximaの式として指定されます。

     キーワード引数はオプションで、どの次数においても指定できます。 それ
     らは形式‘key=val’を取ります。キーワード引数は：

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフ
          ォルトは200。

     ‘quad_qags’は４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード（戻り値の４番目の要素）は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘4’
          収束に失敗した場合;
     ‘5’
          積分が発散しているか収束が遅い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     この積分に関しては、‘quad_qags’は、‘quad_qag’よりも精確で 効率的で
     あることに注意してください。

 -- 関数: quad_qagi (<f(x)>, <x>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- 関数: quad_qagi (<f>, <x>, <a>, <b>, [<epsrel>, <epsabs>, <limit>])

     一般関数の無限のもしくは半無限の区間上の積分。 区間は、有限の区間上
     に写像され、‘quad_qags’の中で使われるのと同じ戦略が適用されます。

     ‘quad_qagi’は、Quadpack QAGIルーチンを使って以下の積分の１つを評価
     します。

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, minf, inf)

     被積分関数は、<f(x)>であり、 従属変数<x>を使って、 関数は無限範囲上
     で積分されます。

     被積分関数は、MaximaまたはLispの関数または演算子の名前、 Maximaのラ
     ムダ式またはMaximaの一般式として指定されるかもしれません。

     積分の境界の１つは、無限でなければいけません。 もしそうでなければ、
     ‘quad_qagi’はただ名詞形を返します。

     キーワード引数は随意で、任意の順序で指定できます。 それらすべては形
     式‘key=val’を取ります。 キーワード引数は:

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフ
          ォルトは200。

     ‘quad_qagi’は、４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード(戻り値の４番目の要素)は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘4’
          収束に失敗した場合;
     ‘5’
          積分が発散しているか収束が遅い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32

 -- 関数: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])
 -- 関数: quad_qawc (<f>, <x>, <c>, <a>, <b>, [<epsrel>, <epsabs>,
          <limit>])

     f(x)/(x - c)のコーシーの主値を 有限の区間(a, b)上で指定されたcを用
     いて 計算します。 戦略は、大域的適応的で、 点x = cを含む部分範囲上
     で変形Clenshaw-Curtis積分が使われます。

     ‘quad_qawc’は、 Quadpack QAWCルーチンを使って、 integrate (f(x)/(x
     - c), x, a, b)

     のコーシーの主値を計算します。

     被積分関数は、 ‘<f(x)>/(<x> - <c>)’で、 従属変数<x>を使って、 関数
     は<a>から<b>までの区間上で積分されます。

     被積分関数は、MaximaまたはLispの関数または演算子の名前、 Maximaのラ
     ムダ式またはMaximaの一般式として指定されるかもしれません。

     キーワード引数は随意で、任意の順序で指定できます。 それらすべては形
     式‘key=val’を取ります。 キーワード引数は:

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフ
          ォルトは200。

     ‘quad_qagc’は、４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード(戻り値の４番目の要素)は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘4’
          収束に失敗した場合;
     ‘5’
          積分が発散しているか収束が遅い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                           'epsrel=1d-7);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
                x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                 3 alpha                       3 alpha
                 -------                       -------
                    2            alpha/2          2          alpha/2
              2 4        atan(4 4       )   2 4        atan(4       )   alpha
            - --------------------------- - -------------------------)/2
                        alpha                        alpha
                     2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917

 -- 関数: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, [<epsabs>,
          <limit>, <maxp1>, <limlst>])
 -- 関数: quad_qawf (<f>, <x>, <a>, <omega>, <trig>, [<epsabs>, <limit>,
          <maxp1>, <limlst>])

     フーリエコサイン変換またはフーリエサイン変換を、 Quadpack QAWF関数
     を使って、半無限区間上で計算します。 ‘quad_qawo’で使われるのと同じ
     アプローチが、連続する区間に適用され、 イプシロンアルゴリズム(Wynn,
     1956)を使った収束の促進が積分寄与の級数に適用されます。

     ‘quad_qawf’は積分 integrate (f(x)*w(x), x, a, inf) を計算します。

     重み関数wは<trig>によって選択されます:

     ‘cos’
          w(x) = cos (omega x)
     ‘sin’
          w(x) = sin (omega x)

     被積分関数は、MaximaまたはLispの関数または演算子の名前、 Maximaのラ
     ムダ式またはMaximaの一般式として指定されるかもしれません。

     キーワード引数は随意で、任意の順序で指定できます。 それらすべては形
     式‘key=val’を取ります。 キーワード引数は:

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。(<limit> - <limlst>)/2は使用する部分区
          間の最大数。デフォルトは200。
     ‘maxp1’
          チェビシェフ積率の最大数。 0より大きくなければいけません。 デ
          フォルトは100です。
     ‘limlst’
          サイクル数に関する上限。 3以上でなければいけません。 デフォル
          トは10です。

     ‘quad_qawf’は、４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード(戻り値の４番目の要素)は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘4’
          収束に失敗した場合;
     ‘5’
          積分が発散しているか収束が遅い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714

 -- 関数: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>, [<epsrel>,
          <epsabs>, <limit>, <maxp1>, <limlst>])
 -- 関数: quad_qawo (<f>, <x>, <a>, <b>, <omega>, <trig>, [<epsrel>,
          <epsabs>, <limit>, <maxp1>, <limlst>])

     cos(omega x) f(x) や sin(omega x) f(x) の有限の区間上の積分。 ここ
     で、 omega は定数です。 規則評価構成要素は、変形Clenshaw-Curtis手法
     に基づいています。 ‘quad_qawo’は、 ‘quad_qags’に似て、外挿とともに
     適応再分割を適用します。

     ‘quad_qawo’は、 Quadpack QAWOルーチンを使って 積分を計算します:

     integrate (f(x)*w(x), x, a, b)

     重み関数wは、<trig>によって選択されます:

     ‘cos’
          w(x) = cos (omega x)
     ‘sin’
          w(x) = sin (omega x)

     被積分関数は、MaximaまたはLispの関数または演算子の名前、 Maximaのラ
     ムダ式またはMaximaの一般式として指定されるかもしれません。

     キーワード引数は随意で、任意の順序で指定できます。 それらすべては形
     式‘key=val’を取ります。 キーワード引数は:

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。<limit>/2は使用する部分区間の最大数。
          デフォルトは200。
     ‘maxp1’
          チェビシェフ積率の最大数。 0より大きくなければいけません。 デ
          フォルトは100です。
     ‘limlst’
          サイクル数に関する上限。 3以上でなければいけません。 デフォル
          トは10です。

     ‘quad_qawo’は、４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード(戻り値の４番目の要素)は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘4’
          収束に失敗した場合;
     ‘5’
          積分が発散しているか収束が遅い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
                x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716

 -- 関数: quad_qaws (<f(x)>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])
 -- 関数: quad_qaws (<f>, <x>, <a>, <b>, <alpha>, <beta>, <wfun>,
          [<epsrel>, <epsabs>, <limit>])

     w(x) f(x)の有限の区間上の積分。 ここで、w(x)は、ある代数的または対
     数関数です。 大域的適応最分割戦略が適用されます。 積分の区間の端点
     を含む部分区間上で変形Clenshaw-Curtis積分を使います。

     ‘quad_qaws’は、 Quadpack QAWSルーチンを使って 積分を計算します:

     integrate (f(x)*w(x), x, a, b)

     重み関数wは<wfun>によって選択されます:

     ‘1’
          w(x) = (x - a)^alpha (b - x)^beta
     ‘2’
          w(x) = (x - a)^alpha (b - x)^beta log(x - a)
     ‘3’
          w(x) = (x - a)^alpha (b - x)^beta log(b - x)
     ‘4’
          w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)

     被積分関数は、MaximaまたはLispの関数または演算子の名前、 Maximaのラ
     ムダ式またはMaximaの一般式として指定されるかもしれません。

     キーワード引数は随意で、任意の順序で指定できます。 それらすべては形
     式‘key=val’を取ります。 キーワード引数は:

     ‘epsrel’
          望まれる近似の相対誤差。デフォルトは1d-8。
     ‘epsabs’
          望まれる近似の絶対誤差。デフォルトは0。
     ‘limit’
          内部の作業配列のサイズ。<limit>は使用する部分区間の最大数。デ
          フォルトは200。

     ‘quad_qaws’は、４つの要素のリストを返します:

        • 積分の近似
        • 見積もられた近似の絶対誤差
        • 非積分関数の評価数
        • エラーコード

     エラーコード(戻り値の４番目の要素)は以下の値を取ります:

     ‘0’
          問題が発生しなかった場合;
     ‘1’
          部分区間の数が上限を超えた場合;
     ‘2’
          丸め誤差が超過した場合;
     ‘3’
          非積分関数の振る舞いが極端に悪い場合;
     ‘4’
          収束に失敗した場合;
     ‘5’
          積分が発散しているか収束が遅い場合;
     ‘6’
          入力が無効な場合;

     例:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                           'epsabs=1d-9);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829


File: maxima.info,  Node: Equations,  Next: Differential Equations,  Prev: Integration,  Up: Top

20 Equations
************

* Menu:

* Functions and Variables for Equations::   


File: maxima.info,  Node: Functions and Variables for Equations,  Prev: Equations,  Up: Equations

20.1 Functions and Variables for Equations
==========================================

 -- システム変数: %rnum_list
     デフォルト値: ‘[]’

     ‘%rnum_list’は、 ‘solve’や‘algsys’による解で導入された 変数のリスト
     です。 ‘%r’変数は、それらが生成された順に ‘%rnum_list’に追加されま
     す。 これは、あとで解への代入を行うのに便利です。 ‘concat ('%r,
     j)’をするよりこのリストを使うことを推奨します。

          (%i1) solve ([x + y = 3], [x,y]);
          (%o1)              [[x = 3 - %r1, y = %r1]]
          (%i2) %rnum_list;
          (%o2)                       [%r1]
          (%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
          (%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
          (%i4) %rnum_list;
          (%o4)                     [%r2, %r3]
          (%i5) for i : 1 thru length (%rnum_list) do
                  sol : subst (t[i], %rnum_list[i], sol)$
          (%i6) sol;
          (%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                               2      1           2       1

 -- オプション変数: algepsilon
     デフォルト値: 10^8

     ‘algsys’が ‘algepsilon’を使います。

 -- オプション変数: algexact
     デフォルト値: ‘false’

     ‘algexact’は、以下のように‘algsys’の振る舞いに影響を与えます:

     もし‘algexact’が‘true’なら、 ‘algsys’はいつも‘solve’をコールし、
     ‘solve’の失敗時には‘realroots’を使います。

     もし‘algexact’が‘false’なら、 問題が１変数でないときだけ、 もしくは
     、方程式が二次もしくは四次なら ‘solve’がコールされます。

     このように、‘algexact: true’は、 厳密解だけを保証せず、ただ、
     ‘algsys’は最初に厳密解を与えるように最大限努力して、 他のすべてが失
     敗した時近似をもたらすことだけを保証します。

 -- 関数: algsys ([<expr_1>, …, <expr_m>], [<x_1>, …, <x_n>])
 -- 関数: algsys ([<eqn_1>, …, <eqn_m>], [<x_1>, …, <x_n>])

     同時多項式<expr_1>, …, <expr_m> または多項式方程式<eqn_1>, …,
     <eqn_m> を変数<x_1>, …, <x_n>について解きます。 式<expr>は、等式
     ‘<expr> = 0’と同値です。 変数より等式が多い場合も逆もあります。

     ‘algsys’は、解のリストを返します。 ここで、それぞれの解は、 方程式
     系を満たす変数<x_1>, …, <x_n>の値を指定する等式のリストとして 与え
     られます。 もし‘algsys’が解を見つけられなければ、 空のリスト‘[]’が
     返されます。

     シンボル‘%r1’, ‘%r2’, …, が、解の任意パラメータを表すために、必要に
     応じて導入されます; これらの変数は、リスト ‘%rnum_list’にも追加され
     ます。

     方法は以下の通りです:

       1. 最初に、方程式は因数分解され、サブシステムに分割されます。

       2. それぞれのサブシステム<S_i>に関して、等式<E>と変数<x>が選択さ
          れます。 変数はゼロでない最低次を持つよう選ばれます。 そして、
          <x>に関する<E>と<E_j>の終結式が サブシステム<S_i>の中の残って
          いる等式群<E_j>のそれぞれに関して計算されます。

          これは、<x>が消去されるので、 １つ変数の少ない新しいサブシステ
          ム<S_i’>をもたらします ここでプロセスは(1)に戻ります。

       3. いつか、１つの等式から成るサブシステムが得られます。 もし等式
          が多変数なら、浮動小数点数の形式の近似は導入されず、 厳密解を
          見つけるために‘solve’がコールされます。

          いくつかの場合、‘solve’は解を見つけることができないか、 もし見
          つけたら、絵が非常に大きな式になるかもしれません。

          もし等式が１変数で、線形か二次か四次なら、 もし近似が導入され
          ないなら、再び‘solve’がコールされます。 もし近似が導入されるか
          、等式が１変数でなく、線形でも二次でも、四次でもないなら、 も
          しスイッチ‘realonly’が‘true’なら、 実数解を見つけるため関数
          ‘realroots’がコールされます。 もし‘realonly’が‘false’なら、 実
          数解と複素数解を探す‘allroots’がコールされます。

          もし‘algsys’が 要求よりも有効数字が少ない解を生成するなら、 ユ
          ーザーは‘algepsilon’の値をより高い値に変更できます。

          もし‘algexact’が‘true’に設定されているなら、 いつも‘solve’がコ
          ールされます。

       4. 最終的に、ステップ(3)で得られた解は以前のレベルに代入され、解
          処理は(1)に戻ります。

     ‘algsys’が（通常、初期の段階での厳密解発見の失敗による）浮動小数点
     近似を含む多変数方程式に出会う時、 厳密な方法をそんな方程式に適用し
     ようとせず、かわりにメッセージを表示します: "‘algsys’ cannot solve
     - system too complicated."

     ‘radcan’との対話は、多きなもしくは複雑な式を生成することができます
     。 この場合、‘pickapart’または ‘reveal’を使って結果の一部を分離する
     ことができるかもしれません。

     時々、‘radcan’は、実際には実数値の解に虚数単位‘%i’を導入するかもし
     れません。

     例:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3

 -- 関数: allroots (<expr>)
 -- 関数: allroots (<eqn>)

     1変数多項式<expr>もしくは1変数多項式方程式<eqn>の実数と複素数の根の
     数値近似を 計算する。

     フラグ‘polyfactor’が‘true’の時、 ‘allroots’は、多項式が実数なら多項
     式を実数上で因数分解し、 多項式が複素数なら複素数上で因数分解します
     。

     ‘allroots’は、多重根の場合、不正確な結果をもたらすことがあります。
     もし多項式が実数なら、‘allroots (%i*<p>)’は、 ‘allroots (<p>)’より
     精確な近似を生成します。 ‘allroots’はこの場合異なるアルゴリズムを呼
     ぶので。

     ‘allroots’は非多項式を却下します。 ‘rat’された分子が多項式であるこ
     とを要求し、 分母はせいぜい複素数であることを要求します。 この結果
     、もし‘polyfactor’が‘true’なら、 ‘allroots’はいつも（因数分解された
     ）同値の式を返します。

     複素多項式のために、JenkinsとTraubのアルゴリズムが使われます （
     Algorithm 419, Comm.  ACM, vol.  15, (1972), .97)。 実多項式のため
     に、Jenkinsのアルゴリズム (Algorithm 493, ACM TOMS, vol.  1,
     (1975), p.178)が使われます。

     例:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)

 -- 関数: bfallroots (<expr>)
 -- 関数: bfallroots (<eqn>)

     １変数の多項式<expr>または多項式等式<eqn>の実数根と複素数根の数値近
     似 を計算します。

     ‘bfallroots’は多倍長浮動小数点を使って根を計算する以外の すべての点
     で、‘bfallroots’は‘allroots’と同一です。 詳しい情報については
     ‘allroots’を参照してください。

 -- オプション変数: backsubst
     デフォルト値: ‘true’

     ‘backsubst’が‘false’の時、 方程式が三角行列化された後、‘linsolve’の
     後退代入を妨げます。 これは、後退代入が極端に大きな式の生成のもとと
     なる非常に大きな問題に関して役立つかもしれません。

          (%i1) eq1 : x + y + z = 6$
          (%i2) eq2 : x - y + z = 2$
          (%i3) eq3 : x + y - z = 0$
          (%i4) backsubst : false$
          (%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o5)             [x = z - y, y = 2, z = 3]
          (%i6) backsubst : true$
          (%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
          (%o7)               [x = 1, y = 2, z = 3]

 -- オプション変数: breakup
     デフォルト値: ‘true’

     ‘breakup’が‘true’の時、 ‘solve’は、三次と四次の方程式の解を共通部分
     式を使って表現します。 共通部分式は、中間式ラベル(‘%t1’, ‘%t2’, な
     ど)に割り当てられます。 そうでなければ、共通部分式は同定されません
     。

     ‘breakup: true’は、 ‘programmode’が‘false’の時だけ、効果を持ちます
     。

     例:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3
                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54
                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]

 -- 関数: dimension (<eqn>)
 -- 関数: dimension (<eqn_1>, ..., <eqn_n>)

     ‘dimen’は、次元解析パッケージです。 ‘load ("dimen")’はこのパッケー
     ジをロードします。 ‘demo ("dimen")’は短いデモンストレーションを表示
     します。

 -- オプション変数: dispflag
     デフォルト値: ‘true’

     もし‘block’内で‘false’に設定されたら ‘block’内でコールされた解法関
     数が生成する出力の表示を抑制します。 ‘block’をドル記号$で終端すると
     、 ‘dispflag’を‘false’に設定します。

 -- 関数: funcsolve (<eqn>, <g>(<t>))

     <eqn>を満たす有理関数‘<g>(<t>)’が存在するかどうかに依存して、
     ‘[<g>(<t>) = ...]’または‘[]’を返します。 ここで、<eqn>は（この場合
     ） ‘<g>(<t>)’と‘<g>(<t>+1)’に関して 一次、線形多項式でなければいけ
     ません。

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) =
                (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     警告: これはとても未熟な実装です – 多くの安全性チェックや 明らかな
     一般化が忘れられています。

 -- オプション変数: globalsolve
     デフォルト値: ‘false’

     ‘globalsolve’が‘true’の時、 ２つ以上の線形方程式を解く時、 解くべき
     変数が、‘linsolve’や‘solve’が見つけた解の値に割り当てられます。

     ‘globalsolve’が‘false’の時、 ２つ以上の線形方程式を解く時、
     ‘linsolve’や‘solve’が見つけた解は、 等式として表現され、 解くべき変
     数は割り当てられません。

     ２つ以上の線形方程式以外の何かを解く時には、 ‘solve’は
     ‘globalsolve’を無視します。 方程式を解く他の関数(例えば‘algsys’)は
     いつも‘globalsolve’を無視します。

     例:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y

 -- 関数: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)

     ‘inteqn’は、積分方程式を解くためのパッケージです。 ‘load
     ("inteqn")’はこのパッケージをロードします。

     <ie>は、積分方程式です; <unk>は、未知の関数です; <tech>は、上で与え
     られたこれらから試される手法です; is the technique to be tried from
     those given above (<tech> = ‘first’は以下を意味します: 解を見つける
     最初の手法を試みる; <tech> = ‘all’は以下を意味します: 適用可能な手
     法すべてを試みる); <n>は、 ‘taylor’, ‘neumann’, ‘firstkindseries’,
     または‘fredseries’ に関して扱う項の最大数です (微分法に関する再帰の
     最大深度でもあります); <guess>は、‘neumann’または
     ‘firstkindseries’に関する 初期の推測です。

     ２番目から５番目までのパラメータのデフォルト値は、以下の通りです:

     <unk>: ‘<p>(<x>)’。 ここで、<p>は被積分関数の中で出会うMaximaが知ら
     ない最初の関数であり、 <x>は、‘secondkind’方程式の場合の積分の外側
     で見つかった<p> の最初の出現時の引数、または、‘firstkind’方程式の中
     の積分変数を除いた唯一の残りの変数 です。 もし<x>を探す企てが失敗し
     たら、ユーザーは独立変数を供給するよう尋ねられるでしょう。

     tech: ‘first’

     n: 1

     guess: ‘neumann’と‘firstkindseries’が 初期推測として‘<f>(<x>)’を使
     うようにする‘none’

 -- オプション変数: ieqnprint
     デフォルト値: ‘true’

     ‘ieqnprint’は、‘ieqn’コマンドが返す結果の振る舞いを決めます。
     ‘ieqnprint’が‘false’の時、 ‘ieqn’関数が返すリストは、形式

     [<solution>, <technique used>, <nterms>, <flag>]

     を取ります。

     ここで、もし解が厳密なら<flag>はありません。

     そうでなければ、厳密でない解か閉じていない形の解かに対応して、それ
     ぞれ、単語‘approximate’または‘incomplete’です。 もし級数法が使われ
     たら、 <nterms>は、取った項の数を与えます。 （項の数は、もしエラー
     が更なる項の生成を防いだなら、‘ieqn’に与えられたnよりも小さいことも
     あり得ます。）

 -- 関数: lhs (<expr>)

     <expr>の演算子が関係演算子‘< <= = # equal notequal >= >’の１つ、 割
     り当て演算子‘:= ::= : ::’の１つ、 または‘infix’で宣言されたユーザー
     定義の二項中置演算子の時、 式<expr>の左辺(すなわち、最初の項) を返
     します。

     <expr>がアトムか、演算子が上で記載したもの以外の何かの時、 ‘lhs’は
     <expr>を返します。

     ‘rhs’も参照してください。

     例:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb),
                 lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
                 lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa

 -- 関数: linsolve ([<expr_1>, …, <expr_m>], [<x_1>, …, <x_n>])

     変数のリストに関して同時線形方程式のリストを解きます。 それぞれの式
     は変数に関する多項式でなければならず、等式も取り得ます。

     ‘globalsolve’が‘true’の時、 解くべき変数それぞれは、方程式の解の値
     にバインドされます。

     ‘backsubst’が‘false’の時、 ‘linsolve’は、方程式が三角行列化された後
     、後退代入を実行しません。 これは、後退代入が極端に大きな式の生成の
     原因となる非常に大きな問題に関して 必要とされるかもしれません。

     ‘linsolve_params’が‘true’の時、 ‘linsolve’は ‘algsys’の下のマニュア
     ルの中で記述された任意のパラメータを表すのに使われる ‘%r’シンボルも
     生成します。 そうでなければ、 ‘linsolve’は、他を使って表現されたい
     くつかの変数を持つ 決定中の方程式系を解きます。

     ‘programmode’が‘false’の時、 ‘linsolve’は、中間式(‘%t’)ラベルを使っ
     て解を表示し、 ラベルのリストを返します。

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]

 -- オプション変数: linsolvewarn
     デフォルト値: ‘true’

     ‘linsolvewarn’が‘true’の時、 ‘linsolve’はメッセージ"Dependent
     equations eliminated"を表示します。

 -- オプション変数: linsolve_params
     デフォルト値: ‘true’

     ‘linsolve_params’が‘true’の時、 ‘linsolve’は、 ‘algsys’の下のマニュ
     アルに記述された任意のパラメータを表すのに使われる‘%r’シンボルも生
     成します。 それでなければ、‘linsolve’は、 他を使って表現されたいく
     つかの変数を使った 決定中の方程式系を解きます。

 -- システム変数: multiplicities
     デフォルト値: ‘not_set_yet’

     ‘multiplicities’は、 ‘solve’や‘realroots’が返す個々の解の多様性のリ
     ストに設定されます。

 -- 関数: nroots (<p>, <low>, <high>)

     半開区間‘(<low>, <high>]’の中の 実数一変数多項式<p>の実根の数を返し
     ます。 区間の端点は‘minf’もしくは‘inf’、無限大かもしれません。 マイ
     ナス無限大とプラス無限大。

     ‘nroots’は、Sturm列の方法を使います。

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4

 -- 関数: nthroot (<p>, <n>)
     pは整数係数多項式で、 nは正の整数ですが、 q^n=pのような整数上の多項
     式qを返すか、 pが完全なn番目のべきでないことを示すエラーメッセージ
     を表示します。 このルーチンは、‘factor’より、また‘sqfr’よりさえもっ
     と速いです。

 -- オプション変数: polyfactor
     デフォルト値: ‘false’

     オプション変数‘polyfactor’が‘true’の時、 ‘allroots’と‘bfallroots’は
     もし多項式が実数なら実数上で、もし多項式が複素数なら複素数上で多項
     式を因数分解します。

     例は‘allroots’を参照してください。

 -- オプション変数: programmode
     デフォルト値: ‘true’

     ‘programmode’が‘true’の時、 ‘solve’, ‘realroots’, ‘allroots’,
     ‘linsolve’は、 リストの中の要素として解を返します。 (‘backsubst’が
     ‘false’設定されている時― その場合、‘programmode: false’が仮定されま
     す―を除いて)

     ‘programmode’が‘false’の時、 ‘solve’などは、中間式ラベル‘%t1’,
     ‘t2’など生成し、 解をそれらに割り当てます。

 -- オプション変数: realonly
     デフォルト値: ‘false’

     ‘realonly’が‘true’の時、 ‘algsys’は、 ‘%i’を含まないそれらの解だけ
     を返します。

 -- 関数: realroots (<expr>, <bound>)
 -- 関数: realroots (<eqn>, <bound>)
 -- 関数: realroots (<expr>)
 -- 関数: realroots (<eqn>)

     変数多項式<expr>もしくは1変数多項方程式<eqn>の実根の有理近似を、
     ‘bound’の許容誤差の範囲内で計算します。 <expr>もしくは<eqn>の係数は
     リテラル数でなければなりません。 ‘%pi’のようなシンボル定数は却下さ
     れます。

     ‘realroots’は、みつけた根の多様性を グローバル変数
     ‘multiplicities’に割り当てます。

     ‘realroots’は、それぞれの根を囲むためSturm列を構成し、 近似を精密化
     するため二分法を適用します。 根を探索する前に、すべての係数は同値の
     有理数に変換され、 正確な有理算術によって計算が実行されます。 たと
     え係数が浮動小数点でも、 （‘float’もしくは‘numer’フラグによって浮動
     小数点が強要されない限り）結果は有理数です。

     <bound>が1よりも小さい時、全ての整数根は正確に計算されます。
     <bound>がしてされない時、グローバル変数‘rootsepsilon’と等しいと仮定
     されます。

     グローバル変数‘programmode’が‘true’の時、 ‘realroots’は形式‘[x =
     <x_1>, x = <x_2>, …]’のリストを 返します。 ‘programmode’が‘false’の
     時、‘realroots’は 中間式ラベル‘%t1’, ‘%t2’, …を生成し、 結果をそれ
     らに割り当て、ラベルのリストを返します。

     例:

          (%i1) realroots (-1 - x + x^5, 5e-6);
                                         612003
          (%o1)                     [x = ------]
                                         524288
          (%i2) ev (%[1], float);
          (%o2)                 x = 1.167303085327148
          (%i3) ev (-1 - x + x^5, %);
          (%o3)                - 7.396496210176905E-6

          (%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
          (%o1)                 [x = 1, x = 2, x = 3]
          (%i2) multiplicities;
          (%o2)                       [5, 3, 1]

 -- 関数: rhs (<expr>)

     <expr>の演算子が関係演算子‘< <= = # equal notequal >= >’の１つ、 割
     り当て演算子‘:= ::= : ::’の１つ、または、 ‘infix’で宣言されたユーザ
     ー定義の二項中置演算子の時 式<expr>の右辺(すなわち、二番目の項)を返
     します。

     <expr>がアトムか、演算子が上で記載したもの以外の何かの時、 ‘rhs’は
     <expr>を返します。

     ‘lhs’も参照してください。

     例:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb),
                 rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
                 rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb

 -- オプション変数: rootsconmode
     デフォルト値: ‘true’

     ‘rootsconmode’は、‘rootscontract’コマンドの振る舞いを決定します。 詳
     細は‘rootscontract’を参照してください。

 -- 関数: rootscontract (<expr>)

     根の積を積の根に変換します。 例えば、 ‘rootscontract
     (sqrt(x)*y^(3/2))’は‘sqrt(x*y^3)’をもたらします。

     ‘radexpand’が‘true’かつ‘domain’が‘real’の時、 ‘rootscontract’は、
     converts ‘abs’を‘sqrt’に変換します。 例えば、‘rootscontract
     (abs(x)*sqrt(y))’は‘sqrt(x^2*y)’をもたらします。

     以下のように‘rootscontract’に影響するオプション‘rootsconmode’があり
     ます:

          問題               rootsconmodeの値　rootscontractを適用した値

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     ‘rootsconmode’が‘false’の時、 ‘rootscontract’は、分母が同じ有理数指
     数に関してだけ短縮します。 ‘rootsconmode: true’の例のキーは、 単に
     、4は2で割り切れますが、4は2で割り切れないということです。
     ‘rootsconmode: all’は、指数の分母の最小公倍数を取ることを伴います。

     ‘rootscontract’は、 ‘logcontract’と似た方法で、‘ratsimp’を使います
     。

     例:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5+sqrt(5)) - 5^(1/4)*sqrt(1+sqrt(5)));
          (%o13)                          0

 -- オプション変数: rootsepsilon
     デフォルト値: 1.0e-7

     ‘rootsepsilon’は、 ‘realroots’関数が見つけた根に関する信頼区間を確
     立する許容誤差です。

 -- 関数: solve (<expr>, <x>)
 -- 関数: solve (<expr>)
 -- 関数: solve ([<eqn_1>, …, <eqn_n>], [<x_1>, …, <x_n>])

     代数等式<expr>を<x>について解き、<x>の解等式のリストを返します。 も
     し<expr>の等式でなければ、等式‘<expr> = 0’が仮定されます。 <x>は関
     数(例えば‘f(x)’)でも他のアトムでない式でも問題ありません。 （sumや
     productは除きます。）<expr>が変数を１つだけ含む場合、<x>は省略でき
     ます。 <expr>は有理式でも、三角関数や指数関数を含むことができます。

     以下の方法が使われます:

     <E>を式、<X>を変数とします。 もし<E>が<X>に関して線形なら、<X>につ
     いて自明に解かれます。 そうでなければ、もし<E>が‘A*X^N + B’の形なら
     、 結果は、‘(-B/A)^(1/N)’かける1の‘N’乗根です。

     もし<E>が<X>について線形でなければ、 <E>の中の<X>の指数のgcd(以下
     <N>とする）が指数に割られ、 根に<N>がかけられます。 その後、結果に
     対して‘solve’が再びコールされます。 もし<E>が因数分解されるなら、
     ‘solve’は因子のそれぞれに対してコールされます。 最後に、‘solve’は２
     次方程式、３次方程式、4次方程式の解の公式を必要に応じて使います。

     <E>が解くべき変数のある関数（以下‘F(X)’)の多項式の場合， 最初に
     ‘F(X)’について解かれ（結果を<C>と呼ぶ）、 関数<F>の逆関数がわかって
     いる場合、等式‘F(X)=C’が<X>について解かれます。

     ‘breakup’が‘false’なら、 ‘solve’は３次もしくは４次方程式の解を、 デ
     フォルトであるいくつかの共通部分式から成る表現ではなく、 単一の式で
     表現されます。

     ‘multiplicities’は、‘solve’や‘realroots’, ‘allroots’が返した 多数の
     独立の解のリストに設定されます。 ‘slove’に影響するスイッチについて
     は、‘apropos (solve)’を試してください。 もしスイッチの目的がはっき
     りしないなら、 個々のスイッチ名について‘describe’を使うことができま
     す。

     ‘solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])’ は、
     ‘linsolve’もしくは‘algsys’をコールすることで， 同時（線形もしくは非
     線形）代数方程式系を解き、変数の解リストのリストを返します。
     ‘linsolve’の場合、このリストは解の単一リストを含みます。 引数に２つ
     のリストをとります。 最初のリストは解くべき等式を示し、２番目のリス
     トは決定すべき未知数のリストです。 もし等式の変数の総数が等式の数に
     等しいなら、２番目の引数リストは省略できます。

     ‘programmode’が‘false’の時、 ‘solve’は中間式(‘%t’)ラベルを持つ解を
     表示し、ラベルのリストを返します。

     ‘globalsolve’が‘true’、かつ、問題が２つ以上の線形方程式を解くことで
     ある場合、 それぞれの解くべき変数は方程式の解の値にバインドされます
     。

     例:

          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          solve: using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]

          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i
           - .1331240357358706, y = .07678378523787788
           - 3.608003221870287 %i], [x = - .5202594388652008 %i
           - .1331240357358706, y = 3.608003221870287 %i
           + .07678378523787788], [x = - 1.733751846381093,
          y = - .1535675710019696]]

          (%i5) solve (1 + a*x + x^3, x);

                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0

     シンボル‘%r’は、解の中で任意定数を示すのに使われます。

          (%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

          solve: dependent equations eliminated: (2)
          (%o1)                      [[x = 1 - %r1, y = %r1]]

     更に知るには、‘algsys’と ‘%rnum_list’.

 -- オプション変数: solvedecomposes
     デフォルト値: ‘true’

     ‘solvedecomposes’が‘true’の時、 もし多項式を解くように頼まれたなら
     、 ‘solve’は、‘polydecomp’をコールします。

 -- オプション変数: solveexplicit
     デフォルト値: ‘false’

     ‘solveexplicit’が‘true’の時、 ‘solve’が 陰解―すなわち、‘F’がある関
     数である形式‘F(x) = 0’の解― を返すことを妨げます。

 -- オプション変数: solvefactors
     デフォルト値: ‘true’

     ‘solvefactors’が‘false’の時、 ‘solve’は、式を因数分解しようとしませ
     ん。 ‘false’設定は、 因数分解が不要ないくつかの場合に望まれるかもし
     れません。

 -- オプション変数: solvenullwarn
     デフォルト値: ‘true’

     ‘solvenullwarn’が‘true’の時、 もし空の等式リストか空の変数リストを
     引数にコールされたら ‘solve’は、警告メッセージを表示します。 例えば
     、‘solve ([], [])’は、２つの警告メッセージを表示し、 ‘[]’を返します
     。

 -- オプション変数: solveradcan
     デフォルト値: ‘false’

     ‘solveradcan’が‘true’の時、 ‘solve’は‘radcan’をコールし、‘solve’は
     遅くなりますが、 指数と対数を含むある問題が解けるようになります。

 -- オプション変数: solvetrigwarn
     デフォルト値: ‘true’

     ‘solvetrigwarn’が‘true’の時、 ‘solve’は、 方程式を解くために逆三角
     関数を使い、ゆえに解を失っていることを示す メッセージを表示するかも
     しれません。


File: maxima.info,  Node: Differential Equations,  Next: Numerical,  Prev: Equations,  Up: Top

21 Differential Equations
*************************

* Menu:

* Introduction to Differential Equations::  
* Functions and Variables for Differential Equations::  


File: maxima.info,  Node: Introduction to Differential Equations,  Next: Functions and Variables for Differential Equations,  Prev: Differential Equations,  Up: Differential Equations

21.1 Introduction to Differential Equations
===========================================

この節は、 一次と二次方程式のいくつかの特定のタイプの解析解を得るための
Maximaで利用可能な関数を 記述します。 微分方程式系の数値解を得るには、 付
加パッケージ‘dynamics’を参照してください。 位相空間でのグラフィカルな表
現に関して、 付加パッケージ‘plotdf’を参照してください。


File: maxima.info,  Node: Functions and Variables for Differential Equations,  Prev: Introduction to Differential Equations,  Up: Differential Equations

21.2 Functions and Variables for Differential Equations
=======================================================

 -- 関数: bc2 (<solution>, <xval1>, <yval1>, <xval2>, <yval2>)
     二階微分方程式の境界値問題を解きます。 ここで: <solution>は、
     ‘ode2’が見つけるような方程式の一般解です; <xval1>は、独立変数の最初
     の点の値を、形式‘<x> = <x1>’で指定し、 <yval1>は、その点の従属変数
     の値を、形式‘<y> = <y1>’で与えます。 式<xval2>と<yval2>は、 それら
     の変数の二番目の点での値を、同じ形式を使って与えます。

     用法の例については‘ode2’を参照してください。

 -- 関数: desolve (<eqn>, <x>)
 -- 関数: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     関数‘desolve’は、ラプラス変換を使って線形常微分方程式系を解きます。
     ここで、<eqn>群は、従属変数<x_1>, ..., <x_n>に関する微分方程式です
     。 <x_1>, ..., <x_n>の独立変数、例えば<x>、への関数依存性は、 変数
     や導関数の中で陽に示されなければいけません。 例えば、これは、２つの
     方程式を定義する正しい方法ではありません:

          eqn_1: 'diff(f,x,2) = sin(x) + 'diff(g,x);
          eqn_2: 'diff(f,x) + x^2 - f = 2*'diff(g,x,2);

     正しい方法は以下の通りです:

          eqn_1: 'diff(f(x),x,2) = sin(x) + 'diff(g(x),x);
          eqn_2: 'diff(f(x),x) + x^2 - f(x) = 2*'diff(g(x),x,2);

     関数‘desolve’のコールは、
          desolve([eqn_1, eqn_2], [f(x),g(x)]);
     です。

     もし‘x=0’の初期条件が既知なら、 それらは、‘atvalue’を使って、
     ‘desolve’コールの前に供給することができます。

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     もし‘desolve’が解を得られないなら、 ‘false’を返します。

 -- 関数: ic1 (<solution>, <xval>, <yval>)
     一階微分方程式の初期値問題を解きます。 ここで、<solution>は、
     ‘ode2’が見つけるような、方程式の一般解であり、 <xval>は、独立変数の
     初期値を、形式‘<x> = <x0>’で与え、 <yval>は、従属変数の初期値を、形
     式‘<y> = <y0>’で与えます。

     用法の例については‘ode2’を参照してください。

 -- 関数: ic2 (<solution>, <xval>, <yval>, <dval>)
     二階微分方程式の初期値を解きます。 ここで、 <solution>は、‘ode2’が
     見つけるような、 方程式の一般解のであり、 <xval>は、独立変数の初期
     値を、形式‘<x> = <x0>’で与え、 <yval>は、従属変数の初期値を、形式
     ‘<y> = <y0>’で与え、 <dval>は、従属変数の独立変数に関する一階導関数
     の初期値を、 形式‘diff(<y>,<x>) = <dy0>’で、与えます。 (‘diff’はク
     ォートされる必要はありません。)

     用法の例については、‘ode2’を参照してください。

 -- 関数: ode2 (<eqn>, <dvar>, <ivar>)
     関数‘ode2’は、一階または二階常微分方程式(ODE)を解きます。 ３つの引
     数を取ります: <eqn>で与えられるODE、従属変数<dvar>、独立変数
     <ivar>。 成功した時、従属変数に関する陽解または陰解を返します。 一
     階方程式の場合、‘%c’が積分定数を表し、 二階方程式の場合、‘%k1’と
     ‘%k2’が定数を表します。 従属変数の独立変数への依存性は、 ‘desolve’の
     場合のように、陽に書かれる必要はありませんが、 独立変数はいつも三番
     目の引数として与えられなければいけません。

     たとえどんな理由でも、もし‘ode2’が解を得られなかったら、 おそらく、
     エラーメッセージを表示した後、‘false’を返します。 一階方程式用に実
     装された方法は、試される順番に、線形、分離、厳密―おそらく因子の積分
     を要求します―、斉次、ベルヌーイの等式、一般化斉次法、です。 解ける
     二階方程式のタイプは、定係数、厳密、定数係数に変換可能な非定数係数
     線形斉次、 オイラーまたは等次元方程式、パラメータ変動法で解ける方程
     式、 独立変数または従属変数を含まなくて、順に解かれる２つの一階線形
     方程式に換算できる方程式、 です。

     ODEを解く間、いくつかの変数が純粋に参考目的で設定されます:
     ‘method’は、使われた解法(例えば、‘linear’)を示し、 ‘intfactor’は、
     任意の使われた積分因子を示し、 ‘odeindex’は、ベルヌーイ法または一般
     化斉次法のインデックスを示し、 ‘yp’は、パラメータ変動手法の特殊解を
     示します。

     初期値問題(IVP)を解くためには、 一階と二階方程式のためには関数
     ‘ic1’と‘ic2’が利用可能であり、 二階境界値問題(BVP)を解くためには、
     ‘bc2’を使うことができます。

     例:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2


File: maxima.info,  Node: Numerical,  Next: Matrices and Linear Algebra,  Prev: Differential Equations,  Up: Top

22 Numerical
************

* Menu:

* Introduction to fast Fourier transform::                     
* Functions and Variables for fast Fourier transform::
* Introduction to Fourier series::
* Functions and Variables for Fourier series::


File: maxima.info,  Node: Introduction to fast Fourier transform,  Next: Functions and Variables for fast Fourier transform,  Prev: Numerical,  Up: Numerical

22.1 Introduction to fast Fourier transform
===========================================

‘fft’パッケージは、高速Fourier変換の（数式計算ではなく）数値計算に関する
関数を含みます。


File: maxima.info,  Node: Functions and Variables for fast Fourier transform,  Next: Introduction to Fourier series,  Prev: Introduction to fast Fourier transform,  Up: Numerical

22.2 Functions and Variables for fast Fourier transform
=======================================================

 -- 関数: polartorect (<r>, <t>)

     形式‘r %e^(%i t)’の複素値を形式‘a + b %i’に変換します。 ここで、
     <r>は大きさで、<t>は位相です。 <r>と<t>は、同じサイズの１次元配列で
     す。 配列のサイズは2のべき乗である必要はありません。

     関数が戻ると、入力配列の元の値は、実部‘a’と虚部‘b’に置き換えられま
     す。 出力は、以下のように計算されます。

          a = r cos(t)
          b = r sin(t)

     ‘polartorect’は、‘recttopolar’の逆関数です。

     ‘load("fft")’はこの関数をロードします。 ‘fft’も参照してください。

 -- 関数: recttopolar (<a>, <b>)

     形式‘a + b %i’の複素値を形式‘r %e^(%i t)’に変換します。 ここで、
     <a>は実部で、<b>は虚部です。 <a>と<b>は同じサイズの１次元配列です。
     配列のサイズは2のべき乗である必要はありません。

     関数が戻ると、入力配列の元の値は、大きさ‘r’と偏角‘t’に置き換えられ
     ます。 出力は、以下のように計算されます。

          r = sqrt(a^2 + b^2)
          t = atan2(b, a)

     計算された偏角は、‘-%pi’から‘%pi’の範囲の中にあります。

     ‘recttopolar’は‘polartorect’の逆関数です。

     ‘load("fft")’はこの関数をロードします。 ‘fft’も参照してください。

 -- 関数: inverse_fft (<y>)

     複素逆高速Fourier変換を計算します。 <y>は、変換されるデータを含むリ
     ストもしくは配列です。 要素の数は2のべき乗でなければいけません。 要
     素は、数リテラル（整数、有理数、浮動小数点、多倍長浮動小数点）、シ
     ンボル定数、 もしくは、‘a’と‘b’が数リテラルもしくはシンボル定数であ
     る式‘a + b*%i’ でなければいけません。

     ‘inverse_fft’は、<y>と同じタイプの新しいオブジェクトを返します。
     <y>は変更されません。 結果はいつも浮動小数点、もしくは‘a’と‘b’が浮
     動小数点であるところの式 ‘a + b*%i’として計算されます。

     逆離散Fourier変換は、以下のように定義されます。 ‘x’を逆変換の出力と
     します。 ‘j’が0から‘n - 1’まで変わる中、

          x[j] = sum(y[k] exp(+2 %i %pi j k / n), k, 0, n - 1)

     ‘load("fft")’はこの関数をロードします。

     ‘fft’ (正変換), ‘recttopolar’, ‘polartorect’も参照してください。

     例:

     実数データ。

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [0.0, 14.49 %i - .8284, 0.0, 2.485 %i + 4.828, 0.0,
                                 4.828 - 2.485 %i, 0.0, - 14.49 %i - .8284]
          (%i5) L2 : fft (L1);
          (%o5) [1.0, 2.0 - 2.168L-19 %i, 3.0 - 7.525L-20 %i,
          4.0 - 4.256L-19 %i, - 1.0, 2.168L-19 %i - 2.0,
          7.525L-20 %i - 3.0, 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     複素数データ

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : inverse_fft (L);
          (%o4) [4.0, 2.711L-19 %i + 4.0, 2.0 %i - 2.0,
          - 2.828 %i - 2.828, 0.0, 5.421L-20 %i + 4.0, - 2.0 %i - 2.0,
          2.828 %i + 2.828]
          (%i5) L2 : fft (L1);
          (%o5) [4.066E-20 %i + 1.0, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          1.55L-19 %i - 1.0, - 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.0 - 7.368L-20 %i]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.841L-17

 -- 関数: fft (<x>)

     複素高速Fourier変換を計算します。 <x>は、変換されるデータを含むリス
     トもしくは配列です。 要素の数は2のべき乗でなければいけません。 要素
     は、数リテラル（整数、有理数、浮動小数点、多倍長浮動小数点）、シン
     ボル定数、 もしくは、‘a’と‘b’が数リテラルもしくはシンボル定数である
     式‘a + b*%i’ でなければいけません。

     ‘fft’は、<x>と同じタイプの新しいオブジェクトを返します。 <x>は変更
     されません。 結果はいつも浮動小数点、もしくは‘a’と‘b’が浮動小数点で
     あるところの式 ‘a + b*%i’として計算されます。

     離散Fourier変換は、以下のように定義されます。 ‘y’を変換の出力としま
     す。 ‘k’が0から‘n - 1’まで変わる中、

          y[k] = (1/n) sum(x[j] exp(-2 %i %pi j k / n), j, 0, n - 1)

     データ<x>が実数の時、 実係数‘a’と‘b’は以下のように計算することがで
     きます。
          x[j] = sum(a[k]*cos(2*%pi*j*k/n)+b[k]*sin(2*%pi*j*k/n), k, 0, n/2)

     ここで、

          a[0] = realpart (y[0])
          b[0] = 0

     そして、‘k’が1からn/2 - 1まで変わる中、

          a[k] = realpart (y[k] + y[n - k])
          b[k] = imagpart (y[n - k] - y[k])

     そして、

          a[n/2] = realpart (y[n/2])
          b[n/2] = 0

     ‘load("fft")’はこの関数をロードします。

     ‘inverse_fft’ (逆変換), ‘recttopolar’, ‘polartorect’も参照してくだ
     さい。

     例:

     実数データ。

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, -1, -2, -3, -4] $
          (%i4) L1 : fft (L);
          (%o4) [0.0, - 1.811 %i - .1036, 0.0, .6036 - .3107 %i, 0.0,
                                   .3107 %i + .6036, 0.0, 1.811 %i - .1036]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0, 2.168L-19 %i + 2.0, 7.525L-20 %i + 3.0,
          4.256L-19 %i + 4.0, - 1.0, - 2.168L-19 %i - 2.0,
          - 7.525L-20 %i - 3.0, - 4.256L-19 %i - 4.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       3.545L-16

     複素数データ

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 1 + %i, 1 - %i, -1, -1, 1 - %i, 1 + %i, 1] $
          (%i4) L1 : fft (L);
          (%o4) [0.5, .3536 %i + .3536, - 0.25 %i - 0.25,
          0.5 - 6.776L-21 %i, 0.0, - .3536 %i - .3536, 0.25 %i - 0.25,
          0.5 - 3.388L-20 %i]
          (%i5) L2 : inverse_fft (L1);
          (%o5) [1.0 - 4.066E-20 %i, 1.0 %i + 1.0, 1.0 - 1.0 %i,
          - 1.008L-19 %i - 1.0, 4.066E-20 %i - 1.0, 1.0 - 1.0 %i,
          1.0 %i + 1.0, 1.947L-20 %i + 1.0]
          (%i6) lmax (abs (L2 - L));
          (%o6)                       6.83L-17

     サインとコサイン係数の計算。

          (%i1) load ("fft") $
          (%i2) fpprintprec : 4 $
          (%i3) L : [1, 2, 3, 4, 5, 6, 7, 8] $
          (%i4) n : length (L) $
          (%i5) x : make_array (any, n) $
          (%i6) fillarray (x, L) $
          (%i7) y : fft (x) $
          (%i8) a : make_array (any, n/2 + 1) $
          (%i9) b : make_array (any, n/2 + 1) $
          (%i10) a[0] : realpart (y[0]) $
          (%i11) b[0] : 0 $
          (%i12) for k : 1 thru n/2 - 1 do
             (a[k] : realpart (y[k] + y[n - k]),
              b[k] : imagpart (y[n - k] - y[k]));
          (%o12)                        done
          (%i13) a[n/2] : y[n/2] $
          (%i14) b[n/2] : 0 $
          (%i15) listarray (a);
          (%o15)          [4.5, - 1.0, - 1.0, - 1.0, - 0.5]
          (%i16) listarray (b);
          (%o16)           [0, - 2.414, - 1.0, - .4142, 0]
          (%i17) f(j) := sum (a[k]*cos(2*%pi*j*k/n) + b[k]*sin(2*%pi*j*k/n),
                              k, 0, n/2) $
          (%i18) makelist (float (f (j)), j, 0, n - 1);
          (%o18)      [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]

 -- オプション変数: fortindent
     デフォルト値: 0

     ‘fortindent’は、‘fortran’コマンドが表示する式の 式の左マージンイン
     デントを制御します。 0は、標準のプリントアウト(すなわち6スペース)を
     与え、 正の値は、式を更に右に印字するようにします。

 -- 関数: fortran (<expr>)

     Fortran文として<expr>を印字します。 出力行は、スペースでインデント
     されます。 もし行が長過ぎるなら、 ‘fortran’は継続行を印字します。
     ‘fortran’は、指数演算子‘^’を‘**’として印字し、 複素数‘a + b %i’を形
     式‘(a,b)’で印字します。

     <expr>は等式も取り、もしそうなら、‘fortran’は、 等式の右辺を左辺に
     割り当てる割り当て文を印字します。 特に、もし<expr>の右辺が行列名な
     ら、 ‘fortran’は、行列の要素それぞれに対する割り当て文を印字します
     。

     もし<expr>が‘fortran’が認識する何かでないなら、 エラーなしに、式が
     ‘grind’フォーマットで印字されます。 ‘fortran’は、リスト、配列、関数
     について知りません。

     ‘fortindent’は、‘fortran’コマンドが表示する式の 式の左マージンイン
     デントを制御します。 0は、標準のプリントアウト(すなわち6スペース)を
     与え、 正の値は、式を更に右に印字するようにします。

     ‘fortspaces’が‘true’の時、 ‘fortran’は、印字行それぞれを80カラムま
     でスペースで埋めます。

     ‘fortran’は引数を評価します; 引数のクォートは評価を無効にします。
     ‘fortran’はいつも‘done’を返します。

     例:

     (%i1) expr: (a + b)^12$
     (%i2) fortran (expr);
           (b+a)**12
     (%o2)                         done
     (%i3) fortran ('x=expr);
           x = (b+a)**12
     (%o3)                         done
     (%i4) fortran ('x=expand (expr));
           x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
          1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
          2   **3+66*a**10*b**2+12*a**11*b+a**12
     (%o4)                         done
     (%i5) fortran ('x=7+5*%i);
           x = (7,5)
     (%o5)                         done
     (%i6) fortran ('x=[1,2,3,4]);
           x = [1,2,3,4]
     (%o6)                         done
     (%i7) f(x) := x^2$
     (%i8) fortran (f);
           f
     (%o8)                         done

 -- オプション変数: fortspaces
     デフォルト値: ‘false’

     ‘fortspaces’が‘true’の時、 ‘fortran’は、印字行それぞれを80カラムま
     でスペースで埋めます。

 -- 関数: horner (<expr>, <x>)
 -- 関数: horner (<expr>)

     Horner規則に従って、もし指定されないなら<x>を主変数として使い、
     <expr>の再配列された表現を返します。 ‘x’は、<expr>の標準有理式形の
     主変数が使われる場合には、省略できます。

     もし‘expr’が数値的に評価されるものなら、 ‘horner’は、時々、安定性が
     改善されます。 また、もしMaximaがFortranで走らせるプログラムを生成
     するのに使われるなら、 役に立ちます。 ‘stringout’も参照してください
     。

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154

 -- 関数: find_root (<expr>, <x>, <a>, <b>, [<abserr>, <relerr>])
 -- 関数: find_root (<f>, <a>, <b>, [<abserr>, <relerr>])
 -- 関数: bf_find_root (<expr>, <x>, <a>, <b>, [<abserr>, <relerr>])
 -- 関数: bf_find_root (<f>, <a>, <b>, [<abserr>, <relerr>])
 -- オプション変数: find_root_error
 -- オプション変数: find_root_abs
 -- オプション変数: find_root_rel

     式<expr>もしくは関数<f>の根を、閉区間[<a>, <b>]上で見つけます。 式
     <expr>は等式でも問題ありません。 その場合、‘find_root’は
     ‘lhs(<expr>) - rhs(<expr>)’の根を探します。

     Maximaは<expr>もしくは<f>を[<a>, <b>]上で評価可能であり、 <expr>も
     しくは<f>は連続と仮定して、‘find_root’は根もしくは、 もし複数の根が
     あるなら、根の１つを見つけることを保証します。

     ‘find_root’は初め、２分木探索を適用します。 もし対象の関数が十分滑
     らかなら，‘find_root’は代わりに線形内挿を適用します。

     ‘f_find_root’は‘find_root’の多倍長浮動小数点版です。 関数は多倍長浮
     動小数点数値を使って計算され、多倍長浮動小数点の結果が返されます。
     そうでなければ、‘bf_find_root’は‘find_root’と同一で、以下の記述は
     ‘bf_find_root’に同様に適用されます。

     ‘find_root’の精度は‘abserr’と‘relerr’に支配されます。 それらは
     ‘fine_root’へのオプションのキーワード引数です。 これらのキーワード
     引数は形式‘key=val’を取ります。 キーワード引数は
     ‘abserr’
          根での関数値の望まれる絶対エラー。デフォルトは、
          ‘find_root_abs’です。
     ‘relerr’
          根の望まれる相対エラー。デフォルトは‘find_root_rel’です。

     懸案の関数が‘abserr’以下の何かに評価される時、または、 近似値<x_0>,
     <x_1>の差が‘relerr * max(abs(x_0), abs(x_1))’以下になるなら、
     ‘find_root’は停止します。

     ‘find_root_abs’と‘find_root_rel’のデフォルト値はともに零です。

     ‘find_root’は、探索区間の端で対象の関数が異なる符号を持つことを期待
     します。 関数が両方の終端での数に評価されて、それらの数が同じ符号を
     持つ時、 ‘find_root’の振る舞いは、‘find_root_error’に支配されます。
     ‘find_root_error’が‘true’の時、 ‘find_root’はエラーメッセージを出力
     します。 そうでなければ、‘find_root’は‘find_root_error’の値を返しま
     す。 ‘find_root_error’のデフォルト値は‘true’です。

     もし<f>が探索アルゴリズムの中の任意のステップで、数以外の何かに評価
     するなら、 ‘find_root’は、部分的に評価された‘find_root’式を返します
     。 <a>と<b>の順序は無視されます; 根が探索される区間は[min(<a>,
     <b>), max(<a>, <b>)]です。

     例:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981
          (%i6) find_root (exp(x) = y, x, 0, 100);
                                      x
          (%o6)           find_root(%e  = y, x, 0.0, 100.0)
          (%i7) find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o7)                   2.302585092994046
          (%i8) log (10.0);
          (%o8)                   2.302585092994046
          (%i9) fpprec:32;
          (%o9)                           32
          (%i10) bf_find_root (exp(x) = y, x, 0, 100), y = 10;
          (%o10)                  2.3025850929940456840179914546844b0
          (%i11) log(10b0);
          (%o11)                  2.3025850929940456840179914546844b0

 -- 関数: newton (<expr>, <x>, <x_0>, <eps>)

     <expr>を<x>の１変数関数と考えて、 Newton法による、‘<expr> = 0’の近
     似解を返します。 探索は、‘<x> = <x_0>’で始まり、 (<x>の現在値で評価
     された<expr>を使った)‘abs(<expr>) < <eps>’が成り立つまで続きます。

     終了テスト‘abs(<expr>) < <eps>’が‘true’または‘false’に評価される限
     り、 ‘newton’は、未定義変数が<expr>の中に現れることを許します。

     このように、 <expr>は数に評価される必要はありません。

     ‘load("newton1")’はこの関数をロードします。

     ‘realroots’, ‘allroots’, ‘find_root’, ‘mnewton’も参照してください。

     例:

          (%i1) load ("newton1");
          (%o1) /usr/share/maxima/5.10.0cvs/share/numeric/newton1.mac
          (%i2) newton (cos (u), u, 1, 1/100);
          (%o2)                   1.570675277161251
          (%i3) ev (cos (u), u = %);
          (%o3)                 1.2104963335033528E-4
          (%i4) assume (a > 0);
          (%o4)                        [a > 0]
          (%i5) newton (x^2 - a^2, x, a/2, a^2/100);
          (%o5)                  1.00030487804878 a
          (%i6) ev (x^2 - a^2, x = %);
                                                     2
          (%o6)                6.098490481853958E-4 a


File: maxima.info,  Node: Introduction to Fourier series,  Next: Functions and Variables for Fourier series,  Prev: Functions and Variables for fast Fourier transform,  Up: Numerical

22.3 Introduction to Fourier series
===================================

‘fourie’パッケージは、Fourier級数のシンボル計算のための関数を含みます。

   ‘fourie’パッケージの中には Fourier積分係数を計算する関数や、式の操作
のためのいくつかの関数があります。


File: maxima.info,  Node: Functions and Variables for Fourier series,  Prev: Introduction to Fourier series,  Up: Numerical

22.4 Functions and Variables for Fourier series
===============================================

 -- 関数: equalp (<x>, <y>)

     もし‘equal (<x>, <y>)’なら、‘true’を返し、 そうでないなら、
     ‘false’を返します。 (この場合、‘equal (x, y)’がするようなエラーメッ
     セージを与えません。)

 -- 関数: remfun (<f>, <expr>)
 -- 関数: remfun (<f>, <expr>, <x>)

     ‘remfun (<f>, <expr>)’は、 <expr>の中の‘<f> (<arg>)’すべてを<arg>で
     置き換えます。

     ‘remfun (<f>, <expr>, <x>)’は、 <expr>の中の‘<f> (<arg>)’を <arg>が
     変数<x>を含むときだけ <arg>で置き換えます。

 -- 関数: funp (<f>, <expr>)
 -- 関数: funp (<f>, <expr>, <x>)

     ‘funp (<f>, <expr>)’は、 もし<expr>が関数<f>を含むなら ‘true’を返し
     ます。

     ‘funp (<f>, <expr>, <x>)’は、 もし<expr>が関数<f>を含み、変数 <x>が
     <f>のインスタンスの１つの引数のどこかにあるなら、 ‘true’を返します
     。

 -- 関数: absint (<f>, <x>, <halfplane>)
 -- 関数: absint (<f>, <x>)
 -- 関数: absint (<f>, <x>, <a>, <b>)

     ‘absint (<f>, <x>, <halfplane>)’は、 与えられた半平面(‘pos’, ‘neg’,
     または‘both’)での <f>の<x>に関する不定積分を返します。 <f>は、形式
     ‘abs (x)’, ‘abs (sin (x))’, ‘abs (a) * exp (-abs (b) * abs (x))’ の
     式を含むことができます。

     ‘absint (<f>, <x>)’は‘absint (<f>, <x>, pos)’と同値です。

     ‘absint (<f>, <x>, <a>, <b>)’は、 <f>の <x>に関する <a>から<b>まで
     の定積分 を返します。

     <f>は、絶対値を含むことができます。

 -- 関数: fourier (<f>, <x>, <p>)

     区間‘[-p, p]’上で定義された‘<f>(<x>)’のFourier係数のリストを返しま
     す。

 -- 関数: foursimp (<l>)

     もし‘sinnpiflag’が‘true’なら、‘sin (n %pi)’を0に整理します。 もし
     ‘cosnpiflag’が‘true’なら、‘cos (n %pi)’を‘(-1)^n’に整理します。

 -- オプション変数: sinnpiflag
     デフォルト値: ‘true’

     ‘foursimp’を参照してください。

 -- オプション変数: cosnpiflag
     デフォルト値: ‘true’

     ‘foursimp’を参照してください。

 -- 関数: fourexpand (<l>, <x>, <p>, <limit>)

     Fourier係数<l>のリストから <limit>項までのFourier級数を構成し、返し
     ます。 (<limit>は‘inf’もあり得ます。) <x>と<p>は、‘fourier’における
     ものと同じ意味を持ちます。

 -- 関数: fourcos (<f>, <x>, <p>)

     ‘[0, <p>]’上で定義された ‘<f>(<x>)’のFourierコサイン係数を返します
     。

 -- 関数: foursin (<f>, <x>, <p>)

     ‘[0, <p>]’上で定義された ‘<f>(<x>)’のFourierサイン係数を返します。

 -- 関数: totalfourier (<f>, <x>, <p>)

     ‘fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>, <p>, 'inf)’を
     返します。

 -- 関数: fourint (<f>, <x>)

     ‘[minf, inf]’上で定義された ‘<f>(<x>)’のFourier積分係数のリストを構
     成し、返します。

 -- 関数: fourintcos (<f>, <x>)
     ‘[0, inf]’上の‘<f>(<x>)’のFourierコサイン積分係数を返します。

 -- 関数: fourintsin (<f>, <x>)
     ‘[0, inf]’上の‘<f>(<x>)’のFourierサイン積分係数を返します。


File: maxima.info,  Node: Matrices and Linear Algebra,  Next: Affine,  Prev: Numerical,  Up: Top

23 Matrices and Linear Algebra
******************************

* Menu:

* Introduction to Matrices and Linear Algebra::  
* Functions and Variables for Matrices and Linear Algebra::  


File: maxima.info,  Node: Introduction to Matrices and Linear Algebra,  Next: Functions and Variables for Matrices and Linear Algebra,  Prev: Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

23.1 Introduction to Matrices and Linear Algebra
================================================

* Menu:

* Dot::                         
* Vectors::                     
* eigen::


File: maxima.info,  Node: Dot,  Next: Vectors,  Prev: Introduction to Matrices and Linear Algebra,  Up: Introduction to Matrices and Linear Algebra

23.1.1 Dot
----------

演算子‘.’は、非可換乗算とスカラー積を表します。 オペランドが、1列行列ま
たは1行行列‘a’と‘b’の時、 式‘a.b’は、‘sum (a[i]*b[i], i, 1, length(a))’と
同値です。 もし‘a’と‘b’が複素数でないなら、これはスカラー積であり、 ‘a’と
‘b’の内積すなわちドット積もコールされます。 ‘a’と‘b’が複素数の時、スカラ
ー積は ‘conjugate(a).b’として定義されます; ‘eigen’パッケージの
‘innerproduct’は、複素スカラー積を供給します。

   オペランドがもっと一般的な行列の時、 積は、‘a’と‘b’の行列積です。

   ‘b’の行数は、‘a’の列数と等しくなければいけなく、 結果は、‘a’の行数と
等しい行数と ‘b’の列数と等しい列数を持ちます。

   ‘.’を算術演算子として 浮動小数点数の小数点と区別するために、 どちらか
の側にスペースを残す必要があるかもしれません。 例えば、‘5.e3’は
‘5000.0’ですが、‘5 . e3’は‘5’掛ける‘e3’です。

   ‘.’を含む式の整理を支配する いくつかのフラグがあります。 すなわち、
‘dot0nscsimp’, ‘dot0simp’, ‘dot1simp’, ‘dotassoc’, ‘dotconstrules’,
‘dotdistrib’, ‘dotexptsimp’, ‘dotident’, ‘dotscrules’。


File: maxima.info,  Node: Vectors,  Next: eigen,  Prev: Dot,  Up: Introduction to Matrices and Linear Algebra

23.1.2 Vectors
--------------

‘vect’は、ベクトル解析のための関数のパッケージです。 ‘load ("vect")’は、
このパッケージをロードし、 ‘demo ("vect")’は、デモンストレーションを表示
します。

   ベクトル解析パッケージは、 グラディエント、ダイバージェンス、カール、
ラプラシアン演算子と一緒に、 ドット積やクロス積を含むシンボリックな式を
結合したり整理したりすることができます。 これらの演算子の和や積上の分配
は、 任意の特定の直交座標系の成分への展開を含む、様々な他の展開と同様に
、 いくつかのフラグで決定されます。 場のスカラーポテンシャルやベクトルポ
テンシャルを演繹するための関数もあります。

   The ‘vect’パッケージは以下の関数を含みます: ‘vectorsimp’,
‘scalefactors’, ‘express’, ‘potential’, ‘vectorpotential’.

   デフォルトでは、‘vect’パッケージはドット演算子‘.’を可換演算子とは宣言
しません。 可換ドット演算子‘.’を得るには、コマンド‘declare(".",
commutative)’を実行しなければいけません。


File: maxima.info,  Node: eigen,  Prev: Vectors,  Up: Introduction to Matrices and Linear Algebra

23.1.3 eigen
------------

パッケージ‘eigen’は、 固有値や固有ベクトルのシンボリックな計算に充てられ
た いくつかの関数を含みます。 もし‘eigenvalues’または‘eigenvectors’の１
つが呼び出されたなら、 Maximaは、パッケージを自動的にロードします。 パッ
ケージは‘load ("eigen")’として陽にロードすることもできます。

   ‘demo ("eigen")’は、このパッケージの能力のデモンストレーションを表示
します。 ‘batch ("eigen")’は、 連続する計算の間のユーザープロンプトなし
に、 同じデモンストレーションを実行します。

   ‘eigen’パッケージの関数は、 ‘innerproduct’, ‘unitvector’,
‘columnvector’, ‘gramschmidt’, ‘eigenvalues’, ‘eigenvectors’,
‘uniteigenvectors’, ‘similaritytransform’です。


File: maxima.info,  Node: Functions and Variables for Matrices and Linear Algebra,  Prev: Introduction to Matrices and Linear Algebra,  Up: Matrices and Linear Algebra

23.2 Functions and Variables for Matrices and Linear Algebra
============================================================

 -- 関数: addcol (<M>, <list_1>, ..., <list_n>)

     １つまたは複数のリスト(または行列)が与える列を 行列<M>に追加します
     。

 -- 関数: addrow (<M>, <list_1>, ..., <list_n>)

     １つまたは複数のリスト(または行列)が与える行を 行列<M>に追加します
     。

 -- 関数: adjoint (<M>)

     行列<M>の余因子行列を返します。 余因子行列は、<M>の余因子の行列の転
     置です。

 -- 関数: augcoefmatrix ([<eqn_1>, …, <eqn_m>], [<x_1>, …, <x_n>])

     線形方程式系<eqn_1>, …, <eqn_m>の 変数<x_1>, …, <x_n>に関する拡大係
     数行列を返します。 これは、 それぞれの方程式の定数項(<x_1>, …,
     <x_n>に依存しないそれらの項) に関して隣接した列を持つ係数行列です。

          (%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
          (%i2) augcoefmatrix (m, [x, y]);
                                 [ 2  1 - a  - 5 b ]
          (%o2)                  [                 ]
                                 [ a    b      c   ]

 -- 関数: cauchy_matrix ([<x_1>,<x_2>, …, <x_m>], [<y_1>,<y_2>, …,
          <y_n>])
 -- 関数: cauchy_matrix ([<x_1>,<x_2>, …, <x_n>])

     要素<a[i,j]> = 1/(<x_i>+<y_i>)を持つ、 ‘n’掛ける<m>のCauchy行列を返
     します。 ‘cauchy_matrix’の第二引数はオプションです。 この場合、
     Cauchy行列の要素は<a[i,j]> = 1/(<x_i>+<x_j>)です。

     注意: 文献によると、Cauchy行列は2つの形式で定義されたものが見られま
     す。 2つ目の定義は<a[i,j]> = 1/(<x_i>-<y_i>)です。

     例:

          (%i1) cauchy_matrix([x1,x2],[y1,y2]);
                                [    1        1    ]
                                [ -------  ------- ]
                                [ y1 + x1  y2 + x1 ]
          (%o1)                 [                  ]
                                [    1        1    ]
                                [ -------  ------- ]
                                [ y1 + x2  y2 + x2 ]

          (%i2) cauchy_matrix([x1,x2]);
                                [   1         1    ]
                                [  ----    ------- ]
                                [  2 x1    x2 + x1 ]
          (%o2)                 [                  ]
                                [    1       1     ]
                                [ -------   ----   ]
                                [ x2 + x1   2 x2   ]

 -- 関数: charpoly (<M>, <x>)

     行列<M>の変数<x>に関する特性多項式を返します。 すなわち、
     ‘determinant (<M> - diagmatrix (length (<M>), <x>))’です。

          (%i1) a: matrix ([3, 1], [2, 4]);
                                      [ 3  1 ]
          (%o1)                       [      ]
                                      [ 2  4 ]
          (%i2) expand (charpoly (a, lambda));
                                     2
          (%o2)                lambda  - 7 lambda + 10
          (%i3) (programmode: true, solve (%));
          (%o3)               [lambda = 5, lambda = 2]
          (%i4) matrix ([x1], [x2]);
                                       [ x1 ]
          (%o4)                        [    ]
                                       [ x2 ]
          (%i5) ev (a . % - lambda*%, %th(2)[1]);
                                    [ x2 - 2 x1 ]
          (%o5)                     [           ]
                                    [ 2 x1 - x2 ]
          (%i6) %[1, 1] = 0;
          (%o6)                     x2 - 2 x1 = 0
          (%i7) x2^2 + x1^2 = 1;
                                      2     2
          (%o7)                     x2  + x1  = 1
          (%i8) solve ([%th(2), %], [x1, x2]);
                            1               2
          (%o8) [[x1 = - -------, x2 = - -------],
                         sqrt(5)         sqrt(5)

                                                       1             2
                                              [x1 = -------, x2 = -------]]
                                                    sqrt(5)       sqrt(5)

 -- 関数: coefmatrix ([<eqn_1>, …, <eqn_m>], [<x_1>, …, <x_n>])

     線形方程式系<eqn_1>, …, <eqn_m>の 変数<x_1>, …, <x_n>に関する係数行
     列を返します。

          (%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                           [ 2  1 - a ]
          (%o1)                            [          ]
                                           [ a    b   ]

 -- 関数: col (<M>, <i>)

     行列<M>の<i>番目の列を返します。 戻り値は行列です。

 -- 関数: columnvector (<L>)
 -- 関数: covect (<L>)

     リスト<L>の要素を含む１列‘length (<L>)’行の行列を返します。

     ‘covect’は、‘columnvector’と同義です。

     ‘load ("eigen")’はこの関数をロードします。

     もしこのパッケージの関数の出力の一部を行列計算で使いたいなら、これ
     は役に立ちます。

     例:

          (%i1) load ("eigen")$
          Warning - you are redefining the Macsyma function eigenvalues
          Warning - you are redefining the Macsyma function eigenvectors
          (%i2) columnvector ([aa, bb, cc, dd]);
                                       [ aa ]
                                       [    ]
                                       [ bb ]
          (%o2)                        [    ]
                                       [ cc ]
                                       [    ]
                                       [ dd ]

 -- 関数: copymatrix (<M>)
     行列<M>のコピーを返します。 これは、<M>を要素毎にコピーすることは別
     にして、コピーを作る唯一の方法です。

     ‘m2: m1’のように、１つの行列のもう１つへの割り当ては‘m1’をコピーし
     ない ことに注意してください。 An assignment 割り当て‘m2 [i,j]: x’ま
     たは‘setelmx (x, i, j, m2’は、 ‘m1 [i,j]’も変更します。 Creating a
     copy with ‘copymatrix’を使ってコピーを生成し、割り当てを使うことは
     、 別個の変更されたコピーを生成します。

 -- 関数: determinant (<M>)

     <M>の行列式をガウスの消去法と似た方法で計算します。

     結果の形式は、スイッチ‘ratmx’の設定に依ります。

     スイッチ‘ratmx’と‘sparse’がともに‘true’の時コールされる 粗な行列式
     を計算するための特殊なルーチンがあります。

 -- オプション変数: detout
     デフォルト値: ‘false’

     ‘detout’が‘true’の時、 逆行列が計算された行列の行列式は、逆行列から
     因子として外に出されます。

     このスイッチが効果を持つには、 ‘doallmxops’と‘doscmxops’は、
     ‘false’でなければいけません。 (それらの記述を参照してください。)
     ‘ev’は他の２つを正しく設定するので、 代わりに、このスイッチを‘ev’に
     与えるという方法もあります。

     例:

          (%i1) m: matrix ([a, b], [c, d]);
                                      [ a  b ]
          (%o1)                       [      ]
                                      [ c  d ]
          (%i2) detout: true$
          (%i3) doallmxops: false$
          (%i4) doscmxops: false$
          (%i5) invert (m);
                                    [  d   - b ]
                                    [          ]
                                    [ - c   a  ]
          (%o5)                     ------------
                                     a d - b c

 -- 関数: diagmatrix (<n>, <x>)

     対角要素すべてが<x>に等しい、 サイズが<n>掛ける<n>の対角線行列を返
     します。 ‘diagmatrix (<n>, 1)’は、 (‘ident (<n>)’と同じように)単位
     行列を返します。

     <n>は、整数に評価されなければいけなく、そうでなければ、
     ‘diagmatrix’はエラーメッセージを出力します。

     <x>は、別の行列を含む、任意の種類の式を取り得ます もし<x>が行列なら
     、それはコピーされません; 対角要素すべては、同じインスタンス<x>を参
     照します。

 -- オプション変数: doallmxops
     デフォルト値: ‘true’

     ‘doallmxops’が‘true’の時、 行列に関係する演算すべてが実行されます。
     ‘false’の時、 then the setting of the 個々の‘dot’スイッチの設定が、
     どの演算を実行するか決めます。

 -- オプション変数: domxexpt
     デフォルト値: ‘true’

     ‘domxexpt’が‘true’の時、 行列の指数関数, ‘exp (<M>)’ ただし<M>は行
     列, は、要素‘[i,j’が‘exp (m[i,j])’に等しい行列として解釈されます。

     そうでなければ、‘exp (<M>)’は、‘exp (<ev(M)>’に評価されます。

     ‘domxexpt’は、 形式‘<base>^<power>’の式すべてに影響します。 ここで
     、<base>はスカラーまたは定数と仮定された式、 <power>は、リストまた
     は行列です。

     例:

          (%i1) m: matrix ([1, %i], [a+b, %pi]);
                                   [   1    %i  ]
          (%o1)                    [            ]
                                   [ b + a  %pi ]
          (%i2) domxexpt: false$
          (%i3) (1 - c)^m;
                                       [   1    %i  ]
                                       [            ]
                                       [ b + a  %pi ]
          (%o3)                 (1 - c)
          (%i4) domxexpt: true$
          (%i5) (1 - c)^m;
                            [                      %i  ]
                            [    1 - c      (1 - c)    ]
          (%o5)             [                          ]
                            [        b + a         %pi ]
                            [ (1 - c)       (1 - c)    ]

 -- オプション変数: domxmxops
     デフォルト値: ‘true’

     ‘domxmxops’が‘true’の時、 行列-行列演算、行列-リスト演算すべてが実
     行されます (しかし、スカラー-行列演算は実行されません); もしこのス
     イッチが‘false’なら、 演算は実行されません。

 -- オプション変数: domxnctimes
     デフォルト値: ‘false’

     ‘domxnctimes’が‘true’の時、 行列の非可換積が実行されます。

 -- オプション変数: dontfactor
     デフォルト値: ‘[]’

     ある変数に関する因数分解が起こらないよう、 ‘dontfactor’をその変数の
     リストに設定することができます。 (リストは初期には空です。) 標準有
     理式(CRE)形で仮定される変数順序に従って、 ‘dontfactor’リスト上のそ
     れらよりも重要でない変数に関しても 因数分解は、 行われなくなります
     。

 -- オプション変数: doscmxops
     デフォルト値: ‘false’

     ‘doscmxops’が‘true’の時、 スカラー-行列演算が実行されます。

 -- オプション変数: doscmxplus
     デフォルト値: ‘false’

     ‘doscmxplus’が‘true’の時、 スカラー-行列演算は、行列の結果をもたら
     します。 このスイッチは、‘doallmxops’の下に包括されません。

 -- オプション変数: dot0nscsimp
     デフォルト値: ‘true’

     ‘dot0nscsimp’が‘true’の時、 ゼロと非スカラー項の非可換積は、可換積
     に整理されます。

 -- オプション変数: dot0simp
     デフォルト値: ‘true’

     ‘dot0simp’が‘true’の時、 ゼロとスカラー項の非可換積は、 可換積に整
     理されます。

 -- オプション変数: dot1simp
     デフォルト値: ‘true’

     ‘dot1simp’が‘true’の時、 １ともう１つの項の非可換積は、可換積に整理
     されます。

 -- オプション変数: dotassoc
     デフォルト値: ‘true’

     ‘dotassoc’が‘true’の時、 式‘(A.B).C’は‘A.(B.C)’に整理されます。

 -- オプション変数: dotconstrules
     デフォルト値: ‘true’

     ‘dotconstrules’が‘true’の時、 定数ともう１つの項の非可換積は、可換
     積に整理されます。 このフラグをオンにすることは、事実上、
     ‘dot1simp’はもちろん、‘dot0simp’, ‘dot0nscsimp’もオンにします。

 -- オプション変数: dotdistrib
     デフォルト値: ‘false’

     ‘dotdistrib’が‘true’の時、 式‘A.(B + C)’は‘A.B + A.C’に整理されます
     。

 -- オプション変数: dotexptsimp
     デフォルト値: ‘true’

     ‘dotexptsimp’が‘true’の時、 式‘A.A’は‘A^^2’に整理されます。

 -- オプション変数: dotident
     デフォルト値: 1

     ‘dotident’は‘X^^0’が返す値です。

 -- オプション変数: dotscrules
     デフォルト値: ‘false’

     ‘dotscrules’が‘true’の時、 式‘A.SC’または‘SC.A’は、‘SC*A’に整理され
     、 ‘A.(SC*B)’は‘SC*(A.B)’に整理されます。

 -- 関数: echelon (<M>)

     ガウスの消去法で生成される、行列<M>の階段形を返します。 階段形は、
     <M>から初等行演算によって計算され、 それぞれの行の最初の非ゼロ要素
     が１で、 その要素の下の列要素がすべてゼロであるような行列です。

     ‘triangularize’もガウスの消去法を実行しますが、 それぞれの行の先頭
     の非ゼロ要素を規格化しません。

     ‘lu_factor’と‘cholesky’は、他の、三角行列をもたらす関数です。

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) echelon (M);
                            [ 1  - 8  - 5      - 2     ]
                            [                          ]
                            [         28       11      ]
                            [ 0   1   --       --      ]
          (%o2)             [         37       37      ]
                            [                          ]
                            [              37 bb - 119 ]
                            [ 0   0    1   ----------- ]
                            [              37 aa - 313 ]

 -- 関数: eigenvalues (<M>)
 -- 関数: eivals (<M>)

     行列<M>の固有値を含む２つのリストのリストを返します。 戻り値の最初
     の部分リストは、行列の固有値のリストで、 二番目の部分リストは、対応
     する順序で固有値の重複度のリストです。

     ‘eivals’は、‘eigenvalues’と同義です。

     ‘eigenvalues’は、 行列の特性多項式の根を見つけるために、 関数
     ‘solve’をコールします。 時々、 ‘solve’は、多項式の根を見つけられな
     いかもしれません; その場合、このパッケージの (‘innerproduct’,
     ‘unitvector’, ‘columnvector’, ‘gramschmidt’を除いた)いくつかの他の
     関数はうまく動かないでしょう。

     いくつかの場合、‘solve’が見つける固有値は、 複雑な式かもしれません
     。 (これは、 ‘solve’が 実数とわかっている固有値について 見てもすぐ
     にはわからない実数式を返す時、起こることがあります。) 他のいくつか
     の関数を使って固有値を整理することが可能なことがあります。

     パッケージ‘eigen.mac’は、 ‘eigenvalues’や‘eigenvectors’が参照された
     時、 自動的にロードされます。 もし‘eigen.mac’がまだロードされていな
     いなら、 ‘load ("eigen")’はそれをロードします。 ロードした後は、パ
     ッケージの中の関数と変数すべてが利用可能です。

 -- 関数: eigenvectors (<M>)
 -- 関数: eivects (<M>)

     行列<M>の固有ベクトルを計算します。 戻り値は、２つの要素のリストで
     す。 最初のものは、<M>の固有値のリストと固有値の重複度のリストです
     。 二番目のものは、固有ベクトルのリストのリストです。 固有値それぞ
     れに対して固有ベクトルのリストが１つあります。 リストそれぞれの中に
     は、固有ベクトルが１つの時も複数のときもあります。

     ‘eivects’は、‘eigenvectors’と同義です。

     パッケージ‘eigen.mac’は、 ‘eigenvalues’や‘eigenvectors’が参照された
     時、 自動的にロードされます。 もし‘eigen.mac’がまだロードされていな
     いなら、 ‘load ("eigen")’はそれをロードします。 ロードした後は、パ
     ッケージの中の関数と変数すべてが利用可能です。

     この関数に影響するフラグは以下の通りです:

     ‘nondiagonalizable’は、 ‘eigenvectors’が戻った後、行列が対角化不可
     能か可能かに依って ‘true’か‘false’に設定されます。

     ‘hermitianmatrix’が‘true’の時、 エルミート行列の縮退した固有ベクト
     ルが、グラム-シュミットアルゴリズムを使って直交化されるようにします
     。

     ‘knowneigvals’が‘true’の時、 causes the ‘eigen’パッケージが、 行列
     の固有値がユーザーに知られていて、グローバル名‘listeigvals’の下記憶
     されていることを仮定するようにします。 ‘listeigvals’は、 出力
     ‘eigenvalues’に似たリストに設定されなければいけません。

     ここで、関数‘algsys’が固有ベクトルについて解くために使われます。 も
     し固有値がごちゃごちゃしているなら、 ‘algsys’は、時々、解を見つけら
     れないかもしれません。 いくつかの場合、 最初に‘eigenvalues’コマンド
     を使って固有値を見つけ、 それらをもっと簡潔な何かに換算するために他
     の関数を使うことによって、 固有値を整理することが可能かもしれません
     。 整理に続いて、 ‘true’に設定された‘knowneigvals’フラグとともに 再
     び‘eigenvectors’をコールすることができます。

     ‘eigenvalues’も参照してください。

     例:

     固有値１つにただ１つの固有ベクトルを持つ行列。

          (%i1) M1 : matrix ([11, -1], [1, 7]);
                                     [ 11  - 1 ]
          (%o1)                      [         ]
                                     [ 1    7  ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]],
                                  [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                 val  = 9 - sqrt(3)
                                    1

                                      mult  = 1
                                          1

                              vec  = [[1, sqrt(3) + 2]]
                                 1

                                 val  = sqrt(3) + 9
                                    2

                                      mult  = 1
                                          2

                              vec  = [[1, 2 - sqrt(3)]]
                                 2

          (%o3)                         done

     １つの固有値(ここでは2)に２つの固有ベクトルを持つ行列。

          (%i1) M1 : matrix ([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0],
                             [0, 0, 0, 2]);
                                   [ 0  1  0  0 ]
                                   [            ]
                                   [ 0  0  0  0 ]
          (%o1)                    [            ]
                                   [ 0  0  2  0 ]
                                   [            ]
                                   [ 0  0  0  2 ]
          (%i2) [vals, vecs] : eigenvectors (M1);
          (%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                             [[0, 0, 1, 0], [0, 0, 0, 1]]]]
          (%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
            mult[i] = vals[2][i], vec[i] = vecs[i]);
                                      val  = 0
                                         1

                                      mult  = 2
                                          1

                                vec  = [[1, 0, 0, 0]]
                                   1

                                      val  = 2
                                         2

                                      mult  = 2
                                          2

                         vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                            2

          (%o3)                         done

 -- 関数: ematrix (<m>, <n>, <x>, <i>, <j>)

     値が<x>の‘[<i>, <j>]’要素を除いて、すべての要素がゼロの <m>行<n>列
     行列を返します。

 -- 関数: entermatrix (<m>, <n>)

     対話的に要素を読み、<m>行<n>列行列を返します。

     もし<n>が<m>と等しいなら、 Maximaは、行列のタイプ(対角、対称、反対
     称、一般)の入力を促し、 それぞれの要素の入力を促します。 応答それぞ
     れは、セミコロン‘;’かドル記号‘$’で終了させます。

     もし<n>が<m>と等しくなければ、 Maximaは、それぞれの要素の入力を促し
     ます。

     要素は、任意の式を取り得、また、その式は評価されます。
     ‘entermatrix’は引数を評価します。

          (%i1) n: 3$
          (%i2) m: entermatrix (n, n)$

          Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
          4. General
          Answer 1, 2, 3 or 4 :
          1$
          Row 1 Column 1:
          (a+b)^n$
          Row 2 Column 2:
          (a+b)^(n+1)$
          Row 3 Column 3:
          (a+b)^(n+2)$

          Matrix entered.
          (%i3) m;
                          [        3                     ]
                          [ (b + a)      0         0     ]
                          [                              ]
          (%o3)           [                  4           ]
                          [    0      (b + a)      0     ]
                          [                              ]
                          [                            5 ]
                          [    0         0      (b + a)  ]

 -- 関数: genmatrix (<a>, <i_2>, <j_2>, <i_1>, <j_1>)
 -- 関数: genmatrix (<a>, <i_2>, <j_2>, <i_1>)
 -- 関数: genmatrix (<a>, <i_2>, <j_2>)

     <a>から生成される行列を返します。 返される行列は、要素
     ‘<a>[<i_1>,<j_1>]’を 左上の要素として取り、 ‘<a>[<i_2>,<j_2>]’を 右
     下の要素として取ります。 ここで、<a>は、 (‘make_array’ではなく
     ‘array’が生成する)宣言配列か、 未宣言配列か、配列関数か、２つの引数
     を持つラムダ式のいずれかです。 (配列関数は、他の関数のように、
     ‘:=’や‘define’で生成されますが、 引数は括弧の代わりにカギ括弧でくく
     られます。)

     もし<j_1>が省略されたら、 それは、<i_1>と等しいと仮定されます。 も
     し<j_1>と<i_1>両方が省略されたら、 両方とも1と等しいと仮定されます
     。

     もし配列の選択された要素‘i,j’が未定義なら、 行列は、シンボル要素
     ‘<a>[i,j]’を含みます。

     例:

          (%i1) h [i, j] := 1 / (i + j - 1);
                                              1
          (%o1)                  h     := ---------
                                  i, j    i + j - 1
          (%i2) genmatrix (h, 3, 3);
                                     [    1  1 ]
                                     [ 1  -  - ]
                                     [    2  3 ]
                                     [         ]
                                     [ 1  1  1 ]
          (%o2)                      [ -  -  - ]
                                     [ 2  3  4 ]
                                     [         ]
                                     [ 1  1  1 ]
                                     [ -  -  - ]
                                     [ 3  4  5 ]
          (%i3) array (a, fixnum, 2, 2);
          (%o3)                           a
          (%i4) a [1, 1] : %e;
          (%o4)                          %e
          (%i5) a [2, 2] : %pi;
          (%o5)                          %pi
          (%i6) genmatrix (a, 2, 2);
                                     [ %e   0  ]
          (%o6)                      [         ]
                                     [ 0   %pi ]
          (%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                                   [  0    1   2 ]
                                   [             ]
          (%o7)                    [ - 1   0   1 ]
                                   [             ]
                                   [ - 2  - 1  0 ]
          (%i8) genmatrix (B, 2, 2);
                                  [ B      B     ]
                                  [  1, 1   1, 2 ]
          (%o8)                   [              ]
                                  [ B      B     ]
                                  [  2, 1   2, 2 ]

 -- 関数: gramschmidt (<x>)
 -- 関数: gramschmidt (<x>, <F>)

     <x>に対してグラム-シュミット直交化アルゴリズムを実行します。 <x>は
     、行列かリストのリストのいずれかです。 ‘gramschmidt’は<x>を変更しま
     せん。 もし引数にあれば、‘gramschmidt’は<F>を内積として使います。 そ
     うでなければ、内積は関数‘innerproduct’です。

     もし<x>が行列なら、 アルゴリズムは <x>の行に適用されます。 もし
     <x>がリストのリストなら、 アルゴリズムは部分リストに適用されます。
     部分リストは、要素数が同じでなければいけません。 いずれの場合も、 戻
     り値は、リストのリストです。 この部分リストは互いに直交し、<x>と同
     じ空間を埋めます。 もし、<x>の全範囲の次元が行や部分リストの数より
     ちいさいなら、 戻り値の部分リストのいくつかはゼロです。

     中間結果を整理するために、アルゴリズムのそれぞれの段階で‘factor’が
     コールされます。 結果として、戻り値は、素因数分解された整数を含みま
     す。

     ‘load("eigen")’はこの関数をロードします。

     例:

     デフォルトの内積関数を使ったグラム-シュミットアルゴリズム。

          (%i1) load ("eigen")$
          (%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                                   [ 1   2   3  ]
                                   [            ]
          (%o2)                    [ 9   18  30 ]
                                   [            ]
                                   [ 12  48  60 ]
          (%i3) y: gramschmidt (x);
                                 2      2            4     3
                                3      3   3 5      2  3  2  3
          (%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                                2 7    7   2 7       5     5
          (%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
          (%o4)                       [0, 0, 0]

     指定した内積関数を使ったグラム-シュミットアルゴリズム。

          (%i1) load ("eigen")$
          (%i2) ip (f, g) := integrate (f * g, u, a, b);
          (%o2)          ip(f, g) := integrate(f g, u, a, b)
          (%i3) y : gramschmidt([1, sin(u), cos(u)], ip), a= -%pi/2, b=%pi/2;
                                         %pi cos(u) - 2
          (%o3)              [1, sin(u), --------------]
                                              %pi
          (%i4) map (ip, [y[1], y[2], y[3]], [y[2], y[3], y[1]]),
                                                          a= -%pi/2, b=%pi/2;
          (%o4)                       [0, 0, 0]

 -- 関数: ident (<n>)

     <n>行<n>列の単位行列を返します。

 -- 関数: innerproduct (<x>, <y>)
 -- 関数: inprod (<x>, <y>)

     <x>と<y>の(スカラー積やドット積とも呼ばれる)内積を返します。 <x>と
     <y>は、等しい長さのリストか、ともに等しい長さの1列行列か1行行列です
     。 戻り値は、‘conjugate (x) . y’です。 ここで、‘.’は非可換乗算演算
     子です。

     ‘load ("eigen")’はこの関数をロードします。

     ‘inprod’は、‘innerproduct’と同義です。

 -- 関数: invert (<M>)

     行列<M>の逆行列を返します。 逆行列は随伴法で計算されます。

     これは、ユーザーが 要素が多倍長浮動小数点の行列や 要素が浮動小数点
     係数多項式の行列の逆行列を、 CRE形に変換することなしに計算すること
     を可能にします。

     余因子は、‘determinant’関数で計算されるので、 もし‘ratmx’が
     ‘false’なら、 要素の表現を変えることなしに、逆行列が計算されます。

     現在の実装は、高次の行列には非効率的です。

     ‘detout’が‘true’の時、 行列式は、逆行列から係数として外に出されます
     。

     逆行列の要素は自動的には展開されません。 もし<M>が多項式の要素を持
     つなら、 ‘expand (invert (m)), detout’が、見た目がよりよい出力を生
     成することができます。 もし全体を行列式で割られたものが望ましいなら
     、 ‘xthru (%)’で達成することができます。 また、代わりに最初から以下
     のようにしても達成できます。

          expand (adjoint (m)) / expand (determinant (m))
          invert (m) := adjoint (m) / determinant (m)

     行列の逆を計算する別の方法について‘^^’ (非可換べき乗)を参照してくだ
     さい。

 -- 関数: list_matrix_entries (<M>)

     行列<M>の要素を含むリストを返します。

     例:

          (%i1) list_matrix_entries(matrix([a,b],[c,d]));
          (%o1)                     [a, b, c, d]

 -- オプション変数: lmxchar
     デフォルト値: ‘[’

     ‘lmxchar’は、行列の左区切り記号として表示される文字です。
     ‘rmxchar’も参照してください。

     例:

          (%i1) lmxchar: "|"$
          (%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                                     | a  b  c ]
                                     |         ]
          (%o2)                      | d  e  f ]
                                     |         ]
                                     | g  h  i ]

 -- 関数: matrix (<row_1>, ..., <row_n>)

     行<row_1>, ..., <row_n>を持つ長方形行列を返します。 行それぞれは、
     式のリストです。 すべての行は同じ長さでなければいけません。

     オペランドが、２つの行列、スカラーと行列、行列とスカラーのいずれか
     の時、 演算‘+’ (足し算), ‘-’ (引き算), ‘*’ (掛け算), ‘/’ (割り算)は
     要素毎に実行されます。 もしオペランドが、スカラーと行列、行列とスカ
     ラーのいずれかなら、 演算‘^’ (べき乗, ‘**’と同値)は、要素毎に実行さ
     れますが、 もしオペランドが２つの行列なら要素毎には実行されません。
     ‘.’ (非可換乗算)を含むすべての演算は、通常、完全に実行されます。

     行列の掛け算は、非可換乗算演算子‘.’で表されます。 対応する非可換べ
     き乗演算子は‘^^’です。 行列 ‘<A>’に関して、 ‘<A>.<A> = <A>^^2’であ
     り、 もし存在するなら、‘<A>^^-1’は<A>の逆行列です。

     ドット演算や行列-リスト演算を含む式の整理を制御するためのスイッチが
     あります。 それらは、 ‘doallmxops’, ‘domxexpt’ ‘domxmxops’,
     ‘doscmxops’, ‘doscmxplus’です。

     行列に関係する付加的なオプションがあります。 それらは以下の通りです
     : ‘lmxchar’, ‘rmxchar’, ‘ratmx’, ‘listarith’, ‘detout’,
     ‘scalarmatrix’, ‘sparse’

     行列を引数として取ったり、行列を戻り値としてもたらしたりするたくさ
     んの関数があります。 ‘eigenvalues’, ‘eigenvectors’, ‘determinant’,
     ‘charpoly’, ‘genmatrix’, ‘addcol’, ‘addrow’, ‘copymatrix’,
     ‘transpose’, ‘echelon’, ‘rank’を参照してください。

     例:

        • リストからの行列の組み立て。
          (%i1) x: matrix ([17, 3], [-8, 11]);
                                     [ 17   3  ]
          (%o1)                      [         ]
                                     [ - 8  11 ]
          (%i2) y: matrix ([%pi, %e], [a, b]);
                                     [ %pi  %e ]
          (%o2)                      [         ]
                                     [  a   b  ]
        • 足し算、要素毎に。
          (%i3) x + y;
                                [ %pi + 17  %e + 3 ]
          (%o3)                 [                  ]
                                [  a - 8    b + 11 ]
        • 引き算、要素毎に。
          (%i4) x - y;
                                [ 17 - %pi  3 - %e ]
          (%o4)                 [                  ]
                                [ - a - 8   11 - b ]
        • 掛け算。要素毎に。
          (%i5) x * y;
                                  [ 17 %pi  3 %e ]
          (%o5)                   [              ]
                                  [ - 8 a   11 b ]
        • 割り算。要素毎に。
          (%i6) x / y;
                                  [ 17       - 1 ]
                                  [ ---  3 %e    ]
                                  [ %pi          ]
          (%o6)                   [              ]
                                  [   8    11    ]
                                  [ - -    --    ]
                                  [   a    b     ]
        • 行列のスカラーべき、要素毎に。
          (%i7) x ^ 3;
                                   [ 4913    27  ]
          (%o7)                    [             ]
                                   [ - 512  1331 ]
        • スカラー基数の行列べき、要素毎に。
          (%i8) exp(y);
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o8)                    [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]
        • 行列基数の行列べき。これは要素毎には実行されません。
          (%i9) x ^ y;
                                          [ %pi  %e ]
                                          [         ]
                                          [  a   b  ]
                               [ 17   3  ]
          (%o9)                [         ]
                               [ - 8  11 ]
        • 非可換行列乗算。
          (%i10) x . y;
                            [ 3 a + 17 %pi  3 b + 17 %e ]
          (%o10)            [                           ]
                            [ 11 a - 8 %pi  11 b - 8 %e ]
          (%i11) y . x;
                          [ 17 %pi - 8 %e  3 %pi + 11 %e ]
          (%o11)          [                              ]
                          [  17 a - 8 b     11 b + 3 a   ]
        • 非可換行列べき乗 スカラー基数<b>の行列べき<M>は、要素毎に実行
          され、 ‘b^^m’は‘b^m’と同じです。
          (%i12) x ^^ 3;
                                  [  3833   1719 ]
          (%o12)                  [              ]
                                  [ - 4584  395  ]
          (%i13) %e ^^ y;
                                   [   %pi    %e ]
                                   [ %e     %e   ]
          (%o13)                   [             ]
                                   [    a     b  ]
                                   [  %e    %e   ]
        • 行列の-1指数の非可換べき乗は存在するなら、逆行列のことです。
          (%i14) x ^^ -1;
                                   [ 11      3  ]
                                   [ ---  - --- ]
                                   [ 211    211 ]
          (%o14)                   [            ]
                                   [  8    17   ]
                                   [ ---   ---  ]
                                   [ 211   211  ]
          (%i15) x . (x ^^ -1);
                                      [ 1  0 ]
          (%o15)                      [      ]
                                      [ 0  1 ]

 -- 関数: matrixmap (<f>, <M>)

     ‘<f>(<M>[i,j])’に等しい要素‘i,j’を持つ行列を返します。

     ‘map’, ‘fullmap’, ‘fullmapl’, ‘apply’も参照してください。

 -- 関数: matrixp (<expr>)

     もし<expr>が行列なら‘true’を返し，そうでなければ、‘false’を返します
     。

 -- オプション変数: matrix_element_add
     デフォルト値: ‘+’

     ‘matrix_element_add’は、 行列乗算の中で足し算の代わりに呼び出される
     演算です。 ‘matrix_element_add’は、 任意のn項演算子(すなわち、任意
     の数の引数を扱う関数)に割り当てられます。 割り当てられた値は、クォ
     ートマークでくくられた演算子の名前か、 関数名かラムダ式を取り得ます
     。

     ‘matrix_element_mult’と‘matrix_element_transpose’も参照してください
     。

     例:

          (%i1) matrix_element_add: "*"$
          (%i2) matrix_element_mult: "^"$
          (%i3) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o3)                      [         ]
                                     [ d  e  f ]
          (%i4) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o4)                      [         ]
                                     [ x  y  z ]
          (%i5) aa . transpose (bb);
                               [  u  v  w   x  y  z ]
                               [ a  b  c   a  b  c  ]
          (%o5)                [                    ]
                               [  u  v  w   x  y  z ]
                               [ d  e  f   d  e  f  ]

 -- オプション変数: matrix_element_mult
     デフォルト値: ‘*’

     ‘matrix_element_mult’は、 行列乗算の中で掛け算の代わりに呼び出され
     る演算です。 ‘matrix_element_mult’は、 任意の二項演算子に割り当てら
     れます。 割り当てられた値は、クォートマークでくくられた演算子の名前
     か、関数名か、 ラムダ式を取り得ます。

     ドット演算子‘.’は、いくつかの文脈で役に立つ選択です。

     ‘matrix_element_add’と‘matrix_element_transpose’も参照してください
     。

     例:

          (%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
          (%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
          (%i3) [a, b, c] . [x, y, z];
                                    2          2          2
          (%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
          (%i4) aa: matrix ([a, b, c], [d, e, f]);
                                     [ a  b  c ]
          (%o4)                      [         ]
                                     [ d  e  f ]
          (%i5) bb: matrix ([u, v, w], [x, y, z]);
                                     [ u  v  w ]
          (%o5)                      [         ]
                                     [ x  y  z ]
          (%i6) aa . transpose (bb);
                         [             2          2          2  ]
                         [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
          (%o6)  Col 1 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                                   [             2          2          2  ]
                                   [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                           Col 2 = [                                      ]
                                   [             2          2          2  ]
                                   [ sqrt((f - z)  + (e - y)  + (d - x) ) ]

 -- オプション変数: matrix_element_transpose
     デフォルト値: ‘false’

     ‘matrix_element_transpose’は、 転置される時、行列のそれぞれの要素に
     適用される演算です。 ‘matrix_element_mult’は、任意の単項演算子に割
     り当てられます。 割り当てられた値はクォートマークでくくられた演算子
     の名前か、 関数名か、ラムダ式を取り得ます。

     ‘matrix_element_transpose’が‘transpose’に等しい時、 ‘transpose’関数
     が要素すべてに適用されます。 ‘matrix_element_transpose’が
     ‘nonscalars’に等しい時、 ‘transpose’関数は非スカラー要素すべてに適
     用されます。 もしある要素がアトムなら、‘nonscalars’オプションは ア
     トムが宣言された非スカラーの時だけ‘transpose’を適用します。 一方、
     ‘transpose’オプションはいつも‘transpose’を適用します。

     デフォルト値, ‘false’,はいかなる演算も適用しないことを意味します。

     ‘matrix_element_add’と‘matrix_element_mult’も参照してください。

     例:

          (%i1) declare (a, nonscalar)$
          (%i2) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o2)                   [              ]
                                  [      b       ]
          (%i3) matrix_element_transpose: nonscalars$
          (%i4) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o4)                   [              ]
                                  [      b       ]
          (%i5) matrix_element_transpose: transpose$
          (%i6) transpose ([a, b]);
                                  [ transpose(a) ]
          (%o6)                   [              ]
                                  [ transpose(b) ]
          (%i7) matrix_element_transpose: lambda ([x], realpart(x)
                - %i*imagpart(x))$
          (%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                               [ 5 %i + 1  3 - 2 %i ]
          (%o8)                [                    ]
                               [   7 %i       11    ]
          (%i9) transpose (m);
                                [ 1 - 5 %i  - 7 %i ]
          (%o9)                 [                  ]
                                [ 2 %i + 3    11   ]

 -- 関数: mattrace (<M>)

     正方行列<M>の跡(すなわち、主対角上の要素の和)を返します。

     ‘mattrace’は、‘ncharpoly’―Maximaの‘charpoly’の代わり― によってコー
     ルされます。

     ‘load ("nchrpl")’はこの関数をロードします。

 -- 関数: minor (<M>, <i>, <j>)

     行列<M>の<i>, <j>小行列を返します。 すなわち、行<i>と列<j>を除いた
     <M>です。

 -- 関数: ncharpoly (<M>, <x>)
     行列<M>の <x>に関する特性多項式を返します。 これはMaximaの
     ‘charpoly’の代わりです。

     ‘ncharpoly’は、与えられた行列のべきの跡を計算することで機能します。
     それは、特性多項式の根のべきの和に等しいことが知られています。 それ
     らの量から根の対称関数を計算することができます。 それらは、特性多項
     式の係数以上のなにものでもありません。 ‘charpoly’は、 ‘<x> * ident
     [n] - a’の行列式を形成することで機能します。 このように、
     ‘ncharpoly’ は完全に多項式算術を避けるので、 例えば、整数で埋められ
     た大きな密な行列の場合、‘ncharpoly’が勝ります。

     ‘load ("nchrpl")’はこのファイルをロードします。

 -- 関数: newdet (<M>)

     行列<M>の行列式を ジョンソン-ジェントルマンのtree minorアルゴリズム
     を使って計算します。 ‘newdet’はCRE形式で結果を返します。

 -- 宣言: nonscalar

     アトムをドット演算子に関してリストか行列のように振る舞うようにしま
     す。

 -- 関数: nonscalarp (<expr>)

     もし<expr>が非スカラー、すなわち、 非スカラーとして宣言されたアトム
     かリスト、行列を含むなら、 ‘true’を返します。

 -- 関数: permanent (<M>, <n>)

     行列<M>のパーマネントを計算します。 パーマネントは行列式のようです
     が、符号が変わりません。 ‘permanent’はCRE形式で結果を返します。

     ‘newdet’も参照してください。

 -- 関数: rank (<M>)

     行列<M>のランクを計算します。 すなわち、<M>の、最も大きな非特異な小
     行列式の次数です。

     もし<rank>がゼロと同値の行列要素が確かにそうであることを決定するこ
     とができないなら、 、間違った答えを返します。

 -- オプション変数: ratmx
     デフォルト値: ‘false’

     ‘ratmx’が‘false’の時、 行列要素の表現で、行列式と行列の足し算、引き
     算、掛け算が実行され、 逆行列の結果は一般表現のまま残されます。

     ‘ratmx’が‘true’の時、 上で述べた４つの演算は、CRE形式で実行され、 逆
     行列の結果もCRE形式になります。 これは、(‘ratfac’の設定に依って) い
     つも望まれているわけではないですが、 要素が展開されるようになるかも
     しれないことに注意してください。

 -- 関数: row (<M>, <i>)

     行列<M>の<i>番目の行を返します。 戻り値は行列です。

 -- オプション変数: rmxchar
     デフォルト値: ‘]’

     ‘rmxchar’は、行列の右辺に描かれる文字です。

     ‘lmxchar’も参照してください。

 -- オプション変数: scalarmatrixp
     デフォルト値: ‘true’

     ‘scalarmatrixp’が‘true’の時、 1 x 1行列が行列のドット積を計算した結
     果として生成される時はいつでも、 スカラー、すなわち、行列の唯一の要
     素、に整理されます。

     ‘scalarmatrixp’が‘all’の時、 すべての1 x 1行列はスカラーに整理され
     ます。

     ‘scalarmatrixp’が‘false’の時、 1 x 1行列はスカラーに整理されません
     。

 -- 関数: scalefactors (<coordinatetransform>)

     ここで、 coordinatetransformは、形式 [[expression1, expression2,
     ...], indeterminate1, indeterminat2, ...] に評価されます。また、
     indeterminate1, indeterminate2, などは曲線座標変数であり、 直交カー
     テシアン成分の集合は、 [expression1, expression2, ...]によって、曲
     線座標を使って与えられます。

     ‘coordinates’が ベクトル[indeterminate1, indeterminate2,...]に設定
     され、 ‘dimension’がこのベクトルの長さに設定されます。 SF[1],
     SF[2], …, SF[DIMENSION]は、座標スケールファクタに設定され、
     ‘sfprod’は、これらのスケールファクタの積に設定されます。 初期には、
     3次元直交カーテシアン座標に対応して、 ‘coordinates’は[X, Y, Z]であ
     り、 ‘dimension’は3であり、SF[1]=SF[2]=SF[3]=SFPROD=1です。 式を現
     在の座標形の物理成分に展開するために、 形式?を利用する関数がありま
     す。

 -- 関数: setelmx (<x>, <i>, <j>, <M>)

     <x>を行列<M>の(<i>, <j>)番目の要素に割り当て、 変わった行列を返しま
     す。

     ‘<M> [<i>, <j>]: <x>’は同じ効果を持ちますが、 <M>の代わりに<x>を返
     します。

 -- 関数: similaritytransform (<M>)
 -- 関数: simtran (<M>)

     ‘similaritytransform’は、 行列‘M’の相似変換を計算します。
     ‘uniteigenvectors’コマンドの出力であるリストを返します。 更に、もし
     フラグ‘nondiagonalizable’が‘false’なら、 ２つのグローバル行列
     ‘leftmatrix’と‘rightmatrix’が計算されます。 これらの行列は、
     ‘leftmatrix . <M> . rightmatrix’が <M>の固有値を対角上に持つ対角行
     列となるという性質を持ちます。 もし‘nondiagonalizable’が‘true’なら
     、 左右の行列は計算されません。

     もしフラグ‘hermitianmatrix’が‘true’なら、 ‘leftmatrix’は、
     ‘rightmatrix’の転置の複素共役です。 そうでなければ、‘leftmatrix’は
     ‘rightmatrix’の逆行列です。

     ‘rightmatrix’は、列が<M>の単位固有ベクトルである行列です。 他のフラ
     グ(‘eigenvalues’と‘eigenvectors’を参照してください)は、
     ‘similaritytransform’は、 ‘rightmatrix’を形成することができるように
     なるために、パッケージの中の他の関数をコールするので、 同じ効果を持
     ちます。

     ‘load ("eigen")’はこの関数をロードします。

     ‘simtran’は、‘similaritytransform’と同義です。

 -- オプション変数: sparse
     デフォルト値: ‘false’

     ‘sparse’が‘true’の時、 かつ、もし‘ratmx’が‘true’なら、
     ‘determinant’は、粗な行列式を計算するために特別なルーチンを使います
     。

 -- 関数: submatrix (<i_1>, …, <i_m>, <M>, <j_1>, …, <j_n>)
 -- 関数: submatrix (<i_1>, …, <i_m>, <M>)
 -- 関数: submatrix (<M>, <j_1>, …, <j_n>)

     行<i_1>, …, <i_m>が取り除かれ、 列<j_1>, …, <j_n>が取り除かれた 行
     列<M>から構成された新しい行列を返します。

 -- 関数: transpose (<M>)
     <M>の転置を返します。

     もし<M>が行列なら、 戻り値は、‘N[i,j] = M[j,i]’であるような別の行列
     <N>です。

     もし<M>がリストなら、 返し値は、‘N[i,1] = M[i]’であるような、
     ‘length (m)’行1列の行列<N>です。

     そうでなければ<M>はシンボルで、 戻り値は、名詞式‘'transpose (<M>)’で
     す。

 -- 関数: triangularize (<M>)

     ガウスの消去法で生成されるような、行列‘M’の右上三角化行列を返します
     。 戻り値は、 それぞれの行の先頭の非ゼロ係数が1に規格化されないこと
     を除いて、 ‘echelon’と同じです。

     ‘lu_factor’と‘cholesky’は、三角化行列をもらたす他の関数です。

          (%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                                 [  3   7  aa  bb ]
                                 [                ]
          (%o1)                  [ - 1  8  5   2  ]
                                 [                ]
                                 [  9   2  11  4  ]
          (%i2) triangularize (M);
                       [ - 1   8         5            2      ]
                       [                                     ]
          (%o2)        [  0   - 74     - 56         - 22     ]
                       [                                     ]
                       [  0    0    626 - 74 aa  238 - 74 bb ]

 -- 関数: uniteigenvectors (<M>)
 -- 関数: ueivects (<M>)

     行列<M>の単位固有ベクトルを計算します。 戻り値は、リストのリストで
     す。 最初の部分リストは‘eigenvalues’コマンドの出力であり、 他の部分
     リストは、固有値それぞれに対応する行列の単位固有ベクトルです。

     ‘eigenvectors’コマンドでの記述で言及されたフラグは、 これに関しても
     同じ効果を持ちます。

     ‘knowneigvects’が‘true’の時、 ‘eigen’パッケージは、 行列の固有ベク
     トルがユーザーに知られていて、 グローバル名‘listeigvects’の下に記憶
     されていることを仮定します。 ‘listeigvects’は、 ‘eigenvectors’コマ
     ンドの出力に似たリストに設定されなければいけません。

     もし‘knowneigvects’が‘true’に設定されていて、 固有ベクトルのリスト
     が与えれているなら、 フラグ‘nondiagonalizable’の設定は正しくないか
     もしれません。 もしこの場合に該当するなら、正しい値に設定してくださ
     い。 作者は、ユーザーがしていることを知っていること、 固有値が適切
     な次元のベクトル空間を作り出さない行列を対角化しようとはしないこと
     を 仮定しています。

     ‘load ("eigen")’はこの関数をロードします。

     ‘ueivects’は‘uniteigenvectors’と同義です。

 -- 関数: unitvector (<x>)
 -- 関数: uvect (<x>)

     <x>/norm(<x>)を返します; これは、<x>と同じ向きの単位ベクトルです。

     ‘load ("eigen")’はこの関数をロードします。

     ‘uvect’は、‘unitvector’と同義です。

 -- 関数: vectorpotential (<givencurl>)

     現在の座標系で与えられた回転ベクトルのベクトルポテンシャルを返しま
     す。 ‘potentialzeroloc’が ‘potential’に対して似たような役割を持ちま
     すが、 等式の左辺側の次数は座標変数の巡回置換でなければいけません。

 -- 関数: vectorpotential (<givencurl>)
     現在の座標系で、与えられた回転ベクトルのベクトルポテンシャルを返し
     ます。 ‘potentialzeroloc’は、‘potential’と同様の役割を持ちますが、
     等式の左辺の順序が座標の巡回置換でなければいけません。

 -- 関数: vectorsimp (<expr>)
     以下のグローバルフラグに従って整理と展開を適用します:

     ‘expandall’, ‘expanddot’, ‘expanddotplus’, ‘expandcross’, ‘expandcrossplus’,
     ‘expandcrosscross’, ‘expandgrad’, ‘expandgradplus’, ‘expandgradprod’,
     ‘expanddiv’, ‘expanddivplus’, ‘expanddivprod’, ‘expandcurl’, ‘expandcurlplus’,
     ‘expandcurlcurl’, ‘expandlaplacian’, ‘expandlaplacianplus’,
     ‘expandlaplacianprod’.

     これらのフラグすべては、デフォルト値‘false’を持ちます。 ‘plus’接尾
     辞は、加算性や分配性の利用に関係します。 ‘prod’接尾辞は、任意の種類
     の積のオペランドに関する展開に関係します。

     ‘expandcrosscross’
          p ~ (q ~ r)を(p . r)*q - (p . q)*rに整理します。
     ‘expandcurlcurl’
          curl curl pをgrad div p + div grad pに整理します。
     ‘expandlaplaciantodivgrad’
          laplacian pをdiv grad pに整理します。
     ‘expandcross’
          ‘expandcrossplus’と‘expandcrosscross’を有効にします。
     ‘expandplus’
          ‘expanddotplus’, ‘expandcrossplus’, ‘expandgradplus’,
          ‘expanddivplus’, ‘expandcurlplus’, ‘expandlaplacianplus’を有効にします。
     ‘expandprod’
          ‘expandgradprod’, ‘expanddivprod’, ‘expandlaplacianprod’を有効
          にします。

     これらのフラグはすべて‘evflag’として宣言されています。

 -- オプション変数: vect_cross
     デフォルト値: ‘false’

     ‘vect_cross’が‘true’の時、 ~がSHARE;VECTの中で定義されているところ
     (とにかく、VECT_CROSSが‘true’に設定されているところ) で
     DIFF(X~Y,T)が機能するようにします。

 -- 関数: zeromatrix (<m>, <n>)

     要素すべてがゼロの<m>行<n>列行列を返します。


File: maxima.info,  Node: Affine,  Next: itensor,  Prev: Matrices and Linear Algebra,  Up: Top

24 Affine
*********

* Menu:

* Introduction to Affine::
* Functions and Variables for Affine::


File: maxima.info,  Node: Introduction to Affine,  Next: Functions and Variables for Affine,  Prev: Affine,  Up: Affine

24.1 Introduction to Affine
===========================

‘affine’は多項式の群を扱うパッケージです。


File: maxima.info,  Node: Functions and Variables for Affine,  Prev: Introduction to Affine,  Up: Affine

24.2 Functions and Variables for Affine
=======================================

 -- 関数: fast_linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     変数<x_1>, ..., <x_n>に関する連立線形方程式<expr_1>, ..., <expr_m>
     を解きます。 <expr_i>それぞれは、等式か一般式を取り得ます; もし一般
     式として与えられたら、 形式‘<expr_i> = 0’の等式として扱われます。

     戻り値は、 形式‘[<x_1> = <a_1>, ..., <x_n> = <a_n>]’ の等式のリスト
     です。 ここで、<a_1>, ..., <a_n>はすべて<x_1>, ..., <x_n>を含みませ
     ん。

     ‘fast_linsolve’は、 粗な方程式系に対して‘linsolve’より速いです。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: grobner_basis ([<expr_1>, ..., <expr_m>])
     等式<expr_1>, ..., <expr_m>のグレブナー基底を返します。 等式に関係
     する他の関数を整理するためには、 その後、関数‘polysimp’を使うことが
     できます。

          grobner_basis ([3*x^2+1, y*x])$

          polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2

     ‘polysimp(f)’は、 <f>が<expr_1>, ..., <expr_m>によって生成されたイ
     デアルに含まれるときだけ、 すなわち、<f>が<expr_1>, ..., <expr_m>の
     要素の多項式結合の時だけ、 0をもたらします。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: set_up_dot_simplifications (<eqns>, <check_through_degree>)
 -- 関数: set_up_dot_simplifications (<eqns>)
     The <eqns>は、非可換変数を含む多項式方程式です ‘current_variables’の
     値は、次数を計算するために使われる変数のリストです。 手続きが終了す
     るためには、方程式は斉次でなければいけません。

     もし <f>の次数上の‘dot_simplifications’に関する重複整理をチェックし
     たら、 以下は真です: <f>が方程式によって生成されたイデアルに含まれ
     る時だけ、 すなわち、<f>が方程式の要素の多項式結合の時だけ、
     ‘dotsimp (<f>)’は、0をもたらします。

     次数は‘nc_degree’で返されるものです。 これは、さらに、個々の変数の
     重みに影響されます。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: declare_weights (<x_1>, <w_1>, ..., <x_n>, <w_n>)
     重み <w_1>, ..., <w_n> それぞれを<x_1>, ..., <x_n>に割り当てます。
     これらは、‘nc_degree’を計算する時に使われる重みです。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: nc_degree (<p>)
     非可換多項式<p>の次数を返します。 ‘declare_weights’を参照してくださ
     い。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: dotsimp (<f>)
     <f>が方程式によって生成されたイデアルに含まれる時だけ、 すなわち、
     <f>が方程式の要素の多項式結合の時だけ、 0を返します。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: fast_central_elements ([<x_1>, ..., <x_n>], <n>)
     もし‘set_up_dot_simplifications’が以前に実行されていたら、 与えられ
     た次数<n>での変数<x_1>, ..., <x_n>に関する中心多項式 を見つけます。

     例えば:
          set_up_dot_simplifications ([y.x + x.y], 3);
          fast_central_elements ([x, y], 2);
          [y.y, x.x];

     ‘load("affine")’ loads this function.

 -- 関数: check_overlaps (<n>, <add_to_simps>)
     次数<n>までの重複をチェックします。 すなわち、‘dotsimp’が正しく機能
     するように、 それぞれの次数で十分な整理規則を持つことを確認します。
     もしあらかじめ単項式の空間次元が何か知っているなら、 このプロセスは
     、スピードアップできます。 もし有限グローバル次元なら、 ‘hilbert’が
     使われるべきです。 もし単項式次元を知らないなら、 ‘rank_function’を
     指定しないでください。 オプションの三番目の引数‘reset’は、 ‘false’は
     、物事の再設定についてわざわざ問い合わせないように言います。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: mono ([<x_1>, ..., <x_n>], <n>)
     次数<n>の変数<x_1>, ..., <x_n>に関する現在のドット整理に関係した 独
     立な単項式のリストを返します。

     ‘load("affine")’ loads this function.

 -- 関数: monomial_dimensions (<n>)
     カレント代数に関する次数<n>までのヒルベルト級数を計算します。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: extract_linear_equations ([<p_1>, ..., <p_n>], [<m_1>, ...,
          <m_n>])

     非可換単項式<m_1>, ..., <m_n>の 非可換多項式<p_1>, ..., <p_n> の係
     数のリストを作ります。 係数はスカラーでなければいけません。 単項式
     のリストを組み立てるには、‘list_nc_monomials’を使ってください。

     ‘load("affine")’はこの関数をロードします。

 -- 関数: list_nc_monomials ([<p_1>, ..., <p_n>])
 -- 関数: list_nc_monomials (<p>)

     多項式<p>または多項式のリスト<p_1>, ..., <p_n> の中に現れる非可換単
     項式のリストを返します。

     ‘load("affine")’はこの関数をロードします。

 -- オプション変数: all_dotsimp_denoms
     デフォルト値: ‘false’

     ‘all_dotsimp_denoms’がリストの時、 ‘dotsimp’が出会う分母がリストに
     追加されます。 ‘all_dotsimp_denoms’は、 ‘dotsimp’をコールする前に 空
     のリスト‘[]’に初期化されるかもしれません。

     デフォルトでは、‘dotsimp’は分母を集めません。


File: maxima.info,  Node: itensor,  Next: ctensor,  Prev: Affine,  Up: Top

25 itensor
**********

* Menu:

* Introduction to itensor::
* Functions and Variables for itensor::


File: maxima.info,  Node: Introduction to itensor,  Next: Functions and Variables for itensor,  Prev: itensor,  Up: itensor

25.1 Introduction to itensor
============================

Maximaは、記号的なテンソル操作を２つの異なったタイプで実装しています: 成
分テンソル操作(‘ctensor’パッケージ)と添字テンソル操作(‘itensor’パッケー
ジ)。

   注意せよ: 以下の’新しいテンソル表記’に関するノートを参照してください
。

   成分テンソル操作は、 幾何学的テンソルオブジェクトが配列または行列で表
現されることを意味します。 縮約や共変微分のようなテンソル演算は実際に、
‘do’文を伴う繰り返し用(ダミー)添字上の和によって実行されます。 すなわち
、配列や行列に記憶された適切なテンソル成分上で陽に演算を実行します。

   添字テンソル操作は、 共変、反変、そして微分添字の関数としてテンソルを
表現することで実装されています。 縮約や共変微分のようなテンソル演算は、
対応する成分よりむしろ添字それ自身を操作することで実行されます。

   Riemann幾何の文脈での微分的、代数的、解析的処理へのこれらの２つのアプ
ローチは、 ユーザーの問題の個々の性質と難しさを通してだけ明らかにされる
様々な利点と欠点を持ちます。 しかしながら、２つの実装の以下の特性を心に
とどめて置くべきです:

   成分を陽に使ったテンソルとテンソル演算の表現は、 ‘ctensor’を使いやす
くします。 軽量の指定と、帰納されたテンソルと不変量の計算は容易です。
Maximaの強力な整理能力すべてはいつでも使えますが、 入り組んだ関数的、座
標依存性を持つ複雑な計量は、簡単に、サイズが極端で、構造が隠された式に 至
ります。 さらに、たくさんの計算は、増大する中間式を含み、プログラムが完
了前に終了する原因となります。 経験を通して、ユーザーはこれらの難しさの
多くを避けることができます。

   テンソルとテンソル演算が添字上の記号演算を使って表される特別な方法の
ために、 成分表現では処理できなかった式が、時々、 ‘itensor’の中の対称オ
ブジェクトに関する特別なルーチンを使うことで、 たいそう整理することがで
きます。 この方法で、大きな式の構造がもっと明白になるかもしれません。 他
方で、 ‘itensor’の中の特別な添字表現のために、 いくつかの場合、 ユーザー
は、計量の指定や関数の定義、微分された「添字付き」オブジェクトの評価に 難
しさを見いだすかもしれません。

   ‘itensor’パッケージは、添字付き変数に関する微分を実行できます。 それ
は、ラグランジアンとハミルトニアン形式を扱う時にパッケージを使うことがで
きます。 (添字付き)場の変数に関する場のラグランジアンを微分することが可
能なので、 Maximaを、対応するEuler-Lagrange方程式を添字形式で得るのに使
うことができます。 これらの方程式は、 ‘ic_convert’関数を使って、成分テン
ソル(‘ctensor’)プログラムに翻訳することができ、 それは場の方程式を個別の
座標表現で解くことや、 ハミルトニアン形式の運動方程式を計算し直すことを
可能にします。 ２つの包括的な例として、‘einhil.dem’と‘bradic.dem’を参照
してください。 最初の‘einhil.dem’は、 斉次で等方的な場合(Friedmann方程式
)と 球対称で静的な場合(Schwarzschild解)に のEinsteinの場テンソルを得るた
めに Einstein-Hilbert作用を使います。 二番目の‘bradic.dem’は、
Brans-Dicke重力理論の作用からFriedmann方程式を計算する方法を示し、 理論
のスカラー場に関連したハミルトニアンも演繹します。

25.1.1 New tensor notation
--------------------------

Maximaの‘itensor’パッケージの初期のバージョンは、 時々、間違った添字順序
に至る表記を使いました。 例えば、以下を考えてください:

     (%i2) imetric(g);
     (%o2)                                done
     (%i3) ishow(g([],[j,k])*g([],[i,l])*a([i,j],[]))$
                                      i l  j k
     (%t3)                           g    g    a
                                                i j
     (%i4) ishow(contract(%))$
                                           k l
     (%t4)                                a

   ‘a’が偶然対称テンソルでなければ、 この結果は間違っています これが起こ
る理由は、 ‘itensor’は正しく共変添字と反変添字の集合の中の順序を保つけれ
ども、 一旦、添字が上がったり、下がったりすると、 添字の他の集合に関する
位置が失われるからです。

   この問題を避けるため、 存在する表記と完全に互換性を残し、相互に使うこ
とが可能な新しい表記が開発されました。 この表記では、反変添字は、共変添
字リストの中の適切な位置に挿入されますが、 マイナス記号が前に付けられま
す。 現在、‘contract’や‘ishow’のような関数は、 この新しい添字表記に通じ
ており、 テンソルを適切に処理することができます。

   この新しい表記では、以前の例は正しい結果をもたらします:

     (%i5) ishow(g([-j,-k],[])*g([-i,-l],[])*a([i,j],[]))$
                                      i l       j k
     (%t5)                           g    a    g
                                           i j
     (%i6) ishow(contract(%))$
                                           l k
     (%t6)                                a

   現在、 この表記を使う唯一のコードは、‘lc2kdt’関数です。 数値添字に頼
らずLevi-Civita記号を決定するために計量テンソルを用いる時、 この表記を通
じて、一貫した結果を達成します。

   このコードはできたばかりなので、おそらくバグを含みます。 「古い」テン
ソル表記を使った何かを壊さないことを確認するためにテストされている一方、
「新しい」テンソルが 特定の関数や特徴と相互運営するのに失敗する相当な可
能性があります。 これらのバグは、出会った時修正されるでしょう。それまで
は、利用者責任！

25.1.2 Indicial tensor manipulation
-----------------------------------

添字テンソル操作パッケージは‘load("itensor")’でロードできます。 デモも利
用可能です: ‘demo(tensor)’を試してください。

   ‘itensor’では、 テンソルは「添字付きオブジェクト」として表されます。
これは 共変、反変、微分添字を表す添字の3つのグループの関数です。 共変添
字は添字付きオブジェクトの最初の引数としてリストで指定され、 半変添字は
二番目の引数としてリストで指定されます。 もし添字付きオブジェクトが添字
のグループのいずれかを欠いているなら、 空のリスト‘[]’が対応する引数とし
て与えられます。 例えば、‘g([a,b],[c])’は、 ２つの共変添字‘(a,b)’と１つ
の反変添字(‘c’)を持ち、微分添字を持たない ‘g’と呼ばれる添字付きオブジェ
クトを表します。

   もし存在するなら、微分添字は、テンソルを表すシンボル関数の追加の引数
として添えられます。 それらは、ユーザーによって陽に指定されたり、ある座
標変数に関する微分の処理の中で生成されたりします。 常微分は可換なので、
フレーム計量が使われることを示す‘iframe_flag’が‘true’に設定されない限り
、 微分添字はアルファベット順に並び替えられます。 この標準オーダーは、
Maximaが、例えば、‘t([a],[b],i,j)’が‘t([a],[b],j,i)’と同じだと認識するこ
とを可能にします。 添字付きオブジェクトの引数として現れない添字の座標に
関する 添字付きオブジェクトの微分は、通常ゼロをもたらします。 これは、
Maximaが添字付きオブジェクトで表されたテンソルが対応する座標に陰に依存す
るかもしれないことを知らないためです。 ‘itensor’現在のMaxima関数‘diff’を
修正したことで、 そうでなければ記述されない限り、Maximaは、添字付きオブ
ジェクトすべてが微分の任意の変数に依存することを現在仮定します。 これは
、和の慣例が微分添字に拡張されることを可能にします。 ‘itensor’は微分添字
を上げる能力を所有しないこと、そしてそれらは常に共変として扱われることに
注意すべきです。

   以下の関数が添字付きオブジェクトを操作するためにテンソルパッケージの
中で利用可能です。 現在、整理ルーチンに関して、添字付きオブジェクトがデ
フォルトで対称性を持たないことを仮定します。 これは、変数
‘allsym[false]’を‘true’に設定することで上書きすることができます。 これに
よって、すべての添字付きオブジェクトを共変添字のリストと反変添字のリスト
に関して完全に対称に扱うようになります。

   ‘itensor’パッケージは、一般にテンソルを不透明なオブジェクトとして扱い
ます。 テンソル等式は、代数ルール、特に対称性と縮約ルールに基づいて操作
されます。 加えて、‘itensor’パッケージは、共変微分、曲率、ねじれ率を理解
します。 計算は、‘iframe_flag’変数の設定に依存して動枠の計量に関して実行
されます。

   以下のサンプルセッションは、 ‘itensor’パッケージをロードし、計量名を
指定し、いくつかの簡単な計算を実行する仕方を 例示します。

     (%i1) load("itensor");
     (%o1)      /share/tensor/itensor.lisp
     (%i2) imetric(g);
     (%o2)                                done
     (%i3) components(g([i,j],[]),p([i,j],[])*e([],[]))$
     (%i4) ishow(g([k,l],[]))$
     (%t4)                               e p
                                            k l
     (%i5) ishow(diff(v([i],[]),t))$
     (%t5)                                  0
     (%i6) depends(v,t);
     (%o6)                               [v(t)]
     (%i7) ishow(diff(v([i],[]),t))$
                                         d
     (%t7)                               -- (v )
                                         dt   i
     (%i8) ishow(idiff(v([i],[]),j))$
     (%t8)                                v
                                           i,j
     (%i9) ishow(extdiff(v([i],[]),j))$
     (%t9)                             v    - v
                                        j,i    i,j
                                       -----------
                                            2
     (%i10) ishow(liediff(v,w([i],[])))$
                                    %3          %3
     (%t10)                        v   w     + v   w
                                        i,%3    ,i  %3
     (%i11) ishow(covdiff(v([i],[]),j))$
                                                   %4
     (%t11)                        v    - v   ichr2
                                    i,j    %4      i j
     (%i12) ishow(ev(%,ichr2))$
                     %4 %5
     (%t12) v    - (g      v   (e p       + e   p     - e p       - e    p
             i,j            %4     j %5,i    ,i  j %5      i j,%5    ,%5  i j

                                              + e p       + e   p    ))/2
                                                   i %5,j    ,j  i %5
     (%i13) iframe_flag:true;
     (%o13)                               true
     (%i14) ishow(covdiff(v([i],[]),j))$
                                                  %6
     (%t14)                        v    - v   icc2
                                    i,j    %6     i j
     (%i15) ishow(ev(%,icc2))$
                                                  %6
     (%t15)                        v    - v   ifc2
                                    i,j    %6     i j
     (%i16) ishow(radcan(ev(%,ifc2,ifc1)))$
                  %6 %7                    %6 %7
     (%t16) - (ifg      v   ifb       + ifg      v   ifb       - 2 v
                         %6    j %7 i             %6    i j %7      i,j

                                                  %6 %7
                                             - ifg      v   ifb      )/2
                                                         %6    %7 i j
     (%i17) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t17)                            s    - s
                                        i j    j i
     (%i18) decsym(s,2,0,[sym(all)],[]);
     (%o18)                               done
     (%i19) ishow(canform(s([i,j],[])-s([j,i])))$
     (%t19)                                 0
     (%i20) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t20)                            a    + a
                                        j i    i j
     (%i21) decsym(a,2,0,[anti(all)],[]);
     (%o21)                               done
     (%i22) ishow(canform(a([i,j],[])+a([j,i])))$
     (%t22)                                 0

