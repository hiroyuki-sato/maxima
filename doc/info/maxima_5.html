<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Expressions</TITLE>
<link href="maxima_6.html" rel=Next>
<link href="maxima_4.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_4.html">previous</A>, <A HREF="maxima_6.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC18" HREF="maxima_toc.html#TOC18">Expressions</A></H1>



<H2><A NAME="SEC19" HREF="maxima_toc.html#TOC19">Introduction to Expressions</A></H2>

<P>
There are a number of reserved words which cannot be used as
variable names.   Their use would cause a possibly cryptic syntax error.

</P>

<PRE>
INTEGRATE            NEXT           FROM                 DIFF            
IN                   AT             LIMIT                SUM             
FOR                  AND            ELSEIF               THEN            
ELSE                 DO             OR                   IF              
UNLESS               PRODUCT        WHILE                THRU            
STEP                                                                     
</PRE>

<P>
Most things in MAXIMA are expressions.   A sequence of expressions
can be made into an expression by separating them by commas and
putting parentheses around them.   This is similar to the <B>C</B>
<I>comma expression</I>.

</P>

<PRE>
(C29) x:3$
(C30) joe:(x:x+1,x:x*x);
(D30) 16
(C31) joe:(if (x &#62;17) then 2 else 4);
(D31) 4
(C32) joe:(if (x &#62;17) then x:2 else joe:4,joe+x);
(D32) 20
</PRE>

<P>
Even loops in maxima are expressions, although the value they
return is the not too useful <CODE>DONE</CODE>

</P>

<PRE>
(C33) joe:(x:1,for i from 1 thru 10 do (x:x*i));
(D33) DONE
</PRE>

<P>
whereas what you really want is probably to include a third
term in the <I>comma expression</I> which actually gives back the value.

</P>

<PRE>
(C34) joe:(x:1,for i from 1 thru 10 do (x:x*i),x);
(D34) 3628800
</PRE>



<H2><A NAME="SEC20" HREF="maxima_toc.html#TOC20">ASSIGNMENT</A></H2>
<P>
 - There are two assignment operators in MACSYMA, : and :: .
E.g. A:3 sets the variable A to 3.  :: assigns the value of the
expression on its right to the value of the quantity on its left,
which must evaluate to an atomic variable or subscripted variable.

</P>


<H2><A NAME="SEC21" HREF="maxima_toc.html#TOC21">COMPLEX</A></H2>
<P>
 - A complex expression is specified in MACSYMA by adding the
real part of the expression to %I times the imaginary part.  Thus the
roots of the equation X^2-4*X+13=0 are 2+3*%I and 2-3*%I.  Note that
simplification of products of complex expressions can be effected by
expanding the product.  Simplification of quotients, roots, and other
functions of complex expressions can usually be accomplished by using
the REALPART, IMAGPART, RECTFORM, POLARFORM, ABS, CARG functions.

</P>


<H2><A NAME="SEC22" HREF="maxima_toc.html#TOC22">INEQUALITY</A></H2>
<P>
 - MACSYMA has the usual inequality operators:
less than:  &#60;
greater than:  &#62;
greater than or equal to:  &#62;=
less than or equal to:  &#60;=

</P>


<H2><A NAME="SEC23" HREF="maxima_toc.html#TOC23">SYNTAX</A></H2>
<P>
 - It is possible to add new operators to MACSYMA (infix,
prefix, postfix, unary, or matchfix with given precedences), to remove
existing operators, or to redefine the precedence of existing
operators.  While MACSYMA's syntax should be adequate for most
ordinary applications, it is possible to define new operators or
eliminate predefined ones that get in the user's way.  The extension
mechanism is rather straightforward and should be evident from the
examples below.

<PRE>
(C1) PREFIX("DDX")$
(C2) DDX Y$
     /* means                   "DDX"(Y) */
(C3) INFIX("&#60;-")$
(C4) A&#60;-DDX Y$
    /* means               "&#60;-"(A,"DDX"(Y)) */

</PRE>

<P>
For each of the types of operator except SPECIAL, there is a
corresponding creation function that will give the lexeme specified
the corresponding parsing properties.  Thus "PREFIX("DDX")" will make
"DDX" a prefix operator just like "-" or "NOT".  Of course, certain
extension functions require additional information such as the
matching keyword for a matchfix operator.  In addition, binding powers
and parts of speech must be specified for all keywords defined.  This
is done by passing additional arguments to the extension functions.
If a user does not specify these additional parameters, MACSYMA will
assign default values.  The six extension functions with binding
powers and parts of speech defaults (enclosed in brackets) are
summarized below.
PREFIX(operator, rbp[180], rpos[ANY], pos[ANY])
POSTFIX(operator, lbp[180], lpos[ANY], pos[ANY])
INFIX(operator, lbp[180], rbp[180], lpos[ANY], rpos[ANY],pos[ANY])
NARY(operator, bp[180], argpos[ANY], pos[ANY])
NOFIX(operator, pos[ANY])
MATCHFIX(operator, match, argpos[ANY], pos[ANY])
    The defaults have been provided so that a user who does not wish
to concern himself with parts of speech or binding powers may simply
omit those arguments to the extension functions.  Thus the following
are all equivalent.
PREFIX("DDX",180,ANY,ANY)$
PREFIX("DDX",180)$
PREFIX("DDX")$
    It is also possible to remove the syntax properties of an operator
by using the functions REMOVE or KILL.  Specifically,
"REMOVE("DDX",OP)" or "KILL("DDX")" will return "DDX" to operand
status; but in the second case all the other properties of "DDX" will
also be removed.

<PRE>

(C20) PREFIX("DDX",180,ANY,ANY)$

(C21) DDXYZ;

(D21) 				    DDX YZ

(C26) "ddx"(u):=u+4;

(D26) 			        DDX u := u + 4
(C27) ddx 8;

(D27) 				      12
</PRE>



<H2><A NAME="SEC24" HREF="maxima_toc.html#TOC24">Definitions for Expressions</A></H2>
<P>
<DL>
<DT><U>Function:</U> <B>AT</B> <I>(exp, list)</I>
<DD><A NAME="IDX84"></A>
will evaluate exp (which may be any expression) with
the variables assuming the values as specified for them in the list of
equations or the single equation similar to that given to the ATVALUE
function.  If a subexpression depends on any of the variables in list
but it hasn't had an atvalue specified and it can't be evaluated then
a noun form of the AT will be returned which will display in a
two-dimensional form.  Do EXAMPLE(AT); for an example.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>BOX</B> <I>(expr)</I>
<DD><A NAME="IDX85"></A>
returns expr enclosed in a box.  The box is actually part
of the expression.

<PRE>
BOX(expr,label)
</PRE>

<P>
encloses expr in a labelled box.
label is a name which will be truncated in display if it is too long.
    BOXCHAR["] - is the character used to draw the box in this and in
the DPART and LPART functions.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>BOXCHAR</B>
<DD><A NAME="IDX86"></A>
 default: ["] is the character used to draw the box in the BOX
and in the DPART and LPART functions.

</P>
</DL>
<P>
<DL>
<DT><U>special operator:</U> <B>CONSTANT</B>
<DD><A NAME="IDX87"></A>
 - makes ai a constant as is %PI.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CONSTANTP</B> <I>(exp)</I>
<DD><A NAME="IDX88"></A>
is TRUE if exp is a constant (i.e.  composed of
numbers and %PI, %E, %I or any variables bound to a constant or
DECLAREd constant) else FALSE.  Any function whose arguments are
constant is also considered to be a constant.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CONTRACT</B> <I>(exp)</I>
<DD><A NAME="IDX89"></A>
carries out all possible contractions in exp, which may
be any well-formed combination of sums and products.  This function
uses the information given to the DEFCON function.  Since all tensors
are considered to be symmetric in all indices, the indices are sorted
into alphabetical order.  Also all dummy indices are renamed using the
symbols !1,!2,... to permit the expression to be simplified as much as
possible by reducing equivalent terms to a canonical form.  For best
results exp should be fully expanded.  RATEXPAND is the fastest way to
expand products and powers of sums if there are no variables in the
denominators of the terms.  The GCD switch should be FALSE if gcd
cancellations are unnecessary.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DECLARE</B> <I>(a1, f1, a2, f2, ...)</I>
<DD><A NAME="IDX90"></A>
gives the atom ai the flag fi.  The ai's
and fi's may also be lists of atoms and flags respectively in which
case each of the atoms gets all of the properties.  The possible flags
and their meanings are:

</P>
<P>
CONSTANT - makes ai a constant as is %PI.

</P>
<P>
MAINVAR - makes ai a MAINVAR.  The ordering scale for atoms: numbers &#60;
constants (e.g. %E,%PI) &#60; scalars &#60; other variables &#60; mainvars.

</P>
<P>
SCALAR - makes ai a scalar.

</P>
<P>
NONSCALAR - makes ai behave as does a list or matrix with respect to
the dot operator.

</P>
<P>
NOUN - makes the function ai a noun so that it won't be evaluated
automatically.

</P>
<P>
EVFUN - makes ai known to the EV function so that it will get applied
if its name is mentioned.  Initial evfuns are

<PRE>
FACTOR, TRIGEXPAND,
TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, and RADCAN
</PRE>

<P>
EVFLAG - makes ai known to the EV function so that it will be bound to
TRUE during the execution of EV if it is mentioned.  Initial evflags
are

<PRE>
FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE,
KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER,
RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER,
PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM,
NUMER_PBRANCH, M1PBRANCH, DOTSCRULES, and LOGEXPAND
</PRE>

<P>
BINDTEST - causes ai to signal an error if it ever is used in a
computation unbound.  DECLARE([var1, var2, ...], BINDTEST) causes
MACSYMA to give an error message whenever any of the vari occur
unbound in a computation.
MACSYMA currently recognizes and uses the following features of
objects:

<PRE>
EVEN, ODD, INTEGER, RATIONAL, IRRATIONAL, REAL, IMAGINARY,
and COMPLEX
</PRE>

<P>
he useful features of functions include:

<PRE>
 INCREASING,
DECREASING, ODDFUN (odd function), EVENFUN (even function),
COMMUTATIVE (or SYMMETRIC), ANTISYMMETRIC, LASSOCIATIVE and
RASSOCIATIVE
</PRE>

<P>
DECLARE(F,INCREASING) is in all respects equivalent to

</P>

<PRE>
ASSUME(KIND(F,INCREASING))
</PRE>

<P>
The ai and fi may also be lists of
objects or features.  The command

<PRE>
FEATUREP(object,feature)
</PRE>

<P>
may be used
to determine if an object has been DECLAREd to have "feature".  See
DESCRIBE(FEATURES); .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DISOLATE</B> <I>(exp, var1, var2, ..., varN)</I>
<DD><A NAME="IDX91"></A>
is similar to ISOLATE(exp, var)
(Do DESCRIBE(ISOLATE);) except that it enables the user to isolate
more than one variable simultaneously.  This might be useful, for
example, if one were attempting to change variables in a multiple
integration, and that variable change involved two or more of the
integration variables.  This function is autoloaded from
<TT>`simplification/disol.mac'</TT>.  A demo is available by
<CODE>demo("disol")$</CODE>.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DISPFORM</B> <I>(exp)</I>
<DD><A NAME="IDX92"></A>
returns the external representation of exp (wrt its
main operator).  This should be useful in conjunction with PART which
also deals with the external representation.  Suppose EXP is -A .
Then the internal representation of EXP is "*"(-1,A), while the
external representation is "-"(A). DISPFORM(exp,ALL) converts the
entire expression (not just the top-level) to external format.  For
example, if EXP:SIN(SQRT(X)), then FREEOF(SQRT,EXP) and
FREEOF(SQRT,DISPFORM(EXP)) give TRUE, while
FREEOF(SQRT,DISPFORM(EXP,ALL)) gives FALSE.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DISTRIB</B> <I>(exp)</I>
<DD><A NAME="IDX93"></A>
distributes sums over products.  It differs from EXPAND
in that it works at only the top level of an expression, i.e. it doesn't
recurse and it is faster than EXPAND.  It differs from MULTTHRU in
that it expands all sums at that level. For example, 
DISTRIB((A+B)*(C+D)) -&#62; A C + A D + B C + B D 
MULTTHRU ((A+B)*(C+D)) -&#62; (A + B) C + (A + B) D
DISTRIB (1/((A+B)*(C+D))) -&#62;  1/ ((A+B) *(C+D))
EXPAND(1/((A+B)*(C+D)),1,0) -&#62; 1/(A C + A D + B C + B D)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DPART</B> <I>(exp, n1, ..., nk)</I>
<DD><A NAME="IDX94"></A>
selects the same subexpression as PART, but
instead of just returning that subexpression as its value, it returns
the whole expression with the selected subexpression displayed inside
a box.  The box is actually part of the expression.

<PRE>
(C1) DPART(X+Y/Z**2,1,2,1);
                       Y
(D1)                  ---- + X
                         2
                     *****
                     * Z *
                     *****

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EXP</B> <I>(X)</I>
<DD><A NAME="IDX95"></A>
the exponential function.  It is represented internally as
%E^X.
  DEMOIVRE[FALSE] - if TRUE will cause %E^(A+B*%I) to become
%E^A*(COS(B)+%I*SIN(B)) if B is free of %I.  A and B are not expanded.
  %EMODE[TRUE] - when TRUE %E^(%PI*%I*X) will be simplified as
follows: it will become COS(%PI*X)+%I*SIN(%PI*X) if X is an integer or
a multiple of 1/2, 1/3, 1/4, or 1/6 and thus will simplify further.
For other numerical X it will become %E^(%PI*%I*Y) where Y is X-2*k
for some integer k such that ABS(Y)&#60;1.  If %EMODE is FALSE no
simplification of %E^(%PI*%I*X) will take place.
  %ENUMER[FALSE] - when TRUE will cause %E to be converted into
2.718...  whenever NUMER is TRUE.  The default is that this conversion
will take place only if the exponent in %E^X evaluates to a number.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>EXPTISOLATE</B>
<DD><A NAME="IDX96"></A>
 default: [FALSE] if TRUE will cause ISOLATE(expr,var); to
examine exponents of atoms (like %E) which contain var.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>EXPTSUBST</B>
<DD><A NAME="IDX97"></A>
 default: [FALSE] if TRUE permits substitutions such as Y
for %E**X in %E**(A*X) to take place.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FREEOF</B> <I>(x1, x2, ..., exp)</I>
<DD><A NAME="IDX98"></A>
yields TRUE if the xi do not occur in exp
and FALSE otherwise.  The xi are atoms or they may be subscripted
names, functions (e.g.  SIN(X) ), or operators enclosed in "s.  If
'var' is a "dummy variable" of 'exp', then FREEOF(var,exp); will
return TRUE.  "Dummy variables" are mathematical things like the index
of a sum or product, the limit variable, and the definite integration
variable.  Example: FREEOF(I,'SUM(F(I),I,0,N)); returns TRUE.  Do
EXAMPLE(FREEOF); for more examples.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>GENFACT</B> <I>(X, Y, Z)</I>
<DD><A NAME="IDX99"></A>
is the generalized factorial of X which is:
X*(X-Z)*(X-2*Z)*...*(X-(Y-1)*Z).  Thus, for integral X,
GENFACT(X,X,1)=X!  and GENFACT(X,X/2,2)=X!!

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>IMAGPART</B> <I>(exp)</I>
<DD><A NAME="IDX100"></A>
returns the imaginary part of the expression exp.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>INDICES</B> <I>(exp)</I>
<DD><A NAME="IDX101"></A>
returns a list of two elements.  The first is a list of
the free indices in exp (those that occur only once); the second is
the list of dummy indices in exp (those that occur exactly twice).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>INFIX</B> <I>(op)</I>
<DD><A NAME="IDX102"></A>
 - INFIX operators are used to denote functions of two
arguments, one given before the operator and one after, e.g. A^2 .
The INFIX("x") function is a syntax extention function to declare x to
be an INFIX operator.  Do DESCRIBE(SYNTAX); for more details.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>INFLAG</B>
<DD><A NAME="IDX103"></A>
 default: [FALSE] if set to TRUE, the functions for part
extraction will look at the internal form of exp.  Note that the
simplifier re-orders expressions.  Thus FIRST(X+Y) will be X if INFLAG
is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same
results).  Also, setting INFLAG to TRUE and calling PART/SUBSTPART is
the same as calling INPART/SUBSTINPART.  Functions affected by the
setting of INFLAG are: PART, SUBSTPART, FIRST, REST, LAST, LENGTH, the
FOR ... IN construct, MAP, FULLMAP, MAPLIST, REVEAL and PICKAPART.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>INPART</B> <I>(exp, n1, ..., nk)</I>
<DD><A NAME="IDX104"></A>
is similar to PART but works on the internal
representation of the expression rather than the displayed form and
thus may be faster since no formatting is done.  Care should be taken
with respect to the order of subexpressions in sums and products
(since the order of variables in the internal form is often different
from that in the displayed form) and in dealing with unary minus,
subtraction, and division (since these operators are removed from the
expression). PART(X+Y,0) or INPART(X+Y,0) yield +, though in order to
refer to the operator it must be enclosed in "s.  For example
...IF INPART(D9,0)="+" THEN ...

<PRE>
(C1)  X+Y+W*Z;
(D1)                  W Z + Y + X
(C2)  INPART(D1,3,2);
(D2)                  Z
(C3)  PART(D1,1,2);
(D3)                  Z
(C4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
                                      G(X + 1)
(D4)                      LIMIT   F(X)
                          X -&#62;0-
(C5) INPART(%,1,2);
(D5)                            G(X + 1)

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ISOLATE</B> <I>(exp, var)</I>
<DD><A NAME="IDX105"></A>
returns exp with subexpressions which are sums and
which do not contain var replaced by intermediate expression labels
(these being atomic symbols like E1, E2, ...).  This is often useful
to avoid unnecessary expansion of subexpressions which don't contain
the variable of interest.  Since the intermediate labels are bound to
the subexpressions they can all be substituted back by evaluating the
expression in which they occur.
EXPTISOLATE[FALSE] if TRUE will cause ISOLATE to examine exponents of
atoms (like %E) which contain var.
ISOLATE_WRT_TIMES[FALSE] if TRUE, then ISOLATE will also isolate wrt
products.  E.g. compare both settings of the switch on
ISOLATE(EXPAND((A+B+C)^2),C); .
Do EXAMPLE(ISOLATE); for examples.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>ISOLATE_WRT_TIMES</B>
<DD><A NAME="IDX106"></A>
 default: [FALSE] - if set to TRUE, then ISOLATE
will also isolate wrt products.  E.g. compare both settings of the
switch on ISOLATE(EXPAND((A+B+C)^2),C); .

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>LISTCONSTVARS</B>
<DD><A NAME="IDX107"></A>
 default: [FALSE] - if TRUE will cause LISTOFVARS to
include %E, %PI, %I, and any variables declared constant in the list
it returns if they appear in the expression LISTOFVARS is called on.
The default is to omit these.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>LISTDUMMYVARS</B>
<DD><A NAME="IDX108"></A>
 default: [TRUE] - if FALSE, "dummy variables" in the
expression will not be included in the list returned by LISTOFVARS.
(The meaning of "dummy variables" is as given in DESCRIBE(FREEOF):
"Dummy variables" are mathematical things like the index of a sum or
product, the limit variable, and the definite integration variable.)
Example: LISTOFVARS('SUM(F(I),I,0,N)); gives [I,N] if LISTDUMMYVARS is
TRUE, and [N] if LISTDUMMYVARS is FALSE.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LISTOFVARS</B> <I>(exp)</I>
<DD><A NAME="IDX109"></A>
yields a list of the variables in exp.
LISTCONSTVARS[FALSE] if TRUE will cause LISTOFVARS to include %E, %PI,
%I, and any variables declared constant in the list it returns if they
appear in exp.  The default is to omit these.

<PRE>
(C1) LISTOFVARS(F(X[1]+Y)/G**(2+A));
(D1)                            [X[1], Y, A, G]

</PRE>

</DL>

<P>
<DL>
<DT><U>Function:</U> <B>LFREEOF</B> <I>(list, exp)</I>
<DD><A NAME="IDX110"></A>
For each member m of list, calls FREEOF(m,exp).
It returns false if any call to FREEOF does and true otherwise.
</DL>
<DL>
<DT><U>Function:</U> <B>LOPOW</B> <I>(exp, v)</I>
<DD><A NAME="IDX111"></A>
the lowest exponent of v which explicitly appears in
exp.  Thus

</P>

<PRE>
LOPOW((X+Y)**2+(X+Y)**A,X+Y) ==&#62; MIN(A,2)
</PRE>

<P>
.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LPART</B> <I>(label, expr, n1, ..., nk)</I>
<DD><A NAME="IDX112"></A>
is similar to DPART but uses a
labelled box. A labelled box is similar to the one produced by DPART
but it has a name in the top line.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MULTTHRU</B> <I>(exp)</I>
<DD><A NAME="IDX113"></A>
multiplies a factor (which should be a sum) of exp by
the other factors of exp.  That is exp is f1*f2*...*fn where at least
one factor, say fi, is a sum of terms.  Each term in that sum is
multiplied by the other factors in the product.  (Namely all the
factors except fi).  MULTTHRU does not expand exponentiated sums.
This function is the fastest way to distribute products (commutative
or noncommutative) over sums.  Since quotients are represented as
products MULTTHRU can be used to divide sums by products as well.
MULTTHRU(exp1, exp2) multiplies each term in exp2 (which should be a
sum or an equation) by exp1.  If exp1 is not itself a sum then this
form is equivalent to MULTTHRU(exp1*exp2).

<PRE>
(C1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;
               1        X         F(X)
(D1)       - ----- + -------- - --------
             X - Y          2          3
                     (X - Y)    (X - Y)
(C2) MULTTHRU((X-Y)**3,%);
                    2
(D2)       - (X - Y)  + X (X - Y) - F(X)
(C3) RATEXPAND(D2);
                           2
(D3)                    - Y  + X Y - F(X)
(C4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);
                         10  2              2  2
                (B  + A )   S  + 2 A B S + A  B
(D4)            --------------------------------
                                   2
                              A B S
(C5) MULTTHRU(%);
                                          10
                        2   A B   (B  + A)
(D5)                    - + -- + -------
                        S    2      A B
                            S
(notice that (B+A)**10 is not expanded)
(C6) MULTTHRU(A.(B+C.(D+E)+F));
(D6)                A . F + A . (C . (E + D)) + A . B
(compare with similar example under EXPAND)

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NOUNIFY</B> <I>(f)</I>
<DD><A NAME="IDX114"></A>
returns the noun form of the function name f.  This is
needed if one wishes to refer to the name of a verb function as if it
were a noun.  Note that some verb functions will return their noun
forms if they can't be evaluated for certain arguments.  This is also
the form returned if a function call is preceded by a quote.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NTERMS</B> <I>(exp)</I>
<DD><A NAME="IDX115"></A>
gives the number of terms that exp would have if it were
fully expanded out and no cancellations or combination of terms
occurred. Note that expressions like SIN(E), SQRT(E), EXP(E), etc.
count as just one term regardless of how many terms E has (if it is a
sum).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>OP</B> <I>(exp)</I>
<DD><A NAME="IDX116"></A>
Returns the operator of the expression, and functions the same way as
PART(exp,0).  It observes the setting of the INPART flag.  It may not
return the same value as the commercial Macsyma.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>OPERATORP</B> <I>(exp, ool)</I>
<DD><A NAME="IDX117"></A>
Uses OP to get the operator of the expression and either compares it to ool,
if it is a operator, or checks if it is a member of ool if it is a list.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>OPTIMIZE</B> <I>(exp)</I>
<DD><A NAME="IDX118"></A>
returns an expression that produces the same value and
side effects as exp but does so more efficiently by avoiding the
recomputation of common subexpressions.  OPTIMIZE also has the side
effect of "collapsing" its argument so that all common subexpressions
are shared.
Do EXAMPLE(OPTIMIZE); for examples.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>OPTIMPREFIX</B>
<DD><A NAME="IDX119"></A>
 default: [%] - The prefix used for generated symbols by
the OPTIMIZE command.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ORDERGREAT</B> <I>(V1, ..., Vn)</I>
<DD><A NAME="IDX120"></A>
sets up aliases for the variables V1, ..., Vn
such that V1 &#62; V2 &#62; ...  &#62; Vn &#62; any other variable not mentioned as an
argument.  See also ORDERLESS.  Caveat:  do EXAMPLE(ORDERGREAT); for
some specifics.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ORDERGREATP</B> <I>(exp1,exp2)</I>
<DD><A NAME="IDX121"></A>
returns TRUE if exp2 precedes exp1 in the
ordering set up with the ORDERGREAT function (see DESCRIBE(ORDERGREAT);).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ORDERLESS</B> <I>(V1, ..., Vn)</I>
<DD><A NAME="IDX122"></A>
sets up aliases for the variables V1, ..., Vn
such that V1 &#60; V2 &#60; ...  &#60; Vn &#60; any other variable not mentioned as an
argument.  Thus the complete ordering scale is: numerical constants &#60;
declared constants &#60; declared scalars &#60; first argument to ORDERLESS &#60;
...  &#60; last argument to ORDERLESS &#60; variables which begin with A &#60; ...
&#60; variables which begin with Z &#60; last argument to ORDERGREAT &#60;
 ... &#60; first argument to ORDERGREAT &#60; declared MAINVARs.  Caveat: do
EXAMPLE(ORDERLESS); for some specifics.  For another ordering scheme,
see DESCRIBE(MAINVAR);.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ORDERLESSP</B> <I>(exp1,exp2)</I>
<DD><A NAME="IDX123"></A>
returns TRUE if exp1 precedes exp2 in the
ordering set up by the ORDERLESS command (see DESCRIBE(ORDERLESS);).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PART</B> <I>(exp, n1, ..., nk)</I>
<DD><A NAME="IDX124"></A>
deals with the displayed form of exp. It
obtains the part of exp as specified by the indices n1,...,nk.  First
part n1 of exp is obtained, then part n2 of that, etc.  The result is
part nk of ... part n2 of part n1 of exp.  Thus PART(Z+2*Y,2,1) yields
2.  PART can be used to obtain an element of a list, a row of a
matrix, etc.
If the last argument to a Part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.
PIECE holds the last expression selected when using the Part
functions.  It is set during the execution of the function and thus
may be referred to in the function itself as shown below.
If PARTSWITCH[FALSE] is set to TRUE then END is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.
For examples, do EXAMPLE(PART);

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PARTITION</B> <I>(exp, var)</I>
<DD><A NAME="IDX125"></A>
returns a list of two expressions.  They are (1)
the factors of exp (if it is a product), the terms of exp (if it is a
sum), or the list (if it is a list) which don't contain var and, (2)
the factors, terms, or list which do.

<PRE>
(C1) PARTITION(2*A*X*F(X),X);
(D1)                 [ 2 A , X F(X) ]
(C2) PARTITION(A+B,X);
(D2)                 [ A + B , 0 ]
(C3) PARTITION([A,B,F(A),C],A); 
(D3)                [[B,C],[A,F(A)]]

</PRE>

</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>PARTSWITCH</B>
<DD><A NAME="IDX126"></A>
 default: [FALSE] - if set to TRUE then END is returned
when a selected part of an expression doesn't exist, otherwise an
error message is given.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PICKAPART</B> <I>(exp,depth)</I>
<DD><A NAME="IDX127"></A>
will assign E labels to all subexpressions of
exp down to the specified integer depth.  This is useful for dealing
with large expressions and for automatically assigning parts of an
expression to a variable without having to use the part functions.

<PRE>
(C1) EXP:(A+B)/2+SIN(X^2)/3-LOG(1+SQRT(X+1));
                                                 2
                                            SIN(X )   B + A
(D1)               - LOG(SQRT(X + 1) + 1) + ------- + -----
                                               3        2
(C2) PICKAPART(%,1);
(E2)                    - LOG(SQRT(X + 1) + 1)
                                    2
                               SIN(X )
(E3)                           -------
                                  3
                                B + A
(E4)                            -----
                                  2
(D4)                         E4 + E3 + E2

</PRE>

</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>PIECE</B>
<DD><A NAME="IDX128"></A>
 - holds the last expression selected when using the Part
functions.  It is set during the execution of the function and thus
may be referred to in the function itself.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>POWERS</B> <I>(expr, var)</I>
<DD><A NAME="IDX129"></A>
gives the powers of var occuring in expr.  To use
it, do LOAD(POWERS);.  For details on usage, do
PRINTFILE("powers.usg");.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PRODUCT</B> <I>(exp, ind, lo, hi)</I>
<DD><A NAME="IDX130"></A>
gives the product of the values of exp as
the index ind varies from lo to hi.  The evaluation is similar to that
of SUM.  No simplification of products is available at this time.
If hi is one less than lo, we have an "empty product" and PRODUCT 
returns 1 rather than erring out.  Also see DESCRIBE(PRODHACK).

<PRE>
(C1)  PRODUCT(X+I*(I+1)/2,I,1,4);
(D1)             (X + 1) (X + 3) (X + 6) (X + 10)

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>REALPART</B> <I>(exp)</I>
<DD><A NAME="IDX131"></A>
gives the real part of exp. REALPART and IMAGPART will
work on expressions involving trigonometic and hyperbolic functions,
as well as SQRT, LOG, and exponentiation.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>RECTFORM</B> <I>(exp)</I>
<DD><A NAME="IDX132"></A>
returns an expression of the form A + B*%I, where A and
B are purely real.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>REMBOX</B> <I>(expr, arg)</I>
<DD><A NAME="IDX133"></A>
removes boxes from expr according to arg.  If arg
is UNLABELED then all unlabelled boxes are removed.  If arg is the
name of some label then only boxes with that label are removed.  If
arg is omitted then all boxes labelled and unlabelled are removed.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUM</B> <I>(exp, ind, lo, hi)</I>
<DD><A NAME="IDX134"></A>
performs a summation of the values of exp as
the index ind varies from lo to hi.  If the upper and lower limits
differ by an integer then each term in the sum is evaluated and added
together.  Otherwise, if the SIMPSUM [FALSE] is TRUE the result is
simplified.  This simplification may sometimes be able to produce a
closed form.  If SIMPSUM is FALSE or if 'SUM is used, the value is a
sum noun form which is a representation of the sigma notation used in
mathematics.
If hi is one less than lo, we have an "empty sum" and SUM returns 0 
rather than erring out.
Sums may be differentiated, added, subtracted, or multiplied with some
automatic simplification being performed.
Also see DESCRIBE(SUMHACK).
CAUCHYSUM[FALSE] when TRUE causes the Cauchy product to be used when
multiplying sums together rather than the usual product.  In the
Cauchy product the index of the inner summation is a function of the
index of the outer one rather than varying independently.
GENINDEX[I] is the alphabetic prefix used to generate the next
variable of summation.
GENSUMNUM[0] is the numeric suffix used to generate the next variable
of summation.  If it is set to FALSE then the index will consist only
of GENINDEX with no numeric suffix.
Do EXAMPLE(SUM); for examples.  See also SUMCONTRACT, INTOSUM,
BASHINDICES, and NICEINDICES.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LSUM</B> <I>(exp, ind, list)</I>
<DD><A NAME="IDX135"></A>
performs the sum of EXP for each element IND of the LIST.

<PRE>
(C10) lsum(x^i,i,[1,2,7]);

                            7    2
(D10)                      x  + x  + x
</PRE>

<P>
If the last element LIST argument does not evaluate, or does not
evaluate to a Maxima list then the answer is left in noun form

<PRE>
(C13) lsum(i^2,i,rootsof(x^3-1));

                     ====
                     \      2
(D13)                 &#62;    i
                     /
                     ====
                                   3
                     i in ROOTSOF(x  - 1)
</PRE>

</DL>

<P>
<DL>
<DT><U>special symbol:</U> <B>VERB</B>
<DD><A NAME="IDX136"></A>
 - the opposite of "noun", i.e. a function form which "does
something" ("action" - for most functions the usual case).  E.g.
INTEGRATE integrates a function, unless it is DECLAREd to be a "noun",
in which case it represents the INTEGRAL of the function.  See NOUN,
NOUNIFY, and VERBIFY.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>VERBIFY</B> <I>(f)</I>
<DD><A NAME="IDX137"></A>
returns the function name f in its verb form (See also VERB,
NOUN, and NOUNIFY).

</P>
</DL>

<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_4.html">previous</A>, <A HREF="maxima_6.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
