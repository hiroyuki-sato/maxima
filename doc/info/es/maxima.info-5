This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Depuración del código fuente,  Next: Claves de depuración,  Up: Depurado

41.1 Depuración del código fuente
=================================

Maxima es capaz de dar asistencia en la depuración del código fuente.
Un usuario puede establecer un punto de referencia dentro del código de
una función a partir del cual se siga la ejecución línea a línea. La
compliación puede ser posteriormente examinada, conjuntamente con los
valores que se han ido asignando a las variables.

   La instrucción `:help', o `:h', muestra la lista de comandos para la
depuración. (En general, los comandos pueden abreviarse; en algunos
casos la lista de alternativas podrá ser listada.) Dentro del
depurador, el usuario podrá examinar también cualquier función propia
de Maxima, definirla y manipular variables y expresiones.

   El punto de referencia se establecerá con la instrucción `:br'. Ya
dentro del depurador, el usuario podrá avanzar una línea de cada vez
utilizando la instrucción `:n' (de "next", en inglés). La orden `:bt'
(de "backtrace") muestra la lista de la pila. Finalmente, con el
comando `:r' ("resume") se abandona el depurador continuando con la
ejecución. El uso de estas instrucciones se muestra en el siguiente
ejemplo.

     (%i1) load ("/tmp/foobar.mac");

     (%o1)                           /tmp/foobar.mac

     (%i2) :br foo
     Turning on debugging debugmode(true)
     Bkpt 0 for foo (in /tmp/foobar.mac line 1)

     (%i2) bar (2,3);
     Bkpt 0:(foobar.mac 1)
     /tmp/foobar.mac:1::

     (dbm:1) :bt                  <-- pulsando :bt se retrocede
     #0: foo(y=5)(foobar.mac line 1)
     #1: bar(x=2,y=3)(foobar.mac line 9)

     (dbm:1) :n                   <-- pulsando :n se avanza una línea
     (foobar.mac 2)
     /tmp/foobar.mac:2::

     (dbm:1) :n                   <-- pulsando :n se avanza otra línea
     (foobar.mac 3)
     /tmp/foobar.mac:3::

     (dbm:1) u;                   <-- se pide el valor de u
     28

     (dbm:1) u: 33;               <-- se cambia el valor de u a 33
     33

     (dbm:1) :r                   <-- pulsando :r se termina la depuración

     (%o2)                                1094

   El fichero `/tmp/foobar.mac' contiene lo siguiente:

     foo(y) := block ([u:y^2],
       u: u+3,
       u: u^2,
       u);

     bar(x,y) := (
       x: x+2,
       y: y+2,
       x: foo(y),
       x+y);

   USO DEL DEPURADOR EN EMACS

   Si el usuario está corriendo el código bajo GNU emacs en un entorno
de texto (dbl shell), o está ejecutando el  entorno gráfico `xmaxima',
entonces cuando una función pare en el punto de referencia, podrá
observar su posición actual en el archivo fuente, el cual será mostrado
en la otra mitad de la ventana, bien resaltada en rojo, o con una
pequeña flecha apuntando a la línea correcta. El usuario puede avanzar
líneas simples tecleando M-n (Alt-n).

   Bajo Emacs se debe ejecutar el programa en una ventana de texto
`dbl', la cual requiere el archivo `dbl.el' que está en el directorio
elisp. El usuario debe instalar los archivos elisp o agregar el
directorio elisp de Maxima a la ruta de búsqueda: por ejemplo, se puede
añadir lo siguiente al archivo `.emacs' o al `site-init.el'

     (setq load-path (cons "/usr/share/maxima/5.9.1/emacs" load-path))
     (autoload 'dbl "dbl")

   entonces en emacs

     M-x dbl

   debería abrir una ventana del sistema en la cual se pueden ejecutar
programas, por ejemplo Maxima, gcl, gdb, etc.  En esta ventana también
se puede ejecutar el depurador, mostrando el código fuente en la otra
ventana.

   El usuario puede colocar un punto de referencia en una línea
determinada sin más que teclear `C-x space'. Con esto se le hace saber
al depurador en qué función está el cursor y en qué línea del mismo. Si
el cursor está en la línea 2 de `foo', entonces insertará en la otra
ventana la instrucción "`:br foo 2'", a fin de detener `foo' justo en
la segunda línea. Para tener esto operativo, el usuario debe tener
activo maxima-mode.el (modo-maxima.el) en la ventana en la que está
`foobar.mac'. Hay otros comandos disponibles en la ventana, como
evaluar la función dentro de Maxima tecleando `Alt-Control-x'.


File: maxima.info,  Node: Claves de depuración,  Next: Definiciones para Depurado,  Prev: Depuración del código fuente,  Up: Depurado

41.2 Claves de depuración
=========================

Las claves de depuración son palabras que no son interpretadas como
expresiones de Maxima. Una clave de depuración puede introducirse
dentro de Maxima o del depurador. Las claves de depuración comienzan
con dos puntos, ':'. Por ejemplo, para evaluar una expresión Lisp, se
puede teclear `:lisp' seguido de la expresión a ser evaluada.

     (%i1) :lisp (+ 2 3)
     5

   El número de argumentos depende del comando en particular. Además,
tampoco es necesario teclear el nombre completo de la instrucción, tan
solo lo justo para diferenciarla de las otras instrucciones. Así, `:br'
sería suficiente para `:break'.

   Las claves de depuración se listan a continuación.

`:break F n'
     Establece un punto de referencia en la función `F' en la línea `n'
     contando a partir del comienzo de la función. Si `F' es una
     cadena, entonces se entiende que se trata de un fichero, siendo
     entonces `n' el número de línea a partir del comienzo del fichero.
     El valor `n' es opcional; en caso de no ser suministrado, se
     entenderá que vale cero (primera línea de la función o fichero).

`:bt'
     Retrocede en la pila.

`:continue'
     Continua el cómputo de la función.

`:delete'
     Borra los punto de referencia especificados, o todos si no se
     especifica ninguno.

`:disable'
     Deshabilita los puntos de referencia especificados, o todos si no
     se especifica ninguno.

`:enable'
     Habilita los puntos de referencia especificados, o todos si no se
     especifica ninguno.

`:frame n'
     Imprime el elemento `n' de la pila, o el actualmente activo si no
     se especifica ninguno.

`:help'
     Imprime la ayuda sobre un comando del depurador, o de todos los
     comandos si no se especifica ninguno.

`:info'
     Imprime información sobre un elemento.

`:lisp expresión'
     Evalúa la `expresión' Lisp.

`:lisp-quiet expresión'
     Evalúa la `expresión' Lisp sin devolver el resultado.

`:next'
     Como `:step', excepto que `:next' se salta las llamadas a
     funciones.

`:quit'
     Sale del nivel actual del depurador sin completar el cómputo.

`:resume'
     Continúa con el cómputo.

`:step'
     Sigue con el cómputo de la función o fichero hasta que alcance una
     nueva línea fuente.

`:top'
     Retorna a Maxima desde cualquier nivel del depurador sin completar
     el cómputo.


File: maxima.info,  Node: Definiciones para Depurado,  Prev: Claves de depuración,  Up: Depurado

41.3 Definiciones para Depurado
===============================

 -- Variable opcional: refcheck
     Valor por defecto: `false'

     Cuando `refcheck' vale `true', Maxima imprime un mensaje cada vez
     que una variable es utilizada por vez primera en un cálculo.


 -- Variable opcional: setcheck
     Valor por defecto: `false'

     Cuando el valor de `setcheck' es una lista de variables (se admite
     que tengan subíndices) Maxima devuelve un mensaje indicando si los
     valores que han sido asignados a las variables lo han sido con el
     operador ordinario `:', o con el operador de asignación `::' o
     como resultado de haberse realizado una llamada de función, pero
     en ningún caso cuando la asignación haya sido hecha mediante los
     operadores `:=' o `::='. El mensaje contiene el nombre de la
     variable y su valor.

     La variable `setcheck' admite también los valores `all' o `true'
     con lo que el informe incluirá todas las variables.

     Cada nueva asignación de `setcheck' establece una nueva lista de
     variables a ser monitorizada, de forma que cualquier otra variable
     previamente asignada a `setcheck' es olvidada.

     Los nombres asignados a `setcheck' deben estar precedidos del
     apóstrofo `'' a fin de evitar que las variables sean evaluadas
     antes de ser almacenadas en `setcheck'. Por ejemplo, si `x', `y' y
     `z' ya guardan algún valor entoces se hará

          setcheck: ['x, 'y, 'z]$

     para colocarlas en la lista de variables a monitorizar.

     No se generará ninguna salida cuando una variable de la lista
     `setcheck' sea asignada a ella misma, como en `X: 'X'.


 -- Variable opcional: setcheckbreak
     Valor por defecto: `false'

     Si `setcheckbreak' es igual `true', Maxima se detendrá siempre que
     a una variable de la lista `setcheck' se le asigne un nuevo valor.
     La detención tendrá lugar justo antes de hacerse la asignación. En
     ese momento `setval' guarda el valor que se le va a dar a la
     variable. Entonces el usuario podrá darle un valor diferente
     pasándoselo a la variable `setval'.

     Véanse también `setcheck' y `setval'.


 -- Variable del sistema: setval
     Guarda el valor que va a ser asignado a una variable cuando
     `setcheckbreak' realiza una detención. Entonces se podrá asignarle
     otro valor pasándoselo previamente a `setval'.

     Véanse también `setcheck' y `setcheckbreak'.


 -- Función: timer (<f_1>, ..., <f_n>)
 -- Función: timer (all)
 -- Función: timer ()
     Dadas las funciones <f_1>, ..., <f_n>, `timer' coloca cada una de
     ellas en la lista de funciones para las cuales se generarán
     estadísticas relativas al tiempo de cómputo. Así, `timer(f)$
     timer(g)$' coloca a `f' y luego a `g' en dicha lista de forma
     acumulativa.

     La sentencia `timer(all)' coloca todas las funciones de usuario
     (las referenciadas por la variable global `functions') en la lista
     de funciones cuyos tiempos de ejecución se quieren monitorizar.

     Si no se le pasan argumentos a `timer' se obtendrá la lista de
     funciones cuyos tiempos de ejecución se quieren monitorizar.

     Maxima almacena la duración del cómputo de cada función de la
     lista, de forma que `timer_info' devolverá las estadísticas
     correspondientes, incluyendo el tiempo medio de cada llamada a la
     función, el número de llamadas realizadas y el tiempo total
     transcurrido. La instrucción `untimer' borra las funciones de la
     lista.

     La función `timer' no evalúa sus argumentos, de forma que `f(x) :=
     x^2$ g:f$ timer(g)$' no coloca a `f' en la lista.

     Si `trace(f)' está activada, entonces `timer(f)' está desactivada;
     `trace' y `timer' no pueden estar operativas al mismo tiempo.

     Véase también `timer_devalue'.


 -- Función: untimer (<f_1>, ..., <f_n>)
 -- Función: untimer ()
     Dadas las funciones <f_1>, ..., <f_n>, `untimer' las elimina de la
     lista de funciones cuyos tiempos de ejecución se quiere
     monitorizar.

     Si no se le suministran argumentos, `untimer' borra completamente
     la lista.

     Tras la ejecución de `untimer (f)', `timer_info (f)' aún devuelve
     las estadísticas de tiempo previamente registradas, pero
     `timer_info()' (sin argumentos) no devuelve información sobre
     aquellas funciones que ya no están en la lista. La ejecución de
     `timer (f)' inicializa todas las estadísticas a cero y coloca `f'
     nuevamente en la lista.


 -- Variable opcional: timer_devalue
     Valor por defecto: `false'

     Si `timer_devalue' es igual a `true', Maxima le resta a cada
     función cuyos tiempos de ejecución se quiere monitorizar el tiempo
     gastado en llamadas a otras funciones presentes también en la
     lista de monitorización. En caso contrario, los tiempos que se
     obtienen para cada función incluyen también los consumidos en
     otras funciones. Nótese que el tiempo consumido en llamadas a
     otras funciones que no están en la lista de monitorización no se
     resta del tiempo total.

     Véanse también `timer' y `timer_info'.


 -- Función: timer_info (<f_1>, ..., <f_n>)
 -- Función: timer_info ()
     Dadas las funciones <f_1>, ..., <f_n>, `timer_info' devuelve una
     matriz con información relativa a los tiempos de ejecución de cada
     una de estas funciones. Sin argumentos, `timer_info' devuelve la
     información asociada a todas las funciones cuyos tiempos de
     ejecución se quiere monitorizar.

     La matriz devuelta por `timer_info' incluye los nombres de las
     funciones, tiempo de ejecución en cada llamada, número de veces
     que ha sido llamada, tiempo total de ejecución y tiempo consumido
     en la recolección de basura, `gctime' (del inglés, "garbage
     collection time") en la versión original de Macsyma, aunque ahora
     toma el valor constante cero.

     Los datos con los que `timer_info' construye su respuesta pueden
     obtenerse también con la función `get':

          get(f, 'calls);  get(f, 'runtime);  get(f, 'gctime);

     Véase también `timer'.


 -- Función: trace (<f_1>, ..., <f_n>)
 -- Función: trace (all)
 -- Función: trace ()
     Dadas las funciones <f_1>, ..., <f_n>, `trace' imprime información
     sobre depuración cada vez que estas funciones son llamadas;
     `trace(f)$ trace(g)$' coloca de forma acumulativa a `f' y luego a
     `g' en la lista de funciones a ser rastradas.

     La sentencia `trace(all)' coloca todas las funciones de usuario
     (las referenciadas por la variable global `functions') en la lista
     de funciones a ser rastreadas.

     Si no se suministran argumentos, `trace' devuelve una lista con
     todas las funciones a ser rastreadas.

     La función `untrace' desactiva el rastreo. Véase también
     `trace_options'.

     La función `trace' no evalúa sus argumentos, de forma que `f(x) :=
     x^2$ g:f$ trace(g)$' no coloca a `f' en la lista de rastreo.

     Cuando una función se redefine es eliminada de la lista de
     rastreo. Así, tras  `timer(f)$ f(x) := x^2$', la función `f'
     dejará de estar en dicha lista.

     Si `timer (f)' está activado, entonces `trace (f)' está
     desactivado, ya que `trace' y `timer' no pueden estar ambos
     activos para la misma función.


 -- Función: trace_options (<f>, <option_1>, ..., <option_n>)
 -- Función: trace_options (<f>)
     Establece las opciones de rastreo para la función <f>. Cualquier
     otra opción previamente especificada queda reemplazada por las
     nuevas. La ejecución de `trace_options (<f>, ...)' no tiene ningún
     efecto, a menos que se haya invocado previamente a `trace (<f>)'
     (es indiferente que esta invocación sea anterior o posterior a
     `trace_options').

     `trace_options (<f>)' inicializa todas las opciones a sus valores
     por defecto.

     Las claves de opciones son:

        * `noprint': No se imprime mensaje alguno ni a la entrada ni a
          la salida de la función.

        * `break': Coloca un punto de referencia antes de que la
          función comience a ejecutarse y otro después de que termine
          su ejecución. Véase `break'.

        * `lisp_print': Muestra los argumentos y valores retornados
          como objetos de Lisp.

        * `info': Imprime `-> true' tanto a la entrada como a la salida
          de la función.

        * `errorcatch': Detecta errores, otorgando la posibilidad de
          marcar un error, reintentar la llamada a la función o
          especificar un valor de retorno.

     Las opciones de rastreo se especifican de dos formas. La única
     presencia de la clave de opción ya activa la opción. (Nótese que
     la opción <foo> no se activa mediante `<foo>: true' u otra forma
     similar; se tendrá en cuenta también que las claves no necesitan
     ir precedidas del apóstrofo.) Especificando la clave de opción
     junto con una función de predicado se hace que la opción quede
     condicionada al predicado.

     La lista de argumentos para las funciones de predicado es siempre
     `[level, direction, function, item]' donde `level' es el nivel de
     recursión para la función,  `direction' puede ser tanto `enter'
     como `exit', `function' es el nombre de la función  y `item' es la
     lista de argumentos (a la entrada) o el valor de retorno (a la
     salida).

     A continuación un ejemplo de opciones de rastreo no condicionales:

          (%i1) ff(n) := if equal(n, 0) then 1 else n * ff(n - 1)$

          (%i2) trace (ff)$

          (%i3) trace_options (ff, lisp_print, break)$

          (%i4) ff(3);

     Para la misma función, con la opción `break' condicionada a un
     predicado:

          (%i5) trace_options (ff, break(pp))$

          (%i6) pp (level, direction, function, item) := block (print (item),
              return (function = 'ff and level = 3 and direction = exit))$

          (%i7) ff(6);


 -- Función: untrace (<f_1>, ..., <f_n>)
 -- Función: untrace ()
     Dadas las funciones <f_1>, ..., <f_n>, `untrace' desactiva el
     rastreo previamente activado por la función `trace'. Si no se
     aportan argumentos, `untrace' desactiva el rastreo de todas las
     funciones.

     La llamada a `untrace' devuelve una lista con las funciones para
     las que el rastreo se ha desactivado.



File: maxima.info,  Node: augmented_lagrangian,  Next: bode,  Prev: Depurado,  Up: Top

42 augmented_lagrangian
***********************

* Menu:

* Definiciones para augmented_lagrangian::


File: maxima.info,  Node: Definiciones para augmented_lagrangian,  Prev: augmented_lagrangian,  Up: augmented_lagrangian

42.1 Definiciones para augmented_lagrangian
===========================================

 -- Variable opcional: niter
     Valor por defecto:  10

     Número de iteraciones para `augmented_lagrangian_method'.

 -- Función: augmented_lagrangian_method (<FOM>, <xx>, <constraints>,
          <yy>)
     Método de Lagrange aumentado para optimización con restricciones.
     <FOM> es la función objetivo, <xx> es la lista de variables sobre
     las que minimizar, <constraints> es una lista de expresiones
     iguales a cero y <yy> es una lista de valores iniciales para <xx>.

     Este código minimiza el lagrangiano aumentado calculando un punto
     estacionario de su gradiente; la técnica puede ser mejorada con un
     algoritmo de gradiente conjugado o un método de minimización de
     Newton.

     Para referencias véanse
          http://www-fp.mcs.anl.gov/otc/Guide/OptWeb/continuous/constrained/nonlinearcon/auglag.html
     y
          http://www.cs.ubc.ca/spider/ascher/542/chap10.pdf

     El paquete `mnewton' debe cargarse antes de llamar a la función
     `augmented_lagrangian_method', a fin de que pueda resolver grad L
     = 0.

     Ejemplo:
          (%i1) load (mnewton)$

          (%i2) load("augmented_lagrangian")$

          (%i3) FOM: x^2 + 2*y^2;
                                     2    2
          (%o3)                   2 y  + x
          (%i4) xx: [x, y];
          (%o4)                     [x, y]
          (%i5) C: [x + y - 1];
          (%o5)                  [y + x - 1]
          (%i6) yy: [1, 1];
          (%o6)                     [1, 1]
          (%i7) augmented_lagrangian_method (FOM, xx, C, yy);
          (%o7)          [0.6478349834, 0.3239174917]

     Antes de hacer uso de esta función ejecútense  `load("mnewton")' y
     `load("augmented_lagrangian")'.  Véase también `niter'.


File: maxima.info,  Node: bode,  Next: descriptive,  Prev: augmented_lagrangian,  Up: Top

43 bode
*******

* Menu:

* Definiciones para bode::


File: maxima.info,  Node: Definiciones para bode,  Prev: bode,  Up: bode

43.1 Definiciones para bode
===========================

 -- Función: bode_gain (<H>, <range>, ...<plot_opts>...)
     Función para dibujar el gráfico de ganancia de Bode.

     Ejemplos (1 a 7 de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_gain (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_gain (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_gain (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_gain (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_gain (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_gain (H6 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_gain (H7 (s), [w, 1/1000, 1000]),
                            omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_gain (H8 (s), [w, 1/1000, 1000])$

     Antes de hacer uso de esta función ejecútese  `load("bode")'.
     Véase también `bode_phase'.

 -- Función: bode_phase (<H>, <range>, ...<plot_opts>...)
     Función para dibujar el gráfico de fase de Bode.

     Ejemplos (1 a 7 de
          http://www.swarthmore.edu/NatSci/echeeve1/Ref/Bode/BodeHow.html,
     8 de Ron Crummett):
          (%i1) load("bode")$

          (%i2) H1 (s) := 100 * (1 + s) / ((s + 10) * (s + 100))$

          (%i3) bode_phase (H1 (s), [w, 1/1000, 1000])$

          (%i4) H2 (s) := 1 / (1 + s/omega0)$

          (%i5) bode_phase (H2 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i6) H3 (s) := 1 / (1 + s/omega0)^2$

          (%i7) bode_phase (H3 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i8) H4 (s) := 1 + s/omega0$

          (%i9) bode_phase (H4 (s), [w, 1/1000, 1000]), omega0 = 10$

          (%i10) H5 (s) := 1/s$

          (%i11) bode_phase (H5 (s), [w, 1/1000, 1000])$

          (%i12) H6 (s) := 1/((s/omega0)^2 + 2 * zeta * (s/omega0) + 1)$

          (%i13) bode_phase (H6 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i14) H7 (s) := (s/omega0)^2 + 2 * zeta * (s/omega0) + 1$

          (%i15) bode_phase (H7 (s), [w, 1/1000, 1000]),
                             omega0 = 10, zeta = 1/10$

          (%i16) H8 (s) := 0.5 / (0.0001 * s^3 + 0.002 * s^2 + 0.01 * s)$

          (%i17) bode_phase (H8 (s), [w, 1/1000, 1000])$

          (%i18) block ([bode_phase_unwrap : false],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

          (%i19) block ([bode_phase_unwrap : true],
                        bode_phase (H8 (s), [w, 1/1000, 1000]));

     Antes de hacer uso de esta función ejecútese  `load("bode")'.
     Véase también `bode_gain'.


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: bode,  Up: Top

44 descriptive
**************

* Menu:

* Introducción a descriptive::
* Definiciones para el tratamiento de datos::
* Definiciones de valores descriptivos::
* Definiciones de valores descriptivos multivariantes::
* Definiciones para gráficos estadísticos::


File: maxima.info,  Node: Introducción a descriptive,  Next: Definiciones para el tratamiento de datos,  Prev: descriptive,  Up: descriptive

44.1 Introducción a descriptive
===============================

El paquete `descriptive' contiene funciones para realizar cl'culos y
gráficos estadísticos descriptivos. Junto con el código fuente se
distribuyen tres conjuntos de datos: `pidigits.data', `wind.data' y
`biomed.data', los cuales también se pueden descargar desde el sitio
web `www.biomates.net'.

   Cualquier manual de estadística se puede utilizar como referencia al
paquete `descriptive'.

   Para comentarios, fallos y sugerencias, por favor contactar con
<'mario AT edu DOT xunta DOT es'>.

   Aquí un sencillo ejemplo sobre cómo operan las funciones de
`descriptive', dependiendo de la naturaleza de sus argumentos, listas o
matrices,

     (%i1) load (descriptive)$
     (%i2) /* muestra univariate */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* muestra multivariante */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

   Nótese que en las muestras multivariantes la media se calcula para
cada columna.

   En caso de varias muestras de diferente tamaño, la función `map' de
Maxima puede utilizarse para obtener los resultados deseados para cada
muestra,

     (%i1) load (descriptive)$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

   En este caso, dos muestras de tamaños 3 y 2 han sido almacenadas en
una lista.

   Muestras univariantes deben guardarse en listas como en

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

   y muestras multivariantes en matrices como las del siguiente ejemplo

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

   En este caso, el número de columnas es igual al de la dimensión de
la variable aleatoria y el número de filas coincide con el tamaño
muestral.

   Los datos pueden suministrarse manualmente, pero las muestras
grandes se suelen almacenar en ficheros de texto. Por ejemplo, el
fichero `pidigits.data' contiene los 100 primeros dígitos del número
`%pi':
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

   A fin de leer estos dígitos desde Maxima,

     (%i1) load (numericalio)$
     (%i2) s1 : read_list (file_search ("pidigits.data"))$
     (%i3) length (s1);
     (%o3)                          100

   Por otro lado, el archivo `wind.data' contiene los promedios diarios
de la velocidad del viento en cinco estaciones meteorológicas en
Irlanda (esta muestra es parte de un conjunto de datos correspondientes
a 12 estaciones meteorológicas. El fichero original se puede descargar
libremente del 'StatLib Data Repository' y se analiza en  Haslett, J.,
Raftery, A. E. (1989) <Space-time Modelling with Long-memory
Dependence: Assessing Ireland's Wind Power Resource, with Discussion>.
Applied Statistics 38, 1-50). Así se leen los datos:

     (%i1) load (numericalio)$
     (%i2) s2 : read_matrix (file_search ("wind.data"))$
     (%i3) length (s2);
     (%o3)                          100
     (%i4) s2 [%]; /* ultimo registro */
     (%o4)            [3.58, 6.0, 4.58, 7.62, 11.25]

   Algunas muestras contienen datos no numéricos. Como ejemplo, el
archivo `biomed.data' (el cual es parte de otro mayor descargado
también del 'StatLib Data Repository') contiene cuatro mediciones
sanguíneas tomadas a dos grupos de pacientes, `A' y `B', de diferentes
edades,

     (%i1) load (numericalio)$
     (%i2) s3 : read_matrix (file_search ("biomed.data"))$
     (%i3) length (s3);
     (%o3)                          100
     (%i4) s3 [1]; /* primer registro */
     (%o4)            [A, 30, 167.0, 89.0, 25.6, 364]

   El primer individuo pertenece al grupo `A', tiene 30 años de edad y
sus medidas sanguíneas fueron 167.0, 89.0, 25.6 y 364.

   Debe tenerse cuidado cuando se trabaje con datos categóricos. En el
siguiente ejemplo, se asigna al símbolo `a' cierto valor en algún
momento previo y luego se toma una muestra con el valor categórico `a',

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Definiciones para el tratamiento de datos,  Next: Definiciones de valores descriptivos,  Prev: Introducción a descriptive,  Up: descriptive

44.2 Definiciones para el tratamiento de datos
==============================================

 -- Función: continuous_freq (<list>)
 -- Función: continuous_freq (<list>, <m>)
     El argumento de `continuous_freq' debe ser una lista de números,
     los cuales serán luego agrupados en intervalos y hecho el recuento
     de cuántos hay en cada grupo. Opcionalmente, la función
     `continuous_freq' admite un segundo argumento para indicar el
     número de clases a considerar, siendo 10 su valor por defecto.

          (%i1) load (numericalio)$
          (%i2) load (descriptive)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) continuous_freq (s1, 5);
          (%o4) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     La primera lista contiene los extremos de los intervalos y la
     segunda los resultados de los recuentos: hay 16 dígitos dentro del
     intervalo  `[0, 1.8]', esto es ceros y unos, 24 dígitos en `(1.8,
     3.6]', es decir doses y treses, y así sucesivamente.

 -- Función: discrete_freq (<list>)
     Calcula las frecuencias absolutas en muestras discretas, tanto
     numéricas como categóricas. Su único argumento debe ser una lista.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) discrete_freq (s1);
          (%o4) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     La primera lista son los valores de la muestra y la segunda sus
     frecuencias absolutas. Las instrucciones `? col' y `? transpose'
     pueden ayudar a comprender la última entrada.

 -- Función: subsample (<data_matrix>, <logical_expression>)
 -- Función: subsample (<data_matrix>, <logical_expression>, <col_num>,
          <col_num>, ...)
     Esta es una variante de la función `submatrix' de Maxima. El
     primer argumento es una matriz de datos, el segundo es una
     expresión lógica no evaluada y el resto de argumentos opcionales
     son los números de las columnas a tomar en consideración,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o4)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     Estos son los registros multivariantes en los que la velocidad del
     viento en la primera estación meteorológica fue menor que 18.
     Véase cómo en la expresión lógica no evaluada a la <i>-ésima
     componente se la referencia como `%c[i]'. El símbolo `%c[i]' es
     utilizado dentro de la función `subsample', por lo que si se
     utiliza también como variable categórica, Maxima puede dar
     resultados imprevistos. En el siguiente ejemplo, se solicitan
     únicamente la primera, segunda y quinta componentes de aquellos
     registros con velocidades del viento mayores o iguales que 16
     nudos en la estación número 1 y menores que 25 nudos en la
     estación número 4,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) subsample (s2, '(%c[1] >= 16 and %c[4] < 25), 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     He aquí un ejemplo con las variables categóricas de `biomed.data'.
     Se piden los registros correspondientes a aquellos pacientes del
     grupo `B' mayores de 38 anños,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38));
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Es probable que el análisis estadístico requiera únicamente de las
     medidas sanguíneas,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) subsample (s3, '(%c[1] = B and %c[2] > 38), 3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o4)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Esta es la media multivariante de `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o4) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100

     Aquí la primera componente carece de significado, ya que tanto `A'
     como `B' son categóricas, la segunda componente es la edad media
     de los individuos en forma racional, al tiempo que los valores
     cuarto y quinto muestran cierto comportamiento extraño; lo cual se
     debe a que el símbolo `NA' se utiliza para indicar datos no
     disponibles, por lo que ambas medias no tienen sentido. Una
     posible solución puede ser extraer de la matriz aquellas filas con
     símbolos `NA', lo que acarrearía cierta pérdida de información,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) mean (subsample (s3, '(%c[4] # NA and %c[6] # NA), 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13


File: maxima.info,  Node: Definiciones de valores descriptivos,  Next: Definiciones de valores descriptivos multivariantes,  Prev: Definiciones para el tratamiento de datos,  Up: descriptive

44.3 Definiciones de valores descriptivos
=========================================

 -- Función: mean (<list>)
 -- Función: mean (<matrix>)
     Es la media muestral, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean (s1);
                                         471
          (%o4)                          ---
                                         100
          (%i5) %, numer;
          (%o5)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) mean (s2);
          (%o7)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]


 -- Función: var (<list>)
 -- Función: var (<matrix>)
     Es la varianza muestral, definida como
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var (s1), numer;
          (%o4)                   8.425899999999999

     Véase también `var1'.

 -- Función: var1 (<list>)
 -- Función: var1 (<matrix>)
     Es la cuasivarianza muestral, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) var1 (s1), numer;
          (%o4)                    8.5110101010101
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) var1 (s2);
          (%o6) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     Véase también `var'.

 -- Función: std (<list>)
 -- Función: std (<matrix>)
     Es la desviación típica muestral, raíz cuadrada de `var'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std (s1), numer;
          (%o4)                   2.902740084816414
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std (s2);
          (%o6) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Véanse también `var' y `std1'.

 -- Función: std1 (<list>)
 -- Función: std1 (<matrix>)
     Es la cuasidesviación típica muestral, raíz cuadrada de `var1'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) std1 (s1), numer;
          (%o4)                   2.917363553109228
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) std1 (s2);
          (%o6) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Véanse también `var1' y `std'.

 -- Función: noncentral_moment (<list>, <k>)
 -- Función: noncentral_moment (<matrix>, <k>)
     Es el momento no central de orden k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) noncentral_moment (s1, 1), numer; /* la media */
          (%o4)                         4.71
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) noncentral_moment (s2, 5);
          (%o7) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]

     Véase también `central_moment'.

 -- Función: central_moment (<list>, <k>)
 -- Función: central_moment (<matrix>, <k>)
     Es el momento central de orden k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) central_moment (s1, 2), numer; /* la varianza */
          (%o4)                   8.425899999999999
          (%i6) s2 : read_matrix (file_search ("wind.data"))$
          (%i7) central_moment (s2, 3);
          (%o7) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]

     Véanse también `central_moment' y `mean'.

 -- Función: cv (<list>)
 -- Función: cv (<matrix>)
     Es el coeficiente de variación, o cociente entre la desviación
     típica muestral (`std') y la media (`mean'),

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) cv (s1), numer;
          (%o4)                   .6193977819764815
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) cv (s2);
          (%o6) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Véanse también `std' y `mean'.

 -- Función: mini (<list>)
 -- Función: mini (<matrix>)
     Es el valor mínimo de la muestra <list>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mini (s1);
          (%o4)                           0
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mini (s2);
          (%o6)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Véase también `maxi'.

 -- Función: maxi (<list>)
 -- Función: maxi (<matrix>)
     Es el valor máximo de la muestra <list>,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) maxi (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) maxi (s2);
          (%o6)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Véase también `mini'.

 -- Función: range (<list>)
 -- Función: range (<matrix>)
     Es la diferencia entre los valores extremos.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) range (s1);
          (%o4)                           9
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) range (s2);
          (%o6)          [19.67, 20.96, 17.37, 24.38, 22.46]


 -- Función: quantile (<list>, <p>)
 -- Función: quantile (<matrix>, <p>)
     Es el <p>-cuantil, siendo <p> un número del intervalo [0, 1], de
     la muestra <list>.  Aunque existen varias definiciones para el
     cuantil muestral (Hyndman, R. J., Fan, Y. (1996) <Sample quantiles
     in statistical packages>. American Statistician, 50, 361-365), la
     programada en el paquete  `descriptive' es la basada en la
     interpolación lineal.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) /* 1er and 3er cuartiles */ [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o4)                      [2.0, 7.25]
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quantile (s2, 1/4);
          (%o6)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]


 -- Función: median (<list>)
 -- Función: median (<matrix>)
     Una vez ordenada una muestra, si el tamaño muestral es impar la
     mediana es el valor central, en caso contrario será la media de
     los dos valores centrales.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median (s1);
                                          9
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median (s2);
          (%o6)         [10.06, 9.855, 10.73, 15.48, 14.105]

     La mediana es el cuantil 1/2.

     Véase también `quantile'.

 -- Función: qrange (<list>)
 -- Función: qrange (<matrix>)
     El rango intercuartílico es la diferencia entre el tercer y primer
     cuartil, `quantile(<list>,3/4) - quantile(<list>,1/4)',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) qrange (s1);
                                         21
          (%o4)                          --
                                         4
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) qrange (s2);
          (%o6) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Véase también `quantile'.

 -- Función: mean_deviation (<list>)
 -- Función: mean_deviation (<matrix>)
     Es la desviación media, definida como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) mean_deviation (s1);
                                         51
          (%o4)                          --
                                         20
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean_deviation (s2);
          (%o6) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Véase también `mean'.

 -- Función: median_deviation (<list>)
 -- Función: median_deviation (<matrix>)
     Es la desviación mediana, definida como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1
     siendo `med' la mediana de <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) median_deviation (s1);
                                          5
          (%o4)                           -
                                          2
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) median_deviation (s2);
          (%o6)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Véase también `mean'.

 -- Función: harmonic_mean (<list>)
 -- Función: harmonic_mean (<matrix>)
     Es la media armónica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) harmonic_mean (y), numer;
          (%o4)                   3.901858027632205
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) harmonic_mean (s2);
          (%o6) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Véanse también `mean' y `geometric_mean'.

 -- Función: geometric_mean (<list>)
 -- Función: geometric_mean (<matrix>)
     Es la media geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i4) geometric_mean (y), numer;
          (%o4)                   4.454845412337012
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) geometric_mean (s2);
          (%o6) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Véanse también `mean' y `harmonic_mean'.

 -- Función: kurtosis (<list>)
 -- Función: kurtosis (<matrix>)
     Es el coeficiente de curtosis, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) kurtosis (s1), numer;
          (%o4)                  - 1.273247946514421
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) kurtosis (s2);
          (%o6) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Véanse también `mean', `var' y `skewness'.

 -- Función: skewness (<list>)
 -- Función: skewness (<matrix>)
     Es el coeficiente de asimetría, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) skewness (s1), numer;
          (%o4)                  .009196180476450306
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) skewness (s2);
          (%o6) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Véanse también `mean', `var' y `kurtosis'.

 -- Función: pearson_skewness (<list>)
 -- Función: pearson_skewness (<matrix>)
     Es el coeficiente de asimetría de Pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s
     siendo <med> la mediana de <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) pearson_skewness (s1), numer;
          (%o4)                   .2159484029093895
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) pearson_skewness (s2);
          (%o6) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Véanse también `mean', `var' y `median'.

 -- Función: quartile_skewness (<list>)
 -- Función: quartile_skewness (<matrix>)
     Es el coeficiente de asimetría cuartílico, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4
     siendo c_p el <p>-cuantil de la muestra <list>.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) quartile_skewness (s1), numer;
          (%o4)                  .04761904761904762
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) quartile_skewness (s2);
          (%o6) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Véase también `quantile'.


File: maxima.info,  Node: Definiciones de valores descriptivos multivariantes,  Next: Definiciones para gráficos estadísticos,  Prev: Definiciones de valores descriptivos,  Up: descriptive

44.4 Definiciones de valores descriptivos multivariantes
========================================================

 -- Función: cov (<matrix>)
     Es la matriz de covarianzas de una muestra multivariante, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1
     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$  /* cambia precision */
          (%i5) cov (s2);
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o5) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]

     Véase también `cov1'.

 -- Función: cov1 (<matrix>)
     Es la matriz de cuasivarianzas de una muestra multivariante,
     definida como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1
     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) fpprintprec : 7$ /* cambia precision */
          (%i5) cov1 (s2);
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o5) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]

     Véase también `cov'.

 -- Función: global_variances (<matrix>)
 -- Función: global_variances (<matrix>, <logical_value>)
     La función `global_variances' devuelve una lista de medidas
     globales de variabilidad:

        * <varianza total>: `trace(S_1)',

        * <varianza media>: `trace(S_1)/p',

        * <varianza generalizada>: `determinant(S_1)',

        * <desviación típica generalizada>: `sqrt(determinant(S_1))',

        * <varianza efectiva> `determinant(S_1)^(1/p)', (definida en:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)

        * <desviación típica efectiva>: `determinant(S_1)^(1/(2*p))'.
     donde <p> es la dimensión de la variable aleatoria multivariante y
     S_1 la matriz de covarianzas devuelta por la función `cov1'.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) global_variances (s2);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     La función `global_variances' tiene un argumento lógico opcional:
     `global_variances(x,true)' indica a Maxima que `x' es la matriz de
     datos, calculando entonces lo mismo que `global_variances(x)'. Por
     otro lado, `global_variances(x,false)' significa que  `x' no es la
     matriz de datos, sino la de covarianzas, evitando así recalcularla,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) global_variances (s, false);
          (%o5) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Véanse también `cov' y `cov1'.

 -- Función: cor (<matrix>)
 -- Función: cor (<matrix>, <logical_value>)
     Es la matriz de correlaciones de la muestra multivariante.

     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec: 7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     La función `cor' tiene un argumento lógico opcional: `cor(x,true)'
     indica a Maxima que `x' es la matriz de datos, calculando entonces
     lo mismo que `cor(x)'. Por otro lado, `cor(x,false)' significa que
     `x' no es la matriz de datos, sino la de covarianzas, evitando
     así recalcularla,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) fpprintprec: 7$
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) s : cov1 (s2)$
          (%i6) cor (s, false); /* mas rapido */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o6) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Véanse también `cov' y `cov1'.

 -- Función: list_correlations (<matrix>)
 -- Función: list_correlations (<matrix>, <logical_value>)
     La función `list_correlations' devuelve una lista con medidas de
     correlación:

        * <matriz de precisión>: es la inversa de la matriz de
          covarianzas S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        * <vector de correlación múltiple>:  (R_1^2, R_2^2, ...,
          R_p^2), donde
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          es un indicador de la bondad de ajuste del modelo de
          regresión lineal multivariante de X_i cuando el resto de
          variables se utilizan como regresores.

        * <matriz de correlaciones parciales>: en la que el elemento
          (i, j) es
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /


     Ejemplo:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) z : list_correlations (s2)$
          (%i5) fpprintprec : 5$ /* cambia precision */
          (%i6) z[1];  /* matriz de precision */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o6) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%i7) z[2];  /* vector de correlacion multiple */
          (%o7)       [.85063, .80634, .86474, .71867, .72675]
          (%i8) z[3];  /* matriz de correlaciones parciales */
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o8)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     La función `list_correlations' tiene un argumento lógico opcional:
     `list_correlations(x,true)' indica a Maxima que `x' es la matriz
     de datos, calculando entonces lo mismo que `list_correlations(x)'.
     Por otro lado, `list_correlations(x,false)' significa que  `x' no
     es la matriz de datos, sino la de covarianzas, evitando así
     recalcularla.

     Véanse también `cov' y `cov1'.


File: maxima.info,  Node: Definiciones para gráficos estadísticos,  Prev: Definiciones de valores descriptivos multivariantes,  Up: descriptive

44.5 Definiciones para gráficos estadísticos
============================================

 -- Función: dataplot (<list>)
 -- Función: dataplot (<list>, <option_1>, <option_2>, ...)
 -- Función: dataplot (<matrix>)
 -- Función: dataplot (<matrix>, <option_1>, <option_2>, ...)
     La función `dataplot' permite la visualización directa de datos
     muestrales, tanto univariantes (<list>) como multivariantes
     (<matrix>). Asignando valores a las siguientes opciones
     (<options>) se pueden controlar ciertos aspectos del gráfico:

        * `'outputdev', `"x"' por defecto, indica el dispositivo de
          salida; valores aceptados son `"x"', `"eps"' y `"png"', para
          la pantalla, y los formatos de ficheros postscript y png,
          respectivamente.

        * `'maintitle', `""' por defecto, es el título principal entre
          comillas dobles.

        * `'axisnames', `["x","y","z"]' por defecto, es una lista con
          nombres para los ejes `x', `y' y `z'.

        * `'joined', `false' por defecto, un valor lógico que indica si
          los puntos en 2D deben unirse por segmentos o no.

        * `'picturescales', `[1.0, 1.0]' por defecto, factores de
          escala para el tamaño del gráfico.

        * `'threedim', `true' por defecto, indica a Maxima si debe
          dibujar una matriz de tres columnas como un diagrama
          tridimensional o como un diagrama de dispersión
          multivariante. Véanse ejemplos más abajo.

        * `'axisrot', `[60, 30]' por defecto, cambia el punto de vista
          cuando `'threedim' toma el valor `true' y los datos se
          suministran en una matriz de tres columnas. El primer número
          es el ángulo de rotación del eje <x>, siendo el segundo el
          ángulo de rotación del eje <z>, ambos medidos en grados
          sexagesimales.

        * `'nclasses', `10' por defecto, es el número de clases a
          considerar en los histogramas de la diagonal de los diagramas
          de dispersión multivariantes.

        * `'pointstyle', `1' por defecto, es un entero que indica cómo
          dibujar los puntos muestrales.


     Por ejemplo, con el siguiente código se realiza un gráfico con los
     veinte primeros dígitos del número `%pi' y el resultado se guarda
     en un fichero en formato eps.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 20), 'pointstyle = 3)$

     Nótese que las muestras univariantes se representan como series
     temporales. En el siguiente ejemplo se utilizan más datos y con
     diferentes opciones,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) dataplot (makelist (s1[k], k, 1, 50), 'maintitle = "First pi digits",
           'axisnames = ["digit order", "digit value"], 'pointstyle = 2,
           'joined = true)$

     La función `dataplot' puede utilizarse para representar puntos del
     plano. El siguiente ejemplo es un diagrama de dispersión de los
     pares formados con las velocidades del viento correspondientes a
     las estaciones meteorológicas uno y cinco,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (submatrix (s2, 2, 3, 4), 'pointstyle = 2,
           'maintitle = "Pairs of wind speeds measured in knots",
           'axisnames = ["Wind speed in A", "Wind speed in E"])$

     Si los puntos están almacenados en una matriz de dos columnas,
     `dataplot' los puede dibujar directamente, pero si están guardados
     como una lista de pares deben transformarse previamente a una
     matriz, tal como se hace en el siguiente ejemplo.

          (%i1) load (descriptive)$
          (%i2) x : [[-1, 2], [5, 7], [5, -3], [-6, -9], [-4, 6]]$
          (%i3) dataplot (apply ('matrix, x), 'maintitle = "Points",
           'joined = true, 'axisnames = ["", ""], 'picturescales = [0.5, 1.0])$

     Puntos del espacio tridimensional pueden verse como proyecciones
     sobre un plano. Es este ejemplo se piden gráficos de las
     velocidades del viento correspondientes a tres estaciones
     meteorológicas, primero una representación tridimensional y luego
     como diagrama de dispersión multivariante.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) /* grafico 3D */ dataplot (submatrix (s2, 4, 5), 'pointstyle = 2,
           'maintitle = "Pairs of wind speeds measured in knots",
           'axisnames = ["Station A", "Station B", "Station C"])$
          (%i5) /* Dispersion multivariante */ dataplot (submatrix (s2, 4, 5),
           'nclasses = 6, 'threedim = false)$

     Nótese que en este último ejemplo, el número de clases de los
     histogramas de la diagonal se ajusta a 6, y que a la opción
     `'threedim' se le da el valor `false'.

     Para más de tres dimensiones sólo son posibles los diagramas de
     dispersión multivariantes, como en

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) dataplot (s2)$


 -- Función: histogram (<list>)
 -- Función: histogram (<list>, <option_1>, <option_2>, ...)
 -- Función: histogram (<one_column_matrix>)
 -- Función: histogram (<one_column_matrix>, <option_1>, <option_2>,
          ...)
     Dibuja un histograma. Los datos muestrales deben suministrarse
     como una lista de números o como una matriz columna. Asignando
     valores a las siguientes opciones (<options>) se pueden controlar
     ciertos aspectos del gráfico:

        * `'outputdev', `"x"' por defecto, indica el dispositivo de
          salida; valores aceptados son `"x"', `"eps"' y `"png"', para
          la pantalla, y los formatos de ficheros postscript y png,
          respectivamente.

        * `'maintitle', `""' por defecto, es el título principal entre
          comillas dobles.

        * `'axisnames', `["x", "Fr."]' por defecto, es una lista con
          nombres para los ejes `x' e `y'.

        * `'picturescales', `[1.0, 1.0]' por defecto, factores de
          escala para el tamaño del gráfico.

        * `'nclasses', `10' por defecto, es el número de intervalos de
          clase.

        * `'relbarwidth', `0.9' por defecto, es un número decimal entre
          0 y 1 para controlar el ancho de las barras.

        * `'barcolor', `1' por defecto, es un entero que indica el
          color de las barras.

        * `'colorintensity', `1' por defecto, es un número decimal
          entre 0 y 1 para establecer la intensidad del color.


     En los siguientes dos ejemplos se solicitan sendos histogramas
     para los 100 primeros dígitos del número pi y para las velocidades
     del viento en la estación meteorológica número 3.

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s1 : read_list (file_search ("pidigits.data"))$
          (%i4) histogram (s1, 'maintitle = "pi digits", 'axisnames = ["", "Absolute frequency"],
           'relbarwidth = 0.2, 'barcolor = 3, 'colorintensity = 0.6)$
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) histogram (col (s2, 3), 'colorintensity = 0.3)$

     Nótese que en el primer caso, `s1' es una lista y que en el
     segundo `col(s2,3)' es una matriz.

     Véase también `barsplot'.

 -- Función: barsplot (<list>)
 -- Función: barsplot (<list>, <option_1>, <option_2>, ...)
 -- Función: barsplot (<one_column_matrix>)
 -- Función: barsplot (<one_column_matrix>, <option_1>, <option_2>, ...)
     Similar a `histogram' pero para muestras discretas, numéricas o
     categóricas. Estas son las variables,

        * `'outputdev', `"x"' por defecto, indica el dispositivo de
          salida; valores aceptados son `"x"', `"eps"' y `"png"', para
          la pantalla, y los formatos de ficheros postscript y png,
          respectivamente.

        * `'maintitle', `""' por defecto, es el título principal entre
          comillas dobles.

        * `'axisnames', `["x", "Fr."]' por defecto, es una lista con
          nombres para los ejes `x' e `y'.

        * `'picturescales', `[1.0, 1.0]' por defecto, factores de
          escala para el tamaño del gráfico.

        * `'relbarwidth', `0.9' por defecto, es un número decimal entre
          0 y 1 para controlar el ancho de las barras.

        * `'barcolor', `1' por defecto, es un entero que indica el
          color de las barras.

        * `'colorintensity', `1' por defecto, es un número decimal
          entre 0 y 1 para establecer la intensidad del color.


     En este ejemplo se representa el gráfico de barras correspondiente
     a los grupos `A' y `B' de los pacientes de la muestra `s3',

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 1), 'maintitle = "Groups of patients",
           'axisnames = ["Group", "# of individuals"], 'colorintensity = 0.2)$

     La primera columna de la muestra `s3' almacena los valores
     categóricos `A' y `B', llamados también factores. Por otro lado,
     los números enteros positivos en la segunda columna son las edades
     en años, que es una variable discreta, por lo que podemos
     representar las frecuencias absolutas de estos valores,

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s3 : read_matrix (file_search ("biomed.data"))$
          (%i4) barsplot (col (s3, 2), 'maintitle = "Ages",
           'axisnames = ["Years", "# of individuals"], 'colorintensity = 0.2,
           'relbarwidth = 0.6)$

     Véase también `histogram'.

 -- Función: boxplot (<data>)
 -- Función: boxplot (<data>, <option_1>, <option_2>, ...)
     Dibuja diagramas de cajas. El argumento <data> puede ser una
     lista, lo cual no es de gram interés puesto que estos gráficos se
     utilizan fundamentalmente para comparar varias muestras, o una
     matriz, de manera que es posible comparar dos o más componentes de
     una variable estadística multivariante. También se permite que
     <data> sea una lista de muestras con tamaños muestrales
     diferentes; de hecho esta es la única función del paquete
     `descriptive' que admite este tipo de estructura. Véase ejemplo
     más abajo. Estas son las opciones válidas:

        * `'outputdev', `"x"' por defecto, indica el dispositivo de
          salida; valores aceptados son `"x"', `"eps"' y `"png"', para
          la pantalla, y los formatos de ficheros postscript y png,
          respectivamente.

        * `'maintitle', `""' por defecto, es el título principal entre
          comillas dobles.

        * `'axisnames', `["sample", "y"]' por defecto, es una lista con
          nombres para los ejes `x' e `y'.

        * `'picturescales', `[1.0, 1.0]' por defecto, factores de
          escala para el tamaño del gráfico.


     Ejemplos:

          (%i1) load (descriptive)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) boxplot (s2, 'maintitle = "Windspeed in knots",
           'axisnames = ["Seasons", ""])$
          (%i5) A :
           [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
            [8, 10, 7, 9, 12, 8, 10],
            [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i6) boxplot (A)$



File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Definiciones para diag::


File: maxima.info,  Node: Definiciones para diag,  Prev: diag,  Up: diag

45.1 Definiciones para diag
===========================

 -- Función: diag (<lm>)
     Genera una matriz cuadrada con las matrices de <lm> en la
     diagonal, siendo <lm> una lista de matrices o de escalares.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: JF (<lambda>,<n>)
     Devuelve la célula de Jordan de orden  <n> con valor propio
     <lambda>.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.

 -- Función: jordan (<mat>)
     Devuelve la forma de Jordan de la matriz <mat>, pero en formato de
     lista de Maxima. Para obtener la matriz correspondiente, llámese a
     la función `dispJordan' utilizando como argumento la salida de
     `JF'.

     Ejemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `dispJordan' y `minimalPoly'.

 -- Función: dispJordan (<l>)
     Devuelve la matriz de Jordan asociada a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `minimalPoly'.

 -- Función: minimalPoly (<l>)
     Devuelve el polinomio mínimo asociado a la codificación dada por
     la lista <l>, que habitualmente será la salida de la función
     `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: ModeMatrix (<A>,<l>)
     Devuelve la matriz <M> tal que (M^^-1).A.M=J, donde <J> es la
     forma de Jordan de <A>. La lista <l> es la forma codificada de la
     forma de Jordan tal como la devuelve la función `jordan'.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Nótese que `dispJordan(%o3)' es la forma de Jordan de la matriz
     `a'.

     Antes de hacer uso de esta función ejecútese  `load("diag")'.
     Véanse también `jordan' y `dispJordan'.

 -- Función: mat_function (<f>,<mat>)
     Devuelve  f(mat), siendo <f> una función analítica y <mat> una
     matriz. Este cálculo se basa en la fórmula integral de Cauchy, que
     establece que si `f(x)' es analítica y
          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     entonces

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])*ModeMatrix^^(-1)

     Nótese que hay otros métodos alternativos para realizar este
     cálculo.

     Se presentan algunos ejemplos.

     Ejemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Ejemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Ejemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Antes de hacer uso de esta función ejecútese  `load("diag")'.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introducción a distrib::
* Definiciones para distribuciones continuas::
* Definiciones para distribuciones discretas::


File: maxima.info,  Node: Introducción a distrib,  Next: Definiciones para distribuciones continuas,  Prev: distrib,  Up: distrib

46.1 Introducción a distrib
===========================

El paquete `distrib' contiene un conjunto de funciones para la
realización de cálculos probabilísticos con modelos univariantes, tanto
discretos como continuos.

   A continuación un breve recordatorio de las deficiones básicas sobre
distribuciones de probabilidad.

   Sea f(x) la <función de densidad> de una variable aleatoria X
absolutamente continua. La <función de distribución> se define como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
   que es igual a la probabilidad <Pr(X <= x)>.

   La <media> es un parámetro de localización y se define como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

   La  <varianza> es una medida de dispersión,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
   que es un número real positivo. La raíz cuadrada de la varianza es
la <desviación típica>, D[X]=sqrt(V[X]), siendo otra medida de
dispersión.

   El <coeficiente de asimetría> es una medida de forma,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

   Y el <coeficiente de curtosis> mide el apuntamiento de la densidad,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
   Si X es normal, KU[X]=0. De hecho, tanto la asimetría como la
curtosis son parámetros de forma para medir la no normalidad de una
distribución.

   Si la variable aleatoria X es discreta, su función de densidad, o de
<probabiliad>,  f(x) toma valores positivos dentro de un conjunto
numerable de valores x_i, y cero en cualquier otro lugar. En este caso,
la función de distribución es
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

   La media, varianza, desviación típica y los coeficientes de
asimetría y curtosis adquieren las formas
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
   y
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
   respectivamente.

   El paquete `distrib' incluye funciones para la simulación de
variables aleatorias. Algunas de estas funciones hacen uso de variables
opcionales que indican el algoritmo a ejecutar. El método general de
inversión (basado en el hecho de que si <u> es un número aleatorio
generado uniformemente en (0,1), entonces <F^(-1)(u)> es una variable
aleatoria con distribución F) está implementado en la mayoría de los
casos, aunque se trate de una técnica subóptima en términos de tiempo,
pero útil para compararla con otros algoritmos. En el siguiente ejemplo
se compara mediante histogramas el comportamiento de los algoritmos
`ahrens_cheng' y `inverse' para la simulación de variables chi-cuadrada:

     (%i1) load(distrib)$
     (%i2) load(descriptive)$
     (%i3) showtime: true$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     (%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
     Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
     (%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
     Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
     Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.

   A fin de hacer comparaciones visuales entre algoritmos para
variables discretas, se debería utilizar la función `barsplot' del
paquete `descriptive'.

   Nótese que aún queda trabajo por hacer, puesto que estas funciones
de simulación todavía no se han puesto a prueba con tests de bondad de
ajuste más rigurosos.

   Por favor, consúltese cualquier manual introductorio de probabilidad
y estadística para más información sobre toda esta parafernalia
matemática.

   Se sigue cierta convención a la hora de nombrar las funciones del
paquete `distrib'. Cada nombre tiene dos partes, el primero hace
referencia a la función o parámetro que se quiere calcular,
     Funciones:
        Función de densidad        (pdf_*)
        Función de distribución    (cdf_*)
        Cuantil                    (quantile_*)
        Media                      (mean_*)
        Varianza                   (var_*)
        Desviación típica          (std_*)
        Coeficiente de asimetría   (skewness_*)
        Coeficiente de curtosis    (kurtosis_*)
        Valor aleatorio            (random_*)

   La segunda parte hace referencia explícita al modelo probabilístico,
     Distribuciones continuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continua uniforme   (*continuous_uniform)
        Logística           (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuciones discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica           (*geometric)
        Uniforme discreta    (*discrete_uniform)
        Hipergeométrica      (*hypergeometric)
        Binomial negativa    (*negative_binomial)

   Por ejemplo, `pdf_student_t(x,n)' es la función de densidad de la
distribución de Student con <n> grados de libertad, `std_pareto(a,b)'
es la desviación típica de la distribución de Pareto de parámetros <a>
y <b>, y `kurtosis_poisson(m)' es el coeficiente de curtosis de la
distribución de Poisson de media <m>.

   Para poder hacer uso del paquete `distrib' es necesario cargarlo
primero tecleando
     (%i1) load(distrib)$

   Para comentarios, errores o sugerencias, por favor contáctese
conmigo en <'mario ARROBA edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Definiciones para distribuciones continuas,  Next: Definiciones para distribuciones discretas,  Prev: Introducción a distrib,  Up: distrib

46.2 Definiciones para distribuciones continuas
===============================================

 -- Función: pdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de la variable aleatoria Normal(m,s), con s>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de la variable aleatoria Normal(m,s), con s>0. Esta
     función se define en términos de la función de error,  `erf', de
     Maxima.

          (%i1) load (distrib)$
          (%i2) assume(s>0)$ cdf_normal(x,m,s);
                                       x - m
                                 erf(---------)
                                     sqrt(2) s    1
          (%o3)                  -------------- + -
                                       2          2

     Véase también `erf'.

 -- Función: quantile_normal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Normal(m,s), con
     s>0; en otras palabras, es la inversa de  `cdf_normal'. El
     argumento <q> debe ser un número de [0,1]. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: mean_normal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Normal(m,s), con s>0,
     es decir <m>. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_normal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Normal(m,s), con
     s>0, es decir <s^2>.

 -- Función: std_normal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Normal(m,s), con s>0, es decir <s>. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_normal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_normal (<m>,<s>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Variable opcional: random_normal_algorithm
     Valor por defecto: `box_mueller'

     Este es el algoritmo seleccionado para simular variables
     aleatorias normales. Los algoritmos implementados son
     `box_mueller' y `inverse':
        * `box_mueller', basado en el algoritmo descrito en Knuth, D.E.
          (1981) <Seminumerical Algorithms. The Art of Computer
          Programming.> Addison-Wesley.

        * `inverse', basado en el método inverso.

     Véase también `random_normal'.

 -- Función: random_normal (<m>,<s>)
 -- Función: random_normal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Normal(m,s), con s>0. Llamando a
     `random_normal' con un tercer argumento <n>, se simula una muestra
     aleatoria de tamaño <n>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_normal_algorithm', cuyo valor por defecto
     es `box_mueller'.

     Véanse también `random_normal_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Student t(n), con n>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_student_t_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Student t(n), con n>0.
     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.

          (%i1) load (distrib)$
          (%i2) cdf_student_t(1/2, 7/3);
                                               1  7
          (%o2)                  cdf_student_t(-, -)
                                               2  3
          (%i3) %,numer;
          (%o3)                   .6698450596140417

 -- Función: quantile_student_t (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria de Student t(n),
     con n>0; en otras palabras, se trata de la inversa de
     `cdf_student_t'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_student_t (<n>)
     Devuelve la media de una variable aleatoria de Student t(n), con
     n>0, que vale siempre 0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_student_t (<n>)
     Devuelve la varianza de una variable aleatoria de Student t(n),
     con n>2.

          (%i1) load (distrib)$
          (%i2) assume(n>2)$  var_student_t(n);
                                          n
          (%o3)                         -----
                                        n - 2

 -- Función: std_student_t (<n>)
     Devuelve la desviación típica de una variable aleatoria de Student
     t(n), con n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_student_t (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Student t(n), con n>3, que vale siempre 0. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_student_t (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Student t(n), con n>4. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Variable opcional: random_student_t_algorithm
     Valor por defecto: `ratio'

     Es el algoritmo seleccionado para simular variables aleatorias de
     Student. Los métodos implementados son `inverse' y `ratio':
        * `inverse', basado en el método inverso.

        * `ratio', basado en el hecho de que si <Z> es una variable
          aleatoria normal N(0,1) y S^2 es una variable aleatoria chi
          cuadrada con <n> grados de libertad, Chi^2(n), entonces
                                          Z
                                X = -------------
                                    /   2  \ 1/2
                                    |  S   |
                                    | ---  |
                                    \  n   /
          es una variable aleatoria de Student con <n> grados de
          libertad, t(n).

     Véase también `random_student_t'.

 -- Función: random_student_t (<n>)
 -- Función: random_student_t (<n>,<m>)
     Devuelve un valor aleatorio t(n), con n>0. Llamando a
     `random_student_t' con un segundo argumento <m>, se obtiene una
     muestra aleatoria simulada de tamaño <m>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_student_t_algorithm', cuyo valor por
     defecto es `ratio'.

     Véase también `random_student_t_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la función de
     densidad de la gamma.

          (%i1) load (distrib)$
          (%i2) pdf_chi2(x,n);
                                              n
          (%o2)                  pdf_gamma(x, -, 2)
                                              2
          (%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o4)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Función: cdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado Chi^2(n), con
     n>0.

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal basada en la distribución
     gamma, puesto que la variable aleatoria Chi^2(n) equivale a una
     Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) cdf_chi2(3,4);
          (%o2)                  cdf_gamma(3, 2, 2)
          (%i3) cdf_chi2(3,4),numer;
          (%o3)                   .4421745996289249

 -- Función: quantile_chi2 (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Chi^2(n), con
     n>0; en otras palabras, se trata de la inversa de  `cdf_chi2'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal basada en la función cuantil
     de la gamma, puesto que la variable aleatoria Chi^2(n) equivale a
     una Gamma(n/2,2).

          (%i1) load (distrib)$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194
          (%i3) quantile_chi2(0.99,n);
                                                  n
          (%o3)              quantile_gamma(0.99, -, 2)
                                                  2

 -- Función: mean_chi2 (<n>)
     Devuelve la media de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la media de la
     gamma.

          (%i1) load (distrib)$
          (%i2) mean_chi2(n);
                                             n
          (%o2)                   mean_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ mean_chi2(n);
          (%o4)                           n

 -- Función: var_chi2 (<n>)
     Devuelve la varianza de  una variable aleatoria  Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la varianza de la
     gamma.

          (%i1) load (distrib)$
          (%i2) var_chi2(n);
                                             n
          (%o2)                    var_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ var_chi2(n);
          (%o4)                          2 n

 -- Función: std_chi2 (<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en la desviación
     típica de la gamma.

          (%i1) load (distrib)$
          (%i2) std_chi2(n);
                                             n
          (%o2)                    std_gamma(-, 2)
                                             2
          (%i3) assume(n>0)$ std_chi2(n);
          (%o4)                    sqrt(2) sqrt(n)

 -- Función: skewness_chi2 (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     asimetría de la gamma.

          (%i1) load (distrib)$
          (%i2) skewness_chi2(n);
                                               n
          (%o2)                 skewness_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ skewness_chi2(n);
                                      2 sqrt(2)
          (%o4)                       ---------
                                       sqrt(n)

 -- Función: kurtosis_chi2 (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2), por lo
     que cuando Maxima no tiene suficiente información para obtener el
     resultado, devuelve una forma nominal basada en el coeficiente de
     curtosis de la gamma.

          (%i1) load (distrib)$
          (%i2) kurtosis_chi2(n);
                                               n
          (%o2)                 kurtosis_gamma(-, 2)
                                               2
          (%i3) assume(n>0)$ kurtosis_chi2(n);
                                         12
          (%o4)                          --
                                         n

 -- Variable opcional: random_chi2_algorithm
     Valor por defecto: `ahrens_cheng'

     Es el algoritmo seleccionado para simular variables aleatorias
     chi-cuadrado. Los métodos implementados son `ahrens_cheng' y
     `inverse':

        * `ahrens_cheng', basado en la simulación aleatoria de
          variables gamma. Véase `random_gamma_algorithm' para más
          detalles.

        * `inverse', basado en el método inverso.


     Véase también `random_chi2'.

 -- Función: random_chi2 (<n>)
 -- Función: random_chi2 (<n>,<m>)
     Devuelve un valor aleatorio  Chi^2(n), con n>0. Llamando a
     `random_chi2' con un segundo argumento <m>, se simulará una
     muestra aleatoria de tamaño <m>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_chi2_algorithm', cuyo valor por defecto es
     `ahrens_cheng'.

     Véase también `random_chi2_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  F(m,n), con m,n>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  F(m,n), con m,n>0.

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) cdf_f(2,3,9/4);
                                               9
          (%o2)                    cdf_f(2, 3, -)
                                               4
          (%i3) %,numer;
          (%o3)                   0.66756728179008

 -- Función: quantile_f (<q>,<m>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria  F(m,n), con
     m,n>0; en otras palabras, se trata de la inversa de  `cdf_f'. El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Función: mean_f (<m>,<n>)
     Devuelve la media de  una variable aleatoria  F(m,n), con m>0,
     n>2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_f (<m>,<n>)
     Devuelve la varianza de  una variable aleatoria  F(m,n), con m>0,
     n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_f (<m>,<n>)
     Devuelve la desviación típica de  una variable aleatoria  F(m,n),
     con m>0, n>4. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_f (<m>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     F(m,n), con m>0, n>6. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_f (<m>,<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     F(m,n), con m>0, n>8. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Variable opcional: random_f_algorithm
     Valor por defecto: `inverse'

     Es el algoritmo seleccionado para simular variables aleatorias F.
     Los algoritmos programados son `ratio' y `inverse':
        * `ratio', basado en el hecho de que si <X> es una variable
          aleatoria Chi^2(m) y Y es una Chi^2(n), entonces
                                       n X
                                   F = ---
                                       m Y
          es una variable aleatoria F con <m> y <n> grados de libertad,
          F(m,n).

        * `inverse', basado en el método inverso.


     Véase también `random_f'.

 -- Función: random_f (<m>,<n>)
 -- Función: random_f (<m>,<n>,<k>)
     Devuelve un valor aleatorio  F(m,n), con m,n>0. Llamando a
     `random_f' con un tercer argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_f_algorithm', cuyo valor por defecto es
     `inverse'.

     Véase también `random_f_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la densidad de Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_exp(x,m);
                                                  1
          (%o2)                 pdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                          - m x
          (%o4)                       m %e

 -- Función: cdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la distribución de Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_exp(x,m);
                                                  1
          (%o2)                 cdf_weibull(x, 1, -)
                                                  m
          (%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                           - m x
          (%o4)                      1 - %e

 -- Función: quantile_exp (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria Exponencial(m),
     con m>0; en otras palabras, se trata de la inversa de  `cdf_exp'.
     El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el cuantil de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Función: mean_exp (<m>)
     Devuelve la media de  una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la media de la Weibull.

          (%i1) load (distrib)$
          (%i2) mean_exp(m);
                                                 1
          (%o2)                  mean_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  mean_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: var_exp (<m>)
     Devuelve la varianza de  una variable aleatoria Exponencial(m),
     con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la varianza de la Weibull.

          (%i1) load (distrib)$
          (%i2) var_exp(m);
                                                 1
          (%o2)                   var_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  var_exp(m);
                                         1
          (%o4)                          --
                                          2
                                         m

 -- Función: std_exp (<m>)
     Devuelve la desviación típica de  una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en la desviación típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_exp(m);
                                                 1
          (%o2)                   std_weibull(1, -)
                                                 m
          (%i3) assume(m>0)$  std_exp(m);
                                          1
          (%o4)                           -
                                          m

 -- Función: skewness_exp (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_exp(m);
                                                   1
          (%o2)                skewness_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  skewness_exp(m);
          (%o4)                           2

 -- Función: kurtosis_exp (<m>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una
     Weibull(1,1/m), por lo que si Maxima no tiene suficiente
     información para calcular el resultado, devolverá una forma
     nominal basada en el coeficiente de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_exp(m);
                                                   1
          (%o2)                kurtosis_weibull(1, -)
                                                   m
          (%i3) assume(m>0)$  kurtosis_exp(m);
          (%o4)                           6

 -- Variable opcional: random_exp_algorithm
     Valor por defecto: `inverse'

     Es el algoritmo seleccionado para simular variables aleatoria
     exponenciales. Los algoritmos programados son `inverse',
     `ahrens_cheng' y `ahrens_dieter'
        * `inverse', basado en el método inverso.

        * `ahrens_cheng', basado en el hecho de que la variable
          aleatoria Exponencial(m) equivale a una Gamma(1,1/m). Véase
          `random_gamma_algorithm' para más detalles.

        * `ahrens_dieter', basada en el algoritmo descrito en Ahrens,
          J.H. y Dieter, U. (1972) <Computer methods for sampling from
          the exponential and normal distributions>. Comm, ACM, 15,
          Oct.,  873-882.


     Véase también `random_exp'.

 -- Función: random_exp (<m>)
 -- Función: random_exp (<m>,<k>)
     Devuelve un valor aleatorio  Exponencial(m), con m>0. Llamando a
     `random_exp2' con un segundo argumento <k>, se simulará una
     muestra aleatoria de tamaño <k>.

     Hay tres algoritmos programados para esta función, el que se vaya
     a utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_exp_algorithm', cuyo valor por defecto es
     `inverse'.

     Véase también `random_exp_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Lognormal(m,s), con s>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Lognormal(m,s), con s>0.
     Esta función se define en términos de la función de error, `erf',
     de Maxima.

          (%i1) load (distrib)$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o3)                  --------------- + -
                                        2          2

     Véase también `erf'.

 -- Función: quantile_lognormal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Lognormal(m,s),
     con s>0; en otras palabras, se trata de la inversa de
     `cdf_lognormal'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_lognormal (<m>,<s>)
     Devuelve la media de  una variable aleatoria Lognormal(m,s), con
     s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_lognormal (<m>,<s>)
     Devuelve la varianza de  una variable aleatoria Lognormal(m,s),
     con s>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_lognormal (<m>,<s>)
     Devuelve la desviación típica de  una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_lognormal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_lognormal (<m>,<s>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Lognormal(m,s), con s>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_lognormal (<m>,<s>)
 -- Función: random_lognormal (<m>,<s>,<n>)
     Devuelve un valor aleatorio  Lognormal(m,s), con s>0. Llamando a
     `random_lognormal' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Las variables lognormales se simulan mediante variables normales.
     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_normal_algorithm', cuyo valor por defecto
     es `box_mueller'.

     Véase también `random_normal_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Gamma(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Gamma(a,b), con a,b>0.

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) cdf_gamma(3,5,21);
          (%o2)                  cdf_gamma(3, 5, 21)
          (%i3) %,numer;
          (%o3)                 4.402663157135039E-7

 -- Función: quantile_gamma (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Gamma(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_gamma'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gamma (<a>,<b>)
     Devuelve la media de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_gamma (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Gamma(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gamma (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gamma (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_gamma (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Gamma(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Variable opcional: random_gamma_algorithm
     Valor por defecto: `ahrens_cheng'

     Es el algoritmo seleccionado para simular variables aleatorias
     gamma. Algoritmos programados son `ahrens_cheng' y `inverse'
        * `ahrens_cheng', se trata de una combinación de dos
          procedimientos, según sea el valor del parámetro <a>:

          Para a>=1, Cheng, R.C.H. y Feast, G.M. (1979). <Some simple
          gamma variate generators>. Appl. Stat., 28, 3, 290-295.

          Para 0<a<1, Ahrens, J.H. y Dieter, U. (1974). <Computer
          methods for sampling from gamma, beta, poisson and binomial
          distributions>. Computing, 12, 223-246.

        * `inverse', basado en el método inverso.


     Véase también `random_gamma'.

 -- Función: random_gamma (<a>,<b>)
 -- Función: random_gamma (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gamma(a,b), con a,b>0. Llamando a
     `random_gamma' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_gamma_algorithm', cuyo valor por defecto
     es `ahrens_cheng'.

     Véase también `random_gamma_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Beta(a,b), con a,b>0. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Beta(a,b), con a,b>0.

     Esta función no tiene expresión compacta, por lo que es evaluada
     numéricamente si la variable global `numer' vale `true', en caso
     contrario devuelve una forma nominal.

          (%i1) load (distrib)$
          (%i2) cdf_beta(1/3,15,2);
                                           1
          (%o2)                   cdf_beta(-, 15, 2)
                                           3
          (%i3) %,numer;
          (%o3)                 7.666089131388224E-7

 -- Función: quantile_beta (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Beta(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de  `cdf_beta'.
     El argumento <q> debe ser un número de [0,1]. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_beta (<a>,<b>)
     Devuelve la media de  una variable aleatoria Beta(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_beta (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Beta(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_beta (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_beta (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_beta (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Beta(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Variable opcional: random_beta_algorithm
     Valor por defecto: `cheng'

     Es el algoritmo seleccionado para simular variables aleatorias
     beta. Algoritmos programados son `cheng', `inverse' y `ratio'
        * `cheng', es el algoritmo definido en Cheng, R.C.H.  (1978).
          <Generating Beta Variates with Nonintegral Shape Parameters>.
          Communications of the ACM, 21:317-322

        * `inverse', basado en el método inverso.

        * `ratio', basado en el hecho de que si <X> es una variable
          aleatoria Gamma(a,1) y <Y> es una Gamma(b,1), entonces el
          cociente X/(X+Y) se distribuye como una Beta(a,b).


     Véase también `random_beta'.

 -- Función: random_beta (<a>,<b>)
 -- Función: random_beta (<a>,<b>,<n>)
     Devuelve un valor aleatorio Beta(a,b), con a,b>0. Llamando a
     `random_beta' con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño  <n>.

     Hay tres algoritmos programados para esta función, el que se vaya
     a utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_beta_algorithm', cuyo valor por defecto es
     `cheng'.

     Véase también `random_beta_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria  Uniforme Continua(a,b), con a<b. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria  Uniforme Continua(a,b),
     con a<b. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_continuous_uniform (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria  Uniforme
     Continua(a,b), con a<b; en otras palabras, se trata de la inversa
     de  `cdf_continuous_uniform'. El argumento <q> debe ser un número
     de [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_continuous_uniform (<a>,<b>)
     Devuelve la media de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_continuous_uniform (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: std_continuous_uniform (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria  Uniforme
     Continua(a,b), con a<b. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Uniforme Continua(a,b), con a<b. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_continuous_uniform (<a>,<b>)
 -- Función: random_continuous_uniform (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Uniforme Continuo(a,b), con a<b.
     Llamando a `random_continuous_uniform' con un tercer argumento
     <n>, se simulará una muestra aleatoria de tamaño  <n>.

     Esta función es una aplicación directa de la función  `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Logística(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Logística(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_logistic (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Logística(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_logistic'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_logistic (<a>,<b>)
     Devuelve la media de  una variable aleatoria Logística(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_logistic (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria Logística(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_logistic (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_logistic (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_logistic (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Logística(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_logistic (<a>,<b>)
 -- Función: random_logistic (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Logístico(a,b), con b>0. Llamando a
     `random_logistic' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Pareto(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Pareto(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_pareto (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Pareto(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_pareto'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_pareto (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Pareto(a,b), con
     a>1,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_pareto (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Pareto(a,b),
     con a>2,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_pareto (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Pareto(a,b), con a>2,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_pareto (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Pareto(a,b), con a>3,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_pareto (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Pareto(a,b), con a>4,b>0. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: random_pareto (<a>,<b>)
 -- Función: random_pareto (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Pareto(a,b), con a>0,b>0. Llamando a
     `random_pareto' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Weibull(a,b), con a,b>0. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Weibull(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_weibull (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Weibull(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     `cdf_weibull'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_weibull (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Weibull(a,b), con
     a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_weibull (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Weibull(a,b),
     con a,b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_weibull (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_weibull (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_weibull (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Weibull(a,b), con a,b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_weibull (<a>,<b>)
 -- Función: random_weibull (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Weibull(a,b), con a,b>0. Llamando a
     `random_weibull' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la densidad de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) pdf_rayleigh(x,b);
                                                  1
          (%o2)                 pdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o4)                   2 b  x %e

 -- Función: cdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la
     distribución de la Weibull.

          (%i1) load (distrib)$
          (%i2) cdf_rayleigh(x,b);
                                                  1
          (%o2)                 cdf_weibull(x, 2, -)
                                                  b
          (%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o4)                     1 - %e

 -- Función: quantile_rayleigh (<q>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Rayleigh(b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_rayleigh'. El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en los cuantiles
     de la Weibull.

          (%i1) load (distrib)$
          (%i2) quantile_rayleigh(0.99,b);
                                                      1
          (%o2)             quantile_weibull(0.99, 2, -)
                                                      b
          (%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o4)                   -----------------
                                          b

 -- Función: mean_rayleigh (<b>)
     Devuelve la media de  una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     Weibull.

          (%i1) load (distrib)$
          (%i2) mean_rayleigh(b);
                                                 1
          (%o2)                  mean_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ mean_rayleigh(b);
                                      sqrt(%pi)
          (%o4)                       ---------
                                         2 b

 -- Función: var_rayleigh (<b>)
     Devuelve la varianza de  una variable aleatoria de Rayleigh(b),
     con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la Weibull.

          (%i1) load (distrib)$
          (%i2) var_rayleigh(b);
                                                 1
          (%o2)                   var_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o4)                        -------
                                          2
                                         b

 -- Función: std_rayleigh (<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la Weibull.

          (%i1) load (distrib)$
          (%i2) std_rayleigh(b);
                                                 1
          (%o2)                   std_weibull(2, -)
                                                 b
          (%i3) assume(b>0)$ std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o4)                     -------------
                                          b

 -- Función: skewness_rayleigh (<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la Weibull.

          (%i1) load (distrib)$
          (%i2) skewness_rayleigh(b);
                                                   1
          (%o2)                skewness_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o4)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Función: kurtosis_rayleigh (<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la Weibull.

          (%i1) load (distrib)$
          (%i2) kurtosis_rayleigh(b);
                                                   1
          (%o2)                kurtosis_weibull(2, -)
                                                   b
          (%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o4)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Función: random_rayleigh (<b>)
 -- Función: random_rayleigh (<b>,<n>)
     Devuelve un valor aleatorio  Rayleigh(b), con b>0. Llamando a
     `random_rayleigh' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Laplace(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Laplace(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_laplace (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Laplace(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_laplace'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_laplace (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Laplace(a,b), con
     b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_laplace (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Laplace(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_laplace (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_laplace (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_laplace (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Laplace(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_laplace (<a>,<b>)
 -- Función: random_laplace (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Laplace(a,b), con b>0. Llamando a
     `random_laplace' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Cauchy(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Cauchy(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_cauchy (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Cauchy(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_cauchy'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: random_cauchy (<a>,<b>)
 -- Función: random_cauchy (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Cauchy(a,b), con b>0. Llamando a
     `random_cauchy' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Gumbel(a,b), con b>0. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Gumbel(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_gumbel (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Gumbel(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     `cdf_gumbel'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_gumbel (<a>,<b>)
     Devuelve la media de  una variable aleatoria de Gumbel(a,b), con
     b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$  mean_gumbel(a,b);
          (%o3)                     %gamma b + a
     donde el símbolo `%gamma' representa la constante de
     Euler-Mascheroni. Véase también `%gamma'.

 -- Función: var_gumbel (<a>,<b>)
     Devuelve la varianza de  una variable aleatoria de Gumbel(a,b),
     con b>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_gumbel (<a>,<b>)
     Devuelve la desviación típica de  una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_gumbel (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Gumbel(a,b), con b>0.

          (%i1) load (distrib)$
          (%i2) assume(b>0)$ skewness_gumbel(a,b);
                                 12 sqrt(6) zeta(3)
          (%o3)                  ------------------
                                           3
                                        %pi
          (%i4) numer:true$ skewness_gumbel(a,b);
          (%o5)                   1.139547099404649
     donde `zeta' representa la función zeta de Riemann.

 -- Función: kurtosis_gumbel (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Gumbel(a,b), con b>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: random_gumbel (<a>,<b>)
 -- Función: random_gumbel (<a>,<b>,<n>)
     Devuelve un valor aleatorio  Gumbel(a,b), con b>0. Llamando a
     `random_gumbel' con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Sólo se ha programado el método inverso. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: Definiciones para distribuciones discretas,  Prev: Definiciones para distribuciones continuas,  Up: distrib

46.3 Definiciones para distribuciones discretas
===============================================

 -- Función: pdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: cdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial(n,p), con 0<p<1 y
     n entero positivo.

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.

          (%i1) load (distrib)$
          (%i2) cdf_binomial(5,7,1/6);
                                                   1
          (%o2)                 cdf_binomial(5, 7, -)
                                                   6
          (%i3) cdf_binomial(5,7,1/6), numer;
          (%o3)                   .9998713991769548

 -- Función: quantile_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial(n,p),
     con 0<p<1 y n entero positivo; en otras palabras, se trata de la
     inversa de  `cdf_binomial'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: var_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: std_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     binomial  Binomial(n,p), con 0<p<1 y n entero positivo. Para hacer
     uso de esta función, ejecútese primero `load(distrib)'.

 -- Variable opcional: random_binomial_algorithm
     Valor por defecto: `kachit'

     Es el algoritmo seleccionado para simular variables binomiales.
     Los algoritmos programados son `kachit', `bernoulli' y `inverse':
        * `kachit', basado en el algoritmo descrito en
          Kachitvichyanukul, V. y Schmeiser, B.W. (1988) <Binomial
          Random Variate Generation>. Communications of the ACM, 31,
          Feb., 216.

        * `bernoulli', basado en la simulación de ensayos de Bernoulli.

        * `inverse', basado en el método inverso.


     Véase también `random_binomial'.

 -- Función: random_binomial (<n>,<p>)
 -- Función: random_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio  Binomial(n,p), con 0<p<1 y n entero
     positivo. Llamando a  `random_binomial' con un tercer argumento
     <m>, se simulará una muestra aleatoria de tamaño  <m>.

     Hay tres algoritmos programados para esta función, el que se vaya
     a utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_binomial_algorithm', cuyo valor por
     defecto es `kachit'.

     Véase también `random_binomial_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Poisson(m), con m>0.

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.

          (%i1) load (distrib)$
          (%i2) cdf_poisson(3,5);
          (%o2)                   cdf_poisson(3, 5)
          (%i3) cdf_poisson(3,5), numer;
          (%o3)                   .2650259152973617

 -- Función: quantile_poisson (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria de Poisson(m),
     con m>0; en otras palabras, se trata de la inversa de
     `cdf_poisson'. El argumento <q> debe ser un número de [0,1]. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_poisson (<m>)
     Devuelve la media de una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_poisson (<m>)
     Devuelve la varianza de  una variable aleatoria de Poisson(m), con
     m>0. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_poisson (<m>)
     Devuelve la desviación típica de  una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: skewness_poisson (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: kurtosis_poisson (<m>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Poisson(m), con m>0. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Variable opcional: random_poisson_algorithm
     Valor por defecto: `ahrens_dieter'

     Es el algoritmo seleccionado para simular variables de Poisson.
     Los algoritmos programados son `ahrens_dieter' y `inverse':
        * `ahrens_dieter', basado en el algoritmo descrito en Ahrens,
          J.H. and Dieter, U. (1982) <Computer Generation of Poisson
          Deviates From Modified Normal Distributions>. ACM Trans.
          Math. Software, 8, 2, June,163-179.

        * `inverse', basado en el método inverso.


     Véase también `random_poisson'.

 -- Función: random_poisson (<m>)
 -- Función: random_poisson (<m>,<n>)
     Devuelve un valor aleatorio  Poisson(m), con m>0. Llamando a
     `random_poisson' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_poisson_algorithm', cuyo valor por defecto
     es `ahrens_dieter'.

     Véase también `random_poisson_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la función de
     probabilidad de la binomial.

          (%i1) load (distrib)$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                 pdf_binomial(1, 1, p)
          (%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
          (%o4)                           p

 -- Función: cdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Bernoulli(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_bernoulli (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria de Bernoulli(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_bernoulli'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_bernoulli (<p>)
     Devuelve la media de  una variable aleatoria de Bernoulli(p), con
     0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la media de la
     binomial.

          (%i1) load (distrib)$
          (%i2) mean_bernoulli(p);
          (%o2)                  mean_binomial(1, p)
          (%i3) assume(0<p,p<1)$ mean_bernoulli(p);
          (%o4)                           p

 -- Función: var_bernoulli (<p>)
     Devuelve la varianza de  una variable aleatoria de Bernoulli(p),
     con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la varianza de
     la binomial.

          (%i1) load (distrib)$
          (%i2) var_bernoulli(p);
          (%o2)                  var_binomial(1, p)
          (%i3) assume(0<p,p<1)$ var_bernoulli(p);
          (%o4)                       (1 - p) p

 -- Función: std_bernoulli (<p>)
     Devuelve la desviación típica de  una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en la desviación
     típica de la binomial.

          (%i1) load (distrib)$
          (%i2) std_bernoulli(p);
          (%o2)                  std_binomial(1, p)
          (%i3) assume(0<p,p<1)$ std_bernoulli(p);
          (%o4)                  sqrt(1 - p) sqrt(p)

 -- Función: skewness_bernoulli (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de asimetría de la binomial.

          (%i1) load (distrib)$
          (%i2) skewness_bernoulli(p);
          (%o2)                skewness_binomial(1, p)
          (%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                                       1 - 2 p
          (%o4)                  -------------------
                                 sqrt(1 - p) sqrt(p)

 -- Función: kurtosis_bernoulli (<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Bernoulli(p), con 0<p<1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p),
     por lo que si Maxima no tiene suficiente información para calcular
     el resultado, devolverá una forma nominal basada en el coeficiente
     de curtosis de la binomial.

          (%i1) load (distrib)$
          (%i2) kurtosis_bernoulli(p);
          (%o2)                kurtosis_binomial(1, p)
          (%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o4)                    ---------------
                                      (1 - p) p

 -- Función: random_bernoulli (<p>)
 -- Función: random_bernoulli (<p>,<n>)
     Devuelve un valor aleatorio  Bernoulli(p), con 0<p<1. Llamando a
     `random_bernoulli' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Es aplicación directa de la función `random' de Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Geométrica(p), con 0<p<1.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_geometric (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Geométrica(p),
     con 0<p<1; en otras palabras, se trata de la inversa de
     `cdf_geometric'. El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: mean_geometric (<p>)
     Devuelve la media de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: var_geometric (<p>)
     Devuelve la varianza de  una variable aleatoria Geométrica(p), con
     0<p<1. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_geometric (<p>)
     Devuelve la desviación típica de  una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: skewness_geometric (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: kurtosis_geometric (<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Geométrica(p), con 0<p<1. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Variable opcional: random_geometric_algorithm
     Valor por defecto: `bernoulli'

     Es el algoritmo seleccionado para simular variables geométricas.
     Los algoritmos programados son `bernoulli', `devroye' y `inverse':
        * `bernoulli', basado en la simulación de ensayos de Bernoulli.

        * `devroye', basado en el algoritmo descrito en Devroye, L.
          (1986) <Non-Uniform Random Variate Generation.> Springer
          Verlag, p. 480.

        * `inverse', basado en el método inverso.


     Véase también `random_geometric'.

 -- Función: random_geometric (<p>)
 -- Función: random_geometric (<p>,<n>)
     Devuelve un valor aleatorio Geométrico(p), con 0<p<1. Llamando a
     `random_geometric' con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño  <n>.

     Hay tres algoritmos programados para esta función, el que se vaya
     a utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_geometric_algorithm', cuyo valor por
     defecto es `bernoulli'.

     Véase también `random_geometric_algorithm'. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: pdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: cdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: quantile_discrete_uniform (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo; en otras palabras, se trata de
     la inversa de  `cdf_discrete_uniform'. El argumento <q> debe ser
     un número de [0,1]. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: mean_discrete_uniform (<n>)
     Devuelve la media de  una variable aleatoria Uniforme Discreta(n),
     con n entero positivo. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: var_discrete_uniform (<n>)
     Devuelve la varianza de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: std_discrete_uniform (<n>)
     Devuelve la desviación típica de  una variable aleatoria Uniforme
     Discreta(n), con n entero positivo. Para hacer uso de esta
     función, ejecútese primero `load(distrib)'.

 -- Función: skewness_discrete_uniform (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_discrete_uniform (<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: random_discrete_uniform (<n>)
 -- Función: random_discrete_uniform (<n>,<m>)
     Devuelve un valor aleatorio  Uniforme Discreto(n), con n entero
     positivo. Llamando a  `random_discrete_uniform' con un segundo
     argumento <m>, se simulará una muestra aleatoria de tamaño  <m>.

     Se trata de una aplicación directa de la función `random' de
     Maxima.

     Véase también `random'. Para hacer uso de esta función, ejecútese
     primero `load(distrib)'.

 -- Función: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución of una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.

 -- Función: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2; en otras palabras, se trata de la inversa de
     `cdf_hypergeometric'. El argumento <q> debe ser un número de
     [0,1]. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: mean_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la media de  una variable aleatoria uniforme discreta
     Hyp(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.
     Para hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: var_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la varianza de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: std_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la desviación típica de  una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: skewness_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Función: kurtosis_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2. Para hacer uso de esta función, ejecútese primero
     `load(distrib)'.

 -- Variable opcional: random_hypergeometric_algorithm
     Valor por defecto: `kachit'

     Es el algoritmo seleccionado para simular variables
     hipergeométricas. Los algoritmos programados son `kachit' and
     `inverse':
        * `kachit', basado en el algoritmo descrito en
          Kachitvichyanukul, V., Schmeiser, B.W. (1985) <Computer
          generation of hypergeometric random variates.> Journal of
          Statistical Computation and Simulation 22, 127-145.

        * `inverse', basado en el método inverso.


     Véase también `random_hypergeometric'.

 -- Función: random_hypergeometric (<n1>,<n2>,<n>)
 -- Función: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Devuelve un valor aleatorio Hipergeométrico(n1,n2,n), con <n1>,
     <n2> y <n> enteros positivos y n<=n1+n2. Llamando a
     `random_hypergeometric' con un cuarto argumento <m>, se simulará
     una muestra aleatoria de tamaño  <m>.

     Hay dos algoritmos programados para esta función, el que se vaya a
     utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_hypergeometric_algorithm', cuyo valor por
     defecto es `kachit'.

     Véase también `random_hypergeometric_algorithm'. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: pdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n entero positivo. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: cdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial Negativa(n,p), con
     0<p<1 y n entero positivo.

     Esta función no tiene expresión compacta y se calcula
     numéricamente si la variable global `numer' vale `true', en otro
     caso devuelve una expresión nominal.

          (%i1) load (distrib)$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                                       1
          (%o2)            cdf_negative_binomial(3, 4, -)
                                                       8
          (%i3) cdf_negative_binomial(3,4,1/8), numer;
          (%o3)                  .006238937377929698

 -- Función: quantile_negative_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 y n entero positivo; en otras palabras,
     se trata de la inversa de  `cdf_negative_binomial'. El argumento
     <q> debe ser un número de [0,1]. Para hacer uso de esta función,
     ejecútese primero `load(distrib)'.

 -- Función: mean_negative_binomial (<n>,<p>)
     Devuelve la media de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: var_negative_binomial (<n>,<p>)
     Devuelve la varianza de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: std_negative_binomial (<n>,<p>)
     Devuelve la desviación típica de  una variable aleatoria Binomial
     Negativa(n,p), con 0<p<1 and n entero positivo. Para hacer uso de
     esta función, ejecútese primero `load(distrib)'.

 -- Función: skewness_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial Negativa(n,p), con 0<p<1 and n entero positivo. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Función: kurtosis_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     binomial negativa  NB(n,p), con 0<p<1 and n entero positivo. Para
     hacer uso de esta función, ejecútese primero `load(distrib)'.

 -- Variable opcional: random_negative_binomial_algorithm
     Valor por defecto: `bernoulli'

     Es el algoritmo seleccionado para simular variables aleatorias
     binomiales negativas. Los algoritmos programados son `devroye',
     `bernoulli' y `inverse':
        * `devroye', basado en el algoritmo descrito en Devroye, L.
          (1986) <Non-Uniform Random Variate Generation>. Springer
          Verlag, p. 480.

        * `bernoulli', basado en la simulación de ensayos de Bernoulli.

        * `inverse', basado en el método inverso.


     Véase también `random_negative_binomial'.

 -- Función: random_negative_binomial (<n>,<p>)
 -- Función: random_negative_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial Negativo(n,p), con 0<p<1 y n
     entero positivo. Llamando a  `random_negative_binomial' con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Hay tres algoritmos programados para esta función, el que se vaya
     a utilizar tendrá que ser seleccionado dándole un valor a la
     variable global `random_negative_binomial_algorithm', cuyo valor
     por defecto es `bernoulli'.

     Véase también `random_negative_binomial_algorithm'. Para hacer uso
     de esta función, ejecútese primero `load(distrib)'.


File: maxima.info,  Node: draw,  Next: dynamics,  Prev: distrib,  Up: Top

47 draw
*******

* Menu:

* Introducción a draw::
* Definiciones para draw::


File: maxima.info,  Node: Introducción a draw,  Next: Definiciones para draw,  Prev: draw,  Up: draw

47.1 Introducción a draw
========================

`draw' es un interfaz para comunicar Maxima con Gnuplot.

   Hay tres funciones a utilizar a nivel de Maxima: `draw2d', `draw3d'
y `draw'.

   Sígase este enlace para ver ejemplos más elaborados de este paquete:

   http://www.telefonica.net/web2/biomates/maxima/gpdraw

   Se necesita tener instalado Gnuplot 4.2 para ejecutar este paquete.


File: maxima.info,  Node: Definiciones para draw,  Prev: Introducción a draw,  Up: draw

47.2 Definiciones para draw
===========================

 -- Opción gráfica: xrange
     Valor por defecto: `false'

     Cuando `xrange' vale `false', el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en `xrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también `yrange' y `zrange'.

 -- Opción gráfica: yrange
     Valor por defecto: `false'

     Cuando `yrange' vale `false', el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en `yrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `zrange'.

 -- Opción gráfica: zrange
     Valor por defecto: `false'

     Cuando `zrange' vale `false', el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en `zrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también `yrange' y `zrange'.

 -- Opción gráfica: logx
     Valor por defecto: `false'

     Cuando `logx' vale `true', el eje <x> se dibujará en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también `logy' y `logz'.

 -- Opción gráfica: logy
     Valor por defecto: `false'

     Cuando `logy' vale `true', el eje <y> se dibujará en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también `logx' y `logz'.

 -- Opción gráfica: logz
     Valor por defecto: `false'

     Cuando `logz' vale `true', el eje <z> se dibujará en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también `logx' y `logy'.

 -- Opción gráfica: terminal
     Valor por defecto: `screen'

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: `screen' (por defecto), `png', `jpg', `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Examples:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       pic_width = 300,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$

     Véanse también `file_name', `pic_width' y `pic_height'.

 -- Opción gráfica: grid
     Valor por defecto: `false'

     Cuando `grid' vale `true', se dibujará una rejilla sobre el plano
     <xy>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: title
     Valor por defecto: `""' (cadena vacía)

     La opción `title' almacena una cadena de Maxima con el título de
     la escena. Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: xlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `xlabel' almacena una cadena de Maxima con la etiqueta
     del eje <x>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también `ylabel' y `zlabel'.

 -- Opción gráfica: ylabel
     Valor por defecto: `""' (cadena vacía)

     La opción `ylabel' almacena una cadena de Maxima con la etiqueta
     del eje <y>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también `xlabel' y `zlabel'.

 -- Opción gráfica: zlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `zlabel' almacena una cadena de Maxima con la etiqueta
     del eje <z>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también `xlabel' y `ylabel'.

 -- Opción gráfica: xtics
     Valor por defecto: `true'

     Cuando `xtics' vale `true', se dibujarán las marcas del eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the x-axis */
                draw2d(xtics = false,
                       explicit(exp(u),u,-2,2))$

     Véanse también `ytics' y `ztics'.

 -- Opción gráfica: ytics
     Valor por defecto: `true'

     Cuando `ytics' vale `true', se dibujarán las marcas del eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(ytics = false,
                       explicit(exp(u),u,-2,2),
                       xtics = false)$

     Véanse también `xtics' y `ztics'.

 -- Opción gráfica: ztics
     Valor por defecto: `true'

     Cuando `ztics' vale `true', se dibujarán las marcas del eje <z>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) /* No tics in the z-axis */
                draw3d(ztics = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también `xtics' y `ytics'.

 -- Opción gráfica: rot_vertical
     Valor por defecto: 60

     `rot_vertical' es el ángulo (en grados) de la rotación vertical
     (alrededor del eje <x>) para situar el punto del observador en las
     escenas 3d.

     El ángulo debe pertenecer al intervalo [0, 180].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véase también `rot_horizontal'.

 -- Opción gráfica: rot_horizontal
     Valor por defecto: 30

     `rot_horizontal' es el ángulo (en grados) de la rotación horizontal
     (alrededor del eje <z>) para situar el punto del observador en las
     escenas 3d.

     El ángulo debe pertenecer al intervalo [0, 360].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       rot_horizontal = 360,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véase también `rot_vertical'.

 -- Opción gráfica: xy_file
     Valor por defecto: `""' (cadena vacía)

     `xy_file' es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla 'x'. Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: user_preamble
     Valor por defecto: `""' (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción `plot' o `splot'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     El terminal dumb no está soportado por el paquete `draw', pero es
     posible activarlo haciendo uso de la opción `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opción gráfica: file_name
     Valor por defecto: `"maxima_out"'

     `file_name' es el nombre del fichero en el que los terminales
     `png', `jpg', `eps' y `eps_color' guardarán el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también `terminal', `pic_width' y `pic_height'.

 -- Opción gráfica: pic_width
     Valor por defecto: 640

     `pic_width' es la anchura del fichero de imagen de bits generado
     por los terminales `png' y `jpg'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pic_height'.

 -- Opción gráfica: pic_height
     Valor por defecto: 640

     `pic_height' es la altura del fichero de imagen de bits generado
     por los terminales `png' y `jpg'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pic_width'.

 -- Opción gráfica: eps_width
     Valor por defecto: 12

     `eps_width' es el ancho (medido en cm) del archivo Postscipt
     generado por los terminales `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `eps_height'.

 -- Opción gráfica: eps_height
     Valor por defecto: 8

     `eps_height' es la altura (medida en cm) del archivo Postscipt
     generado por los terminales `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `eps_width'.

 -- Opción gráfica: axis_bottom
     Valor por defecto: `true'

     Cuando `axis_bottom' vale `true', el eje inferior permanece
     visible en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_left',  `axis_top', `axis_right' y `axis_3d'.

 -- Opción gráfica: axis_left
     Valor por defecto: `true'

     Cuando `axis_left' vale `true', el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_top', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_top
     Valor por defecto: `true'

     Cuando `axis_top' vale `true', el eje superior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_right
     Valor por defecto: `true'

     Cuando `axis_right' vale `true', el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y `axis_3d'.

 -- Opción gráfica: axis_3d
     Valor por defecto: `true'

     Cuando `axis_3d' vale `true', los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y
     `axis_right' for axis in 2d.

 -- Opción gráfica: palette
     Valor por defecto: `color'

     `palette' indica cómo transformar los valores reales de una matriz
     pasada al objeto `image' en componentes cromáticas.

     `palette' es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

 -- Opción gráfica: colorbox
     Valor por defecto: `true'

     Cuando `colorbox' vale `true', se dibuja una escala de color al
     lado de los objetos `image'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox=false, image(im,0,0,30,30))$

     Véase también `palette'.

 -- Opción gráfica: enhanced3d
     Valor por defecto: `false'

     Si `enhanced3d' vale `true', se coloreaerán las superficies de los
     gráficos tridimensionales; en otras palabras, se activa el modo
     pm3d de Gnuplot.

     Véase la opción `palette' para informarse sobre cómo se
     especifican las paletas de colores.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(surface_hide = true,
                       enhanced3d   = true,
                       palette      = gray,
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

 -- Opción gráfica: point_size
     Valor por defecto: 1

     `point_size' establece el tamaño de los puntos dibujados. Debe ser
     un número no negativo.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(points(makelist([random(20),random(50)],k,1,10)),
                       point_size = 5,
                       points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     `point_type' es un índice (mayor o igual que -1) que permite
     especificar cómo serán dibujados los puntos aislados.  El color de
     los puntos se controla mediante esta opción.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = 1,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = 2,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = 3,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = 4,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = 7,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = 9,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: `false'

     Cuando `points_joined' vale `true', los puntos se unen con
     segmentos.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = 1,
                       line_type     = 3,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = 3,
                       line_type     = 5,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = 5,
                       line_type     = 8,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: filled_func
     Valor por defecto: `false'

     `filled_func' indica si la función se debe rellenar (`true') o no
     (`false').

     Esta opción sólo afecta al objeto gráfico bidimensional `explicit'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Véase también `fill_color'.

 -- Opción gráfica: transparent
     Valor por defecto: `false'

     Cuando `transparent' vale `true', las regiones internas de los
     polígonos se rellenan de acuerdo con `fill_color'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: border
     Valor por defecto: `true'

     Cuando `border' vale `true', los bordes de los polígonos se
     dibujan de acuerdo con `line_type' y `line_width'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: head_both
     Valor por defecto: `false'

     Cuando `head_both' vale `true', los vectores se dibujan
     bidireccionales.  Si vale `false', se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también `head_length', `head_angle' y `head_type'.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     `head_length' indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_type'.

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     `head_angle' indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también `head_both', `head_length' y `head_type'.

 -- Opción gráfica: head_type
     Valor por defecto: `filled'

     `head_type' se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores. Los valores posibles para esta opción
     son: `filled' (flechas cerradas y rellenas), `empty' (flechas
     cerradas pero no rellenas) y `nofilled' (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_length'.

 -- Opción gráfica: label_alignment
     Valor por defecto: `center'

     `label_alignment' se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia. Los
     valores posibles para esta opción son: `center', `left' y `right'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label("Centered alignment (default)",5,2),
                       label_alignment = 'left,
                       label("Left alignment",5,5),
                       label_alignment = 'right,
                       label("Right alignment",5,8))$

     Véanse también `label_orientation' y `color'.

 -- Opción gráfica: label_orientation
     Valor por defecto: `horizontal'

     `label_orientation' se utiliza para especificar la orientación de
     las etiquetas. Los valores posibles para esta opción son:
     `horizontal' y `vertical'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete `draw' necesita siempre de datos para
     construir la escena.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label("Horizontal orientation (default)",5,2),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label("Vertical orientation",1,5))$

     Véanse también `label_alignment' y `color'.

 -- Opción gráfica: color
     Valor por defecto: `"black"'

     `color' especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: `"white"', `"black"',
     `"gray0"', `"grey0"', `"gray10"', `"grey10"', `"gray20"',
     `"grey20"', `"gray30"', `"grey30"', `"gray40"', `"grey40"',
     `"gray50"', `"grey50"', `"gray60"', `"grey60"', `"gray70"',
     `"grey70"', `"gray80"', `"grey80"', `"gray90"', `"grey90"',
     `"gray100"', `"grey100"', `"gray"', `"grey"', `"light-gray"',
     `"light-grey"', `"dark-gray"', `"dark-grey"', `"red"',
     `"light-red"', `"dark-red"', `"yellow"', `"light-yellow"',
     `"dark-yellow"', `"green"', `"light-green"', `"dark-green"',
     `"spring-green"', `"forest-green"', `"sea-green"', `"blue"',
     `"light-blue"', `"dark-blue"', `"midnight-blue"', `"navy"',
     `"medium-blue"', `"royalblue"', `"skyblue"', `"cyan"',
     `"light-cyan"', `"dark-cyan"', `"magenta"', `"light-magenta"',
     `"dark-magenta"', `"turquoise"', `"light-turquoise"',
     `"dark-turquoise"', `"pink"', `"light-pink"', `"dark-pink"',
     `"coral"', `"light-coral"', `"orange-red"', `"salmon"',
     `"light-salmon"', `"dark-salmon"', `"aquamarine"', `"khaki"',
     `"dark-khaki"', `"goldenrod"', `"light-goldenrod"',
     `"dark-goldenrod"', `"gold"', `"beige"', `"brown"', `"orange"',
     `"dark-orange"', `"violet"', `"dark-violet"', `"plum"' y
     `"purple"'.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato `"#rrggbb"'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = "red",
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = "light-blue", /* double quotes if - is used */
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label("This is a label",0,1.2)  )$

     Véase también `fill_color'.

 -- Opción gráfica: fill_color
     Valor por defecto: `"red"'

     `fill_color' especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase `color' para más información sobre cómo definir colores.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     `line_width' es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points' y `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_type'.

 -- Opción gráfica: line_type
     Valor por defecto: 1

     `line_type' indica cómo se van a dibujar las líneas; valores
     posibles son `solid' y `dots'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric' y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_width'.

 -- Opción gráfica: nticks
     Valor por defecto: 30

     `nticks' es el número de puntos muestreados por la rutina gráfica.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' y `polar'.

        * `gr3d': `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     `adapt_depth' es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo `explicit' en
     2d.

 -- Opción gráfica: key
     Valor por defecto: `""' (cadena vacía)

     `key' es la clave de una función en la leyenda. Si `key' es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric', y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key = "Sinus",
                       explicit(sin(x),x,0,10),
                       key = "Cosinus",
                       line_type = 3,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     `xu_grid' es el número de coordenadas de la primera variable (`x'
     en superficies explcítas y `u' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `yv_grid'.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     `yv_grid' es el número de coordenadas de la segunda variable (`y'
     en superficies explcítas y `v' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `xu_grid'.

 -- Opción gráfica: surface_hide
     Valor por defecto: `false'

     Cuando `surface_hide' vale `true', las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: contour
     Valor por defecto: `none'

     La opción `contour' permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        * `none': no se dibujan líneas de nivel.

        * `base': las líneas de nivel se proyectan sobre el plano xy.

        * `surface': las líneas de nivel se dibujan sobre la propia
          superficie.

        * `both': se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        * `map': las líneas de nivel se proyectan sobre el plano xy y
          el punto de vista del observador se coloca perpendicularmente
          a él.


     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour_levels'.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     `contour_levels' is the number of levels in contour plots.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour'.

 -- Opción gráfica: columns
     Valor por defecto: 1

     `columns' es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opción gráfica: ip_grid
     Valor por defecto: `[50, 50]'

     `ip_grid' establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: `[5, 5]'

     `ip_grid_in' establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Constructor de escena: gr2d (<Opción gráfica>, ..., <graphic
          object>, ...)
     La función `gr2d' construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos. Esta
     escena se interpreta secuencialmente: las opciones gráficas
     afectan a aquellos objetos gráficos colocados a su derecha.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Esta es la lista de objetos gráficos disponibles para escenas en
     dos dimensiones:

        * `points([[x1,y1], [x2,y2], [x3,y3],...])' o
          `points([x1,x2,x3,...], [y1,y2,y3,...])': dibuja los puntos
          `[x1,y1]', `[x2,y2]', `[x2,y2]', ....

          Este objeto depende de las siguientes opciones gráficas:
          `point_size', `point_type', `points_joined', `line_width',
          `key', `line_type' y `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(key           = "puntitos",
                            points(makelist([random(20),random(50)],k,1,10)),
                            point_type    = 6,
                            point_size    = 3,
                            points_joined = true,
                            key           = "puntazos",
                            points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

        * `polygon([[x1,y1], [x2,y2], [x3,y3],...])' o
          `polygon([x1,x2,x3,...], [y1,y2,y3,...])': dibuja sobre el
          plano el polígono de vértices `[x1,y1]', `[x2,y2]',
          `[x2,y2]', ....

          Este objeto depende de las siguientes opciones gráficas:
          `transparent', `fill_color', `border', `line_width', `key',
          `line_type' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(color      = "#e245f0",
                            line_width = 8,
                            polygon([[3,2],[7,2],[5,5]]),
                            border      = false,
                            fill_color  = yellow,
                            polygon([[5,2],[9,2],[7,5]]) )$

        * `rectangle([x1,y1], [x2,y2])': dibuja un rectángulo con
          vértices opuestos `[x1,y1]' y `[x2,y2]'.

          Este objeto depende de las siguientes opciones gráficas:
          `transparent', `fill_color', `border', `line_width', `key',
          `line_type' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(fill_color  = red,
                            line_width  = 6,
                            line_type   = dots,
                            transparent = false,
                            fill_color  = blue,
                            rectangle([-2,-2],[8,-1]),   /* opposite vertices */
                            transparent = true,
                            line_type   = solid,
                            line_width  = 1,
                            rectangle([9,4],[2,-1.5]),
                            xrange      = [-3,10],
                            yrange      = [-3,4.5] )$

        * `ellipse(xc, yc, a, b, ang1, ang2)': dibuja una elipse de
          centro `[xc, yc]' con semiejes horizontal y vertical `a' y
          `b', respectivamente, a partir del ángulo `ang1' un ángulo de
          amplitud `ang2'.

          Este objeto depende de las siguientes opciones gráficas:
          `nticks', `transparent', `fill_color', `border', `line_width',
          `line_type', `key' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(transparent = false,
                            fill_color  = red,
                            color       = gray30,
                            transparent = false,
                            line_width  = 5,
                            ellipse(0,6,3,2,270,-270),  /* center (x,y), a, b, start & end in degrees */
                            transparent = true,
                            color       = blue,
                            line_width  = 3,
                            ellipse(2.5,6,2,3,30,-90),
                            xrange      = [-3,6],
                            yrange      = [2,9] )$

        * `label(string,x,y)': escribe el texto `string' en la posición
          `[x,y]'.

          Este objeto depende de las siguientes opciones gráficas:
          `label_alignment', `label_orientation' and `color'.

          Ejemplo:

          En este ejemplo, el punto ficticio que se añade sirve para
          obtener la imagen, ya que el paquete `draw' necesita siempre
          de datos para construir la escena. Estos colores pueden
          cambiar en diferentes terminales.
               (%i1) load(draw)$
               (%i2) draw2d(explicit(x^2,x,-1,1),
                            color = "red",
                            label("Label in red",0,0.3),
                            color = "#0000ff",
                            label("Label in blue",0,0.6),
                            color = "light-blue", /* double quotes if - is used */
                            label("Label in light-blue",0,0.9)  )$

        * `vector([x,y], [dx,dy])': dibuja el vector `[dx,dy]' con
          origen en `[x,y]'.

          Este objeto depende de las siguientes opciones gráficas:
          `head_both', `head_length', `head_angle', `head_type',
          `line_width', `line_type', `key' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(xrange      = [0,12],
                            yrange      = [0,10],
                            head_length = 1,
                            vector([0,1],[5,5]), /* default type */
                            head_type = 'empty,
                            vector([3,1],[5,5]),
                            head_both = true,
                            head_type = 'nofilled,
                            line_type = dots,
                            vector([6,1],[5,5]))$

        * `explicit(fcn,var,minval,maxval)': dibuja la función
          explícita `fcn', con la variable `var' tomando valores desde
          `minval' hasta `maxval'.

          Este objeto depende de las siguientes opciones gráficas:
          `nticks', `adapt_depth', `line_width', `line_type', `key',
          `filled_func', `fill_color' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(line_width = 3,
                            color      = blue,
                            explicit(x^2,x,-3,3) )$
               (%i3) draw2d(fill_color  = brown,
                            filled_func = true,
                            explicit(x^2,x,-3,3) )$

        *
          `implicit(fcn,x-var,x-minval,x-maxval,y-var,y-minval,y-maxval)':
          dibuja la función implícita `fcn', con la variable `x-var'
          tomando valores desde `x-minval' hasta `x-maxval' y la
          variable `y-var' tomando valores desde `y-minval' hasta
          `y-maxval'.

          Este objeto depende de las siguientes opciones gráficas:
          `ip_grid', `ip_grid_in', `line_width', `line_type', `key' and
          `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(terminal  = eps,
                            grid      = true,
                            line_type = solid,
                            key       = "y^2=x^3-2*x+1",
                              implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                            line_type = dots,
                            key       = "x^3+y^3 = 3*x*y^2-x-1",
                             implicit(x^3+y^3 = 3*x*y^2-x-1, x, -4,4, y, -4,4),
                            title     = "Two implicit functions" )$

        * `polar(radius,ang,minang,maxang)': dibuja la función
          `radius(ang)' definida en coordenadas polares, con la
          variable `ang' tomando valores desde `minang' hasta `maxang'.

          Este objeto depende de las siguientes opciones gráficas:
          `nticks', `line_width', `line_type', `key' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(user_preamble = "set grid polar",
                            nticks        = 200,
                            xrange        = [-5,5],
                            yrange        = [-5,5],
                            line_type     = 6,
                            line_width    = 3,
                            title         = "Hyperbolic Spiral",
                            polar(10/theta,theta,1,10*%pi) )$

        * `parametric(xfun,yfun,par,parmin,parmax)': dibuja la función
          paramétrica `[xfun,yfun]', con el parámetro `par' tomando
          valores desde `parmin' hasta `parmax'.

          Este objeto depende de las siguientes opciones gráficas:
          `nticks', `line_width', `line_type', `key'and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw2d(explicit(exp(x),x,-1,3),
                            color = red,
                            key   = "This is the parametric one!!",
                            parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

        * `image(im,x0,y0,width,height)': dibuja la imagen `im' en la
          región rectangular desde el vértice `(x0,y0)' hasta el
          `(x0+width,y0+height)' del plano real. El argumento `im' debe
          ser una matriz de números reales o una matriz de vectores de
          longitud tres.

          Si `im' es una matriz de números reales, los valores de los
          píxeles se interpretan según indique la opción gráfica
          `palette', que es un vector de longitud tres con sus
          componentes tomando valores enteros en el rango desde -36 a
          +36; cada valor es un índice para seleccionar una fórmula que
          transforma los niveles numéricos en las componentes
          cromáticas rojo, verde y azul:
                0: 0               1: 0.5           2: 1
                3: x               4: x^2           5: x^3
                6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
                9: sin(90x)       10: cos(90x)     11: |x-0.5|
               12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
               15: sin(360x)      16: cos(360x)    17: |sin(360x)|
               18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
               21: 3x             22: 3x-1         23: 3x-2
               24: |3x-1|         25: |3x-2|       26: (3x-1)/2
               27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
               30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
               33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
               36: 2*x - 1
          los números negativos se interpretan como colores invertidos
          de las componentes cromáticas.

          `palette = gray' y `palette = color' son atajos para `palette
          = [3,3,3]' y `palette = [7,5,15]', respectivamente.

          Si `im' es una matriz de vectores de longitud tres, s'tos se
          interpretarán como las componentes cromáticas rojo, verde y
          azul.

          Ejemplos:

          Si `im' es una matriz de números reales, los valores de los
          píxeles se interpretan según indique la opción gráfica
          `palette'.
               (%i1) load(draw)$
               (%i2) im: apply(
                          'matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
               (%i3) /* palette = color, default */
                     draw2d(image(im,0,0,30,30))$
               (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
               (%i5) draw2d(palette = [15,20,-4],
                            colorbox=false,
                            image(im,0,0,30,30))$

          Véase también `colorbox'.

          Si `im' es una matriz de vectores de longitud tres, éstos se
          interpretarán como las componentes cromáticas rojo, verde y
          azul.
               (%i1) load(draw)$
               (%i2) im: apply(
                           'matrix,
                            makelist(
                              makelist([random(300),
                                        random(300),
                                        random(300)],i,1,30),i,1,30))$
               (%i3) draw2d(image(im,0,0,30,30))$


     Véanse también las siguientes opciones gráficas: `xrange',
     `yrange', `logx', `logy', `terminal', `grid', `title', `xlabel',
     `ylabel', `xtics', `ytics', `xy_file', `file_name', `pic_width',
     `pic_height', `eps_width', `eps_height', `user_preamble',
     `axis_bottom', `axis_left', `axis_top' y `axis_right'.


 -- Constructor de escena: gr3d (<Opción gráfica>, ..., <graphic
          object>, ...)
     La función `gr3d' construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos. Esta
     escena se interpreta secuencialmente: las opciones gráficas
     afectan a aquellos objetos gráficos colocados a su derecha.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Esta es la lista de objetos gráficos disponibles para escenas en
     tres dimensiones:

        * `points([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3],...])' o
          `points([x1,x2,x3,...], [y1,y2,y3,...], [z1,z2,z3,...])':
          dibuja los puntos `[x1,y1,z1]', `[x2,y2,z2]', `[x2,y2,z3]',
          ....

          Este objeto depende de las siguientes opciones gráficas:
          `point_size', `point_type', `points_joined', `line_width',
          `key', `line_type' and `color'.

          Ejemplos:

          Una muestra tridimensional,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Daily average wind speeds",
                            point_size = 2,
                            points(args(submatrix (s2, 4, 5))) )$

          Dos muestras tridimensionales,
               (%i1) load(draw)$
               (%i2) load (numericalio)$
               (%i3) s2 : read_matrix (file_search ("wind.data"))$
               (%i4) draw3d(title      = "Daily average wind speeds. Two data sets",
                            point_size = 2,
                            key        = "Sample from stations 1, 2 and 3",
                            points(args(submatrix (s2, 4, 5))),
                            point_type = 4,
                            key        = "Sample from stations 1, 4 and 5",
                            points(args(submatrix (s2, 2, 3))) )$

        * `label(string,x,y,z)': escribe el texto `string' en la
          posición `[x,y,z]'.

          Este objeto depende de las siguientes opciones gráficas:
          `label_alignment', `label_orientation' y `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            color = red,
                            label("UP",-2,0,3),
                            color = blue,
                            label("DOWN",2,0,-3) )$

        * `explicit(fcn,var1,minval1,maxval1,var2,minval2,maxval2)':
          dibuja la función explícita `fcn', con la variable `var1'
          tomando valores desde `minval1' hasta `maxval1' y la variable
          `var2' tomando valores desde `minval2' hasta `maxval2'.

          Este objeto depende de las siguientes opciones gráficas:
          `xu_grid', `yv_grid', `line_type', `key' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw3d(key   = "Gauss",
                            color = "#a02c00",
                            explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                            yv_grid = 10,
                            color   = blue,
                            key     = "Plane",
                            explicit(x+y,x,-5,5,y,-5,5),
                            surface_hide = true)$

        * `parametric(xfun,yfun,zfun,par,parmin,parmax)': dibuja la
          función paramétrica `[xfun,yfun,zfun]', con el parámetro `par'
          tomando valores desde `parmin' hasta `parmax'.

          Este objeto depende de las siguientes opciones gráficas:
          `nticks', `line_width', `line_type', `key' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                            color = royalblue,
                            parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                            color      = turquoise,
                            line_width = 2,
                            parametric(t^2,sin(t),2+t,t,0,2),
                            surface_hide = true,
                            title = "Surface & curves" )$

        *
          `parametric_surface(xfun,yfun,zfun,par1,par1min,par1max,par2,par2min,par2max)':
          dibuja la superficie paramétrica `[xfun,yfun,zfun]', con el
          parámetro `par1' tomando valores desde `par1min' hasta
          `par1max' y el parámetro `par2' tomando valores desde
          `par2min' hasta `par2max'.

          Este objeto depende de las siguientes opciones gráficas:
          `xu_grid', `yv_grid', `line_type', `key' and `color'.

          Ejemplo:

               (%i1) load(draw)$
               (%i2) draw3d(title          = "Sea shell",
                            xu_grid        = 100,
                            yv_grid        = 25,
                            rot_vertical   = 100,
                            rot_horizontal = 20,
                            surface_hide   = true,
                            parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                               0.5*u*sin(u)*(cos(v)+1),
                                               u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                               u, 0, 13*%pi, v, -%pi, %pi) )$


     Véanse también las siguientes opciones gráficas: `xrange',
     `yrange', `zrange', `logx', `logy', `logz', `terminal', `grid',
     `title', `xlabel', `ylabel', `zlabel', `xtics', `ytics', `ztics',
     `xy_file', `user_preamble', `axis_bottom', `axis_left',
     `axis_top', `file_name', `pic_width', `pic_height', `eps_width',
     `eps_height', `axis_right', `rot_vertical', `rot_horizontal',
     `axis_3d', `xu_grid', `yv_grid', `surface_hide', `contour',
     `contour_levels', `palette', `colorbox' y `enhanced3d'.


 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Representa gráficamente una serie de escenas; sus argumentos son
     objetos `gr2d' y `gr3d', junto con algunas opciones. Por defecto,
     las escenas se representan en una columna.

     La función `draw' acepta dos opciones posibles:`terminal' y
     `columns'.

     Las funciones `draw2d' y `draw3d' son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Función: draw2d (<option>, <graphic object>, ...)
     Esta función es un atajo para `draw2d(gr2d(<options>, ...,
     <graphic object>, ...))'.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero `load(draw)'.


 -- Función: draw3d (<option>, <graphic object>, ...)
     Esta función es un atajo para `draw3d(gr3d(<options>, ...,
     <graphic object>, ...))'.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero `load(draw)'.


 -- Variable opcional: draw_pipes
     Valor por defecto: `true'

     Cuando `draw_pipes' vale `true', Maxima se comunica con Gnuplot
     mediante una tubería (pipe, en inglés). Cuando `draw_pipes' vale
     `false', Maxima se comunica con Gnuplot mediante ficheros.  Esto
     sólo tiene efecto en sistemas que no son Windows.



File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: draw,  Up: Top

48 dynamics
***********

* Menu:

* Introducción a dynamics::
* Definiciones para dynamics::


File: maxima.info,  Node: Introducción a dynamics,  Next: Definiciones para dynamics,  Prev: dynamics,  Up: dynamics

48.1 Introducción a dynamics
============================

El paquete adicional `dynamics' incluye varias funciones para crear
diversas representaciones gráficas de sistemas dinámicos y fractales, y
además una implementación del método numérico de Runge-Kutta de cuarto
orden, para resolver sistemas de ecuaciones diferenciales.

   Para usar las funciones en este paquete será necesario primero que
todo cargarlo con `load("dynamics")', y las funciones que crean
gráficas necesitan que Xmaxima esté instalado.


File: maxima.info,  Node: Definiciones para dynamics,  Prev: Introducción a dynamics,  Up: dynamics

48.2 Definiciones para dynamics
===============================

 -- Función: chaosgame (`[['<x1>, <y1>`]'...`['<xm>, <ym>`]]', `['<x0>,
          <y0>`]', <b>, <n>, ...opciones...);
     Usa el método llamado juego del caos, para producir fractales: se
     dibuja un punto inicial (<x0>, <y0>) y luego se elije
     aleatoriamente uno de los <m> puntos `['<x1>, <y1>`]'...`['<xm>,
     <ym>`]'. Después se dibuja un nuevo punto que estará en el
     segmento entre el último punto dibujado y el punto que se acabó de
     elegir aleatoriamente, a una distancia del punto elegido que será
     <b> veces la longitud del segmento. El proceso se repite <n> veces.


 -- Función: evolution (<F>, <y0>, <n>,...opciones...);
     Dibuja <n+1> puntos en una gráfica bidimensional (serie de
     tiempo), en que las coordenadas horizontales de los puntos son los
     números enteros 0, 1, 2, ..., <n>, y las coordenadas verticales
     son los valores <y(n)> correspondientes, obtenidos a partir de la
     relación de recurrencia
                  y(n+1) = F(y(n))

     Con valor inicial <y(0)> igual a <y0>. <F> deberá ser una
     expresión que dependa únicamente de la variable <y> (y no de <n>),
     <y0> deberá ser un número real y <n> un número entero positivo.


 -- Función: evolution2d (`['<F>, <G>`]', `['<x0>, <y0>`]', <n>,
          ...opciones...);
     Muestra, en una gráfica bidimensional, los primeros <n+1> puntos de
     la sucesión definida a partir del sistema dinámico discreto con
     relaciones de recurrencia:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Con valores iniciales <x0> y <y0>. <F> y <G> deben ser dos
     expresiones que dependan únicamente de <x> y <y>.


 -- Función: ifs (`['<r1>,...,<rm>`]',`['<A1>,...,<Am>`]',
          `[['<x1>,<y1>`]'...`['<xm>, <ym>`]]', `['<x0>,<y0>`]', <n>,
          ...opciones...);
     Usa el método del Sistema de Funciones Iteradas (IFS, en inglés
     Iterated Function System). Ese método es semejante al método
     descrito en la función `chaosgame', pero en vez de aproximar el
     último punto al punto elegido aleatoriamente, las dos coordenadas
     del último punto se multiplican por una matriz 2 por 2 <Ai>
     correspondiente al punto que fue elegido aleatoriamente.

     La selección aleatoria de uno de los <m> puntos atractivos puede
     ser realizada con una función de probabilidad no uniforme, definida
     con los pesos <r1>,...,<rm>. Esos pesos deben ser dados en forma
     acumulada; por ejemplo, si se quieren 3 puntos con probabilidades
     0.2, 0.5 y 0.3, los pesos <r1>, <r2> y <r3> podrían ser 2, 7 y 10,
     o cualquier otro grupo de números que tengan la misma proporción.


 -- Función: julia (<x>, <y>, ...<opciones>...)
     Crea un fichero gráfico con la representación del conjunto de Julia
     del número complejo (<x> + i <y>). Los parámetros <x> y <y> deben
     ser reales. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Julia, de acuerdo con el número de iteraciones que
     demore la secuencia, comenzando en ese punto, a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Julia tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: mandelbrot (<options>)
     Crea un fichero gráfico con la representación del conjunto de
     Mandelbrot. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Mandelbrot, de acuerdo con el número de iteraciones
     que demore la secuencia generada por ese punto a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Mandelbrot tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opciones...);
     Dibuja el diagrama de órbitas de una familia de sistemas dinámicos
     discretos unidimensionales, con un parámetro <x>; ese tipo de
     diagrama se usa para mostrar las bifurcaciones de un sistema
     discreto unidimensional.

     La función <F(y)> define una secuencia que comienza con un valor
     inicial <y0>, igual que en el caso de la función `evolution', pero
     en este caso la función también dependerá del parámetro <x>, el
     cual tomará valores comprendidos en el intervalo de <x0> a <xf>,
     con incrementos <xstep>. Cada valor usado para el parámetro <x> se
     muestra en el eje horizontal. En el eje vertical se mostrarán <n2>
     valores de la sucesión <y(n1+1)>,..., <y(n1+n2+1)>, obtenidos
     después de dejarla evolucionar durante <n1> iteraciones iniciales.


 -- Función: rk (EDO, var, inicial, dominio)
 -- Función: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm],
          dominio)
     La primera forma se usa para resolver numéricamente una ecuación
     diferencial ordinaria de primer orden (EDO), y la segunda forma
     resuelve numéricamente un sistema de <m> de esas ecuaciones,
     usando el método de Runge-Kutta de cuarto orden. <var> representa
     la variable dependiente.  EDO debe ser una expresión que dependa
     únicamente de las variables independiente y dependente, y define
     la derivada de la variable dependiente en función de la variable
     independiente.

     La variable independiente se representa con <dominio>, que debe ser
     una lista con cuatro elementos, como por ejemplo:
          [t, 0, 10, 0.1]
     el primer elemento de la lista identifica la variable
     independiente, el segundo y tercer elementos son los valores
     inicial y final para esa variable, y el último elemento da el
     valor de los incrementos que deberán ser usados dentro de ese
     intervalo.

     Si se van a resolver <m> ecuaciones, deberá haber <m> variables
     dependientes <v1>, <v2>, ..., <vm>. Los valores iniciales para
     esas variables serán <inic1>, <inic2>, ..., <inicm>. Continuará
     existiendo apenas una variable independiente definida por la lista
     <domain>, como en el caso anterior. <EDO1>, ..., <EDOm> son las
     expresiones que definen las derivadas de cada una de las variables
     dependientes en función de la variable independiente. Las únicas
     variables que pueden aparecer en cada una de esas expresiones son
     la variable independiente y cualquiera de las variables
     dependientes. Es importante que las derivadas <EDO1>, ..., <EDOm>
     sean colocadas en la lista en el mismo orden en que fueron
     agrupadas las variables dependientes; por ejemplo, el tercer
     elemento de la lista será interpretado como la derivada de la
     tercera variable dependiente.

     El programa intenta integrar las ecuaciones desde el valor inicial
     de la variable independiente, hasta el valor final, usando
     incrementos fijos. Si en algún paso una de las variables
     dependientes toma un valor absoluto muy grande, la integración
     será suspendida en ese punto.  El resultado será una lista con un
     número de elementos igual al número de iteraciones realizadas.
     Cada elemento en la lista de resultados es también una lista con
     <m>+1 elementos: el valor de la variable independiente, seguido de
     los valores de las variables dependientes correspondientes a ese
     punto.


 -- Función: staircase (<F>, <y0>, <n>, ...opciones...);
     Dibuja un diagrama de escalera (o diagrama de red) para la sucesión
     definida por la ecuación de recurrencia
                  y(n+1) = F(y(n))

     La interpretación y valores permitidos de los parámetros de entrada
     es la misma que para la función `evolution'. Un diagrama de
     escalera consiste en una gráfica de la función <F(y)>, junto con
     la recta <G(y)> `=' <y>. Se comienza por dibujar un segmento
     vertical desde el punto (<y0>, <y0>) en la recta, hasta el punto
     de intersección con la función <F>. En seguida, desde ese punto se
     dibuja un segmento horizontal hasta el punto de intersección con
     la recta, (<y1>, <y1>); el procedimiento se repite <n> veces hasta
     alcanzar el punto (<yn>, <yn>).


   Opciones

   Cada opción es una lista con dos o más elementos. El primer elemento
en la lista es el nombre de la opción y el resto consiste en los
argumentos para esa opción.

   Las opciones aceptadas por las funciones evolution, evolution2,
staircase, orbits, ifs y chaosgame son las siguientes:

   * "domain" especifica los valores mínimo y máximo de la variable
     independiente para la gráfica de la función <F> representada por
     `staircase'.

   * "pointsize" define el radio de cada punto dibujado, en unidades de
     puntos.  El valor por omisión es 1.

   * "xaxislabel" es la etiqueta que se escribirá en el eje horizontal.

   * "xcenter" es la coordenada x del punto que deberá aparecer en el
     centro de la gráfica. Esta opción no es usada por la función
     `orbits'.

   * "xradius" es mitad de la longitud del intervalo de valores de x que
     será representado. Esta opción no es usada por la función `orbits'.

   * "yaxislabel" es la etiqueta que se escribirá en el eje vertical.

   * "ycenter" es la coordenada y del punto que deberá aparecer en el
     centro de la gráfica.

   * "yradius" es mitad de la longitud del intervalo de valores de y que
     será representado.


   Las opciones aceptadas por los programas julia y mandelbrot son las
siguientes:

   * "size" acepta uno o dos argumentos. Si se da solo un argumento, el
     ancho y la altura del fichero gráfico creado serán iguales a ese
     valor en pixels. Si se dan dos argumentos, esos dos valores serán
     usados para el ancho y la altura. El valor por omisión es 400
     pixels tanto para el ancho como para la altura. Si los dos valores
     no son iguales, el conjunto aparecerá distorcionado.

   * "levels" define el número máximo de iteraciones, que es también el
     número de colores usado para los puntos que no pertenecem al
     conjunto. El valor por omisión es 12; valores mayores implican
     tiempos de procesamiento más elevados.

   * "huerange" define el intervalo de ángulos usados para la tonalidad
     de los puntos que no pertenecen al conjunto. El valor por omisión
     es 360, que hace que los colores usados abarcarán todo el rango de
     tonalidades. Valores mayores que 360 implican repeticiÃ³n de
     algunos valores de la tonalidad, y pueden usarse valores negativos
     para que el ángulo de tonalidad sea menor a medida que el número
     de iteraciones aumente.

   * "hue" define la tonalidad, en grados, del primer color usado para
     representar los puntos que no pertenecen al conjunto.  Su valor por
     omisión es 300 grados, que corresponde al color magenta; el color
     correspondiente para otros valores estandar es rojo 0, naranja 45,
     amarillo 60, verde 120, cian 180 y azul 240. Consulte también la
     opción <huerange>.

   * "saturation" define el nivel de saturación que será usado para los
     colores de los puntos que no pertenecen al conjunto. Debe ser un
     valor entre 0 y 1. El valor por omisión es 0.46.

   * "value" define el valor de los colores usados para puntos que no
     pertenezcan al conjunto. Debe estar comprendido entre 0 y 1; cuanto
     mayor sea, mas brilhantes serán los colores. Su valor por omisión
     es 0.96.

   * "color" debe ir seguido de tres parámetros que definen la
     tonalidad, saturación y valor del color que será usado para los
     puntos del conjunto. El valor por omisión es 0 para los tres
     parámetros, que corresponde al negro. Consulte las explicación
     sobre el rango de valores aceptados en la explicación de las
     opciones <hue>, <saturation> y <value>.

   * "center" deberá tener dos parámetros reales que dan las
     coordenadas, en el plano complejo, del punto en el centro de la
     región representada. El valor por omisión es 0 para las dos
     coordenadas (el origen).

   * "radius" es el radio de el mayor círculo que cabe dentro de la
     región quadrada que será representada. El valor por omisión es 2.

   * "filename" da el nombre del fichero donde se guardará la gráfica
     producida. A ese nombre se le acrecentará la terminación .xpm. Si
     el fichero ya existe, será substituido por el fichero producido
     por la función. El valor por omisión es julia para el conjunto de
     Julia y mandelbrot para el conjunto de Mandelbrot.


   Ejemplos

   Representación gráfica y diagrama de escalera de la secuencia: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

   Si su procesador es lento, tendrá que reducir el número de
iteraciones usado en los ejemplos siguientes. Y el valor de <pointsize>
que da mejores resultados depende del monitor y de la resolución que
use. Tendrá que experimentar con diferentes valores.

   Diagrama de órbitas para el mapa cuadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

   Para ampliar la región alrededor de la bifurcación en la parte de
abajo, cerca de x `=' -1.25, use el comando:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

   Evolución de un sistema en dos dimensiones, que conduce a un fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

   Y una ampliación de una pequeña región en el fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

   Una gráfica del triangulo de Sierpinsky, obtenida con el juego del
caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

   El helecho de Barnsley, obtenido con el Sistema de Funciones
Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

   Para crear un fichero llamado _dinamica9.xpm_ con la representación
gráfica del conjunto de Mandelbrot, con 12 colores, use el comando:

     mandelbrot([filename,"dinamica9"])$

   y el conjunto de Julia del número (-0.55 + i 0.6) puede ser obtenido
con:
     julia(-0.55, 0.6, [levels, 36], [center, 0, 0.6], [radius, 0.3],
           [hue, 240], [huerange, -180], [filename, "dinamica10"])$

   la gráfica se guardará en el fichero _dinamica10.xpm_ y mostrará la
región desde -0.3 hasta 0.3 en la dirección x, y desde 0.3 hasta 0.9 en
la dirección y. Serán usados 36 colores, comenzando con azul e
terminando con amarillo.

   Para resolver numéricamente la ecuación diferencial

               dx/dt = t - x^2

   Con valor inicial x(t=0) = 1, en el intervalo de t desde 0 hasta 8, y
con incrementos de 0.1, se usa:

     (%i20) resultados: rk(t-x^2,x,1,[t,0,8,0.1])$

   los resultados quedarán guardados en la lista resultados.

   Para resolver numéricamente el sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para t entre 0 y 4, con valores iniciales -1.25 y 0.75 para (x, y)
en t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

49 eval_string
**************

* Menu:

* Definiciones para eval_string::


File: maxima.info,  Node: Definiciones para eval_string,  Prev: eval_string,  Up: eval_string

49.1 Definiciones para eval_string
==================================

 -- Función: eval_string (<str>)
     Analiza sintácticamente la cadena <str> interpretándola como una
     expresión de Maxima y evaluándola a continuación.  El valor dado a
     <str> debe ser una cadena de Maxima (no de Lisp).  La expresión
     puede terminar con un carácter de terminación de sentencia (`$' o
     `;') o carecer de él. Tan solo se analiza y evalúa la primera
     expresión si hay más de una.

     Si <str> no es una cadena de Maxima se emite un mensaje de error.

     Ejemplos:

          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

     Véase también `parse_string'.

 -- Función: parse_string (<str>)
     Analiza sintácticamente la cadena <str> interpretándola como una
     expresión de Maxima sin evaluarla.  El valor dado a  <str> debe
     ser una cadena de Maxima (no de Lisp).  La expresión puede
     terminar con un carácter de terminación de sentencia (`$' o `;') o
     carecer de él. Tan solo se analiza y evalúa la primera expresión
     si hay más de una.

     Si <str> no es una cadena de Maxima se emite un mensaje de error.

     Ejemplos:

          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o2)          (foo : 42, bar : foo  + baz)

     Véase también `eval_string'.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

50 f90
******

* Menu:

* Definiciones para f90::


File: maxima.info,  Node: Definiciones para f90,  Prev: f90,  Up: f90

50.1 Definiciones para f90
==========================

 -- Función: f90 (<expr>)
     La función `f90' es una mejora de la función nativa `fortran' de
     Maxima. La diferencia principal estriba en la forma como se
     interrumpen las líneas de código.

     En el siguiente ejemplo, nótese como la instrucción `fortran'
     interrumpe las líneas dentro de los símbolos.  La instrucción
     `f90', en cambio, nunca corta símbolos.

          (%i1) load("f90")$

          (%i2) expr:expand((xxx+yyy+7)^4);
                   4            3         3        2    2
          (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                       2          2        3             2
           + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                         4         3          2
           + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
           + 1372 xxx + 2401
          (%i3) fortran(expr);
                yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
               1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
               2   xxx**3+294*xxx**2+1372*xxx+2401
          (%o3)                       done
          (%i4) f90(expr);
          yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
               yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
               4+28*xxx**3+294*xxx**2+1372*xxx+2401
          (%o4)                       done

     La implementación de la función `f90' se ha hecho como un parche
     inmediato. No es en modo alguno un buen ejemplo a utilizar como
     paradigma en otras traducciones entre lenguajes.

     Antes de hacer uso de esta función ejecútese  `load("f90")'.


File: maxima.info,  Node: ggf,  Next: impdiff,  Prev: f90,  Up: Top

51 ggf
******

* Menu:

* Definiciones para ggf::


File: maxima.info,  Node: Definiciones para ggf,  Prev: ggf,  Up: ggf

51.1 Definiciones para ggf
==========================

 -- Variable opcional: GGFINFINITY
     Valor por defecto: 3

     Variable opcional para la función `ggf'.

     Cuando se calcula la fracción continua de la función generatriz,
     si un cociente parcial tiene grado estrictamente mayor que
     <GGFINFINITY> será descartado y la convergencia alcanzada hasta
     ese momento será considerada como exacta para la función
     generatriz. Lo más frecuente es que el grado de todos los
     cocientes parciales sea 0 ó 1, de modo que si se utiliza un valor
     mayor se deberán dar más términos para conseguir un cálculo más
     exacto.

     Véase también `ggf'.

 -- Variable opcional: GGFCFMAX
     Valor por defeco: 3

     Variable opcional para la función `ggf'.

     Cuando se calcula la fracción continua de la función generatriz,
     si no se ha encontrado un resultado aceptable (véase la variable
     <GGFINFINITY>) después de haber calculado <GGFCFMAX> cocientes
     parciales, la función generatriz será considerada no equivalente a
     una fracción racional y la función `ggf' se detendrá. Puede
     asignársele a <GGFCFMAX> un valor mayor para funciones
     generatrices más complicadas.

     Véase también `ggf'.

 -- Función: ggf (<l>)
     Calcula la función generatriz de una sucesión de la que se
     suministran tan solo los primeros valores y cuyo término general
     es una fracción algebraica (cociente de dos polinomios).

     La solución se devuelve como una fracción de polinomios.  En caso
     de no poder encontrar una solución, se devuelve `done'.

     Esta función está controlada por las variables globales
     <GGFINFINITY> y <GGFCFMAX>. Véanse también <GGFINFINITY> y
     <GGFCFMAX>.

     Antes de hacer uso de esta función ejecútese  `load("ggf")'.


File: maxima.info,  Node: impdiff,  Next: interpol,  Prev: ggf,  Up: Top

52 impdiff
**********

* Menu:

* Definiciones para impdiff::


File: maxima.info,  Node: Definiciones para impdiff,  Prev: impdiff,  Up: impdiff

52.1 Definiciones para impdiff
==============================

 -- Función: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Calcula las derivadas implícitas de funciones multivariantes. <f>
     es una función array, los índices son los grados de las derivadas
     en el orden establecido en <indvarlist>, <indvarlist> es la lista
     de variables independientes, <orderlist> es el orden deseado y
     <depvar> es la variable dependiente.

     Antes de hacer uso de esta función ejecútese  `load("impdiff")'.



File: maxima.info,  Node: interpol,  Next: lbfgs,  Prev: impdiff,  Up: Top

53 interpol
***********

* Menu:

* Introducción a interpol::
* Definiciones para interpol::


File: maxima.info,  Node: Introducción a interpol,  Next: Definiciones para interpol,  Prev: interpol,  Up: interpol

53.1 Introducción a interpol
============================

El paquete `interpol' desarrolla los métodos de interpolación
polinómica de Lagrange, lineal y de splines cúbicos.

   Para comentarios, fallos o sugerencias, contactar con <'mario ARROBA
edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Definiciones para interpol,  Prev: Introducción a interpol,  Up: interpol

53.2 Definiciones para interpol
===============================

 -- Función: lagrange (<points>)
 -- Función: lagrange (<points>, <option>)
     Calcula el polinomio de interpolación por el método de Lagrange.
     El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es `'x'; para definir
     otra, escríbase algo como `varname='z'.

     Ejemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) /* Plot the polynomial together with points */
                plot2d([f(x),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o8)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5


 -- Función: charfun2 (<x>, <a>, <b>)
     Devuelve `true' si el número <x> pertenece al intervalo [a, b), y
     `false' en caso contrario.

 -- Función: linearinterpol (<points>)
 -- Función: linearinterpol (<points>, <option>)
     Calcula rectas de interpolación. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es `'x'; para definir
     otra, escríbase algo como `varname='z'.

     Ejemplos:

          (%i1) load("interpol")$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7)  /* Plot the polynomial together with points */
                 plot2d(['(f(x)),[discrete,args(p)]],[x,-5,20],
                     [gnuplot_curve_styles,
                           ["with lines","with points pointsize 3"]])$
          (%i8)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o8) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3


 -- Función: cspline (<points>)
 -- Función: cspline (<points>, <option1>, <option2>, ...)
     Calcula el polinomio de interpolación por el método de los splines
     cúbicos. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de tres opciones para acomodarse a
     necesidades concretas:

        * `'d1', por defecto `'unknown', es la primera derivada en x_1;
          si toma el valor `'unknown', la segunda derivada en x_1 se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * `'dn', por defecto `'unknown', es la primera derivada en x_n;
          si toma el valor `'unknown', la segunda derivada en x_n se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * `'varname', por defecto `'x', es el nombre de la variable
          independiente.

     Ejemplos:

          (%i1) load("interpol")$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) /* Plotting interpolating function */
                plot2d(['(f(x)),[discrete,p]],[x,0,10],
                    [gnuplot_curve_styles,
                         ["with lines","with points pointsize 3"]])$
          (%i7) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o7)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                plot2d(['(f(x)),'(g(x)),[discrete,p]],[x,0,10],
                     [gnuplot_curve_styles,
                        ["with lines","with lines","with points pointsize 3"]])$



File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: interpol,  Up: Top

54 lbfgs
********

* Menu:

* Introducción a lbfgs::
* Definiciones para lbfgs::


File: maxima.info,  Node: Introducción a lbfgs,  Next: Definiciones para lbfgs,  Prev: Top,  Up: Top

54.1 Introducción a lbfgs
=========================

La función `lbfgs' implementa el llamado algoritmo L-BFGS [1] para
resolver problemas de minimización sin restricciones mediante una
técnica cuasi-Newton con memoria limitada (BFGS). El término memoria
limitada procede del hecho de que se almacena una aproximación de rango
bajo de la inversa de la matriz hessiana, en lugar de la matriz
completa. El programa fue originalmente escrito en Fortran [2] por
Jorge Nocedal, incorporando algunas funciones escritas originalmente
por Jorge J. Moré y David J. Thuente, traducidas posteriormente a Lisp
automáticamente con el programa `f2cl'. El paquete `lbfgs' contiene el
código traducido, junto con una función interfaz que para controlar
ciertos detalles.

   Referencias:

   [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
large scale optimization". Mathematical Programming B 45:503-528 (1989)

   [2] http://netlib.org/opt/lbfgs_um.shar


File: maxima.info,  Node: Definiciones para lbfgs,  Prev: Introducción a lbfgs,  Up: Top

54.2 Definiciones para lbfgs
============================

 -- Función: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
     Encuentra una solución aproximada para el problema de minimización
     sin restricciones de la función objetivo <FOM> para la lista de
     variables <X>, partiendo de los estimadores iniciales <X0>, de tal
     manera que norm grad FOM < epsilon max(1, norm X).

     El algoritmo utilizado es una técnica cuasi-Newton con memoria
     limitada (BFGS) [1]. El término memoria limitada procede del hecho
     de que se almacena una aproximación de rango bajo de la inversa de
     la matriz hessiana, en lugar de la matriz completa.  Cada
     iteración del algoritmo es una búsqueda a lo largo de una recta,
     cuya dirección se calcula a partir de la matriz inversa aproximada
     del hessiano. La función objetivo decrece siempre tras cada
     búsqueda exitosa a lo largo de la recta; además, casi siempre
     decrece también el módulo del gradiente de la función.

     El argumento <iprint> controla los mensajes de progreso que envía
     la función `lbfgs'.

    `iprint[1]'
          `<iprint>[1]' controla la frecuencia con la que se emiten los
          mensajes.
         `iprint[1] < 0'
               No se envían mensajes.

         `iprint[1] = 0'
               Mensajes únicamente en la primera y última iteraciones.

         `iprint[1] > 0'
               Imprime un mensaje cada `<iprint>[1]' iteraciones.

    `iprint[2]'
          `<iprint>[2]' controla la cantidad de información contenida
          en los mensajes.
         `iprint[2] = 0'
               Imprime contador de iteraciones, número de evaluaciones
               de <FOM>, valor de <FOM>, módulo del gradiente de <FOM>
               y amplitud del paso.

         `iprint[2] = 1'
               Igual que `<iprint>[2] = 0', incluyendo <X0> y el
               gradiente de <FOM> evaluado en <X0>.

         `iprint[2] = 2'
               Igual que `<iprint>[2] = 1', incluyendo los valores de
               <X> en cada iteración.

         `iprint[2] = 3'
               Igual que `<iprint>[2] = 2', incluyendo el gradiente de
               <FOM> en cada iteración.

     Las columnas devueltas por `lbfgs' son las siguientes:

    `I'
          Número de iteraciones. Se incremente tras cada búsqueda a lo
          largo de una recta.

    `NFN'
          Número de evaluaciones de la función objetivo.

    `FUNC'
          Valor de la función objetivo al final de cada iteración.

    `GNORM'
          Módulo del gradiente de la función objetivo al final de cada
          iteración.

    `STEPLENGTH'
          Un parámetro interno del algoritmo de búsqueda.

     Para más información sobre el algoritmo se puede acudir a los
     comentarios en el código original en Fortran [2].

     Véanse también `lbfgs_nfeval_max' y `lbfgs_ncorrections'.

     Referencias:

     [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
     large scale optimization". Mathematical Programming B 45:503-528
     (1989)

     [2] http://netlib.org/opt/lbfgs_um.shar

     Ejemplos:

     La misma función objetivo utilizada por FGCOMPUTE en el programa
     sdrive.f del paquete LBFGS de Netlib. Nótese que las variables en
     cuestión están subindicadas. La función objetivo tiene un mínimo
     exacto igual a cero en u[k] = 1, para k = 1, ..., 8.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1], u[2], u[3], u[4], u[5], u[6], u[7], u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
             2    4     1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
             3    5     1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
             4    6     1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
             5    7     1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
             6    8     1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
             7    9     1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
             8   10     1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
             9   11     1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
            10   12     9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
            11   13     7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
            12   15     7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
            13   16     6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
            14   17     5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
            15   18     3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
            16   20     3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
            17   22     2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
            18   23     2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
            19   24     2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
            20   25     1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
            21   27     1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
            22   28     9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
            23   29     5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
            24   31     3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
            25   32     3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
            26   33     1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
            27   34     9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
            28   35     4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
            29   36     1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
            30   37     6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
            31   38     1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
            32   39     1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
            33   40     1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
            34   41     1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
            35   42     1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
            36   43     3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

     Un problema de regresión. La función objetivo es el cuadrado medio
     de la diferencia entre la predicción F(X[i]) y el valor observado
     Y[i]. La función F es monótona y acotada (llamada en ocasiones
     "sigmoidal"). En este ejemplo, `lbfgs' calcula valores aproximados
     para los parámetros de F y `plot2d' hace una representación gráfica
     comparativa de F junto con los datos observados.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1, length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

             I  NFN     FUNC                    GNORM                   STEPLENGTH

             1    3     1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
             2    6     2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
             3    8     1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
             4    9     7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
             5   10     7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
             6   11     6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
             7   12     5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
             8   13     5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
             9   14     5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00

           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)


 -- Variable: lbfgs_nfeval_max
     Valor por defecto: 100

     La variable `lbfgs_nfeval_max' almacena el número máximo de
     evaluaciones de la función objetivo en `lbfgs'. Cuando se alcanza
     el valor `lbfgs_nfeval_max', `lbfgs' devuelve el resultado logrado
     en la última iteración exitosa.


 -- Variable: lbfgs_ncorrections
     Valor por defecto: 25

     La variable `lbfgs_ncorrections' almacena el número de correcciones
     aplicadas a la matriz inversa aproximada del hessiano, la cual es
     gestionada por `lbfgs'.



File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

55 lindstedt
************

* Menu:

* Definiciones para lindstedt::


File: maxima.info,  Node: Definiciones para lindstedt,  Prev: lindstedt,  Up: lindstedt

55.1 Definiciones para lindstedt
================================

 -- Función: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Este es el primer paso hacia un programa para resolver ecuaciones
     de Lindstedt.  Puede resolver problemas con condiciones iniciales,
     las cuales pueden ser constantes arbitrarias (no pueden usarse
     <%k1> ni <%k2>) donde las condiciones iniciales sobre las
     ecuaciones de perturbación son z[i]=0, z'[i]=0 para i>0.  El
     argumento <ic> es la lista de condiciones iniciales.

     Ejemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Antes de hacer uso de esta función ejecútense
     `load("makeOrders")' y `load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

56 linearalgebra
****************

* Menu:

* Introducción a linearalgebra::
* Definiciones para linearalgebra::


File: maxima.info,  Node: Introducción a linearalgebra,  Next: Definiciones para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

56.1 Introducción a linearalgebra
=================================

El paquete `linearalgebra' contiene una batería de funciones para
álgebra lineal.

   Ejemplo:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]



Local Variables:
coding: iso-8859-1
End:
