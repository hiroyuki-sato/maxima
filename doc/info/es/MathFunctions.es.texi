@c English version 2011-12-01
@menu
* Funciones para los n@'umeros::
* Funciones para los n@'umeros complejos::
* Funciones combinatorias::
* Funciones radicales exponenciales y logar@'{@dotless{i}}tmicas::
* Funciones trigonom@'etricas::
* N@'umeros aleatorios::
@end menu




@node Funciones para los n@'umeros, Funciones para los n@'umeros complejos, Funciones matem@'aticas, Funciones matem@'aticas
@section Funciones para los n@'umeros


@deffn {Funci@'on} abs (@var{z})
La funci@'on @code{abs} representa el valor absoluto y se puede aplicar tanto 
a argumentos num@'ericos como simb@'olicos. Si el argumento @var{z} es un
n@'umero real o complejo, @code{abs} devuelve el valor absoluto de @var{z}.
Si es posible, las expresiones simb@'olicas que utilizan la funci@'on del
valor absoluto tambi@'en se simplifican.

Maxima puede derivar, integrar y calcular l@'{@dotless{i}}mites de expresiones
que contengan a @code{abs}. El paquete @code{abs_integrate} extiende las
capacidades de Maxima para calcular integrales que contengan llamadas a
@code{abs}. V@'ease @code{(%i12)} en el ejemplo de m@'as abajo.

Cuando se aplica a una lista o matriz, @code{abs} se distribuye autom@'aticamente
sobre sus elementos. De forma similar, tambi@'en se distribuye sobre los dos
miembros de una igualdad. Para cambiar este comportamiento por defecto, 
v@'ease la variable @code{distribute_over}.

Ejemplos:

C@'alculo del valor absoluto de n@'umeros reales y complejos, incluyendo
constantes num@'ericas e infinitos. El primer ejemplo muestra c@'omo 
@code{abs} se distribuye sobre los elementos de una lista.

@example
(%i1) abs([-4, 0, 1, 1+%i]);
(%o1)                  [4, 0, 1, sqrt(2)]

(%i2) abs((1+%i)*(1-%i));
(%o2)                           2
(%i3) abs(%e+%i);
                                2
(%o3)                    sqrt(%e  + 1)
(%i4) abs([inf, infinity, minf]);
(%o4)                   [inf, inf, inf]
@end example

Simplificaci@'on de expresiones que contienen @code{abs}:

@example
(%i5) abs(x^2);
                                2
(%o5)                          x
(%i6) abs(x^3);
                             2
(%o6)                       x  abs(x)

(%i7) abs(abs(x));
(%o7)                       abs(x)
(%i8) abs(conjugate(x));
(%o8)                       abs(x)
@end example

Integrando y derivando con la funci@'on @code{abs}. N@'otese que se pueden
calcular m@'as integrales que involucren la funci@'on @code{abs} si se
carga el paquete @code{abs_integrate}. El @'ultimo ejemplo muestra la
transformada de Laplace de @code{abs}. V@'ease @code{laplace}.

@example
(%i9) diff(x*abs(x),x),expand;
(%o9)                       2 abs(x)

(%i10) integrate(abs(x),x);
                             x abs(x)
(%o10)                       --------
                                2

(%i11) integrate(x*abs(x),x);
                           /
                           [
(%o11)                     I x abs(x) dx
                           ]
                           /

(%i12) load(abs_integrate)$
(%i13) integrate(x*abs(x),x);
                      2           3
                     x  abs(x)   x  signum(x)
(%o13)               --------- - ------------
                         2            6

(%i14) integrate(abs(x),x,-2,%pi);
                               2
                            %pi
(%o14)                      ---- + 2
                             2

(%i15) laplace(abs(x),x,s);
                               1
(%o15)                         --
                                2
                               s
@end example
@end deffn



@deffn {Funci@'on} ceiling (@var{x})
Si @var{x} es un n@'umero real, devuelve el menor entero mayor o igual que @var{x}.  

Si @var{x} es una expresi@'on constante (por ejemplo, @code{10 * %pi}), 
@code{ceiling} eval@'ua @var{x} haciendo uso de n@'umeros grandes en coma flotante (big floats), aplicando a continuaci@'on
 @code{ceiling} al n@'umero decimal obtenido. Puesto que @code{ceiling} hace evaluaciones en coma flotante, es posible, pero improbable, que esta funci@'on devuelva un valor err@'oneo para entradas constantes. Para evitar estos errores, la evaluaci@'on en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{ceiling} intenta devolver un valor simplificado. Aqu@'{@dotless{i}} se presentan algunos ejemplos sobre las simplificaciones que @code{ceiling} es capaz de hacer:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                                false
@end example

La funci@'on @code{ceiling} no se extiende autom@'aticamente a los elementos de listas y matrices.
Por @'ultimo, para todos los argumentos que tengan una forma compleja, @code{ceiling} devuelve una forma nominal.

Si el rango de una funci@'on es subconjunto de los n@'umeros enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta informaci@'on; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn



@deffn {Funci@'on} entier (@var{x})
Devuelve el mayor entero menor o igual a @var{x}, siendo @var{x} num@'erico. La funci@'on  @code{fix} (como en
@code{fixnum}) es un sin@'onimo, de modo que @code{fix(@var{x})} hace justamente lo mismo.

@end deffn



@deffn {Funci@'on} floor (@var{x})

Si @var{x} es un n@'umero real, devuelve el mayor entero menor o igual que @var{x}.

Si @var{x} es una expresi@'on constante (por ejemplo, @code{10 * %pi}), 
@code{floor} eval@'ua @var{x} haciendo uso de n@'umeros grandes en coma flotante (big floats), aplicando a continuaci@'on
 @code{floor} al n@'umero decimal obtenido. Puesto que @code{floor} hace evaluaciones en coma flotante, es posible, pero improbable, que esta funci@'on devuelva un valor err@'oneo para entradas constantes. Para evitar estos errores, la evaluaci@'on en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{floor} intenta devolver un valor simplificado. Aqu@'{@dotless{i}} se presentan algunos ejemplos sobre las simplificaciones que @code{floor} es capaz de hacer:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a));
@c ===end===
@example
(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
@end example

La funci@'on @code{floor} no se extiende autom@'aticamente a los elementos de listas y matrices.
Por @'ultimo, para todos los argumentos que tengan una forma compleja, @code{floor} devuelve una forma nominal.

Si el rango de una funci@'on es subconjunto de los n@'umeros enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta informaci@'on; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn


@deffn {Funci@'on} fix (@var{x})
Es un sin@'onimo de  @code{entier (@var{x})}.

@end deffn



@deffn {Funci@'on} lmax (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('max, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, env@'{@dotless{i}}a un mensaje de error.
@end deffn



@deffn {Funci@'on} lmin (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('min, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, env@'{@dotless{i}}a un mensaje de error.
@end deffn



@deffn {Funci@'on} max (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la mayor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o m@'as, @code{max} aplica la simplificaci@'on 
@code{max (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o m@'as, @var{max} intenta
eliminar las expresiones que est@'en entre otros dos de los argumentos dados; por ejemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Funci@'on} min (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la menor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o m@'as, @code{min} aplica la simplificaci@'on 
@code{min (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o m@'as, @var{min} intenta
eliminar las expresiones que est@'en entre otros dos de los argumentos dados; por ejemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn



@deffn {Funci@'on} round (@var{x})
Si @var{x} es un n@'umero real, la funci@'on devuelve el entero m@'as 
pr@'oximo a @var{x}. Los m@'ultiplos de 1/2 se redondean al entero par m@'as pr@'oximo.
La evaluaci@'on de @var{x} es similar a @code{floor} y @code{ceiling}.

@end deffn



@deffn {Funci@'on} signum (@var{x})
Tanto sea @var{x} real o complejo, la funci@'on @code{signum} devuelve 0 si @var{x}
es cero. Para un valor no nulo de @var{x}, la funci@'on devuelve @code{abs(x)/x}.

Para valores no num@'ericos de @var{x}, Maxima intenta determinar el
signo del argumento. Cuando es negativo, cero o positivo, @code{signum}
devuelve -1, 0 o 1, respectivamente. En caso de no poder determinarse,
@code{signum} devuelve una forma simplificada equivalente. Estas 
simplificaciones incluyen la transformaci@'on de @code{signum(-x)}
en @code{-signum(x)} y la de @code{signum(x*y)} en
@code{signum(x) * signum(y)}.

La funci@'on @code{signum} es distributiva respecto de listas,
matrices o ecuaciones. V@'ease @code{distribute_over}.

@end deffn








@node Funciones para los n@'umeros complejos, Funciones combinatorias, Funciones para los n@'umeros, Funciones matem@'aticas
@section Funciones para los n@'umeros complejos


@deffn {Funci@'on} cabs (@var{expr})
Calcula el valor absoluto de una expresi@'on que representa a un n@'umero
complejo. Al contrario que @code{abs}, la funci@'on @code{cabs} siempre
descompone su argumento en sus partes real e imaginaria. Si @code{x} e
@code{y} representan variables o expresiones reales, la funci@'on @code{cabs}
calcula el valor absoluto de @code{x + %i*y} como
@example
                           2    2
                     sqrt(y  + x )
@end example

La funci@'on @code{cabs} puede utilizar propiedades como la simetr@'{@dotless{i}}a
de funciones complejas para calcular el valor absoluto de una expresi@'on.

@code{cabs} no es una funci@'on apropiada para c@'alculos simb@'olicos; en tales
casos, que incluyen la integraci@'on, diferenciaci@'on y l@'{@dotless{i}}mites que
contienen valores absolutos, es mejor utilizar @code{abs}.

El resultado devuelto por @code{cabs} puede incluir la funci@'on de valor absoluto,
@code{abs}, y el arco tangente, @code{atan2}.

Cuando se aplica a una lista o matriz, @code{cabs} autom@'aticamente se distribuye
sobre sus elementos. Tambi@'en se distribuye sobre los dos miembros de una 
igualdad.

Para otras formas de operar con n@'umeros complejos, v@'eanse las funciones
@code{rectform}, @code{realpart}, @code{imagpart}, @code{carg}, @code{conjugate}
y @code{polarform}.

Ejemplos:

Ejemplos con @code{sqrt} and @code{sin}:

@example
(%i1) cabs(sqrt(1+%i*x));
                             2     1/4
(%o1)                      (x  + 1)
(%i2) cabs(sin(x+%i*y));
                    2        2         2        2
(%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))
@end example

La simetr@'{@dotless{i}}a especular de la funci@'on de error @code{erf} se utiliza
para calcular el valor absoluto del argumento complejo:

@example
(%i3) cabs(erf(x+%i*y));
                                          2
           (erf(%i y + x) - erf(%i y - x))
(%o3) sqrt(--------------------------------
                          4
                                                               2
                                (erf(%i y + x) + erf(%i y - x))
                              - --------------------------------)
                                               4
@end example

Dado que Maxima reconoce algunas identidades complejas de las funciones de
Bessel, le permite calcular su valor absoluto cuando tiene argumentos 
complejos. Un ejemplo para @code{bessel_j}:

@example
(%i4) cabs(bessel_j(1,%i));
(%o4)                 abs(bessel_j(1, %i))
@end example
@end deffn




@deffn {Funci@'on} carg (@var{z})
Devuelve el argumento complejo de @var{z}.
El argumento complejo es un @'angulo @code{theta} en @code{(-%pi, %pi]}
tal que @code{r exp (theta %i) = @var{z}} donde @code{r} es la magnitud de @var{z}.

La funci@'on @code{carg} es computacional, no simplificativa.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT

V@'eanse tambi@'en @code{abs} (m@'odulo complejo), @code{polarform}, @code{rectform},
@code{realpart} y @code{imagpart}.

Ejemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@end deffn



@deffn {Funci@'on} conjugate (@var{x})
Devuelve el conjugado complejo de @var{x}.

@c ===beg===
@c declare ([aa, bb], real, cc, complex, ii, imaginary);
@c conjugate (aa + bb*%i);
@c conjugate (cc);
@c conjugate (ii);
@c conjugate (xx + yy);
@c ===end===
@example
(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
@end example

@end deffn



@deffn {Funci@'on} imagpart (@var{expr})
Devuelve la parte imaginaria de la expresi@'on @var{expr}.

La funci@'on @code{imagpart} es computacional,
no simplificativa.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

V@'eanse tambi@'en @code{abs}, @code{carg}, @code{polarform}, @code{rectform} y @code{realpart}.

@c NEED EXAMPLES HERE
@end deffn



@c NEEDS EXAMPLES
@deffn {Funci@'on} polarform (@var{expr})
Devuelve una expresi@'on de la forma @code{r %e^(%i theta)} equivalente a @var{expr},
con @code{r} y @code{theta} son reales.

@end deffn




@c NEEDS EXAMPLES
@deffn {Funci@'on} realpart (@var{expr})
Devuelve la parte real de @var{expr}. La funciones @code{realpart} y @code{imagpart} operan tambi@'en con expresiones que contengan funciones trigonom@'etricas e hiperb@'olicas, ra@'{@dotless{i}}ces cuadradas, logaritmos y exponentes.

@end deffn

@c NEEDS EXAMPLES
@deffn {Funci@'on} rectform (@var{expr})
Devuelve una expresi@'on de la forma @code{a + b %i} equivalente a @var{expr}, con @var{a} y @var{b} reales.

@end deffn







@node Funciones combinatorias, Funciones radicales exponenciales y logar@'{@dotless{i}}tmicas, Funciones para los n@'umeros complejos, Funciones matem@'aticas
@section Funciones combinatorias



@deffn {Operador} !!
@ifinfo
@fnindex Doble factorial
@end ifinfo
El operador doble factorial.

Para un n@'umero entero, de punto flotante o racional @code{n},
@code{n!!} se evaluar@'a como el producto de @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
donde @code{k} es igual a @code{entier(n/2)}, que es, el mayor entero
menor o igual a @code{n/2}. 
Note que esta definici@'on no coincide con otras definciones publicadas para argumentos, los cuales no son enteros. 

@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para un entero par (o impar) @code{n}, @code{n!} se evalua el producto de
todos los enteros pares (o impares) consecutivos desde 2 (o 1) por @code{n} inclusive.  

Para un argumento @code{n} el cual no es un n@'umero entero, punto flotante o racional, @code{n!!} produce una forma de nombre @code{genfact (n, n/2, 2)}. 

@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn




@deffn {Funci@'on} binomial (@var{x}, @var{y})
Es el coeficiente binomial @code{@var{x}!/(@var{y}! (@var{x} - @var{y})!)}.
Si @var{x} y @var{y} son enteros, entonces se calcula el valor num@'erico 
del coeficiente binomial. Si @var{y} o @var{x - y} son enteros, 
el coeficiente binomial se expresa como un polinomio.

Ejemplos:

@c ===beg===
@c binomial (11, 7);
@c 11! / 7! / (11 - 7)!;
@c binomial (x, 7);
@c binomial (x + 7, x);
@c binomial (11, y);
@c ===end===
@example
(%i1) binomial (11, 7);
(%o1)                          330
(%i2) 11! / 7! / (11 - 7)!;
(%o2)                          330
(%i3) binomial (x, 7);
        (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
(%o3)   -------------------------------------------------
                              5040
(%i4) binomial (x + 7, x);
      (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
(%o4) -------------------------------------------------------
                               5040
(%i5) binomial (11, y);
(%o5)                    binomial(11, y)
@end example
@end deffn



@deffn {Funci@'on} factcomb (@var{expr})
Trata de combinar los coeficientes de los factoriales de @var{expr} con los mismos factoriales, convirtiendo, por ejemplo, @code{(n + 1)*n!} en @code{(n + 1)!}.

Si la variable @code{sumsplitfact} vale @code{false} har@'a que @code{minfactorial} se aplique despu@'es de @code{factcomb}.

@end deffn



@deffn {Funci@'on} factorial (@var{x})
@deffnx {Operador} !

Representa la funci@'on factorial. Maxima considera @code{factorial (@var{x})}
y @code{@var{x}!} como sin@'onimos.

Para cualquier n@'umero complejo @code{x}, excepto para
enteros negativos, @code{x!} se define como @code{gamma(x+1)}. 

Para un entero @code{x}, @code{x!} se reduce al producto de los enteros
desde 1 hasta @code{x} inclusive. @code{0!} se reduce a 1.
Para un n@'umero real o complejo en formato de coma flotante @code{x}, 
@code{x!} se reduce al valor de @code{gamma(x+1)}. Cuando
@code{x} es igual a @code{n/2}, siendo @code{n} un entero impar, entonces
@code{x!} se reduce a un factor racional multiplicado por @code{sqrt(%pi)}
(pues @code{gamma(1/2)}) es igual a @code{sqrt(%pi)}).

Las variables opcionales @code{factlim} y @code{gammalim} controlan la
evaluaci@'on num@'erica de factoriales de argumentos enteros y racionales.

Las funciones @code{minfactorial} y @code{factcomb} simplifican expresiones
que contiene factoriales.

V@'eanse tambi@'en @code{factlim}, @code{gammalim}, @code{minfactorial} y 
@code{factcomb}.

Las funciones @code{gamma}, @code{bffac} y @code{cbffac} son variaciones de
la funci@'on matem@'atica gamma. Las funciones @code{bffac} y @code{cbffac} 
son llamadas internamente desde @code{gamma} para evaluar la funci@'on gamma 
de n@'umeros reales y complejos decimales con precisi@'on de reales grandes
(bigfloats).

Las funciones @code{makegamma} substituye a @code{gamma} para factoriales 
y funciones relacionadas. 

Maxima reconoce la derivada de la funci@'on factorial y los l@'{@dotless{i}}mites
para ciertos valores espec@'{@dotless{i}}ficos, tales como los enteros negativos.

La variable opcional @code{factorial_expand} controla la simplificaci@'on de
expresiones como @code{(n+x)!}, para @code{n} entero.

V@'ease tambi@'en @code{binomial}.

Ejemplos:

El factorial de un entero se reduce a un n@'umero exacto, a menos que
el argumento sea mayor que @code{factlim}. Los factoriales de n@'umeros
reales o complejos se eval@'uan como decimales de coma flotante.

@c ===beg===
@c factlim : 10;
@c [0!, (7/2)!, 8!, 20!];
@c [4,77!, (1.0+%i)!];
@c [2.86b0!, 1.0b0+%i)!];
@c ===end===
@example
(%i1) factlim:10;
(%o1)                                 10
(%i2) [0!, (7/2)!, 8!, 20!];
                            105 sqrt(%pi)
(%o2)                   [1, -------------, 40320, 20!]
                                 16
(%i3) [4.77!, (1.0+%i)!];
(%o3)    [81.44668037931197, 
          .3430658398165454 %i + .6529654964201665]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 
       3.430658398165454b-1 %i + 6.529654964201667b-1]
@end example

El factorial de una constante conocida o de una expresi@'on general
no se calcula. Pero puede ser posible reducir el factorial despu@'es de
evaluado el argumento.

@c ===beg===
@c [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
@c ev (%, numer, %enumer);
@c ===end===
@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165454 %i + .6529654964201665, 
       7.188082728976031, 
       4.260820476357003, 1.227580202486819]
@end example

Los factoriales son simplificados o reducidos, no evaluados.
As@'{@dotless{i}} @code{x!} puede ser reemplazado en una expresi@'on 
nominal. 

@c ===beg===
@c '([0!, (7/2)!, 4.77!, 8!, 20!]);
@c ===end===
@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                             2432902008176640000]
@end example

Maxima reconoce la derivada de la funci@'on factorial.

@c ===beg===
@c diff(x!,x);
@c ===end===
@example
(%i1) diff(x!,x);
(%o1)                           x! psi (x + 1)
                                      0
@end example

La variable opcional @code{factorial_expand} controla la simplificaci@'on de
expresiones con la funci@'on factorial.

@c ===beg===
@c (n+1)!/n!,factorial_expand:true;
@c ===end===
@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                                n + 1
@end example
@end deffn



@defvr {Variable opcional} factlim
Valor por defecto: -1

La variable @code{factlim} especifica el mayor factorial que ser@'a expandido autom@'aticamente.  Si su valor es -1, entonces se expandir@'an todos los enteros.

@end defvr



@defvr {Variable opcional} factorial_expand
Valor por defecto: false

La variable @code{factorial_expand} controla la simplificaci@'on
de expresiones tales como @code{(n+1)!}, siendo @code{n} un entero. 

V@'ease @code{!} para un ejemplo.

@end defvr



@c IS THIS DEFINITION CORRECT ??
@deffn {Funci@'on} genfact (@var{x}, @var{y}, @var{z})
Devuelve el factorial generalizado, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  As@'{@dotless{i}}, para el entero @var{x},
@code{genfact (x, x, 1) = x!} y @code{genfact (x, x/2, 2) = x!!}.

@end deffn



@deffn {Funci@'on} minfactorial (@var{expr})

Busca en @var{expr} la presencia de dos factoriales que solo se
diferencien en una unidad; en tal caso, @code{minfactorial}
devuelve una expresi@'on simplificada.

@example
(%i1) n!/(n+2)!;
                               n!
(%o1)                       --------
                            (n + 2)!
(%i2) minfactorial (%);
                                1
(%o2)                    ---------------
                         (n + 1) (n + 2)
@end example

@end deffn


@defvr {Variable opcional} sumsplitfact
Valor por defecto: @code{true}

Si @code{sumsplitfact} vale @code{false},
@c "IS APPLIED" -- UNDER WHAT CIRCUMSTANCES EXACTLY ??
@code{minfactorial} se aplica despu@'es de  @code{factcomb}.

@end defvr









@node Funciones radicales exponenciales y logar@'{@dotless{i}}tmicas, Funciones trigonom@'etricas, Funciones combinatorias, Funciones matem@'aticas
@section Funciones radicales, exponenciales y logar@'{@dotless{i}}tmicas


@defvr {Variable opcional} %e_to_numlog
Valor por defecto: @code{false}

Si @code{%e_to_numlog} vale @code{true}, @code{r} es un n@'umero racional y @code{x} una expresi@'on, @code{%e^(r*log(x))} se reduce a @code{x^r} .  T@'engase en cuenta que la instrucci@'on @code{radcan} tambi@'en hace este tipo de transformaciones, as@'{@dotless{i}} como otras m@'as complicadas. La instrucci@'on @code{logcontract} "contrae" expresiones que contienen alg@'un @code{log}.
@end defvr


@defvr {Variable opcional} %emode
Valor por defecto: @code{true}

Si @code{%emode} vale @code{true},
@code{%e^(%pi %i x)} se simplifica como sigue.

@code{%e^(%pi %i x)} se simplifica a @code{cos (%pi x) + %i sin (%pi x)} si @code{x} es
un n@'umero decimal de coma flotante, un entero o un m@'ultiplo de 1/2, 1/3, 1/4 o 1/6, y luego se sigue simplificando.

Para otros valores num@'ericos de @code{x},
@code{%e^(%pi %i x)} se simplifica a @code{%e^(%pi %i y)} donde @code{y} es @code{x - 2 k}
para alg@'un entero @code{k} tal que @code{abs(y) < 1}.  

Si @code{%emode} vale @code{false}, no se realizan simplificaciones especiales a @code{%e^(%pi %i x)}.

@c NEED EXAMPLES HERE
@end defvr


@defvr {Variable opcional} %enumer
Valor por defecto: @code{false}

Si la variable @code{%enumer} vale @code{true} hace que @code{%e} se reemplace por
2.718...  siempre que @code{numer} valga @code{true}. 

Si @code{%enumer} vale @code{false}, esta sustituci@'on se realiza s@'olo si el exponente en @code{%e^x} tiene un valor num@'erico.

V@'eanse tambi@'en @code{ev} y @code{numer}.

@c NEED EXAMPLES HERE
@end defvr




@deffn {Funci@'on} exp (@var{x})
Representa la funci@'on exponencial.  
La expresi@'on  @code{exp (@var{x})} en la entrada se simplifica en @code{%e^@var{x}};
@code{exp} no aparece en expresiones simplificadas.

Si la variable @code{demoivre} vale @code{true} hace que @code{%e^(a + b %i)} se simplifique a
@code{%e^(a (cos(b) + %i sin(b)))} si @code{b} no contiene a @code{%i}. V@'ease @code{demoivre}.

Si la variable @code{%emode} vale @code{true}, 
hace que  @code{%e^(%pi %i x)} se simplifique. V@'ease @code{%emode}.

Si la variable @code{%enumer} vale @code{true} hace que @code{%e} se reemplace por
2.718...  siempre que @code{numer} valga @code{true}. V@'ease @code{%enumer}.

@end deffn



@deffn {Funci@'on} li [@var{s}] (@var{z})

Representa la funci@'on polilogar@'{@dotless{i}}tmica de orden @var{s} y argumento @var{z},
definida por la serie infinita

@tex
$${\rm Li}_s \left(z\right) = \sum_{k=1}^\infty {z^k \over k^s}$$
@end tex
@ifnottex
@example
                                 inf
                                 ====   k
                                 \     z
                        Li (z) =  >    --
                          s      /      s
                                 ====  k
                                 k = 1
@end example
@end ifnottex

@code{li [1]} es @code{- log (1 - z)}.
@code{li [2]} y @code{li [3]} son las funciones di- y trilogaritmo, respectivamente.

Cuando el orden es 1, el polilogaritmo se simplifica a @code{- log (1 - z)},
el cual a su vez se reduce a un valor num@'erico si @var{z} es un n@'umero
real o complejo en coma flotante o si est@'a presente el t@'ermino @code{numer}.

Cuando el orden es 2 @'o 3,
el polilogaritmo se reduce a un valor num@'erico si @var{z} es
un n@'umero real en coma flotante o si est@'a presente el t@'ermino @code{numer}.

Ejemplos:

@c ===beg===
@c assume (x > 0);
@c integrate ((log (1 - t)) / t, t, 0, x);
@c li [2] (7);
@c li [2] (7), numer;
@c li [3] (7);
@c li [2] (7), numer;
@c L : makelist (i / 4.0, i, 0, 8);
@c map (lambda ([x], li [2] (x)), L);
@c map (lambda ([x], li [3] (x)), L);
@c ===end===
@example
(%i1) assume (x > 0);
(%o1)                        [x > 0]
(%i2) integrate ((log (1 - t)) / t, t, 0, x);
(%o2)                       - li (x)
                                2
(%i3) li [2] (7);
(%o3)                        li (7)
                               2
(%i4) li [2] (7), numer;
(%o4)        1.24827317833392 - 6.113257021832577 %i
(%i5) li [3] (7);
(%o5)                        li (7)
                               3
(%i6) li [2] (7), numer;
(%o6)        1.24827317833392 - 6.113257021832577 %i
(%i7) L : makelist (i / 4.0, i, 0, 8);
(%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
(%i8) map (lambda ([x], li [2] (x)), L);
(%o8) [0, .2676526384986274, .5822405249432515, 
.9784693966661848, 1.64493407, 2.190177004178597
 - .7010261407036192 %i, 2.374395264042415
 - 1.273806203464065 %i, 2.448686757245154
 - 1.758084846201883 %i, 2.467401098097648
 - 2.177586087815347 %i]
(%i9) map (lambda ([x], li [3] (x)), L);
(%o9) [0, .2584613953442624, 0.537213192678042, 
.8444258046482203, 1.2020569, 1.642866878950322
 - .07821473130035025 %i, 2.060877505514697
 - .2582419849982037 %i, 2.433418896388322
 - .4919260182322965 %i, 2.762071904015935
 - .7546938285978846 %i]
@end example

@end deffn




@deffn {Funci@'on} log (@var{x})
Representa el logaritmo natural (en base @math{e}) de @var{x}.

Maxima no tiene definida una funci@'on para el logaritmo de base 10 u
otras bases. El usuario puede hacer uso de la definici@'on 
@code{log10(x) := log(x) / log(10)}.

La simplificaci@'on y evaluaci@'on de logaritmos se controla con
ciertas variables globales:

@table @code
@item @code{logexpand}
hace que @code{log(a^b)} se convierta en @code{b*log(a)}.
Si toma el valor @code{all}, @code{log(a*b)} tambi@'en se reducir@'a a  @code{log(a)+log(b)}.
Si toma el valor @code{super}, entonces @code{log(a/b)} tambi@'en se reducir@'a a
@code{log(a)-log(b)}, siendo @code{a/b} racional con @code{a#1}, 
(la expresi@'on @code{log(1/b)}, para @code{b} entero, se simplifica siempre). 
Si toma el valor  @code{false}, se desactivar@'an todas estas simplificaciones.

@item @code{logsimp}
si vale @code{false}, entonces no se transforma @code{%e} a potencias que contengan logaritmos.

@item @code{lognegint}
si vale @code{true} se aplica la regla @code{log(-n)} -> @code{log(n)+%i*%pi},
siendo @code{n} un entero positivo.

@item @code{%e_to_numlog}
si vale @code{true}, @code{r} es un n@'umero racional y @code{x} una expresi@'on,
@code{%e^(r*log(x))} se reduce a @code{x^r}. T@'engase en cuenta que la 
instrucci@'on @code{radcan} tambi@'en hace este tipo de transformaciones, 
as@'{@dotless{i}} como otras m@'as complicadas. La instrucci@'on @code{logcontract}
"contrae" expresiones que contengan alg@'un @code{log}.
@end table

@end deffn



@defvr {Variable opcional} logabs
Valor por defecto: @code{false}

Cuando se calculan integrales indefinidas en las que se generan logaritmos, como en @code{integrate(1/x,x)}, el resultado se devuelve de la forma  @code{log(abs(...))} si @code{logabs} vale @code{true}, o de la forma @code{log(...)} si
@code{logabs} vale @code{false}. En la integraci@'on definida se hace la asignaci@'on @code{logabs:true}, ya que aqu@'{@dotless{i}} es normalmente necesario evaluar la integral indefinida en los extremos del intervalo de integraci@'on.

@end defvr

@c NEEDS EXAMPLES
@defvr {Variable opcional} logarc
@defvrx {Funci@'on} logarc (@var{expr})

Si la variable global @code{logarc} toma el valor @code{true},
las funciones circulares e hiperb@'olicas inversas se 
reemplazan por funciones logar@'{@dotless{i}}tmicas equivalentes.
El valor por defecto de @code{logarc} es @code{false}.

La funci@'on @code{logarc(@var{expr})} realiza la anterior transformaci@'on
en la expresi@'on @var{expr} sin necesidad de alterar el valor de la
variable global @code{logarc}.

@end defvr



@defvr {Variable opcional} logconcoeffp
Valor por defecto: @code{false}

Controla qu@'e coeficientes se contraen cuando se utiliza @code{logcontract}. Se le puede asignar el nombre de una funci@'on de predicado de un argumento; por ejemplo, si se quiere introducir ra@'{@dotless{i}}ces cuadradas, se puede hacer @code{logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Entonces 
@code{logcontract(1/2*log(x));} devolver@'a @code{log(sqrt(x))}.

@end defvr

@deffn {Funci@'on} logcontract (@var{expr})
Analiza la expresi@'on @var{expr} recursivamente, transformando subexpresiones de la forma @code{a1*log(b1) + a2*log(b2) + c} en @code{log(ratsimp(b1^a1 * b2^a2)) + c}

@c ===beg===
@c 2*(a*log(x) + 2*a*log(y))$
@c logcontract(%);
@c ===end===
@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                 2  4
(%o2)                     a log(x  y )

@end example

Si se hace @code{declare(n,integer);} entonces @code{logcontract(2*a*n*log(x));} da
@code{a*log(x^(2*n))}.  Los coeficientes que se contraen de esta manera son aquellos que como el 2 y el @code{n} satisfacen 
@code{featurep(coeff,integer)}. El usuario puede controlar qu@'e coeficientes se contraen asign@'andole a la variable global @code{logconcoeffp} el nombre de una funci@'on de predicado de un argumento; por ejemplo, si se quiere introducir ra@'{@dotless{i}}ces cuadradas, se puede hacer @code{logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Entonces @code{logcontract(1/2*log(x));} devolver@'a @code{log(sqrt(x))}.

@end deffn


@defvr {Variable opcional} logexpand
Valor por defecto: @code{true}

Si @code{logexpand} vale @code{true} hace que @code{log(a^b)} se convierta
en @code{b*log(a)}. Si toma el valor @code{all}, @code{log(a*b)} tambi@'en se
reducir@'a a  @code{log(a)+log(b)}. Si toma el valor @code{super}, entonces 
@code{log(a/b)} tambi@'en se reducir@'a a @code{log(a)-log(b)}, siendo 
@code{a/b} racional con @code{a#1},  (la expresi@'on @code{log(1/b)}, para
@code{b} entero, se simplifica siempre). Si toma el valor  @code{false},
se desactivar@'an todas estas simplificaciones.
@end defvr



@defvr {Variable opcional} lognegint
Valor por defecto: @code{false}

Si @code{lognegint} vale @code{true} se aplica la regla @code{log(-n)} -> @code{log(n)+%i*%pi} siendo @code{n} un entero positivo.

@end defvr



@defvr {Variable opcional} logsimp
Valor por defecto: @code{true}

Si @code{logsimp} vale @code{false}, entonces no se transforma @code{%e} a potencias que contengan logaritmos.

@end defvr



@deffn {Funci@'on} plog (@var{x})
Representa la rama principal del logaritmo natural complejo con @code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} .

@end deffn



@deffn {Funci@'on} sqrt (@var{x})
Ra@'{@dotless{i}}z cuadrada de @var{x}. Se representa internamente por @code{@var{x}^(1/2)}.  V@'ease tambi@'en @code{rootscontract}.

Si la variable @code{radexpand} vale @code{true} har@'a que las ra@'{@dotless{i}}ces @code{n}-@'esimas de los factores de un producto que sean potencias de @code{n} sean extra@'{@dotless{i}}das del radical; por ejemplo, @code{sqrt(16*x^2)} se convertir@'a en @code{4*x} s@'olo si @code{radexpand} vale @code{true}.

@end deffn









@node Funciones trigonom@'etricas, N@'umeros aleatorios, Funciones radicales exponenciales y logar@'{@dotless{i}}tmicas, Funciones matem@'aticas
@section Funciones trigonom@'etricas


@menu
* Introducci@'on a la trigonometr@'{@dotless{i}}a::  
* Funciones y variables para trigonometr@'{@dotless{i}}a:: 
@end menu


@node Introducci@'on a la trigonometr@'{@dotless{i}}a, Funciones y variables para trigonometr@'{@dotless{i}}a, Funciones trigonom@'etricas, Funciones trigonom@'etricas
@subsection Introducci@'on a la trigonometr@'{@dotless{i}}a


Maxima reconoce muchas funciones trigonom@'etricas. No est@'an programadas todas las identidades trigonom@'etricas, pero el usuario puede a@~nadir muchas de ellas haciendo uso de las t@'ecnicas basadas en patrones.  Las funciones trigonom@'etricas definidas en Maxima son:  @code{acos},
@code{acosh}, @code{acot}, @code{acoth}, @code{acsc},
@code{acsch}, @code{asec}, @code{asech}, @code{asin}, 
@code{asinh}, @code{atan}, @code{atanh}, @code{cos}, 
@code{cosh}, @code{cot}, @code{coth}, @code{csc}, @code{csch}, 
@code{sec}, @code{sech}, @code{sin}, @code{sinh}, @code{tan} y 
@code{tanh}. Hay tambi@'en un determinado n@'umero de instrucciones especiales para manipular funciones trigonom@'etricas;  v@'eanse a este respecto @code{trigexpand},
@code{trigreduce} y la variable @code{trigsign}.  Dos paquetes adicionales ampl@'{@dotless{i}}an las reglas de simplificaci@'on de Maxima, @code{ntrig} y @code{atrig1}.  Ejec@'utese @code{describe(@var{command})} para m@'as detalles.








@node Funciones y variables para trigonometr@'{@dotless{i}}a,  , Introducci@'on a la trigonometr@'{@dotless{i}}a, Funciones trigonom@'etricas
@subsection Funciones y variables para trigonometr@'{@dotless{i}}a




@defvr {Variable opcional} %piargs
Valor por defecto: @code{true}

Cuando @code{%piargs} vale @code{true}, las funciones trigonom@'etricas
se simplifican a constantes algebraicas cuando el argumento es m@'ultiplo
entero de 
@iftex
@math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4} o @math{\pi/6}.
@end iftex
@ifnottex
@math{%pi}, @math{%pi/2}, @math{%pi/3}, @math{%pi/4} o @math{%pi/6}.
@end ifnottex

@iftex
Maxima conoce algunas identidades aplicables cuando @math{\pi}, etc.,
@end iftex
@ifnottex
Maxima conoce algunas identidades aplicables cuando @math{%pi}, etc.,
@end ifnottex
se multiplican por una variable entera (esto es, un s@'{@dotless{i}}mbolo
declarado como entero).

Ejemplo:

@c ===beg===
@c %piargs : false$
@c [sin (%pi), sin (%pi/2), sin (%pi/3)];
@c [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
@c %piargs : true$
@c [sin (%pi), sin (%pi/2), sin (%pi/3)];
@c [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
@c [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
@c        cos (sqrt(2)*%pi/3)];
@c ===end===
@example
(%i1) %piargs : false$
@group
(%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                %pi       %pi
(%o2)            [sin(%pi), sin(---), sin(---)]
                                 2         3
@end group
@group
(%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                      %pi       %pi       %pi
(%o3)            [sin(---), sin(---), sin(---)]
                       4         5         6
@end group
(%i4) %piargs : true$
@group
(%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                sqrt(3)
(%o5)                    [0, 1, -------]
                                   2
@end group
@group
(%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                         1         %pi   1
(%o6)                [-------, sin(---), -]
                      sqrt(2)       5    2
@end group
@group
(%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
       cos (sqrt(2)*%pi/3)];
                1    1               sqrt(2) %pi
(%o7)          [-, - -, sqrt(3), cos(-----------)]
                2    2                    3
@end group
@end example


@iftex
Se aplican ciertas identidades cuando @math{\pi} o @math{\pi/2} se multiplican por una variable entera.
@end iftex
@ifnottex
Se aplican ciertas identidades cuando @math{%pi} o @math{%pi/2} se multiplican por una variable entera.
@end ifnottex

@c ===beg===
@c declare (n, integer, m, even)$
@c [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
@c        cos (%pi/2 * m)];
@c ===end===
@example
(%i1) declare (n, integer, m, even)$
@group
(%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
       cos (%pi/2 * m)];
                                      m/2
(%o2)                  [0, 1, 0, (- 1)   ]
@end group
@end example

@end defvr




@defvr {Variable opcional} %iargs
Valor por defecto: @code{true}

Cuando @code{%iargs} vale @code{true}, las funciones trigonom@'etricas
se simplifican a funciones hiperb@'olicas
@iftex
si el argumento es aparentemente un m@'ultiplo de la unidad imaginaria @math{i}.
@end iftex
@ifnottex
si el argumento es aparentemente un m@'ultiplo de la unidad imaginaria @math{%i}.
@end ifnottex

La simplificaci@'on se lleva a cabo incluso cuando el argumento es manifiestamente real;
@iftex
Maxima s@'olo se fija en si el argumento es un m@'ultiplo literal de @math{i}.
@end iftex
@ifnottex
Maxima s@'olo se fija en si el argumento es un m@'ultiplo literal de @math{%i}.
@end ifnottex

Ejemplos:

@c ===beg===
@c %iargs : false$
@c [sin (%i * x), cos (%i * x), tan (%i * x)];
@c %iargs : true$
@c [sin (%i * x), cos (%i * x), tan (%i * x)];
@c ===end===
@example
(%i1) %iargs : false$
@group
(%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o2)           [sin(%i x), cos(%i x), tan(%i x)]
@end group
(%i3) %iargs : true$
@group
(%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o4)           [%i sinh(x), cosh(x), %i tanh(x)]
@end group
@end example

La simplificaci@'on se aplica incluso en el caso de que
el argumento se reduzca a un n@'umero real.

@c ===beg===
@c declare (x, imaginary)$
@c [featurep (x, imaginary), featurep (x, real)];
@c sin (%i * x);
@c ===end===
@example
(%i1) declare (x, imaginary)$
@group
(%i2) [featurep (x, imaginary), featurep (x, real)];
(%o2)                     [true, false]
@end group
@group
(%i3) sin (%i * x);
(%o3)                      %i sinh(x)
@end group
@end example

@end defvr





@deffn {Function} acos (@var{x})
Arco coseno.

@end deffn

@deffn {Funci@'on} acosh (@var{x})
Arco coseno hiperb@'olico.

@end deffn

@deffn {Funci@'on} acot (@var{x})
Arco cotangente.

@end deffn

@deffn {Funci@'on} acoth (@var{x})
Arco cotangente hiperb@'olica.

@end deffn

@deffn {Funci@'on} acsc (@var{x})
Arco cosecante.

@end deffn

@deffn {Funci@'on} acsch (@var{x})
Arco cosecante hiperb@'olica.

@end deffn

@deffn {Funci@'on} asec (@var{x})
Arco secante.

@end deffn

@deffn {Funci@'on} asech (@var{x})
Arco secante hiperb@'olica.

@end deffn

@deffn {Funci@'on} asin (@var{x})
Arco seno.

@end deffn

@deffn {Funci@'on} asinh (@var{x})
Arco seno hiperb@'olico.

@end deffn

@deffn {Funci@'on} atan (@var{x})
Arco tangente.

@end deffn

@deffn {Funci@'on} atan2 (@var{y}, @var{x})
Calcula el valor de @code{atan(@var{y}/@var{x})} en el intervalo de @code{-%pi} a @code{%pi}.

@end deffn

@deffn {Funci@'on} atanh (@var{x})
Arco tangente hiperb@'olica.

@end deffn

@defvr {Paquete} atrig1
El paquete @code{atrig1} contiene ciertas reglas de simplificaci@'on adicionales para las funciones trigonom@'etricas inversas. Junto con las reglas que ya conoce Maxima, los siguientes @'angulos est@'an completamente implementados:
@code{0}, @code{%pi/6}, @code{%pi/4}, @code{%pi/3} y @code{%pi/2}.  
Los @'angulos correspondientes en los otros tres cuadrantes tambi@'en est@'an disponibles.  
Para hacer uso de estas reglas, ejec@'utese @code{load(atrig1);}.

@end defvr

@deffn {Funci@'on} cos (@var{x})
Coseno.

@end deffn

@deffn {Funci@'on} cosh (@var{x})
Coseno hiperb@'olico.

@end deffn

@deffn {Funci@'on} cot (@var{x})
Cotangente.

@end deffn

@deffn {Funci@'on} coth (@var{x})
Cotangente hiperb@'olica.

@end deffn

@deffn {Funci@'on} csc (@var{x})
Cosecante.

@end deffn

@deffn {Funci@'on} csch (@var{x})
Cosecante hiperb@'olica.

@end deffn


@defvr {Variable opcional} halfangles
Valor por defecto: @code{false}

Si @code{halfangles} vale @code{true}, las funciones
trigonom@'etricas con argumentos del tipo @code{@var{expr}/2}
se simplifican a funciones con argumentos @var{expr}.

Para un argumento real @var{x} en el intervalo @code{0 < x < 2*%pi}
el seno del semi@'angulo se simplifica como

@example
                    sqrt(1 - cos(x))
                    ----------------
                        sqrt(2)
@end example

Se necesita un factor relativamente complicado para que esta f@'ormula
sea tambi@'en v@'alida para cualquier argumento complejo @var{z}:

@example
           realpart(z)
     floor(-----------)
              2 %pi
(- 1)                   (1 - unit_step(- imagpart(z))

                      realpart(z)            realpart(z)
                floor(-----------) - ceiling(-----------)
                         2 %pi                  2 %pi
          ((- 1)                                          + 1))
@end example

Maxima reconoce este factor y otros similares para las funciones @code{sin}, 
@code{cos}, @code{sinh} y @code{cosh}. Para valores especiales del argumento
@math{z}, estos factores se simplifican de forma apropiada.

Ejemplos:

@c ===beg===
@c halfangles : false$
@c sin (x / 2);
@c halfangles : true$
@c sin (x / 2);
@c assume(x>0, x<2*%pi)$
@c sin(x / 2);
@c ===end===
@example
(%i1) halfangles:false;
(%o1)                                false
(%i2) sin(x/2);
                                        x
(%o2)                               sin(-)
                                        2
(%i3) halfangles:true;
(%o3)                                true
(%i4) sin(x/2);
                                                    x
                                            floor(-----)
                                                  2 %pi
                      sqrt(1 - cos(x)) (- 1)
(%o4)                 ----------------------------------
                                   sqrt(2)
(%i5) assume(x>0, x<2*%pi)$
(%i6) sin(x/2);
                               sqrt(1 - cos(x))
(%o6)                          ----------------
                                   sqrt(2)
@end example

@end defvr


@defvr {Paquete} ntrig
El paquete @code{ntrig} contiene un conjunto de reglas de simplificaci@'on que se pueden usar para simplificar funciones trigonom@'etricas cuyos argumentos son de la forma
@code{@var{f}(@var{n} %pi/10)} donde @var{f} es cualquiera de las funciones 
@code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} o @code{cot}.
@c NEED TO LOAD THIS PACKAGE ??

@end defvr

@deffn {Funci@'on} sec (@var{x})
Secante.

@end deffn

@deffn {Funci@'on} sech (@var{x})
Secante hiperb@'olica.

@end deffn

@deffn {Funci@'on} sin (@var{x})
Seno.

@end deffn

@deffn {Funci@'on} sinh (@var{x})
Seno hiperb@'olico.

@end deffn

@deffn {Funci@'on} tan (@var{x})
Tangente.

@end deffn

@deffn {Funci@'on} tanh (@var{x})
Tangente hiperb@'olica.

@end deffn

@deffn {Funci@'on} trigexpand (@var{expr})
Expande funciones trigonom@'etricas e hiperb@'olicas de sumas de @'angulos y de m@'ultiplos de @'angulos presentes en @var{expr}.  Para mejorar los resultados, @var{expr} deber@'{@dotless{i}}a expandirse. Para facilitar el control por parte del usuario de las simplificaciones, esta funci@'on tan solo expande un nivel de cada vez, expandiendo sumas de @'angulos o de m@'ultiplos de @'angulos. A fin de obtener una expansi@'on completa en senos y coseno, se le dar@'a a la variable @code{trigexpand} el valor @code{true}.

La funci@'on @code{trigexpand} est@'a controlada por las siguientes variables:

@table @code
@item trigexpand
Si vale @code{true}, provoca la expansi@'on de todas las expresiones que contengan senos y cosenos.
@item trigexpandplus
Controla la regla de la suma para @code{trigexpand}, la expansi@'on de una suma como @code{sin(x + y)} se llevar@'a a cabo s@'olo si @code{trigexpandplus} vale @code{true}.
@item trigexpandtimes
Controla la regla del producto para @code{trigexpand}, la expansi@'on de un producto como @code{sin(2 x)} se llevar@'a a cabo s@'olo si @code{trigexpandtimes} vale @code{true}.
@end table

Ejemplos:

@c ===beg===
@c x+sin(3*x)/sin(x),trigexpand=true,expand;
@c trigexpand(sin(10*x+y));
@c ===end===
@example
@group
(%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                         2           2
(%o1)               - sin (x) + 3 cos (x) + x
@end group
@group
(%i2) trigexpand(sin(10*x+y));
(%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)
@end group
@end example

@end deffn

@defvr {Variable optativa} trigexpandplus
Valor por defecto: @code{true}

La variable @code{trigexpandplus} controla la regla de la suma para @code{trigexpand}.  As@'{@dotless{i}}, si la instrucci@'on @code{trigexpand} se utiliza o si la variable @code{trigexpand} vale @code{true}, se realizar@'a la expansi@'on de sumas como @code{sin(x+y)} s@'olo si @code{trigexpandplus} vale @code{true}.

@end defvr

@defvr {Variable optativa} trigexpandtimes
Valor por defecto: @code{true}

La variable @code{trigexpandtimes} controla la regla del producto para @code{trigexpand}.  As@'{@dotless{i}}, si la instrucci@'on @code{trigexpand} se utiliza o si la variable @code{trigexpand} vale @code{true}, se realizar@'a la expansi@'on de productos como @code{sin(2*x)} s@'olo si @code{trigexpandtimes} vale @code{true}.

@end defvr

@defvr {Variable optativa} triginverses
Valor por defecto: @code{true}

La variable @code{triginverses} controla la simplificaci@'on de la composici@'on de funciones trigonom@'etricas e hiperb@'olicas con sus funciones inversas.

Si vale @code{all}, tanto @code{atan(tan(@var{x}))}  como @code{tan(atan(@var{x}))} se reducen a @var{x}.  

Si vale @code{true}, se desactiva la simplificaci@'on de @code{@var{arcfun}(@var{fun}(@var{x}))}.

Si vale @code{false}, se desactivan las simplificaciones de 
@code{@var{arcfun}(@var{fun}(@var{x}))} y 
@code{@var{fun}(@var{arcfun}(@var{x}))}.

@end defvr

@deffn {Funci@'on} trigreduce (@var{expr}, @var{x})
@deffnx {Funci@'on} trigreduce (@var{expr})
Combina productos y potencias de senos y cosenos trigonom@'etricos e hiperb@'olicos de @var{x}, transform@'andolos en otros que son m@'ultiplos de @var{x}.  Tambi@'en intenta eliminar estas funciones cuando aparecen en los denominadores.  Si no se introduce el argumento @var{x}, entonces se utilizan todas las variables de @var{expr}.

V@'ease tambi@'en @code{poissimp}.

@c ===beg===
@c trigreduce(-sin(x)^2+3*cos(x)^2+x);
@c ===end===
@example
@group
(%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
               cos(2 x)      cos(2 x)   1        1
(%o1)          -------- + 3 (-------- + -) + x - -
                  2             2       2        2
@end group
@end example


Las rutinas de simplificaci@'on trigonom@'etrica utilizan informaci@'on declarada en algunos casos sencillos. Las declaraciones sobre variables se utilizan como se indica a continuaci@'on:

@c ===beg===
@c declare(j, integer, e, even, o, odd)$
@c sin(x + (e + 1/2)*%pi);
@c sin(x + (o + 1/2)*%pi);
@c ===end===
@example
(%i1) declare(j, integer, e, even, o, odd)$
(%i2) sin(x + (e + 1/2)*%pi);
(%o2)                        cos(x)
(%i3) sin(x + (o + 1/2)*%pi);
(%o3)                       - cos(x)

@end example

@end deffn

@defvr {Variable optativa} trigsign
Valor por defecto: @code{true}

Si @code{trigsign} vale @code{true}, se permite la simplificaci@'on de argumentos negativos en funciones trigonom@'etricas, como en @code{sin(-x)}, que se transformar@'a en @code{-sin(x)} s@'olo si @code{trigsign} vale @code{true}.

@end defvr

@deffn {Funci@'on} trigsimp (@var{expr})
@iftex
Utiliza las identidades
@tex
$\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@end tex
y
@tex
$\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@end tex
para simplificar expresiones que contienen @code{tan}, @code{sec},
etc., en expresiones con @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@end iftex
@ifnottex
Utiliza las identidades @math{sin(x)^2 + cos(x)^2 = 1} y
@math{cosh(x)^2 - sinh(x)^2 = 1} para simplificar expresiones que contienen @code{tan}, @code{sec},
etc., en expresiones con @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@end ifnottex

Las funciones @code{trigreduce}, @code{ratsimp} y @code{radcan} puden seguir siendo @'utiles para continuar el proceso de simplificaci@'on.

La instrucci@'on @code{demo ("trgsmp.dem")} muestra algunos ejemplos de @code{trigsimp}.
@c MERGE EXAMPLES INTO THIS ITEM

@end deffn

@deffn {Funci@'on} trigrat (@var{expr})
Devuelve una forma can@'onica simplificada cuasi-lineal de una expresi@'on trigonom@'etrica;
@var{expr} es una fracci@'on racional que contiene @code{sin}, @code{cos} o @code{tan}, 
cuyos argumentos son formas lineales respecto de ciertas variables (o kernels) y @code{%pi/@var{n}}
(@var{n} entero) con coeficientes enteros. El resultado es una fracci@'on simplificada con 
el numerador y denominador lineales respecto de @code{sin} y @code{cos}. As@'{@dotless{i}},
 @code{trigrat} devuelve una expresi@'on lineal siempre que sea posible.

@c ===beg===
@c trigrat(sin(3*a)/sin(a+%pi/3));
@c ===end===
@example
@group
(%i1) trigrat(sin(3*a)/sin(a+%pi/3));
(%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1
@end group
@end example

El siguiente ejemplo se ha tomado de
Davenport, Siret y Tournier, @i{Calcul Formel}, Masson (o en ingl@'es,
Addison-Wesley), secci@'on 1.5.5, teorema de Morley.

@c ===beg===
@c c : %pi/3 - a - b$
@c bc : sin(a)*sin(3*c)/sin(a+b);
@c ba : bc, c=a, a=c;
@c ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
@c trigrat (ac2);
@c ===end===
@example
(%i1) c : %pi/3 - a - b$
@group
(%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                          %pi
                  sin(a) sin(3 (- b - a + ---))
                                           3
(%o2)             -----------------------------
                           sin(b + a)
@end group
@group
(%i3) ba : bc, c=a, a=c;
                                         %pi
                    sin(3 a) sin(b + a - ---)
                                          3
(%o3)               -------------------------
                                  %pi
                          sin(a - ---)
                                   3
@end group
@group
(%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
         2         2         %pi
      sin (3 a) sin (b + a - ---)
                              3
(%o4) ---------------------------
                2     %pi
             sin (a - ---)
                       3
                                       %pi
 - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                        3
             %pi            %pi
 sin(b + a - ---))/(sin(a - ---) sin(b + a))
              3              3
      2       2              %pi
   sin (a) sin (3 (- b - a + ---))
                              3
 + -------------------------------
                2
             sin (b + a)
@end group
@group
(%i5) trigrat (ac2);
(%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
 - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
 - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
 + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
 + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
 + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
 - 9)/4
@end group
@end example

@end deffn








@node N@'umeros aleatorios, , Funciones trigonom@'etricas, Funciones matem@'aticas
@section N@'umeros aleatorios



@deffn {Funci@'on} make_random_state (@var{n})
@deffnx {Funci@'on} make_random_state (@var{s})
@deffnx {Funci@'on} make_random_state (true)
@deffnx {Funci@'on} make_random_state (false)

Un objeto de estado aleatorio representa el estado del generador de n@'umeros aleatorios. El estado consiste en 627 cadenas binarias de 32 bits.

La llamada @code{make_random_state (@var{n})} devuelve un nuevo objeto de estado aleatorio creado a partir de una semilla entera igual a @var{n} m@'odulo 2^32. El argumento @var{n} puede ser negativo.

La llamada @code{make_random_state (@var{s})} devuelve una copia del estado aleatorio @var{s}.

La llamada @code{make_random_state (true)} devuelve un nuevo objeto de estado aleatorio, cuya semilla se genera a partir de la hora actual del reloj del sistema como semilla.

La llamada @code{make_random_state (false)} devuelve una copia del estado actual del generador de n@'umeros aleatorios.

@end deffn



@deffn {Funci@'on} set_random_state (@var{s})
Establece @var{s} como estado del generador de n@'umeros aleatorios.

La funci@'on @code{set_random_state} devuelve @code{done} en todo caso.

@end deffn



@deffn {Funci@'on} random (@var{x})
Devuelve un n@'umero seudoaleatorio. Si @var{x} es un entero, @code{random (@var{x})} devuelve un
entero entre 0 y @code{@var{x} - 1}, ambos inclusive. Si @var{x} es un decimal en punto flotante,
@code{random (@var{x})} devuelve un decimal no negativo en punto flotante menor que @var{x}.
La funci@'on @code{random} emite un mensaje de error si @var{x} no es ni entero ni de punto flotante,
o si @var{x} no es positivo.

Las funciones @code{make_random_state} y @code{set_random_state}
permiten controlar el estado del generador de n@'umeros aleatorios.

El generador de n@'umeros aleatorios de Maxima implementa el algoritmo de Mersenne twister MT 19937.

Ejemplos:

@c ===beg===
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c ===end===
@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn




@c FALTA DEFINICION DE exptisolate

