This is maxima.info, produced by makeinfo version 5.1 from maxima.texi.


File: maxima.info,  Node: Funciones y variables para contrib_ode,  Next: Posibles mejoras a contrib_ode,  Prev: Introducción a contrib_ode,  Up: contrib_ode

43.2 Funciones y variables para contrib_ode
===========================================

 -- Función: contrib_ode (<eqn>, <y>, <x>)

     Devuelve la lista de soluciones de la ecuación diferencia ordinaria
     (EDO) <eqn> de variable independiente <x> y variable dependiente
     <y>.

 -- Función: odelin (<eqn>, <y>, <x>)

     La función ‘odelin’ resulve EDOs homogéneas lineales de primer y
     segundo orden con variable independiente <x> y variable dependiente
     <y>.  Devuelve un conjunto fundamental de soluciones de la EDO.

     Para EDOs de segundo orden, ‘odelin’ utiliza un método desarrollado
     por Bronstein y Lafaille, que busca las soluciones en términos de
     funciones especiales dadas.

          (%i1) load("contrib_ode");

          (%i2) odelin(x*(x+1)*'diff(y,x,2)+(x+5)*'diff(y,x,1)+(-4)*y,y,x);
          ...trying factor method
          ...solving 7 equations in 4 variables
          ...trying the Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the F01 solver
          ...solving 1 equations in 3 variables
          ...trying the spherodial wave solver
          ...solving 1 equations in 4 variables
          ...trying the square root Bessel solver
          ...solving 1 equations in 2 variables
          ...trying the 2F1 solver
          ...solving 9 equations in 5 variables
                 gauss_a(- 6, - 2, - 3, - x)  gauss_b(- 6, - 2, - 3, - x)
          (%o2) {---------------------------, ---------------------------}
                              4                            4
                             x                            x

 -- Función: ode_check (<eqn>, <soln>)

     Devuelve el valor de la ecuación diferencia ordinaria (EDO) <eqn>
     después de sustituir una posible solución <soln>.  El valor es cero
     si <soln> es una solución de <eqn>.

          (%i1) load("contrib_ode")$

          (%i2) eqn:'diff(y,x,2)+(a*x+b)*y;

                                   2
                                  d y
          (%o2)                   --- + (a x + b) y
                                    2
                                  dx
          (%i3) ans:[y = bessel_y(1/3,2*(a*x+b)^(3/2)/(3*a))*%k2*sqrt(a*x+b)
                   +bessel_j(1/3,2*(a*x+b)^(3/2)/(3*a))*%k1*sqrt(a*x+b)];

                                            3/2
                              1  2 (a x + b)
          (%o3) [y = bessel_y(-, --------------) %k2 sqrt(a x + b)
                              3       3 a
                                                    3/2
                                      1  2 (a x + b)
                           + bessel_j(-, --------------) %k1 sqrt(a x + b)]
                                      3       3 a
          (%i4) ode_check(eqn,ans[1]);

          (%o4)                           0

 -- Variable opcional: ‘method’

     A la variable ‘method’ se le asigna el método aplicado.

 -- Variable: ‘%c’

     ‘%c’ es la constante de integración para EDOs de primer orden.

 -- Variable: ‘%k1’

     ‘%k1’ es la primera constante de integración para EDOs de segundo
     orden.

 -- Variable: ‘%k2’

     ‘%k2’ es la segunda constante de integración para EDOs de segundo
     orden.

 -- Función: gauss_a (<a>, <b>, <c>, <x>)

     ‘gauss_a(a,b,c,x)’ y ‘gauss_b(a,b,c,x)’ son funciones geométricas
     2F1 .  Representan dos soluciones independientes cualesquiera de la
     ecuación diferencial hipergeométrica ‘x(1-x) diff(y,x,2) +
     [c-(a+b+1)x] diff(y,x) - aby = 0’ (A&S 15.5.1).

     El único uso que se hace de estas funciones es en las soluciones de
     EDOs que devuelven ‘odelin’ y ‘contrib_ode’.  La definición y
     utilización de estas funciones puede cambiar en futuras
     distribuciones de Maxima.

     Véanse también ‘gauss_b’, ‘dgauss_a’ y ‘gauss_b’.

 -- Función: gauss_b (<a>, <b>, <c>, <x>)
     Véase también ‘gauss_a’.

 -- Función: dgauss_a (<a>, <b>, <c>, <x>)
     The derivative with respect to x of ‘gauss_a(a,b,c,x)’.

 -- Función: dgauss_b (<a>, <b>, <c>, <x>)
     Derivada de ‘gauss_b(<a>,<b>,<c>,<x>)’ respecto de <x>.

 -- Función: kummer_m (<a>, <b>, <x>)

     Función M de Kummer, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 13.1.2.

     El único uso que se hace de esta función es en las soluciones de
     EDOs que devuelven ‘odelin’ y ‘contrib_ode’.  La definición y
     utilización de estas funciones puede cambiar en futuras
     distribuciones de Maxima.

     Véanse también ‘kummer_u’, ‘dkummer_m’ y ‘dkummer_u’.

 -- Función: kummer_u (<a>, <b>, <x>)

     Función U de Kummer, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 13.1.3.

     Véase también ‘kummer_m’.

 -- Función: dkummer_m (<a>, <b>, <x>)
     Derivada de ‘kummer_m(<a>,<b>,<x>)’ respecto de <x>.

 -- Función: dkummer_u (<a>, <b>, <x>)
     Derivada de ‘kummer_u(<a>,<b>,<x>)’ respecto de <x>.


File: maxima.info,  Node: Posibles mejoras a contrib_ode,  Next: Pruebas realizadas con contrib_ode,  Prev: Funciones y variables para contrib_ode,  Up: contrib_ode

43.3 Posibles mejoras a contrib_ode
===================================

Este paquete aún se encuentra en fase de desarrollo.  Aspectos
pendientes:

   • Extender el método FACTOR ‘ode1_factor’ para que trabaje con raíces
     múltiples.

   • Extender el método FACTOR ‘ode1_factor’ para que intente resolver
     factores de orden superior.  En este momento sólo intenta resolver
     factores lineales.

   • Modificar la rutina LAGRANGE ‘ode1_lagrange’ para que prefiera
     raíces reales a las complejas.

   • Añadir más métodos para las ecuaciones de RIccati.

   • Mejorar la identificación de las ecuaciones de Abel de segunda
     especie.  El procedimiento actual no es muy bueno.

   • Trabajar la rutina del grupo simétrico de Lie ‘ode1_lie’.  Existen
     algunos problemas: algunas partes no están implementadas, algunos
     ejemplos no terminan de ejecutarse, otros producen errors, otros
     devuelven respuestas muy complejas.

   • Hacer más pruebas.


File: maxima.info,  Node: Pruebas realizadas con contrib_ode,  Next: Referencias para contrib_ode,  Prev: Posibles mejoras a contrib_ode,  Up: contrib_ode

43.4 Pruebas realizadas con contrib_ode
=======================================

Los procedimientos fueron probados con cerca de mil ecuaciones tomadas
de Murphy, Kamke, Zwillinger y otros.  Éstas se encuentran en el
directorio de pruebas.

   • La rutina de Clairault ‘ode1_clairault’ encuentra todas las
     soluciones conocidas, incluídas las singulares, de las ecuaciones
     de Clairault en Murphy y Kamke.

   • Las otras rutinas a veces devuelven una sola solución cuando
     existen más.

   • Algunas de las soluciones devueltas por ‘ode1_lie’ son demasiado
     complejas e imposibles de interpretar.

   • A veces se producen detenciones imprevistas del procedimiento.


File: maxima.info,  Node: Referencias para contrib_ode,  Prev: Pruebas realizadas con contrib_ode,  Up: contrib_ode

43.5 Referencias para contrib_ode
=================================

  1. E. Kamke, Differentialgleichungen Losungsmethoden und Losungen, Vol
     1, Geest & Portig, Leipzig, 1961

  2. G. M. Murphy, Ordinary Differential Equations and Their Solutions,
     Van Nostrand, New York, 1960

  3. D. Zwillinger, Handbook of Differential Equations, 3rd edition,
     Academic Press, 1998

  4. F. Schwarz, Symmetry Analysis of Abel’s Equation, Studies in
     Applied Mathematics, 100:269-294 (1998)

  5. F. Schwarz, Algorithmic Solution of Abel’s Equation, Computing 61,
     39-49 (1998)

  6. E. S. Cheb-Terrab, A. D. Roche, Symmetries and First Order ODE
     Patterns, Computer Physics Communications 113 (1998), p 239.
     (<http://lie.uwaterloo.ca/papers/ode_vii.pdf>)

  7. E. S. Cheb-Terrab, T. Kolokolnikov, First Order ODEs, Symmetries
     and Linear Transformations, European Journal of Applied
     Mathematics, Vol.  14, No.  2, pp.  231-246 (2003).
     (<http://arxiv.org/abs/math-ph/0007023>,
     <http://lie.uwaterloo.ca/papers/ode_iv.pdf>)

  8. G. W. Bluman, S. C. Anco, Symmetry and Integration Methods for
     Differential Equations, Springer, (2002)

  9. M Bronstein, S Lafaille, Solutions of linear ordinary differential
     equations in terms of special functions, Proceedings of ISSAC 2002,
     Lille, ACM Press, 23-28.
     (<http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/issac2002.pdf>)


File: maxima.info,  Node: descriptive,  Next: diag,  Prev: contrib_ode,  Up: Top

44 descriptive
**************

* Menu:

* Introducción a descriptive::
* Funciones y variables para el tratamiento de datos::
* Funciones y variables de parámetros descriptivos::
* Funciones y variables para gráficos estadísticos::


File: maxima.info,  Node: Introducción a descriptive,  Next: Funciones y variables para el tratamiento de datos,  Prev: descriptive,  Up: descriptive

44.1 Introducción a descriptive
===============================

El paquete ‘descriptive’ contiene funciones para realizar cĺculos y
gráficos estadísticos descriptivos.  Junto con el código fuente se
distribuyen tres conjuntos de datos: ‘pidigits.data’, ‘wind.data’ y
‘biomed.data’.

Cualquier manual de estadística se puede utilizar como referencia al
paquete ‘descriptive’.

Para comentarios, fallos y sugerencias, por favor contactar con
<’riotorto AT yahoo DOT com’>.

Aquí un sencillo ejemplo sobre cómo operan las funciones de
‘descriptive’, dependiendo de la naturaleza de sus argumentos, listas o
matrices,

     (%i1) load ("descriptive")$
     (%i2) /* muestra univariate */   mean ([a, b, c]);
                                 c + b + a
     (%o2)                       ---------
                                     3
     (%i3) matrix ([a, b], [c, d], [e, f]);
                                 [ a  b ]
                                 [      ]
     (%o3)                       [ c  d ]
                                 [      ]
                                 [ e  f ]
     (%i4) /* muestra multivariante */ mean (%);
                           e + c + a  f + d + b
     (%o4)                [---------, ---------]
                               3          3

Nótese que en las muestras multivariantes la media se calcula para cada
columna.

En caso de varias muestras de diferente tamaño, la función ‘map’ de
Maxima puede utilizarse para obtener los resultados deseados para cada
muestra,

     (%i1) load ("descriptive")$
     (%i2) map (mean, [[a, b, c], [d, e]]);
                             c + b + a  e + d
     (%o2)                  [---------, -----]
                                 3        2

En este caso, dos muestras de tamaños 3 y 2 han sido almacenadas en una
lista.

Muestras univariantes deben guardarse en listas como en

     (%i1) s1 : [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
     (%o1)           [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

y muestras multivariantes en matrices como las del siguiente ejemplo

     (%i1) s2 : matrix ([13.17, 9.29], [14.71, 16.88], [18.50, 16.88],
                  [10.58, 6.63], [13.33, 13.25], [13.21,  8.12]);
                             [ 13.17  9.29  ]
                             [              ]
                             [ 14.71  16.88 ]
                             [              ]
                             [ 18.5   16.88 ]
     (%o1)                   [              ]
                             [ 10.58  6.63  ]
                             [              ]
                             [ 13.33  13.25 ]
                             [              ]
                             [ 13.21  8.12  ]

En este caso, el número de columnas es igual al de la dimensión de la
variable aleatoria y el número de filas coincide con el tamaño muestral.

Los datos pueden suministrarse manualmente, pero las muestras grandes se
suelen almacenar en ficheros de texto.  Por ejemplo, el fichero
‘pidigits.data’ contiene los 100 primeros dígitos del número ‘%pi’:
           3
           1
           4
           1
           5
           9
           2
           6
           5
           3 ...

A fin de leer estos dígitos desde Maxima,

     (%i1) s1 : read_list (file_search ("pidigits.data"))$
     (%i2) length (s1);
     (%o2)                          100

Por otro lado, el archivo ‘wind.data’ contiene los promedios diarios de
la velocidad del viento en cinco estaciones meteorológicas en Irlanda
(esta muestra es parte de un conjunto de datos correspondientes a 12
estaciones meteorológicas.  El fichero original se puede descargar
libremente del ’StatLib Data Repository’ y se analiza en Haslett, J.,
Raftery, A. E. (1989) <Space-time Modelling with Long-memory Dependence:
Assessing Ireland’s Wind Power Resource, with Discussion>.  Applied
Statistics 38, 1-50).  Así se leen los datos:

     (%i1) s2 : read_matrix (file_search ("wind.data"))$
     (%i2) length (s2);
     (%o2)                          100
     (%i3) s2 [%]; /* last record */
     (%o3)            [3.58, 6.0, 4.58, 7.62, 11.25]

Algunas muestras contienen datos no numéricos.  Como ejemplo, el archivo
‘biomed.data’ (el cual es parte de otro mayor descargado también del
’StatLib Data Repository’) contiene cuatro mediciones sanguíneas tomadas
a dos grupos de pacientes, ‘A’ y ‘B’, de diferentes edades,

     (%i1) s3 : read_matrix (file_search ("biomed.data"))$
     (%i2) length (s3);
     (%o2)                          100
     (%i3) s3 [1]; /* first record */
     (%o3)            [A, 30, 167.0, 89.0, 25.6, 364]

El primer individuo pertenece al grupo ‘A’, tiene 30 años de edad y sus
medidas sanguíneas fueron 167.0, 89.0, 25.6 y 364.

Debe tenerse cuidado cuando se trabaje con datos categóricos.  En el
siguiente ejemplo, se asigna al símbolo ‘a’ cierto valor en algún
momento previo y luego se toma una muestra con el valor categórico ‘a’,

     (%i1) a : 1$
     (%i2) matrix ([a, 3], [b, 5]);
                                 [ 1  3 ]
     (%o2)                       [      ]
                                 [ b  5 ]


File: maxima.info,  Node: Funciones y variables para el tratamiento de datos,  Next: Funciones y variables de parámetros descriptivos,  Prev: Introducción a descriptive,  Up: descriptive

44.2 Funciones y variables para el tratamiento de datos
=======================================================

 -- Función: build_sample (<list>)
 -- Función: build_sample (<matrix>)
     Construye una muestra a partir de una tabla de frecuencias
     absolutas.  La tabla de entrada puede ser una una matriz o una
     lista de listas, todas ellas de igual tamaño.  El número de
     columnas o la longitud de las listas debe ser mayor que la unidad.
     El último elemento de cada fila o lista se interpreta como la
     frecuencia absoluta.  El resultado se devuelve siempre en formato
     de matriz.

     Ejemplos:

     Tabla de frecuencias univariante.

          (%i1) load ("descriptive")$
          (%i2) sam1: build_sample([[6,1], [j,2], [2,1]]);
                                 [ 6 ]
                                 [   ]
                                 [ j ]
          (%o2)                  [   ]
                                 [ j ]
                                 [   ]
                                 [ 2 ]
          (%i3) mean(sam1);
                                2 j + 8
          (%o3)                [-------]
                                   4
          (%i4) barsplot(sam1) $

     Tabla de frecuencias multivariante.

          (%i1) load ("descriptive")$
          (%i2) sam2: build_sample([[6,3,1], [5,6,2], [u,2,1],[6,8,2]]) ;
                                     [ 6  3 ]
                                     [      ]
                                     [ 5  6 ]
                                     [      ]
                                     [ 5  6 ]
          (%o2)                      [      ]
                                     [ u  2 ]
                                     [      ]
                                     [ 6  8 ]
                                     [      ]
                                     [ 6  8 ]
          (%i3) cov(sam2);
                 [   2                 2                            ]
                 [  u  + 158   (u + 28)     2 u + 174   11 (u + 28) ]
                 [  -------- - ---------    --------- - ----------- ]
          (%o3)  [     6          36            6           12      ]
                 [                                                  ]
                 [ 2 u + 174   11 (u + 28)            21            ]
                 [ --------- - -----------            --            ]
                 [     6           12                 4             ]
          (%i4) barsplot(sam2, grouping=stacked) $

 -- Función: continuous_freq (<list>)
 -- Función: continuous_freq (<list>, <m>)
     El argumento de ‘continuous_freq’ debe ser una lista de números.
     Divide el rango en intervalos y cuenta cuántos valores hay en
     ellos.  El segundo argumento es opcional y puede ser el número de
     clases deseado, 10 por defecto, o una lista que contenga los
     límites de las clases y el número de éstas, o una lista que
     contenga únicamente los límites.  Si los valores muestrales son
     todos iguales, esta función devuelve solamente una clase de
     amplitud 2.

     Ejemplos:

     El argumento opcional indica el número de clases deseadas.  La
     primera lista de la respuesta contiene los límites de los
     intervalos y la segunda los totales correspondientes: hay 16
     dígitos en el intervalo ‘[0, 1.8]’, 24 en ‘(1.8, 3.6]’ y así
     sucesivamente.

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, 5);
          (%o3) [[0, 1.8, 3.6, 5.4, 7.2, 9.0], [16, 24, 18, 17, 25]]

     El argumento opcional indica que queremos 7 clases con límites -2 y
     12:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12,7]);
          (%o3) [[- 2, 0, 2, 4, 6, 8, 10, 12], [8, 20, 22, 17, 20, 13, 0]]

     El argumento opcional indica que queremos el número por defecto de
     clases y límites -2 y 12:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) continuous_freq (s1, [-2,12]);
                          3  4  11  18     32  39  46  53
          (%o3)  [[- 2, - -, -, --, --, 5, --, --, --, --, 12],
                          5  5  5   5      5   5   5   5
                         [0, 8, 20, 12, 18, 9, 8, 25, 0, 0]]

 -- Función: discrete_freq (<list>)
     Calcula las frecuencias absolutas en muestras discretas, tanto
     numéricas como categóricas.  Su único argumento debe ser una lista.

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) discrete_freq (s1);
          (%o3) [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                                       [8, 8, 12, 12, 10, 8, 9, 8, 12, 13]]

     La primera lista son los valores de la muestra y la segunda sus
     frecuencias absolutas.  Las instrucciones ‘? col’ y ‘? transpose’
     pueden ayudar a comprender la última entrada.

 -- Función: standardize (<list>)
 -- Función: standardize (<matrix>)

     Resta a cada elemento de la lista la media muestral y luego divide
     el resultado por la desviación típica.  Si la entrada es una
     matriz, ‘standardize’ resta a cada fila la media multivariante y
     luego divide cada componente por la desviación típica
     correspondiente.

 -- Función: subsample (<data_matrix>, <predicate_function>)
 -- Función: subsample (<data_matrix>, <predicate_function>, <col_num>,
          <col_num>, ...)
     Esta es una variante de la función ‘submatrix’ de Maxima.  El
     primer argumento es una matriz de datos, el segundo es una función
     de predicado y el resto de argumentos opcionales son los números de
     las columnas a tomar en consideración.

     Estos son los registros multivariantes en los que la velocidad del
     viento en la primera estación meteorológica fue menor de 18 nudos.
     Véase cómo en la expresión lambda la <i>-ésima componente se la
     referencia como ‘v[i]’.
          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) subsample (s2, lambda([v], v[1] > 18));
                        [ 19.38  15.37  15.12  23.09  25.25 ]
                        [                                   ]
                        [ 18.29  18.66  19.08  26.08  27.63 ]
          (%o3)         [                                   ]
                        [ 20.25  21.46  19.95  27.71  23.38 ]
                        [                                   ]
                        [ 18.79  18.96  14.46  26.38  21.84 ]

     En el siguiente ejemplo, se solicitan únicamente la primera,
     segunda y quinta componentes de aquellos registros con velocidades
     del viento mayores o iguales que 16 nudos en la estación número 1 y
     menores que 25 nudos en la estación número 4.  La muestra sólo
     contiene los datos referidos a las estaciones 1, 2 y 5.  En este
     caso, la función de predicado se define por medio de una función de
     Maxima ordinaria.
          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) g(x):= x[1] >= 16 and x[4] < 25$
          (%i4) subsample (s2, g, 1, 2, 5);
                               [ 19.38  15.37  25.25 ]
                               [                     ]
                               [ 17.33  14.67  19.58 ]
          (%o4)                [                     ]
                               [ 16.92  13.21  21.21 ]
                               [                     ]
                               [ 17.25  18.46  23.87 ]

     He aquí un ejemplo con las variables categóricas de ‘biomed.data’.
     Se piden los registros correspondientes a aquellos pacientes del
     grupo ‘B’ mayores de 38 anños,
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) h(u):= u[1] = B and u[2] > 38 $
          (%i4) subsample (s3, h);
                          [ B  39  28.0  102.3  17.1  146 ]
                          [                               ]
                          [ B  39  21.0  92.4   10.3  197 ]
                          [                               ]
                          [ B  39  23.0  111.5  10.0  133 ]
                          [                               ]
                          [ B  39  26.0  92.6   12.3  196 ]
          (%o4)           [                               ]
                          [ B  39  25.0  98.7   10.0  174 ]
                          [                               ]
                          [ B  39  21.0  93.2   5.9   181 ]
                          [                               ]
                          [ B  39  18.0  95.0   11.3  66  ]
                          [                               ]
                          [ B  39  39.0  88.5   7.6   168 ]

     Es probable que el análisis estadístico requiera únicamente de las
     medidas sanguíneas.
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) subsample (s3, lambda([v], v[1] = B and v[2] > 38),
                     3, 4, 5, 6);
                             [ 28.0  102.3  17.1  146 ]
                             [                        ]
                             [ 21.0  92.4   10.3  197 ]
                             [                        ]
                             [ 23.0  111.5  10.0  133 ]
                             [                        ]
                             [ 26.0  92.6   12.3  196 ]
          (%o3)              [                        ]
                             [ 25.0  98.7   10.0  174 ]
                             [                        ]
                             [ 21.0  93.2   5.9   181 ]
                             [                        ]
                             [ 18.0  95.0   11.3  66  ]
                             [                        ]
                             [ 39.0  88.5   7.6   168 ]

     Esta es la media multivariante de ‘s3’.
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) mean (s3);
                 65 B + 35 A  317          6 NA + 8145.0
          (%o3) [-----------, ---, 87.178, -------------, 18.123,
                     100      10                100
                                                              3 NA + 19587
                                                              ------------]
                                                                  100

     Aquí la primera componente carece de significado, ya que tanto ‘A’
     como ‘B’ son categóricas, la segunda componente es la edad media de
     los individuos en forma racional, al tiempo que los valores cuarto
     y quinto muestran cierto comportamiento extraño; lo cual se debe a
     que el símbolo ‘NA’ se utiliza para indicar datos no disponibles,
     por lo que ambas medias no tienen sentido.  Una posible solución
     puede ser extraer de la matriz aquellas filas con símbolos ‘NA’, lo
     que acarrearía cierta pérdida de información.
          (%i1) load ("descriptive")$
          (%i2) s3 : read_matrix (file_search ("biomed.data"))$
          (%i3) g(v):= v[4] # NA and v[6] # NA $
          (%i4) mean (subsample (s3, g, 3, 4, 5, 6));
          (%o4) [79.4923076923077, 86.2032967032967, 16.93186813186813,
                                                                      2514
                                                                      ----]
                                                                       13

 -- Función: transform_sample (<matriz>, <varlist>, <exprlist>)

     Transforma la <matriz> de datos, en la que a cada columna se le
     asigna un nombre de acuerdo con la lista <varlist>, según las
     expresiones de <exprlist>.

     Ejemplos:

     El segundo argumento asigna nombres a las tres columnas, con ellos
     la lista de expresiones define la transformación de la muestra.

          (%i1) load ("descriptive")$
          (%i2) data: matrix([3,2,7],[3,7,2],[8,2,4],[5,2,4]) $
          (%i3) transform_sample(data, [a,b,c], [c, a*b, log(a)]);
                                         [ 7  6   log(3) ]
                                         [               ]
                                         [ 2  21  log(3) ]
          (%o3)                          [               ]
                                         [ 4  16  log(8) ]
                                         [               ]
                                         [ 4  10  log(5) ]

     Añade una columna constante y elimina la tercera variable.

          (%i1) load ("descriptive")$
          (%i2) data: matrix([3,2,7],[3,7,2],[8,2,4],[5,2,4]) $
          (%i3) transform_sample(data, [a,b,c], [makelist(1,k,length(data)),a,b]);
                                            [ 1  3  2 ]
                                            [         ]
                                            [ 1  3  7 ]
          (%o3)                             [         ]
                                            [ 1  8  2 ]
                                            [         ]
                                            [ 1  5  2 ]


File: maxima.info,  Node: Funciones y variables de parámetros descriptivos,  Next: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables para el tratamiento de datos,  Up: descriptive

44.3 Funciones y variables de parámetros descriptivos
=====================================================

 -- Función: mean (<list>)
 -- Función: mean (<matrix>)
     Es la media muestral, definida como
                                 n
                               ====
                       _   1   \
                       x = -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean (s1);
                                         471
          (%o3)                          ---
                                         100
          (%i4) %, numer;
          (%o4)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%i6) mean (s2);
          (%o6)     [9.9485, 10.1607, 10.8685, 15.7166, 14.8441]

 -- Función: var (<list>)
 -- Función: var (<matrix>)
     Es la varianza muestral, definida como
                               n
                             ====
                     2   1   \          _ 2
                    s  = -    >    (x - x)
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var (s1), numer;
          (%o3)                   8.425899999999999

     Véase también ‘var1’.

 -- Función: var1 (<list>)
 -- Función: var1 (<matrix>)
     Es la cuasivarianza muestral, definida como
                               n
                             ====
                         1   \          _ 2
                        ---   >    (x - x)
                        n-1  /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) var1 (s1), numer;
          (%o3)                    8.5110101010101
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) var1 (s2);
          (%o5) [17.39586540404041, 15.13912778787879, 15.63204924242424,
                                      32.50152569696971, 24.66977392929294]

     Véase también ‘var’.

 -- Función: std (<list>)
 -- Función: std (<matrix>)
     Es la desviación típica muestral, raíz cuadrada de ‘var’.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std (s1), numer;
          (%o3)                   2.902740084816414
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std (s2);
          (%o5) [4.149928523480858, 3.871399812729241, 3.933920277534866,
                                      5.672434260526957, 4.941970881136392]

     Véanse también ‘var’ y ‘std1’.

 -- Función: std1 (<list>)
 -- Función: std1 (<matrix>)
     Es la cuasidesviación típica muestral, raíz cuadrada de ‘var1’.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) std1 (s1), numer;
          (%o3)                   2.917363553109228
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) std1 (s2);
          (%o5) [4.17083509672109, 3.89090320978032, 3.953738641137555,
                                      5.701010936401517, 4.966867617451963]

     Véanse también ‘var1’ y ‘std’.

 -- Función: noncentral_moment (<list>, <k>)
 -- Función: noncentral_moment (<matrix>, <k>)
     Es el momento no central de orden k, definido como
                                 n
                               ====
                           1   \      k
                           -    >    x
                           n   /      i
                               ====
                               i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) noncentral_moment (s1, 1), numer; /* the mean */
          (%o3)                         4.71
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%o5) [319793.8724761506, 320532.1923892463, 391249.5621381556,
                                      2502278.205988911, 1691881.797742255]
          (%i6) noncentral_moment (s2, 5);

     Véase también ‘central_moment’.

 -- Función: central_moment (<list>, <k>)
 -- Función: central_moment (<matrix>, <k>)
     Es el momento central de orden k, definido como
                              n
                            ====
                        1   \          _ k
                        -    >    (x - x)
                        n   /       i
                            ====
                            i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) central_moment (s1, 2), numer; /* the variance */
          (%o3)                   8.425899999999999
          (%i5) s2 : read_matrix (file_search ("wind.data"))$
          (%o5) [11.29584771375004, 16.97988248298583, 5.626661952750102,
                                       37.5986572057918, 25.85981904394192]
          (%i6) central_moment (s2, 3);

     Véanse también ‘central_moment’ y ‘mean’.

 -- Función: cv (<list>)
 -- Función: cv (<matrix>)
     Es el coeficiente de variación, o cociente entre la desviación
     típica muestral (‘std’) y la media (‘mean’),

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) cv (s1), numer;
          (%o3)                   .6193977819764815
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) cv (s2);
          (%o5) [.4192426091090204, .3829365309260502, 0.363779605385983,
                                      .3627381836021478, .3346021393989506]

     Véanse también ‘std’ y ‘mean’.

 -- Función: smin (<list>)
 -- Función: smin (<matrix>)
     Es el valor mínimo de la muestra <list>.  Cuando el argumento es
     una matriz, ‘smin’ devuelve una lista con los valores mínimos de
     las columnas, las cuales están asociadas a variables estadísticas.

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smin (s1);
          (%o3)                           0
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smin (s2);
          (%o5)             [0.58, 0.5, 2.67, 5.25, 5.17]

     Véase también ‘smax’.

 -- Función: smax (<list>)
 -- Función: smax (<matrix>)
     Es el valor máximo de la muestra <list>.  Cuando el argumento es
     una matriz, ‘smax’ devuelve una lista con los valores máximos de
     las columnas, las cuales están asociadas a variables estadísticas.

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) smax (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) smax (s2);
          (%o5)          [20.25, 21.46, 20.04, 29.63, 27.63]

     Véase también ‘smin’.

 -- Función: range (<list>)
 -- Función: range (<matrix>)
     Es la diferencia entre los valores extremos.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) range (s1);
          (%o3)                           9
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) range (s2);
          (%o5)          [19.67, 20.96, 17.37, 24.38, 22.46]

 -- Función: quantile (<list>, <p>)
 -- Función: quantile (<matrix>, <p>)
     Es el <p>-cuantil, siendo <p> un número del intervalo [0, 1], de la
     muestra <list>.  Aunque existen varias definiciones para el cuantil
     muestral (Hyndman, R. J., Fan, Y. (1996) <Sample quantiles in
     statistical packages>.  American Statistician, 50, 361-365), la
     programada en el paquete ‘descriptive’ es la basada en la
     interpolación lineal.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) /* 1st and 3rd quartiles */
                   [quantile (s1, 1/4), quantile (s1, 3/4)], numer;
          (%o3)                      [2.0, 7.25]
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quantile (s2, 1/4);
          (%o5)    [7.2575, 7.477500000000001, 7.82, 11.28, 11.48]

 -- Función: median (<list>)
 -- Función: median (<matrix>)
     Una vez ordenada una muestra, si el tamaño muestral es impar la
     mediana es el valor central, en caso contrario será la media de los
     dos valores centrales.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median (s1);
                                          9
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median (s2);
          (%o5)         [10.06, 9.855, 10.73, 15.48, 14.105]

     La mediana es el cuantil 1/2.

     Véase también ‘quantile’.

 -- Función: qrange (<list>)
 -- Función: qrange (<matrix>)
     El rango intercuartílico es la diferencia entre el tercer y primer
     cuartil, ‘quantile(<list>,3/4) - quantile(<list>,1/4)’,

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) qrange (s1);
                                         21
          (%o3)                          --
                                         4
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) qrange (s2);
          (%o5) [5.385, 5.572499999999998, 6.0225, 8.729999999999999,
                                                         6.650000000000002]

     Véase también ‘quantile’.

 -- Función: mean_deviation (<list>)
 -- Función: mean_deviation (<matrix>)
     Es la desviación media, definida como
                               n
                             ====
                         1   \          _
                         -    >    |x - x|
                         n   /       i
                             ====
                             i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) mean_deviation (s1);
                                         51
          (%o3)                          --
                                         20
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) mean_deviation (s2);
          (%o5) [3.287959999999999, 3.075342, 3.23907, 4.715664000000001,
                                                         4.028546000000002]

     Véase también ‘mean’.

 -- Función: median_deviation (<list>)
 -- Función: median_deviation (<matrix>)
     Es la desviación mediana, definida como
                           n
                         ====
                     1   \
                     -    >    |x - med|
                     n   /       i
                         ====
                         i = 1

     siendo ‘med’ la mediana de <list>.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) median_deviation (s1);
                                          5
          (%o3)                           -
                                          2
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) median_deviation (s2);
          (%o5)           [2.75, 2.755, 3.08, 4.315, 3.31]

     Véase también ‘mean’.

 -- Función: harmonic_mean (<list>)
 -- Función: harmonic_mean (<matrix>)
     Es la media armónica, definida como
                            n
                         --------
                          n
                         ====
                         \     1
                          >    --
                         /     x
                         ====   i
                         i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) harmonic_mean (y), numer;
          (%o3)                   3.901858027632205
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) harmonic_mean (s2);
          (%o5) [6.948015590052786, 7.391967752360356, 9.055658197151745,
                                      13.44199028193692, 13.01439145898509]

     Véanse también ‘mean’ y ‘geometric_mean’.

 -- Función: geometric_mean (<list>)
 -- Función: geometric_mean (<matrix>)
     Es la media geométrica, definida como
                           /  n      \ 1/n
                           | /===\   |
                           |  ! !    |
                           |  ! !  x |
                           |  ! !   i|
                           | i = 1   |
                           \         /

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) y : [5, 7, 2, 5, 9, 5, 6, 4, 9, 2, 4, 2, 5]$
          (%i3) geometric_mean (y), numer;
          (%o3)                   4.454845412337012
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) geometric_mean (s2);
          (%o5) [8.82476274347979, 9.22652604739361, 10.0442675714889,
                                      14.61274126349021, 13.96184163444275]

     Véanse también ‘mean’ y ‘harmonic_mean’.

 -- Función: kurtosis (<list>)
 -- Función: kurtosis (<matrix>)
     Es el coeficiente de curtosis, definido como
                              n
                            ====
                      1     \          _ 4
                     ----    >    (x - x)  - 3
                        4   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) kurtosis (s1), numer;
          (%o3)                  - 1.273247946514421
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) kurtosis (s2);
          (%o5) [- .2715445622195385, 0.119998784429451,
             - .4275233490482866, - .6405361979019522, - .4952382132352935]

     Véanse también ‘mean’, ‘var’ y ‘skewness’.

 -- Función: skewness (<list>)
 -- Función: skewness (<matrix>)
     Es el coeficiente de asimetría, definido como
                              n
                            ====
                      1     \          _ 3
                     ----    >    (x - x)
                        3   /       i
                     n s    ====
                            i = 1

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) skewness (s1), numer;
          (%o3)                  .009196180476450306
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) skewness (s2);
          (%o5) [.1580509020000979, .2926379232061854, .09242174416107717,
                                      .2059984348148687, .2142520248890832]

     Véanse también ‘mean’, ‘var’ y ‘kurtosis’.

 -- Función: pearson_skewness (<list>)
 -- Función: pearson_skewness (<matrix>)
     Es el coeficiente de asimetría de Pearson, definido como
                          _
                       3 (x - med)
                       -----------
                            s

     siendo <med> la mediana de <list>.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) pearson_skewness (s1), numer;
          (%o3)                   .2159484029093895
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) pearson_skewness (s2);
          (%o5) [- .08019976629211892, .2357036272952649,
                   .1050904062491204, .1245042340592368, .4464181795804519]

     Véanse también ‘mean’, ‘var’ y ‘median’.

 -- Función: quartile_skewness (<list>)
 -- Función: quartile_skewness (<matrix>)
     Es el coeficiente de asimetría cuartílico, definido como
                         c    - 2 c    + c
                          3/4      1/2    1/4
                         --------------------
                             c    - c
                              3/4    1/4

     siendo c_p el <p>-cuantil de la muestra <list>.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) quartile_skewness (s1), numer;
          (%o3)                  .04761904761904762
          (%i4) s2 : read_matrix (file_search ("wind.data"))$
          (%i5) quartile_skewness (s2);
          (%o5) [- 0.0408542246982353, .1467025572005382,
                 0.0336239103362392, .03780068728522298, 0.210526315789474]

     Véase también ‘quantile’.

 -- Función: km (<list>, <option> ...)
 -- Función: km (<matrix>, <option> ...)

     Estimador Kaplan-Meier de la función de supervivencia o fiabilidad
     S(x)=1-F(x).

     Los datos se pueden introducir como una lista de pares de números o
     como una matriz de dos columnas.  La primera componente es el
     tiempo observado y la segunda componente es el índice de censura (1
     = no censurado, 0 = censurado por la derecha).

     El argumento opcional es el nombre de la variable en la expresión
     devuelta, la cual es <x> por defecto.

     Ejemplos:

     Muestra como una lista de pares.

          (%i1) load ("descriptive")$
          (%i2) S: km([[2,1], [3,1], [5,0], [8,1]]);
                                 charfun((3 <= x) and (x < 8))
          (%o2) charfun(x < 0) + -----------------------------
                                               2
                          3 charfun((2 <= x) and (x < 3))
                        + -------------------------------
                                         4
                        + charfun((0 <= x) and (x < 2))
          (%i3) load ("draw")$
          (%i4) draw2d(
                  line_width = 3, grid = true,
                  explicit(S, x, -0.1, 10))$

     Estimación de probabilidades de supervivencia.

          (%i1) load ("descriptive")$
          (%i2) S(t):= ''(km([[2,1], [3,1], [5,0], [8,1]], t)) $
          (%i3) S(6);
                                      1
          (%o3)                       -
                                      2

 -- Función: cdf_empirical (<list>, <option> ...)
 -- Función: cdf_empirical (<matrix>, <option> ...)

     Función de distribución empírica F(x).

     Los datos se pueden introducir como una lista de números o como una
     matriz columna.

     El argumento opcional es el nombre de la variable en la expresión
     devuelta, la cual es <x> por defecto.

     Ejemplo:

     Función de distribución empírica.

          (%i1) load ("descriptive")$
          (%i2) F(x):= ''(cdf_empirical([1,3,3,5,7,7,7,8,9]));
          (%o2) F(x) := (charfun(x >= 9) + charfun(x >= 8)
                         + 3 charfun(x >= 7) + charfun(x >= 5)
                         + 2 charfun(x >= 3) + charfun(x >= 1))/9
          (%i3) F(6);
                                     4
          (%o3)                      -
                                     9
          (%i4) load("draw")$
          (%i5) draw2d(
                  line_width = 3,
                  grid       = true,
                  explicit(F(z), z, -2, 12)) $

 -- Función: cov (<matrix>)
     Es la matriz de covarianzas de una muestra multivariante, definida
     como
                        n
                       ====
                    1  \           _        _
                S = -   >    (X  - X) (X  - X)'
                    n  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$  /* change precision for pretty output */
                [ 17.22191  13.61811  14.37217  19.39624  15.42162 ]
                [                                                  ]
                [ 13.61811  14.98774  13.30448  15.15834  14.9711  ]
                [                                                  ]
          (%o4) [ 14.37217  13.30448  15.47573  17.32544  16.18171 ]
                [                                                  ]
                [ 19.39624  15.15834  17.32544  32.17651  20.44685 ]
                [                                                  ]
                [ 15.42162  14.9711   16.18171  20.44685  24.42308 ]
          (%i5) cov (s2);

     Véase también ‘cov1’.

 -- Función: cov1 (<matrix>)
     Es la matriz de cuasivarianzas de una muestra multivariante,
     definida como
                        n
                       ====
                   1   \           _        _
             S  = ---   >    (X  - X) (X  - X)'
              1   n-1  /       j        j
                       ====
                       j = 1

     siendo X_j la j-ésima fila de la matriz muestral.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec : 7$ /* change precision for pretty output */
                [ 17.39587  13.75567  14.51734  19.59216  15.5774  ]
                [                                                  ]
                [ 13.75567  15.13913  13.43887  15.31145  15.12232 ]
                [                                                  ]
          (%o4) [ 14.51734  13.43887  15.63205  17.50044  16.34516 ]
                [                                                  ]
                [ 19.59216  15.31145  17.50044  32.50153  20.65338 ]
                [                                                  ]
                [ 15.5774   15.12232  16.34516  20.65338  24.66977 ]
          (%i5) cov1 (s2);

     Véase también ‘cov’.

 -- Función: global_variances (<matrix>)
 -- Función: global_variances (<matrix>, <options> ...)
     La función ‘global_variances’ devuelve una lista de medidas
     globales de variabilidad:

        • <varianza total>: ‘trace(S_1)’,
        • <varianza media>: ‘trace(S_1)/p’,
        • <varianza generalizada>: ‘determinant(S_1)’,
        • <desviación típica generalizada>: ‘sqrt(determinant(S_1))’,
        • <varianza efectiva> ‘determinant(S_1)^(1/p)’, (definida en:
          Peña, D. (2002) <Análisis de datos multivariantes>;
          McGraw-Hill, Madrid.)
        • <desviación típica efectiva>: ‘determinant(S_1)^(1/(2*p))’.
     donde <p> es la dimensión de la variable aleatoria multivariante y
     S_1 la matriz de covarianzas devuelta por la función ‘cov1’.

     Opción:

        • ‘'data’, por defecto ‘'true’, indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas ‘cov1’ debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en lugar
          de los datos.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) global_variances (s2);
          (%o3) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Cálculo de ‘global_variances’ a partir de la matriz de covarianzas.

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) s : cov1 (s2)$
          (%i4) global_variances (s, data=false);
          (%o4) [105.338342060606, 21.06766841212119, 12874.34690469686,
                   113.4651792608502, 6.636590811800794, 2.576158149609762]

     Véanse también ‘cov’ y ‘cov1’.

 -- Función: cor (<matrix>)
 -- Función: cor (<matrix>, <options> ...)
     Es la matriz de correlaciones de la muestra multivariante.

     Opción:

        • ‘'data’, por defecto ‘'true’, indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas ‘cov1’ debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en lugar
          de los datos.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) fpprintprec:7$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) cor (s2);
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o4) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Cálculo de la matriz de correlaciones a partir de la matriz de
     covarianzas.

          (%i1) load ("descriptive")$
          (%i2) fpprintprec : 7 $
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) s : cov1 (s2)$
          (%i5) cor (s, data=false); /* this is faster */
                [   1.0     .8476339  .8803515  .8239624  .7519506 ]
                [                                                  ]
                [ .8476339    1.0     .8735834  .6902622  0.782502 ]
                [                                                  ]
          (%o5) [ .8803515  .8735834    1.0     .7764065  .8323358 ]
                [                                                  ]
                [ .8239624  .6902622  .7764065    1.0     .7293848 ]
                [                                                  ]
                [ .7519506  0.782502  .8323358  .7293848    1.0    ]

     Véanse también ‘cov’ y ‘cov1’.

 -- Función: list_correlations (<matrix>)
 -- Función: list_correlations (<matrix>, <options> ...)
     La función ‘list_correlations’ devuelve una lista con medidas de
     correlación:

        • <matriz de precisión>: es la inversa de la matriz de
          covarianzas S_1,
                      -1     ij
                     S   = (s  )
                      1         i,j = 1,2,...,p

        • <multiple correlation vector>: (R_1^2, R_2^2, ..., R_p^2),
          with
                      2          1
                     R  = 1 - -------
                      i        ii
                              s   s
                                   ii
          es un indicador de la bondad de ajuste del modelo de regresión
          lineal multivariante de X_i cuando el resto de variables se
          utilizan como regresores.

        • <matriz de correlaciones parciales>: en la que el elemento (i,
          j) es
                                        ij
                                       s
                     r        = - ------------
                      ij.rest     / ii  jj\ 1/2
                                  |s   s  |
                                  \       /

     Opción:

        • ‘'data’, por defecto ‘'true’, indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas ‘cov1’ debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en lugar
          de los datos.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) z : list_correlations (s2)$
          (%i4) fpprintprec : 5$ /* for pretty output */
                [  .38486   - .13856   - .15626   - .10239    .031179  ]
                [                                                      ]
                [ - .13856   .34107    - .15233    .038447   - .052842 ]
                [                                                      ]
          (%o5) [ - .15626  - .15233    .47296    - .024816  - .10054  ]
                [                                                      ]
                [ - .10239   .038447   - .024816   .10937    - .034033 ]
                [                                                      ]
                [ .031179   - .052842  - .10054   - .034033   .14834   ]
          (%o6)       [.85063, .80634, .86474, .71867, .72675]
                 [  - 1.0     .38244   .36627   .49908   - .13049 ]
                 [                                                ]
                 [  .38244    - 1.0    .37927  - .19907   .23492  ]
                 [                                                ]
          (%o7)  [  .36627    .37927   - 1.0    .10911    .37956  ]
                 [                                                ]
                 [  .49908   - .19907  .10911   - 1.0     .26719  ]
                 [                                                ]
                 [ - .13049   .23492   .37956   .26719    - 1.0   ]

     Véanse también ‘cov’ y ‘cov1’.

 -- Función: principal_components (<matrix>)
 -- Función: principal_components (<matrix>, <options> ...)
     Calcula las componentes principales de una muestra multivariante.
     Las componentes principales se utilizan en el análisis estadístico
     multivariante para reducir la dimensionalidad de la muestra.

     Opción:

        • ‘'data’, por defecto ‘'true’, indica si la matriz de entrada
          contiene los datos muestrales, en cuyo caso la matriz de
          covarianzas ‘cov1’ debe ser calculada; en caso contrario, se
          le debe pasar ésta a la función como matriz simétrica en lugar
          de los datos.

     La salida de la función ‘principal_components’ es una lista con los
     siguientes resultados:

        • varianzas de las componentes principales,
        • porcentajes de variación total explicada por cada componente
          principal,
        • matriz de rotación.

     Ejemplos:

     En este ejemplo, la primera componente explica el 83.13 por ciento
     de la varianza total.

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) fpprintprec:4 $
          (%i4) res: principal_components(s2);
          0 errors, 0 warnings
          (%o4) [[87.57, 8.753, 5.515, 1.889, 1.613],
          [83.13, 8.31, 5.235, 1.793, 1.531],
          [ .4149  .03379   - .4757  - 0.581   - .5126 ]
          [                                            ]
          [ 0.369  - .3657  - .4298   .7237    - .1469 ]
          [                                            ]
          [ .3959  - .2178  - .2181  - .2749    .8201  ]]
          [                                            ]
          [ .5548   .7744    .1857    .2319    .06498  ]
          [                                            ]
          [ .4765  - .4669   0.712   - .09605  - .1969 ]
          (%i5) /* porcentajes acumulados  */
              block([ap: copy(res[2])],
                for k:2 thru length(ap) do ap[k]: ap[k]+ap[k-1],
                ap);
          (%o5)                 [83.13, 91.44, 96.68, 98.47, 100.0]
          (%i6) /* dimension de la muestra */
                p: length(first(res));
          (%o6)                                  5
          (%i7) /* dibuja porcentajes para seleccionar el numero de
                   componentes principales para el analisis ulterior */
               draw2d(
                  fill_density = 0.2,
                  apply(bars, makelist([k, res[2][k], 1/2], k, p)),
                  points_joined = true,
                  point_type    = filled_circle,
                  point_size    = 3,
                  points(makelist([k, res[2][k]], k, p)),
                  xlabel = "Variances",
                  ylabel = "Percentages",
                  xtics  = setify(makelist([concat("PC",k),k], k, p))) $

     En caso de que la matriz de covarianzas sea conocida, se le puede
     pasar a la función, pero debe utilizarse la opción ‘data=false’.

          (%i1) load ("descriptive")$
          (%i2) S: matrix([1,-2,0],[-2,5,0],[0,0,2]);
                                          [  1   - 2  0 ]
                                          [             ]
          (%o2)                           [ - 2   5   0 ]
                                          [             ]
                                          [  0    0   2 ]
          (%i3) fpprintprec:4 $
          (%i4) /* el argumento es una matriz de covarianzas */
                res: principal_components(S, data=false);
          0 errors, 0 warnings
                                                            [ - .3827  0.0  .9239 ]
                                                            [                     ]
          (%o4) [[5.828, 2.0, .1716], [72.86, 25.0, 2.145], [  .9239   0.0  .3827 ]]
                                                            [                     ]
                                                            [   0.0    1.0   0.0  ]
          (%i5) /* transformacion para obtener las componentes principales a
                   partir de los registros originales */
                matrix([a1,b2,c3],[a2,b2,c2]).last(res);
                       [ .9239 b2 - .3827 a1  1.0 c3  .3827 b2 + .9239 a1 ]
          (%o5)        [                                                  ]
                       [ .9239 b2 - .3827 a2  1.0 c2  .3827 b2 + .9239 a2 ]


File: maxima.info,  Node: Funciones y variables para gráficos estadísticos,  Prev: Funciones y variables de parámetros descriptivos,  Up: descriptive

44.4 Funciones y variables para gráficos estadísticos
=====================================================

 -- Función: barsplot (<data1>, <data2>, …, <option_1>, <option_2>, …)
 -- Función: barsplot_description (…)

     Dibuja diagramas de barras para variables estadísticas discretas,
     tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

          <box_width> (valor por defecto, ‘3/4’): ancho relativo de los
          rectángulos.  Este valor debe pertenecer al rango ‘[0,1]’.

        • <grouping> (valor por defecto, ‘clustered’): indica cómo se
          agrupan las diferentes muestras.  Son valores válidos:
          ‘clustered’ y ‘stacked’.

        • <groups_gap> (valor por defecto, ‘1’): un número positivo que
          representa la separación entre dos grupos consecutivos de
          barras.

        • <bars_colors> (valor por defecto, ‘[]’): una lista de colores
          para múltiples muestras.  Cuando el número de muestras sea
          mayor que el de colores especificados, los colores adicionales
          necesarios se seleccionan aleatoriamente.  Véase ‘color’ para
          más información.

        • <frequency> (valor por defecto, ‘absolute’): indica la escala
          de las ordenadas.  Valores admitidos son: ‘absolute’,
          ‘relative’ y and ‘percent’.

        • <ordering> (valor por defecto, ‘orderlessp’): los valores
          admitidos para esta opción son: ‘orderlessp’ y ‘ordergreatp’,
          indicando cómo se deben ordenar los resultados muestrales
          sobre el eje-<x>.

        • <sample_keys> (valor por defecto, ‘[]’): es una lista de
          cadenas de texto a usar como leyendas.  Cuando la lista tenga
          una longitud diferente de cero o del número de muestras, se
          devolverá un mensaje de error.

        • <start_at> (valor por defecto, ‘0’): indica a qué altura
          comienza a dibujarse el gráfico de barra sobre el eje de
          abscisas.

        • Todas las opciones globales de ‘draw’, excepto ‘xtics’, que se
          asigna internamente por ‘barsplot’.  Si es necesario que el
          usuario le dé su propio valor a esta opción, o quiere
          construir una escena más compleja, debe hacer uso de
          ‘barsplot_description’.  Véase el ejemplo más abajo.

        • Las siguientes opciones locales de ‘draw’: ‘key’, ‘color’,
          ‘fill_color’, ‘fill_density’ y ‘line_width’.  Véase también
          ‘bars’.

     La función ‘barsplot_description’ crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función ‘wxbarsplot’ para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Muestra univariante en formato matricial.  Frecuencias absolutas.

          (%i1) load ("descriptive")$
          (%i2) m : read_matrix (file_search ("biomed.data"))$
          (%i3) barsplot(
                  col(m,2),
                  title        = "Ages",
                  xlabel       = "years",
                  box_width    = 1/2,
                  fill_density = 3/4)$

     Dos muestras de diferente tamaño, con frecuencias relativas y
     colores definidos por el usuario.

          (%i1) load ("descriptive")$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) barsplot(
                  l1,l2,
                  box_width    = 1,
                  fill_density = 1,
                  bars_colors  = [black, grey],
                  frequency = relative,
                  sample_keys = ["A", "B"])$

     Cuatro muestras no numéricas de igual tamaño.

          (%i1) load ("descriptive")$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  groups_gap   = 3,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     Barras apiladas verticalmente.

          (%i1) load ("descriptive")$
          (%i2) barsplot(
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  makelist([Yes, No, Maybe][random(3)+1],k,1,50),
                  title  = "Asking for something to four groups",
                  ylabel = "# of individuals",
                  grouping     = stacked,
                  fill_density = 0.5,
                  ordering     = ordergreatp)$

     ‘barsplot’ en un contexto multiplot.

          (%i1) load ("descriptive")$
          (%i2) l1:makelist(random(10),k,1,50)$
          (%i3) l2:makelist(random(10),k,1,100)$
          (%i4) bp1 :
                  barsplot_description(
                   l1,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [blue],
                   frequency = relative)$
          (%i5) bp2 :
                  barsplot_description(
                   l2,
                   box_width = 1,
                   fill_density = 0.5,
                   bars_colors = [red],
                   frequency = relative)$
          (%i6) draw(gr2d(bp1), gr2d(bp2))$

     Para las opciones relacionadas con los diagramas de barras, véase
     ‘bars’ del paquete ‘draw’.

     Véanse también las funciones ‘histogram’ y ‘piechart’.

 -- Función: boxplot (<data>)
 -- Función: boxplot (<data>, <option_1>, <option_2>, …)
 -- Función: boxplot_description (…)

     Dibuja diagramas de cajas (box-and-whishker).  El argumento <data>
     puede ser una lista, lo cual no es de gran interés, puesto que
     estos gráficos se utilizan principalmente para comparar distintas
     muestras, o una matriz, de manera que sea posible comparar dos o
     más componentes de una muestra multivariante.  También se permite
     que <data> sea una lista de muestras con posibles tamaños
     diferentes; de hecho, esta es la única función del paquete
     ‘descriptive’ que admite esta estructura de datos.

     La caja se dibuja desde el primer cuartil hasta el tercero, con un
     segmento horizontal situado a la altura del segundo cuartil o
     mediana.  Por defecto, los bigotes inferior y superior se sitúan a
     la altura de los valores mínimo y máximo, respectivamente.  La
     opción <range> se puede utilizar para indicar que los valores
     mayores que
     ‘quantile(x,3/4)+range*(quantile(x,3/4)-quantile(x,1/4))’, o
     menores que
     ‘quantile(x,1/4)-range*(quantile(x,3/4)-quantile(x,1/4))’, deben
     considerarse atípicos, en cuyo caso se dibujan como puntos
     aislados, al tiempo que los bigotes se colocan en los extremos del
     resto de la muestra.

     Opciones disponibles:

        • <box_width> (valor por defecto, ‘3/4’): ancho relativo de las
          cajas.  This value must be in the range ‘[0,1]’.

        • <box_orientation> (valor por defecto, ‘vertical’): valores
          posibles: ‘vertical’ y ‘horizontal’.

        • <range> (valor por defecto, ‘inf’): coeficiente positivo del
          rango intercuartílico para declarar los límites de los datos
          atípicos.

        • <outliers_size> (valor por defecto, ‘1’): tamaño de los
          círculos para los datos atípicos.

        • Todas las opciones globales de ‘draw’, excepto
          ‘points_joined’, ‘point_size’, ‘point_type’, ‘xtics’, ‘ytics’,
          ‘xrange’ y ‘yrange’, que se asignan internamente por
          ‘boxplot’.  Si es necesario que el usuario le dé sus propios
          valores a estas opciones, o quiere construir una escena más
          compleja, debe hacer uso de ‘boxplot_description’.

        • Las siguientes opciones locales de ‘draw’: ‘key’, ‘color’, y
          ‘line_width’.

     La función ‘boxplot_description’ crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función ‘wxboxplot’ para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Diagrama de cajas de una muestra multivariante.

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix(file_search("wind.data"))$
          (%i3) boxplot(s2,
                  box_width  = 0.2,
                  title      = "Windspeed in knots",
                  xlabel     = "Stations",
                  color      = red,
                  line_width = 2)$

     Diagrama de cajas de tres muestras de tamaños diferentes.

          (%i1) load ("descriptive")$
          (%i2) A :
                 [[6, 4, 6, 2, 4, 8, 6, 4, 6, 4, 3, 2],
                  [8, 10, 7, 9, 12, 8, 10],
                  [16, 13, 17, 12, 11, 18, 13, 18, 14, 12]]$
          (%i3) boxplot (A, box_orientation = horizontal)$

     La opción <range> puede utilizarse para tratar con datos atípicos.

          (%i1) load ("descriptive")$
          (%i2) B: [[7, 15, 5, 8, 6, 5, 7, 3, 1],
                    [10, 8, 12, 8, 11, 9, 20],
                    [23, 17, 19, 7, 22, 19]] $
          (%i3) boxplot (B, range=1)$
          (%i4) boxplot (B, range=1.5, box_orientation = horizontal)$
          (%i5) draw2d(
                  boxplot_description(
                    B,
                    range            = 1.5,
                    line_width       = 3,
                    outliers_size    = 2,
                    color            = red,
                    background_color = light_gray),
                  xtics = {["Low",1],["Medium",2],["High",3]}) $

 -- Función: histogram (<list>)
 -- Función: histogram (<list>, <option_1>, <option_2>, …)
 -- Función: histogram (<one_column_matrix>)
 -- Función: histogram (<one_column_matrix>, <option_1>, <option_2>, …)
 -- Función: histogram (<one_row_matrix>)
 -- Función: histogram (<one_row_matrix>, <option_1>, <option_2>, …)
 -- Función: histogram_description (…)

     Dibuja un histograma a partir de una muestra continua.  Los datos
     muestrales deben darse en forma de lista de números o como una
     matriz unidimensional.

     Opciones dispponibles:

        • <nclasses> (valor por defecto, ‘10’): número de clases del
          histograma, o una lista indicando los límites de las clases y
          su número, o solamente los límites.

        • <frequency> (valor por defecto, ‘absolute’): indica la escala
          de las ordenadas.  Valores admitidos son: ‘absolute’,
          ‘relative’, ‘percent’ y ‘density’.  Con ‘density’, el
          histograma adquiere un área total igual a uno.

        • <htics> (valor por defecto, ‘auto’): formato para las marcas
          sobre el eje de las abscisas.  Valores admitidos son: ‘auto’,
          ‘endpoints’, ‘intervals’ o una lista de etiquetas.

        • Todas las opciones globales de ‘draw’, excepto ‘xrange’,
          ‘yrange’ y ‘xtics’, que son asignadas internamente por
          ‘histogram’.  Si es necesario que el usuario le dé sus propios
          valores a estas opciones, debe hacer uso de
          ‘histogram_description’.  Véase el ejemplo más abajo.

        • Las siguientes opciones locales de ‘draw’: ‘key’, ‘color’,
          ‘fill_color’, ‘fill_density’ y ‘line_width’.  Véase también
          ‘bars’.

     La función ‘histogram_description’ crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función ‘wxhistogram’ para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Un histograma con seis clases:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = 8,
                     title        = "pi digits",
                     xlabel       = "digits",
                     ylabel       = "Absolute frequency",
                     fill_color   = grey,
                     fill_density = 0.6)$

     Ajustando los límites del histograma a -2 y 12, con 3 clases.
     También se establece un formato predefinido a las marcas del eje de
     abscisas:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) histogram (
                     s1,
                     nclasses     = [-2,12,3],
                     htics        = ["A", "B", "C"],
                     terminal     = png,
                     fill_color   = "#23afa0",
                     fill_density = 0.6)$

     Se hace uso de ‘histogram_description’ para ajustar la opción
     ‘xrange’ y añadir una curva explícita a la escena:

          (%i1) load ("descriptive")$
          (%i2) ( load("distrib"),
                  m: 14, s: 2,
                  s2: random_normal(m, s, 1000) ) $
          (%i3) draw2d(
                  grid   = true,
                  xrange = [5, 25],
                  histogram_description(
                    s2,
                    nclasses     = 9,
                    frequency    = density,
                    fill_density = 0.5),
                  explicit(pdf_normal(x,m,s), x, m - 3*s, m + 3* s))$

 -- Función: piechart (<list>)
 -- Función: piechart (<list>, <option_1>, <option_2>, …)
 -- Función: piechart (<one_column_matrix>)
 -- Función: piechart (<one_column_matrix>, <option_1>, <option_2>, …)
 -- Función: piechart (<one_row_matrix>)
 -- Función: piechart (<one_row_matrix>, <option_1>, <option_2>, …)
 -- Función: piechart_description (…)

     Similar a ‘barsplot’, pero dibuja sectores en lugar de rectángulos.

     Opciones disponibles:

        • <sector_colors> (valor por defecto, ‘[]’): una lista de
          colores para los sectores.  Cuando el número de sectores sea
          mayor que el de colores especificados, los colores adicionales
          necesarios se seleccionan aleatoriamente.  Véase ‘color’ para
          más información.

        • <pie_center> (valor por defecto, ‘[0,0]’): centro del diagrama

        • <pie_radius> (valor por defecto, ‘1’): radio del diagrama.

        • Todas las opciones globales de ‘draw’, excepto ‘key’, que se
          asigna internamente por ‘piechart’.  Si es necesario que el
          usuario le dé su propio valor a esta opción, o quiere
          construir una escena más compleja, debe hacer uso de
          ‘piechart_description’.

        • Las siguientes opciones locales de ‘draw’: ‘key’, ‘color’,
          ‘fill_density’ y ‘line_width’.  Véase también ‘bars’.

     La función ‘piechart_description’ crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función ‘wxpiechart’ para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) s1 : read_list (file_search ("pidigits.data"))$
          (%i3) piechart(
                  s1,
                  xrange  = [-1.1, 1.3],
                  yrange  = [-1.1, 1.1],
                  title   = "Digit frequencies in pi")$

     Véase también la función ‘barsplot’.

 -- Función: scatterplot (<list>)
 -- Función: scatterplot (<list>, <option_1>, <option_2>, …)
 -- Función: scatterplot (<matrix>)
 -- Función: scatterplot (<matrix>, <option_1>, <option_2>, …)
 -- Función: scatterplot_description (…)

     Dibuja diagramas de dispersión, tanto de muestras univariantes
     (<list>) como multivariantes (<matrix>).

     Las opciones disponibles son las mismas que admite ‘histogram’.

     La función ‘scatterplot_description’ crea un objeto gráfico útil
     para formar escenas complejas, junto con otros objetos gráficos.
     Se dispone también de la función ‘wxscatterplot’ para crear
     histogramas incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplos:

     Diagrama de dispersión univariante a partir de una muestra normal
     simulada.

          (%i1) load ("descriptive")$
          (%i2) load ("distrib")$
          (%i3) scatterplot(
                  random_normal(0,1,200),
                  xaxis      = true,
                  point_size = 2,
                  dimensions = [600,150])$

     Diagrama de dispersión bidimensional.

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                 submatrix(s2, 1,2,3),
                 title      = "Data from stations #4 and #5",
                 point_type = diamant,
                 point_size = 2,
                 color      = blue)$

     Diagrama de dispersión tridimensional.

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(submatrix (s2, 1,2), nclasses=4)$

     Diagrama de dispersión de cinco dimensiones, con histogramas de
     cinco classes.

          (%i1) load ("descriptive")$
          (%i2) s2 : read_matrix (file_search ("wind.data"))$
          (%i3) scatterplot(
                  s2,
                  nclasses     = 5,
                  frequency    = relative,
                  fill_color   = blue,
                  fill_density = 0.3,
                  xtics        = 5)$

     Para dibujar puntos aislados o unidos por segmentos, tanto en dos
     como en tres dimensiones, véase ‘points’.  Véase también
     ‘histogram’.

 -- Función: starplot (<data1>, <data2>, …, <option_1>, <option_2>, …)
 -- Función: starplot_description (…)

     Dibuja diagramas de estrellas para variables estadísticas
     discretas, tanto para una como para más muestras.

     <data> puede ser una lista de resultados provenientes de una
     muestra o una matriz de <m> filas y <n> columnas, representando <n>
     muestras de tamaño <m> cada una.

     Las opciones disponibles son:

        • <stars_colors> (valor por defecto, ‘[]’): una lista de colores
          para muestras múltiples.  Cuando haya más muestras que colores
          especificados, los colores que faltan se eligen
          aleatoriamente.  Véase ‘color’ para más información.

        • <frequency> (valor por defecto, ‘absolute’): indica la escala
          de los radios.  Valores admitidos son: ‘absolute’ y
          ‘relative’.

        • <ordering> (valor por defecto, ‘orderlessp’): los valores
          admitidos para esta opción son: ‘orderlessp’ y ‘ordergreatp’,
          indicando cómo se deben ordenar los resultados muestrales
          sobre el eje-<x>.

        • <sample_keys> (valor por defecto, ‘[]’): es una lista de
          cadenas de texto a usar como leyendas.  Cuando la lista tenga
          una longitud diferente de cero o del número de muestras, se
          devolverá un mensaje de error.

        • <star_center> (valor por defecto, ‘[0,0]’): centro del
          diagrama.

        • <star_radius> (valor por defecto, ‘1’): radio del diagrama.

        • Todas las opciones globales de ‘draw’, excepto
          ‘points_joined’, ‘point_type’, and ‘key’, que se asignan
          internamente por ‘starplot’.  Si es necesario que el usuario
          les dé sus propios valores a estas opciones, o quiere
          construir una escena más compleja, debe hacer uso de
          ‘starplot_description’.

        • La siguiente opción local de ‘draw’: ‘line_width’.

     La función ‘starplot_description’ crea un objeto gráfico útil para
     formar escenas complejas, junto con otros objetos gráficos.  Se
     dispone también de la función ‘wxstarplot’ para crear histogramas
     incorporados en los interfaces wxMaxima y iMaxima.

     Ejemplo:

     Gráfico basado en frecuencias absolutas.  La localización y el
     radios lo define el usuario.

          (%i1) load ("descriptive")$
          (%i2) l1: makelist(random(10),k,1,50)$
          (%i3) l2: makelist(random(10),k,1,200)$
          (%i4) starplot(
                  l1, l2,
                  stars_colors = [blue,red],
                  sample_keys = ["1st sample", "2nd sample"],
                  star_center = [1,2],
                  star_radius = 4,
                  proportional_axes = xy,
                  line_width = 2 ) $

 -- Función: stemplot (<m>)
 -- Función: stemplot (<m>, <option>)

     Dibuja diagrama de tallos y hojas.

     La única opción disponible es:

        • <leaf_unit> (valor por defecto, ‘1’): indica la unidad de las
          hojas; debe ser una potencia de 10.

     Ejemplo:

          (%i1) load ("descriptive")$
          (%i2) load("distrib")$
          (%i3) stemplot(
                  random_normal(15, 6, 100),
                  leaf_unit = 0.1);
          -5|4
           0|37
           1|7
           3|6
           4|4
           5|4
           6|57
           7|0149
           8|3
           9|1334588
          10|07888
          11|01144467789
          12|12566889
          13|24778
          14|047
          15|223458
          16|4
          17|11557
          18|000247
          19|4467799
          20|00
          21|1
          22|2335
          23|01457
          24|12356
          25|455
          27|79
          key: 6|3 =  6.3
          (%o3)                  done


File: maxima.info,  Node: diag,  Next: distrib,  Prev: descriptive,  Up: Top

45 diag
*******

* Menu:

* Funciones y variables para diag::


File: maxima.info,  Node: Funciones y variables para diag,  Prev: diag,  Up: diag

45.1 Funciones y variables para diag
====================================

 -- Función: diag (<lm>)
     Genera una matriz cuadrada con las matrices de <lm> en la diagonal,
     siendo <lm> una lista de matrices o de escalares.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a1:matrix([1,2,3],[0,4,5],[0,0,6])$

          (%i3) a2:matrix([1,1],[1,0])$

          (%i4) diag([a1,x,a2]);
                             [ 1  2  3  0  0  0 ]
                             [                  ]
                             [ 0  4  5  0  0  0 ]
                             [                  ]
                             [ 0  0  6  0  0  0 ]
          (%o4)              [                  ]
                             [ 0  0  0  x  0  0 ]
                             [                  ]
                             [ 0  0  0  0  1  1 ]
                             [                  ]
                             [ 0  0  0  0  1  0 ]

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.

 -- Función: JF (<lambda>,<n>)
     Devuelve la célula de Jordan de orden <n> con valor propio
     <lambda>.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) JF(2,5);
                              [ 2  1  0  0  0 ]
                              [               ]
                              [ 0  2  1  0  0 ]
                              [               ]
          (%o2)               [ 0  0  2  1  0 ]
                              [               ]
                              [ 0  0  0  2  1 ]
                              [               ]
                              [ 0  0  0  0  2 ]
          (%i3) JF(3,2);
                                   [ 3  1 ]
          (%o3)                    [      ]
                                   [ 0  3 ]

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.

 -- Función: jordan (<mat>)
     Devuelve la forma de Jordan de la matriz <mat>, pero en formato de
     lista de Maxima.  Para obtener la matriz correspondiente, llámese a
     la función ‘dispJordan’ utilizando como argumento la salida de
     ‘jordan’.

     Ejemplo:
          (%i1) load("diag")$

          (%i3) a:matrix([2,0,0,0,0,0,0,0],
                         [1,2,0,0,0,0,0,0],
                         [-4,1,2,0,0,0,0,0],
                         [2,0,0,2,0,0,0,0],
                         [-7,2,0,0,2,0,0,0],
                         [9,0,-2,0,1,2,0,0],
                         [-34,7,1,-2,-1,1,2,0],
                         [145,-17,-16,3,9,-2,0,3])$

          (%i34) jordan(a);
          (%o4)             [[2, 3, 3, 1], [3, 1]]
          (%i5) dispJordan(%);
                          [ 2  1  0  0  0  0  0  0 ]
                          [                        ]
                          [ 0  2  1  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  2  0  0  0  0  0 ]
                          [                        ]
                          [ 0  0  0  2  1  0  0  0 ]
          (%o5)           [                        ]
                          [ 0  0  0  0  2  1  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  2  0  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  2  0 ]
                          [                        ]
                          [ 0  0  0  0  0  0  0  3 ]

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.
     Véanse también ‘dispJordan’ y ‘minimalPoly’.

 -- Función: dispJordan (<l>)
     Devuelve la matriz de Jordan asociada a la codificación dada por la
     lista <l>, que habitualmente será la salida de la función ‘jordan’.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i3) jordan(b1);
          (%o3)                  [[0, 3, 2]]
          (%i4) dispJordan(%);
                              [ 0  1  0  0  0 ]
                              [               ]
                              [ 0  0  1  0  0 ]
                              [               ]
          (%o4)               [ 0  0  0  0  0 ]
                              [               ]
                              [ 0  0  0  0  1 ]
                              [               ]
                              [ 0  0  0  0  0 ]

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.
     Véanse también ‘jordan’ y ‘minimalPoly’.

 -- Función: minimalPoly (<l>)
     Devuelve el polinomio mínimo asociado a la codificación dada por la
     lista <l>, que habitualmente será la salida de la función ‘jordan’.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                         [-2,2,1,2],
                         [-2,-1,-1,1],
                         [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) minimalPoly(%);
                                      3
          (%o4)                (x - 1)  (x + 1)

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.
     Véanse también ‘jordan’ y ‘dispJordan’.

 -- Función: ModeMatrix (<A>,<l>)
     Devuelve la matriz <M> tal que (M^^-1).A.M=J, donde <J> es la forma
     de Jordan de <A>.  La lista <l> es la forma codificada de la forma
     de Jordan tal como la devuelve la función ‘jordan’.

     Ejemplo:
          (%i1) load("diag")$

          (%i2) a:matrix([2,1,2,0],
                    [-2,2,1,2],
                    [-2,-1,-1,1],
                    [3,1,2,-1])$

          (%i3) jordan(a);
          (%o3)               [[- 1, 1], [1, 3]]
          (%i4) M: ModeMatrix(a,%);
                            [  1    - 1   1   1 ]
                            [                   ]
                            [   1               ]
                            [ - -   - 1   0   0 ]
                            [   9               ]
                            [                   ]
          (%o4)             [   13              ]
                            [ - --   1   - 1  0 ]
                            [   9               ]
                            [                   ]
                            [  17               ]
                            [  --   - 1   1   1 ]
                            [  9                ]
          (%i5) is(  (M^^-1).a.M = dispJordan(%o3)  );
          (%o5)                      true
     Nótese que ‘dispJordan(%o3)’ es la forma de Jordan de la matriz
     ‘a’.

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.
     Véanse también ‘jordan’ y ‘dispJordan’.

 -- Función: mat_function (<f>,<mat>)
     Devuelve f(mat), siendo <f> una función analítica y <mat> una
     matriz.  Este cálculo se basa en la fórmula integral de Cauchy, que
     establece que si ‘f(x)’ es analítica y
          mat=diag([JF(m1,n1),...,JF(mk,nk)]),

     entonces

          f(mat)=ModeMatrix*diag([f(JF(m1,n1)),...,f(JF(mk,nk))])
                    * ModeMatrix^^(-1)

     Nótese que hay otros métodos alternativos para realizar este
     cálculo.

     Se presentan algunos ejemplos.

     Ejemplo 1:
          (%i1) load("diag")$

          (%i2) b2:matrix([0,1,0], [0,0,1], [-1,-3,-3])$

          (%i3) mat_function(exp,t*b2);
                         2   - t
                        t  %e          - t     - t
          (%o3) matrix([-------- + t %e    + %e   ,
                           2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) + t (2 %e    - -----)
                  t       2                             t
                         t
                                   - t          - t     - t
                 - t       - t   %e        2  %e      %e
           + 2 %e   , t (%e    - -----) + t  (----- - -----)
                                   t            2       t
                         2   - t            - t     - t
               - t      t  %e        2    %e      %e        - t
           + %e   ], [- --------, - t  (- ----- - ----- + %e   ),
                           2                t       2
                                                   t
                  - t     - t      2   - t
             2  %e      %e        t  %e          - t
          - t  (----- - -----)], [-------- - t %e   ,
                  2       t          2
                  - t     - t                           - t
           2    %e      %e        - t           - t   %e
          t  (- ----- - ----- + %e   ) - t (2 %e    - -----),
                  t       2                             t
                         t
                - t     - t                 - t
           2  %e      %e            - t   %e
          t  (----- - -----) - t (%e    - -----)])
                2       t                   t
          (%i4) ratsimp(%);
                         [   2              - t ]
                         [ (t  + 2 t + 2) %e    ]
                         [ -------------------- ]
                         [          2           ]
                         [                      ]
                         [         2   - t      ]
          (%o4)  Col 1 = [        t  %e         ]
                         [      - --------      ]
                         [           2          ]
                         [                      ]
                         [     2          - t   ]
                         [   (t  - 2 t) %e      ]
                         [   ----------------   ]
                         [          2           ]
                   [      2        - t    ]
                   [    (t  + t) %e       ]
                   [                      ]
           Col 2 = [     2            - t ]
                   [ - (t  - t - 1) %e    ]
                   [                      ]
                   [     2          - t   ]
                   [   (t  - 3 t) %e      ]
                   [        2   - t       ]
                   [       t  %e          ]
                   [       --------       ]
                   [          2           ]
                   [                      ]
                   [      2          - t  ]
           Col 3 = [    (t  - 2 t) %e     ]
                   [  - ----------------  ]
                   [           2          ]
                   [                      ]
                   [   2              - t ]
                   [ (t  - 4 t + 2) %e    ]
                   [ -------------------- ]
                   [          2           ]

     Ejemplo 2:
          (%i5) b1:matrix([0,0,1,1,1],
                          [0,0,0,1,1],
                          [0,0,0,0,1],
                          [0,0,0,0,0],
                          [0,0,0,0,0])$

          (%i6) mat_function(exp,t*b1);
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o6)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i7) minimalPoly(jordan(b1));
                                       3
          (%o7)                       x
          (%i8) ident(5)+t*b1+1/2*(t^2)*b1^^2;
                            [              2     ]
                            [             t      ]
                            [ 1  0  t  t  -- + t ]
                            [             2      ]
                            [                    ]
          (%o8)             [ 0  1  0  t    t    ]
                            [                    ]
                            [ 0  0  1  0    t    ]
                            [                    ]
                            [ 0  0  0  1    0    ]
                            [                    ]
                            [ 0  0  0  0    1    ]
          (%i9) mat_function(exp,%i*t*b1);
                       [                           2 ]
                       [                          t  ]
                       [ 1  0  %i t  %i t  %i t - -- ]
                       [                          2  ]
                       [                             ]
          (%o9)        [ 0  1   0    %i t    %i t    ]
                       [                             ]
                       [ 0  0   1     0      %i t    ]
                       [                             ]
                       [ 0  0   0     1        0     ]
                       [                             ]
                       [ 0  0   0     0        1     ]
          (%i10) mat_function(cos,t*b1)+%i*mat_function(sin,t*b1);
                        [                           2 ]
                        [                          t  ]
                        [ 1  0  %i t  %i t  %i t - -- ]
                        [                          2  ]
                        [                             ]
          (%o10)        [ 0  1   0    %i t    %i t    ]
                        [                             ]
                        [ 0  0   1     0      %i t    ]
                        [                             ]
                        [ 0  0   0     1        0     ]
                        [                             ]
                        [ 0  0   0     0        1     ]

     Ejemplo 3:
          (%i11) a1:matrix([2,1,0,0,0,0],
                           [-1,4,0,0,0,0],
                           [-1,1,2,1,0,0],
                           [-1,1,-1,4,0,0],
                           [-1,1,-1,1,3,0],
                           [-1,1,-1,1,1,2])$

          (%i12) fpow(x):=block([k],declare(k,integer),x^k)$

          (%i13) mat_function(fpow,a1);
                          [  k      k - 1 ]         [      k - 1    ]
                          [ 3  - k 3      ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [  k      k - 1 ]
                          [  - k 3        ]         [ 3  + k 3      ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
          (%o13)  Col 1 = [               ] Col 2 = [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                          [               ]         [               ]
                          [       k - 1   ]         [      k - 1    ]
                          [  - k 3        ]         [   k 3         ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [       0       ]         [       0       ]
                   [               ]         [               ]
                   [  k      k - 1 ]         [      k - 1    ]
                   [ 3  - k 3      ]         [   k 3         ]
                   [               ]         [               ]
           Col 3 = [       k - 1   ] Col 4 = [  k      k - 1 ]
                   [  - k 3        ]         [ 3  + k 3      ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [               ]         [               ]
                   [       k - 1   ]         [      k - 1    ]
                   [  - k 3        ]         [   k 3         ]
                   [    0    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
                   [    0    ]         [    ]
                   [         ]         [ 0  ]
           Col 5 = [    0    ] Col 6 = [    ]
                   [         ]         [ 0  ]
                   [    k    ]         [    ]
                   [   3     ]         [ 0  ]
                   [         ]         [    ]
                   [  k    k ]         [  k ]
                   [ 3  - 2  ]         [ 2  ]

     Antes de hacer uso de esta función ejecútese ‘load("diag")’.


File: maxima.info,  Node: distrib,  Next: draw,  Prev: diag,  Up: Top

46 distrib
**********

* Menu:

* Introducción a distrib::
* Funciones y variables para distribuciones continuas::
* Funciones y variables para distribuciones discretas::


File: maxima.info,  Node: Introducción a distrib,  Next: Funciones y variables para distribuciones continuas,  Prev: distrib,  Up: distrib

46.1 Introducción a distrib
===========================

El paquete ‘distrib’ contiene un conjunto de funciones para la
realización de cálculos probabilísticos con modelos univariantes, tanto
discretos como continuos.

A continuación un breve recordatorio de las deficiones básicas sobre
distribuciones de probabilidad.

Sea f(x) la <función de densidad> de una variable aleatoria X
absolutamente continua.  La <función de distribución> se define como
                            x
                           /
                           [
                    F(x) = I     f(u) du
                           ]
                           /
                            minf
que es igual a la probabilidad <Pr(X <= x)>.

La <media> es un parámetro de localización y se define como
                          inf
                         /
                         [
                E[X]  =  I   x f(x) dx
                         ]
                         /
                          minf

La <varianza> es una medida de dispersión,
                      inf
                     /
                     [                    2
              V[X] = I     f(x) (x - E[X])  dx
                     ]
                     /
                      minf
que es un número real positivo.  La raíz cuadrada de la varianza es la
<desviación típica>, D[X]=sqrt(V[X]), siendo otra medida de dispersión.

El <coeficiente de asimetría> es una medida de forma,
                      inf
                     /
                 1   [                    3
       SK[X] = ----- I     f(x) (x - E[X])  dx
                   3 ]
               D[X]  /
                      minf

Y el <coeficiente de curtosis> mide el apuntamiento de la densidad,
                      inf
                     /
                 1   [                    4
       KU[X] = ----- I     f(x) (x - E[X])  dx - 3
                   4 ]
               D[X]  /
                      minf
Si X es normal, KU[X]=0.  De hecho, tanto la asimetría como la curtosis
son parámetros de forma para medir la no normalidad de una distribución.

Si la variable aleatoria X es discreta, su función de densidad, o de
<probabiliad>, f(x) toma valores positivos dentro de un conjunto
numerable de valores x_i, y cero en cualquier otro lugar.  En este caso,
la función de distribución es
                            ====
                            \
                     F(x) =  >    f(x )
                            /        i
                            ====
                           x <= x
                            i

La media, varianza, desviación típica y los coeficientes de asimetría y
curtosis adquieren las formas
                            ====
                            \
                     E[X] =  >  x  f(x ) ,
                            /    i    i
                            ====
                             x
                              i

                     ====
                     \                     2
             V[X] =   >    f(x ) (x - E[X])  ,
                     /        i    i
                     ====
                      x
                       i

                    D[X] = sqrt(V[X]),

                          ====
                   1      \                     3
       SK[X] =  -------    >    f(x ) (x - E[X])
                D[X]^3    /        i    i
                          ====
                           x
                            i
y
                          ====
                   1      \                     4
       KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
                D[X]^4    /        i    i
                          ====
                           x
                            i
respectivamente.

Por favor, consúltese cualquier manual introductorio de probabilidad y
estadística para más información sobre toda esta parafernalia
matemática.

Se sigue cierta convención a la hora de nombrar las funciones del
paquete ‘distrib’.  Cada nombre tiene dos partes, el primero hace
referencia a la función o parámetro que se quiere calcular,
     Funciones:
        Función de densidad        (pdf_*)
        Función de distribución    (cdf_*)
        Cuantil                    (quantile_*)
        Media                      (mean_*)
        Varianza                   (var_*)
        Desviación típica          (std_*)
        Coeficiente de asimetría   (skewness_*)
        Coeficiente de curtosis    (kurtosis_*)
        Valor aleatorio            (random_*)

La segunda parte hace referencia explícita al modelo probabilístico,
     Distribuciones continuas:
        Normal              (*normal)
        Student             (*student_t)
        Chi^2               (*chi2)
        Chi^2 no central    (*noncentral_chi2)
        F                   (*f)
        Exponencial         (*exp)
        Lognormal           (*lognormal)
        Gamma               (*gamma)
        Beta                (*beta)
        Continua uniforme   (*continuous_uniform)
        Logística           (*logistic)
        Pareto              (*pareto)
        Weibull             (*weibull)
        Rayleigh            (*rayleigh)
        Laplace             (*laplace)
        Cauchy              (*cauchy)
        Gumbel              (*gumbel)

     Distribuciones discretas:
        Binomial             (*binomial)
        Poisson              (*poisson)
        Bernoulli            (*bernoulli)
        Geométrica           (*geometric)
        Uniforme discreta    (*discrete_uniform)
        Hipergeométrica      (*hypergeometric)
        Binomial negativa    (*negative_binomial)
        Finita discreta      (*general_finite_discrete)

Por ejemplo, ‘pdf_student_t(x,n)’ es la función de densidad de la
distribución de Student con <n> grados de libertad, ‘std_pareto(a,b)’ es
la desviación típica de la distribución de Pareto de parámetros <a> y
<b>, y ‘kurtosis_poisson(m)’ es el coeficiente de curtosis de la
distribución de Poisson de media <m>.

Para poder hacer uso del paquete ‘distrib’ es necesario cargarlo primero
tecleando
     (%i1) load("distrib")$

Para comentarios, errores o sugerencias, por favor contáctese conmigo en
<’riotorto AT yahoo DOT com’>.


File: maxima.info,  Node: Funciones y variables para distribuciones continuas,  Next: Funciones y variables para distribuciones discretas,  Prev: Introducción a distrib,  Up: distrib

46.2 Funciones y variables para distribuciones continuas
========================================================

 -- Función: pdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de la variable aleatoria Normal(m,s), con s>0.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_normal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de la variable aleatoria Normal(m,s), con s>0.  Esta
     función se define en términos de la función de error, ‘erf’, de
     Maxima.

          (%i1) load ("distrib")$
          (%i2) cdf_normal(x,m,s);
                                              x - m
                                        erf(---------)
                                            sqrt(2) s    1
          (%o2)                         -------------- + -
                                              2          2

     Véase también ‘erf’.

 -- Función: quantile_normal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Normal(m,s), con
     s>0; en otras palabras, es la inversa de ‘cdf_normal’.  El
     argumento <q> debe ser un número de [0,1].  Para hacer uso de esta
     función, ejecútese primero ‘load("distrib")’.

          (%i1) load ("distrib")$
          (%i2) quantile_normal(95/100,0,1);
                                                9
          (%o2)             sqrt(2) inverse_erf(--)
                                                10
          (%i3) float(%);
          (%o3)               1.644853626951472

 -- Función: mean_normal (<m>,<s>)
     Devuelve la media de una variable aleatoria Normal(m,s), con s>0,
     es decir <m>.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_normal (<m>,<s>)
     Devuelve la varianza de una variable aleatoria Normal(m,s), con
     s>0, es decir <s^2>.

 -- Función: std_normal (<m>,<s>)
     Devuelve la desviación típica de una variable aleatoria
     Normal(m,s), con s>0, es decir <s>.  Para hacer uso de esta
     función, ejecútese primero ‘load("distrib")’.

 -- Función: skewness_normal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_normal (<m>,<s>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Normal(m,s), con s>0, que es siempre igual a 0.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: random_normal (<m>,<s>)
 -- Función: random_normal (<m>,<s>,<n>)
     Devuelve un valor aleatorio Normal(m,s), con s>0.  Llamando a
     ‘random_normal’ con un tercer argumento <n>, se simula una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el de Box-Mueller, tal como está
     descrito en Knuth, D.E. (1981) <Seminumerical Algorithms.  The Art
     of Computer Programming.> Addison-Wesley.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Student t(n), con n>0.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_student_t (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Student t(n), con n>0.

          (%i1) load ("distrib")$
          (%i2) cdf_student_t(1/2, 7/3);
                                                   7  1  28
                       beta_incomplete_regularized(-, -, --)
                                                   6  2  31
          (%o2)    1 - -------------------------------------
                                         2
          (%i3) float(%);
          (%o3)                .6698450596140415

 -- Función: quantile_student_t (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria de Student t(n),
     con n>0; en otras palabras, se trata de la inversa de
     ‘cdf_student_t’.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_student_t (<n>)
     Devuelve la media de una variable aleatoria de Student t(n), con
     n>0, que vale siempre 0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: var_student_t (<n>)
     Devuelve la varianza de una variable aleatoria de Student t(n), con
     n>2.

          (%i1) load ("distrib")$
          (%i2) var_student_t(n);
                                          n
          (%o2)                         -----
                                        n - 2

 -- Función: std_student_t (<n>)
     Devuelve la desviación típica de una variable aleatoria de Student
     t(n), con n>2.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: skewness_student_t (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Student t(n), con n>3, que vale siempre 0.  Para hacer uso de esta
     función, ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_student_t (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Student t(n), con n>4.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_student_t (<n>)
 -- Función: random_student_t (<n>,<m>)
     Devuelve un valor aleatorio t(n), con n>0.  Llamando a
     ‘random_student_t’ con un segundo argumento <m>, se obtiene una
     muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <Z> es una
     variable aleatoria normal N(0,1) y S^2 es una chi cuadrada de <n>
     grados de libertad, Chi^2(n), entonces
                                     Z
                           X = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria de Student de <n> grados de libertad,
     t(n).

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria no central de Student nc_t(n,ncp), con
     n>0 grados de libertad y parámetro de no centralidad ncp.  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

     En ocasiones es necesario hacer algún trabajo extra para obtener el
     resultado final.

          (%i1) load ("distrib")$
          (%i2) expand(pdf_noncentral_student_t(3,5,0.1));
                                     7/2                         7/2
                0.04296414417400905 5      1.323650307289301e-6 5
          (%o2) ------------------------ + -------------------------
                   3/2   5/2                       sqrt(%pi)
                  2    14    sqrt(%pi)
                                                                  7/2
                                             1.94793720435093e-4 5
                                           + ------------------------
                                                       %pi
          (%i3) float(%);
          (%o3)          .02080593159405669

 -- Función: cdf_noncentral_student_t (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp.  Esta función no tiene expresión compacta y se
     calcula numéricamente.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

          (%i1) load ("distrib")$
          (%i2) cdf_noncentral_student_t(-2,5,-5);
          (%o2)          .9952030093319743

 -- Función: quantile_noncentral_student_t (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>0 grados de libertad y parámetro de no
     centralidad ncp; en otras palabras, se trata de la inversa de
     ‘cdf_noncentral_student_t’.  El argumento <q> debe ser un número de
     [0,1].  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_noncentral_student_t (<n>,<ncp>)
     Devuelve la media de una variable aleatoria no central de Student
     nc_t(n,ncp), con n>1 grados de libertad y parámetro de no
     centralidad ncp.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

          (%i1) load ("distrib")$
          (%i2) mean_noncentral_student_t(df,k);
                             df - 1
                       gamma(------) sqrt(df) k
                               2
          (%o2)        ------------------------
                                        df
                          sqrt(2) gamma(--)
                                        2

 -- Función: var_noncentral_student_t (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria no central de
     Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de no
     centralidad ncp.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_noncentral_student_t (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria no central
     de Student nc_t(n,ncp), con n>2 grados de libertad y parámetro de
     no centralidad ncp.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>3 grados de libertad y
     parámetro de no centralidad ncp.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_noncentral_student_t (<n>,<ncp>)
     Devuelve el coeficiente de curtosis de una variable aleatoria no
     central de Student nc_t(n,ncp), con n>4 grados de libertad y
     parámetro de no centralidad ncp.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: random_noncentral_student_t (<n>,<ncp>)
 -- Función: random_noncentral_student_t (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_t(n,ncp), con n>0.  Llamando a
     ‘random_noncentral_student_t’ con un tercer argumento <m>, se
     obtiene una muestra aleatoria simulada de tamaño <m>.

     El algoritmo utilizado está basado en el hecho de que si <X> es una
     variable aleatoria normal N(ncp,1) y S^2 es una chi cuadrada de <n>
     grados de libertad, Chi^2(n), entonces
                                     X
                           U = -------------
                               /   2  \ 1/2
                               |  S   |
                               | ---  |
                               \  n   /

     es una variable aleatoria no central de Student de <n> grados de
     libertad y parámetro de no centralidad ncp, nc_t(n,ncp).

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado Chi^2(n), con n>0.  La
     variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load ("distrib")$
          (%i2) pdf_chi2(x,n);
                                   n/2 - 1   - x/2
                                  x        %e
          (%o2)                   ----------------
                                    n/2       n
                                   2    gamma(-)
                                              2

 -- Función: cdf_chi2 (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado Chi^2(n), con
     n>0.

          (%i1) load ("distrib")$
          (%i2) cdf_chi2(3,4);
                                                         3
          (%o2)      1 - gamma_incomplete_regularized(2, -)
                                                         2
          (%i3) float(%);
          (%o3)               .4421745996289256

 -- Función: quantile_chi2 (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Chi^2(n), con
     n>0; en otras palabras, se trata de la inversa de ‘cdf_chi2’.  El
     argumento <q> debe ser un número de [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente.

          (%i1) load ("distrib")$
          (%i2) quantile_chi2(0.99,9);
          (%o2)                   21.66599433346194

 -- Función: mean_chi2 (<n>)
     Devuelve la media de una variable aleatoria Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load ("distrib")$
          (%i2) mean_chi2(n);
          (%o2)                           n

 -- Función: var_chi2 (<n>)
     Devuelve la varianza de una variable aleatoria Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load ("distrib")$
          (%i2) var_chi2(n);
          (%o2)                          2 n

 -- Función: std_chi2 (<n>)
     Devuelve la desviación típica de una variable aleatoria Chi^2(n),
     con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load ("distrib")$
          (%i2) std_chi2(n);
          (%o2)                    sqrt(2) sqrt(n)

 -- Función: skewness_chi2 (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load ("distrib")$
          (%i2) skewness_chi2(n);
                                               3/2
                                              2
          (%o2)                              -------
                                             sqrt(n)

 -- Función: kurtosis_chi2 (<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Chi^2(n), con n>0.

     La variable aleatoria Chi^2(n) equivale a una Gamma(n/2,2).

          (%i1) load ("distrib")$
          (%i2) kurtosis_chi2(n);
                                         12
          (%o2)                          --
                                         n

 -- Función: random_chi2 (<n>)
 -- Función: random_chi2 (<n>,<m>)
     Devuelve un valor aleatorio Chi^2(n), con n>0.  Llamando a
     ‘random_chi2’ con un segundo argumento <m>, se simulará una muestra
     aleatoria de tamaño <m>.

     La simulación está basada en el algoritmo de Ahrens-Cheng.  Véase
     ‘random_gamma’ para más detalles.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria chi-cuadrado no centrada nc_Chi^2(n,ncp),
     con n>0 y parámetro de no centralidad ncp>=0.  Para hacer uso de
     esta función ejecútese primero ‘load("distrib")’.

 -- Función: cdf_noncentral_chi2 (<x>,<n>,<ncp>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria chi-cuadrado no centrada
     nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad ncp>=0.

 -- Función: quantile_noncentral_chi2 (<q>,<n>,<ncp>)
     Devuelve el <q>-cuantil de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0; en otras palabras, se trata de la inversa de
     ‘cdf_noncentral_chi2’.  El argumento <q> debe ser un número de
     [0,1].

     Esta función no tiene expresión compacta y se calcula
     numéricamente.

 -- Función: mean_noncentral_chi2 (<n>,<ncp>)
     Devuelve la media de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.

 -- Función: var_noncentral_chi2 (<n>,<ncp>)
     Devuelve la varianza de una variable aleatoria chi-cuadrado no
     centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no centralidad
     ncp>=0.

 -- Función: std_noncentral_chi2 (<n>,<ncp>)
     Devuelve la desviación típica de una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no
     centralidad ncp>=0.

 -- Función: skewness_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no
     centralidad ncp>=0.

 -- Función: kurtosis_noncentral_chi2 (<n>,<ncp>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     chi-cuadrado no centrada nc_Chi^2(n,ncp), con n>0 y parámetro de no
     centralidad ncp>=0.

 -- Función: random_noncentral_chi2 (<n>,<ncp>)
 -- Función: random_noncentral_chi2 (<n>,<ncp>,<m>)
     Devuelve un valor aleatorio nc_Chi^2(n,ncp), con n>0 y parámetro de
     no centralidad ncp>=0.  Llamando a ‘random_noncentral_chi2’ con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria F(m,n), con m,n>0.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_f (<x>,<m>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria F(m,n), con m,n>0.

          (%i1) load ("distrib")$
          (%i2) cdf_f(2,3,9/4);
                                                   9  3  3
          (%o2)    1 - beta_incomplete_regularized(-, -, --)
                                                   8  2  11
          (%i3) float(%);
          (%o3)                 0.66756728179008

 -- Función: quantile_f (<q>,<m>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria F(m,n), con
     m,n>0; en otras palabras, se trata de la inversa de ‘cdf_f’.  El
     argumento <q> debe ser un número de [0,1].

          (%i1) load ("distrib")$
          (%i2) quantile_f(2/5,sqrt(3),5);
                                         2
          (%o2)               quantile_f(-, sqrt(3), 5)
                                         5
          (%i3) %,numer;
          (%o3)                   0.518947838573693

 -- Función: mean_f (<m>,<n>)
     Devuelve la media de una variable aleatoria F(m,n), con m>0, n>2.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_f (<m>,<n>)
     Devuelve la varianza de una variable aleatoria F(m,n), con m>0,
     n>4.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_f (<m>,<n>)
     Devuelve la desviación típica de una variable aleatoria F(m,n), con
     m>0, n>4.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: skewness_f (<m>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     F(m,n), con m>0, n>6.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_f (<m>,<n>)
     Devuelve el coeficiente de curtosis una variable aleatoria F(m,n),
     con m>0, n>8.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: random_f (<m>,<n>)
 -- Función: random_f (<m>,<n>,<k>)
     Devuelve un valor aleatorio F(m,n), con m,n>0.  Llamando a
     ‘random_f’ con un tercer argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el hecho de que si <X> es
     una variable aleatoria Chi^2(m) y Y es una Chi^2(n), entonces
                                  n X
                              F = ---
                                  m Y

     es una variable aleatoria F con <m> y <n> grados de libertad,
     F(m,n).

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) pdf_exp(x,m);
                                          - m x
          (%o2)                       m %e

 -- Función: cdf_exp (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) cdf_exp(x,m);
                                           - m x
          (%o2)                      1 - %e

 -- Función: quantile_exp (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria Exponencial(m),
     con m>0; en otras palabras, se trata de la inversa de ‘cdf_exp’.
     El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) quantile_exp(0.56,5);
          (%o2)                   .1641961104139661
          (%i3) quantile_exp(0.56,m);
                                                      1
          (%o3)             quantile_weibull(0.56, 1, -)
                                                      m

 -- Función: mean_exp (<m>)
     Devuelve la media de una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) mean_exp(m);
                                          1
          (%o2)                           -
                                          m

 -- Función: var_exp (<m>)
     Devuelve la varianza de una variable aleatoria Exponencial(m), con
     m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) var_exp(m);
                                         1
          (%o2)                          --
                                          2
                                         m

 -- Función: std_exp (<m>)
     Devuelve la desviación típica de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) std_exp(m);
                                          1
          (%o2)                           -
                                          m

 -- Función: skewness_exp (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) skewness_exp(m);
          (%o2)                           2

 -- Función: kurtosis_exp (<m>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Exponencial(m), con m>0.

     La variable aleatoria Exponencial(m) equivale a una Weibull(1,1/m).

          (%i1) load ("distrib")$
          (%i2) kurtosis_exp(m);
          (%o3)                           6

 -- Función: random_exp (<m>)
 -- Función: random_exp (<m>,<k>)
     Devuelve un valor aleatorio Exponencial(m), con m>0.  Llamando a
     ‘random_exp2’ con un segundo argumento <k>, se simulará una muestra
     aleatoria de tamaño <k>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Lognormal(m,s), con s>0.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_lognormal (<x>,<m>,<s>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Lognormal(m,s), con s>0.
     Esta función se define en términos de la función de error, ‘erf’,
     de Maxima.

          (%i1) load ("distrib")$
          (%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                                     log(x) - m
                                 erf(----------)
                                     sqrt(2) s     1
          (%o2)                  --------------- + -
                                        2          2

     Véase también ‘erf’.

 -- Función: quantile_lognormal (<q>,<m>,<s>)
     Devuelve el <q>-cuantil de una variable aleatoria Lognormal(m,s),
     con s>0; en otras palabras, se trata de la inversa de
     ‘cdf_lognormal’.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_lognormal (<m>,<s>)
     Devuelve la media de una variable aleatoria Lognormal(m,s), con
     s>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_lognormal (<m>,<s>)
     Devuelve la varianza de una variable aleatoria Lognormal(m,s), con
     s>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_lognormal (<m>,<s>)
     Devuelve la desviación típica de una variable aleatoria
     Lognormal(m,s), con s>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_lognormal (<m>,<s>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Lognormal(m,s), con s>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_lognormal (<m>,<s>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Lognormal(m,s), con s>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_lognormal (<m>,<s>)
 -- Función: random_lognormal (<m>,<s>,<n>)
     Devuelve un valor aleatorio Lognormal(m,s), con s>0.  Llamando a
     ‘random_lognormal’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     Las variables lognormales se simulan mediante variables normales.
     Véase ‘random_normal’ para más detalles.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Gamma(a,b), con a,b>0.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_gamma (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Gamma(a,b), con a,b>0.

          (%i1) load ("distrib")$
          (%i2) cdf_gamma(3,5,21);
                                                        1
          (%o2)     1 - gamma_incomplete_regularized(5, -)
                                                        7
          (%i3) float(%);
          (%o3)              4.402663157376807E-7

 -- Función: quantile_gamma (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Gamma(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de ‘cdf_gamma’.
     El argumento <q> debe ser un número de [0,1].  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_gamma (<a>,<b>)
     Devuelve la media de una variable aleatoria Gamma(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_gamma (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Gamma(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_gamma (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria Gamma(a,b),
     con a,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: skewness_gamma (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Gamma(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_gamma (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Gamma(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_gamma (<a>,<b>)
 -- Función: random_gamma (<a>,<b>,<n>)
     Devuelve un valor aleatorio Gamma(a,b), con a,b>0.  Llamando a
     ‘random_gamma’ con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es una combinación de dos
     procedimientos, según sea el valor del parámetro <a>:

     Para a>=1, Cheng, R.C.H. y Feast, G.M. (1979).  <Some simple gamma
     variate generators>.  Appl.  Stat., 28, 3, 290-295.

     Para 0<a<1, Ahrens, J.H. y Dieter, U. (1974).  <Computer methods
     for sampling from gamma, beta, poisson and binomial distributions>.
     Computing, 12, 223-246.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Beta(a,b), con a,b>0.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_beta (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Beta(a,b), con a,b>0.

          (%i1) load ("distrib")$
          (%i2) cdf_beta(1/3,15,2);
                                       11
          (%o2)                     --------
                                    14348907
          (%i3) float(%);
          (%o3)              7.666089131388195E-7

 -- Función: quantile_beta (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Beta(a,b), con
     a,b>0; en otras palabras, se trata de la inversa de ‘cdf_beta’.  El
     argumento <q> debe ser un número de [0,1].  Para hacer uso de esta
     función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_beta (<a>,<b>)
     Devuelve la media de una variable aleatoria Beta(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_beta (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Beta(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_beta (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria Beta(a,b),
     con a,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: skewness_beta (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Beta(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_beta (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Beta(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_beta (<a>,<b>)
 -- Función: random_beta (<a>,<b>,<n>)
     Devuelve un valor aleatorio Beta(a,b), con a,b>0.  Llamando a
     ‘random_beta’ con un tercer argumento <n>, se simulará una muestra
     aleatoria de tamaño <n>.

     El algoritmo de simulación es el decrito en Cheng, R.C.H. (1978).
     <Generating Beta Variates with Nonintegral Shape Parameters>.
     Communications of the ACM, 21:317-322.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Uniforme Continua(a,b), con a<b.  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_continuous_uniform (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Continua(a,b), con
     a<b.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_continuous_uniform (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Continua(a,b), con a<b; en otras palabras, se trata de la inversa
     de ‘cdf_continuous_uniform’.  El argumento <q> debe ser un número
     de [0,1].  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_continuous_uniform (<a>,<b>)
     Devuelve la media de una variable aleatoria Uniforme Continua(a,b),
     con a<b.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_continuous_uniform (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Uniforme
     Continua(a,b), con a<b.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: std_continuous_uniform (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria Uniforme
     Continua(a,b), con a<b.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Continua(a,b), con a<b.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_continuous_uniform (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria Uniforme
     Continua(a,b), con a<b.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_continuous_uniform (<a>,<b>)
 -- Función: random_continuous_uniform (<a>,<b>,<n>)
     Devuelve un valor aleatorio Uniforme Continuo(a,b), con a<b.
     Llamando a ‘random_continuous_uniform’ con un tercer argumento <n>,
     se simulará una muestra aleatoria de tamaño <n>.

     Esta función es una aplicación directa de la función ‘random’ de
     Maxima.

     Véase también ‘random’.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: pdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria Logística(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_logistic (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Logística(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_logistic (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria Logística(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     ‘cdf_logistic’.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_logistic (<a>,<b>)
     Devuelve la media de una variable aleatoria Logística(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_logistic (<a>,<b>)
     Devuelve la varianza de una variable aleatoria Logística(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_logistic (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria
     Logística(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_logistic (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Logística(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_logistic (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria
     Logística(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_logistic (<a>,<b>)
 -- Función: random_logistic (<a>,<b>,<n>)
     Devuelve un valor aleatorio Logístico(a,b), con b>0.  Llamando a
     ‘random_logistic’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Pareto(a,b), con a,b>0.  Para hacer
     uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_pareto (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Pareto(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_pareto (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Pareto(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     ‘cdf_pareto’.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_pareto (<a>,<b>)
     Devuelve la media de una variable aleatoria de Pareto(a,b), con
     a>1,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_pareto (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Pareto(a,b), con
     a>2,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_pareto (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Pareto(a,b), con a>2,b>0.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: skewness_pareto (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Pareto(a,b), con a>3,b>0.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_pareto (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Pareto(a,b), con a>4,b>0.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: random_pareto (<a>,<b>)
 -- Función: random_pareto (<a>,<b>,<n>)
     Devuelve un valor aleatorio Pareto(a,b), con a>0,b>0.  Llamando a
     ‘random_pareto’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Weibull(a,b), con a,b>0.  Para hacer
     uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_weibull (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Weibull(a,b), con a,b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_weibull (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Weibull(a,b),
     con a,b>0; en otras palabras, se trata de la inversa de
     ‘cdf_weibull’.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_weibull (<a>,<b>)
     Devuelve la media de una variable aleatoria de Weibull(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_weibull (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Weibull(a,b), con
     a,b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_weibull (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Weibull(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_weibull (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Weibull(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_weibull (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Weibull(a,b), con a,b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_weibull (<a>,<b>)
 -- Función: random_weibull (<a>,<b>,<n>)
     Devuelve un valor aleatorio Weibull(a,b), con a,b>0.  Llamando a
     ‘random_weibull’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) pdf_rayleigh(x,b);
                                              2  2
                                     2     - b  x
          (%o2)                   2 b  x %e

 -- Función: cdf_rayleigh (<x>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) cdf_rayleigh(x,b);
                                             2  2
                                          - b  x
          (%o2)                     1 - %e

 -- Función: quantile_rayleigh (<q>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Rayleigh(b),
     con b>0; en otras palabras, se trata de la inversa de
     ‘cdf_rayleigh’.  El argumento <q> debe ser un número de [0,1].

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) quantile_rayleigh(0.99,b);
                                  2.145966026289347
          (%o2)                   -----------------
                                          b

 -- Función: mean_rayleigh (<b>)
     Devuelve la media de una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) mean_rayleigh(b);
                                      sqrt(%pi)
          (%o2)                       ---------
                                         2 b

 -- Función: var_rayleigh (<b>)
     Devuelve la varianza de una variable aleatoria de Rayleigh(b), con
     b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) var_rayleigh(b);
                                           %pi
                                       1 - ---
                                            4
          (%o2)                        -------
                                          2
                                         b

 -- Función: std_rayleigh (<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) std_rayleigh(b);
                                             %pi
                                    sqrt(1 - ---)
                                              4
          (%o2)                     -------------
                                          b

 -- Función: skewness_rayleigh (<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) skewness_rayleigh(b);
                                   3/2
                                %pi      3 sqrt(%pi)
                                ------ - -----------
                                  4           4
          (%o2)                 --------------------
                                         %pi 3/2
                                    (1 - ---)
                                          4

 -- Función: kurtosis_rayleigh (<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Rayleigh(b), con b>0.

     La variable aleatoria Rayleigh(b) equivale a una Weibull(2,1/b).

          (%i1) load ("distrib")$
          (%i2) kurtosis_rayleigh(b);
                                            2
                                       3 %pi
                                   2 - ------
                                         16
          (%o2)                    ---------- - 3
                                        %pi 2
                                   (1 - ---)
                                         4

 -- Función: random_rayleigh (<b>)
 -- Función: random_rayleigh (<b>,<n>)
     Devuelve un valor aleatorio Rayleigh(b), con b>0.  Llamando a
     ‘random_rayleigh’ con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Laplace(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_laplace (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Laplace(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_laplace (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Laplace(a,b),
     con b>0; en otras palabras, se trata de la inversa de
     ‘cdf_laplace’.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_laplace (<a>,<b>)
     Devuelve la media de una variable aleatoria de Laplace(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_laplace (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Laplace(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_laplace (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Laplace(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_laplace (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Laplace(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_laplace (<a>,<b>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Laplace(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_laplace (<a>,<b>)
 -- Función: random_laplace (<a>,<b>,<n>)
     Devuelve un valor aleatorio Laplace(a,b), con b>0.  Llamando a
     ‘random_laplace’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Cauchy(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_cauchy (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Cauchy(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_cauchy (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Cauchy(a,b),
     con b>0; en otras palabras, se trata de la inversa de ‘cdf_cauchy’.
     El argumento <q> debe ser un número de [0,1].  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: random_cauchy (<a>,<b>)
 -- Función: random_cauchy (<a>,<b>,<n>)
     Devuelve un valor aleatorio Cauchy(a,b), con b>0.  Llamando a
     ‘random_cauchy’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria de Gumbel(a,b), con b>0.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: cdf_gumbel (<x>,<a>,<b>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Gumbel(a,b), con b>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_gumbel (<q>,<a>,<b>)
     Devuelve el <q>-cuantil de una variable aleatoria de Gumbel(a,b),
     con b>0; en otras palabras, se trata de la inversa de ‘cdf_gumbel’.
     El argumento <q> debe ser un número de [0,1].  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_gumbel (<a>,<b>)
     Devuelve la media de una variable aleatoria de Gumbel(a,b), con
     b>0.

          (%i1) load ("distrib")$
          (%i2) mean_gumbel(a,b);
          (%o2)                     %gamma b + a
     donde el símbolo ‘%gamma’ representa la constante de
     Euler-Mascheroni.  Véase también ‘%gamma’.

 -- Función: var_gumbel (<a>,<b>)
     Devuelve la varianza de una variable aleatoria de Gumbel(a,b), con
     b>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_gumbel (<a>,<b>)
     Devuelve la desviación típica de una variable aleatoria de
     Gumbel(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_gumbel (<a>,<b>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Gumbel(a,b), con b>0.

          (%i1) load ("distrib")$
          (%i2) skewness_gumbel(a,b);
                                            3/2
                                         2 6    zeta(3)
          (%o2)                          --------------
                                                 3
                                              %pi
     donde ‘zeta’ representa la función zeta de Riemann.

 -- Función: kurtosis_gumbel (<a>,<b>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Gumbel(a,b), con b>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_gumbel (<a>,<b>)
 -- Función: random_gumbel (<a>,<b>,<n>)
     Devuelve un valor aleatorio Gumbel(a,b), con b>0.  Llamando a
     ‘random_gumbel’ con un tercer argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación está basado en el método inverso.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.


File: maxima.info,  Node: Funciones y variables para distribuciones discretas,  Prev: Funciones y variables para distribuciones continuas,  Up: distrib

46.3 Funciones y variables para distribuciones discretas
========================================================

 -- Función: pdf_general_finite_discrete (<x>,<v>)
     Devuelve el valor correspondiente a <x> de la función de densidad
     de una variable aleatoria general discreta finita, con vector de
     probabilidades v, tal que ‘Pr(X=i) = v_i’.  El vector v puede ser
     una lista de expresiones no negativas, cuyas componentes se
     normalizarán para obtener un vector de probabilidades.  Para hacer
     uso de esta función, ejecútese primero ‘load("distrib")’.

          (%i1) load ("distrib")$
          (%i2) pdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          4
          (%o2)                           -
                                          7
          (%i3) pdf_general_finite_discrete(2, [1, 4, 2]);
                                          4
          (%o3)                           -
                                          7

 -- Función: cdf_general_finite_discrete (<x>,<v>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria general discreta finita, con
     vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

          (%i1) load ("distrib")$
          (%i2) cdf_general_finite_discrete(2, [1/7, 4/7, 2/7]);
                                          5
          (%o2)                           -
                                          7
          (%i3) cdf_general_finite_discrete(2, [1, 4, 2]);
                                          5
          (%o3)                           -
                                          7
          (%i4) cdf_general_finite_discrete(2+1/2, [1, 4, 2]);
                                          5
          (%o4)                           -
                                          7

 -- Función: quantile_general_finite_discrete (<q>,<v>)
     Devuelve el <q>-cuantil de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

 -- Función: mean_general_finite_discrete (<v>)
     Devuelve la media de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

 -- Función: var_general_finite_discrete (<v>)
     Devuelve la varianza de una variable aleatoria general discreta
     finita, con vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

 -- Función: std_general_finite_discrete (<v>)
     Devuelve la desviación típica de una variable aleatoria general
     discreta finita, con vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

 -- Función: skewness_general_finite_discrete (<v>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     general discreta finita, con vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

 -- Función: kurtosis_general_finite_discrete (<v>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     general discreta finita, con vector de probabilidades v.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

 -- Función: random_general_finite_discrete (<v>)
 -- Función: random_general_finite_discrete (<v>,<m>)
     Devuelve un valor aleatorio de una variable aleatoria general
     discreta finita, con vector de probabilidades v.  Llamando a
     ‘random_general_finite_discrete’ con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     Véase ‘pdf_general_finite_discrete’ para más detalles.

          (%i1) load ("distrib")$
          (%i2) random_general_finite_discrete([1,3,1,5]);
          (%o2)                          4
          (%i3) random_general_finite_discrete([1,3,1,5], 10);
          (%o3)           [4, 2, 2, 3, 2, 4, 4, 1, 2, 2]

 -- Función: pdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial(n,p), con 0 \leq p
     \leq 1 y n entero positivo.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: cdf_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial(n,p), con 0 \leq p
     \leq 1 y n entero positivo.

          (%i1) load ("distrib")$
          (%i2) cdf_binomial(5,7,1/6);
                                      7775
          (%o2)                       ----
                                      7776
          (%i3) float(%);
          (%o3)               .9998713991769548

 -- Función: quantile_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial(n,p),
     con 0 \leq p \leq 1 y n entero positivo; en otras palabras, se
     trata de la inversa de ‘cdf_binomial’.  El argumento <q> debe ser
     un número de [0,1].  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: mean_binomial (<n>,<p>)
     Devuelve la media de una variable aleatoria Binomial(n,p), con 0
     \leq p \leq 1 y n entero positivo.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: var_binomial (<n>,<p>)
     Devuelve la varianza de una variable aleatoria Binomial(n,p), con 0
     \leq p \leq 1 y n entero positivo.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: std_binomial (<n>,<p>)
     Devuelve la desviación típica de una variable aleatoria
     Binomial(n,p), con 0 \leq p \leq 1 y n entero positivo.  Para hacer
     uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: skewness_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial(n,p), con 0 \leq p \leq 1 y n entero positivo.  Para hacer
     uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     binomial Binomial(n,p), con 0 \leq p \leq 1 y n entero positivo.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: random_binomial (<n>,<p>)
 -- Función: random_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial(n,p), con 0 \leq p \leq 1 y n
     entero positivo.  Llamando a ‘random_binomial’ con un tercer
     argumento <m>, se simulará una muestra aleatoria de tamaño <m>.

     El algoritmo de simulación es el descrito en Kachitvichyanukul, V.
     y Schmeiser, B.W. (1988) <Binomial Random Variate Generation>.
     Communications of the ACM, 31, Feb., 216.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: cdf_poisson (<x>,<m>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Poisson(m), con m>0.

          (%i1) load ("distrib")$
          (%i2) cdf_poisson(3,5);
          (%o2)       gamma_incomplete_regularized(4, 5)
          (%i3) float(%);
          (%o3)               .2650259152973623

 -- Función: quantile_poisson (<q>,<m>)
     Devuelve el <q>-cuantil de una variable aleatoria de Poisson(m),
     con m>0; en otras palabras, se trata de la inversa de
     ‘cdf_poisson’.  El argumento <q> debe ser un número de [0,1].  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: mean_poisson (<m>)
     Devuelve la media de una variable aleatoria de Poisson(m), con m>0.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_poisson (<m>)
     Devuelve la varianza de una variable aleatoria de Poisson(m), con
     m>0.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_poisson (<m>)
     Devuelve la desviación típica de una variable aleatoria de
     Poisson(m), con m>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: skewness_poisson (<m>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Poisson(m), con m>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: kurtosis_poisson (<m>)
     Devuelve el coeficiente de curtosis de una variable aleatoria de
     Poisson(m), con m>0.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: random_poisson (<m>)
 -- Función: random_poisson (<m>,<n>)
     Devuelve un valor aleatorio Poisson(m), con m>0.  Llamando a
     ‘random_poisson’ con un segundo argumento <n>, se simulará una
     muestra aleatoria de tamaño <n>.

     El algoritmo de simulación es el descrito en Ahrens, J.H. and
     Dieter, U. (1982) <Computer Generation of Poisson Deviates From
     Modified Normal Distributions>.  ACM Trans.  Math.  Software, 8, 2,
     June,163-179.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria de Bernoulli(p), con 0 \leq
     p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load ("distrib")$
          (%i2) pdf_bernoulli(1,p);
          (%o2)                           p

 -- Función: cdf_bernoulli (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria de Bernoulli(p), con 0 \leq
     p \leq 1.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_bernoulli (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria de Bernoulli(p),
     con 0 \leq p \leq 1; en otras palabras, se trata de la inversa de
     ‘cdf_bernoulli’.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_bernoulli (<p>)
     Devuelve la media de una variable aleatoria de Bernoulli(p), con 0
     \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load ("distrib")$
          (%i2) mean_bernoulli(p);
          (%o2)                           p

 -- Función: var_bernoulli (<p>)
     Devuelve la varianza de una variable aleatoria de Bernoulli(p), con
     0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load ("distrib")$
          (%i2) var_bernoulli(p);
          (%o2)                       (1 - p) p

 -- Función: std_bernoulli (<p>)
     Devuelve la desviación típica de una variable aleatoria de
     Bernoulli(p), con 0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load ("distrib")$
          (%i2) std_bernoulli(p);
          (%o2)                           sqrt((1 - p) p)

 -- Función: skewness_bernoulli (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria de
     Bernoulli(p), con 0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load ("distrib")$
          (%i2) skewness_bernoulli(p);
                                              1 - 2 p
          (%o2)                           ---------------
                                          sqrt((1 - p) p)

 -- Función: kurtosis_bernoulli (<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria de
     Bernoulli(p), con 0 \leq p \leq 1.

     La variable aleatoria Bernoulli(p) equivale a una Binomial(1,p).

          (%i1) load ("distrib")$
          (%i2) kurtosis_bernoulli(p);
                                   1 - 6 (1 - p) p
          (%o2)                    ---------------
                                      (1 - p) p

 -- Función: random_bernoulli (<p>)
 -- Función: random_bernoulli (<p>,<n>)
     Devuelve un valor aleatorio Bernoulli(p), con 0 \leq p \leq 1.
     Llamando a ‘random_bernoulli’ con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     Es aplicación directa de la función ‘random’ de Maxima.

     Véase también ‘random’.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: pdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Geométrica(p), con 0 < p
     \leq 1.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: cdf_geometric (<x>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Geométrica(p), con 0 < p
     \leq 1.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_geometric (<q>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Geométrica(p),
     con 0 < p \leq 1; en otras palabras, se trata de la inversa de
     ‘cdf_geometric’.  El argumento <q> debe ser un número de [0,1].
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_geometric (<p>)
     Devuelve la media de una variable aleatoria Geométrica(p), con 0 <
     p \leq 1.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_geometric (<p>)
     Devuelve la varianza de una variable aleatoria Geométrica(p), con 0
     < p \leq 1.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_geometric (<p>)
     Devuelve la desviación típica de una variable aleatoria
     Geométrica(p), con 0 < p \leq 1.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: skewness_geometric (<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Geométrica(p), con 0 < p \leq 1.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_geometric (<p>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Geométrica(p), con 0 < p \leq 1.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: random_geometric (<p>)
 -- Función: random_geometric (<p>,<n>)
     Devuelve un valor aleatorio Geométrico(p), con 0 < p \leq 1.
     Llamando a ‘random_geometric’ con un segundo argumento <n>, se
     simulará una muestra aleatoria de tamaño <n>.

     El algoritmo está basado en la simulación de ensayos de Bernoulli.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: cdf_discrete_uniform (<x>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Uniforme Discreta(n), con n
     entero positivo.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_discrete_uniform (<q>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo; en otras palabras, se trata de
     la inversa de ‘cdf_discrete_uniform’.  El argumento <q> debe ser un
     número de [0,1].  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_discrete_uniform (<n>)
     Devuelve la media de una variable aleatoria Uniforme Discreta(n),
     con n entero positivo.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: var_discrete_uniform (<n>)
     Devuelve la varianza de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo.  Para hacer uso de esta
     función, ejecútese primero ‘load("distrib")’.

 -- Función: std_discrete_uniform (<n>)
     Devuelve la desviación típica de una variable aleatoria Uniforme
     Discreta(n), con n entero positivo.  Para hacer uso de esta
     función, ejecútese primero ‘load("distrib")’.

 -- Función: skewness_discrete_uniform (<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_discrete_uniform (<n>)
     Devuelve el coeficiente de curtosis de una variable aleatoria
     Uniforme Discreta(n), con n entero positivo.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: random_discrete_uniform (<n>)
 -- Función: random_discrete_uniform (<n>,<m>)
     Devuelve un valor aleatorio Uniforme Discreto(n), con n entero
     positivo.  Llamando a ‘random_discrete_uniform’ con un segundo
     argumento <m>, se simulará una muestra aleatoria de tamaño <m>.

     Se trata de una aplicación directa de la función ‘random’ de
     Maxima.

     Véase también ‘random’.  Para hacer uso de esta función, ejecútese
     primero ‘load("distrib")’.

 -- Función: pdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.  Siendo <n1> el
     número de objetos de la clase A, <n2> el número de objetos de la
     clase B y <n> el tamaño de una muestra sin reemplazo, esta función
     devuelve la probabilidad del suceso "extraer exactamente <x>
     objetos de la clase A".

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: cdf_hypergeometric (<x>,<n1>,<n2>,<n>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución of una variable aleatoria Hipergeométrica(n1,n2,n),
     con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.  Véase
     ‘pdf_hypergeometric’ para una descripción más completa.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: quantile_hypergeometric (<q>,<n1>,<n2>,<n>)
     Devuelve el <q>-cuantil de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2; en otras palabras, se trata de la inversa de
     ‘cdf_hypergeometric’.  El argumento <q> debe ser un número de
     [0,1].  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: mean_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la media de una variable aleatoria uniforme discreta
     Hyp(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y n<=n1+n2.
     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: var_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la varianza de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: std_hypergeometric (<n1>,<n2>,<n>)
     Devuelve la desviación típica de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: skewness_hypergeometric (<n1>,<n2>,<n>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Hipergeométrica(n1,n2,n), con <n1>, <n2> y <n> enteros positivos y
     n<=n1+n2.  Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: random_hypergeometric (<n1>,<n2>,<n>)
 -- Función: random_hypergeometric (<n1>,<n2>,<n>,<m>)
     Devuelve un valor aleatorio Hipergeométrico(n1,n2,n), con <n1>,
     <n2> y <n> enteros positivos y n<=n1+n2.  Llamando a
     ‘random_hypergeometric’ con un cuarto argumento <m>, se simulará
     una muestra aleatoria de tamaño <m>.

     Algoritmo descrito en Kachitvichyanukul, V., Schmeiser, B.W. (1985)
     <Computer generation of hypergeometric random variates.> Journal of
     Statistical Computation and Simulation 22, 127-145.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.

 -- Función: pdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     probabilidad de una variable aleatoria Binomial Negativa(n,p), con
     0 < p \leq 1 y n positivo.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: cdf_negative_binomial (<x>,<n>,<p>)
     Devuelve el valor correspondiente a <x> de la función de
     distribución de una variable aleatoria Binomial Negativa(n,p), con
     0 < p \leq 1 y n positivo.

          (%i1) load ("distrib")$
          (%i2) cdf_negative_binomial(3,4,1/8);
                                      3271
          (%o2)                      ------
                                     524288

 -- Función: quantile_negative_binomial (<q>,<n>,<p>)
     Devuelve el <q>-cuantil de una variable aleatoria Binomial
     Negativa(n,p), con 0 < p \leq 1 y n positivo; en otras palabras, se
     trata de la inversa de ‘cdf_negative_binomial’.  El argumento <q>
     debe ser un número de [0,1].  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: mean_negative_binomial (<n>,<p>)
     Devuelve la media de una variable aleatoria Binomial Negativa(n,p),
     con 0 < p \leq 1 and n positivo.  Para hacer uso de esta función,
     ejecútese primero ‘load("distrib")’.

 -- Función: var_negative_binomial (<n>,<p>)
     Devuelve la varianza de una variable aleatoria Binomial
     Negativa(n,p), con 0 < p \leq 1 and n positivo.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: std_negative_binomial (<n>,<p>)
     Devuelve la desviación típica de una variable aleatoria Binomial
     Negativa(n,p), con 0 < p \leq 1 and n positivo.  Para hacer uso de
     esta función, ejecútese primero ‘load("distrib")’.

 -- Función: skewness_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de asimetría de una variable aleatoria
     Binomial Negativa(n,p), con 0 < p \leq 1 and n positivo.  Para
     hacer uso de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: kurtosis_negative_binomial (<n>,<p>)
     Devuelve el coeficiente de curtosis una variable aleatoria binomial
     negativa NB(n,p), con 0 < p \leq 1 and n positivo.  Para hacer uso
     de esta función, ejecútese primero ‘load("distrib")’.

 -- Función: random_negative_binomial (<n>,<p>)
 -- Función: random_negative_binomial (<n>,<p>,<m>)
     Devuelve un valor aleatorio Binomial Negativo(n,p), con 0 < p \leq
     1 y n positivo.  Llamando a ‘random_negative_binomial’ con un
     tercer argumento <m>, se simulará una muestra aleatoria de tamaño
     <m>.

     Algoritmo descrito en Devroye, L. (1986) <Non-Uniform Random
     Variate Generation>.  Springer Verlag, p.  480.

     Para hacer uso de esta función, ejecútese primero
     ‘load("distrib")’.


File: maxima.info,  Node: draw,  Next: drawdf,  Prev: distrib,  Up: Top

47 draw
*******

* Menu:

* Introducción a draw::
* Funciones y variables para draw::
* Funciones y variables para picture::
* Funciones y variables para worldmap::


File: maxima.info,  Node: Introducción a draw,  Next: Funciones y variables para draw,  Prev: draw,  Up: draw

47.1 Introducción a draw
========================

‘draw’ es un interfaz para comunicar Maxima con Gnuplot.

Tres son las funciones principales a utilizar a nivel de Maxima:
‘draw2d’, ‘draw3d’ y ‘draw’.

Síganse estos enlaces para ver ejemplos más elaborados de este paquete:

<http://riotorto.users.sourceforge.net/Maxima/gnuplot/>

y

<http://riotorto.users.sourceforge.net/Maxima/vtk/>

Se necesita tener instalado Gnuplot 4.2 o superior para ejecutar este
paquete.


File: maxima.info,  Node: Funciones y variables para draw,  Next: Funciones y variables para picture,  Prev: Introducción a draw,  Up: draw

47.2 Funciones y variables para draw
====================================

47.2.1 Escenas
--------------

 -- Constructor de escena: gr2d (<Opción gráfica>, ...,
          <graphic_object>, ...)

     La función ‘gr2d’ construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos.  Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha.  Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en dos
     dimensiones: ‘bars’, ‘ellipse’, ‘explicit’, ‘image’, ‘implicit’,
     ‘label’, ‘parametric’, ‘points’, ‘polar’, ‘polygon’,
     ‘quadrilateral’, ‘rectangle’, ‘triangle’, ‘vector’ y ‘geomap’ (este
     último definido en el paquete ‘worldmap’).

     Véanse también ‘draw’ y ‘draw2d’.

     Para utilizar este objecto, ejecútese primero ‘load("draw")’.

 -- Constructor de escena: gr3d (<Opción gráfica>, ...,
          <graphic_object>, ...)

     La función ‘gr3d’ construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos o listas
     que contengan elementos de ambos tipos.  Esta escena se interpreta
     secuencialmente: las opciones gráficas afectan a aquellos objetos
     gráficos colocados a su derecha.  Algunas opciones gráficas afectan
     al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en tres
     dimensiones: ‘cylindrical’, ‘elevation_grid’, ‘explicit’,
     ‘implicit’, ‘label’, ‘mesh’, ‘parametric’, ‘parametric_surface’,
     ‘points’, ‘quadrilateral’, ‘spherical’, ‘triangle’, ‘tube’,
     ‘vector’ y ‘geomap’ (este último definido en el paquete
     ‘worldmap’).

     Véanse también ‘draw’ y ‘draw3d’.

     Para utilizar este objeto, ejecútese primero ‘load("draw")’.

47.2.2 Funciones
----------------

 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)

     Representa gráficamente una serie de escenas; sus argumentos son
     objetos ‘gr2d’ y/o ‘gr3d’, junto con algunas opciones, o listas de
     escenas y opciones.  Por defecto, las escenas se representan en una
     columna.

     La función ‘draw’ acepta las siguientes opciones globales:
     ‘terminal’, ‘columns’, ‘dimensions’, ‘file_name’ y ‘delay’.

     Las funciones ‘draw2d’ y ‘draw3d’ son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Véanse también ‘gr2d’ y ‘gr3d’.

     Para utilizar esta función, ejecútese primero ‘load("draw")’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     Las dos sentencias gráficas siguientes son equivalentes:
          (%i1) load("draw")$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     Un fichero gif animado:
          (%i1) load("draw")$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Véanse también ‘gr2d’, ‘gr3d’, ‘draw2d’ y ‘draw3d’.

 -- Función: draw2d (<option>, <graphic_object>, ...)

     Esta función es un atajo para ‘draw(gr2d(<options>, ...,
     <graphic_object>, ...))’.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero ‘load("draw")’.

     Véanse también ‘draw’ y ‘gr2d’.

 -- Función: draw3d (<option>, <graphic_object>, ...)

     Esta función es un atajo para ‘draw(gr3d(<options>, ...,
     <graphic_object>, ...))’.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero ‘load("draw")’.

     Véanse también ‘draw’ y ‘gr3d’.

 -- Función: draw_file (<Opción gráfica>, ..., <Opción gráfica>, ...)

     Almacena el gráfico actual en un fichero.  Las opciones gráficas
     que acepta son: ‘terminal’, ‘dimensions’ y‘file_name’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) /* dibujo en pantalla */
                draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)))$
          (%i3) /* same plot in eps format */
                draw_file(terminal  = eps,
                          dimensions = [5,5]) $

 -- Función: multiplot_mode (<term>)

     Esta función permite a Maxima trabajar en modo de gráficos
     múltiples en una sola ventana del terminal <term>; argumentos
     válidos para esta función son ‘screen’, ‘wxt’, ‘aquaterm’ y ‘none’.

     Cuando el modo de gráficos múltiples está activo, cada llamada a
     ‘draw’ envía un nuevo gr’afico a la misma ventana, sin borrar los
     anteriores.  Para desactivar el modo de gráficos múltiples
     escríbase ‘multiplot_mode(none)’.

     Cuando el modo de gráficos múltiples está activo, la opción global
     ‘terminal’ se bloquea; para desbloquearla y cambiar de terminal es
     necesario desactivar previamente el modo de gráficos múltiples.

     Este modo de trabajo no funciona en plataformas Windows.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) set_draw_defaults(
                   xrange = [-1,1],
                   yrange = [-1,1],
                   grid   = true,
                   title  = "Step by step plot" )$
          (%i3) multiplot_mode(screen)$
          (%i4) draw2d(color=blue,  explicit(x^2,x,-1,1))$
          (%i5) draw2d(color=red,   explicit(x^3,x,-1,1))$
          (%i6) draw2d(color=brown, explicit(x^4,x,-1,1))$
          (%i7) multiplot_mode(none)$

 -- Función: set_draw_defaults (<Opción gráfica>, ..., <Opción gráfica>,
          ...)

     Establece las opciones gráficas de usuario.  Esta función es útil
     para dibujar varios gráficos con las mismas opciones.  Llamando a
     la función sin argumentos se borran las opciones de usuario por
     defecto.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) set_draw_defaults(
                   xrange = [-10,10],
                   yrange = [-2, 2],
                   color  = blue,
                   grid   = true)$
          (%i3) /* dibujo con opciones de usuario */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$
          (%i4) set_draw_defaults()$
          (%i5) /* dibujo con opciones por defecto */
                draw2d(explicit(((1+x)**2/(1+x*x))-1,x,-10,10))$

     Para utilizar esta función, ejecútese primero ‘load("draw")’.

47.2.3 Opciones gráficas
------------------------

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     ‘adapt_depth’ es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo ‘explicit’ en
     2d.

 -- Opción gráfica: allocation
     Valor por defecto: ‘false’

     Con la opción ‘allocation’ es posible colocar a voluntad una escena
     en la ventana de salida, lo cual resulta de utilidad en el caso de
     gráficos múltiples.  Cuando la opción toma el valor ‘false’, la
     escena se coloca de forma automática, dependiendo del valor
     asignado a la opción ‘columns’.  En cualquier otro caso, a
     ‘allocation’ se le debe asignar una lista con dos pares de números;
     el primero se corresponde con la posición de la esquina inferior
     izquierda del gráfico y el segundo par hace referencia al ancho y
     alto de la escena.  Todas las cantidades deben darse en coordenadas
     relativas, entre 0 y 1.

     Ejemplos:

     Gráficos internos.

          (%i1) load("draw")$
          (%i2) draw(
                  gr2d(
                    explicit(x^2,x,-1,1)),
                  gr2d(
                    allocation = [[1/4, 1/4],[1/2, 1/2]],
                    explicit(x^3,x,-1,1),
                    grid = true) ) $

     Multiplot con dimensiones establecidas por el usuario.

          (%i1) load("draw")$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(
                    allocation = [[0, 0],[1, 1/4]],
                    explicit(x^2,x,-1,1)),
                  gr3d(
                    allocation = [[0, 1/4],[1, 3/4]],
                    explicit(x^2+y^2,x,-1,1,y,-1,1) ))$

     Véase también la opción ‘columns’.

 -- Opción gráfica: axis_3d
     Valor por defecto: ‘true’

     Cuando ‘axis_3d’ vale ‘true’, los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también ‘axis_bottom’, ‘axis_left’, ‘axis_top’ y
     ‘axis_right’ for axis in 2d.

 -- Opción gráfica: axis_bottom
     Valor por defecto: ‘true’

     Cuando ‘axis_bottom’ vale ‘true’, el eje inferior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también ‘axis_left’, ‘axis_top’, ‘axis_right’ y ‘axis_3d’.

 -- Opción gráfica: axis_left
     Valor por defecto: ‘true’

     Cuando ‘axis_left’ vale ‘true’, el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también ‘axis_bottom’, ‘axis_top’, ‘axis_right’ y ‘axis_3d’.

 -- Opción gráfica: axis_right
     Valor por defecto: ‘true’

     Cuando ‘axis_right’ vale ‘true’, el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también ‘axis_bottom’, ‘axis_left’, ‘axis_top’ y ‘axis_3d’.

 -- Opción gráfica: axis_top
     Valor por defecto: ‘true’

     Cuando ‘axis_top’ vale ‘true’, el eje superior permanece visible en
     las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también ‘axis_bottom’, ‘axis_left’, ‘axis_right’ y
     ‘axis_3d’.

 -- Opción gráfica: background_color
     Valor por defecto: ‘white’

     Establece el color de fondo en los terminales ‘gif’, ‘png’, ‘jpg’ y
     ‘gif’.  El color de fondo por defecto es blanco.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción no es compatible con los terminales ‘epslatex’ y
     ‘epslatex_standalone’.

     Véase también ‘color’.

 -- Opción gráfica: border
     Valor por defecto: ‘true’

     Cuando ‘border’ vale ‘true’, los bordes de los polígonos se dibujan
     de acuerdo con ‘line_type’ y ‘line_width’.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘polygon’, ‘rectangle’ y ‘ellipse’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: capping
     Valor por defecto: ‘[false, false]’

     Una lista de dos elementos, ‘true’ y ‘false’, indicando si los
     extremos de un objeto gráfico ‘tube’ permanece abiertos o si deben
     ser cerrados.  Por defecto, ambos extremos se dejan abiertos.

     La asignación ‘capping = false’ equivale a ‘capping = [false,
     false]’ y ‘capping = true’ equivale a ‘capping = [true, true]’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(
                  capping = [false, true],
                  tube(0, 0, a, 1,
                       a, 0, 8) )$

 -- Opción gráfica: cbrange
     Valor por defecto: ‘auto’

     Cuando ‘cbrange’ vale ‘auto’, el rango de los valores que se
     colorean cuando ‘enhanced3d’ es diferente de ‘false’ se calcula
     automáticamente.  Valores fuera del rango utilizan el color del
     valor extremo más cercano.

     Cuando ‘enhanced3d’ o ‘colorbox’ vale ‘false’, la opción ‘cbrange’
     no tiene efecto alguno.

     Si el usuario quiere especificar un intervalo para los valores a
     colorear, éste debe expresarse como una lista de Maxima, como en
     ‘cbrange=[-2, 3]’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d (
                  enhanced3d     = true,
                  color          = green,
                  cbrange = [-3,10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     Véanse también ‘enhanced3d’ y ‘cbtics’.

 -- Opción gráfica: cbtics
     Valor por defecto: ‘auto’

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas en la escala de color cuando la opción ‘enhanced3d’ sea
     diferente de ‘false’.

     Cuando ‘enhanced3d’ o ‘colorbox’ vale ‘false’, la opción ‘cbtics’
     no tiene efecto alguno.

     Véase ‘xtics’ para una descripción completa.

     Ejemplo :

          (%i1) load("draw")$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  cbtics  = {["High",10],["Medium",05],["Low",0]},
                  cbrange = [0, 10],
                  explicit(x^2+y^2, x,-2,2,y,-2,2)) $

     See also ‘enhanced3d’, ‘colorbox’ and ‘cbrange’.

 -- Opción gráfica: color
     Valor por defecto: ‘blue’

     ‘color’ especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: ‘white’, ‘black’, ‘gray0’,
     ‘grey0’, ‘gray10’, ‘grey10’, ‘gray20’, ‘grey20’, ‘gray30’,
     ‘grey30’, ‘gray40’, ‘grey40’, ‘gray50’, ‘grey50’, ‘gray60’,
     ‘grey60’, ‘gray70’, ‘grey70’, ‘gray80’, ‘grey80’, ‘gray90’,
     ‘grey90’, ‘gray100’, ‘grey100’, ‘gray’, ‘grey’, ‘light_gray’,
     ‘light_grey’, ‘dark_gray’, ‘dark_grey’, ‘red’, ‘light_red’,
     ‘dark_red’, ‘yellow’, ‘light_yellow’, ‘dark_yellow’, ‘green’,
     ‘light_green’, ‘dark_green’, ‘spring_green’, ‘forest_green’,
     ‘sea_green’, ‘blue’, ‘light_blue’, ‘dark_blue’, ‘midnight_blue’,
     ‘navy’, ‘medium_blue’, ‘royalblue’, ‘skyblue’, ‘cyan’,
     ‘light_cyan’, ‘dark_cyan’, ‘magenta’, ‘light_magenta’,
     ‘dark_magenta’, ‘turquoise’, ‘light_turquoise’, ‘dark_turquoise’,
     ‘pink’, ‘light_pink’, ‘dark_pink’, ‘coral’, ‘light_coral’,
     ‘orange_red’, ‘salmon’, ‘light_salmon’, ‘dark_salmon’,
     ‘aquamarine’, ‘khaki’, ‘dark_khaki’, ‘goldenrod’,
     ‘light_goldenrod’, ‘dark_goldenrod’, ‘gold’, ‘beige’, ‘brown’,
     ‘orange’, ‘dark_orange’, ‘violet’, ‘dark_violet’, ‘plum’ y
     ‘purple’.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato ‘"#rrggbb"’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = red,
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = light_blue,
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     Véase también ‘fill_color’.

 -- Opción gráfica: colorbox
     Valor por defecto: ‘true’

     Cuando ‘colorbox’ vale ‘true’, se dibuja una escala de colores sin
     título al lado de los objetos ‘image’ en 2D o de objetos coloreados
     en 3D. Cuando ‘colorbox’ vale ‘false’, no se presenta la escala de
     colores.  Cuando ‘colorbox’ es una cadena de caracteres, se
     mostrará la escala de colores con un título.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     Escala de colores e imágenes.

          (%i1) load("draw")$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox = false, image(im,0,0,30,30))$

     Escala de colores y objeto 3D coloreado.

          (%i1) load("draw")$
          (%i2) draw3d(
                  colorbox   = "Magnitude",
                  enhanced3d = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1))$

     Véase también ‘palette’.

 -- Opción gráfica: columns
     Valor por defecto: 1

     ‘columns’ es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

 -- Opción gráfica: contour
     Valor por defecto: ‘none’

     La opción ‘contour’ permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        • ‘none’: no se dibujan líneas de nivel.

        • ‘base’: las líneas de nivel se proyectan sobre el plano xy.

        • ‘surface’: las líneas de nivel se dibujan sobre la propia
          superficie.

        • ‘both’: se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        • ‘map’: las líneas de nivel se proyectan sobre el plano xy y el
          punto de vista del observador se coloca perpendicularmente a
          él.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también ‘contour_levels’.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     Esta opción gráfica controla cómo se dibujarán las líneas de nivel.
     A ‘contour_levels’ se le puede asignar un número entero positivo,
     una lista de tres números o un conjunto numérico arbitrario:

        • Si a ‘contour_levels’ se le asigna un entero positivo <n>,
          entonces se dibujarán <n> líneas de nivel a intervalos
          iguales.  Por defecto, se dibujaán cinco isolíneas.

        • Si a ‘contour_levels’ se le asigna una lista de tres números
          de la forma ‘[inf,p,sup]’, las isolíneas se dibujarán desde
          ‘inf’ hasta ‘sup’ en pasos de amplitud ‘p’.

        • Si a ‘contour_levels’ se le asigna un conjunto de números de
          la forma ‘{n1, n2, ...}’, entonces se dibujarán las isolíneas
          correspondientes a los niveles ‘n1’, ‘n2’, ...

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Diez isolíneas igualmente espaciadas.  El número real puede
     ajustarse a fin de poder conseguir etiquetas más sencillas.
          (%i1) load("draw")$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     Desde -8 hasta 8 en pasos de amplitud 4.
          (%i1) load("draw")$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Líneas correspondientes a los niveles -7, -6, 0.8 y 5.
          (%i1) load("draw")$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     Véase también ‘contour’.

 -- Opción gráfica: data_file_name
     Valor por defecto: ‘"data.gnuplot"’

     ‘data_file_name’ es el nombre del fichero que almacena la
     información numérica que necesita Gnuplot para crear el gráfico
     solicitado.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     Véase ejemplo en ‘gnuplot_file_name’.

 -- Opción gráfica: delay
     Valor por defecto: 5

     Este es el retraso en centésimas de segundo entre imágenes en los
     ficheros gif animados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób ‘delay’ sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también ‘terminal’, ‘dimensions’.

 -- Opción gráfica: dimensions
     Valor por defecto: ‘[600,500]’

     Dimensiones del terminal de salida.  Su valor es una lista formada
     por el ancho y el alto.  El significado de estos dos números
     depende del terminal con el que se esté trabajando.

     Con los terminales ‘gif’, ‘animated_gif’, ‘png’, ‘jpg’, ‘svg’,
     ‘screen’, ‘wxt’ y ‘aquaterm’, los enteros representan números de
     puntos en cada dirección.  Si no son enteros se redondean.

     Con los terminales ‘eps’, ‘eps_color’, ‘pdf’ y ‘pdfcairo’, los
     números representan centésimas de cm, lo que significa que, por
     defecto, las imágenes en estos formatos tienen 6 cm de ancho por 5
     cm de alto.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     Ejemplos:

     La opción ‘dimensions’ aplicada a un fichero de salida y al lienzo
     wxt.

          (%i1) load("draw")$
          (%i2) draw2d(
                  dimensions = [300,300],
                  terminal   = 'png,
                  explicit(x^4,x,-1,1)) $
          (%i3) draw2d(
                  dimensions = [300,300],
                  terminal   = 'wxt,
                  explicit(x^4,x,-1,1)) $

     La opción ‘dimensions’ aplicada a una salida eps.  En este caso
     queremos un fichero eps con dimensiones A4.

          (%i1) load("draw")$
          (%i2) A4portrait: 100*[21, 29.7]$
          (%i3) draw3d(
                  dimensions = A4portrait,
                  terminal   = 'eps,
                  explicit(x^2-y^2,x,-2,2,y,-2,2)) $

 -- Opción gráfica: draw_realpart
     Valor por defecto: ‘true’

     Cuando vale ‘true’, las funciones a dibujar se consideran funciones
     complejas cuyas partes reales se deben dibujar; cuando la opción
     vale ‘false’, no se dibujará nada en caso de que la función no
     devuelve valores reales.

     Esta opción afecta a los objetos ‘explicit’ y ‘parametric’ en 2D y
     3D, y al objeto ‘parametric_surface’.

     Ejemplo:

     La opción ‘draw_realpart’ afecta a los objetos ‘explicit’ y
     ‘parametric’.

          (%i1) load("draw")$
          (%i2) draw2d(
                  draw_realpart = false,
                  explicit(sqrt(x^2  - 4*x) - x, x, -1, 5),
                  color         = red,
                  draw_realpart = true,
                  parametric(x,sqrt(x^2  - 4*x) - x + 1, x, -1, 5) );

 -- Opción gráfica: enhanced3d
     Valor por defecto: ‘none’

     Cuando ‘enhanced3d’ vale ‘none’, las superficies no se colorean en
     escenas 3D. Para obtener una superficie coloreada se debe asignar
     una lista a la opción ‘enhanced3d’, en la que el primer elemento es
     una expresión y el resto son los nombres de las variables o
     parámetros utilizados en la expresión.  Una lista tal como
     ‘[f(x,y,z), x, y, z]’ significa que al punto ‘[x,y,z]’ de la
     superficie se le asigna el número ‘f(x,y,z)’, el cual será
     coloreado de acuerdo con el valor actual de ‘palette’.  Para
     aquellos objetos gráficos 3D definidos en términos de parámetros,
     es posible definir el número de color en términos de dichos
     parámetros, como en ‘[f(u), u]’, para los objetos ‘parametric’ y
     ‘tube’, o ‘[f(u,v), u, v]’, para el objeto ‘parametric_surface’.
     Mientras que todos los objetos 3D admiten el modelo basado en
     coordenadas absolutas, ‘[f(x,y,z), x, y, z]’, solamente dos de
     ellos, esto es ‘explicit’ y ‘elevation_grid’, aceptan también el
     modelo basado en las coordenadas ‘[x,y]’, ‘[f(x,y), x, y]’.  El
     objeto 3D ‘implicit’ acepta solamente el modelo ‘[f(x,y,z), x, y,
     z]’.  El objeto ‘points’ también acepta el modelo ‘[f(x,y,z), x, y,
     z]’, pero cuando los puntos tienen naturaleza cronológica también
     admite el modelo ‘[f(k), k]’, siendo ‘k’ un parámetro de orden.

     Cuando a ‘enhanced3d’ se le asigna algo diferente de ‘none’, se
     ignoran las opciones ‘color’ y ‘surface_hide’.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     A fin de mantener compatibilidad con versiones anteriores,
     ‘enhanced3d = false’ es equivalente a ‘enhanced3d = none’ y
     ‘enhanced3d = true’ es equivalente a ‘enhanced3d = [z, x, y, z]’.
     Si a ‘enhanced3d’ se le asigna una expresión, sus variables deben
     ser las mismas utilizadas en la definición de la superficie.  Esto
     no es necesario cuando se utilizan listas.

     Sobre la definición de paletas, véase ‘palette’.

     Ejemplos:

     Objeto ‘explicit’ con coloreado definido por el modelo ‘[f(x,y,z),
     x, y, z]’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   enhanced3d = [x-z/10,x,y,z],
                   palette    = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto ‘explicit’ con coloreado definido por el modelo ‘[f(x,y), x,
     y]’.  Los nombres de las variables definidas en las listas pueden
     ser diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos 3D; en este caso, ‘r’ corresponde a ‘x’ y ‘s’ a
     ‘y’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   enhanced3d = [sin(r*s),r,s],
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     Objeto ‘parametric’ con coloreado definido por el modelo
     ‘[f(x,y,z), x, y, z]’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   nticks = 100,
                   line_width = 2,
                   enhanced3d = [if y>= 0 then 1 else 0, x, y, z],
                   parametric(sin(u)^2,cos(u),u,u,0,4*%pi)) $

     Objeto ‘parametric’ con coloreado definido por el modelo ‘[f(u),
     u]’.  En este caso, ‘(u-1)^2’ es una simplificación de
     ‘[(u-1)^2,u]’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   nticks = 60,
                   line_width = 3,
                   enhanced3d = (u-1)^2,
                   parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2))$

     Objeto ‘elevation_grid’ con coloreado definido por el modelo
     ‘[f(x,y), x, y]’.

          (%i1) load("draw")$
          (%i2) m: apply(
                     matrix,
                     makelist(makelist(cos(i^2/80-k/30),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   enhanced3d = [cos(x*y*10),x,y],
                   elevation_grid(m,-1,-1,2,2),
                   xlabel = "x",
                   ylabel = "y");

     Objeto ‘tube’ con coloreado definido por el modelo ‘[f(x,y,z), x,
     y, z]’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   enhanced3d = [cos(x-y),x,y,z],
                   palette = gray,
                   xu_grid = 50,
                   tube(cos(a), a, 0, 1, a, 0, 4*%pi) )$

     Objeto ‘tube’ con coloreado definido por el modelo ‘[f(u), u]’.  En
     este caso, ‘enhanced3d = -a’ puede ser una simplificación de
     ‘enhanced3d = [-foo,foo]’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   capping = [true, false],
                   palette = [26,15,-2],
                   enhanced3d = [-foo, foo],
                   tube(a, a, a^2, 1, a, -2, 2) )$

     Objetos ‘implicit’ y ‘points’ con coloreado definido por el modelo
     ‘[f(x,y,z), x, y, z]’.

          (%i1) load("draw")$
          (%i2) draw3d(
                   enhanced3d = [x-y,x,y,z],
                   implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                            x,-1,1,y,-1.2,2.3,z,-1,1)) $
          (%i3) m: makelist([random(1.0),random(1.0),random(1.0)],k,1,2000)$
          (%i4) draw3d(
                   point_type = filled_circle,
                   point_size = 2,
                   enhanced3d = [u+v-w,u,v,w],
                   points(m) ) $

     cuando los puntos tienen naturaleza cronológica también se admite
     el modelo ‘[f(k), k]’, siendo ‘k’ un parámetro de orden.

          (%i1) load("draw")$
          (%i2) m:makelist([random(1.0), random(1.0), random(1.0)],k,1,5)$
          (%i3) draw3d(
                   enhanced3d = [sin(j), j],
                   point_size = 3,
                   point_type = filled_circle,
                   points_joined = true,
                   points(m)) $

 -- Opción gráfica: error_type
     Valor por defecto: ‘y’

     Dependiendo de su valor, el cual puede ser ‘x’, ‘y’ o ‘xy’, el
     objeto gráfico ‘errors’ dibujará puntos con barras de error
     horizontales, verticales, o ambas.  Si ‘error_type=boxes’, se
     dibujarán cajas en lugar de cruces.

     Véase también ‘errors’.

 -- Opción gráfica: file_name
     Valor por defecto: ‘"maxima_out"’

     ‘file_name’ es el nombre del fichero en el que los terminales
     ‘png’, ‘jpg’, ‘gif’, ‘eps’, ‘eps_color’, ‘pdf’, ‘pdfcairo’ y ‘svg’
     guardarán el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también ‘terminal’, ‘dimensions’.

 -- Opción gráfica: fill_color
     Valor por defecto: ‘"red"’

     ‘fill_color’ especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase ‘color’ para más información sobre cómo definir colores.

 -- Opción gráfica: fill_density
     Valor por defecto: 0

     ‘fill_density’ es un número entre 0 y 1 que especifica la
     intensidad del color de relleno (dado por ‘fill_color’) en los
     objetos ‘bars’.

     Véase ‘bars’ para ejemplos.

 -- Opción gráfica: filled_func
     Valor por defecto: ‘false’

     La opción ‘filled_func’ establece cómo se van a rellenar las
     regiones limitadas por funciones.  Si ‘filled_func’ vale ‘true’, la
     región limitada por la función definida en el objeto ‘explicit’ y
     el borde inferior del la ventana gráfica se rellena con
     ‘fill_color’.  Si ‘filled_func’ guarda la expresión de una función,
     entonces la región limitada por esta función y la definida en el
     objeto ‘explicit’ será la que se rellene.  Por defecto, las
     funciones explícitas no se rellenan.

     Un caso de especial utilidad es ‘filled_func=0’, con lo que se
     sombrea la región limitada por el eje horizontal y la función
     explícita.

     Esta opción sólo afecta al objeto gráfico bidimensional ‘explicit’.

     Ejemplo:

     Región limitada por un objeto ‘explicit’ y el borde inferior de la
     ventana gráfica.
          (%i1) load("draw")$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Región limitada por un objeto ‘explicit’ y la función definida en
     la opción ‘filled_func’.  Nótese que la variable en ‘filled_func’
     debe ser la misma que la utilizada en ‘explicit’.
          (%i1) load("draw")$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     Véanse también ‘fill_color’ y ‘explicit’.

 -- Opción gráfica: font
     Valor por defecto: ‘""’ (cadena vacía)

     Esta opción permite seleccionar el tipo de fuente a utilizar por el
     terminal.  Sólo se puede utilizar un tipo de fuente y tamaño por
     gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también ‘font_size’.

     Gnuplot no puede gestionar por sí mismo las fuentes, dejando esta
     tarea a las librerías que dan soporte a los diferentes terminales,
     cada uno con su propia manera de controlar la tipografía.  A
     continuación un breve resumen:

        • x11: Utiliza el mecanismo habitual para suministrar las
          fuentes en x11.

          Ejemplo:
               (%i1) load("draw")$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        • windows: El terminal de windows no permite cambiar fuentes
          desde dentro del gráfico.  Una vez se ha creado el gráfico, se
          pueden cambiar las fuentes haciendo clic derecho en el menú de
          la ventana gráfica.

        • png, jpeg, gif: La librería libgd utiliza la ruta a las
          fuentes almacenada en la variable de entorno ‘GDFONTPATH’; en
          tal caso sólo es necesario darle a la opción ‘font’ el nombre
          de la fuente.  También es posible darle la ruta completa al
          fichero de la fuente.

          Ejemplos:

          A la opción ‘font’ se le puede dar la ruta completa al fichero
          de la fuente:
               (%i1) load("draw")$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          Si la variable de entorno ‘GDFONTPATH’ almacena la ruta a la
          carpeta donde se alojan las fuentes, es posible darle a la
          opción ‘font’ sólo el nombre de la fuente:
               (%i1) load("draw")$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        • Postscript: Las fuentes estándar de Postscript son:
          ‘"Times-Roman"’, ‘"Times-Italic"’, ‘"Times-Bold"’,
          ‘"Times-BoldItalic"’, ‘"Helvetica"’, ‘"Helvetica-Oblique"’,
          ‘"Helvetica-Bold"’, ‘"Helvetic-BoldOblique"’, ‘"Courier"’,
          ‘"Courier-Oblique"’, ‘"Courier-Bold"’ y
          ‘"Courier-BoldOblique"’.

          Ejemplo:
               (%i1) load("draw")$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        • pdf: Utiliza las mismas fuentes que Postscript.

        • pdfcairo: Utiliza las mismas fuentes que wxt.

        • wxt: La librería pango encuentra las fuentes por medio de la
          utilidad ‘fontconfig’.

        • aqua: La fuente por defecto es ‘"Times-Roman"’.

     La documentación de gnuplot es una importante fuente de información
     sobre terminales y fuentes.

 -- Opción gráfica: font_size
     Valor por defecto: 10

     Esta opción permite seleccionar el tamaño de la fuente a utilizar
     por el terminal.  Sólo se puede utilizar un tipo de fuente y tamaño
     por gráfico.  ‘font_size’ sólo se activa cuando la opción ‘font’
     tiene un valor diferente de la cadena vacía.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también ‘font’.

 -- Opción gráfica: gnuplot_file_name
     Valor por defecto: ‘"maxout.gnuplot"’

     ‘gnuplot_file_name’ es el nombre del fichero que almacena las
     instrucciones a ser procesadas por Gnuplot.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                 file_name = "my_file",
                 gnuplot_file_name = "my_commands_for_gnuplot",
                 data_file_name    = "my_data_for_gnuplot",
                 terminal          = png,
                 explicit(x^2,x,-1,1)) $

     Véase también ‘data_file_name’.

 -- Opción gráfica: grid
     Valor por defecto: ‘false’

     Cuando

     Cuando ‘grid’ toma un valor distinto de ‘false’, se dibujará una
     rejilla sobre el plano <xy>.  Si a ‘grid’ se le asigna el valor
     ‘true’, se dibujará una línea de la rejilla por cada marca que haya
     sobre los ejes.  Si a ‘grid’ se le asigna la lista ‘[nx,ny]’, con
     <[nx,ny] > [0,0]>, se dibujarán ‘nx’ líneas por cada marca del
     eje-<x> y <ny> líneas por cada marca del eje-<y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     ‘head_angle’ indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo ‘vector’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también ‘head_both’, ‘head_length’ y ‘head_type’.

 -- Opción gráfica: head_both
     Valor por defecto: ‘false’

     Cuando ‘head_both’ vale ‘true’, los vectores se dibujan
     bidireccionales.  Si vale ‘false’, se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo ‘vector’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también ‘head_length’, ‘head_angle’ y ‘head_type’.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     ‘head_length’ indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo ‘vector’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también ‘head_both’, ‘head_angle’ y ‘head_type’.

 -- Opción gráfica: head_type
     Valor por defecto: ‘filled’

     ‘head_type’ se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores.  Los valores posibles para esta opción
     son: ‘filled’ (flechas cerradas y rellenas), ‘empty’ (flechas
     cerradas pero no rellenas) y ‘nofilled’ (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo ‘vector’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también ‘head_both’, ‘head_angle’ y ‘head_length’.

 -- Opción gráfica: interpolate_color
     Valor por defecto: ‘false’

     Esta opción solo es relevante si ‘enhanced3d’ tiene un valor
     diferente de ‘false’.

     Si ‘interpolate_color’ vale ‘false’, las superficies se colorean
     con cuadriláteros homogéneos.  Si vale ‘true’, las transiciones de
     colores se suavizan por interpolación.

     La opción ‘interpolate_color’ también acepta una lista de dos
     números, ‘[m,n]’.  Para <m> y <n> positivos, cada cuadrilátero o
     triángulo se interpola <m> y <n> veces en la dirección respectiva.
     Para <m> y <n> negativos, la frecuencia de interpolación se elige
     de forma que se dibujen al menos <abs(m)> y <abs(n)> puntos,
     pudiéndose considerar esto como una función especial de enrejado.
     Con valores nulos, esto es ‘interpolate_color=[0,0]’, se
     seleccionará un número óptimo de puntos interpolados en la
     superficie.

     Además, ‘interpolate_color=true’ es equivalente a
     ‘interpolate_color=[0,0]’.

     La interpolación de colores en superficies paramétricas puede dar
     resultados imprevisibles.

     Ejemplos:

     Interpolación de color con funciones explícitas.

          (%i1) load("draw")$
          (%i2) draw3d(
                  enhanced3d   = sin(x*y),
                  explicit(20*exp(-x^2-y^2)-10, x ,-3, 3, y, -3, 3)) $
          (%i3) draw3d(
                  interpolate_color = true,
                  enhanced3d   = sin(x*y),
                  explicit(20*exp(-x^2-y^2)-10, x ,-3, 3, y, -3, 3)) $
          (%i4) draw3d(
                  interpolate_color = [-10,0],
                  enhanced3d   = sin(x*y),
                  explicit(20*exp(-x^2-y^2)-10, x ,-3, 3, y, -3, 3)) $

     Interpolación de color con el objeto ‘mesh’.

          (%i1) load("draw")$
          (%i2) draw3d(
                  enhanced3d = true,
                  mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                       [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                       [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $
          (%i3) draw3d(
                  enhanced3d        = true,
                  interpolate_color = true,
                  mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                       [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                       [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $
          (%i4) draw3d(
                  enhanced3d        = true,
                  interpolate_color = true,
                  view=map,
                  mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                       [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                       [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Véase también ‘enhanced3d’.

 -- Opción gráfica: ip_grid
     Valor por defecto: ‘[50, 50]’

     ‘ip_grid’ establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo ‘implicit’.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: ‘[5, 5]’

     ‘ip_grid_in’ establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo ‘implicit’.

 -- Opción gráfica: key
     Valor por defecto: ‘""’ (cadena vacía)

     ‘key’ es la clave de una función en la leyenda.  Si ‘key’ es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘points’, ‘polygon’, ‘rectangle’, ‘ellipse’, ‘vector’,
          ‘explicit’, ‘implicit’, ‘parametric’ y ‘polar’.

        • ‘gr3d’: ‘points’, ‘explicit’, ‘parametric’, y
          ‘parametric_surface’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: key_pos
     Valor por defecto: ‘""’ (cadena vacía)

     La opción ‘key_pos’ establece en qué posición se colocará la
     leyenda.  Si ‘key’ es una cadena vacía, entonces se utilizará por
     defecto la posición ‘"top_right"’.  Los valores disponibles para
     esta opción son: ‘top_left’, ‘top_center’, ‘top_right’,
     ‘center_left’, ‘center’, ‘center_right’, ‘bottom_left’,
     ‘bottom_center’ y ‘bottom_right’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

          (%i1) load("draw")$
          (%i2) draw2d(
                  key_pos = top_left,
                  key     = "x",
                  explicit(x,  x,0,10),
                  color   = red,
                  key     = "x squared",
                  explicit(x^2,x,0,10))$
          (%i3) draw3d(
                  key_pos = center,
                  key     = "x",
                  explicit(x+y,x,0,10,y,0,10),
                  color= red,
                  key     = "x squared",
                  explicit(x^2+y^2,x,0,10,y,0,10))$

 -- Opción gráfica: label_alignment
     Valor por defecto: ‘center’

     ‘label_alignment’ se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia.  Los
     valores posibles para esta opción son: ‘center’, ‘left’ y ‘right’.

     Esta opción sólo es relevante para objetos de tipo ‘label’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     Véanse también ‘label_orientation’ y ‘color’.

 -- Opción gráfica: label_orientation
     Valor por defecto: ‘horizontal’

     ‘label_orientation’ se utiliza para especificar la orientación de
     las etiquetas.  Los valores posibles para esta opción son:
     ‘horizontal’ y ‘vertical’.

     Esta opción sólo es relevante para objetos de tipo ‘label’.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete ‘draw’ necesita siempre de datos para
     construir la escena.
          (%i1) load("draw")$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     Véanse también ‘label_alignment’ y ‘color’.

 -- Opción gráfica: line_type
     Valor por defecto: ‘solid’

     ‘line_type’ indica cómo se van a dibujar las líneas; valores
     posibles son ‘solid’ y ‘dots’, que están disponibles en todos los
     terminales, y ‘dashes’, ‘short_dashes’, ‘short_long_dashes’,
     ‘short_short_long_dashes’ y ‘dot_dash’, que no esán disponibles en
     los terminales ‘png’, ‘jpg’ y ‘gif’.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘points’, ‘polygon’, ‘rectangle’, ‘ellipse’, ‘vector’,
          ‘explicit’, ‘implicit’, ‘parametric’ y ‘polar’.

        • ‘gr3d’: ‘points’, ‘explicit’, ‘parametric’ y
          ‘parametric_surface’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también ‘line_width’.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     ‘line_width’ es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘points’, ‘polygon’, ‘rectangle’, ‘ellipse’, ‘vector’,
          ‘explicit’, ‘implicit’, ‘parametric’ y ‘polar’.

        • ‘gr3d’: ‘points’ y ‘parametric’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también ‘line_type’.

 -- Opción gráfica: logcb
     Valor por defecto: ‘false’

     Cuando ‘logcb’ vale ‘true’, la escala de colores se dibuja
     logarítmicamente.

     Cuando ‘enhanced3d’ o ‘colorbox’ vale ‘false’, la opción ‘logcb’ no
     tiene efecto alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d (
                  enhanced3d = true,
                  color      = green,
                  logcb = true,
                  logz  = true,
                  palette = [-15,24,-9],
                  explicit(exp(x^2-y^2), x,-2,2,y,-2,2)) $

     Véanse también ‘enhanced3d’, ‘colorbox’ y ‘cbrange’.

 -- Opción gráfica: logx
     Valor por defecto: ‘false’

     Cuando ‘logx’ vale ‘true’, el eje <x> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también ‘logy’, ‘logx_secondary’, ‘logy_secondary’ y ‘logz’.

 -- Opción gráfica: logx_secondary
     Valor por defecto: ‘false’

     Si ‘logx_secondary’ vale ‘true’, el eje secundario de <x> se dibuja
     en la escala logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  grid = true,
                  key="x^2, linear scale",
                  color=red,
                  explicit(x^2,x,1,100),
                  xaxis_secondary = true,
                  xtics_secondary = true,
                  logx_secondary  = true,
                  key = "x^2, logarithmic x scale",
                  color = blue,
                  explicit(x^2,x,1,100) )$

     Véanse también ‘logx’, ‘logy’, ‘logy_secondary’ y ‘logz’.

 -- Opción gráfica: logy
     Valor por defecto: ‘false’

     Cuando ‘logy’ vale ‘true’, el eje <y> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también ‘logx’, ‘logx_secondary’, ‘logy_secondary’ y ‘logz’.

 -- Opción gráfica: logy_secondary
     Valor por defecto: ‘false’

     Si ‘logy_secondary’ vale ‘true’, el eje secundario de <y> se dibuja
     en la escala logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  grid = true,
                  key="x^2, linear scale",
                  color=red,
                  explicit(x^2,x,1,100),
                  yaxis_secondary = true,
                  ytics_secondary = true,
                  logy_secondary  = true,
                  key = "x^2, logarithmic y scale",
                  color = blue,
                  explicit(x^2,x,1,100) )$

     Véanse también ‘logx’, ‘logy’, ‘logx_secondary’ y ‘logz’.

 -- Opción gráfica: logz
     Valor por defecto: ‘false’

     Cuando ‘logz’ vale ‘true’, el eje <z> se dibuja en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también ‘logx’ and ‘logy’.

 -- Opción gráfica: nticks
     Valor por defecto: 29

     En 2d, ‘nticks’ es el número de puntos a utilizar por el programa
     adaptativo que genera las funciones explícitas.  También es el
     número de puntos que se representan en las curvas paramétricas y
     polares.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘ellipse’, ‘explicit’, ‘parametric’ y ‘polar’.

        • ‘gr3d’: ‘parametric’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: palette
     Valor por defecto: ‘color’

     ‘palette’ indica cómo transformar niveles de gris en componentes
     cromáticas.  Trabaja conjuntamente con la opción ‘enhanced3d’ en
     gráficos 3D, la cual asocia cada punto de una superficie con un
     número real o nivel de gris.  También trabaja con imágenes grises.
     Con ‘palette’, estos niveles se transforman en colores.

     Hay dos formas de definir estas transformaciones.

     En primer lugar, ‘palette’ puede ser un vector de longitud tres con
     sus componentes tomando valores enteros en el rango desde -36 a
     +36; cada valor es un índice para seleccionar una fórmula que
     transforma los niveles numéricos en las componentes cromáticas
     rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de las
     componentes cromáticas.  ‘palette = gray’ y ‘palette = color’ son
     atajos para ‘palette = [3,3,3]’ y ‘palette = [7,5,15]’,
     respectivamente.

     En segundo lugar, ‘palette’ puede ser una paleta de colores
     definida por el usuario.  En este caso, el formato para crear una
     paleta de longitud ‘n’ es ‘palette=[color_1, color_2, ...,
     color_n]’, donde ‘color_i’ es un color correctamente definido
     (véase la opción ‘color’), de tal manera que ‘color_1’ se asigna al
     valor más bajo del nivel y ‘color_n’ al más alto.  El resto de
     colores se interpolan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Trabaja conjuntamente con la opción ‘enhanced3d’ en gráficos 3D.

          (%i1) load("draw")$
          (%i2) draw3d(
                  enhanced3d = [z-x+2*y,x,y,z],
                  palette = [32, -8, 17],
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

     También trabaja con imágenes grises.

          (%i1) load("draw")$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     ‘palette’ puede ser una paleta de colores definida por el usuario.
     En este ejemplo, valores bajos de ‘x’ se colorean en rojo y altos
     en amarillo.

          (%i1) load("draw")$
          (%i2) draw3d(
                   palette = [red, blue, yellow],
                   enhanced3d = x,
                   explicit(x^2+y^2,x,-1,1,y,-1,1)) $

     Véase también ‘colorbox’ y ‘enhanced3d’.

 -- Opción gráfica: point_size
     Valor por defecto: 1

     ‘point_size’ establece el tamaño de los puntos dibujados.  Debe ser
     un número no negativo.

     Esta opción no tiene efecto alguno cuando a la opción gráfica
     ‘point_type’ se le ha dado el valor ‘dot’.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘points’.

        • ‘gr3d’: ‘points’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     ‘point_type’ indica cómo se van a dibujar los puntos aislados.  Los
     valores para esta opción pueden ser índices enteros mayores o
     iguales que -1, o también nombres de estilos: ‘$none’ (-1), ‘dot’
     (0), ‘plus’ (1), ‘multiply’ (2), ‘asterisk’ (3), ‘square’ (4),
     ‘filled_square’ (5), ‘circle’ (6), ‘filled_circle’ (7),
     ‘up_triangle’ (8), ‘filled_up_triangle’ (9), ‘down_triangle’ (10),
     ‘filled_down_triangle’ (11), ‘diamant’ (12) y ‘filled_diamant’
     (13).

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘points’.

        • ‘gr3d’: ‘points’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: ‘false’

     Cuando ‘points_joined’ vale ‘true’, los puntos se unen con
     segmentos; si vale ‘false’, se dibujarán puntos aislados.  Un
     tercer valor posible para esta opción gráfica es ‘impulses’; en tal
     caso, se dibujarán segmentos verticales desde los puntos hasta el
     eje-x (2D) o hasta el plano-xy (3D).

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘points’.

        • ‘gr3d’: ‘points’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: proportional_axes
     Valor por defecto: ‘none’

     Cuando ‘proportional_axes’ es igual a ‘xy’ o ‘xy’, una escena 2D o
     3D se dibujará con los ejes proporcionales a sus longitudes
     relativas.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Esta opción sólo funciona con Gnuplot versión 4.2.6 o superior.

     Ejemplos:

     Gráfico en 2D.

          (%i1) load("draw")$
          (%i2) draw2d(
                  ellipse(0,0,1,1,0,360),
                  transparent=true,
                  color = blue,
                  line_width = 4,
                  ellipse(0,0,2,1/2,0,360),
                  proportional_axes = xy) $

     Multiplot.

          (%i1) load("draw")$
          (%i2) draw(
                  terminal = wxt,
                  gr2d(proportional_axes = xy,
                       explicit(x^2,x,0,1)),
                  gr2d(explicit(x^2,x,0,1),
                       xrange = [0,1],
                       yrange = [0,2],
                       proportional_axes=xy),
                  gr2d(explicit(x^2,x,0,1)))$

 -- Opción gráfica: surface_hide
     Valor por defecto: ‘false’

     Cuando ‘surface_hide’ vale ‘true’, las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: terminal
     Valor por defecto: ‘screen’

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: ‘screen’ (por defecto), ‘png’, ‘pngcairo’, ‘jpg’, ‘gif’,
     ‘eps’, ‘eps_color’, ‘epslatex’, ‘epslatex_standalone’, ‘svg’,
     ‘dumb’, ‘dumb_file’, ‘pdf’, ‘pdfcairo’, ‘wxt’, ‘animated_gif’,
     ‘multipage_pdfcairo’, ‘multipage_pdf’, ‘multipage_eps’,
     ‘multipage_eps_color’ y ‘aquaterm’.

     Los terminales ‘screen’, ‘wxt’ y ‘aquaterm’ también se pueden
     definir como una lista de dos elementos: el propio nombre del
     terminal y un número entero no negativo.  De esta forma se pueden
     abrir varias ventanas al mismo tiempo, cada una de ellas con su
     número correspondiente.  Esta modalidad no funciona en plataformas
     Windows.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.  También puede
     usarse como argumento de la función ‘draw’.

     pdfcairo necesita Gnuplot 4.3.  ‘pdf’ necesita que Gnuplot haya
     sido compilado con la opción ‘--enable-pdf’ y libpdf debe estar
     instalado
     (<http://www.pdflib.com/en/download/pdflib-family/pdflib-lite/>).

     Ejemplos:

          (%i1) load("draw")$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       dimensions = [300,300],
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* pdf file */
                draw2d(file_name = "mypdf",
                       dimensions = 100*[12.0,8.0],
                       explicit(x^2,x,-1,1),
                       terminal  = 'pdf)$
          (%i7) /* wxwidgets window */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Ventanas múltiples.
          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^5,x,-2,2), terminal=[screen, 3])$
          (%i3) draw2d(explicit(x^2,x,-2,2), terminal=[screen, 0])$

     Un fichero gif animado.
          (%i1) load("draw")$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opción ‘delay’ sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Salida multipágina en formato eps.
          (%i1) load("draw")$
          (%i2) draw(
                  file_name = "parabol",
                  terminal  = multipage_eps,
                  dimensions = 100*[10,10],
                  gr2d(explicit(x^2,x,-1,1)),
                  gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1))) $

     Véanse también ‘file_name’, ‘pic_width’, ‘pic_height’ y ‘delay’.

 -- Opción gráfica: title
     Valor por defecto: ‘""’ (cadena vacía)

     La opción ‘title’ almacena una cadena con el título de la escena.
     Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: transform
     Valor por defecto: ‘none’

     Si ‘transform’ vale ‘none’, el espacio no sufre transformación
     alguna y los objetos gráficos se representan tal cual se definen.
     Si es necesario transformar el espacio, se debe asignar una lista a
     la opción ‘transform’.  En caso de una escena 2D, la lista toma la
     forma ‘[f1(x,y), f2(x,y), x, y]’.  En caso de una escena 3D, la
     lista debe ser de la forma ‘[f1(x,y,z), f2(x,y,z), f3(x,y,z), x, y,
     z]’.

     Los nombres de las variables definidas en las listas pueden ser
     diferentes de aquellas utilizadas en las definiciones de los
     objetos gráficos.

     Ejemplos:

     Rotación en 2D.

          (%i1) load("draw")$
          (%i2) th : %pi / 4$
          (%i3) draw2d(
                  color = "#e245f0",
                  proportional_axes = 'xy,
                  line_width = 8,
                  triangle([3,2],[7,2],[5,5]),
                  border     = false,
                  fill_color = yellow,
                  transform  = [cos(th)*x - sin(th)*y,
                                sin(th)*x + cos(th)*y, x, y],
                  triangle([3,2],[7,2],[5,5]) )$

     Traslación en 3D.

          (%i1) load("draw")$
          (%i2) draw3d(
                  color     = "#a02c00",
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                  transform = [x+10,y+10,z+10,x,y,z],
                  color     = blue,
                  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3) )$

 -- Opción gráfica: transparent
     Valor por defecto: ‘false’

     Cuando ‘transparent’ vale ‘false’, las regiones internas de los
     polígonos se rellenan de acuerdo con ‘fill_color’.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr2d’: ‘polygon’, ‘rectangle’ y ‘ellipse’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: unit_vectors
     Valor por defecto: ‘false’

     Cuando ‘unit_vectors’ vale ‘true’, los vectores se dibujan con
     módulo unidad.  Esta opción es útil para representar campos
     vectoriales.  Cuando ‘unit_vectors’ vale ‘false’, los vectores se
     dibujan con su longitud original.

     Esta opción sólo es relevante para objetos de tipo ‘vector’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Opción gráfica: user_preamble
     Valor por defecto: ‘""’ (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción ‘plot’ o ‘splot’.

     El valor dado a esta opción debe ser una cadena alfanumérica o una
     lista de cadenas (una por línea).

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     Se le indica a Gnuplot que dibuje los ejes encima de todos los
     demás objetos,
          (%i1) load("draw")$
          (%i2) draw2d(
                  xaxis =true, xaxis_type=solid,
                  yaxis =true, yaxis_type=solid,
                  user_preamble="set grid front",
                  region(x^2+y^2<1 ,x,-1.5,1.5,y,-1.5,1.5))$

 -- Opción gráfica: view
     Valor por defecto: ‘[60,30]’

     Un par de ángulos, medidos en grados, indicando la direcciÃ³n del
     observador en una escena 3D. El primer ángulo es la rotación
     vertical alrededor del eje <x>, dentro del intervalo [0, 360].  El
     segundo es la rotación horizontal alrededor del eje <z>, dentro del
     intervalo [0, 360].

     Dándole a la opción ‘view’ el valor ‘map’, la dirección del
     observador se sitúa perpendicularmente al plano-xy.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(view = [170, 50],
                       enhanced3d = true,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$
          (%i3) draw3d(view = map,
                       enhanced3d = true,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

 -- Opción gráfica: wired_surface
     Valor por defecto: ‘false’

     Indica si las superficies en 3D en modo ‘enhanced3d’ deben mostrar
     o no la malla que unen los puntos.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(
                  enhanced3d    = [sin(x),x,y],
                  wired_surface = true,
                  explicit(x^2+y^2,x,-1,1,y,-1,1)) $

 -- Opción gráfica: x_voxel
     Valor por defecto: 10

     ‘x_voxel’ es el número de voxels en la dirección x a utilizar por
     el algoritmo marching cubes implementado por el objeto ‘implicit’
     tridimensional.  También se utiliza como opción del objeto gráfico
     ‘region’.

 -- Opción gráfica: xaxis
     Valor por defecto: ‘false’

     Si ‘xaxis’ vale ‘true’, se dibujará el eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     Véanse también ‘xaxis_width’, ‘xaxis_type’ y ‘xaxis_color’.

 -- Opción gráfica: xaxis_color
     Valor por defecto: ‘"black"’

     ‘xaxis_color’ especifica el color para el eje <x>.  Véase ‘color’
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     Véanse también ‘xaxis’, ‘xaxis_width’ y ‘xaxis_type’.

 -- Opción gráfica: xaxis_secondary
     Valor por defecto: ‘false’

     Si ‘xaxis_secondary’ vale ‘true’, los valores de las funciones se
     pueden representar respecto del eje <x> secundario, el cual se
     dibuja en la parte superior de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                   key   = "Bottom x-axis",
                   explicit(x+1,x,1,2),
                   color = red,
                   key   = "Above x-axis",
                   xtics_secondary = true,
                   xaxis_secondary = true,
                   explicit(x^2,x,-1,1)) $

     Véanse también ‘xrange_secondary’, ‘xtics_secondary’,
     ‘xtics_rotate_secondary’, ‘xtics_axis_secondary’ y
     ‘xaxis_secondary’.

 -- Opción gráfica: xaxis_type
     Valor por defecto: ‘dots’

     ‘xaxis_type’ indica cómo se debe dibujar el eje <x>; valores
     admisibles son ‘solid’ y ‘dots’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     Véanse también ‘xaxis’, ‘xaxis_width’ y ‘xaxis_color’.

 -- Opción gráfica: xaxis_width
     Valor por defecto: 1

     ‘xaxis_width’ es el ancho del eje <x>.  Su valor debe ser un número
     positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     Véanse también ‘xaxis’, ‘xaxis_type’ y ‘xaxis_color’.

 -- Opción gráfica: xlabel
     Valor por defecto: ‘""’

     La opción ‘xlabel’ almacena una cadena con la etiqueta del eje <x>.
     Por defecto, el eje tiene etiqueta ‘"x"’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también ‘xlabel_secondary’, ‘ylabel’, ‘ylabel_secondary’ y
     ‘zlabel’.

 -- Opción gráfica: xlabel_secondary
     Valor por defecto: ‘""’ (cadena vacía)

     La opción ‘xlabel_secondary’ almacena una cadena con la etiqueta
     del eje <x> secundario.  Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                   xaxis_secondary=true,yaxis_secondary=true,
                   xtics_secondary=true,ytics_secondary=true,
                   xlabel_secondary="t[s]",
                   ylabel_secondary="U[V]",
                   explicit(sin(t),t,0,10) )$

     Véanse también ‘xlabel’, ‘ylabel’, ‘ylabel_secondary’ y ‘zlabel’.

 -- Opción gráfica: xrange
     Valor por defecto: ‘auto’

     Cuando ‘xrange’ vale ‘auto’, el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en ‘xrange=[-2, 3]’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también ‘yrange’ y ‘zrange’.

 -- Opción gráfica: xrange_secondary
     Valor por defecto: ‘auto’

     Cuando ‘xrange_secondary’ vale ‘auto’, el rango del eje <x>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <x>
     secundario, éste debe expresarse como una lista de Maxima, como en
     ‘xrange_secondary=[-2, 3]’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véanse también ‘xrange’, ‘yrange’, ‘zrange’ y ‘yrange_secondary’.

 -- Opción gráfica: xtics
     Valor por defecto: ‘true’

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x>.

        • Cuando a ‘xtics’ se le da el valor <true>, las marcas se
          dibujarán de forma automática.

        • Cuando a ‘xtics’ se le da el valor <false>, no habrá marcas en
          los ejes.

        • Cuando a ‘xtics’ se le da un valor numérico positivo, se
          interpretará como la distancia entre dos marcas consecutivas.

        • Cuando a ‘xtics’ se le da una lista de longitud tres de la
          forma ‘[start,incr,end]’, las marcas se dibujarán desde
          ‘start’ hasta ‘end’ a intervalos de longitud ‘incr’.

        • Cuando a ‘xtics’ se le da un conjunto de números de la forma
          ‘{n1, n2, ...}’, las marcas se dibujarán exactamente en los
          valores ‘n1’, ‘n2’, ...

        • Cuando a ‘xtics’ se le da un conjunto de pares de la forma
          ‘{["label1", n1], ["label2", n2], ...}’, las marcas
          correspondientes a los valores ‘n1’, ‘n2’, ...  se etiquetarán
          con ‘"label1"’, ‘"label2"’, ..., respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Marcas desactivadas.
          (%i1) load("draw")$
          (%i2) draw2d(xtics = 'false,
                       explicit(x^3,x,-1,1)  )$

     Marcas cada 1/4 unidades.
          (%i1) load("draw")$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Marcas desde -3/4 hasta 3/4 en saltos de 1/8.
          (%i1) load("draw")$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Marcas en los puntos -1/2, -1/4 y 3/4.
          (%i1) load("draw")$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Marcas etiquetadas.
          (%i1) load("draw")$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

 -- Opción gráfica: xtics_axis
     Valor por defecto: ‘false’

     Si ‘xtics_axis’ vale ‘true’, las marcas y sus etiquetas se dibujan
     sobre el propio eje <x>, si vale ‘false’ las marcas se colocan a lo
     largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate
     Valor por defecto: ‘false’

     Si ‘xtics_rotate’ vale ‘true’, las marcas del eje <x> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_rotate_secondary
     Valor por defecto: ‘false’

     Si ‘xtics_rotate_secondary’ vale ‘true’, las marcas del eje <x>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_secondary
     Valor por defecto: ‘auto’

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x> secundario.

     Véase ‘xtics’ para una descripción completa.

 -- Opción gráfica: xtics_secondary_axis
     Valor por defecto: ‘false’

     Si ‘xtics_secondary_axis’ vale ‘true’, las marcas y sus etiquetas
     se dibujan sobre el propio eje <x> secundario, si vale ‘false’ las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     ‘xu_grid’ es el número de coordenadas de la primera variable (‘x’
     en superficies explcítas y ‘u’ en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr3d’: ‘explicit’ y ‘parametric_surface’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también ‘yv_grid’.

 -- Opción gráfica: xy_file
     Valor por defecto: ‘""’ (cadena vacía)

     ‘xy_file’ es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla ’x’.  Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Graphic option: xyplane
     Valor por defecto: ‘false’

     Coloca el plano-xy en escenas 3D. Si ‘xyplane’ vale ‘false’, el
     plano-xy se coloca automáticamente; en cambio, si toma un valor
     real, el plano-xy intersectará con el eje <z> a ese nivel.  Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Opción gráfica: y_voxel
     Valor por defecto: 10

     ‘y_voxel’ es el número de voxels en la dirección y a utilizar por
     el algoritmo marching cubes implementado por el objeto ‘implicit’
     tridimensional.  También se utiliza como opción del objeto gráfico
     ‘region’.

 -- Opción gráfica: yaxis
     Valor por defecto: ‘false’

     Si ‘yaxis’ vale ‘true’, se dibujará el eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     Véanse también ‘yaxis_width’, ‘yaxis_type’ y ‘yaxis_color’.

 -- Opción gráfica: yaxis_color
     Valor por defecto: ‘"black"’

     ‘yaxis_color’ especifica el color para el eje <y>.  Véase ‘color’
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     Véanse también ‘yaxis’, ‘yaxis_width’ y ‘yaxis_type’.

 -- Opción gráfica: yaxis_secondary
     Valor por defecto: ‘false’

     Si ‘yaxis_secondary’ vale ‘true’, los valores de las funciones se
     pueden representar respecto del eje <y> secundario, el cual se
     dibuja al lado derecho de la escena.

     Nótese que esta es una opción gráfica local que sólo afecta a
     objetos 2d.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10));

     Véanse también ‘yrange_secondary’, ‘ytics_secondary’,
     ‘ytics_rotate_secondary’ y ‘ytics_axis_secondary’.

 -- Opción gráfica: yaxis_type
     Valor por defecto: ‘dots’

     ‘yaxis_type’ indica cómo se debe dibujar el eje <y>; valores
     admisibles son ‘solid’ y ‘dots’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     Véanse también ‘yaxis’, ‘yaxis_width’ y ‘yaxis_color’.

 -- Opción gráfica: yaxis_width
     Valor por defecto: 1

     ‘yaxis_width’ es el ancho del eje <y>.  Su valor debe ser un número
     positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     Véanse también ‘yaxis’, ‘yaxis_type’ y ‘yaxis_color’.

 -- Opción gráfica: ylabel
     Valor por defecto: ‘""’

     La opción ‘ylabel’ almacena una cadena con la etiqueta del eje <y>.
     Por defecto, el eje tiene etiqueta ‘"y"’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también ‘xlabel’, ‘xlabel_secondary’, ‘ylabel_secondary’ y
     ‘zlabel’.

 -- Opción gráfica: ylabel_secondary
     Valor por defecto: ‘""’ (cadena vacía)

     La opción ‘ylabel_secondary’ almacena una cadena con la etiqueta
     del eje <y> secundario.  Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  key="current",
                  xlabel="t[s]",
                  ylabel="I[A]",ylabel_secondary="P[W]",
                  explicit(sin(t),t,0,10),
                  yaxis_secondary=true,
                  ytics_secondary=true,
                  color=red,key="Power",
                  explicit((sin(t))^2,t,0,10)
              )$

     Véanse también ‘xlabel’, ‘xlabel_secondary’, ‘ylabel’ and ‘zlabel’.

 -- Opción gráfica: yrange
     Valor por defecto: ‘auto’

     Cuando ‘yrange’ vale ‘auto’, el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en ‘yrange=[-2, 3]’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también ‘xrange’ y ‘zrange’.

 -- Opción gráfica: yrange_secondary
     Valor por defecto: ‘auto’

     Cuando ‘yrange_secondary’ vale ‘auto’, el rango del eje <y>
     secundario se calcula de forma automática.

     Si el usuario quiere especificar un intervalo para el eje <y>
     secundario, éste debe expresarse como una lista de Maxima, como en
     ‘yrange_secondary=[-2, 3]’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                   explicit(sin(x),x,0,10),
                   yaxis_secondary = true,
                   ytics_secondary = true,
                   yrange = [-3, 3],
                   yrange_secondary = [-20, 20],
                   color = blue,
                   explicit(100*sin(x+0.1)+2,x,0,10)) $

     Véanse también ‘xrange’, ‘yrange’ y ‘zrange’.

 -- Opción gráfica: ytics
     Valor por defecto: ‘true’

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y>.

     Véase ‘xtics’ para una descripción completa.

 -- Opción gráfica: ytics_axis
     Valor por defecto: ‘false’

     Si ‘ytics_axis’ vale ‘true’, las marcas y sus etiquetas se dibujan
     sobre el propio eje <y>, si vale ‘false’ las marcas se colocan a lo
     largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate
     Valor por defecto: ‘false’

     Si ‘ytics_rotate’ vale ‘true’, las marcas del eje <y> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate_secondary
     Valor por defecto: ‘false’

     Si ‘ytics_rotate_secondary’ vale ‘true’, las marcas del eje <y>
     secundario se giran 90 grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_secondary
     Valor por defecto: ‘auto’

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y> secundario.

     Véase ‘xtics’ para una descripción completa.

 -- Opción gráfica: ytics_secondary_axis
     Valor por defecto: ‘false’

     Si ‘ytics_secondary_axis’ vale ‘true’, las marcas y sus etiquetas
     se dibujan sobre el propio eje <y> secundario, si vale ‘false’ las
     marcas se colocan a lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     ‘yv_grid’ es el número de coordenadas de la segunda variable (‘y’
     en superficies explcítas y ‘v’ en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        • ‘gr3d’: ‘explicit’ y ‘parametric_surface’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también ‘xu_grid’.

 -- Opción gráfica: z_voxel
     Valor por defecto: 10

     ‘z_voxel’ es el número de voxels en la dirección z a utilizar por
     el algoritmo marching cubes implementado por el objeto ‘implicit’
     tridimensional.

 -- Opción gráfica: zaxis
     Valor por defecto: ‘false’

     Si ‘zaxis’ vale ‘true’, se dibujará el eje <z> en escenas 3D. Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     Véanse también ‘zaxis_width’, ‘zaxis_type’ y ‘zaxis_color’.

 -- Opción gráfica: zaxis_color
     Valor por defecto: ‘"black"’

     ‘zaxis_color’ especifica el color para el eje <z>.  Véase ‘color’
     para ver cómo se definen los colores.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     Véanse también ‘zaxis’, ‘zaxis_width’ y ‘zaxis_type’.

 -- Opción gráfica: zaxis_type
     Valor por defecto: ‘dots’

     ‘zaxis_type’ indica cómo se debe dibujar el eje <z>; valores
     admisibles son ‘solid’ y ‘dots’.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     Véanse también ‘zaxis’, ‘zaxis_width’ y ‘zaxis_color’.

 -- Opción gráfica: zaxis_width
     Valor por defecto: 1

     ‘zaxis_width’ es el ancho del eje <z>.  Su valor debe ser un número
     positivo.  Esta opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     Véanse también ‘zaxis’, ‘zaxis_type’ y ‘zaxis_color’.

 -- Opción gráfica: zlabel
     Valor por defecto: ‘""’

     La opción ‘zlabel’ almacena una cadena con la etiqueta del eje <z>.
     Por defecto, el eje tiene etiqueta ‘"z"’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también ‘xlabel’ y ‘ylabel’.

 -- Opción gráfica: zrange
     Valor por defecto: ‘auto’

     Cuando ‘zrange’ vale ‘auto’, el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en ‘zrange=[-2, 3]’.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también ‘xrange’ y ‘yrange’.

 -- Opción gráfica: ztics
     Valor por defecto: ‘true’

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <z>.

     Véase ‘xtics’ para una descripción completa.

 -- Opción gráfica: ztics_axis
     Valor por defecto: ‘false’

     Si ‘ztics_axis’ vale ‘true’, las marcas y sus etiquetas se dibujan
     sobre el propio eje <z>, si vale ‘false’ las marcas se colocan a lo
     largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_rotate
     Valor por defecto: ‘false’

     Si ‘ztics_rotate’ vale ‘true’, las marcas del eje <z> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

47.2.4 Objetos gráficos
-----------------------

 -- Objeto gráfico: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Dibuja barras verticales en 2D.

     2D

     ‘bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])’ dibuja barras
     centradas en los valores <x1>, <x2>, ...  de alturas <h1>, <h2>,
     ...  y anchos <w1>, <w2>, ...

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘key’, ‘fill_color’, ‘fill_density’ y ‘line_width’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                 key          = "Grupo A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Grupo B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Objeto gráfico: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Dibuja funciones 3D definidas en coordenadas cilíndricas.

     3D

     ‘cylindrical (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)’
     dibuja la función ‘<radius>(<z>,<azi>)’ definida en coordenadas
     cilíndricas, con la variable <z> tomando valores desde <minz> hasta
     <maxz> y el azimut <azi> tomando valores desde <minazi> hasta
     <maxazi>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘xu_grid’, ‘yv_grid’, ‘line_type’, ‘key’, ‘wired_surface’,
     ‘enhanced3d’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Objeto gráfico: elevation_grid (<mat>,<x0>,<y0>,<width>,<height>)
     Dibuja la matriz <mat> en 3D. Los valores <z> se toman de <mat>,
     las abscisas van desde <x0> hasta <x0> + <width> y las ordenadas
     desde <y0> hasta <y0> + <height>.  El elemento a(1,1) se proyecta
     sobre el punto (x0,y0+height), a(1,n) sobre (x0+width,y0+height),
     a(m,1) sobre (x0,y0) y a(m,n) sobre (x0+width,y0).

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘line_type’, ‘line_width’, ‘key’, ‘wired_surface’, ‘enhanced3d’ y
     ‘color’.

     En versiones antiguas de Maxima, ‘elevation_grid’ se llamaba
     ‘mesh’.  Véase también ‘mesh’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) m: apply(
                      matrix,
                      makelist(makelist(random(10.0),k,1,30),i,1,20)) $
          (%i3) draw3d(
                   color = blue,
                   elevation_grid(m,0,0,3,2),
                   xlabel = "x",
                   ylabel = "y",
                   surface_hide = true);

 -- Objeto gráfico: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Dibuja elipses y círculos en 2D.

     2D

     ‘ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)’ dibuja una elipse
     de centro ‘[<xc>, <yc>]’ con semiejes horizontal y vertical <a> y
     <b>, respectivamente, comenzando en el ángulo <ang1> y trazando un
     arco de amplitud igual al ángulo <ang2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘nticks’, ‘transparent’, ‘fill_color’, ‘border’, ‘line_width’,
     ‘line_type’, ‘key’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Objeto gráfico: errors ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja puntos con barras de error asociadas horizontales,
     verticales o de ambos tipos, según sea el valor de la opción
     ‘error_type’.

     2D

     Si ‘error_type=x’, los argumentos a ‘errors’ deben ser de la forma
     ‘[x,y,xdelta]’ o ‘[x,y,xlow,xhigh]’.  Si ‘error_type=y’, los
     argumentos deben ser del tipo ‘[x,y,ydelta]’ o ‘[x,y,ylow,yhigh]’.
     Si ‘error_type=xy’ o ‘error_type=boxes’, los argumentos deben ser
     de la forma ‘[x,y,xdelta,ydelta]’ o ‘[x,y,xlow,xhigh,ylow,yhigh]’.

     Véase también ‘error_type’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘error_type’, ‘points_joined’, ‘line_width’, ‘key’, ‘line_type’,
     ‘color’, ‘fill_density’, ‘xaxis_secondary’ y ‘yaxis_secondary’.

     La opción ‘fill_density’ solo es relevante cuando
     ‘error_type=boxes’.

     Ejemplos:

     Barras de error horizontales.

          (%i1) load("draw")$
          (%i2) draw2d(
                  error_type = y,
                  errors([[1,2,1], [3,5,3], [10,3,1], [17,6,2]]))$

     Barras de error horizontales y verticales.

          (%i1) load("draw")$
          (%i2) draw2d(
                  error_type = xy,
                  points_joined = true,
                  color = blue,
                  errors([[1,2,1,2], [3,5,2,1], [10,3,1,1], [17,6,1/2,2]]));

 -- Objeto gráfico: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Objeto gráfico: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja funciones explícitas en 2D y 3D.

     2D

     ‘explicit (<fcn>,<var>,<minval>,<maxval>)’ dibuja la función
     explícita <fcn>, con la variable <var> tomando valores desde
     <minval> hasta <maxval>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘nticks’, ‘adapt_depth’, ‘draw_realpart’, ‘line_width’,
     ‘line_type’, ‘key’, ‘filled_func’, ‘fill_color’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     ‘explicit
     (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)’
     dibuja la función explícita <fcn>, con la variable ‘var1’ tomando
     valores desde <minval1> hasta <maxval1> y la variable <var2>
     tomando valores desde <minval2> hasta <maxval2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘draw_realpart’, ‘xu_grid’, ‘yv_grid’, ‘line_type’, ‘line_width’,
     ‘key’, ‘wired_surface’, ‘enhanced3d’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     Véase también ‘filled_func’ para el relleno de curvas.

 -- Objeto gráfico: image (<im>,<x0>,<y0>,<width>,<height>)
     Reproduce una imagen en 2D.

     2D

     ‘image (<im>,<x0>,<y0>,<width>,<height>)’: dibuja la imagen <im> en
     la región rectangular desde el vértice ‘(<x0>,<y0>)’ hasta el
     ‘(x0+<width>,y0+<height>)’ del plano real.  El argumento <im> debe
     ser una matriz de números reales, una matriz de vectores de
     longitud tres o un objeto de tipo ‘picture’.

     Si <im> es una matriz de números reales, los valores de los píxeles
     se interpretan según indique la opción gráfica ‘palette’, que es un
     vector de longitud tres con sus componentes tomando valores enteros
     en el rango desde -36 a +36; cada valor es un índice para
     seleccionar una fórmula que transforma los niveles numéricos en las
     componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de las
     componentes cromáticas.

     ‘palette = gray’ y ‘palette = color’ son atajos para ‘palette =
     [3,3,3]’ y ‘palette = [7,5,15]’, respectivamente.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.

     Ejemplos:

     Si <im> es una matriz de números reales, los valores de los píxeles
     se interpretan según indique la opción gráfica ‘palette’.
          (%i1) load("draw")$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también ‘colorbox’.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.
          (%i1) load("draw")$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     El paquete ‘draw’ carga automáticamente el paquete ‘picture’.  En
     este ejemplo, una imagen de niveles se define a mano,
     reproduciéndola a continuación.
          (%i1) load("draw")$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     Se lee un fichero xpm y se reproduce.
          (%i1) load("draw")$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     Véanse también ‘make_level_picture’, ‘make_rgb_picture’ y
     ‘read_xpm’.

     En <http://www.telefonica.net/web2/biomates/maxima/gpdraw/image> se
     encuentran ejemplos más elaborados.

 -- Objeto gráfico: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Objeto gráfico: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Dibuja funciones implícitas en 2D y 3D.

     2D

     ‘implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)’ dibuja la
     función implícita <fcn>, con la variable ‘x’ tomando valores desde
     <xmin> hasta <xmax>, y la variable <y> tomando valores desde <ymin>
     hasta <ymax>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘ip_grid’, ‘ip_grid_in’, ‘line_width’, ‘line_type’, ‘key’ y
     ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     ‘implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)’ dibuja la función implícita <fcn>, con la
     variable <x> tomando valores desde <xmin> hasta <xmax>, la variable
     <y> tomando valores desde <ymin> hasta <ymax> y la variable <z>
     tomando valores desde <zmin> hasta <zmax>.  Este objeto está
     programado con el algoritmo marching cubes.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘x_voxel’, ‘y_voxel’, ‘z_voxel’, ‘line_width’, ‘line_type’, ‘key’,
     ‘wired_surface’, ‘enhanced3d’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Objeto gráfico: label ([<string>,<x>,<y>],...)
 -- Objeto gráfico: label ([<string>,<x>,<y>,<z>],...)
     Escribe etiquetas en 2D y 3D.

     Las etiquetas coloreadas sólo trabajan con Gnuplot 4.3.  Este es un
     fallo conocido del paquete ‘draw’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘label_alignment’, ‘label_orientation’ y ‘color’.

     2D

     ‘label([<string>,<x>,<y>])’ escribe la cadena de caracteres
     <string> en el punto ‘[<x>,<y>]’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = red,
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = light_blue,
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     ‘label([<string>,<x>,<y>,<z>])’ escribe la cadena de caracteres
     <string> en el punto ‘[<x>,<y>,<z>]’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Objeto gráfico: mesh (<fila_1>,<fila_2>,...)
     Dibuja un enrejado cuadrangular en 3D.

     3D

     El argumento <fila_i> es una lista de <n> puntos en 3D de la forma
     ‘[[x_i1,y_i1,z_i1], ...,[x_in,y_in,z_in]]’, siendo todas las filas
     de igual longitud.  Todos estos puntos definen una superficie
     arbitraria en 3D. En cierto sentido, se trata de una generalización
     del objeto ‘elevation_grid’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘line_type’, ‘line_width’, ‘color’, ‘key’, ‘wired_surface’,
     ‘enhanced3d’ y ‘transform’.

     Ejemplos:

     Un sencillo ejemplo.

          (%i1) load("draw")$
          (%i2) draw3d(
                   mesh([[1,1,3],   [7,3,1],[12,-2,4],[15,0,5]],
                        [[2,7,8],   [4,3,1],[10,5,8], [12,7,1]],
                        [[-2,11,10],[6,9,5],[6,15,1], [20,15,2]])) $

     Dibujando un triángulo en 3D.

          (%i1) load("draw")$
          (%i2) draw3d(
                  line_width = 2,
                  mesh([[1,0,0],[0,1,0]],
                       [[0,0,1],[0,0,1]])) $

     Dos cuadriláteros.

          (%i1) load("draw")$
          (%i2) draw3d(
                  surface_hide = true,
                  line_width   = 3,
                  color = red,
                  mesh([[0,0,0], [0,1,0]],
                       [[2,0,2], [2,2,2]]),
                  color = blue,
                  mesh([[0,0,2], [0,1,2]],
                       [[2,0,4], [2,2,4]])) $

 -- Objeto gráfico: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Objeto gráfico: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Dibuja funciones paramétricas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘nticks’, ‘line_width’, ‘line_type’, ‘key’, ‘color’ y ‘enhanced3d’.

     2D

     ‘parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)’ dibuja la
     función paramétrica ‘[<xfun>,<yfun>]’, con el parámetro <par>
     tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     ‘parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)’ dibuja
     la curva paramétrica ‘[<xfun>,<yfun>,<zfun>]’, con el parámetro
     <par> tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Objeto gráfico: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Dibuja superficies paramétricas en 3D.

     3D

     ‘parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)’
     dibuja la superficie paramétrica ‘[<xfun>,<yfun>,<zfun>]’, con el
     parámetro <par1> tomando valores desde <par1min> hasta <par1max> y
     el parámetro <par2> tomando valores desde <par2min> hasta
     <par2max>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘draw_realpart’, ‘xu_grid’, ‘yv_grid’, ‘line_type’, ‘line_width’,
     ‘key’, ‘wired_surface’, ‘enhanced3d’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       view           = [100,20],
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Objeto gráfico: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Objeto gráfico: points ([<y1>,<y2>,...])
 -- Objeto gráfico: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Objeto gráfico: points (<matrix>)
 -- Objeto gráfico: points (<1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>)
 -- Objeto gráfico: points (<1d_x_array>, <1d_y_array>, <1d_z_array>)
 -- Objeto gráfico: points (<2d_xy_array>)
 -- Objeto gráfico: points (<2d_xyz_array>)

     Dibuja puntos en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘point_size’, ‘point_type’, ‘points_joined’, ‘line_width’, ‘key’,
     ‘line_type’ y ‘color’.  En modo 3D también se ve afectado por
     ‘enhanced3d’.

     2D

     ‘points ([[<x1>,<y1>], [<x2>,<y2>],...])’ o ‘points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])’ dibuja los puntos
     ‘[<x1>,<y1>]’, ‘[<x2>,<y2>]’, etc.  Si no se dan las abscisas,
     éstas se asignan automáticamente a enteros positivos consecutivos,
     de forma que ‘points([<y1>,<y2>,...])’ dibuja los puntos
     ‘[1,<y1>]’, ‘[2,<y2>]’, etc.  Si <matrix> es una matriz de dos
     columnas o de dos filas, ‘points (<matrix>)’ dibuja los puntos
     asociados.

     Si <1d_y_array> es un array lisp de números en 1D, ‘points
     (<1d_y_array>)’ los dibujará asignando las abscisas a números
     enteros consecutivos.  ‘points (<1d_x_array>, <1d_y_array>)’ dibuja
     los puntos cuyas coordenadas se toman de los dos arrays pasados
     como argumentos.  Si <2d_xy_array> es un array lisp 2D de dos
     filas, o de dos columnas, ‘points (<2d_xy_array>)’ dibuja los
     correspondientes puntos del plano.

     Ejemplos:

     Dos tipos de argumentos para ‘points’, una lista de pares ordenados
     y dos listas con las coordenadas separadas.
          (%i1) load("draw")$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

     Dibujando impulsos.
          (%i1) load("draw")$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     Array con ordenadas.
          (%i1) load("draw")$
          (%i2) a: make_array (flonum, 100) $
          (%i3) for i:0 thru 99 do a[i]: random(1.0) $
          (%i4) draw2d(points(a)) $

     Dos arrays con coordenadas separadas.
          (%i1) load("draw")$
          (%i2) x: make_array (flonum, 100) $
          (%i3) y: make_array (fixnum, 100) $
          (%i4) for i:0 thru 99 do (
                  x[i]: float(i/100),
                  y[i]: random(10) ) $
          (%i5) draw2d(points(x, y)) $

     Un array 2D de dos columnas.
          (%i1) load("draw")$
          (%i2) xy: make_array(flonum, 100, 2) $
          (%i3) for i:0 thru 99 do (
                  xy[i, 0]: float(i/100),
                  xy[i, 1]: random(10) ) $
          (%i4) draw2d(points(xy)) $

     Dibujando un array rellenado con la función ‘read_array’.
          (%i1) load("draw")$
          (%i2) a: make_array(flonum,100) $
          (%i3) read_array (file_search ("pidigits.data"), a) $
          (%i4) draw2d(points(a)) $

     3D

     ‘points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])’ o ‘points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])’ dibuja los
     puntos ‘[<x1>,<y1>,<z1>]’, ‘[<x2>,<y2>,<z2>]’, etc.  Si <matrix> es
     una matriz de tres columnas o de tres filas, ‘points (<matrix>)’
     dibuja los puntos asociados.  Si <matrix> es una matriz columna o
     fila, las abscisas se asignan automáticamente.

     En caso de que los argumentos sean arrays lisp, ‘points
     (<1d_x_array>, <1d_y_array>, <1d_z_array>)’ toma las coordenadas de
     los tres arrays unidimensionales.  Si <2d_xyz_array> es un array 2D
     de tres columnas, o de tres filas, entonces ‘points
     (<2d_xyz_array>)’ dibuja los puntos correspondientes.

     Ejemplos:

     Una muestra tridimensional,
          (%i1) load("draw")$
          (%i2) load ("numericalio")$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Dos muestras tridimensionales,
          (%i1) load("draw")$
          (%i2) load ("numericalio")$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

     Arrays unidimensionales,
          (%i1) load("draw")$
          (%i2) x: make_array (fixnum, 10) $
          (%i3) y: make_array (fixnum, 10) $
          (%i4) z: make_array (fixnum, 10) $
          (%i5) for i:0 thru 9 do (
                  x[i]: random(10),
                  y[i]: random(10),
                  z[i]: random(10) ) $
          (%i6) draw3d(points(x,y,z)) $

     Array bidimensional coloreado,
          (%i1) load("draw")$
          (%i2) xyz: make_array(fixnum, 10, 3) $
          (%i3) for i:0 thru 9 do (
                  xyz[i, 0]: random(10),
                  xyz[i, 1]: random(10),
                  xyz[i, 2]: random(10) ) $
          (%i4) draw3d(
                   enhanced3d = true,
                   points_joined = true,
                   points(xyz)) $

     Números de colores especificados explícitamente por el usuario.
          (%i1) load("draw")$
          (%i2) pts: makelist([t,t^2,cos(t)], t, 0, 15)$
          (%i3) col_num: makelist(k, k, 1, length(pts))$
          (%i4) draw3d(
                  enhanced3d = ['part(col_num,k),k],
                  point_size = 3,
                  point_type = filled_circle,
                  points(pts))$

 -- Objeto gráfico: polar (<radius>,<ang>,<minang>,<maxang>)
     Dibuja funciones 2D definidas en coordenadas polares.

     2D

     ‘polar (<radius>,<ang>,<minang>,<maxang>)’ dibuja la función
     ‘<radius>(<ang>)’ definida en coordenadas polares, con la variable
     <ang> tomando valores desde <minang> hasta <maxang>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘nticks’, ‘line_width’, ‘line_type’, ‘key’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Objeto gráfico: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja polígonos en 2D.

     2D

     ‘polygon ([[<x1>,<y1>], [<x2>,<y2>],...])’ o ‘polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])’: dibuja en el plano un polígono
     de vértices ‘[<x1>,<y1>]’, ‘[<x2>,<y2>]’, etc..

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘transparent’, ‘fill_color’, ‘border’, ‘line_width’, ‘key’,
     ‘line_type’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Objeto gráfico: quadrilateral (<point_1>, <point_2>, <point_3>,
          <point_4>)
     Dibuja un cuadrilátero.

     2D

     ‘quadrilateral ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>],
     [<x4>,<y4>])’ dibuja un cuadrilátero de vértices ‘[<x1>,<y1>]’,
     ‘[<x2>,<y2>]’, ‘[<x3>,<y3>]’ y ‘[<x4>,<y4>]’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘transparent’, ‘fill_color’, ‘border’, ‘line_width’, ‘key’,
     ‘xaxis_secondary’, ‘yaxis_secondary’, ‘line_type’, ‘transform’ y
     ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  quadrilateral([1,1],[2,2],[3,-1],[2,-2]))$

     3D

     ‘quadrilateral ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],
     [<x3>,<y3>,<z3>], [<x4>,<y4>,<z4>])’ dibuja un cuadrilátero de
     vértices ‘[<x1>,<y1>,<z1>]’, ‘[<x2>,<y2>,<z2>]’, ‘[<x3>,<y3>,<z3>]’
     y ‘[<x4>,<y4>,<z4>]’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘line_type’, ‘line_width’, ‘color’, ‘key’, ‘enhanced3d’ y
     ‘transform’.

 -- Objeto gráfico: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Dibuja rectángulos en 2D.

     2D

     ‘rectangle ([<x1>,<y1>], [<x2>,<y2>])’ dibuja un rectángulo de
     vértices opuestos ‘[<x1>,<y1>]’ y ‘[<x2>,<y2>]’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘transparent’, ‘fill_color’, ‘border’, ‘line_width’, ‘key’,
     ‘line_type’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Objeto gráfico: region
          (<expr>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja una región del plano definida por desigualdades.

     2D <expr> es una expresión formada por desigualdades y los
     operadores lógicos ‘and’, ‘or’ y ‘not’.  La región está acotada por
     el rectángulo definido por [<minval1>, <maxval1>] y [<minval2>,
     <maxval2>].

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘fill_color’, ‘key’, ‘x_voxel’ y ‘y_voxel’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  x_voxel = 30,
                  y_voxel = 30,
                  region(x^2+y^2<1 and x^2+y^2 > 1/2,
                         x, -1.5, 1.5, y, -1.5, 1.5));

 -- Objeto gráfico: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Dibuja funciones 3D definidas en coordenadas esféricas.

     3D

     ‘spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)’ dibuja
     la función ‘<radius>(<azi>,<zen>)’ definida en coordenadas
     esféricas, con el azimut <azi> tomando valores desde <minazi> hasta
     <maxazi> y el zenit <zen> tomando valores desde <minzen> hasta
     <maxzen>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘xu_grid’, ‘yv_grid’, ‘line_type’, ‘key’, ‘wired_surface’,
     ‘enhanced3d’ y ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Objeto gráfico: triangle (<punto_1>, <punto_2>, <punto_3>)
     Dibuja un triángulo.

     2D

     ‘triangle ([<x1>,<y1>], [<x2>,<y2>], [<x3>,<y3>])’ dibuja un
     triángulo de vértices ‘[<x1>,<y1>]’, ‘[<x2>,<y2>]’ y ‘[<x3>,<y3>]’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘transparent’, ‘fill_color’, ‘border’, ‘line_width’, ‘key’,
     ‘xaxis_secondary’, ‘yaxis_secondary’, ‘line_type’, ‘transform’ y
     ‘color’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(
                  triangle([1,1],[2,2],[3,-1]))$

     3D

     ‘triangle ([<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>], [<x3>,<y3>,<z3>])’
     dibuja un triángulo de vértices ‘[<x1>,<y1>,<z1>]’,
     ‘[<x2>,<y2>,<z2>]’ y ‘[<x3>,<y3>,<z3>]’.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘line_type’, ‘line_width’, ‘color’, ‘key’, ‘enhanced3d’ y
     ‘transform’.

 -- Objeto gráfico: tube (<xfun>,<yfun>,<zfun>,<rfun>,<p>,<pmin>,<pmax>)
     Dibuja un tubo en 3D de diámetro variable.

     3D

     ‘[<xfun>,<yfun>,<zfun>]’ es la curva paramétrica de parámetro <p>,
     el cual toma valores entre <pmin> y <pmax>.  Se colocan círculos de
     radio <rfun> con sus centros sobre la curva paramétrica y
     perpendiculares a ella.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘xu_grid’, ‘yv_grid’, ‘line_type’, ‘line_width’, ‘key’,
     ‘wired_surface’, ‘enhanced3d’, ‘color’ y ‘capping’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(
                  enhanced3d = true,
                  xu_grid    = 50,
                  tube(cos(a), a, 0, cos(a/10)^2,
                       a, 0, 4*%pi) )$

 -- Objeto gráfico: vector ([<x>,<y>], [<dx>,<dy>])
 -- Objeto gráfico: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Dibuja vectores en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     ‘head_both’, ‘head_length’, ‘head_angle’, ‘head_type’,
     ‘line_width’, ‘line_type’, ‘key’ y ‘color’.

     2D

     ‘vector ([<x>,<y>], [<dx>,<dy>])’ dibuja el vector ‘[<dx>,<dy>]’
     con origen en ‘[<x>,<y>]’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     ‘vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])’ dibuja el vector
     ‘[<dx>,<dy>,<dz>]’ con origen en ‘[<x>,<y>,<z>]’.

     Ejemplo:

          (%i1) load("draw")$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$

