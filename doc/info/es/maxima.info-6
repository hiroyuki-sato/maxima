This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Funciones y variables para draw,  Next: Funciones y variables para picture,  Prev: Introducción a draw,  Up: draw

48.2 Funciones y variables para draw
====================================

 -- Opción gráfica: xrange
     Valor por defecto: `auto'

     Cuando `xrange' vale `auto', el rango de la coordenada <x> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <x>, éste debe
     expresarse como una lista de Maxima, como en `xrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [-3,5],
                       explicit(x^2,x,-1,1))$

     Véanse también `yrange' y `zrange'.

 -- Opción gráfica: yrange
     Valor por defecto: `auto'

     Cuando `yrange' vale `auto', el rango de la coordenada <y> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <y>, éste debe
     expresarse como una lista de Maxima, como en `yrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [-2,3],
                       explicit(x^2,x,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `zrange'.

 -- Opción gráfica: zrange
     Valor por defecto: `auto'

     Cuando `zrange' vale `auto', el rango de la coordenada <z> se
     calcula de forma automática.

     Si el usuario quiere especificar un intervalo para <z>, éste debe
     expresarse como una lista de Maxima, como en `zrange=[-2, 3]'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(yrange = [-3,3],
                       zrange = [-2,5],
                       explicit(x^2+y^2,x,-1,1,y,-1,1),
                       xrange = [-3,3])$

     Véanse también `xrange' y `yrange'.

 -- Opción gráfica: logx
     Valor por defecto: `false'

     Cuando `logx' vale `true', el eje <x> se dibujará en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(log(x),x,0.01,5),
                       logx = true)$

     Véanse también `logy' y `logz'.

 -- Opción gráfica: logy
     Valor por defecto: `false'

     Cuando `logy' vale `true', el eje <y> se dibujará en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(logy = true,
                       explicit(exp(x),x,0,5))$

     Véanse también `logx' y `logz'.

 -- Opción gráfica: logz
     Valor por defecto: `false'

     Cuando `logz' vale `true', el eje <z> se dibujará en la escala
     logarítmica.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(logz = true,
                       explicit(exp(u^2+v^2),u,-2,2,v,-2,2))$

     Véanse también `logx' y `logy'.

 -- Opción gráfica: terminal
     Valor por defecto: `screen'

     Selecciona el terminal a utilizar por Gnuplot; valores posibles
     son: `screen' (por defecto), `png', `jpg', `eps', `eps_color',
     `gif', `animated_gif', `wxt' y `aquaterm'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) /* screen terminal (default) */
                draw2d(explicit(x^2,x,-1,1))$
          (%i3) /* png file */
                draw2d(terminal  = 'png,
                       pic_width = 300,
                       explicit(x^2,x,-1,1))$
          (%i4) /* jpg file */
                draw2d(terminal   = 'jpg,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$
          (%i5) /* eps file */
                draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'eps)$
          (%i6) /* ventana wxwidgets */
                draw2d(explicit(x^2,x,-1,1),
                       terminal  = 'wxt)$

     Un fichero gif animado,
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     Véanse también `file_name', `pic_width', `pic_height' y `delay'.

 -- Opción gráfica: font
     Valor por defecto: `""' (cadena vacía)

     Esta opción permite seleccionar el tipo de fuente a utilizar por el
     terminal. Sólo se puede utilizar un tipo de fuente y tamaño por
     gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font_size'.

     Gnuplot no puede gestionar por sí mismo las fuentes, dejando esta
     tarea a las librerías que dan soporte a los diferentes terminales,
     cada uno con su propia manera de controlar la tipografía. A
     continuación un breve resumen:

        * x11: Utiliza el mecanismo habitual para suministrar las
          fuentes en x11.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(font      = "Arial",
                            font_size = 20,
                            label(["Arial font, size 20",1,1]))$

        * windows: El terminal de windows no permite cambiar fuentes
          desde dentro del gráfico. Una vez se ha creado el gráfico, se
          pueden cambiar las fuentes haciendo clic derecho en el menú
          de la ventana gráfica.

        * png, jpeg, gif: La librería libgd utiliza la ruta a las
          fuentes almacenada en la variable de entorno `GDFONTPATH'; en
          tal caso sólo es necesario darle a la opción `font' el nombre
          de la fuente. También es posible darle la ruta completa al
          fichero de la fuente.

          Ejemplos:

          A la opción `font' se le puede dar la ruta completa al
          fichero de la fuente:
               (%i1) load(draw)$
               (%i2) path: "/usr/share/fonts/truetype/freefont/" $
               (%i3) file: "FreeSerifBoldItalic.ttf" $
               (%i4) draw2d(
                       font      = concat(path, file),
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

          Si la variable de entorno `GDFONTPATH' almacena la ruta a la
          carpeta donde se alojan las fuentes, es posible darle a la
          opción `font' sólo el nombre de la fuente:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "FreeSerifBoldItalic",
                       font_size = 20,
                       color     = red,
                       label(["FreeSerifBoldItalic font, size 20",1,1]),
                       terminal  = png)$

        * Postscript: Las fuentes estándar de Postscript son:
          `"Times-Roman"', `"Times-Italic"', `"Times-Bold"',
          `"Times-BoldItalic"', `"Helvetica"', `"Helvetica-Oblique"',
          `"Helvetica-Bold"', `"Helvetic-BoldOblique"', `"Courier"',
          `"Courier-Oblique"', `"Courier-Bold"' y
          `"Courier-BoldOblique"'.

          Ejemplo:
               (%i1) load(draw)$
               (%i2) draw2d(
                       font      = "Courier-Oblique",
                       font_size = 15,
                       label(["Courier-Oblique font, size 15",1,1]),
                       terminal = eps)$

        * wxt: La librería pango encuentra las fuentes por medio de la
          utilidad `fontconfig'.

        * aqua: La fuente por defecto es `"Times-Roman"'.

     La documentación de gnuplot es una importante fuente de
     información sobre terminales y fuentes.

 -- Opción gráfica: font_size
     Valor por defecto: 12

     Esta opción permite seleccionar el tamaño de la fuente a utilizar
     por el terminal. Sólo se puede utilizar un tipo de fuente y tamaño
     por gráfico. `font_size' sólo se activa cuando la opción `font'
     tiene un valor diferente de la cadena vacía.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Véase también `font'.

 -- Opción gráfica: grid
     Valor por defecto: `false'

     Cuando `grid' vale `true', se dibujará una rejilla sobre el plano
     <xy>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(grid = true,
                       explicit(exp(u),u,-2,2))$

 -- Opción gráfica: title
     Valor por defecto: `""' (cadena vacía)

     La opción `title' almacena una cadena con el título de la escena.
     Por defecto, no se escribe título alguno.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(u),u,-2,2),
                       title = "Exponential function")$

 -- Opción gráfica: xlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `xlabel' almacena una cadena con la etiqueta del eje
     <x>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       explicit(exp(u),u,-2,2),
                       ylabel = "Population")$

     Véanse también `ylabel' y `zlabel'.

 -- Opción gráfica: ylabel
     Valor por defecto: `""' (cadena vacía)

     La opción `ylabel' almacena una cadena con la etiqueta del eje
     <y>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xlabel = "Time",
                       ylabel = "Population",
                       explicit(exp(u),u,-2,2) )$

     Véanse también `xlabel' y `zlabel'.

 -- Opción gráfica: zlabel
     Valor por defecto: `""' (cadena vacía)

     La opción `zlabel' almacena una cadena con la etiqueta del eje
     <z>. Por defecto, el eje no tiene etiqueta.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(zlabel = "Z variable",
                       ylabel = "Y variable",
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2),
                       xlabel = "X variable" )$

     Véanse también `xlabel' y `ylabel'.

 -- Opción gráfica: xtics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <x>.

        * Cuando a `xtics' se le da el valor <auto>, las marcas se
          dibujarán de forma automática.

        * Cuando a `xtics' se le da el valor <none>, no habrá marcas en
          los ejes.

        * Cuando a `xtics' se le da un valor numérico positivo, se
          interpretará como la distancia entre dos marcas consecutivas.

        * Cuando a `xtics' se le da una lista de longitud tres de la
          forma `[start,incr,end]', las marcas se dibujarán desde
          `start' hasta `end' a intervalos de longitud `incr'.

        * Cuando a `xtics' se le da un conjunto de números de la forma
          `{n1, n2, ...}', las marcas se dibujarán exactamente en los
          valores `n1', `n2', ...

        * Cuando a `xtics' se le da un conjunto de pares de la forma
          `{["label1", n1], ["label2", n2], ...}', las marcas
          correspondientes a los valores `n1', `n2', ... se etiquetarán
          con `"label1"', `"label2"', ..., respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Marcas desactivadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 'none,
                       explicit(x^3,x,-1,1)  )$

     Marcas cada 1/4 unidades.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = 1/4,
                       explicit(x^3,x,-1,1)  )$

     Marcas desde -3/4 hasta 3/4 en saltos de 1/8.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = [-3/4,1/8,3/4],
                       explicit(x^3,x,-1,1)  )$

     Marcas en los puntos -1/2, -1/4 y 3/4.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {-1/2,-1/4,3/4},
                       explicit(x^3,x,-1,1)  )$

     Marcas etiquetadas.
          (%i1) load(draw)$
          (%i2) draw2d(xtics = {["High",0.75],["Medium",0],["Low",-0.75]},
                       explicit(x^3,x,-1,1)  )$

 -- Opción gráfica: ytics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <y>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: ztics
     Valor por defecto: `auto'

     Esta opción gráfica controla la forma en la que se dibujarán las
     marcas del eje <z>.

     Véase `xtics' para una descripción completa.

 -- Opción gráfica: xtics_rotate
     Valor por defecto: `false'

     Si `xtics_rotate' vale `true', las marcas del eje <x> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_rotate
     Valor por defecto: `false'

     Si `ytics_rotate' vale `true', las marcas del eje <y> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_rotate
     Valor por defecto: `false'

     Si `ztics_rotate' vale `true', las marcas del eje <z> se giran 90
     grados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xtics_axis
     Valor por defecto: `false'

     Si `xtics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <x>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ytics_axis
     Valor por defecto: `false'

     Si `ytics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <y>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: ztics_axis
     Valor por defecto: `false'

     Si `ztics_axis' vale `true', las marcas y sus etiquetas se dibujan
     sobre el propio eje <z>, si vale `false' las marcas se colocan a
     lo largo del borde del gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: xaxis
     Valor por defecto: `false'

     Si `xaxis' vale `true', se dibujará el eje <x>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = blue)$

     Véanse también `xaxis_width', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xaxis_width
     Valor por defecto: 1

     `xaxis_width' es el ancho del eje <x>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_width = 3)$

     Véanse también `xaxis', `xaxis_type' y `xaxis_color'.

 -- Opción gráfica: xaxis_type
     Valor por defecto: `dots'

     `xaxis_type' indica cómo se debe dibujar el eje <x>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_type  = solid)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_color'.

 -- Opción gráfica: xaxis_color
     Valor por defecto: `"black"'

     `xaxis_color' especifica el color para el eje <x>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       xaxis       = true,
                       xaxis_color = red)$

     Véanse también `xaxis', `xaxis_width' y `xaxis_type'.

 -- Opción gráfica: yaxis
     Valor por defecto: `false'

     Si `yaxis' vale `true', se dibujará el eje <y>.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = blue)$

     Véanse también `yaxis_width', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: yaxis_width
     Valor por defecto: 1

     `yaxis_width' es el ancho del eje <y>.  Su valor debe ser un
     número positivo.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_width = 3)$

     Véanse también `yaxis', `yaxis_type' y `yaxis_color'.

 -- Opción gráfica: yaxis_type
     Valor por defecto: `dots'

     `yaxis_type' indica cómo se debe dibujar el eje <y>; valores
     admisibles son `solid' y `dots'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_type  = solid)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_color'.

 -- Opción gráfica: yaxis_color
     Valor por defecto: `"black"'

     `yaxis_color' especifica el color para el eje <y>. Véase `color'
     para ver cómo se definen los colores.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^3,x,-1,1),
                       yaxis       = true,
                       yaxis_color = red)$

     Véanse también `yaxis', `yaxis_width' y `yaxis_type'.

 -- Opción gráfica: zaxis
     Valor por defecto: `false'

     Si `zaxis' vale `true', se dibujará el eje <z> en escenas 3D. Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = blue)$

     Véanse también `zaxis_width', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zaxis_width
     Valor por defecto: 1

     `zaxis_width' es el ancho del eje <z>.  Su valor debe ser un
     número positivo. Esta opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_width = 3)$

     Véanse también `zaxis', `zaxis_type' y `zaxis_color'.

 -- Opción gráfica: zaxis_type
     Valor por defecto: `dots'

     `zaxis_type' indica cómo se debe dibujar el eje <z>; valores
     admisibles son `solid' y `dots'.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_color'.

 -- Opción gráfica: zaxis_color
     Valor por defecto: `"black"'

     `zaxis_color' especifica el color para el eje <z>. Véase `color'
     para ver cómo se definen los colores.  Esta opción no tiene efecto
     alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1),
                       zaxis       = true,
                       zaxis_type  = solid,
                       zaxis_color = red)$

     Véanse también `zaxis', `zaxis_width' y `zaxis_type'.

 -- Graphic option: xyplane
     Valor por defecto: `false'

     Coloca el plano-xy en escenas 3D. Si `xyplane' vale `false', el
     plano-xy se coloca automáticamente; en cambio, si toma un valor
     real, el plano-xy intersectará con el eje <z> a ese nivel.  Esta
     opción no tiene efecto alguno en escenas 2D.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xyplane = %e-2,
                       explicit(x^2+y^2,x,-1,1,y,-1,1))$

 -- Opción gráfica: rot_vertical
     Valor por defecto: 60

     `rot_vertical' es el ángulo (en grados) de la rotación vertical
     (alrededor del eje <x>) para situar el punto del observador en las
     escenas 3d.

     El ángulo debe pertenecer al intervalo [0, 180].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véase también `rot_horizontal'.

 -- Opción gráfica: rot_horizontal
     Valor por defecto: 30

     `rot_horizontal' es el ángulo (en grados) de la rotación horizontal
     (alrededor del eje <z>) para situar el punto del observador en las
     escenas 3d.

     El ángulo debe pertenecer al intervalo [0, 360].

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(rot_vertical = 170,
                       rot_horizontal = 360,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véase también `rot_vertical'.

 -- Opción gráfica: xy_file
     Valor por defecto: `""' (cadena vacía)

     `xy_file' es el nombre del fichero donde se almacenarán las
     coordenadas después de hacer clic con el botón del ratón en un
     punto de la imagen y pulsado la tecla 'x'. Por defecto, las
     coordenadas no se almacenan.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

 -- Opción gráfica: user_preamble
     Valor por defecto: `""' (cadena vacía)

     Usuarios expertos en Gnuplot pueden hacer uso de esta opción para
     afinar el comportamiento de Gnuplot escribiendo código que será
     enviado justo antes de la instrucción `plot' o `splot'.

     El valor dado a esta opción debe ser una cadena alfanumérica o una
     lista de cadenas (una por línea).

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

     El terminal dumb no está soportado por el paquete `draw', pero es
     posible activarlo haciendo uso de la opción `user_preamble',
          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x)-1,x,-1,1),
                       parametric(cos(u),sin(u),u,0,2*%pi),
                       user_preamble="set terminal dumb")$

 -- Opción gráfica: file_name
     Valor por defecto: `"maxima_out"'

     `file_name' es el nombre del fichero en el que los terminales
     `png', `jpg', `eps' y `eps_color' guardarán el gráfico.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(file_name = "myfile",
                       explicit(x^2,x,-1,1),
                       terminal  = 'png)$

     Véanse también `terminal', `pic_width' y `pic_height'.

 -- Opción gráfica: delay
     Valor por defecto: 5

     Este es el retraso en centésimas de segundo entre imágenes en los
     ficheros gif animados.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     La opciób `delay' sólo se activa en caso de gifs animados; se
     ignora en cualquier otro caso.

     See also `terminal', `pic_width', and `pic_height'.

 -- Opción gráfica: pic_width
     Valor por defecto: 640

     `pic_width' es la anchura del fichero de imagen de bits generado
     por los terminales `png' y `jpg'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pic_height'.

 -- Opción gráfica: pic_height
     Valor por defecto: 640

     `pic_height' es la altura del fichero de imagen de bits generado
     por los terminales `png' y `jpg'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'png,
                       pic_width  = 300,
                       pic_height = 300,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `pic_width'.

 -- Opción gráfica: eps_width
     Valor por defecto: 12

     `eps_width' es el ancho (medido en cm) del archivo Postscipt
     generado por los terminales `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `eps_height'.

 -- Opción gráfica: eps_height
     Valor por defecto: 8

     `eps_height' es la altura (medida en cm) del archivo Postscipt
     generado por los terminales `eps' y `eps_color'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal   = 'eps,
                       eps_width  = 3,
                       eps_height = 3,
                       explicit(x^2,x,-1,1))$

     Véanse también `terminal', `file_name' y `eps_width'.

 -- Opción gráfica: axis_bottom
     Valor por defecto: `true'

     Cuando `axis_bottom' vale `true', el eje inferior permanece
     visible en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_bottom = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_left',  `axis_top', `axis_right' y `axis_3d'.

 -- Opción gráfica: axis_left
     Valor por defecto: `true'

     Cuando `axis_left' vale `true', el eje izquierdo permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_left = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_top', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_top
     Valor por defecto: `true'

     Cuando `axis_top' vale `true', el eje superior permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_top = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_right' y
     `axis_3d'.

 -- Opción gráfica: axis_right
     Valor por defecto: `true'

     Cuando `axis_right' vale `true', el eje derecho permanece visible
     en las escenas 2d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(axis_right = false,
                       explicit(x^3,x,-1,1))$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y `axis_3d'.

 -- Opción gráfica: axis_3d
     Valor por defecto: `true'

     Cuando `axis_3d' vale `true', los ejes <x>, <y> y <z> permanecen
     visibles en las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(axis_3d = false,
                       explicit(sin(x^2+y^2),x,-2,2,y,-2,2) )$

     Véanse también `axis_bottom',  `axis_left', `axis_top' y
     `axis_right' for axis in 2d.

 -- Opción gráfica: palette
     Valor por defecto: `color'

     `palette' indica cómo transformar los valores reales de una matriz
     pasada al objeto `image' en componentes cromáticas.

     `palette' es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84     32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

 -- Opción gráfica: colorbox
     Valor por defecto: `true'

     Cuando `colorbox' vale `true', se dibuja una escala de color al
     lado de los objetos `image'.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) im: apply('matrix,
                           makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(colorbox=false, image(im,0,0,30,30))$

     Véase también `palette'.

 -- Opción gráfica: enhanced3d
     Valor por defecto: `false'

     Si `enhanced3d' vale `false', no se colorearán las superficies de
     los gráficos tridimensionales. Si `enhanced3d' vale `true', las
     superficies se colorearán activando el modo pm3d de Gnuplot.  Si
     se da una expresión a `enhanced3d', ésta se utilizará para asignar
     colores de acuerdo con el valor de la opción `palette'; las
     variables de esta expresión deben ser las mismas que luego se
     utilicen para la descripción de la superficie.

     Ejemplos:

          (%i1) load(draw)$
          (%i2) draw3d(
                   surface_hide = true,
                   enhanced3d   = true,
                   palette      = gray,
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$
          (%i3) draw3d(
                   surface_hide = true,
                   /* mismas variables x e y que */
                   /* en explicit mas abajo:     */
                   enhanced3d   = sin(x*y),
                   explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3))$

 -- Opción gráfica: point_size
     Valor por defecto: 1

     `point_size' establece el tamaño de los puntos dibujados. Debe ser
     un número no negativo.

     Esta opción no tiene efecto alguno cuando a la opción gráfica
     `point_type' se le ha dado el valor `dot'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_size = 5,
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)))$

 -- Opción gráfica: point_type
     Valor por defecto: 1

     `point_type' indica cómo se van a dibujar los puntos aislados. Los
     valores para esta opción pueden ser índices enteros mayores o
     iguales que -1, o también nombres de estilos: `$none' (-1), `dot'
     (0), `plus' (1), `multiply' (2), `asterisk' (3), `square' (4),
     `filled_square' (5), `circle' (6), `filled_circle' (7),
     `up_triangle' (8), `filled_up_triangle' (9), `down_triangle' (10),
     `filled_down_triangle' (11), `diamant' (12) y `filled_diamant'
     (13).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange = [0,10],
                       yrange = [0,10],
                       point_size = 3,
                       point_type = diamant,
                       points([[1,1],[5,1],[9,1]]),
                       point_type = filled_down_triangle,
                       points([[1,2],[5,2],[9,2]]),
                       point_type = asterisk,
                       points([[1,3],[5,3],[9,3]]),
                       point_type = filled_diamant,
                       points([[1,4],[5,4],[9,4]]),
                       point_type = 5,
                       points([[1,5],[5,5],[9,5]]),
                       point_type = 6,
                       points([[1,6],[5,6],[9,6]]),
                       point_type = filled_circle,
                       points([[1,7],[5,7],[9,7]]),
                       point_type = 8,
                       points([[1,8],[5,8],[9,8]]),
                       point_type = filled_diamant,
                       points([[1,9],[5,9],[9,9]]) )$

 -- Opción gráfica: points_joined
     Valor por defecto: `false'

     Cuando `points_joined' vale `true', los puntos se unen con
     segmentos; si vale `false', se dibujarán puntos aislados. Un
     tercer valor posible para esta opción gráfica es `impulses'; en
     tal caso, se dibujarán segmentos verticales desde los puntos hasta
     el eje-x (2D) o hasta el plano-xy (3D).

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points'.

        * `gr3d': `points'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange        = [0,10],
                       yrange        = [0,4],
                       point_size    = 3,
                       point_type    = up_triangle,
                       color         = blue,
                       points([[1,1],[5,1],[9,1]]),
                       points_joined = true,
                       point_type    = square,
                       line_type     = dots,
                       points([[1,2],[5,2],[9,2]]),
                       point_type    = circle,
                       color         = red,
                       line_width    = 7,
                       points([[1,3],[5,3],[9,3]]) )$

 -- Opción gráfica: filled_func
     Valor por defecto: `false'

     La opción `filled_func' establece cómo se van a rellenar las
     regiones limitadas por funciones. Si `filled_func' vale `true', la
     región limitada por la función definida en el objeto `explicit' y
     el borde inferior del la ventana gráfica se rellena con
     `fill_color'.  Si `filled_func' guarda la expresión de una
     función, entonces la región limitada por esta función y la
     definida en el objeto `explicit' será la que se rellene. Por
     defecto, las funciones explícitas no se rellenan.

     Esta opción sólo afecta al objeto gráfico bidimensional `explicit'.

     Ejemplo:

     Región limitada por un objeto `explicit' y el borde inferior de la
     ventana gráfica.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       filled_func = true,
                       explicit(sin(x),x,0,10) )$

     Región limitada por un objeto `explicit' y la función definida en
     la opción `filled_func'. Nótese que la variable en `filled_func'
     debe ser la misma que la utilizada en `explicit'.
          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = grey,
                       filled_func = sin(x),
                       explicit(-sin(x),x,0,%pi));

     Véanse también `fill_color' y `explicit'.

 -- Opción gráfica: transparent
     Valor por defecto: `false'

     Cuando `transparent' vale `true', las regiones internas de los
     polígonos se rellenan de acuerdo con `fill_color'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(polygon([[3,2],[7,2],[5,5]]),
                       transparent = true,
                       color       = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: border
     Valor por defecto: `true'

     Cuando `border' vale `true', los bordes de los polígonos se
     dibujan de acuerdo con `line_type' y `line_width'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `polygon', `rectangle' y `ellipse'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color       = brown,
                       line_width  = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = blue,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Opción gráfica: head_both
     Valor por defecto: `false'

     Cuando `head_both' vale `true', los vectores se dibujan
     bidireccionales.  Si vale `false', se dibujan unidireccionales.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,8],
                       yrange      = [0,8],
                       head_length = 0.7,
                       vector([1,1],[6,0]),
                       head_both   = true,
                       vector([1,7],[6,0]) )$

     Véanse también `head_length', `head_angle' y `head_type'.

 -- Opción gráfica: head_length
     Valor por defecto: 2

     `head_length' indica, en las unidades del eje <x>, la longitud de
     las flechas de los vectores.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,8],
                       vector([0,1],[5,5]),
                       head_length = 1,
                       vector([2,1],[5,5]),
                       head_length = 0.5,
                       vector([4,1],[5,5]),
                       head_length = 0.25,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_type'.

 -- Opción gráfica: head_angle
     Valor por defecto: 45

     `head_angle' indica el ángulo, en grados, entre la flecha y el
     segmento del vector.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,10],
                       yrange      = [0,9],
                       head_length = 0.7,
                       head_angle  = 10,
                       vector([1,1],[0,6]),
                       head_angle  = 20,
                       vector([2,1],[0,6]),
                       head_angle  = 30,
                       vector([3,1],[0,6]),
                       head_angle  = 40,
                       vector([4,1],[0,6]),
                       head_angle  = 60,
                       vector([5,1],[0,6]),
                       head_angle  = 90,
                       vector([6,1],[0,6]),
                       head_angle  = 120,
                       vector([7,1],[0,6]),
                       head_angle  = 160,
                       vector([8,1],[0,6]),
                       head_angle  = 180,
                       vector([9,1],[0,6]) )$

     Véanse también `head_both', `head_length' y `head_type'.

 -- Opción gráfica: head_type
     Valor por defecto: `filled'

     `head_type' se utiliza para especificar cómo se habrán de dibujar
     las flechas de los vectores. Los valores posibles para esta opción
     son: `filled' (flechas cerradas y rellenas), `empty' (flechas
     cerradas pero no rellenas) y `nofilled' (flechas abiertas).

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_type = 'nofilled,
                       vector([6,1],[5,5]))$

     Véanse también `head_both', `head_angle' y `head_length'.

 -- Opción gráfica: unit_vectors
     Valor por defecto: `false'

     Cuando `unit_vectors' vale `true', los vectores se dibujan con
     módulo unidad.  Esta opción es útil para representar campos
     vectoriales. Cuando `unit_vectors' vale `false', los vectores se
     dibujan con su longitud original.

     Esta opción sólo es relevante para objetos de tipo `vector'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [-1,6],
                       yrange      = [-1,6],
                       head_length = 0.1,
                       vector([0,0],[5,2]),
                       unit_vectors = true,
                       color        = red,
                       vector([0,3],[5,2]))$

 -- Opción gráfica: label_alignment
     Valor por defecto: `center'

     `label_alignment' se utiliza para especificar dónde se escribirán
     las etiquetas con respecto a las coordenadas de referencia. Los
     valores posibles para esta opción son: `center', `left' y `right'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange          = [0,10],
                       yrange          = [0,10],
                       points_joined   = true,
                       points([[5,0],[5,10]]),
                       color           = blue,
                       label(["Centered alignment (default)",5,2]),
                       label_alignment = 'left,
                       label(["Left alignment",5,5]),
                       label_alignment = 'right,
                       label(["Right alignment",5,8]))$

     Véanse también `label_orientation' y `color'.

 -- Opción gráfica: label_orientation
     Valor por defecto: `horizontal'

     `label_orientation' se utiliza para especificar la orientación de
     las etiquetas. Los valores posibles para esta opción son:
     `horizontal' y `vertical'.

     Esta opción sólo es relevante para objetos de tipo `label'.

     Ejemplo:

     En este ejemplo, el punto ficticio que se añade sirve para obtener
     la imagen, ya que el paquete `draw' necesita siempre de datos para
     construir la escena.
          (%i1) load(draw)$
          (%i2) draw2d(xrange     = [0,10],
                       yrange     = [0,10],
                       point_size = 0,
                       points([[5,5]]),
                       color      = navy,
                       label(["Horizontal orientation (default)",5,2]),
                       label_orientation = 'vertical,
                       color             = "#654321",
                       label(["Vertical orientation",1,5]))$

     Véanse también `label_alignment' y `color'.

 -- Opción gráfica: color
     Valor por defecto: `"black"'

     `color' especifica el color para dibujar líneas, puntos, bordes de
     polígonos y etiquetas.

     Los colores se pueden dar a partir de sus nombres o en código
     hexadecimal rgb.

     Los nombres de colores disponibles son: `"white"', `"black"',
     `"gray0"', `"grey0"', `"gray10"', `"grey10"', `"gray20"',
     `"grey20"', `"gray30"', `"grey30"', `"gray40"', `"grey40"',
     `"gray50"', `"grey50"', `"gray60"', `"grey60"', `"gray70"',
     `"grey70"', `"gray80"', `"grey80"', `"gray90"', `"grey90"',
     `"gray100"', `"grey100"', `"gray"', `"grey"', `"light-gray"',
     `"light-grey"', `"dark-gray"', `"dark-grey"', `"red"',
     `"light-red"', `"dark-red"', `"yellow"', `"light-yellow"',
     `"dark-yellow"', `"green"', `"light-green"', `"dark-green"',
     `"spring-green"', `"forest-green"', `"sea-green"', `"blue"',
     `"light-blue"', `"dark-blue"', `"midnight-blue"', `"navy"',
     `"medium-blue"', `"royalblue"', `"skyblue"', `"cyan"',
     `"light-cyan"', `"dark-cyan"', `"magenta"', `"light-magenta"',
     `"dark-magenta"', `"turquoise"', `"light-turquoise"',
     `"dark-turquoise"', `"pink"', `"light-pink"', `"dark-pink"',
     `"coral"', `"light-coral"', `"orange-red"', `"salmon"',
     `"light-salmon"', `"dark-salmon"', `"aquamarine"', `"khaki"',
     `"dark-khaki"', `"goldenrod"', `"light-goldenrod"',
     `"dark-goldenrod"', `"gold"', `"beige"', `"brown"', `"orange"',
     `"dark-orange"', `"violet"', `"dark-violet"', `"plum"' y
     `"purple"'.

     Las componentes cromáticas en código hexadecimal se introducen en
     el formato `"#rrggbb"'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default is black */
                       color = "red",
                       explicit(0.5 + x^2,x,-1,1),
                       color = blue,
                       explicit(1 + x^2,x,-1,1),
                       color = "light-blue", /* double quotes if - is used */
                       explicit(1.5 + x^2,x,-1,1),
                       color = "#23ab0f",
                       label(["This is a label",0,1.2])  )$

     Véase también `fill_color'.

 -- Opción gráfica: fill_color
     Valor por defecto: `"red"'

     `fill_color' especifica el color para rellenar polígonos y
     funciones explícitas bidimensionales.

     Véase `color' para más información sobre cómo definir colores.

 -- Opción gráfica: fill_density
     Valor por defecto: 0

     `fill_density' es un número entre 0 y 1 que especifica la
     intensidad del color de relleno (dado por `fill_color') en los
     objetos `bars'.

     Véase `bars' para ejemplos.

 -- Opción gráfica: line_width
     Valor por defecto: 1

     `line_width' es el ancho de las líneas a dibujar.  Su valor debe
     ser un número positivo.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points' y `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(x^2,x,-1,1), /* default width */
                       line_width = 5.5,
                       explicit(1 + x^2,x,-1,1),
                       line_width = 10,
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_type'.

 -- Opción gráfica: line_type
     Valor por defecto: 1

     `line_type' indica cómo se van a dibujar las líneas; valores
     posibles son `solid' y `dots'.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric' y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_type = dots,
                       explicit(1 + x^2,x,-1,1),
                       line_type = solid, /* default */
                       explicit(2 + x^2,x,-1,1))$

     Véase también `line_width'.

 -- Opción gráfica: nticks
     Valor por defecto: 30

     En 2d, `nticks' es el número de puntos a utilizar por el programa
     adaptativo que genera las funciones explícitas. También es el
     número de puntos que se representan en las curvas paramétricas y
     polares.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `ellipse', `explicit', `parametric' y `polar'.

        * `gr3d': `parametric'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = true,
                       ellipse(0,0,4,2,0,180),
                       nticks = 5,
                       ellipse(0,0,4,2,180,180) )$

 -- Opción gráfica: adapt_depth
     Valor por defecto: 10

     `adapt_depth' es el número máximo de particiones utilizadas por la
     rutina gráfica adaptativa.

     Esta opción sólo es relevante para funciones de tipo `explicit' en
     2d.

 -- Opción gráfica: key
     Valor por defecto: `""' (cadena vacía)

     `key' es la clave de una función en la leyenda. Si `key' es una
     cadena vacía, las funciones no tendrán clave asociada en la
     leyenda.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr2d': `points', `polygon', `rectangle', `ellipse',
          `vector', `explicit', `implicit', `parametric' y `polar'.

        * `gr3d': `points', `explicit', `parametric', y
          `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(key   = "Sinus",
                       explicit(sin(x),x,0,10),
                       key   = "Cosinus",
                       color = red,
                       explicit(cos(x),x,0,10) )$

 -- Opción gráfica: xu_grid
     Valor por defecto: 30

     `xu_grid' es el número de coordenadas de la primera variable (`x'
     en superficies explcítas y `u' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `yv_grid'.

 -- Opción gráfica: yv_grid
     Valor por defecto: 30

     `yv_grid' es el número de coordenadas de la segunda variable (`y'
     en superficies explcítas y `v' en las paramétricas) para formar la
     rejilla de puntos muestrales.

     Esta opción afecta a los siguientes objetos gráficos:
        * `gr3d': `explicit' y `parametric_surface'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(xu_grid = 10,
                       yv_grid = 50,
                       explicit(x^2+y^2,x,-3,3,y,-3,3) )$

     Véase también `xu_grid'.

 -- Opción gráfica: surface_hide
     Valor por defecto: `false'

     Cuando `surface_hide' vale `true', las partes ocultas no se
     muestran en las superficies de las escenas 3d.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw(columns=2,
                     gr3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)),
                     gr3d(surface_hide = true,
                          explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3)) )$

 -- Opción gráfica: contour
     Valor por defecto: `none'

     La opción `contour' permite al usuario decidir dónde colocar las
     líneas de nivel.  Valores posibles son:

        * `none': no se dibujan líneas de nivel.

        * `base': las líneas de nivel se proyectan sobre el plano xy.

        * `surface': las líneas de nivel se dibujan sobre la propia
          superficie.

        * `both': se dibujan dos conjuntos de líneas de nivel: sobre la
          superficie y las que se proyectan sobre el plano xy.

        * `map': las líneas de nivel se proyectan sobre el plano xy y
          el punto de vista del observador se coloca perpendicularmente
          a él.


     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 15,
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour_levels'.

 -- Opción gráfica: contour_levels
     Valor por defecto: 5

     Esta opción gráfica controla cómo se dibujarán las líneas de
     nivel. A `contour_levels' se le puede asignar un número entero
     positivo, una lista de tres números o un conjunto numérico
     arbitrario:

        * Si a `contour_levels' se le asigna un entero positivo <n>,
          entonces se dibujarán <n> líneas de nivel a intervalos
          iguales. Por defecto, se dibujaán cinco isolíneas.

        * Si a `contour_levels' se le asigna una lista de tres números
          de la forma `[inf,p,sup]', las isolíneas se dibujarán desde
          `inf' hasta `sup' en pasos de amplitud `p'.

        * Si a `contour_levels' se le asigna un conjunto de números de
          la forma `{n1, n2, ...}', entonces se dibujarán las isolíneas
          correspondientes a los niveles `n1', `n2', ...

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia.

     Ejemplos:

     Diez isolíneas igualmente espaciadas. El número real puede
     ajustarse a fin de poder conseguir etiquetas más sencillas.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = 10,
                       contour        = both,
                       surface_hide   = true) $

     Desde -8 hasta 8 en pasos de amplitud 4.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = [-8,4,8],
                       contour        = both,
                       surface_hide   = true) $

     Líneas correspondientes a los niveles -7, -6, 0.8 y 5.
          (%i1) load(draw)$
          (%i2) draw3d(color = green,
                       explicit(20*exp(-x^2-y^2)-10,x,0,2,y,-3,3),
                       contour_levels = {-7, -6, 0.8, 5},
                       contour        = both,
                       surface_hide   = true) $

     Véase también `contour'.

 -- Opción gráfica: columns
     Valor por defecto: 1

     `columns' es el número de columnas en gráficos múltiples.

     Puesto que ésta es una opción global, su posición dentro de la
     descripción de la escena no reviste importancia. También puede
     usarse como argumento de la función `draw'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$


 -- Opción gráfica: ip_grid
     Valor por defecto: `[50, 50]'

     `ip_grid' establece la rejilla del primer muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: ip_grid_in
     Valor por defecto: `[5, 5]'

     `ip_grid_in' establece la rejilla del segundo muestreo para los
     gráficos de funciones implícitas.

     Esta opción sólo es relevante para funciones de tipo `implicit'.

 -- Opción gráfica: x_voxel
     Valor por defecto: 10

     `x_voxel' es el número de voxels en la dirección x a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Opción gráfica: y_voxel
     Valor por defecto: 10

     `y_voxel' es el número de voxels en la dirección y a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Opción gráfica: z_voxel
     Valor por defecto: 10

     `z_voxel' es el número de voxels en la dirección z a utilizar por
     el algoritmo marching cubes implementado por el objeto `implicit'
     tridimensional.

 -- Constructor de escena: gr2d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr2d' construye un objeto que describe una escena 2d.
     Los argumentos son opciones gráficas y objetos gráficos. Esta
     escena se interpreta secuencialmente: las opciones gráficas
     afectan a aquellos objetos gráficos colocados a su derecha.
     Algunas opciones gráficas afectan al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en dos
     dimensiones: `points', `polygon', `rectangle', `ellipse', `label',
     `vector', `explicit', `implicit', `polar', `parametric', `image' y
     `geomap'.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también las siguientes opciones gráficas: `xrange',
     `yrange', `logx', `logy', `terminal', `grid', `title', `xlabel',
     `ylabel', `xtics', `ytics', `xtics_rotate', `ytics_rotate',
     `xtics_axis', `ytics_axis', `xaxis', `yaxis', `xaxis_width',
     `yaxis_width', `xaxis_type', `yaxis_type', `xaxis_color',
     `yaxis_color', `xy_file', `file_name', `pic_width', `pic_height',
     `eps_width', `eps_height', `user_preamble', `axis_bottom',
     `axis_left', `axis_top' y `axis_right'.

 -- Constructor de escena: gr3d (<Opción gráfica>, ...,
          <graphic_object>, ...)
     La función `gr3d' construye un objeto que describe una escena 3d.
     Los argumentos son opciones gráficas y objetos gráficos. Esta
     escena se interpreta secuencialmente: las opciones gráficas
     afectan a aquellos objetos gráficos colocados a su derecha.
     Algunas opciones gráficas afectan al aspecto global de la escena.

     La lista de objetos gráficos disponibles para escenas en tres
     dimensiones: `points', `label', `vector', `explicit', `implicit',
     `parametric', `parametric_surface' y `geomap'.

     Véanse también las siguientes opciones gráficas: `xrange',
     `yrange', `zrange', `logx', `logy', `logz', `terminal', `grid',
     `title', `xlabel', `ylabel', `zlabel', `xtics', `ytics', `ztics',
     `xtics_rotate', `ytics_rotate', `ztics_rotate', `xtics_axis',
     `ytics_axis', `ztics_axis', `xaxis', `yaxis', `zaxis',
     `xaxis_width', `yaxis_width', `zaxis_width', `xaxis_type',
     `yaxis_type', `zaxis_type', `xaxis_color', `yaxis_color',
     `zaxis_color', `xy_file', `user_preamble', `axis_bottom',
     `axis_left', `axis_top', `file_name', `pic_width', `pic_height',
     `eps_width', `eps_height', `axis_right', `rot_vertical',
     `rot_horizontal', `axis_3d', `xu_grid', `yv_grid', `surface_hide',
     `contour', `contour_levels', `palette', `colorbox' y `enhanced3d'.

     Para utilizar esta función, ejecútese primero `load(draw)'.

 -- Objeto gráfico: points ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...])
 -- Objeto gráfico: points ([<y1>,<y2>,...])
 -- Objeto gráfico: points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])
 -- Objeto gráfico: points ([<x1>,<x2>,...], [<y1>,<y2>,...],
          [<z1>,<z2>,...])
 -- Objeto gráfico: points (<matrix>)
     Dibuja puntos en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `point_size', `point_type', `points_joined', `line_width', `key',
     `line_type' y `color'.

     2D

     `points ([[<x1>,<y1>], [<x2>,<y2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...])' dibuja los puntos
     `[<x1>,<y1>]', `[<x2>,<y2>]', etc. Si no se dan las abscisas,
     éstas se asignan automáticamente a enteros positivos consecutivos,
     de forma que `points([<y1>,<y2>,...])' dibuja los puntos
     `[1,<y1>]', `[2,<y2>]', etc.  Si <matrix> es una matriz de dos
     columnas o de dos filas, `points (<matrix>)' dibuja los puntos
     asociados.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                  key = "Small points",
                  points(makelist([random(20),random(50)],k,1,10)),
                  point_type    = circle,
                  point_size    = 3,
                  points_joined = true,
                  key           = "Great points",
                  points(makelist(k,k,1,20),makelist(random(30),k,1,20)),
                  point_type    = filled_down_triangle,
                  key           = "Automatic abscissas",
                  color         = red,
                  points([2,12,8]))$

          (%i1) load(draw)$
          (%i2) draw2d(
                  points_joined = impulses,
                  line_width    = 2,
                  color         = red,
                  points(makelist([random(20),random(50)],k,1,10)))$

     3D

     `points ([[<x1>,<y1>,<z1>], [<x2>,<y2>,<z2>],...])' o `points
     ([<x1>,<x2>,...], [<y1>,<y2>,...], [<z1>,<z2>,...])' dibuja los
     puntos `[<x1>,<y1>,<z1>]', `[<x2>,<y2>,<z2>]', etc.  Si <matrix>
     es una matriz de tres columnas o de tres filas, `points (<matrix>)'
     dibuja los puntos asociados. Si <matrix> es una matriz columna o
     fila, las abscisas se asignan automáticamente.

     Ejemplo:

     Una muestra tridimensional,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(title = "Daily average wind speeds",
                       point_size = 2,
                       points(args(submatrix (s2, 4, 5))) )$

     Dos muestras tridimensionales,
          (%i1) load(draw)$
          (%i2) load (numericalio)$
          (%i3) s2 : read_matrix (file_search ("wind.data"))$
          (%i4) draw3d(
                   title = "Daily average wind speeds. Two data sets",
                   point_size = 2,
                   key        = "Sample from stations 1, 2 and 3",
                   points(args(submatrix (s2, 4, 5))),
                   point_type = 4,
                   key        = "Sample from stations 1, 4 and 5",
                   points(args(submatrix (s2, 2, 3))) )$

 -- Objeto gráfico: polygon ([[<x1>,<y1>], [<x2>,<y2>],...])
 -- Objeto gráfico: polygon ([<x1>,<x2>,...], [<y1>,<y2>,...])
     Dibuja polígonos en 2D.

     2D

     `polygon ([[<x1>,<y1>], [<x2>,<y2>],...])' o `polygon
     ([<x1>,<x2>,...], [<y1>,<y2>,...])': dibuja en el plano un
     polígono de vértices `[<x1>,<y1>]', `[<x2>,<y2>]', etc..

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(color      = "#e245f0",
                       line_width = 8,
                       polygon([[3,2],[7,2],[5,5]]),
                       border      = false,
                       fill_color  = yellow,
                       polygon([[5,2],[9,2],[7,5]]) )$

 -- Objeto gráfico: rectangle ([<x1>,<y1>], [<x2>,<y2>])
     Dibuja rectángulos en 2D.

     2D

     `rectangle ([<x1>,<y1>], [<x2>,<y2>])' dibuja un rectángulo de
     vértices opuestos `[<x1>,<y1>]' y `[<x2>,<y2>]'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `transparent', `fill_color', `border', `line_width', `key',
     `line_type' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(fill_color  = red,
                       line_width  = 6,
                       line_type   = dots,
                       transparent = false,
                       fill_color  = blue,
                       rectangle([-2,-2],[8,-1]), /* opposite vertices */
                       transparent = true,
                       line_type   = solid,
                       line_width  = 1,
                       rectangle([9,4],[2,-1.5]),
                       xrange      = [-3,10],
                       yrange      = [-3,4.5] )$

 -- Objeto gráfico: bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])
     Dibuja barras verticales en 2D.

     2D

     `bars ([<x1>,<h1>,<w1>], [<x2>,<h2>,<w2>, ...])' dibuja barras
     centradas en los valores <x1>, <x2>, ... de alturas <h1>, <h2>, ...
     y anchos <w1>, <w2>, ...

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `key', `fill_color', `fill_density' y `line_width'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(
                 key          = "Grupo A",
                 fill_color   = blue,
                 fill_density = 0.2,
                 bars([0.8,5,0.4],[1.8,7,0.4],[2.8,-4,0.4]),
                 key          = "Grupo B",
                 fill_color   = red,
                 fill_density = 0.6,
                 line_width   = 4,
                 bars([1.2,4,0.4],[2.2,-2,0.4],[3.2,5,0.4]),
                 xaxis = true);

 -- Objeto gráfico: ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)
     Dibuja elipses y círculos en 2D.

     2D

     `ellipse (<xc>, <yc>, <a>, <b>, <ang1>, <ang2>)' dibuja una elipse
     de centro `[<xc>, <yc>]' con semiejes horizontal y vertical <a> y
     <b>, respectivamente, comenzando en el ángulo <ang1> y trazando un
     arco de amplitud igual al ángulo <ang2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `transparent', `fill_color', `border', `line_width',
     `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(transparent = false,
                       fill_color  = red,
                       color       = gray30,
                       transparent = false,
                       line_width  = 5,
                       ellipse(0,6,3,2,270,-270),
                       /* center (x,y), a, b, start & end in degrees */
                       transparent = true,
                       color       = blue,
                       line_width  = 3,
                       ellipse(2.5,6,2,3,30,-90),
                       xrange      = [-3,6],
                       yrange      = [2,9] )$

 -- Objeto gráfico: label ([<string>,<x>,<y>],...)
 -- Objeto gráfico: label ([<string>,<x>,<y>,<z>],...)
     Escribe etiquetas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `label_alignment', `label_orientation' y `color'.

     2D

     `label([<string>,<x>,<y>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(yrange = [0.1,1.4],
                       color = "red",
                       label(["Label in red",0,0.3]),
                       color = "#0000ff",
                       label(["Label in blue",0,0.6]),
                       color = "light-blue",
                       label(["Label in light-blue",0,0.9],
                             ["Another light-blue",0,1.2])  )$

     3D

     `label([<string>,<x>,<y>,<z>])' escribe la cadena de caracteres
     <string> en el punto `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = red,
                       label(["UP 1",-2,0,3], ["UP 2",1.5,0,4]),
                       color = blue,
                       label(["DOWN 1",2,0,-3]) )$

 -- Objeto gráfico: vector ([<x>,<y>], [<dx>,<dy>])
 -- Objeto gráfico: vector ([<x>,<y>,<z>], [<dx>,<dy>,<dz>])
     Dibuja vectores en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `head_both', `head_length', `head_angle', `head_type',
     `line_width', `line_type', `key' y `color'.

     2D

     `vector ([<x>,<y>], [<dx>,<dy>])' dibuja el vector `[<dx>,<dy>]'
     con origen en `[<x>,<y>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(xrange      = [0,12],
                       yrange      = [0,10],
                       head_length = 1,
                       vector([0,1],[5,5]), /* default type */
                       head_type = 'empty,
                       vector([3,1],[5,5]),
                       head_both = true,
                       head_type = 'nofilled,
                       line_type = dots,
                       vector([6,1],[5,5]))$

     3D

     `vector([<x>,<y>,<z>], [<dx>,<dy>,<dz>])' dibuja el vector
     `[<dx>,<dy>,<dz>]' con origen en `[<x>,<y>,<z>]'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(color = cyan,
                       vector([0,0,0],[1,1,1]/sqrt(3)),
                       vector([0,0,0],[1,-1,0]/sqrt(2)),
                       vector([0,0,0],[1,1,-2]/sqrt(6)) )$

 -- Objeto gráfico: explicit (<fcn>,<var>,<minval>,<maxval>)
 -- Objeto gráfico: explicit
          (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)
     Dibuja funciones explícitas en 2D y 3D.

     2D

     `explicit (<fcn>,<var>,<minval>,<maxval>)' dibuja la función
     explícita <fcn>, con la variable <var> tomando valores desde
     <minval> hasta <maxval>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `adapt_depth', `line_width', `line_type', `key',
     `filled_func', `fill_color' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(line_width = 3,
                       color      = blue,
                       explicit(x^2,x,-3,3) )$
          (%i3) draw2d(fill_color  = brown,
                       filled_func = true,
                       explicit(x^2,x,-3,3) )$

     3D

     `explicit
     (<fcn>,<var1>,<minval1>,<maxval1>,<var2>,<minval2>,<maxval2>)'
     dibuja la función explícita <fcn>, con la variable `var1' tomando
     valores desde <minval1> hasta <maxval1> y la variable <var2>
     tomando valores desde <minval2> hasta <maxval2>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(key   = "Gauss",
                       color = "#a02c00",
                       explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3),
                       yv_grid     = 10,
                       color = blue,
                       key   = "Plane",
                       explicit(x+y,x,-5,5,y,-5,5),
                       surface_hide = true)$

     Véase también `filled_func' para el relleno de curvas.

 -- Objeto gráfico: implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)
 -- Objeto gráfico: implicit
          (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>,<z>,<zmin>,<zmax>)
     Dibuja funciones implícitas en 2D y 3D.

     2D

     `implicit (<fcn>,<x>,<xmin>,<xmax>,<y>,<ymin>,<ymax>)' dibuja la
     función implícita <fcn>, con la variable `x' tomando valores desde
     <xmin> hasta <xmax>, y la variable <y> tomando valores desde
     <ymin> hasta <ymax>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `ip_grid', `ip_grid_in', `line_width', `line_type', `key' y
     `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(terminal  = eps,
                       grid      = true,
                       line_type = solid,
                       key       = "y^2=x^3-2*x+1",
                       implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,4),
                       line_type = dots,
                       key       = "x^3+y^3 = 3*x*y^2-x-1",
                       implicit(x^3+y^3 = 3*x*y^2-x-1, x,-4,4, y,-4,4),
                       title     = "Two implicit functions" )$

     3D

     `implicit (<fcn>,<x>,<xmin>,<xmax>, <y>,<ymin>,<ymax>,
     <z>,<zmin>,<zmax>)' dibuja la función implícita <fcn>, con la
     variable <x> tomando valores desde <xmin> hasta <xmax>, la
     variable <y> tomando valores desde <ymin> hasta <ymax> y la
     variable <z> tomando valores desde <zmin> hasta <zmax>. Este
     objeto está programado con el algoritmo marching cubes.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `x_voxel', `y_voxel', `z_voxel', `line_width', `line_type', `key'
     y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(
                  color=blue,
                  implicit((x^2+y^2+z^2-1)*(x^2+(y-1.5)^2+z^2-0.5)=0.015,
                           x,-1,1,y,-1.2,2.3,z,-1,1),
                  surface_hide=true);

 -- Objeto gráfico: polar (<radius>,<ang>,<minang>,<maxang>)
     Dibuja funciones 2D definidas en coordenadas polares.

     2D

     `polar (<radius>,<ang>,<minang>,<maxang>)' dibuja la función
     `<radius>(<ang>)' definida en coordenadas polares, con la variable
     <ang> tomando valores desde <minang> hasta <maxang>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(user_preamble = "set grid polar",
                       nticks        = 200,
                       xrange        = [-5,5],
                       yrange        = [-5,5],
                       color         = blue,
                       line_width    = 3,
                       title         = "Hyperbolic Spiral",
                       polar(10/theta,theta,1,10*%pi) )$

 -- Objeto gráfico: spherical
          (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)
     Dibuja funciones 3D definidas en coordenadas esféricas.

     3D

     `spherical
     (<radius>,<azi>,<minazi>,<maxazi>,<zen>,<minzen>,<maxzen>)' dibuja
     la función `<radius>(<azi>,<zen>)' definida en coordenadas
     esféricas, con el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi> y el zenit <zen> tomando valores desde <minzen>
     hasta <maxzen>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(spherical(1,a,0,2*%pi,z,0,%pi))$

 -- Objeto gráfico: cylindrical
          (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)
     Dibuja funciones 3D definidas en coordenadas cilíndricas.

     3D

     `cylindrical (<radius>,<z>,<minz>,<maxz>,<azi>,<minazi>,<maxazi>)'
     dibuja la función `<radius>(<z>,<azi>)' definida en coordenadas
     cilíndricas, con la variable <z> tomando valores desde <minz>
     hasta <maxz> y el azimut <azi> tomando valores desde <minazi>
     hasta <maxazi>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(cylindrical(1,z,-2,2,az,0,2*%pi))$

 -- Objeto gráfico: parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)
 -- Objeto gráfico: parametric
          (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)
     Dibuja funciones paramétricas en 2D y 3D.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `nticks', `line_width', `line_type', `key' y `color'.

     2D

     `parametric (<xfun>,<yfun>,<par>,<parmin>,<parmax>)' dibuja la
     función paramétrica `[<xfun>,<yfun>]', con el parámetro <par>
     tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw2d(explicit(exp(x),x,-1,3),
                       color = red,
                       key   = "This is the parametric one!!",
                       parametric(2*cos(rrr),rrr^2,rrr,0,2*%pi))$

     3D

     `parametric (<xfun>,<yfun>,<zfun>,<par>,<parmin>,<parmax>)' dibuja
     la curva paramétrica `[<xfun>,<yfun>,<zfun>]', con el parámetro
     <par> tomando valores desde <parmin> hasta <parmax>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(explicit(exp(sin(x)+cos(x^2)),x,-3,3,y,-3,3),
                       color = royalblue,
                       parametric(cos(5*u)^2,sin(7*u),u-2,u,0,2),
                       color      = turquoise,
                       line_width = 2,
                       parametric(t^2,sin(t),2+t,t,0,2),
                       surface_hide = true,
                       title = "Surface & curves" )$

 -- Objeto gráfico: image (<im>,<x0>,<y0>,<width>,<height>)
     Reproduce una imagen en 2D.

     2D

     `image (<im>,<x0>,<y0>,<width>,<height>)': dibuja la imagen <im>
     en la región rectangular desde el vértice <(X0,Y0)> hasta el
     `(x0+<width>,y0+<height>)' del plano real. El argumento <im> debe
     ser una matriz de números reales, una matriz de vectores de
     longitud tres o un objeto de tipo `picture'.

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette',
     que es un vector de longitud tres con sus componentes tomando
     valores enteros en el rango desde -36 a +36; cada valor es un
     índice para seleccionar una fórmula que transforma los niveles
     numéricos en las componentes cromáticas rojo, verde y azul:
           0: 0               1: 0.5           2: 1
           3: x               4: x^2           5: x^3
           6: x^4             7: sqrt(x)       8: sqrt(sqrt(x))
           9: sin(90x)       10: cos(90x)     11: |x-0.5|
          12: (2x-1)^2       13: sin(180x)    14: |cos(180x)|
          15: sin(360x)      16: cos(360x)    17: |sin(360x)|
          18: |cos(360x)|    19: |sin(720x)|  20: |cos(720x)|
          21: 3x             22: 3x-1         23: 3x-2
          24: |3x-1|         25: |3x-2|       26: (3x-1)/2
          27: (3x-2)/2       28: |(3x-1)/2|   29: |(3x-2)/2|
          30: x/0.32-0.78125 31: 2*x-0.84
          32: 4x;1;-2x+1.84;x/0.08-11.5
          33: |2*x - 0.5|    34: 2*x          35: 2*x - 0.5
          36: 2*x - 1
     los números negativos se interpretan como colores invertidos de
     las componentes cromáticas.

     `palette = gray' y `palette = color' son atajos para `palette =
     [3,3,3]' y `palette = [7,5,15]', respectivamente.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.

     Ejemplos:

     Si <im> es una matriz de números reales, los valores de los
     píxeles se interpretan según indique la opción gráfica `palette'.
          (%i1) load(draw)$
          (%i2) im: apply(
                     'matrix,
                      makelist(makelist(random(200),i,1,30),i,1,30))$
          (%i3) /* palette = color, default */
                draw2d(image(im,0,0,30,30))$
          (%i4) draw2d(palette = gray, image(im,0,0,30,30))$
          (%i5) draw2d(palette = [15,20,-4],
                       colorbox=false,
                       image(im,0,0,30,30))$

     Véase también `colorbox'.

     Si <im> es una matriz de vectores de longitud tres, éstos se
     interpretarán como las componentes cromáticas rojo, verde y azul.
          (%i1) load(draw)$
          (%i2) im: apply(
                      'matrix,
                       makelist(
                         makelist([random(300),
                                   random(300),
                                   random(300)],i,1,30),i,1,30))$
          (%i3) draw2d(image(im,0,0,30,30))$

     El paquete `draw' carga automáticamente el paquete `picture'.  En
     este ejemplo, una imagen de niveles se define a mano,
     reproduciéndola a continuación.
          (%i1) load(draw)$
          (%i2) im: make_level_picture([45,87,2,134,204,16],3,2);
          (%o2)       picture(level, 3, 2, {Array:  #(45 87 2 134 204 16)})
          (%i3) /* default color palette */
                draw2d(image(im,0,0,30,30))$
          (%i4) /* gray palette */
                draw2d(palette = gray,
                       image(im,0,0,30,30))$

     Se lee un fichero xpm y se reproduce.
          (%i1) load(draw)$
          (%i2) im: read_xpm("myfile.xpm")$
          (%i3) draw2d(image(im,0,0,10,7))$

     Véanse también `make_level_picture', `make_rgb_picture' y
     `read_xpm'.

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/image'
     se encuentran ejemplos más elaborados.

 -- Global variable: boundaries_array
     Valor por defecto: `false'

     `boundaries_array' es donde el objeto gráfico `geomap' lee las
     coordenadas de las líneas fronterizas.

     Cada componente de `boundaries_array' es un array de números
     decimales en coma flotante representando las coordenadas que
     definen un segmento poligonal o línea fronteriza.

     Véase también `geomap'.

 -- Objeto gráfico: geomap (<numlist>)
 -- Objeto gráfico: geomap (<numlist>,<3Dprojection>)
     Dibuja mapas cartográficos en 2D y 3D.

     2D

     Esta función trabaja junto con la variable global
     `boundaries_array'.

     El argumento <numlist> es una lista de números o de listas de
     números. Todos estos números deben ser enteros mayores o iguales
     que cero, representando las componentes del array global
     `boundaries_array'.

     Cada componente de `boundaries_array' es un array de decimales en
     coma flotante, las coordenadas de un segmento poligonal o línea
     fronteriza.

     `geomap (<numlist>)' toma los enteros de sus argumentos y dibuja
     los segmentos poligonales asociados de `boundaries_array'.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `line_width', `line_type' y `color'.

     Ejemplos:

     Un sencillo mapa hecho a mano:
          (%i1) load(draw)$
          (%i2) /* Vertices of boundary #0: {(1,1),(2,5),(4,3)} */
             ( bnd0: make_array(flonum,6),
               bnd0[0]:1.0, bnd0[1]:1.0, bnd0[2]:2.0,
               bnd0[3]:5.0, bnd0[4]:4.0, bnd0[5]:3.0 )$
          (%i3) /* Vertices of boundary #1: {(4,3),(5,4),(6,4),(5,1)} */
             ( bnd1: make_array(flonum,8),
               bnd1[0]:4.0, bnd1[1]:3.0, bnd1[2]:5.0, bnd1[3]:4.0,
               bnd1[4]:6.0, bnd1[5]:4.0, bnd1[6]:5.0, bnd1[7]:1.0)$
          (%i4) /* Vertices of boundary #2: {(5,1), (3,0), (1,1)} */
             ( bnd2: make_array(flonum,6),
               bnd2[0]:5.0, bnd2[1]:1.0, bnd2[2]:3.0,
               bnd2[3]:0.0, bnd2[4]:1.0, bnd2[5]:1.0 )$
          (%i5) /* Vertices of boundary #3: {(1,1), (4,3)} */
             ( bnd3: make_array(flonum,4),
               bnd3[0]:1.0, bnd3[1]:1.0, bnd3[2]:4.0, bnd3[3]:3.0)$
          (%i6) /* Vertices of boundary #4: {(4,3), (5,1)} */
             ( bnd4: make_array(flonum,4),
               bnd4[0]:4.0, bnd4[1]:3.0, bnd4[2]:5.0, bnd4[3]:1.0)$
          (%i7) /* Pack all together in boundaries_array */
             ( boundaries_array: make_array(any,5),
               boundaries_array[0]: bnd0, boundaries_array[1]: bnd1,
               boundaries_array[2]: bnd2, boundaries_array[3]: bnd3,
               boundaries_array[4]: bnd4 )$
          (%i8) draw2d(geomap([0,1,2,3,4]))$

     El paquete auxiliar `worldmap' asigna al array global
     `boundaries_array' líneas fronterizas reales en coordenadas
     (longitud, latitud). Estos datos son de dominio público y proceden
     de `http://www-cger.nies.go.jp/grid-e/gridtxt/grid19.html'.  El
     paquete `worldmap' también define fronteras de países, continentes
     y líneas costeras a partir de las componentes de
     `boundaries_array' (véase el fichero `share/draw/worldmap.mac'
     para más información). El paquete `draw' no carga automáticamente
     `worldmap'.
          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) c1: gr2d(geomap(Canada,United_States,
                                Mexico,Cuba))$
          (%i4) c2: gr2d(geomap(Africa))$
          (%i5) c3: gr2d(geomap(Oceania,China,Japan))$
          (%i6) c4: gr2d(geomap(France,Portugal,Spain,
                                Morocco,Western_Sahara))$
          (%i7) draw(columns  = 2,
                     c1,c2,c3,c4)$

     `worldmap' se puede utilizar para dibujar países como polígonos.
     En este caso, ya no será necesario hacer uso del objeto gráfico
     `geomap', pero sí de `polygon'. Puesto que en este caso se
     utilizan listas en lugar de arrays, los mapas se reproducirán de
     forma más lenta. Véanse también `make_poly_country' y
     `make_poly_continent' para comprender el siguiente código.
          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) mymap: append(
             [color      = white],  /* borders are white */
             [fill_color = red],             make_poly_country(Bolivia),
             [fill_color = cyan],            make_poly_country(Paraguay),
             [fill_color = green],           make_poly_country(Colombia),
             [fill_color = blue],            make_poly_country(Chile),
             [fill_color = "#23ab0f"],       make_poly_country(Brazil),
             [fill_color = goldenrod],       make_poly_country(Argentina),
             [fill_color = "midnight-blue"], make_poly_country(Uruguay))$
          (%i4) apply(draw2d, mymap)$

     3D

     `geomap (<numlist>)' proyecta los mapas sobre la esfera de radio 1
     y centro (0,0,0). Es posible cambiar la esfera o el tipo de
     proyección haciendo uso de `geomap (<numlist>,<3Dprojection>)'.

     Proyecciones 3D disponibles:

        * `[spherical_projection,<x>,<y>,<z>,<r>]': proyecta los mapas
          sobre la esfera de radio <r> y centro (<x>,<y>,<z>).
               (%i1) load(draw)$
               (%i2) load(worldmap)$
               (%i3) draw3d(geomap(Australia), /* default projection */
                            geomap(Australia,
                                   [spherical_projection,2,2,2,3]))$

        * `[cylindrical_projection,<x>,<y>,<z>,<r>,<rc>]': re-proyecta
          mapas esféricos sobre el cilindro de radio <rc> cuyo eje pasa
          a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>).
               (%i1) load(draw)$
               (%i2) load(worldmap)$
               (%i3) draw3d(geomap([America_coastlines,Eurasia_coastlines],
                                   [cylindrical_projection,2,2,2,3,4]))$

        * `[conic_projection,<x>,<y>,<z>,<r>,<alpha>]': re-proyecta
          mapas esféricos sobre los conos de ángulo <alpha>, cuyos ejes
          pasan a través de los polos del globo de radio <r> y centro
          (<x>,<y>,<z>). Ambos conos, norte y sur, son tangentes a la
          esfera.
               (%i1) load(draw)$
               (%i2) load(worldmap)$
               (%i3) draw3d(geomap(World_coastlines,
                                   [conic_projection,0,0,0,1,90]))$

     En `http://www.telefonica.net/web2/biomates/maxima/gpdraw/geomap'
     hay ejemplos más elaborados.

 -- Objeto gráfico: parametric_surface
          (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)
     Dibuja superficies paramétricas en 3D.

     3D

     `parametric_surface
     (<xfun>,<yfun>,<zfun>,<par1>,<par1min>,<par1max>,<par2>,<par2min>,<par2max>)'
     dibuja la superficie paramétrica `[<xfun>,<yfun>,<zfun>]', con el
     parámetro <par1> tomando valores desde <par1min> hasta <par1max> y
     el parámetro <par2> tomando valores desde <par2min> hasta
     <par2max>.

     Este objeto se ve afectado por las siguientes opciones gráficas:
     `xu_grid', `yv_grid', `line_type', `key' y `color'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) draw3d(title          = "Sea shell",
                       xu_grid        = 100,
                       yv_grid        = 25,
                       rot_vertical   = 100,
                       rot_horizontal = 20,
                       surface_hide   = true,
                       parametric_surface(0.5*u*cos(u)*(cos(v)+1),
                                     0.5*u*sin(u)*(cos(v)+1),
                                     u*sin(v) - ((u+3)/8*%pi)^2 - 20,
                                     u, 0, 13*%pi, v, -%pi, %pi) )$

 -- Función: draw (<gr2d>, ..., <gr3d>, ..., <options>, ...)
     Representa gráficamente una serie de escenas; sus argumentos son
     objetos `gr2d' y/o `gr3d', junto con algunas opciones. Por defecto,
     las escenas se representan en una columna.

     La función `draw' acepta las siguientes opciones globales:
     `terminal', `columns', `pic_width', `pic_height', `eps_width',
     `eps_height', `file_name' y `delay'.

     Las funciones `draw2d' y `draw3d' son atajos a utilizar cuando se
     quiere representar una única escena en dos o tres dimensiones,
     respectivamente.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) scene1: gr2d(title="Ellipse",
                             nticks=30,
                             parametric(2*cos(t),5*sin(t),t,0,2*%pi))$
          (%i3) scene2: gr2d(title="Triangle",
                             polygon([4,5,7],[6,4,2]))$
          (%i4) draw(scene1, scene2, columns = 2)$

     Las dos sentencias gráficas siguientes son equivalentes:
          (%i1) load(draw)$
          (%i2) draw(gr3d(explicit(x^2+y^2,x,-1,1,y,-1,1)));
          (%o2)                          [gr3d(explicit)]
          (%i3) draw3d(explicit(x^2+y^2,x,-1,1,y,-1,1));
          (%o3)                          [gr3d(explicit)]

     Un fichero gif animado:
          (%i1) load(draw)$
          (%i2) draw(
                  delay     = 100,
                  file_name = "zzz",
                  terminal  = 'animated_gif,
                  gr2d(explicit(x^2,x,-1,1)),
                  gr2d(explicit(x^3,x,-1,1)),
                  gr2d(explicit(x^4,x,-1,1)));
          End of animation sequence
          (%o2)          [gr2d(explicit), gr2d(explicit), gr2d(explicit)]

     Véanse también `gr2d', `gr3d', `draw2d' y `draw3d'.

 -- Función: draw2d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr2d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 2d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr2d'.

 -- Función: draw3d (<option>, <graphic_object>, ...)
     Esta función es un atajo para `draw(gr3d(<options>, ...,
     <graphic_object>, ...))'.

     Puede utilizarse para representar una única escena en 3d.

     Para utilizar esta función, ejecútese primero `load(draw)'.

     Véanse también `draw' y `gr3d'.


File: maxima.info,  Node: Funciones y variables para picture,  Next: Funciones y variables para worldmap,  Prev: Funciones y variables para draw,  Up: draw

48.3 Funciones y variables para picture
=======================================

 -- Función: make_level_picture (<data>)
 -- Función: make_level_picture (<data>,<width>,<height>)
     Devuelve un objeto `picture' consistente en una imagen de niveles.
     `make_level_picture (<data>)' construye el objeto `picture' a
     partir de la matriz <data>.  `make_level_picture
     (<data>,<width>,<height>)' construye el objeto a partir de una
     lista de números, en cuyo caso deben indicarse el ancho <width> y
     la altura <height> en píxeles.

     El objeto  `picture' devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `level'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros con los valores de los píxeles entre 0 y
          255. El argumento <data> debe contener sólo números entre 0 y
          255; los cantidades negativas se transforman en ceros y las
          que son mayores de 255 se igualan a este número.

     Ejemplo:

     Imagen de niveles a partir de una matriz.
          (%i1) load(draw)$
          (%i2) make_level_picture(matrix([3,2,5],[7,-9,3000]));
          (%o2)         picture(level, 3, 2, {Array:  #(3 2 5 7 0 255)})

     Imagen de niveles a partir de una lista numérica.
          (%i1) load(draw)$
          (%i2) make_level_picture([-2,0,54,%pi],2,2);
          (%o2)            picture(level, 2, 2, {Array:  #(0 0 54 3)})

 -- Función: picturep (<x>)
     Devuelve `true' si el argumento es una imagen bien formada, o
     `false' en caso contrario.

 -- Función: picture_equalp (<x>,<y>)
     Devuelve `true' si los dos argumentos son imágenes idénticas, o
     `false' en caso contrario.

 -- Función: make_rgb_picture (<redlevel>,<greenlevel>,<bluelevel>)
     Devuelve un objeto <picture> conteniendo una imagen en color (RGB).
     Los tres argumentos deben ser imágenes de niveles, para el rojo
     (R), verde (G) y azul (B).

     El objeto  <picture> devuelto contiene los siguientes cuatro
     elemento:

       1. el símbolo `rgb'

       2. anchura de la imagen

       3. altura de la imagen

       4. un array de enteros de <3*ancho*alto> con los valores de los
          píxeles entre 0 y 255. Cada valor de pixel se representa en
          el array con tres números consecutivos (rojo, verde, azul).

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})

 -- Función: take_channel (<im>,<color>)
     Si el argumento <color> es `red', `green' o `blue', la función
     `take_channel' devuelve el canal de color correspondiente de la
     imagen <im>.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) red: make_level_picture(matrix([3,2],[7,260]));
          (%o2)           picture(level, 2, 2, {Array:  #(3 2 7 255)})
          (%i3) green: make_level_picture(matrix([54,23],[73,-9]));
          (%o3)           picture(level, 2, 2, {Array:  #(54 23 73 0)})
          (%i4) blue: make_level_picture(matrix([123,82],[45,32.5698]));
          (%o4)          picture(level, 2, 2, {Array:  #(123 82 45 33)})
          (%i5) make_rgb_picture(red,green,blue);
          (%o5) picture(rgb, 2, 2,
                        {Array:  #(3 54 123 2 23 82 7 73 45 255 0 33)})
          (%i6) take_channel(%,'green);  /* simple quote!!! */
          (%o6)           picture(level, 2, 2, {Array:  #(54 23 73 0)})

 -- Función: negative_picture (<pic>)
     Devuelve el negativo de la imagen, sea ésta de tipo nivel (<level>)
     o color (<rgb>).

 -- Función: rgb2level (<pic>)
     Transforma una imagen en color <rgb> a otra de niveles <level>
     promediando los niveles.

 -- Función: get_pixel (<pic>,<x>,<y>)
     Devuelve el pixel de la imagen <pic>. Las coordenadas <x> e <y>
     van desde 0 hasta `ancho-1' y `alto-1', respectivamente.

 -- Función: read_xpm (<xpm_file>)
     Lee el fichero gráfico en formato xpm y devuelve un objeto
     `picture'.


File: maxima.info,  Node: Funciones y variables para worldmap,  Prev: Funciones y variables para picture,  Up: draw

48.4 Funciones y variables para worldmap
========================================

 -- Función: region_boundaries (<x1>,<y1>,<x2>,<y2>)
     Detecta los segmentos poligonales almacenados en la variable global
     `boundaries_array' contenidos en el rectángulo de vértices
     (<x1>,<y1>) -superior izquierdo- y (<x2>,<y2>) -inferior derecho-.

     Ejemplo:

     Devuelve los números de los segmentos necesarios para dibujar el
     sur de Italia.
          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) region_boundaries(10.4,41.5,20.7,35.4);
          (%o3)                [1846, 1863, 1864, 1881, 1888, 1894]
          (%i4) draw2d(geomap(%))$

 -- Función: numbered_boundaries (<nlist>)
     Dibuja una lista de segmentos poligonales (líneas fronterizas),
     etiquetadas con sus números correspondientes (coordenadas de
     `boundaries_array'). Esta función es de mucha ayuda a la hora de
     definir nuevas entidades geográficas.

     Ejemplo:

     Mapa de Europa con las fronteras y costas etiquetadas con su
     componente numérica de `boundaries_array'.
          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) european_borders:
                   region_boundaries(-31.81,74.92,49.84,32.06)$
          (%i4) numbered_boundaries(european_borders)$

 -- Función: make_polygon (<nlist>)
     Devuelve un objeto `polygon' a partie de una lista de líneas
     fronterizas y de costas. El argumento <nlist> debe ser una lista
     de componentes de `boundaries_array'.

     Ejemplo:

     La variable Bhutan (Bután) está definida con los números
     fronterizos 171, 173 y 1143, de manera que
     `make_polygon([171,173,1143])' concatena los arrays
     `boundaries_array[171]', `boundaries_array[173]' y
     `boundaries_array[1143]' y devuelve un objeto `polygon' apto para
     ser dibujado por `draw'. A fin de evitar mensajes de errores, los
     arrays deben ser compatibles en el sentido de que dos de ellos
     consecutivos deben tener dos coordenadas comunes en los extremos.
     En este ejemplo, las dos primeras componentes de
     `boundaries_array[171]' son iguales a las dos últimas de
     `boundaries_array[173]', y las dos primeras de
     `boundaries_array[173]' coinciden con las dos primeras de
     `boundaries_array[1143]'; en conclusión, los números de segmentos
     poligonales171, 173 y 1143 (en este orden) son compatibles y el
     polígono coloreado se podrá dibujar.
          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) Bhutan;
          (%o3)                        [[171, 173, 1143]]
          (%i4) boundaries_array[171];
          (%o4) {Array:
                 #(88.750549 27.14727 88.806351 27.25305 88.901367 27.282221
                   88.917877 27.321039)}
          (%i5) boundaries_array[173];
          (%o5) {Array:
                 #(91.659554 27.76511 91.6008 27.66666 91.598022 27.62499
                   91.631348 27.536381 91.765533 27.45694 91.775253 27.4161
                   92.007751 27.471939 92.11441 27.28583 92.015259 27.168051
                   92.015533 27.08083 92.083313 27.02277 92.112183 26.920271
                   92.069977 26.86194 91.997192 26.85194 91.915253 26.893881
                   91.916924 26.85416 91.8358 26.863331 91.712479 26.799999
                   91.542191 26.80444 91.492188 26.87472 91.418854 26.873329
                   91.371353 26.800831 91.307457 26.778049 90.682457 26.77417
                   90.392197 26.903601 90.344131 26.894159 90.143044 26.75333
                   89.98996 26.73583 89.841919 26.70138 89.618301 26.72694
                   89.636093 26.771111 89.360786 26.859989 89.22081 26.81472
                   89.110237 26.829161 88.921631 26.98777 88.873016 26.95499
                   88.867737 27.080549 88.843307 27.108601 88.750549
                   27.14727)}
          (%i6) boundaries_array[1143];
          (%o6) {Array:
                 #(91.659554 27.76511 91.666924 27.88888 91.65831 27.94805
                   91.338028 28.05249 91.314972 28.096661 91.108856 27.971109
                   91.015808 27.97777 90.896927 28.05055 90.382462 28.07972
                   90.396088 28.23555 90.366074 28.257771 89.996353 28.32333
                   89.83165 28.24888 89.58609 28.139999 89.35997 27.87166
                   89.225517 27.795 89.125793 27.56749 88.971077 27.47361
                   88.917877 27.321039)}
          (%i7) Bhutan_polygon: make_polygon([171,173,1143])$
          (%i8) draw2d(Bhutan_polygon)$

 -- Función: make_poly_country (<country_name>)
     Construye los polígonos necesarios para dibujar un país coloreado.
     En caso de contener islas, un país tendrá asociados varios
     polígonos.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) make_poly_country(India)$
          (%i4) apply(draw2d, %)$

 -- Función: make_poly_continent (<continent_name>)
 -- Función: make_poly_continent (<country_list>)
     Construye los polígonos necesarios para dibujar un continente o
     lista de países coloreados.

     Ejemplo:

          (%i1) load(draw)$
          (%i2) load(worldmap)$
          (%i3) /* A continent */
                make_poly_continent(Africa)$
          (%i4) apply(draw2d, %)$
          (%i5) /* A list of countries */
                make_poly_continent([Germany,Denmark,Poland])$
          (%i6) apply(draw2d, %)$


File: maxima.info,  Node: dynamics,  Next: eval_string,  Prev: draw,  Up: Top

49 dynamics
***********

* Menu:

* Introducción a dynamics::
* Funciones y variables para dynamics::


File: maxima.info,  Node: Introducción a dynamics,  Next: Funciones y variables para dynamics,  Prev: dynamics,  Up: dynamics

49.1 Introducción a dynamics
============================

El paquete adicional `dynamics' incluye varias funciones para crear
diversas representaciones gráficas de sistemas dinámicos y fractales, y
además una implementación del método numérico de Runge-Kutta de cuarto
orden, para resolver sistemas de ecuaciones diferenciales.

   Para usar las funciones en este paquete será necesario primero que
todo cargarlo con `load("dynamics")', y las funciones que crean
gráficas necesitan que Xmaxima esté instalado.


File: maxima.info,  Node: Funciones y variables para dynamics,  Prev: Introducción a dynamics,  Up: dynamics

49.2 Funciones y variables para dynamics
========================================

 -- Función: chaosgame (`[['<x1>, <y1>`]'...`['<xm>, <ym>`]]', `['<x0>,
          <y0>`]', <b>, <n>, ...opciones...);
     Usa el método llamado juego del caos, para producir fractales: se
     dibuja un punto inicial (<x0>, <y0>) y luego se elije
     aleatoriamente uno de los <m> puntos `['<x1>, <y1>`]'...`['<xm>,
     <ym>`]'. Después se dibuja un nuevo punto que estará en el
     segmento entre el último punto dibujado y el punto que se acabó de
     elegir aleatoriamente, a una distancia del punto elegido que será
     <b> veces la longitud del segmento. El proceso se repite <n> veces.


 -- Función: evolution (<F>, <y0>, <n>,...opciones...);
     Dibuja <n+1> puntos en una gráfica bidimensional (serie de
     tiempo), en que las coordenadas horizontales de los puntos son los
     números enteros 0, 1, 2, ..., <n>, y las coordenadas verticales
     son los valores <y(n)> correspondientes, obtenidos a partir de la
     relación de recurrencia
                  y(n+1) = F(y(n))

     Con valor inicial <y(0)> igual a <y0>. <F> deberá ser una
     expresión que dependa únicamente de la variable <y> (y no de <n>),
     <y0> deberá ser un número real y <n> un número entero positivo.


 -- Función: evolution2d (`['<F>, <G>`]', `['<x0>, <y0>`]', <n>,
          ...opciones...);
     Muestra, en una gráfica bidimensional, los primeros <n+1> puntos de
     la sucesión definida a partir del sistema dinámico discreto con
     relaciones de recurrencia:
                  x(n+1) = F(x(n), y(n))    y(n+1) = G(x(n), y(n))

     Con valores iniciales <x0> y <y0>. <F> y <G> deben ser dos
     expresiones que dependan únicamente de <x> y <y>.


 -- Función: ifs (`['<r1>,...,<rm>`]',`['<A1>,...,<Am>`]',
          `[['<x1>,<y1>`]'...`['<xm>, <ym>`]]', `['<x0>,<y0>`]', <n>,
          ...opciones...);
     Usa el método del Sistema de Funciones Iteradas (IFS, en inglés
     Iterated Function System). Ese método es semejante al método
     descrito en la función `chaosgame', pero en vez de aproximar el
     último punto al punto elegido aleatoriamente, las dos coordenadas
     del último punto se multiplican por una matriz 2 por 2 <Ai>
     correspondiente al punto que fue elegido aleatoriamente.

     La selección aleatoria de uno de los <m> puntos atractivos puede
     ser realizada con una función de probabilidad no uniforme, definida
     con los pesos <r1>,...,<rm>. Esos pesos deben ser dados en forma
     acumulada; por ejemplo, si se quieren 3 puntos con probabilidades
     0.2, 0.5 y 0.3, los pesos <r1>, <r2> y <r3> podrían ser 2, 7 y 10,
     o cualquier otro grupo de números que tengan la misma proporción.


 -- Función: julia (<x>, <y>, ...<opciones>...)
     Crea un fichero gráfico con la representación del conjunto de Julia
     del número complejo (<x> + i <y>). Los parámetros <x> y <y> deben
     ser reales. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Julia, de acuerdo con el número de iteraciones que
     demore la secuencia, comenzando en ese punto, a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Julia tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: mandelbrot (<options>)
     Crea un fichero gráfico con la representación del conjunto de
     Mandelbrot. El fichero se crea en el directório actual o en el
     directório del usuario, usando el formato gráfico XPM. El programa
     puede demorar varios segundos a ser ejecutado y cuando termina
     imprime un mensaje con el nombre del fichero creado.

     Se asignan diferentes colores a los puntos que no pertenecen al
     conjunto de Mandelbrot, de acuerdo con el número de iteraciones
     que demore la secuencia generada por ese punto a salir fuera del
     círculo de convergencia con radio 2. El número máximo de
     iteraciones se define con la opción <levels>; después de
     ejecutadas ese número de iteraciones, si la secuencia aun está
     dentro del círculo de convergencia, el punto será coloreado con el
     color definido por la opción <color>.

     Todos los colores usados para los puntos que no pertenecen al
     conjunto de Mandelbrot tendrán los mismos valores de saturación
     (<saturation>) y valor (<value>), pero con diferentes ángulos de
     tonalidad, distribuidos uniformemente en el intervalo entre <hue>
     y (<hue> + <huerange>).

     Se puede dar a la función una secuencia de opciones. La lista de
     posibles opciones aparece en una sección más al frente.


 -- Función: orbits (<F>, <y0>, <n1>, <n2>, [<x>, <x0>, <xf>, <xstep>],
          ...opciones...);
     Dibuja el diagrama de órbitas de una familia de sistemas dinámicos
     discretos unidimensionales, con un parámetro <x>; ese tipo de
     diagrama se usa para mostrar las bifurcaciones de un sistema
     discreto unidimensional.

     La función <F(y)> define una secuencia que comienza con un valor
     inicial <y0>, igual que en el caso de la función `evolution', pero
     en este caso la función también dependerá del parámetro <x>, el
     cual tomará valores comprendidos en el intervalo de <x0> a <xf>,
     con incrementos <xstep>. Cada valor usado para el parámetro <x> se
     muestra en el eje horizontal. En el eje vertical se mostrarán <n2>
     valores de la sucesión <y(n1+1)>,..., <y(n1+n2+1)>, obtenidos
     después de dejarla evolucionar durante <n1> iteraciones iniciales.


 -- Función: rk (EDO, var, inicial, dominio)
 -- Función: rk ([EDO1,...,EDOm], [v1,...,vm], [inic1,...,inicm],
          dominio)
     La primera forma se usa para resolver numéricamente una ecuación
     diferencial ordinaria de primer orden (EDO), y la segunda forma
     resuelve numéricamente un sistema de <m> de esas ecuaciones,
     usando el método de Runge-Kutta de cuarto orden. <var> representa
     la variable dependiente.  EDO debe ser una expresión que dependa
     únicamente de las variables independiente y dependente, y define
     la derivada de la variable dependiente en función de la variable
     independiente.

     La variable independiente se representa con <dominio>, que debe ser
     una lista con cuatro elementos, como por ejemplo:
          [t, 0, 10, 0.1]
     el primer elemento de la lista identifica la variable
     independiente, el segundo y tercer elementos son los valores
     inicial y final para esa variable, y el último elemento da el
     valor de los incrementos que deberán ser usados dentro de ese
     intervalo.

     Si se van a resolver <m> ecuaciones, deberá haber <m> variables
     dependientes <v1>, <v2>, ..., <vm>. Los valores iniciales para
     esas variables serán <inic1>, <inic2>, ..., <inicm>. Continuará
     existiendo apenas una variable independiente definida por la lista
     <domain>, como en el caso anterior. <EDO1>, ..., <EDOm> son las
     expresiones que definen las derivadas de cada una de las variables
     dependientes en función de la variable independiente. Las únicas
     variables que pueden aparecer en cada una de esas expresiones son
     la variable independiente y cualquiera de las variables
     dependientes. Es importante que las derivadas <EDO1>, ..., <EDOm>
     sean colocadas en la lista en el mismo orden en que fueron
     agrupadas las variables dependientes; por ejemplo, el tercer
     elemento de la lista será interpretado como la derivada de la
     tercera variable dependiente.

     El programa intenta integrar las ecuaciones desde el valor inicial
     de la variable independiente, hasta el valor final, usando
     incrementos fijos. Si en algún paso una de las variables
     dependientes toma un valor absoluto muy grande, la integración
     será suspendida en ese punto.  El resultado será una lista con un
     número de elementos igual al número de iteraciones realizadas.
     Cada elemento en la lista de resultados es también una lista con
     <m>+1 elementos: el valor de la variable independiente, seguido de
     los valores de las variables dependientes correspondientes a ese
     punto.


 -- Función: staircase (<F>, <y0>, <n>, ...opciones...);
     Dibuja un diagrama de escalera (o diagrama de red) para la sucesión
     definida por la ecuación de recurrencia
                  y(n+1) = F(y(n))

     La interpretación y valores permitidos de los parámetros de entrada
     es la misma que para la función `evolution'. Un diagrama de
     escalera consiste en una gráfica de la función <F(y)>, junto con
     la recta <G(y)> `=' <y>. Se comienza por dibujar un segmento
     vertical desde el punto (<y0>, <y0>) en la recta, hasta el punto
     de intersección con la función <F>. En seguida, desde ese punto se
     dibuja un segmento horizontal hasta el punto de intersección con
     la recta, (<y1>, <y1>); el procedimiento se repite <n> veces hasta
     alcanzar el punto (<yn>, <yn>).


   Opciones

   Cada opción es una lista con dos o más elementos. El primer elemento
en la lista es el nombre de la opción y el resto consiste en los
argumentos para esa opción.

   Las opciones aceptadas por las funciones evolution, evolution2,
staircase, orbits, ifs y chaosgame son las siguientes:

   * "domain" especifica los valores mínimo y máximo de la variable
     independiente para la gráfica de la función <F> representada por
     `staircase'.

   * "pointsize" define el radio de cada punto dibujado, en unidades de
     puntos.  El valor por omisión es 1.

   * "xaxislabel" es la etiqueta que se escribirá en el eje horizontal.

   * "xcenter" es la coordenada x del punto que deberá aparecer en el
     centro de la gráfica. Esta opción no es usada por la función
     `orbits'.

   * "xradius" es mitad de la longitud del intervalo de valores de x que
     será representado. Esta opción no es usada por la función `orbits'.

   * "yaxislabel" es la etiqueta que se escribirá en el eje vertical.

   * "ycenter" es la coordenada y del punto que deberá aparecer en el
     centro de la gráfica.

   * "yradius" es mitad de la longitud del intervalo de valores de y que
     será representado.


   Las opciones aceptadas por los programas julia y mandelbrot son las
siguientes:

   * "size" acepta uno o dos argumentos. Si se da solo un argumento, el
     ancho y la altura del fichero gráfico creado serán iguales a ese
     valor en pixels. Si se dan dos argumentos, esos dos valores serán
     usados para el ancho y la altura. El valor por omisión es 400
     pixels tanto para el ancho como para la altura. Si los dos valores
     no son iguales, el conjunto aparecerá distorcionado.

   * "levels" define el número máximo de iteraciones, que es también el
     número de colores usado para los puntos que no pertenecem al
     conjunto. El valor por omisión es 12; valores mayores implican
     tiempos de procesamiento más elevados.

   * "huerange" define el intervalo de ángulos usados para la tonalidad
     de los puntos que no pertenecen al conjunto. El valor por omisión
     es 360, que hace que los colores usados abarcarán todo el rango de
     tonalidades. Valores mayores que 360 implican repetición de algunos
     valores de la tonalidad, y pueden usarse valores negativos para
     que el ángulo de tonalidad sea menor a medida que el número de
     iteraciones aumente.

   * "hue" define la tonalidad, en grados, del primer color usado para
     representar los puntos que no pertenecen al conjunto.  Su valor por
     omisión es 300 grados, que corresponde al color magenta; el color
     correspondiente para otros valores estandar es rojo 0, naranja 45,
     amarillo 60, verde 120, cian 180 y azul 240. Consulte también la
     opción <huerange>.

   * "saturation" define el nivel de saturación que será usado para los
     colores de los puntos que no pertenecen al conjunto. Debe ser un
     valor entre 0 y 1. El valor por omisión es 0.46.

   * "value" define el valor de los colores usados para puntos que no
     pertenezcan al conjunto. Debe estar comprendido entre 0 y 1; cuanto
     mayor sea, mas brilhantes serán los colores. Su valor por omisión
     es 0.96.

   * "color" debe ir seguido de tres parámetros que definen la
     tonalidad, saturación y valor del color que será usado para los
     puntos del conjunto. El valor por omisión es 0 para los tres
     parámetros, que corresponde al negro. Consulte las explicación
     sobre el rango de valores aceptados en la explicación de las
     opciones <hue>, <saturation> y <value>.

   * "center" deberá tener dos parámetros reales que dan las
     coordenadas, en el plano complejo, del punto en el centro de la
     región representada. El valor por omisión es 0 para las dos
     coordenadas (el origen).

   * "radius" es el radio de el mayor círculo que cabe dentro de la
     región quadrada que será representada. El valor por omisión es 2.

   * "filename" da el nombre del fichero donde se guardará la gráfica
     producida. A ese nombre se le acrecentará la terminación .xpm. Si
     el fichero ya existe, será substituido por el fichero producido
     por la función. El valor por omisión es julia para el conjunto de
     Julia y mandelbrot para el conjunto de Mandelbrot.


   Ejemplos

   Representación gráfica y diagrama de escalera de la secuencia: 2,
cos(2), cos(cos(2)),...

     (%i1) load("dynamics")$
     (%i2) evolution(cos(y), 2, 11, [yaxislabel, "y"], [xaxislabel,"n"]);
     (%i3) staircase(cos(y), 1, 11, [domain, 0, 1.2]);

   Si su procesador es lento, tendrá que reducir el número de
iteraciones usado en los ejemplos siguientes. Y el valor de <pointsize>
que da mejores resultados depende del monitor y de la resolución que
use. Tendrá que experimentar con diferentes valores.

   Diagrama de órbitas para el mapa cuadrático
             y(n+1) = x + y(n)^2

     (%i4) orbits(y^2+x, 0, 50, 200, [x, -2, 0.25, 0.01], [pointsize, 0.9]);

   Para ampliar la región alrededor de la bifurcación en la parte de
abajo, cerca de x `=' -1.25, use el comando:
     (%i5) orbits(x+y^2, 0, 100, 400, [x,-1,-1.53,-0.001], [pointsize,0.9],
                  [ycenter,-1.2], [yradius,0.4]);

   Evolución de un sistema en dos dimensiones, que conduce a un fractal:

     (%i6) f: 0.6*x*(1+2*x)+0.8*y*(x-1)-y^2-0.9$
     (%i7) g: 0.1*x*(1-6*x+4*y)+0.1*y*(1+9*y)-0.4$
     (%i8) evolution2d([f,g],[-0.5,0],50000,[pointsize,0.7]);

   Y una ampliación de una pequeña región en el fractal:

     (%i9) evolution2d([f,g],[-0.5,0],300000,[pointsize,0.7], [xcenter,-0.7],
                       [ycenter,-0.3],[xradius,0.1],[yradius,0.1]);

   Una gráfica del triangulo de Sierpinsky, obtenida con el juego del
caos:

     (%i9) chaosgame([[0, 0], [1, 0], [0.5, sqrt(3)/2]], [0.1, 0.1], 1/2,
                      30000, [pointsize,0.7]);

   El helecho de Barnsley, obtenido con el Sistema de Funciones
Iteradas:

     (%i10) a1: matrix([0.85,0.04],[-0.04,0.85])$
     (%i11) a2: matrix([0.2,-0.26],[0.23,0.22])$
     (%i12) a3: matrix([-0.15,0.28],[0.26,0.24])$
     (%i13) a4: matrix([0,0],[0,0.16])$
     (%i14) p1: [0,1.6]$
     (%i15) p2: [0,1.6]$
     (%i16) p3: [0,0.44]$
     (%i17) p4: [0,0]$
     (%i18) w: [85,92,99,100]$
     (%i19) ifs(w,[a1,a2,a3,a4],[p1,p2,p3,p4],[5,0],50000,[pointsize,0.9]);

   Para crear un fichero llamado _dinamica9.xpm_ con la representación
gráfica del conjunto de Mandelbrot, con 12 colores, use el comando:

     mandelbrot([filename,"dinamica9"])$

   y el conjunto de Julia del número (-0.55 + i 0.6) puede ser obtenido
con:
     julia(-0.55, 0.6, [levels, 36], [center, 0, 0.6], [radius, 0.3],
           [hue, 240], [huerange, -180], [filename, "dinamica10"])$

   la gráfica se guardará en el fichero _dinamica10.xpm_ y mostrará la
región desde -0.3 hasta 0.3 en la dirección x, y desde 0.3 hasta 0.9 en
la dirección y. Serán usados 36 colores, comenzando con azul e
terminando con amarillo.

   Para resolver numéricamente la ecuación diferencial

               dx/dt = t - x^2

   Con valor inicial x(t=0) = 1, en el intervalo de t desde 0 hasta 8, y
con incrementos de 0.1, se usa:

     (%i20) resultados: rk(t-x^2,x,1,[t,0,8,0.1])$

   los resultados quedarán guardados en la lista resultados.

   Para resolver numéricamente el sistema:

             dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1

   para t entre 0 y 4, con valores iniciales -1.25 y 0.75 para (x, y)
en t=0:

     (%i21) sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$


File: maxima.info,  Node: eval_string,  Next: f90,  Prev: dynamics,  Up: Top

50 eval_string
**************

* Menu:

* Funciones y variables para eval_string::


File: maxima.info,  Node: Funciones y variables para eval_string,  Prev: eval_string,  Up: eval_string

50.1 Funciones y variables para eval_string
===========================================

 -- Función: eval_string (<str>)
     Analiza sintácticamente la cadena <str> interpretándola como una
     expresión de Maxima y evaluándola a continuación.  El valor dado a
     <str> debe ser una cadena de Maxima (no de Lisp).  La expresión
     puede terminar con un carácter de terminación de sentencia (`$' o
     `;') o carecer de él. Tan solo se analiza y evalúa la primera
     expresión si hay más de una.

     Si <str> no es una cadena de Maxima se emite un mensaje de error.

     Ejemplos:

          (%i1) eval_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                       42
          (%i2) eval_string ("(foo: 42, bar: foo^2 + baz)");
          (%o2)                   baz + 1764

     Véase también `parse_string'.

 -- Función: parse_string (<str>)
     Analiza sintácticamente la cadena <str> interpretándola como una
     expresión de Maxima sin evaluarla.  El valor dado a  <str> debe
     ser una cadena de Maxima (no de Lisp).  La expresión puede
     terminar con un carácter de terminación de sentencia (`$' o `;') o
     carecer de él. Tan solo se analiza y evalúa la primera expresión
     si hay más de una.

     Si <str> no es una cadena de Maxima se emite un mensaje de error.

     Ejemplos:

          (%i1) parse_string ("foo: 42; bar: foo^2 + baz");
          (%o1)                    foo : 42
          (%i2) parse_string ("(foo: 42, bar: foo^2 + baz)");
                                             2
          (%o2)          (foo : 42, bar : foo  + baz)

     Véase también `eval_string'.


File: maxima.info,  Node: f90,  Next: ggf,  Prev: eval_string,  Up: Top

51 f90
******

* Menu:

* Funciones y variables para f90::


File: maxima.info,  Node: Funciones y variables para f90,  Prev: f90,  Up: f90

51.1 Funciones y variables para f90
===================================

 -- Función: f90 (<expr>)
     La función `f90' es una mejora de la función nativa `fortran' de
     Maxima. La diferencia principal estriba en la forma como se
     interrumpen las líneas de código.

     En el siguiente ejemplo, nótese como la instrucción `fortran'
     interrumpe las líneas dentro de los símbolos.  La instrucción
     `f90', en cambio, nunca corta símbolos.


     (%i1) load("f90")$

     (%i2) expr:expand((xxx+yyy+7)^4);
              4            3         3        2    2
     (%o2) yyy  + 4 xxx yyy  + 28 yyy  + 6 xxx  yyy
                  2          2        3             2
      + 84 xxx yyy  + 294 yyy  + 4 xxx  yyy + 84 xxx  yyy
                                    4         3          2
      + 588 xxx yyy + 1372 yyy + xxx  + 28 xxx  + 294 xxx
      + 1372 xxx + 2401
     (%i3) fortran(expr);
           yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294*yy
          1   y**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx**4+28*
          2   xxx**3+294*xxx**2+1372*xxx+2401
     (%o3)                       done
     (%i4) f90(expr);
     yyy**4+4*xxx*yyy**3+28*yyy**3+6*xxx**2*yyy**2+84*xxx*yyy**2+294* &
          yyy**2+4*xxx**3*yyy+84*xxx**2*yyy+588*xxx*yyy+1372*yyy+xxx** &
          4+28*xxx**3+294*xxx**2+1372*xxx+2401
     (%o4)                       done

     La implementación de la función `f90' se ha hecho como un parche
     inmediato. No es en modo alguno un buen ejemplo a utilizar como
     paradigma en otras traducciones entre lenguajes.

     Antes de hacer uso de esta función ejecútese  `load("f90")'.


File: maxima.info,  Node: ggf,  Next: graphs,  Prev: f90,  Up: Top

52 ggf
******

* Menu:

* Funciones y variables para ggf::


File: maxima.info,  Node: Funciones y variables para ggf,  Prev: ggf,  Up: ggf

52.1 Funciones y variables para ggf
===================================

 -- Variable opcional: GGFINFINITY
     Valor por defecto: 3

     Variable opcional para la función `ggf'.

     Cuando se calcula la fracción continua de la función generatriz,
     si un cociente parcial tiene grado estrictamente mayor que
     <GGFINFINITY> será descartado y la convergencia alcanzada hasta
     ese momento será considerada como exacta para la función
     generatriz. Lo más frecuente es que el grado de todos los
     cocientes parciales sea 0 ó 1, de modo que si se utiliza un valor
     mayor se deberán dar más términos para conseguir un cálculo más
     exacto.

     Véase también `ggf'.

 -- Variable opcional: GGFCFMAX
     Valor por defeco: 3

     Variable opcional para la función `ggf'.

     Cuando se calcula la fracción continua de la función generatriz,
     si no se ha encontrado un resultado aceptable (véase la variable
     <GGFINFINITY>) después de haber calculado <GGFCFMAX> cocientes
     parciales, la función generatriz será considerada no equivalente a
     una fracción racional y la función `ggf' se detendrá. Puede
     asignársele a <GGFCFMAX> un valor mayor para funciones
     generatrices más complicadas.

     Véase también `ggf'.

 -- Función: ggf (<l>)
     Calcula la función generatriz de una sucesión de la que se
     suministran tan solo los primeros valores y cuyo término general
     es una fracción algebraica (cociente de dos polinomios).

     La solución se devuelve como una fracción de polinomios.  En caso
     de no poder encontrar una solución, se devuelve `done'.

     Esta función está controlada por las variables globales
     <GGFINFINITY> y <GGFCFMAX>. Véanse también <GGFINFINITY> y
     <GGFCFMAX>.

     Antes de hacer uso de esta función ejecútese  `load("ggf")'.


File: maxima.info,  Node: graphs,  Next: grobner,  Prev: ggf,  Up: Top

53 graphs
*********

* Menu:

* Introducción a graphs::
* Funciones y variables para graphs::


File: maxima.info,  Node: Introducción a graphs,  Next: Funciones y variables para graphs,  Prev: graphs,  Up: graphs

53.1 Introducción a graphs
==========================

El paquete `graphs' permite trabajar con estructuras de grafos y
digrafos en Maxima. Tanto los grafos como los digrafos son de
estructura simples (no tienen ni aristas mÃºltiples ni bucles), pero
los digrafos pueden tener una arista dirigida desde <u> hasta <v> y
otra desde <v> hasta <u>.

   Los grafos se representan internamente como listas de adyacencia y se
implementan como estructuras de lisp. Los vértices se identifican por
sus números de identificacin' (siempre enteros). Las aristas/arcos se
representan por listas de longitud 2. Se pueden asignar etiquetas a los
vértices de los grafos/digrafos y pesos a sus aristas/arcos.

   La función `draw_graph' dibuja grafos siguiendo un criterio rígido
de posicionamiento de los vértices. También puede hacer uso del
programa graphviz disponible en `http://www.graphviz.org'. La funcin'
`draw_graph' utiliza el paquete `draw' de Maxima.

   Para hacer uso de este paquete, ejecútese primero `load(graphs)'.


File: maxima.info,  Node: Funciones y variables para graphs,  Prev: Introducción a graphs,  Up: graphs

53.2 Funciones y variables para graphs
======================================

53.2.1 Construyendo grafos
--------------------------

 -- Función: create_graph (<v_list>, <e_list>)
 -- Función: create_graph (<n>, <e_list>)
 -- Función: create_graph (<v_list>, <e_list>, <directed>)
     Crea un nuevo grafo sobre el conjunto de vértices <v_list> con
     aristas <e_list>.

     <v_list> es una lista de vértices (`[v1, v2,..., vn]') o una lista
     de vértices junto con sus respectivas etiquetas (`[[v1,l1],
     [v2,l2],..., [vn,ln]]').

     <n> es el número de vértices, los cuales se identificarán desde 0
     hasta n-1.

     <e_list> es una lista de aristas (`[e1, e2,..., em]') o una lista
     de aristas con sus respectivas ponderaciones (`[[e1, w1], ...,
     [em, wm]]').

     Si <directed> is not `false', se devolverá un grafo orientado.

     Ejemplos:

     Crea un ciclo de 3 vértices.

          (%i1) load (graphs)$
          (%i2) g : create_graph([1,2,3], [[1,2], [2,3], [1,3]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Crea un ciclo de 3 vértices y aristas ponderadas:

          (%i1) load (graphs)$
          (%i2) g : create_graph([1,2,3], [[[1,2], 1.0], [[2,3], 2.0],
                                          [[1,3], 3.0]])$
          (%i3) print_graph(g)$
          Graph on 3 vertices with 3 edges.
          Adjacencies:
            3 :  1  2
            2 :  3  1
            1 :  3  2

     Crea un grafo orientado:

          (%i1) load (graphs)$
          (%i2) d : create_graph(
                 [1,2,3,4],
                 [
                  [1,3], [1,4],
                  [2,3], [2,4]
                 ],
                 'directed = true)$
          (%i3) print_graph(d)$
          Digraph on 4 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :
            2 :  4  3
            1 :  4  3

 -- Función: copy_graph (<g>)
     Devuelve una copia del grafo <g>.

 -- Función: circulant_graph (<n>, <d>)
     Devuelve un grafo cirlulante de parámetros <n> y <d>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : circulant_graph(10, [1,3])$
          (%i3) print_graph(g)$
          Graph on 10 vertices with 20 edges.
          Adjacencies:
            9 :  2  6  0  8
            8 :  1  5  9  7
            7 :  0  4  8  6
            6 :  9  3  7  5
            5 :  8  2  6  4
            4 :  7  1  5  3
            3 :  6  0  4  2
            2 :  9  5  3  1
            1 :  8  4  2  0
            0 :  7  3  9  1

 -- Función: clebsch_graph ()
     Devuelve el grafo de Clebsch.

 -- Función: complement_graph (<g>)
     Devuelve el complemento del grafo <g>.

 -- Función: complete_bipartite_graph (<n>, <m>)
     Devuelve el grafo bipartido completo de <n+m> vértices.

 -- Función: complete_graph (<n>)
     Devuelve el grafo completo de <n> vértices.

 -- Función: cycle_digraph (<n>)
     Devuelve el ciclo dirigido de <n> vértices.

 -- Función: cycle_graph (<n>)
     Devuelve el ciclo de <n> vértices.

 -- Función: cube_graph (<n>)
     Devuelve el cubo de <n> dimensiones.

 -- Función: dodecahedron_graph ()
     Devuelve el grafo del dodecaedro.

 -- Función: empty_graph (<n>)
     Devuelve el grafo vacío de <n> vértices.

 -- Función: flower_snark (<n>)
     Devuelve el grafo de flor de <4n> vértices.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) f5 : flower_snark(5)$
          (%i3) chromatic_index(f5);
          (%o3)                                  4

 -- Función: from_adjacency_matrix (<A>)
     Devuelve el grafo definido por la matriz de adyacencia <A>.

 -- Función: frucht_graph ()
     Devuelve el grafo de Frucht.

 -- Función: graph_product (<g1>, <g1>)
     Devuelve el producto dirigido de los grafos <g1> y <g2>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) grid : graph_product(path_graph(3), path_graph(4))$
          (%i3) draw_graph(grid)$

 -- Función: graph_union (<g1>, <g1>)
     Devuelve la unión (suma) de los grafos <g1> y <g2>.

 -- Función: grid_graph (<n>, <m>)
     Devuelve la rejilla <n x m>.

 -- Función: grotzch_graph ()
     Devuelve el grafo de Grotzch.

 -- Función: heawood_graph ()
     Devuelve el grafo de Heawood.

 -- Función: icosahedron_graph ()
     Devuelve el grafo del icosaedro.

 -- Función: induced_subgraph (<V>, <g>)
     Devuelve el grafo inducido por el subconjunto <V> de vértices del
     grafo <g>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) V : [0,1,2,3,4]$
          (%i4) g : induced_subgraph(V, p)$
          (%i5) print_graph(g)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  3  0
            3 :  2  4
            2 :  1  3
            1 :  0  2
            0 :  1  4

 -- Función: line_graph (<g>)
     Devuelve el grafo de línea del grafo <g>.

 -- Función: make_graph (<vrt>, <f>)
 -- Función: make_graph (<vrt>, <f>, <oriented>)
     Crea un grafo por medio de la función de predicado <f>.

     <vrt> es una lista o conjunto de vértices o un simplemente un
     número entero.  Si <vrt> es un número entero, entonces los
     vértices del grafo serán los enteros desde 1 hasta <vrt>.

     <f> es una función de predicado. Dos vértices <a> y <b> se
     conectarán si `f(a,b)=true'.

     Si <directed> no es <false>, entonces en grafo será dirigido.

     Ejemplo 1:
          (%i1) load(graphs)$
          (%i2) g : make_graph(powerset({1,2,3,4,5}, 2), disjointp)$
          (%i3) is_isomorphic(g, petersen_graph());
          (%o3)                         true
          (%i4) get_vertex_label(1, g);
          (%o4)                        {1, 2}

     Ejemplo 2:
          (%i1) load(graphs)$
          (%i2) f(i, j) := is (mod(j, i)=0)$
          (%i3) g : make_graph(20, f, directed=true)$
          (%i4) out_neighbors(4, g);
          (%o4)                    [8, 12, 16, 20]
          (%i5) in_neighbors(18, g);
          (%o5)                    [1, 2, 3, 6, 9]

 -- Función: mycielski_graph (<g>)
     Devuelve el grafo de Mycielski del grafo <g>.

 -- Función: new_graph ()
     Devuelve el grafo sin vértices ni aristas.

 -- Función: path_digraph (<n>)
     Devuelve el camino dirigido de <n> vértices.

 -- Función: path_graph (<n>)
     Devuelve el camino de <n> vértices.

 -- Función: petersen_graph ()
 -- Función: petersen_graph (<n>, <d>)
     Devuelve el grafo de Petersen <P_{n,d}>. Los valores por defecto
     para <n> y <d> son `n=5' y `d=2'.

 -- Función: random_bipartite_graph (<a>, <b>, <p>)
     Devuelve un grafo aleatorio bipartido a partir de los vértices
     `a+b'. Cada arista se genera con probabilidad <p>.

 -- Función: random_digraph (<n>, <p>)
     Devuelve un grafo aleatorio dirigido de <n> vértices. Cada arco se
     presenta con una probabilidad <p>.

 -- Función: random_regular_graph (<n>)
 -- Función: random_regular_graph (<n>, <d>)
     Devuelve un grafo aleatorio <d>-regular de <n> vértices. El valor
     por defecto para <d> es `d=3'.

 -- Función: random_graph (<n>, <p>)
     Devuelve un grafo aleatorio de <n> vértices. Cada arco se presenta
     con una probabilidad <p>.

 -- Función: random_graph1 (<n>, <m>)
     Devuelve un grafo aleatorio de <n> vértices y <m> arcos aleatorios.

 -- Función: random_network (<n>, <p>, <w>)
     Devuelve una red aleatoria de <n> vértices. Cada arco se presenta
     con probabilidad <p> y tiene un peso dentro del rango `[0,w]'.  La
     función devuelve una lista `[network, source, sink]'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) [net, s, t] : random_network(50, 0.2, 10.0);
          (%o2)                         [DIGRAPH, 50, 51]
          (%i3) max_flow(net, s, t)$
          (%i4) first(%);
          (%o4)                   27.65981397932507

 -- Función: random_tournament (<n>)
     Devuelve un torneo aleatorio de <n> vértices.

 -- Función: random_tree (<n>)
     Devuelve un árbol aleatorio de <n> vértices.

 -- Función: tutte_graph ()
     Devuelve el grafo de Tutte.

 -- Función: underlying_graph (<g>)
     Devuelve el grafo asociado al grafo orientado <g>.

 -- Función: wheel_graph (<n>)
     Devuelve el grafo de rueda de <n+1> vértices.

53.2.2 Propiedades de los grafos
--------------------------------

 -- Función: adjacency_matrix (<gr>)
     Devuelve la matriz de adyacencia del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(4)$
          (%i3) adjacency_matrix(c5);
                                          [ 0  1  0  1 ]
                                          [            ]
                                          [ 1  0  1  0 ]
          (%o3)                           [            ]
                                          [ 0  1  0  1 ]
                                          [            ]
                                          [ 1  0  1  0 ]

 -- Función: average_degree (<gr>)
     Devuelve el grado medio de los vértices del garfo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) average_degree(grotzch_graph());
                                                40
          (%o2)                                 --
                                                11

 -- Función: biconected_components (<gr>)
     Devuelve los subconjuntos de vértices biconectados del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph(
                      [1,2,3,4,5,6,7],
                      [
                       [1,2],[2,3],[2,4],[3,4],
                       [4,5],[5,6],[4,6],[6,7]
                      ])$
          (%i3) biconnected_components(g);
          (%o3)               [[6, 7], [4, 5, 6], [1, 2], [2, 3, 4]]


 -- Función: bipartition (<gr>)
     Devuelve una bipartición de los vértices del grafo <gr>, o una
     lista vacía si <gr> no es bipartido.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) h : heawood_graph()$
          (%i3) [A,B]:bipartition(h);
          (%o3)         [[8, 12, 6, 10, 0, 2, 4], [13, 5, 11, 7, 9, 1, 3]]
          (%i4) draw_graph(h, show_vertices=A, program=circular)$

 -- Función: chromatic_index (<gr>)
     Devuelve el índice cromático del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) chromatic_index(p);
          (%o3)                                  4

 -- Función: chromatic_number (<gr>)
     Devuelve el número cromático del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) chromatic_number(cycle_graph(5));
          (%o2)                                  3
          (%i3) chromatic_number(cycle_graph(6));
          (%o3)                                  2

 -- Función: clear_edge_weight (<e>, <gr>)
     Elimina el peso del arco <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph(3, [[[0,1], 1.5], [[1,2], 1.3]])$
          (%i3) get_edge_weight([0,1], g);
          (%o3)                                 1.5
          (%i4) clear_edge_weight([0,1], g)$
          (%i5) get_edge_weight([0,1], g);
          (%o5)                                  1

 -- Función: clear_vertex_label (<v>, <gr>)
     Elimina la etiqueta del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                               Zero
          (%i4) clear_vertex_label(0, g);
          (%o4)                               done
          (%i5) get_vertex_label(0, g);
          (%o5)                               false

 -- Función: connected_components (<gr>)
     Devuelve las componentes conexas del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: graph_union(cycle_graph(5), path_graph(4))$
          (%i3) connected_components(g);
          (%o3)                  [[1, 2, 3, 4, 0], [8, 7, 6, 5]]

 -- Función: diameter (<gr>)
     Devuelve el diámetro del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) diameter(dodecahedron_graph());
          (%o2)                                 5

 -- Función: edge_coloring (<gr>)
     Devuelve una coloración óptima de los arcos del grafo <gr>.

     La función devuelve el índice cromático y una lista que representa
     el coloreado de los arcos de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) [ch_index, col] : edge_coloring(p);
          (%o3) [4, [[[0, 5], 3], [[5, 7], 1], [[0, 1], 1], [[1, 6], 2],
          [[6, 8], 1], [[1, 2], 3], [[2, 7], 4], [[7, 9], 2], [[2, 3], 2],
          [[3, 8], 3], [[5, 8], 2], [[3, 4], 1], [[4, 9], 4], [[6, 9], 3],
          [[0, 4], 2]]]
          (%i4) assoc([0,1], col);
          (%o4)                           1
          (%i5) assoc([0,5], col);
          (%o5)                           3

 -- Función: degree_sequence (<gr>)
     Devuelve una lista con los grados de los vértices del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) degree_sequence(random_graph(10, 0.4));
          (%o2)            [2, 2, 2, 2, 2, 2, 3, 3, 3, 3]

 -- Función: edge_connectivity (<gr>)
     Devuelve la conectividad de las aristas del grafo conexto <gr>.

 -- Función: edges (<gr>)
     Devuelve la lista de las aristas (arcos) del grafo (dirigido) <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) edges(complete_graph(4));
          (%o2)         [[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]

 -- Función: get_edge_weight (<e>, <gr>)
 -- Función: get_edge_weight (<e>, <gr>, <ifnot>)
     Devuelve el peso de la arista <e> del grafo <gr>.

     Si la arista no tiene peso, la función devuelve 1. Si la arista no
     pertenece al grafo, la función emite un mensaje de error o devuelve
     el argumento opcional <ifnot>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(5)$
          (%i3) get_edge_weight([1,2], c5);
          (%o3)                                 1
          (%i4) set_edge_weight([1,2], 2.0, c5);
          (%o4)                               done
          (%i5) get_edge_weight([1,2], c5);
          (%o5)                                2.0

 -- Función: get_vertex_label (<v>, <gr>)
     Devuelve la etiqueta del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[0,"Zero"], [1, "One"]], [[0,1]])$
          (%i3) get_vertex_label(0, g);
          (%o3)                               Zero

 -- Función: graph_charpoly (<gr>, <x>)
     Devuelve el polinomio característico (de variable <x>) del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_charpoly(p, x), factor;
                                                   5        4
          (%o3)                     (x - 3) (x - 1)  (x + 2)

 -- Función: graph_center (<gr>)
     Devuelve el centro del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_center(g);
          (%o3)                               [12]

 -- Función: graph_eigenvalues (<gr>)
     Devuelve los valores propios del grafo <gr>. La función devuelve
     los valores propios en el mismo formato en el que lo hace la
     función `eigenvalue'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_eigenvalues(p);
          (%o3)                     [[3, - 2, 1], [1, 4, 5]]

 -- Función: graph_periphery (<gr>)
     Devuelve la periferia del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : grid_graph(5,5)$
          (%i3) graph_periphery(g);
          (%o3)                          [24, 20, 4, 0]

 -- Función: graph_size (<gr>)
     Devuelve el número de vértices del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_size(p);
          (%o3)                                10

 -- Función: graph_order (<gr>)
     Devuelve el número de aristas del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) graph_order(p);
          (%o3)                                15

 -- Función: girth (<gr>)
     Devuelve la longitud del ciclo más corto del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : heawood_graph()$
          (%i3) girth(g);
          (%o3)                                 6

 -- Función: hamilton_cycle (<gr>)
     Devuelve el ciclo de Hamilton del grafo <gr> o una lista vacía si
     <gr> no es hamiltoniano.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c : cube_graph(3)$
          (%i3) hc : hamilton_cycle(c);
          (%o3)              [7, 3, 2, 6, 4, 0, 1, 5, 7]
          (%i4) draw_graph(c, show_edges=vertices_to_cycle(hc))$

 -- Función: hamilton_path (<gr>)
     Devuelve el camino de Hamilton del grafo <gr> o una lista vacía si
     <gr> no los tiene.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) hp : hamilton_path(p);
          (%o3)                  [0, 5, 7, 2, 1, 6, 8, 3, 4, 9]
          (%i4) draw_graph(p, show_edges=vertices_to_path(hp))$

 -- Función: isomorphism (<gr1>, <gr2>)
     Devuelve un isomorfismo entre los grafos/digrafos <gr1> y <gr2>.
     Si <gr1> y <gr2> no son isomorfos, devuelve una lista vacía.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) isomorphism(clk5, petersen_graph());
          (%o3) [9 -> 0, 2 -> 1, 6 -> 2, 5 -> 3, 0 -> 4, 1 -> 5, 3 -> 6,
                                                    4 -> 7, 7 -> 8, 8 -> 9]

 -- Función: in_neighbors (<v>, <gr>)
     Devuelve la lista de los nodos hijos del vértice <v> del grafo
     orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                                 [1]
          (%i4) out_neighbors(2, p);
          (%o4)                                 []

 -- Función: is_biconnected (<gr>)
     Devuelve `true' si <gr> está biconectado y `false' en caso
     contrario.

     Ejemplo:

     Example:
          (%i1) load (graphs)$
          (%i2) is_biconnected(cycle_graph(5));
          (%o2)                         true
          (%i3) is_biconnected(path_graph(5));
          (%o3)                         false

 -- Función: is_bipartite (<gr>)
     Devuelve `true' si <gr> es bipartido (2-coloreable) y `false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_bipartite(petersen_graph());
          (%o2)                               false
          (%i3) is_bipartite(heawood_graph());
          (%o3)                               true

 -- Función: is_connected (<gr>)
     Devuelve `true' si el grafo <gr> es conexo y `false' en caso
     contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_connected(graph_union(cycle_graph(4), path_graph(3)));
          (%o2)                               false

 -- Función: is_digraph (<gr>)
     Devuelve `true' si <gr> es un grafo orientado (digrafo) y `false'
     en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_digraph(path_graph(5));
          (%o2)                               false
          (%i3) is_digraph(path_digraph(5));
          (%o3)                               true

 -- Función: is_edge_in_graph (<e>, <gr>)
     Devuelve `true' si <e> es una arista (arco) del grafo (digrafo)
     <g> y `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_edge_in_graph([2,3], c4);
          (%o3)                               true
          (%i4) is_edge_in_graph([3,2], c4);
          (%o4)                               true
          (%i5) is_edge_in_graph([2,4], c4);
          (%o5)                               false
          (%i6) is_edge_in_graph([3,2], cycle_digraph(4));
          (%o6)                               false

 -- Función: is_graph (<gr>)
     Devuelve `true' si <gr> es un grafo y `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_graph(path_graph(5));
          (%o2)                               true
          (%i3) is_graph(path_digraph(5));
          (%o3)                               false

 -- Función: is_graph_or_digraph (<gr>)
     Devuelve `true' si <gr> es una grafo, orientado o no, y `false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_graph_or_digraph(path_graph(5));
          (%o2)                               true
          (%i3) is_graph_or_digraph(path_digraph(5));
          (%o3)                               true

 -- Función: is_isomorphic (<gr1>, <gr2>)
     Devuelve `true' si los grafos/digrafos <gr1> y <gr2> son isomorfos
     y `false' en caso contrario.

     Véase también `isomorphism'.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) clk5:complement_graph(line_graph(complete_graph(5)))$
          (%i3) is_isomorphic(clk5, petersen_graph());
          (%o3)                         true

 -- Función: is_planar (<gr>)
     Devuelve `true' si <gr> es un grafo planar y `false' en caso
     contrario.

     El algoritmo utilizado es el de Demoucron, que es de tiempo
     cuadrático.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_planar(dodecahedron_graph());
          (%o2)                                true
          (%i3) is_planar(petersen_graph());
          (%o3)                                false
          (%i4) is_planar(petersen_graph(10,2));
          (%o4)                                true

 -- Función: is_sconnected (<gr>)
     Devuelve `true' si el grafo orientado <gr> es fuertemente conexo,
     devolviendo `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_sconnected(cycle_digraph(5));
          (%o2)                               true
          (%i3) is_sconnected(path_digraph(5));
          (%o3)                               false

 -- Función: is_vertex_in_graph (<v>, <gr>)
     Devuelve `true' si <v> es un vértice del grafo <g> y `false' en
     caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c4 : cycle_graph(4)$
          (%i3) is_vertex_in_graph(0, c4);
          (%o3)                               true
          (%i4) is_vertex_in_graph(6, c4);
          (%o4)                               false

 -- Función: is_tree (<gr>)
     Devuelve `true' si <gr> es un árbol y `false' en caso contrario.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) is_tree(random_tree(4));
          (%o2)                               true
          (%i3) is_tree(graph_union(random_tree(4), random_tree(5)));
          (%o3)                               false

 -- Función: laplacian_matrix (<gr>)
     Devuelve el laplaciano de la matriz del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) laplacian_matrix(cycle_graph(5));
                                    [  2   - 1   0    0   - 1 ]
                                    [                         ]
                                    [ - 1   2   - 1   0    0  ]
                                    [                         ]
          (%o2)                     [  0   - 1   2   - 1   0  ]
                                    [                         ]
                                    [  0    0   - 1   2   - 1 ]
                                    [                         ]
                                    [ - 1   0    0   - 1   2  ]

 -- Función: max_clique (<gr>)
     Devuelve el clique máximo del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.5)$
          (%i3) max_clique(g);
          (%o3)       [6, 12, 31, 36, 52, 59, 62, 63, 80]

 -- Función: max_degree (<gr>)
     Devuelve el grado máximo de los vértices del grafo <gr> y un
     vértice de grado máximo.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.02)$
          (%i3) max_degree(g);
          (%o3)                        [6, 79]
          (%i4) vertex_degree(95, g);
          (%o4)                           3

 -- Función: max_flow (<net>, <s>, <t>)
     Devuelve el flujo maximal de la red <net> con origen en <s> y
     final en <t>.

     La función devuelve el valor del flujo maximal y una lista con los
     pesos de los arcos del flujo óptimo.

     Ejemplo:

     Example:
          (%i1) load (graphs)$
          (%i2) net : create_graph(
            [1,2,3,4,5,6],
            [[[1,2], 1.0],
             [[1,3], 0.3],
             [[2,4], 0.2],
             [[2,5], 0.3],
             [[3,4], 0.1],
             [[3,5], 0.1],
             [[4,6], 1.0],
             [[5,6], 1.0]],
            directed=true)$
          (%i3) [flow_value, flow] : max_flow(net, 1, 6);
          (%o3) [0.7, [[[1, 2], 0.5], [[1, 3], 0.2], [[2, 4], 0.2],
          [[2, 5], 0.3], [[3, 4], 0.1], [[3, 5], 0.1], [[4, 6], 0.3],
          [[5, 6], 0.4]]]
          (%i4) fl : 0$
          (%i5) for u in out_neighbors(1, net)
                   do fl : fl + assoc([1, u], flow)$
          (%i6) fl;
          (%o6)                                 0.7

 -- Función: max_independent_set (<gr>)
     Devuelve un conjunto maximal independiente de vértices del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) mi : max_independent_set(d);
          (%o3)             [0, 3, 5, 9, 10, 11, 18, 19]
          (%i4) draw_graph(d, show_vertices=mi)$

 -- Función: max_matching (<gr>)
     Devuelve un conjunto maximal independiente de aristas del grafo
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) m : max_matching(d);
          (%o3) [[5, 7], [8, 9], [6, 10], [14, 19], [13, 18], [12, 17],
                                         [11, 16], [0, 15], [3, 4], [1, 2]]
          (%i4) draw_graph(d, show_edges=m)$

 -- Función: min_degree (<gr>)
     Devuelve el grado mínimo de los vértices del grafo <gr> y un
     vértice de grado mínimo.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : random_graph(100, 0.1)$
          (%i3) min_degree(g);
          (%o3)                              [3, 49]
          (%i4) vertex_degree(21, g);
          (%o4)                                 9

 -- Función: min_edge_cut (<gr>)
     Devuelve el mínimo edge cut del grafo conexo <gr>. Un edge cut es
     un conjunto de aristas cuya eliminación aumenta el número de
     componentes del grafo.

 -- Función: min_vertex_ cover(<gr>)
     Devuelve el mínimo nodo covering del grafo <gr>.

 -- Función: minimum_spanning_tree (<gr>)
     Devuelve el grafo de expansión mínimo del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : graph_product(path_graph(10), path_graph(10))$
          (%i3) t : minimum_spanning_tree(g)$
          (%i4) draw_graph(g, show_edges=edges(t))$

 -- Función: neighbors (<v>, <gr>)
     Devuelve la lista de los vecinos del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : petersen_graph()$
          (%i3) neighbors(3, p);
          (%o3)                             [4, 8, 2]

 -- Función: odd_girth (<gr>)
     Devuelve la longitud del ciclo impar más corto del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : graph_product(cycle_graph(4), cycle_graph(7))$
          (%i3) girth(g);
          (%o3)                                 4
          (%i4) odd_girth(g);
          (%o4)                                 7

 -- Función: out_neighbors (<v>, <gr>)
     Devuelve la lista de los nodos padres del vértice <v> del grafo
     orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_digraph(3)$
          (%i3) in_neighbors(2, p);
          (%o3)                                 [1]
          (%i4) out_neighbors(2, p);
          (%o4)                                 []

 -- Función: planar_embedding (<gr>)
     Devuelve la lista de caminos faciales en una proyección planar de
     <gr>, o `false' si <gr> no es un grafo planar.

     El grafo <gr> debe estar biconectado.

     El algoritmo utilizado es el de Demoucron, que es de tiempo
     cuadrático.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) planar_embedding(grid_graph(3,3));
          (%o2) [[3, 6, 7, 8, 5, 2, 1, 0], [4, 3, 0, 1], [3, 4, 7, 6],
                                                [8, 7, 4, 5], [1, 2, 5, 4]]

 -- Función: print_graph (<gr>)
     Muestra alguna información sobre el grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c5 : cycle_graph(5)$
          (%i3) print_graph(c5)$
          Graph on 5 vertices with 5 edges.
          Adjacencies:
            4 :  0  3
            3 :  4  2
            2 :  3  1
            1 :  2  0
            0 :  4  1
          (%i4) dc5 : cycle_digraph(5)$
          (%i5) print_graph(dc5)$
          Digraph on 5 vertices with 5 arcs.
          Adjacencies:
            4 :  0
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i6) out_neighbors(0, dc5);
          (%o6)                                [1]

 -- Función: radius (<gr>)
     Devuelve el radio del grafo  <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) radius(dodecahedron_graph());
          (%o2)                                 5

 -- Función: set_edge_weight (<e>, <w>, <gr>)
     Asigna el peso <w> a la arista <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([1, 2], [[[1,2], 1.2]])$
          (%i3) get_edge_weight([1,2], g);
          (%o3)                                1.2
          (%i4) set_edge_weight([1,2], 2.1, g);
          (%o4)                               done
          (%i5) get_edge_weight([1,2], g);
          (%o5)                                2.1

 -- Función: set_vertex_label (<v>, <l>, <gr>)
     Asigna la etiqueta <l> al vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : create_graph([[1, "One"], [2, "Two"]], [[1,2]])$
          (%i3) get_vertex_label(1, g);
          (%o3)                                One
          (%i4) set_vertex_label(1, "oNE", g);
          (%o4)                               done
          (%i5) get_vertex_label(1, g);
          (%o5)                                oNE

 -- Función: shortest_path (<u>, <v>, <gr>)
     Devuelve el camino más corto desde <u> hasta <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) path : shortest_path(0, 7, d);
          (%o3)                          [0, 1, 19, 13, 7]
          (%i4) draw_graph(d, show_edges=vertices_to_path(path))$

 -- Función: shortest_weighted_path (<u>, <v>, <gr>)
     Devuelve la longitud del camino más corto ponderado y el propio
     camino más corto ponderado desde <u> hasta <v> en el grafo <gr>.

     La longitud del camino ponderado es la suma de los pesos de las
     aristas del camino. Si una arista no tiene peso asignado, su valor
     por defecto es la unidad.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: petersen_graph(20, 2)$
          (%i3) for e in edges(g) do set_edge_weight(e, random(1.0), g)$
          (%i4) shortest_weighted_path(0, 10, g);
          (%o4) [2.575143920268482, [0, 20, 38, 36, 34, 32, 30, 10]]


 -- Función: strong_components (<gr>)
     Devuelve las componentes fuertes del grafo orientado <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) t : random_tournament(4)$
          (%i3) strong_components(t);
          (%o3)                         [[1], [0], [2], [3]]
          (%i4) vertex_out_degree(3, t);
          (%o4)                                 3

 -- Función: topological_sort (<dag>)
     Devuelve el orden topológico de los vértices del grafo orientado
     <dag> o una lista vacía si <dag> no es un grafo orientado acíclico.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g:create_graph(
                   [1,2,3,4,5],
                   [
                    [1,2], [2,5], [5,3],
                    [5,4], [3,4], [1,3]
                   ],
                   directed=true)$
          (%i3) topological_sort(g);
          (%o3)                           [1, 2, 5, 3, 4]

 -- Función: vertex_degree (<v>, <gr>)
     Devuelve el grado del vértice <v> del grafo <gr>.

 -- Función: vertex_distance (<u>, <v>, <gr>)
     Devuelve la longitud del camino más corto entre <u> y <v> del
     grafo o digrafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) d : dodecahedron_graph()$
          (%i3) vertex_distance(0, 7, d);
          (%o3)                                 4
          (%i4) shortest_path(0, 7, d);
          (%o4)                         [0, 1, 19, 13, 7]

 -- Función: vertex_eccentricity (<v>, <gr>)
     Devuelve la excentricidad del vértice <v> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g:cycle_graph(7)$
          (%i3) vertex_eccentricity(0, g);
          (%o3)                           3

 -- Función: vertex_in_degree (<v>, <gr>)
     Devuelve el grado de entrada del vértice <v> del grafo orientado
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p5 : path_digraph(5)$
          (%i3) print_graph(p5)$
          Digraph on 5 vertices with 4 arcs.
          Adjacencies:
            4 :
            3 :  4
            2 :  3
            1 :  2
            0 :  1
          (%i4) vertex_in_degree(4, p5);
          (%o4)                                 1
          (%i5) in_neighbors(4, p5);
          (%o5)                                [3]

 -- Función: vertex_out_degree (<v>, <gr>)
     Devuelve el grado de salida del vértice <v> del grafo orientado
     <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) t : random_tournament(10)$
          (%i3) vertex_out_degree(0, t);
          (%o3)                           2
          (%i4) out_neighbors(0, t);
          (%o4)                        [7, 1]

 -- Función: vertices (<gr>)
     Devuelve la lista de vértices del grafo <gr>.

     Example

          (%i1) load (graphs)$
          (%i2) vertices(complete_graph(4));
          (%o2)                           [3, 2, 1, 0]

53.2.3 Modificación de grafos
-----------------------------

 -- Función: add_edge (<e>, <gr>)
     Añade la arista <e> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p : path_graph(4)$
          (%i3) neighbors(0, p);
          (%o3)                                [1]
          (%i4) add_edge([0,3], p);
          (%o4)                               done
          (%i5) neighbors(0, p);
          (%o5)                              [3, 1]

 -- Función: add_edges (<e_list>, <gr>)
     Añade las aristas de la lista  <e_list> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : empty_graph(3)$
          (%i3) add_edges([[0,1],[1,2]], g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  1
            1 :  2  0
            0 :  1

 -- Función: add_vertex (<v>, <gr>)
     Añade el vértice <v> al grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : path_graph(2)$
          (%i3) add_vertex(2, g)$
          (%i4) print_graph(g)$
          Graph on 3 vertices with 1 edges.
          Adjacencies:
            2 :
            1 :  0
            0 :  1

 -- Función: add_vertices (<v_list>, <gr>)
     Añade los vértices de la lista  <v_list> al grafo <gr>.

 -- Función: connect_vertices (<v_list>, <u_list>, <gr>)
     Conecta todos los vértices de la lista <v_list> con los vértices
     de la lista <u_list> del grafo <gr>.

     <v_list> y <u_list> pueden ser vértices aislados o una lista de
     vértices.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g : empty_graph(4)$
          (%i3) connect_vertices(0, [1,2,3], g)$
          (%i4) print_graph(g)$
          Graph on 4 vertices with 3 edges.
          Adjacencies:
            3 :  0
            2 :  0
            1 :  0
            0 :  3  2  1

 -- Función: contract_edge (<e>, <gr>)
     Contrae la arista <e> del <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) g: create_graph(
                 8, [[0,3],[1,3],[2,3],[3,4],[4,5],[4,6],[4,7]])$
          (%i3) print_graph(g)$
          Graph on 8 vertices with 7 edges.
          Adjacencies:
            7 :  4
            6 :  4
            5 :  4
            4 :  7  6  5  3
            3 :  4  2  1  0
            2 :  3
            1 :  3
            0 :  3
          (%i4) contract_edge([3,4], g)$
          (%i5) print_graph(g)$
          Graph on 7 vertices with 6 edges.
          Adjacencies:
            7 :  3
            6 :  3
            5 :  3
            3 :  5  6  7  2  1  0
            2 :  3
            1 :  3
            0 :  3

 -- Función: remove_edge (<e>, <gr>)
     Elimina la arista <e> del grafo <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) c3 : cycle_graph(3)$
          (%i3) remove_edge([0,1], c3)$
          (%i4) print_graph(c3)$
          Graph on 3 vertices with 2 edges.
          Adjacencies:
            2 :  0  1
            1 :  2
            0 :  2

 -- Función: remove_vertex (<v>, <gr>)
     Elimina el vértice <v> del grafo <gr>.

 -- Función: vertex_coloring (<gr>)
     Devuelve un coloreado óptimo de los vértice del grafo <gr>.

     La función devuelve el número cromático y una lista representando
     el coloreado de los vértices de <gr>.

     Ejemplo:

          (%i1) load (graphs)$
          (%i2) p:petersen_graph()$
          (%i3) vertex_coloring(p);
          (%o3) [3, [[0, 2], [1, 3], [2, 2], [3, 3], [4, 1], [5, 3],
                                          [6, 1], [7, 1], [8, 2], [9, 2]]]

53.2.4 Lectura y escritura de ficheros
--------------------------------------

 -- Función: dimacs_export (<gr>, <fl>)
 -- Función: dimacs_export (<gr>, <fl>, <comment1>, ..., <commentn>)
     Exporta el grafo al fichero <fl> en formato DIMACS. Los comentarios
     adicionales se anãdirán al comienzo del fichero.

 -- Función: dimacs_import (<fl>)
     Lee el grafo almacenado en el fichero <fl> en formato DIMACS.

 -- Función: graph6_decode (<str>)
     Devuelve el grafo codificado en formato graph6 en la cadena <str>.

 -- Función: graph6_encode (<gr>)
     Devuelve una cadena codificando el grafo <gr> en formato graph6.

 -- Función: graph6_export (<gr_list>, <fl>)
     Exporta los grafos de la lista <gr_list> al fichero <fl> en
     formato graph6.

 -- Función: graph6_import (<fl>)
     Lee la lista de grafos almacenados en el fichero <fl> en formato
     graph6.

 -- Función: sparse6_decode (<str>)
     Devuelve el grafo codificado en formato sparse6 en la cadena <str>.

 -- Función: sparse6_encode (<gr>)
     Devuelve una cadena codificando el grafo <gr> en formato sparse6.

 -- Función: sparse6_export (<gr_list>, <fl>)
     Exporta los grafos de la lista <gr_list> al fichero <fl> en
     formato sparse6.

 -- Función: sparse6_import (<fl>)
     Lee la lista de grafos almacenados en el fichero <fl> en formato
     sparse6.

53.2.5 Visualización
--------------------

 -- Función: draw_graph (<graph>)
 -- Función: draw_graph (<graph>, <option1>, ..., <optionk>)
     Dibuja el grafo utilizando el paquete `draw'.

     El algoritmo utilizado para posicionar los vértices se especifica
     con el argumento opcional <program>, cuyo valor por defecto es
     `program=spring_embedding'.  <spring_embedding> también puede
     utilizar los programas de graphviz para posicionar los vértices,
     para lo cual deberá instalarse separadamente el programa graphviz.

     Los argumentos opcionales de la función <draw_graph> son:

        * "show_id=show": si <show> vale <true> entonces se muestran los
          números identificadores de los vértices.

        * "show_label=show": si <show> vale <true> entonces se muestran
          las etiquetas de los vértices.

        * "label_alignment=pos": indica cómo se deben alinear las
          etiquetas o números identificadores de los vértices. Puede
          ser: `left', `center' or `right'.  El valor por defecto es
          `left'.

        * "show_weight=show": si <show> vale <true> entonces se
          mostrarán los pesos de las aristas.

        * "vertex_type=type": establece cómo se mostrarán los vértices.
          Véase la opción <point_type> del paquete `draw'.

        * "vertex_size=size": tamanõ de los vértices.

        * "vertex_color=c": color a utilizar en los vértices.

        * "show_vertices=v_list": dibuja los vértices de la lista
          <v_list> con colores diferentes.

        * "show_vertex_type=type": establece cómo se mostrarán los
          vértices de <show_vertices>. Véase la opción <point_type> del
          paquete `draw'.

        * "show_vertex_size=size": tamanõs de los vértices de
          <show_vertices>.

        * "show_vertex_color=c": color a utilizar en los vértices de la
          lista <show_vertices>.

        * "vertex_partition=part": una partición
          `[[v1,v2,...],...,[vk,...,vn]]' de los vértices del grafo. Los
          vértices de cada lista se dibujarán de diferente color.

        * "vertex_coloring=col": colores de los vértices. Los colores
          <col> deben especificarse en el mismo formato que el devuelto
          por <vertex_coloring>.

        * "edge_color=c": color a utilizar en las aristas.

        * "edge_width=width": ancho de las aristas.

        * "edge_type=type": establece cómo se dibujarán las aristas.
          Véase la opción <line_type> del paquete `draw'.

        * "show_edges=e_list": dibuja las aristas de la lista <e_list>
          con colores diferentes.

        * "show_edge_color=c": color a utilizar en las aristas de la
          lista <show_edges>.

        * "show_edge_width=width": anchos de las aristas de
          <show_edges>.

        * "show_edge_type=type": establece cómo se dibujarán las
          aristas de <show_edges>.  Véase la opción <line_type> del
          paquete `draw'.

        * "edge_partition=partition": una partición
          `[[e1,e2,...],...,[ek,...,em]]' de las aristas del grafo. Las
          aristas de cada lista se dibujarán de diferente color.

        * "edge_coloring=col": colores de las aristas. Los colores
          <col> deben especificarse en el mismo formato que el devuelto
          por <edge_coloring>.

        * "redraw=r": si <redraw> vale `true', las posiciones de los
          vértices se recalculan incluso si las posiciones están
          almacenadas de un dibujo previo del grafo.

        * "head_angle=angle": ángulo de las flechas de los arcos en los
          grafos orientados.  Valor por defecto: 15.

        * "head_length=len": longitud de las flechas de los arcos en
          los grafos orientados.  Valor por defecto: 0.1.

        * "spring_embedding_depth=depth": número de iteraciones del
          algoritmo de dibujo de grafos.  Valor por defecto: 50.

        * "terminal=term": terminal utilizado para ver el gráfo. Véase
          la opción <terminal> del paquete `draw'.

        * "file_name=file": nombre del fichero cuando el terminal
          especificado no es la pantalla.

        * "program=prg": establece el programa para posicionado de
          vértices del grafo. Puede ser cualquiera de los programas
          graphviz (dot, neato, twopi, circ, fdp), <circular> o
          <spring_embedding> or <planar_embedding>; <planar_embedding>
          sl'o está disponible para grafos planares 2-conectados. Si
          `program=spring_embedding', se puede especificar un conjunto
          de vértices de posición fija con la opción <fixed_vertices>.

        * "fixed_vertices=[]": especifica una lista de vértices con
          posiciones fijas en un polígono regular. Se puede utilizar
          cuando `program=spring_embedding'.

     Ejemplo 1:

          (%i1) load (graphs)$
          (%i2) g:grid_graph(10,10)$
          (%i3) m:max_matching(g)$
          (%i4) draw_graph(g,
             spring_embedding_depth=100,
             show_edges=m, edge_type=dots,
             vertex_size=0)$

     Ejemplo 2:

          (%i1) load (graphs)$
          (%i2) g:create_graph(16,
              [
               [0,1],[1,3],[2,3],[0,2],[3,4],[2,4],
               [5,6],[6,4],[4,7],[6,7],[7,8],[7,10],[7,11],
               [8,10],[11,10],[8,9],[11,12],[9,15],[12,13],
               [10,14],[15,14],[13,14]
              ])$
          (%i3) t:minimum_spanning_tree(g)$
          (%i4) draw_graph(
              g,
              show_edges=edges(t),
              show_edge_width=4,
              show_edge_color=green,
              vertex_type=filled_square,
              vertex_size=2
              )$

     Ejemplo 3:

          (%i1) load (graphs)$
          (%i2) mi : max_independent_set(g)$
          (%i3) draw_graph(
              g,
              show_vertices=mi,
              show_vertex_type=filled_up_triangle,
              show_vertex_size=2,
              edge_color=cyan,
              edge_width=3,
              show_id=true,
              text_color=brown
              )$

     Ejemplo 4:

          (%i1) load (graphs)$
          (%i2) net : create_graph(
              [0,1,2,3,4,5],
              [
               [[0,1], 3], [[0,2], 2],
               [[1,3], 1], [[1,4], 3],
               [[2,3], 2], [[2,4], 2],
               [[4,5], 2], [[3,5], 2]
              ],
              directed=true
              )$
          (%i3) draw_graph(
              net,
              show_weight=true,
              vertex_size=0,
              show_vertices=[0,5],
              show_vertex_type=filled_square,
              head_length=0.2,
              head_angle=10,
              edge_color="dark-green",
              text_color=blue
              )$

     Ejemplo 5:

          (%i1) load(graphs)$
          (%i2) g: petersen_graph(20, 2);
          (%o2)                         GRAPH
          (%i3) draw_graph(g, redraw=true, program=planar_embedding);
          (%o3)                         done

     Ejemplo 6:

          (%i1) load(graphs)$
          (%i2) t: tutte_graph();
          (%o2)                         GRAPH
          (%i3) draw_graph(t, redraw=true, fixed_vertices=[1,2,3,4,5,6,7,8,9]);
          (%o3)                         done


 -- Variable opcional: draw_graph_program
     Valor por defecto: <spring_embedding>.

     Programa a utilizar por defecto para posicionar los vértices en la
     función `draw_graph'.

 -- Función: vertices_to_path (<v_list>)
     Convierte una lista <v_list> de vértices en la lista de aristas
     del camino definido por la propia <v_list>.

 -- Función: vertices_to_cycle (<v_list>)
     Convierte una lista <v_list> de vértices en la lista de aristas
     del ciclo definido por la propia <v_list>.


File: maxima.info,  Node: grobner,  Next: impdiff,  Prev: graphs,  Up: Top

54 grobner
**********

* Menu:

* Introducción a grobner::
* Funciones y variables para grobner::


File: maxima.info,  Node: Introducción a grobner,  Next: Funciones y variables para grobner,  Prev: Top,  Up: Top

54.1 Introducción a grobner
===========================

`grobner' es un paquete para operar con bases de Groebner en Maxima.

Se puede encontrar un tutorial sobre _Bases de Groebner_ en

`http://www.geocities.com/CapeCanaveral/Hall/3131/'

Para hacer uso de las funciones de este paquete es necesario cargar
previamente el archivo `grobner.lisp':

     load(grobner);

Es posible ejecutar una demostración haciendo
     demo("grobner.demo");

o
     batch("grobner.demo")

Algunos de los cálculos de la demostración pueden llevar tiempo, razón
por la cual sus resultados se han guardado en el archivo
`grobner-demo.output', que se encuentra en el mismo directorio que el
archivo de demostración.

54.1.1 Notas sobre el paquete grobner
-------------------------------------

El autor del paquete es

Marek Rychlik

`http://alamos.math.arizona.edu'

habiendo sido distribuido el 24-05-2002 bajo los términos de la General
Public License (GPL) (ver archivo `grobner.lisp'). Esta documentación
ha sido extraída de los archivos
`README', `grobner.lisp', `grobner.demo' y `grobner-demo.output'

por Günter Nowak. Las sugerencias para mejorar la documentación se
pueden hacer en la lista de correos de _maxima_,
<maxima@math.utexas.edu>.

   El código está algo anticuado. Las implementaciones modernas utilizan
el algoritmo _F4_, más rápido, descrito en
A new efficient algorithm for computing Gröbner bases (F4)
Jean-Charles Faugère
LIP6/CNRS Université Paris VI
January 20, 1999

54.1.2 Implementaciones de órdenes admisibles de monomios
---------------------------------------------------------

   * `lex'

     lexicográfico puro; orden por defecto para la comparación de
     monomios.

   * `grlex'

     grado total, con empates resueltos por el orden lexicográfico.

   * `grevlex'

     grado total, con empates resueltos por el orden lexicográfico
     inverso.

   * `invlex'

     orden lexicográfico inverso.



File: maxima.info,  Node: Funciones y variables para grobner,  Prev: Introducción a grobner,  Up: Top

54.2 Funciones y variables para grobner
=======================================

54.2.1 Variables opcionales
---------------------------

 -- Variable opcional: poly_monomial_order
     Valor por defecto: `lex'

     Controla qué orden de monomios utiliza en los cálculos con
     polinomios y bases de Groebner. Si no se le asigna valor alguno,
     se utilizará `lex'.

 -- Variable opcional: poly_coefficient_ring
     Valor por defecto: `expression_ring'

     Indica el anillo de coeficientes de los polinomios que se va a
     utilizar en los cálculos. Si no se le asigna ningún valor, se
     utilizará el anillo de expresiones propio de _maxima_.  A esta
     variable se le puede asignar el valor `ring_of_integers'.

 -- Variable opcional: poly_primary_elimination_order
     Valor por defecto: `false'

     Nombre del orden por defecto para las variables eliminadas en las
     funciones basadas en eliminaciones. Si no se le asigna ningún
     valor, se utilizará `lex'.

 -- Variable opcional: poly_secondary_elimination_order
     Valor por defecto: `false'

     Nombre del orden por defecto para las variables almacenadas en
     funciones basadas en eliminaciones. Si no se le asigna ningún
     valor, se utilizará `lex'.

 -- Variable opcional: poly_elimination_order
     Valor por defecto: `false'

     Nombre del orden de eliminación por defecto utilizado en los
     cálculos de eliminación. Si se le asigna un valor, ignorará los
     guardados en `poly_primary_elimination_order' y
     `poly_secondary_elimination_order'.  El usuario se asegurará que
     este es un orden válido de eliminación.

 -- Variable opcional: poly_return_term_list
     Valor por defecto: `false'

     Si vale `true', todas las funciones de este paquete devolverán los
     polinomios como una lista de términos en el orden activo de
     monomios, en lugar de una expresión ordinaria de _maxima_.

 -- Variable opcional: poly_grobner_debug
     Valor por defecto: `false'

     Si vale `true', genera una salida de seguimiento y depuración.

 -- Variable opcional: poly_grobner_algorithm
     Valor por defecto: `buchberger'

     Valores posibles:
        * `buchberger'

        * `parallel_buchberger'

        * `gebauer_moeller'

     Es el nombre del algoritmo utilizado para encontrar las bases de
     Groebner.

 -- Variable opcional: poly_top_reduction_only
     Valor por defecto: `false'

     Si no vale `false', siempre que sea posible el algoritmo de
     división se detendrá tras la primera reducción.

54.2.2 Operadores simples
-------------------------

`poly_add', `poly_subtract', `poly_multiply' y `poly_expt' son los
operadores aritméticos para polinomios. Se ejecutan utilizando la
representación interna, pero los resultados se devuelven en forma de
expresión ordinaria de _maxima_.

 -- Función: poly_add (<poly1>, <poly2>, <varlist>)
     Suma los polinomios <poly1> y <poly2>.

          (%i1) poly_add(z+x^2*y,x-z,[x,y,z]);
                                              2
          (%o1)                              x  y + x


 -- Función: poly_subtract (<poly1>, <poly2>, <varlist>)
     Resta el polinomio <poly2> de <poly1>.

          (%i1) poly_subtract(z+x^2*y,x-z,[x,y,z]);
                                                2
          (%o1)                          2 z + x  y - x

 -- Función: poly_multiply (<poly1>, <poly2>, <varlist>)
     Multiplica <poly1> por <poly2>.

          (%i2) poly_multiply(z+x^2*y,x-z,[x,y,z])-(z+x^2*y)*(x-z),expand;
          (%o1)                                  0

 -- Función: poly_s_polynomial (<poly1>, <poly2>, <varlist>)
     Devuelve el _polinomio syzygy_ (_S-polinomio_) de dos polinomios
     <poly1> y <poly2>.

 -- Función: poly_primitive_part (<poly1>, <varlist>)
     Devuelve el polinomio <poly> dividido por el MCD de sus
     coeficientes.

          (%i1) poly_primitive_part(35*y+21*x,[x,y]);
          (%o1)                              5 y + 3 x

 -- Función: poly_normalize (<poly>, <varlist>)
     Devuelve el polinomio <poly> dividido por el coeficiente
     principal. Da por supuesto que la división es posible, lo cual
     puede no ser siempre cierto en anillos que no son campos.

54.2.3 Otras funciones
----------------------

 -- Función: poly_expand (<poly>, <varlist>)
     Esta función expande los polinomios. Equivale a `expand(<poly>)'
     si <poly> es un polinomio. Si la representación no es compatible
     con un polinomio de variables <varlist>, devuelve un error.

          (%i1) poly_expand((x-y)*(y+x),[x,y]);
                                               2    2
          (%o1)                               x  - y
          (%i2) poly_expand((y+x)^2,[x,y]);
                                          2            2
          (%o2)                          y  + 2 x y + x
          (%i3) poly_expand((y+x)^5,[x,y]);
                            5      4         2  3       3  2      4      5
          (%o3)            y  + 5 x y  + 10 x  y  + 10 x  y  + 5 x  y + x
          (%i4) poly_expand(-1-x*exp(y)+x^2/sqrt(y),[x]);
                                                    2
                                            y      x
          (%o4)                       - x %e  + ------- - 1
                                                 sqrt(y)

          (%i5) poly_expand(-1-sin(x)^2+sin(x),[sin(x)]);
                                          2
          (%o5)                      - sin (x) + sin(x) - 1

 -- Función: poly_expt (<poly>, <number>, <varlist>)
     Eleva el polinomio <poly> a la potencia <number>, siendo este un
     entero positivo. Si <number> no es un número entero positivo,
     devolverá un error.

          (%i1) poly_expt(x-y,3,[x,y])-(x-y)^3,expand;
          (%o1)                                  0

 -- Función: poly_content (<poly>. <varlist>)
     `poly_content' calcula el MCD de los coeficientes.

          (%i1) poly_content(35*y+21*x,[x,y]);
          (%o1)                                  7

 -- Función: poly_pseudo_divide (<poly>, <polylist>, <varlist>)
     Realiza la seudo-división del polinomio <poly> por la lista de n
     polinomios de <polylist>.  Devuelve varios resultados. El primer
     resultado es una lista de cocientes a. El segundo resultado es el
     resto r. El tercer resultado es un coeficiente escalar c, tal que
     c*poly puede dividirse por <polylist> dentro del anillo de
     coeficientes, el cual no es necesariamente un campo. Por último,
     el cuarto resultado es un entero que guarda el recuento de
     reducciones realizadas. El objeto resultante satisface la ecuación:

     c*poly=sum(a[i]*polylist[i],i=1...n)+r.

 -- Función: poly_exact_divide (<poly1>, <poly2>, <varlist>)
     Divide el polinomio <poly1> por otro polinomio <poly2>. Da por
     supuesto que es posible la división de resto nulo. Devuelve el
     cociente.

 -- Función: poly_normal_form (<poly>, <polylist>, <varlist>)
     `poly_normal_form' encuentra la forma normal de un polinomio
     <poly> respecto de un conjunto de polinomios <polylist>.

 -- Función: poly_buchberger_criterion (<polylist>, <varlist>)
     Devuelve `true' si <polylist> es una base de Groebner respecto del
     orden de términos activo, utilizando el criterio de Buchberger:
     para cualesquiera polinomios h1 y h2 de <polylist> el S-polinomio
     S(h1,h2) se reduce a 0 modulo <polylist>.


 -- Función: poly_buchberger (<polylist_fl> <varlist>)
     `poly_buchberger' ejecuta el algoritmo de Buchberger sobre una
     lista de polinomios y devuelve la base de Groebner resultante.


54.2.4 Postprocesamiento estándar de bases de Groebner
------------------------------------------------------

El _k-ésimo ideal de eliminación_ I_k de un ideal I sobre K[
x[1],...,x[n] ] es el ideal intersect(I, K[ x[k+1],...,x[n] ]).
El _ideal_ I:J es el ideal {h|para todo w en J: w*h pertence a I}.
El ideal I:p^inf es el ideal {h| existe un n en N: p^n*h pertence a I}.
El ideal I:J^inf es el ideal {h| existe un n en N y un p en J: p^n*h
pertence a I}.
El _ideal radical_ sqrt(I) es el ideal {h| existe un n en N : h^n
pertence a I }.



 -- Función: poly_reduction (<polylist>, <varlist>)
     `poly_reduction' reduce una lista de polinomios <polylist> de
     manera que cada polinomio se reduce completamente respecto de los
     otros polinomios.

 -- Función: poly_minimization (<polylist>, <varlist>)
     Devuelve una sublista de la lista de polinomios <polylist> con el
     mismo ideal de monomios que <polylist>, pero mínimo, esto es,
     ningún monomio principal de los polinomios de la sublista divide a
     los monomios principales de los demás polinomios.


 -- Función: poly_normalize_list (<polylist>, <varlist>)
     `poly_normalize_list' aplica `poly_normalize' a cada polinomio de
     la lista. Esto significa que divide cada polinomio de <polylist>
     por su coeficiente principal.


 -- Función: poly_grobner (<polylist>, <varlist>)
     Devuelve la base de Groebner del ideal asociado a los polinomios
     de <polylist>. El resultado depende de las variables globales.

 -- Función: poly_reduced_grobner (<polylist>, <varlist>)
     Devuelve la base de Groebner reducida del ideal asociado a los
     polinomios de <polylist>. El resultado depende de las variables
     globales.

 -- Función: poly_depends_p (<poly>, <var>, <varlist>)
     `poly_depends' comprueba si el polinomio depende de la variable
     <var>.

 -- Función: poly_elimination_ideal (<polylist>, <n>, <varlist>)
     `poly_elimination_ideal' devuelve la base de Groebner del n-ésimo
     ideal de eliminación de un ideal especificado como una lista de
     polinomios generadores (no necesariamente una base de Groebner).

 -- Función: poly_colon_ideal (<polylist1>, <polylist2>, <varlist>)
     Devuelve la base de Groebner reducida del ideal

     I(polylist1):I(polylist2)

     siendo polylist1 y polylist2 dos listas de polinomios.

 -- Función: poly_ideal_intersection (<polylist1>, <polylist2>,
          <varlist>)
     `poly_ideal_intersection' devuelve la intersección de dos ideales.

 -- Función: poly_lcm (<poly1>, <poly2>, <varlist>)
     Devuelve el MCM de <poly1> y <poly2>.

 -- Función: poly_gcd (<poly1>, <poly2>, <varlist>)
     Devuelve el MCD de <poly1> y <poly2>.

 -- Función: poly_grobner_equal (<polylist1>, <polylist2>, <varlist>)
     `poly_grobner_equal' comprueba si dos bases de Groebner generan el
     mismo ideal. Devuelve `true' si dos listas de polinomios
     <polylist1> y <polylist2>, supuestas bases de Groebner, generan el
     mismo ideal, o `false' en caso contrario.  Eso equivale a
     comprobar si cada polinomio de la primera base se reduce a 0
     módulo la segunda base y viceversa. Nótese que en el ejemplo que
     sigue la primera lista no es una base de Groebner, por lo que el
     resultado es `false'.

          (%i1) poly_grobner_equal([y+x,x-y],[x,y],[x,y]);
          (%o1)                         false


 -- Función: poly_grobner_subsetp (<polylist1>, <polylist2>, <varlist>)
     `poly_grobner_subsetp' comprueba si el ideal generado por
     <polylist1> está contenido en el ideal generado por <polylist2>.
     Para que esta comprobación tenga éxito, <polylist2> debe ser una
     base de Groebner.

 -- Función: poly_grobner_member (<poly>, <polylist>, <varlist>)
     Devuelve `true' si el polinomio <poly> pertenece al ideal generado
     por la lista de polinomios <polylist>, la cual se supone una base
     de Groebner.  Devolverá `false' en caso contrario.

 -- Función: poly_ideal_saturation1 (<polylist>, <poly>, <varlist>)
     Devuelve la base de Groebner reducida de la saturación del ideal

     I(polylist):poly^inf

     Desde un punto de vista geométrico, sobre un campo algebraicamente
     cerrado, este es el conjunto de polinomios del ideal generado por
     <polylist> que no se anulan sobre la variedad de  <poly>.

 -- Función: poly_ideal_saturation (<polylist1>, <polylist2>, <varlist>)
     Devuelve la base de Groebner reducida de la saturación del ideal

     I(polylist1):I(polylist2)^inf

     Desde un punto de vista geométrico, sobre un campo algebraicamente
     cerrado, este es el conjunto de polinomios del ideal generado por
     <polylist1> que no se anulan sobre la variedad de  <polylist2>.

 -- Función: poly_ideal_polysaturation1 (<polylist1>, <polylist2>,
          <varlist>)
     <polylist2> es una lista de n poliomios `[poly1,...,polyn]'.
     Devuelve la base de Groebner reducida del ideal

     I(polylist):poly1^inf:...:polyn^inf

     obtenida a partir de una secuencia de saturaciones sucesivas de
     los polinomios de la lista <polylist2> del ideal generado por la
     lista de polinomios <polylist1>.

 -- Función: poly_ideal_polysaturation (<polylist>, <polylistlist>,
          <varlist>)
     <polylistlist> es una lista de n listas de polinomios
     `[polylist1,...,polylistn]'.  Devuelve la base de Groebner
     reducida de la saturación del ideal

     I(polylist):I(polylist_1)^inf:...:I(polylist_n)^inf

 -- Función: poly_saturation_extension (<poly>, <polylist>, <varlist1>,
          <varlist2>)
     `poly_saturation_extension' ejecuta el truco de Rabinowitz.

 -- Función: poly_polysaturation_extension (<poly>, <polylist>,
          <varlist1>, <varlist2>)


File: maxima.info,  Node: impdiff,  Next: interpol,  Prev: grobner,  Up: Top

55 impdiff
**********

* Menu:

* Funciones y variables para impdiff::


File: maxima.info,  Node: Funciones y variables para impdiff,  Prev: impdiff,  Up: impdiff

55.1 Funciones y variables para impdiff
=======================================

 -- Función: implicit_derivative (<f>,<indvarlist>,<orderlist>,<depvar>)
     Calcula las derivadas implícitas de funciones multivariantes. <f>
     es una función array, los índices son los grados de las derivadas
     en el orden establecido en <indvarlist>, <indvarlist> es la lista
     de variables independientes, <orderlist> es el orden deseado y
     <depvar> es la variable dependiente.

     Antes de hacer uso de esta función ejecútese  `load("impdiff")'.



File: maxima.info,  Node: interpol,  Next: lapack,  Prev: impdiff,  Up: Top

56 interpol
***********

* Menu:

* Introducción a interpol::
* Funciones y variables para interpol::


File: maxima.info,  Node: Introducción a interpol,  Next: Funciones y variables para interpol,  Prev: interpol,  Up: interpol

56.1 Introducción a interpol
============================

El paquete `interpol' desarrolla los métodos de interpolación
polinómica de Lagrange, lineal y de splines cúbicos.

   Para comentarios, fallos o sugerencias, contactar con <'mario ARROBA
edu PUNTO xunta PUNTO es'>.


File: maxima.info,  Node: Funciones y variables para interpol,  Prev: Introducción a interpol,  Up: interpol

56.2 Funciones y variables para interpol
========================================

 -- Función: lagrange (<points>)
 -- Función: lagrange (<points>, <option>)
     Calcula el polinomio de interpolación por el método de Lagrange.
     El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es `'x'; para definir
     otra, escríbase algo como `varname='z'.

     Téngase en cuenta que cuando se trabaja con polinomios de grado
     alto, los cálculos con números decimales en coma flotante pueden
     ser muy inestables.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) lagrange(p);
                           4        3         2
                       73 x    701 x    8957 x    5288 x   186
          (%o3)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5
          (%i4) f(x):=''%;
                               4        3         2
                           73 x    701 x    8957 x    5288 x   186
          (%o4)    f(x) := ----- - ------ + ------- - ------ + ---
                            420     210       420      105      5
          (%i5) /* Evaluate the polynomial at some points */
                map(f,[2.3,5/7,%pi]);
                                       919062
          (%o5)  [- 1.567534999999992, ------,
                                       84035
                                   4          3           2
                             73 %pi    701 %pi    8957 %pi    5288 %pi   186
                             ------- - -------- + --------- - -------- + ---]
                               420       210         420        105       5
          (%i6) %,numer;
          (%o6) [- 1.567534999999992, 10.9366573451538, 2.89319655125692]
          (%i7) load(draw)$  /* load draw package */
          (%i8) /* Plot the polynomial together with points */
                draw2d(
                  color      = red,
                  key        = "Lagrange polynomial",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i9) /* Change variable name */
                lagrange(p, varname=w);
                           4        3         2
                       73 w    701 w    8957 w    5288 w   186
          (%o9)        ----- - ------ + ------- - ------ + ---
                        420     210       420      105      5


 -- Función: charfun2 (<x>, <a>, <b>)
     Devuelve `true' si el número <x> pertenece al intervalo [a, b), y
     `false' en caso contrario.

 -- Función: linearinterpol (<points>)
 -- Función: linearinterpol (<points>, <option>)
     Calcula rectas de interpolación. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Mediante el argumento <option> es posible seleccionar el nombre de
     la variable independiente, que por defecto es `'x'; para definir
     otra, escríbase algo como `varname='z'.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p: matrix([7,2],[8,3],[1,5],[3,2],[6,7])$
          (%i3) linearinterpol(p);
                  13   3 x
          (%o3)  (-- - ---) charfun2(x, minf, 3)
                  2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3

          (%i4) f(x):=''%;
                          13   3 x
          (%o4)  f(x) := (-- - ---) charfun2(x, minf, 3)
                          2     2
           + (x - 5) charfun2(x, 7, inf) + (37 - 5 x) charfun2(x, 6, 7)
              5 x
           + (--- - 3) charfun2(x, 3, 6)
               3
          (%i5)  /* Evaluate the polynomial at some points */
                 map(f,[7.3,25/7,%pi]);
                                      62  5 %pi
          (%o5)                 [2.3, --, ----- - 3]
                                      21    3
          (%i6) %,numer;
          (%o6)  [2.3, 2.952380952380953, 2.235987755982989]
          (%i7) load(draw)$  /* load draw package */
          (%i8)  /* Plot the polynomial together with points */
                 draw2d(
                   color      = red,
                   key        = "Linear interpolator",
                   explicit(f(x),x,-5,20),
                   point_size = 3,
                   color      = blue,
                   key        = "Sample points",
                   points(args(p)))$
          (%i9)  /* Change variable name */
                 linearinterpol(p, varname='s);
                 13   3 s
          (%o9) (-- - ---) charfun2(s, minf, 3)
                 2     2
           + (s - 5) charfun2(s, 7, inf) + (37 - 5 s) charfun2(s, 6, 7)
              5 s
           + (--- - 3) charfun2(s, 3, 6)
               3


 -- Función: cspline (<points>)
 -- Función: cspline (<points>, <option1>, <option2>, ...)
     Calcula el polinomio de interpolación por el método de los splines
     cúbicos. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de tres opciones para acomodarse a
     necesidades concretas:

        * `'d1', por defecto `'unknown', es la primera derivada en x_1;
          si toma el valor `'unknown', la segunda derivada en x_1 se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * `'dn', por defecto `'unknown', es la primera derivada en x_n;
          si toma el valor `'unknown', la segunda derivada en x_n se
          iguala a 0 (spline cúbico natural); en caso de tomar un valor
          numérico, la segunda derivada se calcula en base a este
          número.

        * `'varname', por defecto `'x', es el nombre de la variable
          independiente.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) p:[[7,2],[8,2],[1,5],[3,2],[6,7]]$
          (%i3) /* Unknown first derivatives at the extremes
                   is equivalent to natural cubic splines */
                cspline(p);
                        3         2
                  1159 x    1159 x    6091 x   8283
          (%o3)  (------- - ------- - ------ + ----) charfun2(x, minf, 3)
                   3288      1096      3288    1096
                      3         2
                2587 x    5174 x    494117 x   108928
           + (- ------- + ------- - -------- + ------) charfun2(x, 7, inf)
                 1644       137       1644      137
                    3          2
              4715 x    15209 x    579277 x   199575
           + (------- - -------- + -------- - ------) charfun2(x, 6, 7)
               1644       274        1644      274
                      3         2
                3287 x    2223 x    48275 x   9609
           + (- ------- + ------- - ------- + ----) charfun2(x, 3, 6)
                 4932       274      1644     274

          (%i4) f(x):=''%$
          (%i5) /* Some evaluations */
                map(f,[2.3,5/7,%pi]), numer;
          (%o5) [1.991460766423356, 5.823200187269903, 2.227405312429507]
          (%i6) load(draw)$  /* load draw package */
          (%i7) /* Plotting interpolating function */
                draw2d(
                  color      = red,
                  key        = "Cubic splines",
                  explicit(f(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$
          (%i8) /* New call, but giving values at the derivatives */
                cspline(p,d1=0,dn=0);
                        3          2
                  1949 x    11437 x    17027 x   1247
          (%o8)  (------- - -------- + ------- + ----) charfun2(x, minf, 3)
                   2256       2256      2256     752
                      3          2
                1547 x    35581 x    68068 x   173546
           + (- ------- + -------- - ------- + ------) charfun2(x, 7, inf)
                  564       564        141      141
                   3          2
              607 x    35147 x    55706 x   38420
           + (------ - -------- + ------- - -----) charfun2(x, 6, 7)
               188       564        141      47
                      3         2
                3895 x    1807 x    5146 x   2148
           + (- ------- + ------- - ------ + ----) charfun2(x, 3, 6)
                 5076       188      141      47
          (%i8) /* Defining new interpolating function */
                g(x):=''%$
          (%i9) /* Plotting both functions together */
                draw2d(
                  color      = black,
                  key        = "Cubic splines (default)",
                  explicit(f(x),x,0,10),
                  color      = red,
                  key        = "Cubic splines (d1=0,dn=0)",
                  explicit(g(x),x,0,10),
                  point_size = 3,
                  color      = blue,
                  key        = "Sample points",
                  points(p))$

 -- Función: ratinterpol (<points>, <numdeg>)
 -- Función: ratinterpol (<points>, <numdeg>, <option1>, <option2>, ...)
     Genera el interpolador racional para los datos dados por <points>
     y con grado <numdeg> en el numerador; el grado del denominador se
     calcula automáticamente. El argumento <points> debe ser:

        * una matriz de dos columnas, `p:matrix([2,4],[5,6],[9,3])',

        * una lista de pares de números, `p: [[2,4],[5,6],[9,3]]',

        * una lista de números, `p: [4,6,3]', en cuyo caso las abscisas
          se asignarán automáticamente a 1, 2, 3, etc.

     En los dos primeros casos los pares se ordenan con respecto a la
     primera coordenada antes de proceder a los cálculos.

     Esta función dispone de dos opciones para acomodarse a necesidades
     concretas:
        * `'denterm', por defecto `1', es el término independente del
          polinomio en el denominador.

        * `'varname', por defecto `'x', es el nombre de la variable
          independiente.

     Ejemplos:

          (%i1) load(interpol)$
          (%i2) load(draw)$
          (%i3) p:[[7.2,2.5],[8.5,2.1],[1.6,5.1],[3.4,2.4],[6.7,7.9]]$
          (%i4) for k:0 thru length(p)-1 do
                  draw2d(
                    explicit(ratinterpol(p,k),x,0,9),
                    point_size = 3,
                    points(p),
                    title = concat("Grado del numerador = ",k),
                    yrange=[0,10])$


File: maxima.info,  Node: lapack,  Next: lbfgs,  Prev: interpol,  Up: Top

57 lapack
*********

* Menu:

* Introducción a lapack::
* Funciones y variables para lapack::


File: maxima.info,  Node: Introducción a lapack,  Next: Funciones y variables para lapack,  Prev: lapack,  Up: lapack

57.1 Introducción a lapack
==========================

`lapack' es una traducción automática a Common Lisp (con el programa
`f2c') de la librería LAPACK escrita en Fortran.


File: maxima.info,  Node: Funciones y variables para lapack,  Prev: Introducción a lapack,  Up: lapack

57.2 Funciones y variables para lapack
======================================

 -- Función: dgeev (<A>)
 -- Función: dgeev (<A>, <right_p>, <left_p>)
     Calcula los autovalores y, opcionalmente, también los autovectores
     de la matriz <A>.  Todos los elementos de <A> deben ser enteros o
     números decimales en coma flotante.  Además, <A> debe ser cuadrada
     (igual número de filas que de columnas) y puede ser o no simétrica.

     `dgeev(<A>)' calcula sólo los autovalores de <A>.  `dgeev(<A>,
     <right_p>, <left_p>)' calcula los autovalores de <A> y los
     autovectores por la derecha cuando <right_p> = `true', y los
     autovectores por la izquierda cuando <left_p> = `true'.

     La función devuelve una lista de tres elementos.  El primer
     elemento es una lista con los autovalores.  El segundo elemento es
     `false' o la matriz de autovectores por la derecha.  El tercer
     elemento es `false' o la matriz de autovectores por la izquierda.

     El autovector por la derecha v(j) (la j-ésima columna de la matriz
     de autovectores por la derecha) satisface

     A . v(j) = lambda(j) . v(j)

     donde lambda(j) es su autovalor asociado.

     El autovector por la izquierda u(j) (la j-ésima columna de la
     matriz de autovectores por la izquierda) satisface

     u(j)**H . A = lambda(j) . u(j)**H

     donde u(j)**H denota la transpuesta conjugada de u(j).

     La función de Maxima `ctranspose' calcula la transpuesta conjugada.

     Los autovectores calculados están normalizados para que su norma
     euclídea valga 1 y su componente mayor tenga su parte imaginaria
     igual a cero.

     Ejemplo:

          (%i1) load (lapack)$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M : matrix ([9.5, 1.75], [3.25, 10.45]);
                                   [ 9.5   1.75  ]
          (%o3)                    [             ]
                                   [ 3.25  10.45 ]
          (%i4) dgeev (M);
          (%o4)          [[7.54331, 12.4067], false, false]
          (%i5) [L, v, u] : dgeev (M, true, true);
                                     [ - .666642  - .515792 ]
          (%o5) [[7.54331, 12.4067], [                      ],
                                     [  .745378   - .856714 ]
                                                  [ - .856714  - .745378 ]
                                                  [                      ]]
                                                  [  .515792   - .666642 ]
          (%i6) D : apply (diag_matrix, L);
                                [ 7.54331     0    ]
          (%o6)                 [                  ]
                                [    0     12.4067 ]
          (%i7) M . v - v . D;
                          [      0.0       - 8.88178E-16 ]
          (%o7)           [                              ]
                          [ - 8.88178E-16       0.0      ]
          (%i8) transpose (u) . M - D . transpose (u);
                               [ 0.0  - 4.44089E-16 ]
          (%o8)                [                    ]
                               [ 0.0       0.0      ]


 -- Función: dgesvd (<A>)
 -- Función: dgesvd (<A>, <left_p>, <right_p>)
     Calcula la descomposición singular (SVD, en inglés) de la matriz
     <A>, que contiene los valores singulares y, opcionalmente, los
     vectores singulares por la derecha o por la izquierda. Todos los
     elementos de <A> deben ser enteros o números decimales en coma
     flotante. La matriz <A> puede ser cuadrada o no (igual número de
     filas que de columnas).

     Sea m el número de filas y n el de columnas de <A>.  La
     descomposición singular de <A> consiste en calcular tres matrices:
     <U>, <Sigma> y <V^T>, tales que

     <A> = <U> . <Sigma> . <V>^T

     donde <U> es una matriz unitaria m-por-m, <Sigma> es una matriz
     diagonal m-por-n y <V^T> es una matriz unitaria n-por-n.

     Sea sigma[i] un elemento diagonal de Sigma, esto es, <Sigma>[i, i]
     = <sigma>[i]. Los elementos sigma[i] se llaman valores singulares
     de <A>, los cuales son reales y no negativos, siendo devueltos por
     la función `dgesvd' en orden descendente.

     Las primeras min(m, n) columnas de <U> y <V> son los vectores
     singulares izquierdo y derecho de <A>. Nótese que `dgesvd'
     devuelve la transpuesta de <V>, no la propia matriz <V>.

     `dgesvd(<A>)' calcula únicamente los valores singulares de <A>.
     `dgesvd(<A>, <left_p>, <right_p>)' calcula los valores singulares
     de <A> y los vectores sigulares por la izquierda cuando <left_p> =
     `true', y los vectores sigulares por la derecha cuando <right_p> =
     `true'.

     La función devuelve una lista de tres elementos.  El primer
     elemento es una lista con los valores singulares.  El segundo
     elemento es `false' o la matriz de vectores singulares por la
     izquierda.  El tercer elemento es `false' o la matriz de vectores
     singulares por la derecha.

     Ejemplo:

          (%i1) load (lapack)$
          (%i2) fpprintprec : 6;
          (%o2)                           6
          (%i3) M: matrix([1, 2, 3], [3.5, 0.5, 8], [-1, 2, -3], [4, 9, 7]);
                                  [  1    2    3  ]
                                  [               ]
                                  [ 3.5  0.5   8  ]
          (%o3)                   [               ]
                                  [ - 1   2   - 3 ]
                                  [               ]
                                  [  4    9    7  ]
          (%i4) dgesvd (M);
          (%o4)      [[14.4744, 6.38637, .452547], false, false]
          (%i5) [sigma, U, VT] : dgesvd (M, true, true);
          (%o5) [[14.4744, 6.38637, .452547],
          [ - .256731  .00816168   .959029    - .119523 ]
          [                                             ]
          [ - .526456   .672116   - .206236   - .478091 ]
          [                                             ],
          [  .107997   - .532278  - .0708315  - 0.83666 ]
          [                                             ]
          [ - .803287  - .514659  - .180867    .239046  ]
          [ - .374486  - .538209  - .755044 ]
          [                                 ]
          [  .130623   - .836799   0.5317   ]]
          [                                 ]
          [ - .917986   .100488    .383672  ]
          (%i6) m : length (U);
          (%o6)                           4
          (%i7) n : length (VT);
          (%o7)                           3
          (%i8) Sigma:
                  genmatrix(lambda ([i, j], if i=j then sigma[i] else 0),
                            m, n);
                            [ 14.4744     0        0    ]
                            [                           ]
                            [    0     6.38637     0    ]
          (%o8)             [                           ]
                            [    0        0     .452547 ]
                            [                           ]
                            [    0        0        0    ]
          (%i9) U . Sigma . VT - M;
                    [  1.11022E-15        0.0       1.77636E-15 ]
                    [                                           ]
                    [  1.33227E-15    1.66533E-15       0.0     ]
          (%o9)     [                                           ]
                    [ - 4.44089E-16  - 8.88178E-16  4.44089E-16 ]
                    [                                           ]
                    [  8.88178E-16    1.77636E-15   8.88178E-16 ]
          (%i10) transpose (U) . U;
                 [     1.0      5.55112E-17    2.498E-16     2.77556E-17  ]
                 [                                                        ]
                 [ 5.55112E-17      1.0       5.55112E-17    4.16334E-17  ]
          (%o10) [                                                        ]
                 [  2.498E-16   5.55112E-17       1.0       - 2.08167E-16 ]
                 [                                                        ]
                 [ 2.77556E-17  4.16334E-17  - 2.08167E-16       1.0      ]
          (%i11) VT . transpose (VT);
                    [      1.0           0.0      - 5.55112E-17 ]
                    [                                           ]
          (%o11)    [      0.0           1.0       5.55112E-17  ]
                    [                                           ]
                    [ - 5.55112E-17  5.55112E-17       1.0      ]


 -- Función: dlange (<norm>, <A>)
 -- Función: zlange (<norm>, <A>)
     Calcula una norma o seudonorma de la matriz <A>.

    `max'
          Calcula max(abs(A(i, j))), siendo i y j números de filas y
          columnas, respectivamente, de <A>.  Nótese que esta función
          no es una norma matricial.

    `one_norm'
          Calcula la norma L[1] de <A>, esto es, el máximo de la suma
          de los valores absolutos de los elementos de cada columna.

    `inf_norm'
          Calcula la norma L[inf] de <A>, esto es, el máximo de la suma
          de los valores absolutos de los elementos de cada fila.

    `frobenius'
          Calcula la norma de Frobenius de <A>, esto es, la raíz
          cuadrada de la suma de los cuadrados de los elementos de la
          matriz.



File: maxima.info,  Node: lbfgs,  Next: lindstedt,  Prev: lapack,  Up: Top

58 lbfgs
********

* Menu:

* Introducción a lbfgs::
* Funciones y variables para lbfgs::


File: maxima.info,  Node: Introducción a lbfgs,  Next: Funciones y variables para lbfgs,  Prev: Top,  Up: Top

58.1 Introducción a lbfgs
=========================

La función `lbfgs' implementa el llamado algoritmo L-BFGS [1] para
resolver problemas de minimización sin restricciones mediante una
técnica cuasi-Newton con memoria limitada (BFGS). El término memoria
limitada procede del hecho de que se almacena una aproximación de rango
bajo de la inversa de la matriz hessiana, en lugar de la matriz
completa. El programa fue originalmente escrito en Fortran [2] por
Jorge Nocedal, incorporando algunas funciones escritas originalmente
por Jorge J. Moré y David J. Thuente, traducidas posteriormente a Lisp
automáticamente con el programa `f2cl'. El paquete `lbfgs' contiene el
código traducido, junto con una función interfaz que para controlar
ciertos detalles.

   Referencias:

   [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
large scale optimization". Mathematical Programming B 45:503-528 (1989)

   [2] `http://netlib.org/opt/lbfgs_um.shar'


File: maxima.info,  Node: Funciones y variables para lbfgs,  Prev: Introducción a lbfgs,  Up: Top

58.2 Funciones y variables para lbfgs
=====================================

 -- Función: lbfgs (<FOM>, <X>, <X0>, <epsilon>, <iprint>)
     Encuentra una solución aproximada para el problema de minimización
     sin restricciones de la función objetivo <FOM> para la lista de
     variables <X>, partiendo de los estimadores iniciales <X0>, de tal
     manera que norm grad FOM < epsilon max(1, norm X).

     El algoritmo utilizado es una técnica cuasi-Newton con memoria
     limitada (BFGS) [1]. El término memoria limitada procede del hecho
     de que se almacena una aproximación de rango bajo de la inversa de
     la matriz hessiana, en lugar de la matriz completa.  Cada
     iteración del algoritmo es una búsqueda a lo largo de una recta,
     cuya dirección se calcula a partir de la matriz inversa aproximada
     del hessiano. La función objetivo decrece siempre tras cada
     búsqueda exitosa a lo largo de la recta; además, casi siempre
     decrece también el módulo del gradiente de la función.

     El argumento <iprint> controla los mensajes de progreso que envía
     la función `lbfgs'.

    `iprint[1]'
          `<iprint>[1]' controla la frecuencia con la que se emiten los
          mensajes.
         `iprint[1] < 0'
               No se envían mensajes.

         `iprint[1] = 0'
               Mensajes únicamente en la primera y última iteraciones.

         `iprint[1] > 0'
               Imprime un mensaje cada `<iprint>[1]' iteraciones.

    `iprint[2]'
          `<iprint>[2]' controla la cantidad de información contenida
          en los mensajes.
         `iprint[2] = 0'
               Imprime contador de iteraciones, número de evaluaciones
               de <FOM>, valor de <FOM>, módulo del gradiente de <FOM>
               y amplitud del paso.

         `iprint[2] = 1'
               Igual que `<iprint>[2] = 0', incluyendo <X0> y el
               gradiente de <FOM> evaluado en <X0>.

         `iprint[2] = 2'
               Igual que `<iprint>[2] = 1', incluyendo los valores de
               <X> en cada iteración.

         `iprint[2] = 3'
               Igual que `<iprint>[2] = 2', incluyendo el gradiente de
               <FOM> en cada iteración.

     Las columnas devueltas por `lbfgs' son las siguientes:

    `I'
          Número de iteraciones. Se incremente tras cada búsqueda a lo
          largo de una recta.

    `NFN'
          Número de evaluaciones de la función objetivo.

    `FUNC'
          Valor de la función objetivo al final de cada iteración.

    `GNORM'
          Módulo del gradiente de la función objetivo al final de cada
          iteración.

    `STEPLENGTH'
          Un parámetro interno del algoritmo de búsqueda.

     Para más información sobre el algoritmo se puede acudir a los
     comentarios en el código original en Fortran [2].

     Véanse también `lbfgs_nfeval_max' y `lbfgs_ncorrections'.

     Referencias:

     [1] D. Liu and J. Nocedal. "On the limited memory BFGS method for
     large scale optimization". Mathematical Programming B 45:503-528
     (1989)

     [2] `http://netlib.org/opt/lbfgs_um.shar'

     Ejemplos:

     La misma función objetivo utilizada por FGCOMPUTE en el programa
     sdrive.f del paquete LBFGS de Netlib. Nótese que las variables en
     cuestión están subindicadas. La función objetivo tiene un mínimo
     exacto igual a cero en u[k] = 1, para k = 1, ..., 8.
          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) t1[j] := 1 - u[j];
          (%o2)                     t1  := 1 - u
                                      j         j
          (%i3) t2[j] := 10*(u[j + 1] - u[j]^2);
                                                    2
          (%o3)                t2  := 10 (u      - u )
                                 j         j + 1    j
          (%i4) n : 8;
          (%o4)                           8
          (%i5) FOM : sum (t1[2*j - 1]^2 + t2[2*j - 1]^2, j, 1, n/2);
                           2 2           2              2 2           2
          (%o5) 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                      8    7           7           6    5           5
                               2 2           2              2 2           2
                  + 100 (u  - u )  + (1 - u )  + 100 (u  - u )  + (1 - u )
                          4    3           3           2    1           1
          (%i6) lbfgs (FOM, '[u[1],u[2],u[3],u[4],u[5],u[6],u[7],u[8]],
                 [-1.2, 1, -1.2, 1, -1.2, 1, -1.2, 1], 1e-3, [1, 0]);
          *************************************************
            N=    8   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  9.680000000000000D+01   GNORM=  4.657353755084532D+02
          *************************************************

           I NFN   FUNC                    GNORM                   STEPLENGTH

           1   3   1.651479526340304D+01   4.324359291335977D+00   7.926153934390631D-04
           2   4   1.650209316638371D+01   3.575788161060007D+00   1.000000000000000D+00
           3   5   1.645461701312851D+01   6.230869903601577D+00   1.000000000000000D+00
           4   6   1.636867301275588D+01   1.177589920974980D+01   1.000000000000000D+00
           5   7   1.612153014409201D+01   2.292797147151288D+01   1.000000000000000D+00
           6   8   1.569118407390628D+01   3.687447158775571D+01   1.000000000000000D+00
           7   9   1.510361958398942D+01   4.501931728123680D+01   1.000000000000000D+00
           8  10   1.391077875774294D+01   4.526061463810632D+01   1.000000000000000D+00
           9  11   1.165625686278198D+01   2.748348965356917D+01   1.000000000000000D+00
          10  12   9.859422687859137D+00   2.111494974231644D+01   1.000000000000000D+00
          11  13   7.815442521732281D+00   6.110762325766556D+00   1.000000000000000D+00
          12  15   7.346380905773160D+00   2.165281166714631D+01   1.285316401779533D-01
          13  16   6.330460634066370D+00   1.401220851762050D+01   1.000000000000000D+00
          14  17   5.238763939851439D+00   1.702473787613255D+01   1.000000000000000D+00
          15  18   3.754016790406701D+00   7.981845727704576D+00   1.000000000000000D+00
          16  20   3.001238402309352D+00   3.925482944716691D+00   2.333129631296807D-01
          17  22   2.794390709718290D+00   8.243329982546473D+00   2.503577283782332D-01
          18  23   2.563783562918759D+00   1.035413426521790D+01   1.000000000000000D+00
          19  24   2.019429976377856D+00   1.065187312346769D+01   1.000000000000000D+00
          20  25   1.428003167670903D+00   2.475962450826961D+00   1.000000000000000D+00
          21  27   1.197874264861340D+00   8.441707983493810D+00   4.303451060808756D-01
          22  28   9.023848941942773D-01   1.113189216635162D+01   1.000000000000000D+00
          23  29   5.508226405863770D-01   2.380830600326308D+00   1.000000000000000D+00
          24  31   3.902893258815567D-01   5.625595816584421D+00   4.834988416524465D-01
          25  32   3.207542206990315D-01   1.149444645416472D+01   1.000000000000000D+00
          26  33   1.874468266362791D-01   3.632482152880997D+00   1.000000000000000D+00
          27  34   9.575763380706598D-02   4.816497446154354D+00   1.000000000000000D+00
          28  35   4.085145107543406D-02   2.087009350166495D+00   1.000000000000000D+00
          29  36   1.931106001379290D-02   3.886818608498966D+00   1.000000000000000D+00
          30  37   6.894000721499670D-03   3.198505796342214D+00   1.000000000000000D+00
          31  38   1.443296033051864D-03   1.590265471025043D+00   1.000000000000000D+00
          32  39   1.571766603154336D-04   3.098257063980634D-01   1.000000000000000D+00
          33  40   1.288011776581970D-05   1.207784183577257D-02   1.000000000000000D+00
          34  41   1.806140173752971D-06   4.587890233385193D-02   1.000000000000000D+00
          35  42   1.769004645459358D-07   1.790537375052208D-02   1.000000000000000D+00
          36  43   3.312164100763217D-10   6.782068426119681D-04   1.000000000000000D+00


           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o6) [u  = 1.000005339815974, u  = 1.000009942839805,
                  1                       2
          u  = 1.000005339815974, u  = 1.000009942839805,
           3                       4
          u  = 1.000005339815974, u  = 1.000009942839805,
           5                       6
          u  = 1.000005339815974, u  = 1.000009942839805]
           7                       8

     Un problema de regresión. La función objetivo es el cuadrado medio
     de la diferencia entre la predicción F(X[i]) y el valor observado
     Y[i]. La función F es monótona y acotada (llamada en ocasiones
     "sigmoidal"). En este ejemplo, `lbfgs' calcula valores aproximados
     para los parámetros de F y `plot2d' hace una representación gráfica
     comparativa de F junto con los datos observados.

          (%i1) load (lbfgs);
          (%o1)   /usr/share/maxima/5.10.0cvs/share/lbfgs/lbfgs.mac
          (%i2) FOM : '((1/length(X))*sum((F(X[i]) - Y[i])^2, i, 1,
                                                          length(X)));
                                         2
                         sum((F(X ) - Y ) , i, 1, length(X))
                                 i     i
          (%o2)          -----------------------------------
                                      length(X)
          (%i3) X : [1, 2, 3, 4, 5];
          (%o3)                    [1, 2, 3, 4, 5]
          (%i4) Y : [0, 0.5, 1, 1.25, 1.5];
          (%o4)                [0, 0.5, 1, 1.25, 1.5]
          (%i5) F(x) := A/(1 + exp(-B*(x - C)));
                                             A
          (%o5)            F(x) := ----------------------
                                   1 + exp((- B) (x - C))
          (%i6) ''FOM;
                          A               2            A                2
          (%o6) ((----------------- - 1.5)  + (----------------- - 1.25)
                    - B (5 - C)                  - B (4 - C)
                  %e            + 1            %e            + 1
                      A             2            A               2
           + (----------------- - 1)  + (----------------- - 0.5)
                - B (3 - C)                - B (2 - C)
              %e            + 1          %e            + 1
                       2
                      A
           + --------------------)/5
                - B (1 - C)     2
             (%e            + 1)
          (%i7) estimates : lbfgs (FOM, '[A, B, C], [1, 1, 1], 1e-4, [1, 0]);
          *************************************************
            N=    3   NUMBER OF CORRECTIONS=25
                 INITIAL VALUES
           F=  1.348738534246918D-01   GNORM=  2.000215531936760D-01
          *************************************************

          I  NFN  FUNC                    GNORM                   STEPLENGTH
          1    3  1.177820636622582D-01   9.893138394953992D-02   8.554435968992371D-01
          2    6  2.302653892214013D-02   1.180098521565904D-01   2.100000000000000D+01
          3    8  1.496348495303005D-02   9.611201567691633D-02   5.257340567840707D-01
          4    9  7.900460841091139D-03   1.325041647391314D-02   1.000000000000000D+00
          5   10  7.314495451266917D-03   1.510670810312237D-02   1.000000000000000D+00
          6   11  6.750147275936680D-03   1.914964958023047D-02   1.000000000000000D+00
          7   12  5.850716021108205D-03   1.028089194579363D-02   1.000000000000000D+00
          8   13  5.778664230657791D-03   3.676866074530332D-04   1.000000000000000D+00
          9   14  5.777818823650782D-03   3.010740179797255D-04   1.000000000000000D+00


           THE MINIMIZATION TERMINATED WITHOUT DETECTING ERRORS.
           IFLAG = 0
          (%o7) [A = 1.461933911464101, B = 1.601593973254802,
                                                     C = 2.528933072164854]
          (%i8) plot2d ([F(x), [discrete, X, Y]], [x, -1, 6]), ''estimates;
          (%o8)


 -- Variable: lbfgs_nfeval_max
     Valor por defecto: 100

     La variable `lbfgs_nfeval_max' almacena el número máximo de
     evaluaciones de la función objetivo en `lbfgs'. Cuando se alcanza
     el valor `lbfgs_nfeval_max', `lbfgs' devuelve el resultado logrado
     en la última iteración exitosa.


 -- Variable: lbfgs_ncorrections
     Valor por defecto: 25

     La variable `lbfgs_ncorrections' almacena el número de correcciones
     aplicadas a la matriz inversa aproximada del hessiano, la cual es
     gestionada por `lbfgs'.



File: maxima.info,  Node: lindstedt,  Next: linearalgebra,  Prev: lbfgs,  Up: Top

59 lindstedt
************

* Menu:

* Funciones y variables para lindstedt::


File: maxima.info,  Node: Funciones y variables para lindstedt,  Prev: lindstedt,  Up: lindstedt

59.1 Funciones y variables para lindstedt
=========================================

 -- Función: Lindstedt (<eq>,<pvar>,<torder>,<ic>)
     Este es el primer paso hacia un programa para resolver ecuaciones
     de Lindstedt.  Puede resolver problemas con condiciones iniciales,
     las cuales pueden ser constantes arbitrarias (no pueden usarse
     <%k1> ni <%k2>) donde las condiciones iniciales sobre las
     ecuaciones de perturbación son z[i]=0, z'[i]=0 para i>0.  El
     argumento <ic> es la lista de condiciones iniciales.

     Ejemplo:
          (%i1) load("makeOrders")$

          (%i2) load("lindstedt")$

          (%i3) Lindstedt('diff(x,t,2)+x-(e*x^3)/6,e,2,[1,0]);
                    2
                   e  (cos(5 T) - 24 cos(3 T) + 23 cos(T))
          (%o3) [[[---------------------------------------
                                    36864
             e (cos(3 T) - cos(T))
           - --------------------- + cos(T)],
                      192
                    2
                 7 e    e
          T = (- ---- - -- + 1) t]]
                 3072   16

     Antes de hacer uso de esta función ejecútense
     `load("makeOrders")' y `load("lindstedt")'.


File: maxima.info,  Node: linearalgebra,  Next: lsquares,  Prev: lindstedt,  Up: Top

60 linearalgebra
****************

* Menu:

* Introducción a linearalgebra::
* Funciones y variables para linearalgebra::


File: maxima.info,  Node: Introducción a linearalgebra,  Next: Funciones y variables para linearalgebra,  Prev: linearalgebra,  Up: linearalgebra

60.1 Introducción a linearalgebra
=================================

El paquete `linearalgebra' contiene una batería de funciones para
álgebra lineal.

   Ejemplo:

     (%i1) M : matrix ([1, 2], [1, 2]);
                                 [ 1  2 ]
     (%o1)                       [      ]
                                 [ 1  2 ]
     (%i2) nullspace (M);
                                    [  1  ]
                                    [     ]
     (%o2)                     span([   1 ])
                                    [ - - ]
                                    [   2 ]
     (%i3) columnspace (M);
                                     [ 1 ]
     (%o3)                      span([   ])
                                     [ 1 ]
     (%i4) ptriangularize (M - z*ident(2), z);
                              [ 1   2 - z   ]
     (%o4)                    [             ]
                              [           2 ]
                              [ 0  3 z - z  ]
     (%i5) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                          [ 1 - z    2      3   ]
                          [                     ]
     (%o5)                [   4    5 - z    6   ]
                          [                     ]
                          [   7      8    9 - z ]
     (%i6) MM : ptriangularize (M, z);
                   [ 4  5 - z            6            ]
                   [                                  ]
                   [                2                 ]
                   [     66        z    102 z   132   ]
                   [ 0   --      - -- + ----- + ---   ]
     (%o6)         [     49        7     49     49    ]
                   [                                  ]
                   [               3        2         ]
                   [           49 z    245 z    147 z ]
                   [ 0    0    ----- - ------ - ----- ]
                   [            264      88      44   ]
     (%i7) algebraic : true;
     (%o7)                         true
     (%i8) tellrat (MM [3, 3]);
                              3       2
     (%o8)                  [z  - 15 z  - 18 z]
     (%i9) MM : ratsimp (MM);
                    [ 4  5 - z           6           ]
                    [                                ]
                    [                2               ]
     (%o9)          [     66      7 z  - 102 z - 132 ]
                    [ 0   --    - ------------------ ]
                    [     49              49         ]
                    [                                ]
                    [ 0    0             0           ]
     (%i10) nullspace (MM);
                             [        1         ]
                             [                  ]
                             [   2              ]
                             [  z  - 14 z - 16  ]
                             [  --------------  ]
     (%o10)             span([        8         ])
                             [                  ]
                             [    2             ]
                             [   z  - 18 z - 12 ]
                             [ - -------------- ]
                             [         12       ]
     (%i11) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8],
                        [9, 10, 11, 12], [13, 14, 15, 16]);
                            [ 1   2   3   4  ]
                            [                ]
                            [ 5   6   7   8  ]
     (%o11)                 [                ]
                            [ 9   10  11  12 ]
                            [                ]
                            [ 13  14  15  16 ]
     (%i12) columnspace (M);
                                [ 1  ]  [ 2  ]
                                [    ]  [    ]
                                [ 5  ]  [ 6  ]
     (%o12)                span([    ], [    ])
                                [ 9  ]  [ 10 ]
                                [    ]  [    ]
                                [ 13 ]  [ 14 ]
     (%i13) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                                [ 0 ]  [  1  ]
                                [   ]  [     ]
                                [ 1 ]  [  0  ]
     (%o13)                span([   ], [     ])
                                [ 2 ]  [ - 1 ]
                                [   ]  [     ]
                                [ 3 ]  [ - 2 ]


File: maxima.info,  Node: Funciones y variables para linearalgebra,  Prev: Introducción a linearalgebra,  Up: linearalgebra

60.2 Funciones y variables para linearalgebra
=============================================

 -- Función: addmatrices (<f>, <M_1>, ..., <M_n>)
     Utiliza la función <f> como una función aditiva, devolviendo la
     suma de las matrices <M_1>, ..., <M_n>. La función <f> debe ser
     tal que acepte un número arbitrario de argumentos; en otras
     palabras, será una función n-aria de Maxima.

     Ejemplos:

          (%i1) m1 : matrix([1,2],[3,4])$
          (%i2) m2 : matrix([7,8],[9,10])$
          (%i3) addmatrices('max,m1,m2);
          (%o3) matrix([7,8],[9,10])
          (%i4) addmatrices('max,m1,m2,5*m1);
          (%o4) matrix([7,10],[15,20])


 -- Función: blockmatrixp (<M>)
     Devuelve el valor `true' si y solo si <M> es una matriz cuyos
     elementos son a su vez matrices.


 -- Función: columnop (<M>, <i>, <j>, <theta>)
     Si <M> es una matriz, devuelve la matriz que resulta de hacer la
     operación columna `C_i <- C_i - <theta> * C_j'. Si <M> carece de
     cualquiera de las filas <i> o <j>, devuelve un mensaje de error.


 -- Función: columnswap (<M>, <i>, <j>)
     Si <M> es una matriz, intercambia las columnas <i> y <j>.  Si <M>
     carece de cualquiera de las filas <i> o <j>, devuelve un mensaje
     de error.


 -- Función: columnspace (<M>)
     Si <M> es una matriz, devuelve `span (v_1, ..., v_n)', donde el
     conjunto `{v_1, ..., v_n}' es la base del espacio generado por las
     columnas de <M>.


 -- Función: copy (<e>)
     Devuelve una copia de la expresión <e> de Maxima. Aunque <e> puede
     ser cualquier expresión de Maxima, la función `copy' es
     especialmente útil cuando <e> es una lista o una matriz.
     Considérese el siguiente ejemplo:
          (%i1) m : [1,[2,3]]$
          (%i2) mm : m$
          (%i3) mm[2][1] : x$
          (%i4) m;
          (%o4)                      [1,[x,3]]
          (%i5) mm;
          (%o5)                      [1,[x,3]]
     Veamos el mismo ejemplo siendo ahora <mm> una copia de <m>
          (%i6) m : [1,[2,3]]$
          (%i7) mm : copy(m)$
          (%i8) mm[2][1] : x$
          (%i9) m;
          (%o9)                     [1,[2,3]]
          (%i10) mm;
          (%o10)                    [1,[x,3]]
     En esta ocasión, la asignación a <mm> no cambia el valor de <m>.


 -- Función: cholesky (<M>)
 -- Función: cholesky (<M>, <field>)
     Devuelve la factorización de Cholesky de la matriz autoadjunta (o
     hermítica) <M>. El valor por defecto del segundo argumento es
     <generalring>. Para una descripción de los posibles valores para
     <field>, véase `lu_factor'.


 -- Función: ctranspose (<M>)
     Devuelve la transpuesta compleja conjugada de la matriz <M>. La
     función `ctranspose' utiliza `matrix_element_transpose' para
     transponer cada elemento de la matriz.


 -- Función: diag_matrix (<d_1>, <d_2>,...,<d_n>)
     Devuelve una matriz diagonal con los elementos de la diagonal
     iguales a <d_1>, <d_2>,...,<d_n>; cuando éstos son matrices, los
     elementos nulos de la matriz devuelta son matrices nulas de tamaño
     apropiado. Por ejemplo:
          (%i1) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                                      [ [ 1  0 ]  [ 0  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  2 ]  [ 0  0 ] ]
          (%o1)                       [                    ]
                                      [ [ 0  0 ]  [ 3  0 ] ]
                                      [ [      ]  [      ] ]
                                      [ [ 0  0 ]  [ 0  4 ] ]
          (%i2) diag_matrix(p,q);

                                             [ p  0 ]
          (%o2)                              [      ]
                                             [ 0  q ]

 -- Función: dotproduct (<u>, <v>)
     Devuelve el producto escalar de los vectores <u> y <v>. Equivale a
     `conjugate (transpose (<u>)) . <v>'. Los argumentos <u> y <v>
     deben ser vectores columna.


 -- Función: eigens_by_jacobi (<A>)
 -- Función: eigens_by_jacobi (<A>, <field_type>)
     Calcula los valores y vectores propios de <A> por el método de las
     rotaciones de Jacobi. <A> debe ser una matriz simétrica (aunque no
     necesariamente definida o semidefinida positiva).  El argumento
     <field_type> indica el tipo numérico sobre el que se realizan los
     cálculos, que puede ser tanto `floatfield' como `bigfloatfield'.
     En caso de que no se especifique <field_type>, su valor por
     defecto será `floatfield'.

     Los elementos de <A> deben ser números o expresiones reducibles a
     números mediante la ejecución de `float' o `bfloat', según sea el
     valor de <field_type>.

     Ejemplos:

          (%i1) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                               [     1         1    ]
                               [  -------   ------- ]
                               [  sqrt(2)   sqrt(2) ]
          (%o1)                [                    ]
                               [      1        1    ]
                               [ - -------  ------- ]
                               [   sqrt(2)  sqrt(2) ]
          (%i2) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                                [ sqrt(3)     0    ]
          (%o2)                 [                  ]
                                [    0     sqrt(5) ]
          (%i3) M : S . L . transpose (S);
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- + -------  ------- - ------- ]
                      [    2         2        2         2    ]
          (%o3)       [                                      ]
                      [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
                      [ ------- - -------  ------- + ------- ]
                      [    2         2        2         2    ]
          (%i4) eigens_by_jacobi (M);
          The largest percent change was 0.1454972243679
          The largest percent change was 0.0
          number of sweeps: 2
          number of rotations: 1
          (%o4) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i5) float ([[sqrt(3), sqrt(5)], S]);
          (%o5) [[1.732050807568877, 2.23606797749979],
                                  [  0.70710678118655   0.70710678118655 ]
                                  [                                      ]]
                                  [ - 0.70710678118655  0.70710678118655 ]
          (%i6) eigens_by_jacobi (M, bigfloatfield);
          The largest percent change was 1.454972243679028b-1
          The largest percent change was 0.0b0
          number of sweeps: 2
          number of rotations: 1
          (%o6) [[1.732050807568877b0, 2.23606797749979b0],
                          [  7.071067811865475b-1   7.071067811865475b-1 ]
                          [                                              ]]
                          [ - 7.071067811865475b-1  7.071067811865475b-1 ]


 -- Función: get_lu_factors (<x>)
     Cuando `<x> = lu_factor (<A>)', entonces `get_lu_factors' devuelve
     una lista de la forma `[P, L, U]', donde <P> es una matriz
     permutación, <L> es triangular inferior con unos en la diagonal y
     <U> es triangular superior, verificándose que `<A> = <P> <L> <U>'.


 -- Función: hankel (<col>)
 -- Función: hankel (<col>, <row>)
     Devuelve la matriz de Hankel <H>. La primera columna de <H>
     coincide con <col>, excepto en el primer elemento, la última fila
     de <H> es <row>. El valor por defecto para <row> es el vector nulo
     con igual número de elementos que <col>.


 -- Función: hessian (<f>, <x>)
     Devuelve la matriz hessiana de <f> con respecto de la lista de
     variables <x>. El elemento `(i, j)'-ésimo de la matriz hessiana es
     `diff(<f>, <x>[i], 1, <x>[j], 1)'.

     Ejemplos:

          (%i1) hessian (x * sin (y), [x, y]);
                               [   0       cos(y)   ]
          (%o1)                [                    ]
                               [ cos(y)  - x sin(y) ]
          (%i2) depends (F, [a, b]);
          (%o2)                       [F(a, b)]
          (%i3) hessian (F, [a, b]);
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [  ---   ----- ]
                                  [    2   da db ]
                                  [  da          ]
          (%o3)                   [              ]
                                  [   2      2   ]
                                  [  d F    d F  ]
                                  [ -----   ---  ]
                                  [ da db     2  ]
                                  [         db   ]

 -- Función: hilbert_matrix (<n>)
     Devuelve la matriz de Hilbert <n> por <n>. Si <n> no es un entero
     positivo, emite un mensaje de error.


 -- Función: identfor (<M>)
 -- Función: identfor (<M>, <fld>)
     Devuelve una matriz identidad con la misma forma que la matriz
     <M>. Los elementos de la diagonal de la matriz identidad son la
     identidad multiplicativa del campo <fld>; el valor por defecto
     para <fld> es <generalring>.

     El primer argumento <M> debe ser una matriz cuadrada o no ser
     matriz en absoluto. Si <M> es una matriz, sus elementos pueden ser
     matrices cuadradas. La matriz puede tener bloques a cualquier nivel
     finito de profundidad.

     Véase también `zerofor'


 -- Función: invert_by_lu (<M>, <(rng generalring)>)
     Invierte la matriz <M> mediante la factorización LU, la cual se
     hace utilizando el anillo <rng>.


 -- Función: jacobian (<f>, <x>)
     Devuelve la matriz jacobiana de la lista de funciones <f> respecto
     de la lista de variables <x>. El elemento `(i, j)'-ésimo de la
     matriz jacobiana es `diff(<f>[i], <x>[j])'.

     Ejemplos:

          (%i1) jacobian ([sin (u - v), sin (u * v)], [u, v]);
                            [ cos(v - u)  - cos(v - u) ]
          (%o1)             [                          ]
                            [ v cos(u v)   u cos(u v)  ]
          (%i2) depends ([F, G], [y, z]);
          (%o2)                  [F(y, z), G(y, z)]
          (%i3) jacobian ([F, G], [y, z]);
                                     [ dF  dF ]
                                     [ --  -- ]
                                     [ dy  dz ]
          (%o3)                      [        ]
                                     [ dG  dG ]
                                     [ --  -- ]
                                     [ dy  dz ]

 -- Función: kronecker_product (<A>, <B>)
     Devuelve el producto de Kroneckerde las matrices <A> y <B>.


 -- Función: listp (<e>, <p>)
 -- Función: listp (<e>)
     Dado el argumento opcional <p>, devuelve `true' si <e> es una
     lista de Maxima y <p> toma el valor `true' al aplicarlo a cada
     elemento de la lista. Si a `listp' no se le suministra el
     argumento opcional, devuelve `true' si <e> es una lista de Maxima.
     En cualquier otro caso, el resultado es `false'.


 -- Función: locate_matrix_entry (<M>, <r_1>, <c_1>, <r_2>, <c_2>, <f>,
          <rel>)
     El primer argumento debe ser una matriz, mientras que los
     argumentos desde <r_1> hasta <c_2> determinan la submatriz de <M>
     tomando las filas desde <r_1> hasta <r_2> y las columnas desde
     <c_1> hasta <c_2>.

     La función `locate_matrix_entry' busca en la submatriz de <M> un
     elemento que satisfaga cierta propiedad. hay tres posibilidades:

     (1) `<rel> = 'bool' y <f> es un predicado:

     Rastrea la submatriz de izquierda a derecha y de arriba hacia
     abajo, devolviendo el índice del primer elemento que satisface el
     predicado <f>; si ningún elemento lo satisface, el resultado es
     `false'.

     (2) `<rel> = 'max' y <f> una función real:

     Rastrea la submatriz buscando el elemento que maximice <f>,
     devolviendo el índice correspondiente.

     (3) `<rel> = 'min' y <f> una función real:

     Rastrea la submatriz buscando el elemento que minimice <f>,
     devolviendo el índice correspondiente.


 -- Función: lu_backsub (<M>, <b>)
     Si `<M> = lu_factor (<A>, <field>)', entonces `lu_backsub (<M>,
     <b>)' resuelve el sistema de ecuaciones lineales `<A> <x> = <b>'.


 -- Función: lu_factor (<M>, <field>)
     Devuelve una lista de la forma `[<LU>, <perm>, <fld>]', o `[<LU>,
     <perm>, <fld>, <lower-cnd> <upper-cnd>]', donde

        * La matriz <LU> contiene la factorización de <M> de forma
          empaquetada, lo que significa tres cosas. En primer lugar,
          que las filas de <LU> están permutadas de acuerdo con la
          lista <perm>; por ejemplo, si <perm> es la lista `[3,2,1]',
          la primera fila de la factorización <LU> es la tercera fila
          de la matriz <LU>.  En segundo lugar, el factor triangular
          inferior de <M> es la parte triangular inferior de <LU> con
          los elementos de la diagonal sustituidos por unos. Por
          último, el factor triangular superior de <M> es la parte
          triangular superior de <LU>.

        * Si el campo es `floatfield' o `complexfield', los números
          <lower-cnd> y <upper-cnd> son las cotas inferior y superior
          del número de condición de la norma infinita de <M>. El
          número de condición no se puede estimar para todos los campos,
          en cuyo caso `lu_factor' devuelve una lista de dos elementos.
          Tanto la cota inferior como la superior pueden diferir de sus
          valores verdaderos. Véase también `mat_cond'.


     El argumento <M> debe ser una matriz cuadrada.

     El argumento opcional <fld> debe ser un símbolo que determine un
     anillo o un campo. Los anillos y campos predefinidos son:

       a. `generalring' - el anillo de las expresiones de Maxima

       b. `floatfield' - el campo de los números decimales en coma
          flotante de doble precisión

       c. `complexfield' - el campo de los números complejos decimales
          en coma flotante de doble precisión

       d. `crering'  - el anillo de las expresiones canónicas
          racionales (Canonical Rational Expression o CRE) de Maxima

       e. `rationalfield' - el campo de los números racionales

       f. `runningerror' - controla los errores de redondeo de las
          operaciones en coma flotante

       g. `noncommutingring' - el anillo de las expresiones de Maxima
          en las que el producto es el operador no conmutativo "."


     Si el campo es `floatfield', `complexfield' o `runningerror', el
     algoritmo utiliza pivoteo parcial; para los demás campos, las
     filas se cambian cuando se necesita evitar pivotes nulos.

     La suma aritmética en coma flotante no es asociativa, por lo que el
     significado de 'campo' no coincide exactamente con su definición
     matemática.

     Un elemento del campo `runningerror' consiste en una lista de
     Maxima de la forma `[x,n]', donde <x> es un número decimal en coma
     flotante y `n' un enetro. La diferencia relativa entre el valor
     real de `x' y `x' está aproximadamente acotado por el valor
     epsilon de la máquina multiplicado por `n'.

     No es posible la definición de un nuevo campo por parte del
     usuario, a menos que éste tenga conocimientos de Common Lisp. Para
     hacerlo, el usuario debe definir funciones para las operaciones
     aritméticas y para convertir de la representación del campo a
     Maxima y al revés. Además, en los campos ordenados, donde se hace
     uso del pivoteo parcial, el usuario debe definir funciones para el
     módulo y para comparar números del campo. Después de lo anterior,
     tan solo queda definir una estructura Common Lisp `mring'. El
     fichero `mring' tiene muchos ejemplos.

     Para calcular la factorización, la primera tarea consiste en
     convertir cada elemento de la matriz a un elemento del campo
     especificado. Si la conversión no es posible, la factorización se
     detiene con un mensaje de error. Los elementos del campo no
     necesitan ser expresiones de Maxima; por ejemplo, los elementos de
     `complexfield' son números complejos de Common Lisp. Tras la
     factorización, los elementos de la matriz deben convertirse
     nuevamente a expresiones de Maxima.

     Véase también  `get_lu_factors'.

     Ejemplos:

          (%i1) w[i,j] := random (1.0) + %i * random (1.0);
          (%o1)          w     := random(1.) + %i random(1.)
                          i, j
          (%i2) showtime : true$
          Evaluation took 0.00 seconds (0.00 elapsed)
          (%i3) M : genmatrix (w, 100, 100)$
          Evaluation took 7.40 seconds (8.23 elapsed)
          (%i4) lu_factor (M, complexfield)$
          Evaluation took 28.71 seconds (35.00 elapsed)
          (%i5) lu_factor (M, generalring)$
          Evaluation took 109.24 seconds (152.10 elapsed)
          (%i6) showtime : false$

          (%i7) M : matrix ([1 - z, 3], [3, 8 - z]);
                                  [ 1 - z    3   ]
          (%o7)                   [              ]
                                  [   3    8 - z ]
          (%i8) lu_factor (M, generalring);
                    [ 1 - z         3        ]
                    [                        ]
          (%o8)    [[   3            9       ], [1, 2], generalring]
                    [ -----  - z - ----- + 8 ]
                    [ 1 - z        1 - z     ]
          (%i9) get_lu_factors (%);
                            [   1    0 ]  [ 1 - z         3        ]
                  [ 1  0 ]  [          ]  [                        ]
          (%o9)  [[      ], [   3      ], [                9       ]]
                  [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                            [ 1 - z    ]  [              1 - z     ]
          (%i10) %[1] . %[2] . %[3];
                                  [ 1 - z    3   ]
          (%o10)                  [              ]
                                  [   3    8 - z ]


 -- Función: mat_cond (<M>, 1)
 -- Función: mat_cond (<M>, inf)
     Devuelve el número de condición de la <p>-norma de la matriz <M>.
     Los valores admisibles para  <p> son 1 y <inf>. Esta función
     utiliza la factorización LU para invertir la matriz <M>, por lo
     que el tiempo de ejecución de `mat_cond' es proporcional al cubo
     del tamaño de la matriz; `lu_factor' determina las cotas inferior
     y superior para el número de condición de la norma infinita en un
     tiempo proporcional al cuadrado del tamaño de la matriz.


 -- Función: mat_norm (<M>, 1)
 -- Función: mat_norm (<M>, inf)
 -- Función: mat_norm (<M>, frobenius)
     Devuelve la <p>-norma de la matriz <M>. Los valores admisibles
     para <p> son 1, `inf' y `frobenius' (la norma matricial de
     Frobenius).  La matriz <M> no debe contener bloques.

 -- Función: matrixp (<e>, <p>)
 -- Función: matrixp (<e>)
     Dado el argumento opcional <p>, devuelve `true' si <e> es una
     matriz y <p> toma el valor `true' al aplicarlo a cada elemento de
     la matriz. Si a `matrixp' no se le suministra el argumento
     opcional, devuelve `true' si <e> es una matriz.  En cualquier otro
     caso, el resultado es `false'.

     Véase también `blockmatrixp'


 -- Función: matrix_size (<M>)
     Devuelve una lista con el número de filas y columnas de la matriz
     <M>.


 -- Función: mat_fullunblocker (<M>)
     Si <M> es una matriz de bloques, transforma la matriz llevando
     todos los elementos de los bloques al primer nivel. Si <M> es una
     matriz, devuelve <M>; en cualquier otro caso, envía un mensaje de
     error.


 -- Función: mat_trace (<M>)
     Calcula la traza de la matriz <M>. Si <M> no es una matriz,
     devuelve una forma nominal. Si <M> es una matriz de bloques,
     `mat_trace(M)' calcula el mismo valor que
     `mat_trace(mat_unblocker(m))'.


 -- Función: mat_unblocker (<M>)
     Si <M> es una matriz de bloques, deshace los bloques de un nivel.
     Si <M> es una matriz, `mat_unblocker (M)' devuelve <M>; en
     cualquier otro caso, envía un mensaje de error.

     Si todos los elementos de <M> son matrices, `mat_unblocker (M)'
     devuelve una matriz sin bloques, pero si los elementos de <M> son
     a su vez matrices de bloques, `mat_unblocker (M)' devuelve una
     matriz con el nivel de bloques disminuido en uno.

     En caso de trabajar con matrices de bloques, quizás sea
     conveniente darle a `matrix_element_mult' el valor `"."' y a
     `matrix_element_transpose' el valor `'transpose'. Véase también
     `mat_fullunblocker'.

     Ejemplo:

          (%i1) A : matrix ([1, 2], [3, 4]);
                                      [ 1  2 ]
          (%o1)                       [      ]
                                      [ 3  4 ]
          (%i2) B : matrix ([7, 8], [9, 10]);
                                      [ 7  8  ]
          (%o2)                       [       ]
                                      [ 9  10 ]
          (%i3) matrix ([A, B]);
                               [ [ 1  2 ]  [ 7  8  ] ]
          (%o3)                [ [      ]  [       ] ]
                               [ [ 3  4 ]  [ 9  10 ] ]
          (%i4) mat_unblocker (%);
                                   [ 1  2  7  8  ]
          (%o4)                    [             ]
                                   [ 3  4  9  10 ]


 -- Función: nonnegintegerp (<n>)
     Devuelve `true' si y solo si `<n> >= 0', siendo <n> un entero.


 -- Función: nullspace (<M>)
     Si <M> es una matriz, devuelve `span (v_1, ..., v_n)', siendo
     `{v_1, ..., v_n}' la base del espacio nulo de <M>. Si el espacio
     nulo contiene un único elemento, devuelve `span ()'.


 -- Función: nullity (<M>)
     Si <M> es una matriz, devuelve la dimensión del espacio nulo de
     <M>.


 -- Función: orthogonal_complement (<v_1>, ..., <v_n>)
     Devuelve `span (u_1, ..., u_m)', siendo `{u_1, ..., u_m}' la base
     del complemento ortogonal del conjunto `(v_1, ..., v_n)', cuyos
     elementos deben ser vectores columna.


 -- Función: polynomialp (<p>, <L>, <coeffp>, <exponp>)
 -- Función: polynomialp (<p>, <L>, <coeffp>)
 -- Función: polynomialp (<p>, <L>)
     Devuelve `true' si <p> es un polinomio cuyas variables son las de
     la lista <L>, el predicado <coeffp> toma el valor `true' al
     aplicarlo a cada coeficiente y el predicado <exponp> también
     alcanza el valor `true' al ser aplicado a los exponentes de las
     variables listadas en <L>. En caso de necesitar que <exponp> no
     sea un predicado por defecto, se deberá especificar también el
     predicado <coeffp>, aunque aquí se desee su comportamiento por
     defecto.

     `polynomialp (<p>, <L>, <coeffp>)' equivale a `polynomialp (<p>,
     <L>, <coeffp>, 'nonnegintegerp)'.

     `polynomialp (<p>, <L>)' equivale a `polynomialp (<p>, L<,>
     'constantp, 'nonnegintegerp)'.

     No es necesario expandir el polinomio:

          (%i1) polynomialp ((x + 1)*(x + 2), [x]);
          (%o1)                         true
          (%i2) polynomialp ((x + 1)*(x + 2)^a, [x]);
          (%o2)                         false

     Un ejemplo utilizando valores distintos a los utilizados por
     defecto en <coeffp> y en <exponp>:

          (%i1) polynomialp ((x + 1)*(x + 2)^(3/2), [x],
                             numberp, numberp);
          (%o1)                         true
          (%i2) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x],
                             numberp, numberp);
          (%o2)                         true

     Polinomios con dos variables:

          (%i1) polynomialp (x^2 + 5*x*y + y^2, [x]);
          (%o1)                         false
          (%i2) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
          (%o2)                         true


 -- Función: polytocompanion (<p>, <x>)
     Si <p> es un polinomio en <x>, devuelve la matriz compañera de
     <p>. Para un polinomio mónico <p> de grado <n> se tiene `<p> =
     (-1)^<n> charpoly (polytocompanion (<p>, <x>))'.

     Si <p> no es un polinomio en  <x>, se devuelve un mensaje de error.


 -- Función: ptriangularize (<M>, <v>)
     Si <M> es una matriz en la que sus elementos son polinomios en <v>,
     devuelve una matriz <M2> tal que

       1. <M2> es triangular superior,

       2. `<M2> = <E_n> ... <E_1> <M>', donde <E_1>, ..., <E_n> son
          matrices elementales cuyos elementos son polinomios en <v>,

       3. `|det (<M>)| = |det (<M2>)|',

     Nota: esta función no comprueba si los elementos de la matriz son
     polinomios en <v>.

 -- Función: rowop (<M>, <i>, <j>, <theta>)
     Si <M> es una matriz, devuelve la matriz que resulta de relizar la
     transformación `R_i <- R_i - theta * R_j' con las filas `R_i' y
     `R_j'. Si <M> no tiene estas filas, devuelve un mensaje de error.


 -- Función: rank (<M>)
     Calcula el rango de la matriz <M>. El rango es la dimensión del
     espacio columna. Ejemplo:
          (%i1) rank(matrix([1,2],[2,4]));
          (%o1)                                  1
          (%i2) rank(matrix([1,b],[c,d]));
          Proviso:  {d - b c # 0}
          (%o2)                                  2


 -- Función: rowswap (<M>, <i>, <j>)
     Si <M> es una matriz, intercambia las filas  <i> y <j>. Si <M>
     carece de estas filas, devuelve un mensaje de error.


 -- Función: toeplitz (<col>)
 -- Función: toeplitz (<col>, <row>)
     Devuelve una  matriz de Toeplitz <T>. La primera columna de <T> es
     <col>, excepto su primer elemento. La primera fila de <T> es
     <row>. El valor por defecto para <row> es el complejo conjugado de
     <col>. Ejemplo:
          (%i1)  toeplitz([1,2,3],[x,y,z]);

                                            [ 1  y  z ]
                                            [         ]
          (%o1)                             [ 2  1  y ]
                                            [         ]
                                            [ 3  2  1 ]
          (%i2)  toeplitz([1,1+%i]);

                                        [   1     1 - %I ]
          (%o2)                         [                ]
                                        [ %I + 1    1    ]


 -- Función: vandermonde_matrix ([<x_1>, ..., <x_n>])
     Devuelve una matriz <n> por <n>, cuya <i>-ésima fila es `[1,
     <x_i>, <x_i>^2, ... <x_i>^(<n>-1)]'.


 -- Función: zerofor (<M>)
 -- Función: zerofor (<M>, <fld>)
     Devuelve la matriz nula con la misma estructura que la matriz <M>.
     Cada elemento de la matriz nula es la identidad aditiva del campo
     <fld>; el valor por defecto de <fld> es <generalring>.

     El primer argumento de <M> debe ser una matriz cuadrada o no ser
     matriz en absoluto. Si <M> es una matriz, cada uno de sus
     elementos puede ser una matriz cuadrada, por lo que <M> puede ser
     una matriz de Maxima definida por bloques.

     Véase también `identfor'.


 -- Función: zeromatrixp (<M>)
     Si <M> no es una matriz definida por bloques, devuelve `true' si
     `is (equal (<e>, 0))' es verdadero para todo elemento <e> de <M>.
     Si <M> es una matriz por bloques, devuelve `true' si `zeromatrixp'
     devuelve a su vez `true' para cada elemento de <e>.



File: maxima.info,  Node: lsquares,  Next: makeOrders,  Prev: linearalgebra,  Up: Top

61 lsquares
***********

* Menu:

* Funciones y variables para lsquares::


File: maxima.info,  Node: Funciones y variables para lsquares,  Prev: lsquares,  Up: lsquares

61.1 Funciones y variables para lsquares
========================================

 -- Función: lsquares_estimates (<D>, <x>, <e>, <a>)
 -- Función: lsquares_estimates (<D>, <x>, <e>, <a>, initial = <L>, tol
          = <t>)
     Estima los parámetros <a> que mejor se ajusten a la ecuación <e>
     de variables <x> y <a> a los datos <D> por el método de los
     mínimos cuadrados. La función `lsquares_estimates' busca primero
     una solución exacta, y si no la encuentra, buscará una aproximada.

     El resultado es una lista de listas de ecuaciones de la forma `[a
     = ..., b = ..., c = ...]'. Cada elemento de la lista es un mínimo
     diferente de error cuadrático medio.

     Los datos deben darse en formato matricial. Cada fila es un dato
     (el cual suele denominarse `registro' o `caso' en ciertos
     contextos), y las columnas contienen los valores para cada una de
     las variables. La lista de variables <x> asigna un nombre a cada
     una de las columnas de <D>, incluso a aquellas que no intervienen
     en el análisis. La lista <a> asigna nombres a los parámetros cuyas
     estimaciones se buscan. El argumento <e> es una expresión o
     ecuación de variables <x> y <a>; si <e> no es una ecuación (es
     decir, carece de igualdad), se trata como si fuese  `<e> = 0'.

     Se pueden dar argumentos adicionales a `lsquares_estimates' en
     forma de ecuaciones, las cuales se pasan tal cual a la función
     `lbfgs', que es la que se encarga de calcular las estimaciones por
     el método numérico cuando no encuentra una solución exacta.

     Cuando se pueda encontrar una solución exacta, mediante `solve',
     los datos en <D> pueden contener valores no numéricos. Sin
     embargo, cuando no exista solución exacta, todos los elementos de
     <D> deben ser necesariamente numéricos, lo cual incluye constantes
     numéricas tales como `%pi' o `%e' y números literales (enteros,
     racionales y decimales en coma flotante, tanto los de doble
     precisión como los de precisión arbitraria).  Los cálculos
     numéricos se realizan en doble precisión con aritmética de punto
     flotante, por lo que números de cualesquiera otro tipo son
     convenientemente convertidos antes de proceder con los cálculos.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Véanse también `lsquares_estimates_exact',
     `lsquares_estimates_approximate', `lsquares_mse',
     `lsquares_residuals' y `lsquares_residual_mse'.

     Ejemplos:

     Un problema con solución exacta.

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                  [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) lsquares_estimates (
                   M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32

     un problema para el que no se encuentra solución exacta, por lo
     que `lsquares_estimates' recurre a la aproximación numérica.

          (%i1) load (lsquares)$
          (%i2) M : matrix ([1, 1], [2, 7/4], [3, 11/4], [4, 13/4]);
                                             [ 1  1  ]
                                             [       ]
                                             [    7  ]
                                             [ 2  -  ]
                                             [    4  ]
                                             [       ]
          (%o2)                              [    11 ]
                                             [ 3  -- ]
                                             [    4  ]
                                             [       ]
                                             [    13 ]
                                             [ 4  -- ]
                                             [    4  ]
          (%i3) lsquares_estimates (
            M, [x,y], y=a*x^b+c, [a,b,c], initial=[3,3,3], iprint=[-1,0]);
          (%o3) [[a = 1.387365874920637, b = .7110956639593767,
                                                  c = - .4142705622439105]]


 -- Función: lsquares_estimates_exact (<MSE>, <a>)
     Estima los valores de los parámetros <a> que minimizan el error
     cuadrático medio <MSE> mediante un sistema de ecuaciones que
     intentará resolver simbólicamente con `solve'. El error cuadrático
     medio es una expresión con parámetros <a>, como los devueltos por
     `lsquares_mse'.

     El valor devuelto por la función es una lista de listas de
     ecuaciones de la forma `[a = ..., b = ..., c = ...]'. El resultado
     puede contener cero, uno o más elementos. Cuando la respuesta
     contiene más de una solución, todas ellas representan mínimos del
     error cuadrático medio.

     Véanse también `lsquares_estimates',
     `lsquares_estimates_approximate', `lsquares_mse',
     `lsquares_residuals' y `lsquares_residual_mse'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_exact (mse, [A, B, C, D]);
                            59        27      10921        107
          (%o4)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32


 -- Función: lsquares_estimates_approximate (<MSE>, <a>, initial = <L>,
          tol = <t>)
     Estima los valores de los parámetros <a> que minimizan el error
     cuadrático medio <MSE> mediante el algoritmo numérico `lbfgs'.  El
     error cuadrático medio es una expresión con parámetros <a>, como
     los devueltos por `lsquares_mse'.

     La solución devuelta por la función es un mínimo local
     (posiblemente global) del error cuadrático medio.

     Por consistencia con `lsquares_estimates_exact', el valor devuelto
     es una lista anidada con un único elemento, consistente en una
     lista de ecuaciones de la forma `[a = ..., b = ..., c = ...]'.

     Los argumentos adicionales de `lsquares_estimates_approximate' se
     especifican como ecuaciones y se pasan de esta forma a la función
     `lbfgs'.

     <MSE> debe devolver un número cuando a sus parámetros se les
     asignen valores numéricos, lo cual implica que los datos a partir
     de los cuales se ha generado <MSE> contengan únicamente constantes
     numéricas tales como `%pi' o `%e' y números literales (enteros,
     racionales y decimales en coma flotante, tanto los de doble
     precisión como los de precisión arbitraria).  Los cálculos
     numéricos se realizan en doble precisión con aritmética de punto
     flotante, por lo que números de cualesquiera otro tipo son
     convenientemente convertidos antes de proceder con los cálculos.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Véanse también `lsquares_estimates', `lsquares_estimates_exact',
     `lsquares_mse', `lsquares_residuals' y `lsquares_residual_mse'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) lsquares_estimates_approximate (
                        mse, [A, B, C, D], iprint = [-1, 0]);
          (%o4) [[A = - 3.67850494740174, B = - 1.683070351177813,
                           C = 10.63469950148635, D = - 3.340357993175206]]


 -- Función: lsquares_mse (<D>, <x>, <e>)
     Devuelve el error medio cuadrático (MSE) para la ecuación <e> de
     variables <x> respecto de los datos <D>. El resultado devuelto es
     una suma, definida como

                              n
                             ====
                             \                        2
                              >    (lhs(e ) - rhs(e ))
                             /           i         i
                             ====
                             i = 1
                             --------------------------
                                         n

     siendo <n> el número de datos y `<e>[i]' es la ecuación <e>
     evaluada cuando a sus variables <x> se le asignan los valores
     asociados al dato `i'-ésimo `<D>[i]'.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) mse : lsquares_mse (M, [z, x, y], (z + D)^2 = A*x + B*y + C);
                     5
                    ====
                    \                 2                         2
                     >    ((D + M    )  - C - M     B - M     A)
                    /            i, 1          i, 3      i, 2
                    ====
                    i = 1
          (%o3)     ---------------------------------------------
                                          5
          (%i4) diff (mse, D);
                   5
                  ====
                  \                             2
                4  >    (D + M    ) ((D + M    )  - C - M     B - M     A)
                  /           i, 1         i, 1          i, 3      i, 2
                  ====
                  i = 1
          (%o4) ----------------------------------------------------------
                                            5
          (%i5) ''mse, nouns;
                         2                 2         9 2               2
          (%o5) (((D + 3)  - C - 2 B - 2 A)  + ((D + -)  - C - B - 2 A)
                                                     4
                     2               2         3 2               2
           + ((D + 2)  - C - B - 2 A)  + ((D + -)  - C - 2 B - A)
                                               2
                     2             2
           + ((D + 1)  - C - B - A) )/5


 -- Función: lsquares_residuals (<D>, <x>, <e>, <a>)
     Devuelve los residuos para la ecuación <e> de parámetros <a> y
     datos <D>.

     <D> es una matriz, <x> una lista de variables y <e> es una ecuación
     o expresión general; si <e> no es una ecuación (es decir, carece
     de igualdad), se trata como si fuese  `<e> = 0'. La lista <a>
     contiene ecuaciones que especifican valores para cualesquiera
     parámetros de <e> que no estén en <x>.

     Los residuos se definen como

                                  lhs(e ) - rhs(e )
                                       i         i

     siendo `<e>[i]' la ecuación <e> evaluada cuando las variables <x>
     toman los valores asociados al dato `i'-ésimo `<D>[i]', y haciendo
     las asignaciones indicadas en <a> al resto de variables.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                            [ 1  1  1 ]
                                            [         ]
                                            [ 3       ]
                                            [ -  1  2 ]
                                            [ 2       ]
                                            [         ]
          (%o2)                             [ 9       ]
                                            [ -  2  1 ]
                                            [ 4       ]
                                            [         ]
                                            [ 3  2  2 ]
                                            [         ]
                                            [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);
                                   59        27      10921        107
          (%o3)            [[A = - --, B = - --, C = -----, D = - ---]]
                                   16        16      1024         32
          (%i4) lsquares_residuals (
                    M, [z,x,y], (z+D)^2 = A*x+B*y+C, first(a));
                                      13    13    13  13  13
          (%o4)                      [--, - --, - --, --, --]
                                      64    64    32  64  64


 -- Función: lsquares_residual_mse (<D>, <x>, <e>, <a>)
     Devuelve el residuo del error cuadrático medio (MSE) de la
     ecuación <e> para los valores parámetricos <a> y datos <D>.

     El residuo del error cuadrático medio (MSE) se define como

                              n
                             ====
                             \                        2
                              >    (rhs(e ) - lhs(e ))
                             /           i         i
                             ====
                             i = 1
                             --------------------------
                                         n

     siendo `<e>[i]' la ecuación <e> evaluada cuando las variables <x>
     toman los valores asociados al dato `i'-ésimo `<D>[i]', y haciendo
     las asignaciones indicadas en <a> al resto de variables.

     Antes de utilizar esta función ejecútese `load(lsquares)'.

     Ejemplo:

          (%i1) load (lsquares)$
          (%i2) M : matrix (
                   [1,1,1], [3/2,1,2], [9/4,2,1], [3,2,2], [2,2,1]);
                                     [ 1  1  1 ]
                                     [         ]
                                     [ 3       ]
                                     [ -  1  2 ]
                                     [ 2       ]
                                     [         ]
          (%o2)                      [ 9       ]
                                     [ -  2  1 ]
                                     [ 4       ]
                                     [         ]
                                     [ 3  2  2 ]
                                     [         ]
                                     [ 2  2  1 ]
          (%i3) a : lsquares_estimates (
                       M, [z,x,y], (z+D)^2 = A*x+B*y+C, [A,B,C,D]);

                            59        27      10921        107
          (%o3)     [[A = - --, B = - --, C = -----, D = - ---]]
                            16        16      1024         32
          (%i4) lsquares_residual_mse (
                       M, [z,x,y], (z + D)^2 = A*x + B*y + C, first (a));
                                        169
          (%o4)                         ----
                                        2560


 -- Función: plsquares (<Mat>,<VarList>,<depvars>)
 -- Función: plsquares (<Mat>,<VarList>,<depvars>,<maxexpon>)
 -- Función: plsquares
          (<Mat>,<VarList>,<depvars>,<maxexpon>,<maxdegree>)
     Ajuste de una función polinómica multivariante a una tabla de
     datos por el método de los mínimos cuadrados. <Mat> es la matriz
     con los datos empíricos, <VarList> es la lista con los nombres de
     las variables (una por cada columna de <Mat>, pero puede usarse
     `-' en lugar de los nombres de variables para ignorar las columnas
     de <Mat>), <depvars> es el nombre de la variable dependiente o una
     lista con uno o más nombres de variables dependientes (cuyos
     nombres deben estar también en <VarList>), <maxexpon> es un
     argumento opcional para indicar el máximo exponente para cada una
     de las variables independientes (1 por defecto) y  <maxdegree> es
     otro argumento opcional para el grado del polinomio (<maxexpon>
     por defecto); nótese que la suma de exponentes de cada término
     debe ser igual o menor que <maxdegree>. Si `maxdgree = 0' entonces
     no se aplicará ningún límite.

     Si <depvars> es el nombre de una variable dependiente (no en una
     lista), `plsquares' devuelve el polinomio ajustado. Si <depvars>
     es una lista de una o más variables dependientes, `plsquares'
     devuelve una lista con los polinomios ajustados. Los coeficientes
     de determinación se muestran en su orden correspondiente para
     informar sobre la bondad del ajuste. Estos valores se almacenan
     también en la variable global <DETCOEF> en un formato de lista si
     <depvars> es a su vez una lista.

     Un ejemplo sencillo de ajuste lineal multivariante:

          (%i1) load("plsquares")$

          (%i2) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z);
               Determination Coefficient for z = .9897039897039897
                                 11 y - 9 x - 14
          (%o2)              z = ---------------
                                        3

     El mismo ejemplo sin restricciones en el grado:

          (%i3) plsquares(matrix([1,2,0],[3,5,4],[4,7,9],[5,8,10]),
                          [x,y,z],z,1,0);
               Determination Coefficient for z = 1.0
                              x y + 23 y - 29 x - 19
          (%o3)           z = ----------------------
                                        6

     Cálculo del número de diagonales de un polígono de N lados

          (%i4) plsquares(matrix([3,0],[4,2],[5,5],[6,9],[7,14],[8,20]),
                          [N,diagonals],diagonals,5);
               Determination Coefficient for diagonals = 1.0
                                          2
                                         N  - 3 N
          (%o4)              diagonals = --------
                                            2
          (%i5) ev(%, N=9);   /* Testing for a 9 sides polygon */
          (%o5)                 diagonals = 27

     Cálculo del número de formas de colocar dos reinas en un tablero n
     x n de manera que no se amenacen.

          (%i6) plsquares(matrix([0,0],[1,0],[2,0],[3,8],[4,44]),
                          [n,positions],[positions],4);
               Determination Coefficient for [positions] = [1.0]
                                   4       3      2
                                3 n  - 10 n  + 9 n  - 2 n
          (%o6)    [positions = -------------------------]
                                            6
          (%i7) ev(%[1], n=8); /* Testing for a (8 x 8) chessboard */
          (%o7)                positions = 1288

     Un ejemplo con seis variables dependientes:

          (%i8) mtrx:matrix([0,0,0,0,0,1,1,1],[0,1,0,1,1,1,0,0],
                            [1,0,0,1,1,1,0,0],[1,1,1,1,0,0,0,1])$
          (%i8) plsquares(mtrx,[a,b,_And,_Or,_Xor,_Nand,_Nor,_Nxor],
                               [_And,_Or,_Xor,_Nand,_Nor,_Nxor],1,0);
                Determination Coefficient for
          [_And, _Or, _Xor, _Nand, _Nor, _Nxor] =
          [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
          (%o2) [_And = a b, _Or = - a b + b + a,
          _Xor = - 2 a b + b + a, _Nand = 1 - a b,
          _Nor = a b - b - a + 1, _Nxor = 2 a b - b - a + 1]

     Antes de hacer uso de esta función ejecútese  `load("plsquares")'.


File: maxima.info,  Node: makeOrders,  Next: mnewton,  Prev: lsquares,  Up: Top

62 makeOrders
*************

* Menu:

* Funciones y variables para makeOrders::


File: maxima.info,  Node: Funciones y variables para makeOrders,  Prev: makeOrders,  Up: makeOrders

62.1 Funciones y variables para makeOrders
==========================================

 -- Función: makeOrders (<indvarlist>,<orderlist>)
     Devuelve una lista con las potencias de las variables de un
     polinomio término a término.

          (%i1) load("makeOrders")$

          (%i2) makeOrders([a,b],[2,3]);
          (%o2) [[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1],
                      [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3]]
          (%i3) expand((1+a+a^2)*(1+b+b^2+b^3));
                 2  3      3    3    2  2      2    2    2
          (%o3) a  b  + a b  + b  + a  b  + a b  + b  + a  b + a b
                                                            2
                                                     + b + a  + a + 1
     donde `[0, 1]' se asocia al término b y `[2, 3]' a a^2 b^3.

     Antes de hacer uso de esta función ejecútese `load("makeOrders")'.


File: maxima.info,  Node: mnewton,  Next: numericalio,  Prev: makeOrders,  Up: Top

63 mnewton
**********

* Menu:

* Funciones y variables para mnewton::


File: maxima.info,  Node: Funciones y variables para mnewton,  Prev: mnewton,  Up: mnewton

63.1 Funciones y variables para mnewton
=======================================

 -- Variable opcional: newtonepsilon
     Valor por defecto:  `10.0^(-fpprec/2)'

     Precisión que determina cuando la función `mnewton' ha conseguido
     una convergencia aceptable.

     Véase también `mnewton'.

 -- Variable opcional: newtonmaxiter
     Valor por defecto:  `50'

     Número máximo de iteraciones para la función `mnewton' en caso de
     que no se produzca convergencia, o de que ésta se haga muy lenta.

     Véase también `mnewton'.

 -- Función: mnewton (<FuncList>,<VarList>,<GuessList>)
     Resolución de sistemas de ecuaciones no lineales por el método de
     Newton.  <FuncList> es la lista de ecuaciones a resolver,
     <VarList> es la lista con los nombres de las incógnitas y
     <GuessList> es la lista de aproximaciones iniciales.

     La solución se devuelve en el mismo formato que lo hace la función
     `solve()'.  Si no se le encuentra solución al sistema, se obtiene
     `[]' como respuesta.

     Esta función se controla con las variables globales
     `newtonepsilon' y `newtonmaxiter'.

          (%i1) load("mnewton")$

          (%i2) mnewton([x1+3*log(x1)-x2^2, 2*x1^2-x1*x2-5*x1+1],
                        [x1, x2], [5, 5]);
          (%o2) [[x1 = 3.756834008012769, x2 = 2.779849592817897]]
          (%i3) mnewton([2*a^a-5],[a],[1]);
          (%o3)             [[a = 1.70927556786144]]
          (%i4) mnewton([2*3^u-v/u-5, u+2^v-4], [u, v], [2, 2]);
          (%o4) [[u = 1.066618389595407, v = 1.552564766841786]]

     Antes de hacer uso de esta función ejecútese  `load("mnewton")'.
     Véanse también `newtonepsilon' y `newtonmaxiter'.


File: maxima.info,  Node: numericalio,  Next: opsubst,  Prev: mnewton,  Up: Top

64 numericalio
**************

* Menu:

* Introducción a numericalio::
* Funciones y variables para entrada y salida en formato texto::
* Funciones y variables para entrada y salida en formato binario::


File: maxima.info,  Node: Introducción a numericalio,  Next: Funciones y variables para entrada y salida en formato texto,  Prev: numericalio,  Up: numericalio

64.1 Introducción a numericalio
===============================

El paquete `numericalio' define funciones para leer y escribir ficheros
de datos y flujos. Las funciones de entrada y salida en formato texto
pueden leer y escribir números (enteros, decimales o decimales
grandes), símbolos y cadenas.  Las funciones de entrada y salida en
formato binario sólo pueden leer y escribir números decimales.

   Si ya existe una lista, matriz o array para almacenar los datos de
entrada, las funciones de entrada de `numericalio' pueden escribir los
datos directamente en estos objetos. En caso contrario, `numericalio'
tratará de generar el objeto apropiado para almacenar estos datos.

64.1.1 Entrada y salida en formato texto
----------------------------------------

In plain-text input and output, it is assumed that each item to read or
write is an atom:

   En la entrada y salida de datos en formato texto se supone que cada
dato es un átomo: un número entero, decimal, decimal grande, una cadena
o un símbolo; no se admiten fracciones, números complejos o cualquier
otra expresión no atómica. Estas funciones pueden llegar a realizar
operaciones válidas con expresiones no atómicas, pero estos resultados
no se documentan y están sujetos a cambios ulteriores.

   Los átomos, tanto en los ficheros de entrada como en los de salida,
tienen el mismo formato que en los ficheros por lotes de Maxima o en la
consola interactiva. En particular, las cadenas deben encerrarse entre
comillas dobles, la barra invertida `\' evita cualquier interpretación
especial del carácter siguiente, y el símbolo de interrogación `?' se
reconoce como el comienzo de un símbolo de Lisp. No se reconoce ningún
carácter de continuación de línea interrumpida.

64.1.2 Separadores válidos para lectura
---------------------------------------

Las funciones para la entrada y salida de datos en formato texto tiene
un argumento opcional, <separator_flag>, para indicar qué carácter se
utiliza como separador.

   Para la entrada de texto se reconocen los siguientes valores de la
variable <separator_flag>: `comma' para los valores separados por
comas, `pipe' para los valores separados por el carácter de la barra
vertical `|', `semicolon' para los valores separados por punto y coma
`;', y `space' para cuando los valores se separan por espacios o
tabulaciones. Si el nombre del fichero tiene extensión `.csv' y no se
especifica el argumento <separator_flag>, se tomará por defecto `comma'.
Si el fichero tiene cualquier otra extensión diferente de `.csv' y no se
especifica `separator_flag', se usará por defecto `space'.

   En la entrada de texto, varios espacios y tabulaciones sucesivos
cuentan como un único separador. Sin embargo, varias comas, barras
verticales o punto y comas sucesivos se interpretan que tienen el
símbolo `false' entre ellos; por ejemplo, `1234,,Foo' se interpreta lo
mismo que si fuese `1234,false,Foo'. En la salida, los átomos `false'
deben escribirse explícitamente, por lo que la lista `[1234, false,
Foo]' debe escribirse `1234,false,Foo'.

64.1.3 Separadores válidos para escritura
-----------------------------------------

Para la entrada de texto se acepta `tab' como valor de <separator_flag>
para datos separados por tabuladores, así como `comma', `pipe',
`semicolon' y `space'.

   En la escritura de texto, el átomo`false' se escribe tal cual y una
lista `[1234, false, Foo]' se escribe `1234,false,Foo'.

64.1.4 Entrada y salida de decimales en formato binario
-------------------------------------------------------

Las funciones de `numericalio' pueden leer y escribir números decimales
en coma flotante de 8 bytes del estándar IEEE 754. Estos números se
pueden escribir empezando por el byte menos significativo o por el más
significativo, según lo indique la variable global
`assume_external_byte_order'. Por defecto, `numericalio' los almacena
con el byte más significativo primero.

   Cualesquiera otros tipos de decimales son transformados a 8 bytes.
El paquete `numericalio' no puede leer ni escribir datos binarios no
numéricos.

   Ciertos entornos Lisp no reconocen valores especiales del estándar
IEEE 754 (más o menos infinito, valores no numéricos, valores no
normales). El efecto que pueda producir la lectura de tales valores por
parte de `numericalio' es imprevisible.

   `numericalio' incluye funciones para abrir un flujo de lectura o
escritura de flujos de bytes.



Local Variables:
coding: iso-8859-1
End:
