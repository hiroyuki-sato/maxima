@c English version 2011-06-30
@menu
* Comentarios::
* Archivos::
* Funciones y variables para lectura y escritura::
@end menu

@node Comentarios, Archivos, Lectura y escritura, Lectura y escritura
@section Comentarios

En Maxima, un comentario es cualquier texto encerrado entre las
marcas @code{/*} y @code{*/}.

El analizador sint@'actico de Maxima trata los comentarios como
espacios en blanco a efectos de encontrar @i{tokens} en el flujo
de entrada. Una entrada tal como @code{a/* foo */b} contiene dos
@i{tokens}, @code{a} y @code{b}, no un @'unico @i{token} @code{ab}.
En cualquier otro contexto, los comentarios son ignorados por Maxima;
no se almacenan ni sus contenidos ni sus localizaciones.

Los comentarios pueden anidarse hasta una profundidad arbitraria.
Las marcas  @code{/*} y @code{*/} deben emparejarse y debe haber igual n@'umero
de ambos.

Ejemplos:

@c ===beg===
@c /* aa is a variable of interest */  aa : 1234;
@c /* Value of bb depends on aa */  bb : aa^2;
@c /* User-defined infix operator */  infix ("b");
@c /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
@c /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
@c ===end===
@example
(%i1) /* aa is a variable of interest */  aa : 1234;
(%o1)                         1234
(%i2) /* Value of bb depends on aa */  bb : aa^2;
(%o2)                        1522756
(%i3) /* User-defined infix operator */  infix ("b");
(%o3)                           b
(%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
(%o4)                         a b c
(%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
(%o5)                        xyz + 1
@end example


@node Archivos, Funciones y variables para lectura y escritura, Comentarios, Lectura y escritura
@section Archivos

Un archivo no es m@'as que una @'area de un cierto dispositivo de almacenamiento que contiene datos o texto.
Los archivos se agrupan en los discos en "directorios", que son listas de archivos.
Instrucciones que operan con archivos son:

@example
appendfile           batch                 batchload     
closefile            file_output_append    filename_merge        
file_search          file_search_maxima    file_search_lisp      
file_search_demo     file_search_usage     file_search_tests     
file_type            load                  load_pathname         
loadfile             loadprint             printfile             
pathname_directory   pathname_name         pathname_type
save                 stringout             with_stdout
writefile
@end example

Cuando el nombre de un fichero se pasa a funciones como @code{plot2d}, @code{save} o 
@code{writefile} y en @'el no se incluye la ruta de acceso, Maxima almacena
el fichero en la carpeta de trabajo actual. La ubicaci@'on de la carpeta de 
trabajo depende del sistema operativo y de la instalaci@'on.


@node Funciones y variables para lectura y escritura,  , Archivos, Lectura y escritura
@section Funciones y variables para lectura y escritura


@deffn {Funci@'on} appendfile (@var{filename})
A@~nade informaci@'on de la consola a @var{filename}, de igual manera que lo hace @code{writefile}, pero con la salvedad de que si el archivo ya existe la informaci@'on queda a@~nadida al final de su contenido.

La funci@'on @code{closefile} cierra los archivos abiertos por @code{appendfile} o @code{writefile}.

@end deffn



@deffn {Funci@'on} batch (@var{filename})
@deffnx {Function} batch (@var{filename}, @code{option})

@code{batch(@var{filename})} lee expresiones de Maxima desde @var{filename} y 
las eval@'ua. La funci@'on @code{batch} busca @var{filename} en la lista 
@code{file_search_maxima}. V@'ease @code{file_search}.

@code{batch(@var{filename}, @code{test})} es como @code{run_testsuite} con la
opci@'on @code{display_all=true}. En este caso @code{batch} busca @var{filename} 
en la lista @code{file_search_maxima} y no en @code{file_search_tests} como hace
@code{run_testsuite}. Adem@'as, @code{run_testsuite} ejecuta tests que est@'an
en la lista @code{testsuite_files}. Con @code{batch} es posible ejecutar
cualquier fichero que se encuentre en @code{file_search_maxima} en modo de prueba.

El contenido de @var{filename} debe ser una secuencia de expresiones de Maxima,
cada una de las cuales termina en @code{;} o @code{$}.
La variable especial @code{%} y la funci@'on @code{%th}
se refieren a resultados previos dentro del archivo.
El archivo puede incluir construcciones del tipo @code{:lisp}.
Espacios, tabulaciones y saltos de l@'{@dotless{i}}nea en el archivo se ignoran.
Un archivo de entrada v@'alido puede crearse con un editor de texto o con la 
funci@'on @code{stringout}.

La funci@'on @code{batch} lee las expresiones del archivo @var{filename}, 
muestra las entradas en la consola, realiza los c@'alculos solicitados y 
muestra las expresiones de los resultados.
A las expresiones de entrada se les asignan etiquetas, as@'{@dotless{i}} 
como a las de salida. La funci@'on @code{batch} eval@'ua todas las expresiones 
de entrada del archivo a menos que se produzca un error. Si se le solicita 
informaci@'on al usuario (con @code{asksign} o @code{askinteger}, por ejemplo)
@code{batch} se detiene para leer la nueva informaci@'on para luego continuar.

Es posible detener  @code{batch} tecleando @code{control-C} desde la consola.
El efecto de @code{control-C} depende del entorno Lisp instalado.

La funci@'on @code{batch} tiene diversas aplicaciones, tales como servir de 
almac@'en de c@'odigo escrito por el usuario, suministrar demostraciones
libres de errores o ayudar a organizar el trabajo del usuario en la resoluci@'on 
de problemas complejos.

La funci@'on @code{batch} eval@'ua su argumento y devuelve la ruta hacia
@var{filename} en formato cadena cuando es invocada sin segundo argumento
o con la opci@'on @code{demo}. Cuando es llamada con la opci@'on @code{test}, 
devuelve la lista vac@'{@dotless{i}}a @code{[]} o una lista con @var{filename}
y los n@'umeros de tests que han fallado.

V@'eanse tambi@'en  @code{load}, @code{batchload} y @code{demo}.

@end deffn

@deffn {Funci@'on} batchload (@var{filename})
Lee expresiones de Maxima desde @var{filename} y las eval@'ua sin mostrar las entradas ni las salidas y sin asignarles etiquetas. Sin embargo, las salidas producidas por  @code{print} o @code{describe} s@'{@dotless{i}} se muestran.

La variable especial @code{%} y la funci@'on @code{%th} se refieren a resultados previos del int@'erprete interactivo, no a los del propio archivo. El archivo no puede incluir construcciones del tipo @code{:lisp}.

La funci@'on @code{batchload} devuelve la ruta de @var{filename} en formato de cadena.

La funci@'on @code{batchload} eval@'ua sus argumentos.

V@'eanse tambi@'en @code{batch} y @code{load}.
@c batchload APPEARS TO HAVE THE SAME EFFECT AS load. WHY NOT GET RID OF batchload ???

@end deffn



@deffn {Funci@'on} closefile ()
La funci@'on @code{closefile} cierra los archivos abiertos por @code{appendfile} o @code{writefile}.

@end deffn


@defvr {Variable opcional} file_output_append
Valor por defecto: @code{false}

La variable @code{file_output_append} controla si las funciones de escritura de ficheros a@~naden informaci@'on o sustituyen el fichero de salida. Cuando @code{file_output_append} toma el valor @code{true}, estas funciones ampl@'{@dotless{i}}an el contenido de sus ficheros de salida; en otro caso, sustituyen el fichero anterior de igual nombre por otro con el nuevo contenido.

Las funciones @code{save}, @code{stringout} y @code{with_stdout} se ven afectadas por el valor que tome la variable @code{file_output_append}. Otras funciones que tambi@'en escriben en ficheros de salida no tienen en cuenta este valor; en concreto, las funciones para la representaci@'on de gr@'aficos y las de traducci@'on siempre sustituyen el fichero anterior por uno nuevo de igual nombre, mientras que las funciones @code{tex} y @code{appendfile} siempre a@~naden informaci@'on al fichero de salida sin eliminar la informaci@'on anterior.
@c WHAT ABOUT WRITEFILE ??

@end defvr



@deffn {Funci@'on} filename_merge (@var{path}, @var{filename})
Construye una ruta modificada a partir de @var{path} y @var{filename}.
Si la componente final de @var{path} es de la forma @code{###.@var{something}},
la componente se reemplaza con @code{@var{filename}.@var{something}}.
En otro caso, la componente final se reemplaza simplemente por @var{filename}.

El resultado es un objeto Lisp de tipo @i{pathname}.
@end deffn



@deffn {Funci@'on} file_search (@var{filename})
@deffnx {Funci@'on} file_search (@var{filename}, @var{pathlist})

La funci@'on @code{file_search} busca el archivo @var{filename} y devuelve su ruta como una cadena; si no lo encuentra,  @code{file_search} devuelve @code{false}. La llamada 
@code{file_search (@var{filename})} busca en los directorios de b@'usqueda por defecto,
que son los especificados por las variables @code{file_search_maxima}, @code{file_search_lisp} y @code{file_search_demo}.

La funci@'on @code{file_search} analiza primero si el nombre del argumento existe antes de hacerlo coincidir con los comodines de los patrones de b@'usqueda de archivos.
V@'ease @code{file_search_maxima} para m@'as informaci@'on sobre patrones de b@'usqueda de archivos.

El argumento @var{filename} puede ser una ruta con nombre de archivo,
o simplemente el nombre del archivo, o, si el directorio de b@'usqueda de archivo incluye un patr@'on de b@'usqueda, es suficiente con el nombre de archivo sin extensi@'on.
Por ejemplo,

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

todos buscan el mismo archivo, dando por hecho que el archivo existe y que @code{/home/wfs/special/###.mac}
est@'a en @code{file_search_maxima}.

La llamada @code{file_search (@var{filename}, @var{pathlist})} busca solamente en los directorios especificados por @var{pathlist}, que es una lista de cadenas.
El argumento @var{pathlist} ignora los directorios de b@'usqueda por defecto, de manera que si se da la lista de rutas, @code{file_search} busca solamente en ellas y no en los directorios por defecto.
Incluso si hay un @'unico directorio en @var{pathlist}, debe ser suministrado como una lista de un @'unico elemento.

El usuario puede modificar los directorios de b@'usqueda por defecto; v@'ease para ello See @code{file_search_maxima}.

La funci@'on @code{file_search} es llamada por @code{load} con los directorios de b@'usqueda @code{file_search_maxima} y @code{file_search_lisp}.
@end deffn



@defvr {Variable opcional} file_search_maxima
@defvrx {Variable opcional} file_search_lisp
@defvrx {Variable opcional} file_search_demo
@defvrx {Variable opcional} file_search_usage
@defvrx {Variable opcional} file_search_tests

Estas variables especifican listas de directorios en los que deben buscar la funciones  @code{load}, @code{demo} y algunas otras. Los valores por defecto de estas variables nombran directorios de la instalaci@'on de Maxima.

El usuario puede modificar estas variables, bien reemplazando los valores por defecto, bien a@~nadiendo nuevos directorios.
Por ejemplo,

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

reemplaza el valor por defecto de @code{file_search_maxima}, mintras que

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

a@~nade dos directorios m@'as. Puede ser conveniente colocar una expresi@'on como esta en el archivo @code{maxima-init.mac}, de manera que la ruta de b@'usqueda de ficheros se asigne autom@'aticamente cada vez que arranca Maxima.

Se pueden especificar varias extensiones de archivos y rutas con comodines especiales.
La cadena @code{###} representa el nombre del archivo buscado y una lista separada de comas y encerrada entre llaves,  @code{@{foo,bar,baz@}} representa m@'ultiples cadenas.
Por ejemplo, suponiendo que se busca el nombre @code{neumann},

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

se interpreta como @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp}, @code{/home/wfs/neumann.mac} y @code{/home/gcj/neumann.mac}.
@end defvr


@deffn {Funci@'on} file_type (@var{filename})
Devuelve una descripci@'on del contenido de @var{filename} basada en la 
extensi@'on, sin intentar abrir el archivo para inspeccionar su contenido.

El valor devuelto es un s@'{@dotless{i}}mbolo @code{object}, @code{lisp} o 
@code{maxima}. Si la extensi@'on es "mac", "mc", "demo", "dem", "dm1", "dm2", 
"dm3" o "dmt", @code{file_type} devuelve @code{maxima}. Si la extensi@'on es 
"l", "lsp" o "lisp", @code{file_type} devuelve @code{lisp}. Si la extensi@'on
no es ninguna de las anteriores, @code{file_type} devuelve @code{object}.

V@'ease tambi@'en @code{pathname_type}.

Ejemplos:

@c === beg ===
@c map('file_type,["test.lisp", "test.mac", "test.dem", "test.txt"]);
@c === end ===
@example
(%i2) map('file_type,["test.lisp", "test.mac", "test.dem", "test.txt"]);
(%o2)            [lisp, maxima, maxima, object]
@end example
@end deffn



@defvr {Variable opcional} file_type_lisp
Valor por defecto:  @code{[l, lsp, lisp]}

@code{file_type_lisp} es una lista con extensiones de ficheros que Maxima 
reconoce como fuente de Lisp.

V@'ease tambi@'en @code{file_type}
@end defvr



@defvr {Variable opcional} file_type_maxima
Valor por defecto:  @code{[mac, mc, demo, dem, dm1, dm2, dm3, dmt]}

@code{file_type_maxima} es una lista con extensiones de ficheros que Maxima 
reconoce como fuente de Maxima.

V@'ease tambi@'en @code{file_type}
@end defvr




@deffn {Funci@'on} load (@var{filename})
Eval@'ua las expresiones del archivo @var{filename}, trayendo variables, funciones y otros objetos a Maxima.
Una asignaci@'on hecha previamente a una variable en Maxima ser@'a destruida por otra asignaci@'on que se le haga en @var{filename}. Para encontrar el fichero, @code{load} llama a @code{file_search} con @code{file_search_maxima} y @code{file_search_lisp} como directorios de b@'usqueda. Si la llamada a @code{load} funciona correctamente, devuelve el nombre del fichero; en caso contrario, @code{load} muestra un mensaje de error.

La funci@'on @code{load} trabaja indistintamente con c@'odigo Lisp y Maxima.
Los ficheros creados con @code{save}, @code{translate_file} y @code{compile_file}, que crea c@'odigo Lisp,
y @code{stringout}, que crea c@'odigo Maxima, todos ellos pueden ser procesados por @code{load}. La funci@'on
@code{load} llama a @code{loadfile} para cargar archivos en Lisp y a  @code{batchload} para cargar archivos en Maxima.

La funci@'on @code{load} no reconoce las construcciones de tipo @code{:lisp} en
ficheros de Maxima. Adem@'as, mientras se est@'a procesando @var{filename},
las variables globales @code{_}, @code{__}, @code{%} y @code{%th} mantienen los
valores que ten@'{@dotless{i}}an cuando se realiz@'o la llamada a @code{load}.

V@'eanse tambi@'en @code{loadfile}, @code{batch}, @code{batchload} y @code{demo};
@code{loadfile} procesa archivos en Lisp; @code{batch}, @code{batchload} y @code{demo} procesan archivos en Maxima.

V@'ease @code{file_search} para m@'as detalles sobre el mecanismo de b@'usqueda de archivos.

La funci@'on @code{load} eval@'ua sus argumentos.

@end deffn



@defvr {Variable del sistema} load_pathname
Valor por defecto: @code{false}

Cuando se carga un fichero con las funciones @code{load}, @code{loadfile}
o @code{batchload}, a la variable @code{load_pathname} se le asigna la
ruta al fichero en cuesti@'on.

Se puede acceder a la variable @code{load_pathname} mientras se est@'a
cargando el fichero.

Ejemplo:

Sup@'ongase que se tiene el fichero @code{test.mac} en la carpeta
@code{"/home/usuario/workspace/mymaxima/temp/"} con las siguientes
instrucciones:

@example
print("The value of load_pathname is: ", load_pathname)$
print("End of batchfile")$
@end example

Entonces se obtiene el siguiente resultado:

@example
(%i1) load("/home/usuario/workspace/mymaxima/temp/test.mac")$
The value of load_pathname is:  
                   /home/usuario/workspace/mymaxima/temp/test.mac 
End of batchfile
@end example
@end defvr


@deffn {Funci@'on} loadfile (@var{filename})
Eval@'ua las expresiones Lisp del archivo @var{filename}. La funci@'on
@code{loadfile} no llama a @code{file_search}, de manera que @code{filename} debe incluir la extensi@'on del archivo y su ruta completa.

La funci@'on @code{loadfile} puede procesar ficheros creados por  @code{save}, @code{translate_file} y @code{compile_file}.
Puede ser m@'as conveniente utilizar @code{load} en lugar de @code{loadfile}.
@end deffn



@defvr {Variable opcional} loadprint
Valor por defecto: @code{true}

La variable @code{loadprint} indica si mostrar un mensaje cuando se carga un archivo.

@itemize @bullet
@item
Si @code{loadprint} vale @code{true}, se muestra siempre un mensaje.
@item
Si @code{loadprint} vale @code{'loadfile}, muestra un mensaje s@'olo si el archivo es cargado con la funci@'on @code{loadfile}.
@item
Si @code{loadprint} vale @code{'autoload}, muestra un mensaje s@'olo cuandi un archivo se carga autom@'aticamente. V@'ease  @code{setup_autoload}.
@item
Si @code{loadprint} vale @code{false}, nunca mostrar@'a mensajes.
@end itemize

@end defvr



@defvr {Variable opcional} packagefile
Valor por defecto: @code{false}

Los desarrolladores de paquetes que utilizan @code{save} o @code{translate}
para crear paquetes (ficheros) que van a ser utilizados por terceros pueden
hacer @code{packagefile: true} para evitar que se a@~nada informaci@'on a la
listas de informaci@'on de Maxima, como @code{values} o @code{functions}.
@end defvr



@deffn  {Funci@'on} pathname_directory (@var{pathname})
@deffnx {Funci@'on} pathname_name (@var{pathname})
@deffnx {Funci@'on} pathname_type (@var{pathname})

Estas funciones devuelven las componentes de @var{pathname}.

Ejemplos:

@c === beg ===
@c pathname_directory("/home/usuario/maxima/changelog.txt");
@c pathname_name("/home/usuario/maxima/changelog.txt");
@c pathname_type("/home/usuario/maxima/changelog.txt");
@c === end ===
@example 
(%i1) pathname_directory("/home/usuario/maxima/changelog.txt");
(%o1)                 /home/usuario/maxima/
(%i2) pathname_name("/home/usuario/maxima/changelog.txt");
(%o2)                       changelog
(%i3) pathname_type("/home/usuario/maxima/changelog.txt");
(%o3)                          txt
@end example

@end deffn



@deffn {Funci@'on} printfile (@var{path})

Env@'{@dotless{i}}a el fichero al que hace referncia la ruta @var{path}
a la consola. @var{path} puede ser una cadena o un s@'{@dotless{i}}mbolo,
en cuyo caso se convertir@'a en una cadena.

Si @var{path} hace referencia a un fichero accesible desde el directorio
actual de trabajo, entonces se enviar@'a a la consola; en caso contrario,
@code{printfile} intentar@'a localizar el fichero a@~nadi@'endole @var{path}
a cada uno de los elementos de @code{file_search_usage} a trav@'es de 
@code{filename_merge}.

@code{printfile} devuelve la ruta del fichero encontado.

@end deffn




@deffn {Funci@'on} save (@var{filename}, @var{name_1}, @var{name_2}, @var{name_3}, ...)
@deffnx {Funci@'on} save (@var{filename}, values, functions, labels, ...)
@deffnx {Funci@'on} save (@var{filename}, [@var{m}, @var{n}])
@deffnx {Funci@'on} save (@var{filename}, @var{name_1}=@var{expr_1}, ...)
@deffnx {Funci@'on} save (@var{filename}, all)
@deffnx {Funci@'on} save (@var{filename}, @var{name_1}=@var{expr_1}, @var{name_2}=@var{expr_2}, ...)

Alamacena los valores actuales de @var{name_1}, @var{name_2}, @var{name_3}, ..., en el archivo @var{filename}.
Los argumentos son nombres de variables, funciones u otros objetos.
Si un nombre no tiene un valor o una funci@'on asociado a @'el, entonces se ignora.

La funci@'on @code{save} devuelve @var{filename}.

La funci@'on @code{save} almacena datos en forma de expresiones Lisp.
Los datos almacenados por @code{save} pueden recuperarse con @code{load (@var{filename})}.
El resultado de ejecutar  @code{save} cuando @var{filename} ya existe depende del soporte Lisp implementado;
el archivo puede ser sobreescrito o que @code{save} env@'{@dotless{i}}e un mesaje de error.

La llamada @code{save (@var{filename}, values, functions, labels, ...)}
almacena los elementos cuyos nombres son @code{values}, @code{functions}, @code{labels}, etc.
Los nombres pueden ser cualesquiera de los especificados por la variable @code{infolists};
@code{values} incluye todas las variables definidas por el usuario.

La llamada @code{save (@var{filename}, [@var{m}, @var{n}])} almacena los valores de las etiquetas de entrada y salida desde @var{m} hasta @var{n}.
N@'otese que @var{m} y @var{n} deben ser n@'umeros.
Las etiquetas de entrada y salida tambi@'en se pueden almacenar una a una, por ejemplo, @code{save ("foo.1", %i42, %o42)}.
La llamada @code{save (@var{filename}, labels)} almacena todas las etiquetas de entrada y salida.
Cuando las etiquetas almacenadas en el archivo sean posteriormente recuperadas, se sobreescribir@'an las activas en ese momento.

La llamada @code{save (@var{filename}, @var{name_1}=@var{expr_1}, @var{name_2}=@var{expr_2}, ...)}
almacena los valores de @var{expr_1}, @var{expr_2}, ...,
con los nombres @var{name_1}, @var{name_2}, ....
Es @'util hacer este tipo de llamada para con etiquetas de entrada y salida, por ejemplo, @code{save ("foo.1", aa=%o88)}.
El miembro derecho de la igualdad puede ser cualquier expresi@'on, que ser@'a evaluada.
Esta llamada a la funci@'on @code{save} no incorpora nuevos nombres a la sesi@'on actual de Maxima,
simplemente los almacena en el archivo @var{filename}.

Todas estas formas de llamar a la funci@'on @code{save} se pueden combinar a voluntad.
Por ejemplo, @code{save (@var{filename}, aa, bb, cc=42, functions, [11, 17])}.

La llamada @code{save (@var{filename}, all)} almacena el estado actual de Maxima, lo que incluye todas las variables definidas por el usuario, funciones, arreglos, etc., as@'{@dotless{i}} como algunos objetos definidos autom@'aticamente.
Los elementos almacenados incluyen variables del sistema, como @code{file_search_maxima} o @code{showtime}, si han sido modificadas por el usuario. V@'ease @code{myoptions}.

@code{save} eval@'ua @var{filename} pero no el resto de argumentos.
@end deffn



@deffn {Funci@'on} stringout (@var{filename}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
@deffnx {Funci@'on} stringout (@var{filename}, [@var{m}, @var{n}])
@deffnx {Funci@'on} stringout (@var{filename}, input)
@deffnx {Funci@'on} stringout (@var{filename}, functions)
@deffnx {Funci@'on} stringout (@var{filename}, values)

La funci@'on @code{stringout} escribe expresiones en un archivo de la misma forma en que se escribir@'{@dotless{i}}an como expresiones de entrada. El archivo puede ser utilizado entonces como entrada a las funciones @code{batch} o @code{demo}, y puede ser editado para cualquier otro prop@'osito.

La forma general de @code{stringout} escribe los valores de una o m@'as expresiones en el archivo de salida. N@'otese que si una expresi@'on es una variable, solamente se escribir@'a el valor de la variable y no el nombre de @'esta. Como caso especial, y muy @'util en algunas ocasiones, las expresiones pueden ser etiquetas de entrada (@code{%i1}, @code{%i2}, @code{%i3}, ...) o de salida (@code{%o1}, @code{%o2}, @code{%o3}, ...).

Si @code{grind} vale @code{true}, @code{stringout} formatea la salida utilizando @code{grind}. En caso contrario, se utilizar@'a el formato @code{string}. V@'eanse @code{grind} y @code{string}.

La forma especial @code{stringout (@var{filename}, [@var{m}, @var{n}])} escribe los valores de las etiquetas de entrada desde la m hasta la n, ambas inclusive. 

La forma especial @code{stringout (@var{filename}, input)} escribe todas las etiquetas de entrada en el archivo.

La forma especial @code{stringout (@var{filename}, functions)} escribe todas las funciones definidas por el usuario, contenidas en la lista global @code{functions}, en el archivo.

La forma especial @code{stringout (@var{filename}, values)} escribe todas las variables asignadas por el usuario, contenidas en la lista global @code{values}, en el archivo. Cada variable se escribe como una sentencia de asignaci@'on, con el nombre de la variable seguida de dos puntos y a continuaci@'on su valor. N@'otese que la forma general de @code{stringout} no escribe las variables como sentencias de asignaci@'on.
@end deffn




@deffn {Funci@'on} tex (@var{expr})
@deffnx {Funci@'on} tex (@var{expr}, @var{destination})
@deffnx {Funci@'on} tex (@var{expr}, false)
@deffnx {Funci@'on} tex (@var{label})
@deffnx {Funci@'on} tex (@var{label}, @var{destination})
@deffnx {Funci@'on} tex (@var{label}, false)

Devuelve la expresi@'on en un formato apropiado para para ser incorporado a un documento basado en TeX.
El resultado que se obtiene es un fragmento de c@'odigo que puede incluirse en un documento mayor, pero que
no puede ser procesado aisladamente.

La instrucci@'on @code{tex (@var{expr})} imprime en la consola la representaci@'on en TeX de @var{expr}.

La instrucci@'on @code{tex (@var{label})} imprime en la consola la representaci@'on en TeX de la expresi@'on a la que hace referencia la etiqueta @var{label}, asign@'andole a su vez una etiqueta de ecuaci@'on que ser@'a mostrada al lado izquierdo de la misma. La etiqueta de la expresi@'on en TeX es la misma que la de Maxima.

@var{destination} puede ser tanto un flujo de salida como el nombre de un fichero.

Si @var{destination} es el nombre de un fichero, @code{tex} a@~nade la salida al fichero.
Las funciones @code{openw} y @code{opena} crean flujos de salida.

Las instrucciones @code{tex (@var{expr}, false)} y @code{tex (@var{label}, false)}
devuelven el c@'odigo TeX en formato de cadena.

La funci@'on @code{tex} eval@'ua su primer argumento tras
comprobar si se trata de una etiqueta. La doble comilla simple @code{''} 
fuerza la evaluaci@'on del argumento, anulando la comprobaci@'on sobre la etiqueta.

V@'ease tambi@'en @code{texput}.

Ejemplos:

@example
(%i1) integrate (1/(1+x^3), x);
                                    2 x - 1
                  2            atan(-------)
             log(x  - x + 1)        sqrt(3)    log(x + 1)
(%o1)      - --------------- + ------------- + ----------
                    6             sqrt(3)          3
(%i2) tex (%o1);
$$-@{@{\log \left(x^2-x+1\right)@}\over@{6@}@}+@{@{\arctan \left(@{@{2\,x-1
 @}\over@{\sqrt@{3@}@}@}\right)@}\over@{\sqrt@{3@}@}@}+@{@{\log \left(x+1\right)
 @}\over@{3@}@}\leqno@{\tt (\%o1)@}$$
(%o2)                          (\%o1)
(%i3) tex (integrate (sin(x), x));
$$-\cos x$$
(%o3)                           false
(%i4) tex (%o1, "foo.tex");
(%o4)                          (\%o1)
@end example

@code{tex (@var{expr}, false)} devuelve el c@'odigo TeX en formato de cadena.

@c ===beg===
@c S : tex (x * y * z, false);
@c S;
@c ===end===
@example
(%i1) S : tex (x * y * z, false);
(%o1) $$x\,y\,z$$
(%i2) S;
(%o2) $$x\,y\,z$$
@end example
@end deffn




@deffn {Funci@'on} tex1 (@var{e})
Devuelve una cadena con el c@'odigo TeX de la expresi@'on @var{e}.
El c@'odigo TeX no se encierra entre delimitadores para una ecuaci@'on
ni cualesquiera otros entornos.

Ejemplo:

@c ===beg===
@c tex1 (sin(x) + cos(x));
@c ===end===
@example
(%i1) tex1 (sin(x) + cos(x));
(%o1)                     \sin x+\cos x
@end example
@end deffn


@deffn {Funci@'on} texput (@var{a}, @var{s})
@deffnx {Funci@'on} texput (@var{a}, @var{f})
@deffnx {Funci@'on} texput (@var{a}, @var{s}, @var{operator_type})
@deffnx {Funci@'on} texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)
@deffnx {Funci@'on} texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)

Establece el formato en TeX del @'atomo @var{a}, el cual puede ser un
s@'{@dotless{i}}mbolo o el nombre de un operador.

La instrucci@'on @code{texput (@var{a}, @var{s})} hace que la funci@'on
@code{tex} introduzca @var{s} en la salida TeX en el lugar de @var{a}.

La instrucci@'on @code{texput (@var{a}, @var{f})} hace que @code{tex} llame
a la funci@'on @var{f} para que genere c@'odigo TeX. La funci@'on @var{f} 
debe aceptar un @'unico argumento, el cual es una expresi@'on que tenga como
operador @var{a} y que devuelva una cadena con el c@'odigo TeX. Esta funci@'on
puede llamar a @code{tex1} para generar el c@'odigo TeX para los argumentos
de la expresi@'on de entrada.

La instrucci@'on @code{texput (@var{a}, @var{s}, @var{operator_type})},
en la que @var{operator_type} es @code{prefix}, @code{infix} o
@code{postfix}, @code{nary} o @code{nofix},hace que la funci@'on
@code{tex} introduzca @var{s} en la salida TeX en el lugar de @var{a},
coloc@'andolo en el lugar correcto.

La instrucci@'on @code{texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)}
hace que la funci@'on @code{tex} introduzca @var{s_1} y @var{s_2} en la
salida TeX a los lados de los argumentos de @var{a}. Si son m@'as de uno,
los argumentos se separan por comas.

La instrucci@'on @code{texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}],
matchfix)} hace que la funci@'on @code{tex} introduzca @var{s_1} y
@var{s_2} en la salida TeX a los lados de los argumentos de @var{a},
con @var{s_3} separando los argumentos.

Ejemplos:

Asigna c@'odigo TeX para una variable.
@c ===beg===
@c texput (me,"\\mu_e");
@c tex (me);
@c ===end===

Llama a una funci@'on que genera c@'odigo TeX.

@c ===beg===
@c texfoo (e) := block ([a, b], [a, b] : args (e),
@c   concat ("\\left[\\stackrel{", tex1 (b), "}{", tex1 (a), "}\\right]"))$
@c texput (foo, texfoo);
@c tex (foo (2^x, %pi));
@c ===end===
@example
(%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
  concat ("\\left[\\stackrel@{", tex1 (b), 
          "@}@{", tex1 (a), "@}\\right]"))$
(%i2) texput (foo, texfoo);
(%o2)                        texfoo
(%i3) tex (foo (2^x, %pi));
$$\left[\stackrel@{\pi@}@{2^@{x@}@}\right]$$
(%o3)                         false
@end example

@example
(%i1) texput (me,"\\mu_e");
(%o1)                         \mu_e
(%i2) tex (me);
$$\mu_e$$
(%o2)                         false
@end example

Asigna c@'odigo TeX para una funci@'on ordinaria (no para un operador).
@c ===beg===
@c texput (lcm, "\\mathrm{lcm}");
@c tex (lcm (a, b));
@c ===end===

@example
(%i1) texput (lcm, "\\mathrm@{lcm@}");
(%o1)                     \mathrm@{lcm@}
(%i2) tex (lcm (a, b));
$$\mathrm@{lcm@}\left(a , b\right)$$
(%o2)                         false
@end example

Asigna c@'odigo TeX para un operador prefijo.
@c ===beg===
@c prefix ("grad");
@c texput ("grad", " \\nabla ", prefix);
@c tex (grad f);
@c ===end===

@example
(%i1) prefix ("grad");
(%o1)                         grad
(%i2) texput ("grad", " \\nabla ", prefix);
(%o2)                        \nabla 
(%i3) tex (grad f);
$$ \nabla f$$
(%o3)                         false
@end example

Asigna c@'odigo TeX para un operador infijo.
@c ===beg===
@c infix ("~");
@c texput ("~", " \\times ", infix);
@c tex (a ~ b);
@c ===end===

@example
(%i1) infix ("~");
(%o1)                           ~
(%i2) texput ("~", " \\times ", infix);
(%o2)                        \times 
(%i3) tex (a ~ b);
$$a \times b$$
(%o3)                         false
@end example

Asigna c@'odigo TeX para un operador postfijo..
@c ===beg===
@c postfix ("##");
@c texput ("##", "!!", postfix);
@c tex (x ##);
@c ===end===

@example
(%i1) postfix ("##");
(%o1)                          ##
(%i2) texput ("##", "!!", postfix);
(%o2)                          !!
(%i3) tex (x ##);
$$x!!$$
(%o3)                         false
@end example

Asigna c@'odigo TeX para un operador n-ario.
@c ===beg===
@c nary ("@@");
@c texput ("@@", " \\circ ", nary);
@c tex (a @@ b @@ c @@ d);
@c ===end===

@example
(%i1) nary ("@@@@");
(%o1)                          @@@@
(%i2) texput ("@@@@", " \\circ ", nary);
(%o2)                         \circ 
(%i3) tex (a @@@@ b @@@@ c @@@@ d);
$$a \circ b \circ c \circ d$$
(%o3)                         false
@end example

Asigna c@'odigo TeX para un operador "no-fijo".
@c ===beg===
@c nofix ("foo");
@c texput ("foo", "\\mathsc{foo}", nofix);
@c tex (foo);
@c ===end===

@example
(%i1) nofix ("foo");
(%o1)                          foo
(%i2) texput ("foo", "\\mathsc@{foo@}", nofix);
(%o2)                     \mathsc@{foo@}
(%i3) tex (foo);
$$\mathsc@{foo@}$$
(%o3)                         false
@end example

Asigna c@'odigo TeX para un operador "bi-fijo" (matchfix).
@c ===beg===
@c matchfix ("<<", ">>");
@c texput ("<<", [" \\langle ", " \\rangle "], matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], 
@c       matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c ===end===

@example
(%i1) matchfix ("<<", ">>");
(%o1)                          <<
(%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
(%o2)                [ \langle ,  \rangle ]
(%i3) tex (<<a>>);
$$ \langle a \rangle $$
(%o3)                         false
(%i4) tex (<<a, b>>);
$$ \langle a , b \rangle $$
(%o4)                         false
(%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
      matchfix);
(%o5)           [ \langle ,  \rangle ,  \, | \,]
(%i6) tex (<<a>>);
$$ \langle a \rangle $$
(%o6)                         false
(%i7) tex (<<a, b>>);
$$ \langle a \, | \,b \rangle $$
(%o7)                         false
@end example
@end deffn




@deffn {Funci@'on} get_tex_environment (@var{op})
@deffnx {Funci@'on} set_tex_environment (@var{op}, @var{before}, @var{after})

Gestiona el entorno de las salidas TeX que se obtienen de la funci@'on @code{tex}.
El entorno TeX est@'a formado por dos cadenas: una que se escribe antes que
cualquier salida en TeX, y otra que se escribe despu@'es.

@code{get_tex_environment} devuelve el entorno TeX que se aplica al operador @var{op}.
Si no se ha asignado ning@'un entorno, devolver@'a el que tenga por defecto.

@code{set_tex_environment} asigna el entorno TeX al operador @var{op}.

Ejemplos:

@c ===beg===
@c get_tex_environment (":=");
@c tex (f (x) := 1 - x);
@c set_tex_environment (":=", "$$", "$$");
@c tex (f (x) := 1 - x);
@c ===end===
@example
(%i1) get_tex_environment (":=");
(%o1) [
\begin@{verbatim@}
, ;
\end@{verbatim@}
]
(%i2) tex (f (x) := 1 - x);

\begin@{verbatim@}
f(x):=1-x;
\end@{verbatim@}

(%o2)                         false
(%i3) set_tex_environment (":=", "$$", "$$");
(%o3)                       [$$, $$]
(%i4) tex (f (x) := 1 - x);
$$f(x):=1-x$$
(%o4)                         false
@end example
@end deffn

@deffn {Funci@'on} get_tex_environment_default ()
@deffnx {Funci@'on} set_tex_environment_default (@var{before}, @var{after})

Gestiona el entorno de las salidas TeX que se obtienen de la funci@'on @code{tex}.
El entorno TeX est@'a formado por dos cadenas: una que se escribe antes que
cualquier salida en TeX, y otra que se escribe despu@'es.

@code{get_tex_environment_default} devuelve el entorno TeX que se aplica
a expresiones para las cuales el operador de mayor rango no tiene entorno
TeX asignado (mediante @code{set_tex_environment}).

@code{set_tex_environment_default} asigna el entorno TeX por defecto.

Ejemplos:

@c ===beg===
@c get_tex_environment_default ();
@c tex (f(x) + g(x));
@c set_tex_environment_default ("\\begin{equation}
@c ", "
@c \\end{equation}");
@c tex (f(x) + g(x));
@c ===end===
@example
(%i1) get_tex_environment_default ();
(%o1)                       [$$, $$]
(%i2) tex (f(x) + g(x));
$$g\left(x\right)+f\left(x\right)$$
(%o2)                         false
(%i3) set_tex_environment_default ("\\begin@{equation@}
", "
\\end@{equation@}");
(%o3) [\begin@{equation@}
, 
\end@{equation@}]
(%i4) tex (f(x) + g(x));
\begin@{equation@}
g\left(x\right)+f\left(x\right)
\end@{equation@}
(%o4)                         false
@end example
@end deffn






@deffn {Funci@'on} with_stdout (@var{f}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
@deffnx {Funci@'on} with_stdout (@var{s}, @var{expr_1}, @var{expr_2}, @var{expr_3}, ...)
Eval@'ua  @var{expr_1}, @var{expr_2}, @var{expr_3}, ...
y escribe los resultados en el fichero @var{f} o flujo de salida @var{s}.
Las expresiones que se eval@'uan no se escriben. La salida puede generarse por medio
de @code{print}, @code{display}, @code{grind} entre otras funciones.

La variable global @code{file_output_append} controla si @code{with_stdout}
a@~nade o reinicia el contenido del fichero de salida @var{f}.
Si @code{file_output_append} vale @code{true}, @code{with_stdout} a@~nade
contenido al fichero de salida. En cualquier caso, @code{with_stdout}
crea el fichero si @'este no existe.

La funci@'on @code{with_stdout} devuelve el valor de su @'ultimo argumento.

V@'ease tambi@'en @code{writefile}.

@c THIS DOESN'T SEEM VERY IMPORTANT TO MENTION ...
@c Note the binding of display2d to be
@c false, otherwise the printing will have things like "- 3" instead
@c of "-3".
@c
@example
@c THIS EXAMPLE USES SOME UNIX-ISH CONSTRUCTS -- WILL IT WORK IN WINDOWS ???
@c ALSO IT'S SORT OF COMPLICATED AND THE SIMPLER SECOND EXAMPLE ILLUSTRATES with_stdout BETTER !!!
@c mygnuplot (f, var, range, number_ticks) :=
@c  block ([numer:true, display2d:false],
@c  with_stdout("tmp.out",
@c    dx: (range[2]-range[1])/number_ticks,
@c    for x: range[1] thru range[2] step dx
@c       do print (x, at (f, var=x))),
@c  system ("echo \"set data style lines; set title '", f,"' ;plot '/tmp/gnu'
@c ;pause 10 \" | gnuplot"))$
(%i1) with_stdout ("tmp.out", 
                   for i:5 thru 10 do print (i, "! yields", i!))$
(%i2) printfile ("tmp.out")$
5 ! yields 120 
6 ! yields 720 
7 ! yields 5040 
8 ! yields 40320 
9 ! yields 362880 
10 ! yields 3628800
@end example
@end deffn




@deffn {Funci@'on} writefile (@var{filename})
Comienza escribiendo una transcripci@'on de la sesi@'on de Maxima en el archivo @var{filename}.
Cualquier interacci@'on entre Maxima y el usuario se almacena tambi@'en en este archivo, tal como aparece en la consola.

Puesto que la transcripci@'on se escribe en el formato de salida a la consola, su contenido no es interpretable por Maxima.
Para hacer un archivo que contenga expresiones que puedan ser nuevamente cargadas en Maxima, v@'eanse @code{save} y @code{stringout}; la funci@'on @code{save} almacena expresiones en formato Lisp, mientras que @code{stringout} lo hace en formato Maxima.

El resultado de ejecutar @code{writefile} cuando el archivo @var{filename} ya existe depende del entorno Lisp operativo; el contenido anterior puede ser sobreescrito o ampliado con la sesi@'on actual. La funci@'on @code{appendfile} siempre a@~nade la sesi@'on al contenido actual.

Puede ser @'util ejecutar @code{playback} despu@'es de @code{writefile} para guardar las interacciones previas de la sesi@'on. Puesto que  @code{playback} muestra solamente las variables de entrada y salida (@code{%i1}, @code{%o1}, etc.),
cualquier salida generada por una sentencia de impresi@'on desde dentro de una funci@'on no es mostrada por @code{playback}.

La funci@'on @code{closefile} cierra los archivos abiertos por @code{writefile} o @code{appendfile}.
@end deffn

