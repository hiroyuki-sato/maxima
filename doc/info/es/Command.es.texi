@c English version 2011-07-24.
@menu
* Introducci@'on a la l@'{@dotless{i}}nea de comandos::
* Funciones y variables para la l@'{@dotless{i}}nea de comandos::
* Funciones y variables para la impresi@'on::
@end menu










@node Introducci@'on a la l@'{@dotless{i}}nea de comandos, Funciones y variables para la l@'{@dotless{i}}nea de comandos, L@'{@dotless{i}}nea de comandos, L@'{@dotless{i}}nea de comandos

@section Introducci@'on a la l@'{@dotless{i}}nea de comandos


@subheading Consola

Existen distintos interfaces para Maxima, tales como wxMaxima, Xmaxima, Imaxima
y la consola o terminal de texto.

La consola trabaja en modo texto, al tiempo que para introducir instrucciones
con ayuda de un men@'u y obtener resultados en modo gr@'afico es necesario instalar
otros interfaces.

A lo largo de este manual se utilizar@'a la consola, la cual est@'a disponible en
cualquiera de los sistemas operativos en los que trabaja Maxima. El usuario puede
introducir todas las funciones de Maxima desde la consola; en el modo texto, los
resultados se devolver@'an normalmente en un formato ASCII bidimensional, mientras
que los gr@'aficos necesitan de un programa adicional tal como Gnuplot.

@subheading Entrada, Evaluaci@'on, Simplificaci@'on y Salida

Desde que el usuario introduce una solicitud de c@'alculo hasta que obtiene el
resultado en la consola, se desarrolla un proceso que consta de cuatro fases:

@enumerate
@item
Bien sea desde un teclado o desde un fichero se lee una expresi@'on que el
analizador sint@'actico se encargar@'a de transformar en una cierta representaci@'on
interna. En esta primera fase, se utilizan principalmente operadores tales
como "+", "/" o "do".

@item
La expresi@'on le@'{@dotless{i}}da por el analizador sint@'actico es evaluada
durante la segunda fase. Las variables se substituyen por sus valores y se
ejecutan funciones tales como la derivaci@'on o la integraci@'on. El resultado 
de esta fase es una expresi@'on evaluada.

@item
La expresi@'on evaluada de la fase anterior se simplifica en esta tercera fase,
en la que una expresi@'on tal como @code{a+a} se reduce a @code{2*a}, o
@code{sin(%pi/2)} se simplifica a @code{1}.

@item
Tras la tercera fase se dispone de una expresi@'on que ha sido evaluada y
posteriormente simplificada. Ya en la cuarta y @'ultima fase, se prepara
el resultado para ser mostrado a trav@'es de la consola.
@end enumerate

El usuario puede tomar el control en cualquiera de las cuatro fases reci@'en
descritas. En diferentes cap@'{@dotless{i}}tulos de este manual se detallan estas posibilidades,
pero en @'este se describen aquellas instrucciones relacionadas con las fases
primera y cuarta, relacionadas con la entrada y salida a trav@'es de la consola.
Los cap@'{@dotless{i}}tulos sobre Evaluaci@'on y Simplificaci@'on tratan
de las otras dos fases intermedias.

@subheading Marcas

Maxima almacena todas las entradas con la marca @code{%i} seguida de un
n@'umero entero en orden creciente, as@'{@dotless{i}} como las salidas o resultados con la
marca @code{%o} tambi@'en seguida de un n@'umero de orden. Adem@'as,
ciertas funciones utilizan la marca intermedia @code{%t}. Otras variables
del sistema almacenan el @'ultimo resultado devuelto por Maxima o la
@'ultima entrada efectuada por el usuario. Los siguientes s@'{@dotless{i}}mbolos
indican variables y funciones para la gesti@'on de las marcas:

@verbatim
   __          _        
   %           %%           %th
   inchar      linechar     outchar
   linenum     nolabels
@end verbatim

@subheading Listas informativas

Maxima gestiona listas informativas, cuyos nombres se guardan en la variable
del sistema @code{infolists}. En el presente cap@'{@dotless{i}}tulo se
describen las listas @code{labels}, @code{values} y @code{myoptions}.
Los siguientes s@'{@dotless{i}}mbolos indican variables y funciones
relacionadas con las listas informativas y variables opcionales.

@verbatim
   infolists     labels        values 
   myoptions     optionset
@end verbatim

Otras listas informativas, que se describir@'an en otros cap@'{@dotless{i}}tulos,
son:

@verbatim
   functions      arrays         macros
   rules          aliases        dependencies 
   gradefs        props          let_rule_packages
   structures     namespaces  
@end verbatim

@subheading Borrado y reiniciaci@'on

A fin de establecer el contexto en el que trabaje Maxima, en el que
no haya variables o funciones definidas, o en el que se eliminen
hip@'otesis, propiedades o definiciones concretas, se dispone de las
siguientes funciones:

@verbatim
   kill     reset     reset_verbosely
@end verbatim

@subheading Otras instrucciones

Se puede acceder a la documentaci@'on con los s@'{@dotless{i}}mbolos
@code{?} y @code{??}. En caso de que se utilice @code{?} a modo
de prefijo de un s@'{@dotless{i}}mbolo, @'este se interpretar@'a como
s@'{@dotless{i}}mbolo de Lisp. Hay instrucciones para terminar una sesi@'on de 
Maxima o para cambiar a una sesi@'on de Lisp. Tambi@'en es posible conocer el tiempo
que ha necesitado Maxima para realizar un c@'alculo. Para este tipo de cuestiones,
Maxima dispone de las siguientes instrucciones:

@verbatim
   ?            ??
   playback     prompt     showtime
   quit         to_lisp
@end verbatim

Las funciones @code{read} und @code{readonly} imprimen texto en la consola y
leen la informaci@'on introducida por el usuario.

@subheading Salida por consola

Antes de mostrar un resultado, se transforma su representaci@'on interna 
a otra externa. Por ejemplo, la representaci@'on interna de @code{sqrt(x)}
es @code{x^(1/2)}, y ambos formatos pueden ser devueltos por Maxima en
funci@'on del valor que guarde la variable opcional @code{sqrtdispflag}.

Los siguientes s@'{@dotless{i}}mbolos y variables opcionales controlan
la salida de resultados por consola:

@verbatim
   %edispflag         absboxchar       display2d
   display_format_internal             exptdispflag
   expt               nexpt            ibase
   linel              lispdisp         negsumdispflag
   obase              pfeformat        powerdisp
   sqrtdispflag       stardisp         ttyoff
@end verbatim

Con las siguientes funciones es posible formatear los resultados:

@verbatim
   disp               display          dispterms
   grind              ldisp            ldisplay
   print
@end verbatim
























@node Funciones y variables para la l@'{@dotless{i}}nea de comandos, Funciones y variables para la impresi@'on, Introducci@'on a la l@'{@dotless{i}}nea de comandos, L@'{@dotless{i}}nea de comandos

@section Funciones y variables para la l@'{@dotless{i}}nea de comandos


@defvr {Variable del sistema} __
@ifinfo
@vrindex Expresi@'on actual de entrada
@end ifinfo

@code{__} es la expresi@'on de entrada que est@'a siendo actualmente evaluada.
Esto es, mientras se est@'a evaluando una expresi@'on de entrada, 
@code{__} es igual a @var{expr}.

A @code{__} se le asigna la expresi@'on de entrada antes de que @'esta sea 
simplificada o evaluada. Sin embargo, el valor de @code{__} es simplificado,
pero no evaluado, cuando su valor es mostrado en el terminal.

La variable @code{__} es reconocida por  @code{batch} y por @code{load}.
Cuando un fichero es procesado por @code{batch}, la variable @code{__}
tiene el mismo significado que en el modo interactivo.
Cuando un fichero es procesado por @code{load}, a la variable @code{__}
se le asigna la @'ultima expresi@'on introducida, bien desde el modo
interactivo, bien en un fichero por lotes; en ning@'un caso se le asigna 
a @code{__} una expresi@'on de entrada del fichero que est@'a siendo procesado.
En particular, si @code{load (@var{filename})} es ejecutado desde el modo
interactivo, entonces @code{__} almacena la expresi@'on @code{load (@var{filename})}
mientras el fichero est@'a siendo procesado.

V@'eanse tambi@'en @code{_} y @code{%}.

Ejemplos:

@c ===beg===
@c print ("I was called as", __);
@c foo (__);
@c g (x) := (print ("Current input expression =", __), 0);
@c [aa : 1, bb : 2, cc : 3];
@c (aa + bb + cc)/(dd + ee + g(x));
@c ===end===
@example
(%i1) print ("I was called as", __);
I was called as print(I was called as, __) 
(%o1)              print(I was called as, __)
(%i2) foo (__);
(%o2)                     foo(foo(__))
(%i3) g (x) := (print ("Current input expression =", __), 0);
(%o3) g(x) := (print("Current input expression =", __), 0)
(%i4) [aa : 1, bb : 2, cc : 3];
(%o4)                       [1, 2, 3]
(%i5) (aa + bb + cc)/(dd + ee + g(x));
                            cc + bb + aa
Current input expression = -------------- 
                           g(x) + ee + dd
                                6
(%o5)                        -------
                             ee + dd
@end example

@end defvr





@defvr {Variable del sistema} _
@ifinfo
@vrindex Entrada anterior
@end ifinfo

El s@'{@dotless{i}}mbolo @code{_} representa la @'ultima expresi@'on de entrada (esto es, @code{%i1}, @code{%i2}, @code{%i3}, ...).

Al s@'{@dotless{i}}mbolo @code{_} se le asigna la expresi@'on de entrada antes de que @'esta sea simplificada o evaluada. Sin embargo, el valor de @code{_} se simplifica (pero no se eval@'ua) cuando se muestra en el terminal.

La variable @code{_} es reconocida por  @code{batch} y por @code{load}.
Cuando un fichero es procesado por @code{batch}, la variable @code{_}
tiene el mismo significado que en el modo interactivo.
Cuando un fichero es procesado por @code{load}, a la variable @code{_}
se le asigna la @'ultima expresi@'on introducida, bien desde el modo
interactivo, bien en un fichero por lotes; en ning@'un caso se le asigna 
a @code{_} una expresi@'on de entrada del fichero que est@'a siendo procesado.

V@'eanse tambi@'en @code{__} y @code{%}.

Ejemplos:

@c ===beg===
@c 13 + 29;
@c :lisp $_
@c _;
@c sin (%pi/2);
@c :lisp $_
@c _;
@c a: 13$
@c b: 29$
@c a + b;
@c :lisp $_
@c _;
@c a + b;
@c ev (_);
@c ===end===
@example
(%i1) 13 + 29;
(%o1)                          42
(%i2) :lisp $_
((MPLUS) 13 29)
(%i2) _;
(%o2)                          42
(%i3) sin (%pi/2);
(%o3)                           1
(%i4) :lisp $_
((%SIN) ((MQUOTIENT) $%PI 2))
(%i4) _;
(%o4)                           1
(%i5) a: 13$
(%i6) b: 29$
(%i7) a + b;
(%o7)                          42
(%i8) :lisp $_
((MPLUS) $A $B)
(%i8) _;
(%o8)                         b + a
(%i9) a + b;
(%o9)                          42
(%i10) ev (_);
(%o10)                         42
@end example

@end defvr



@defvr {Variable del sistema} %
@ifinfo
@vrindex Salida anterior
@end ifinfo

El s@'{@dotless{i}}mbolo @code{%} representa la expresi@'on de salida (esto es, @code{%o1}, @code{%o2}, @code{%o3}, ...)
m@'as reciente calculada por Maxima, independientemente de que la haya mostrado o no.

La variable @code{%} es reconocida por  @code{batch} y por @code{load}.
Cuando un fichero es procesado por @code{batch}, la variable @code{%}
tiene el mismo significado que en el modo interactivo.
Cuando un fichero es procesado por @code{load}, a la variable @code{%}
se le asigna la @'ultima expresi@'on introducida, bien desde el modo
interactivo, bien en un fichero por lotes; en ning@'un caso se le asigna 
a @code{%} una expresi@'on de entrada del fichero que est@'a siendo procesado.

V@'eanse tambi@'en @code{_}, @code{%%} y @code{%th}.

@end defvr




@defvr {Variable del sistema} %%
@ifinfo
@vrindex Resultado anterior en una sentencia compuesta
@end ifinfo

En una sentencia compuesta, como @code{block}, @code{lambda} o 
@code{(@var{s_1}, ..., @var{s_n})}, @code{%%} es el valor de la sentencia previa.
Por ejemplo,

Cuando se escribe al comienzo de una sentencia compuesta, o fuera de ella,
@code{%%} no est@'a definido.

@code{%%} es reconocido por @code{batch} y @code{load}, interpret@'andose
de la misma manera que se acaba de indicar.

V@'ease tambi@'en @code{%}

Ejemplos:

Los siguientes dos ejemplos devuelven el mismo resultado.

@example
(%i1) block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
                               21
(%o1)                          --
                               2
(%i2) block ([prev], prev: integrate (x^5, x),
               ev (prev, x=2) - ev (prev, x=1));
                               21
(%o2)                          --
                               2

@end example

Una sentencia compuesta puede contener otras sentencias compuestas.
Independientemente de que una sentencia sea simple o compuesta, @code{%%} es 
el valor de la sentencia previa.

@example
(%i3) block (block (a^n, %%*42), %%/6);
                                 n
(%o3)                         7 a
@end example

Dentro de una sentencia compuesta, el valor de @code{%%} puede inspeccionarse en un punto de interrupci@'on que se abra ejecutando la funci@'on @code{break}. Por ejemplo, escribiendo @code{%%;} en el siguiente ejemplo se obtiene @code{42}.

@example
(%i4) block (a: 42, break ())$

Entering a Maxima break point. Type 'exit;' to resume.
_%%;
42
_
@end example

@end defvr



@deffn {Funci@'on} %th (@var{i})
@ifinfo
@fnindex i-@'esima salida anterior
@end ifinfo

Es el valor de la expresi@'on de la @var{i}-@'esima salida anterior.
Esto es, si la siguiente expresi@'on a calcular es la salida @var{n}-@'esima,
@code{%th (@var{m})} es la salida  (@var{n} - @var{m})-@'esima.

@code{%th} es reconocido por @code{batch} y @code{load}, interpret@'andose
de la misma manera que se acaba de indicar. Cuando un fichero es procesado
por @code{load}, @code{%th} se refiere a los c@'alculos m@'as recientes;
@code{%th} no hace referencia a las expresiones de salida incluidas en el
propio fichero que se est@'a procesando.

V@'eanse tambi@'en @code{%} y @code{%%}

Ejemplo:

@code{%th} es @'util en ficheros @code{batch} para hacer referencia a grupos de resultados
reci@'en obtenidos.  En este ejemplo se asigna a @code{s} la suma de los cinco resultados.

@example
(%i1) 1;2;3;4;5;
(%o1)                           1
(%o2)                           2
(%o3)                           3
(%o4)                           4
(%o5)                           5
(%i6) block (s: 0, for i:1 thru 5 do s: s + %th(i), s);
(%o6)                          15
@end example
@end deffn



@deffn {S@'{@dotless{i}}mbolo especial} ?
@ifinfo
@fnindex Busca en la documentaci&oacute;n
@end ifinfo

Como prefijo de una funci@'on o nombre de variable, @code{?} significa que el nombre es de Lisp, no de Maxima.
Por ejemplo, @code{?round} representa la funci@'on de Lisp @code{ROUND}.
V@'ease @code{Lisp y Maxima} para m@'as informaci@'on.

La notaci@'on @code{? word} (un s@'{@dotless{i}}mbolo de interrogaci@'on
seguido de una palabra y separados por un espacio)
equivale a @code{describe ("word")}.
El s@'{@dotless{i}}mbolo de interrogaci@'on debe escribirse al
comienzo de la l@'{@dotless{i}}nea de entrada; en caso contrario
no se reconoce como una solicitud de documentaci@'on.

@end deffn

@deffn {S@'{@dotless{i}}mbolo especial} ??
@ifinfo
@fnindex Busca coincidencias inexactas en la documentaci&oacute;n
@end ifinfo

La notaci@'on @code{?? palabra} (@code{??} seguido de un espacio
y una palabra) equivale a @code{describe("palabra", inexact)}.
El s@'{@dotless{i}}mbolo de interrogaci@'on debe escribirse al
comienzo de la l@'{@dotless{i}}nea de entrada; en caso contrario
no se reconoce como una solicitud de documentaci@'on.

@end deffn



@defvr {Variable opcional} inchar
Valor por defecto: @code{%i}

La variable @code{inchar} es el prefijo de las etiquetas de las
expresiones introducidas por el usuario. Maxima crea autom@'aticamente 
una etiqueta para cada expresi@'on de entrada concatenando @code{inchar} 
y @code{linenum}.

A @code{inchar} se le puede asignar cualquier s@'{@dotless{i}}mbolo 
o cadena, no necesariamente un carac@'acter sencillo. Puesto que
internamente Maxima solo tiene en cuenta el primer car@'acter del
prefijo, los prefijos @code{inchar}, @code{outchar} y @code{linechar}
deben comenzar con caracteres diferentes; en caso contrario, sentencias
como @code{kill(inlables)} pueden dar resultados inesperados.

V@'ease tambi@'en @code{labels}.

Ejemplo:

@c ===beg===
@c inchar: "input";
@c expand((a+b)^3);
@c ===end===
@example
(%i1) inchar: "input";
(%o1)                         input
(input2) expand((a+b)^3);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(input3)
@end example

@end defvr


@defvr {Variable del sistema} infolists
Valor por defecto: @code{[]}

La variable @code{infolists} es una lista con los nombres de todas las listas que guardan informaci@'on sobre Maxima. Estas son:

@table @code
@item labels
Todas las etiquetas @code{%i}, @code{%o} y @code{%t} con valores asignados.
@item values
Todos los @'atomos que son variables de usuario, no opciones de Maxima creadas con  @code{:} o @code{::}.
@item functions
Todas las funciones de usuario creadas con @code{:=} o @code{define}.
@item arrays
Arreglos declarados y no declarados, creados por @code{:}, @code{::} o @code{:=}.
@c AREN'T THERE OTHER MEANS OF CREATING ARRAYS ??
@item macros
Cualquier macro definida por el usuario.
@item myoptions
Todas las opciones inicializadas por el usuario, independientemente de que posteriormente hayan sido devueltas a sus valores por defecto.
@item rules
Reglas de patrones y simplificaci@'on definidas por el usuario, creadas con @code{tellsimp}, @code{tellsimpafter}, @code{defmatch} o @code{defrule}.
@item aliases
@'Atomos que tienen un "alias" definido por el usuario, creado por las funciones @code{alias}, @code{ordergreat} o @code{orderless} o por haber declarado el @'atomo como @code{noun} (nombre) con @code{declare}.
@item dependencies
@'Atomos que tienen dependencias funcionales, creados por las funciones @code{depends} o @code{gradef}.
@item gradefs
Funciones que tienen derivadas definidas por el usuario, creadas por la funci@'on @code{gradef}.
@item props
Todos los @'atomos que tengan cualquier propiedad que no sea de las mencionadas hasta ahora, como las establecidas por @code{atvalue}, @code{matchdeclare}, etc., as@'{@dotless{i}} como propiedadas especificadas en la funci@'on @code{declare}.
@item let_rule_packages
Todos los paquetes de reglas @code{let} definidos por el usuario, junto con el paquete especial @code{default_let_rule_package}; @code{default_let_rule_package} es el nombre del paquete de reglas utilizado cuando no se use ning@'un otro especificado por el usuario.
@end table

@end defvr



@deffn {Funci@'on} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Funci@'on} kill (labels)
@deffnx {Funci@'on} kill (inlabels, outlabels, linelabels)
@deffnx {Funci@'on} kill (@var{n})
@deffnx {Funci@'on} kill ([@var{m}, @var{n}])
@deffnx {Funci@'on} kill (values, functions, arrays, ...)
@deffnx {Funci@'on} kill (all)
@deffnx {Funci@'on} kill (allbut (@var{a_1}, ..., @var{a_n}))
Elimina todas las asignaciones (valor, funci@'on, arreglo o regla) hechas a los
argumentos @var{a_1}, ..., @var{a_n}.
Un argumento @var{a_k} puede ser un s@'{@dotless{i}}mbolo o el elemento
de un array. Si @var{a_k} es elemento de un array, @code{kill} elimina la
asignaci@'on hecha a este elemento sin afectar al resto del array.

Se reconocen varios argumentos especiales. 
Se pueden combinar diferentes clases de argumentos, 
como por ejemplo, @code{kill (inlabels, functions, allbut (foo, bar))}.

La instrucci@'on @code{kill (labels)} borra todas las asignaciones asociadas
a las etiquetas de entrada, de salida e intermedias creadas hasta el
momento. La instrucci@'on @code{kill (inlabels)} elimina @'unicamente
las asignaciones de las etiquetas de entrada que comienzan con el
valor actual de @code{inchar}. Del mismo modo, @code{kill (outlabels)}
elimina @'unicamente las asignaciones de las etiquetas de salida
que comienzan con el valor actual de @code{outchar}. Finalmente,
@code{kill (linelabels)} elimina @'unicamente las asignaciones
de las etiquetas de las expresiones intermedias
que comienzan con el valor actual de @code{linechar}.

La instrucci@'on @code{kill (@var{n})}, siendo @var{n} un entero,
elimina las asignaciones de las @'ultimas @var{n} etiquetas, tanto
de entrada como de salida.

La instrucci@'on @code{kill ([@var{m}, @var{n}])} elimina las asignaciones
hechas a las etiquetas de entrada y salida desde la @var{m} hasta la@var{n}.

La instrucci@'on @code{kill (@var{infolist})}, siendo @var{infolist} 
cualquier elemento de @code{infolists} (como @code{values}, @code{functions} 
o @code{arrays}), elimina todas las asignaciones hechas a los elementos de
@var{infolist}. V@'ease tambi@'en @code{infolists}.

La instrucci@'on @code{kill (all)} elimina todas las asignaciones de
todas las variables, pero no reinicia las variables globales a sus
valores por defecto. V@'ease tambi@'en @code{reset}.

La instrucci@'on @code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
elimina las asignaciones hechas a todas las variables,
excepto a @var{a_1}, ..., @var{a_n}; la instrucci@'on
@code{kill (allbut (@var{infolist}))} elimina todas las asignaciones,
excepto las de los elementos de @var{infolist}, pudiendo ser @var{infolist}
igual a @code{values}, @code{functions}, @code{arrays}, etc.

La memoria reservada para una asignaci@'on no se libera hasta que
no se vac@'{@dotless{i}}en todos los s@'{@dotless{i}}mbolos
asociados con esta asignaci@'on; por ejemplo, para liberar la memoria
del valor de un s@'{@dotless{i}}mbolo es necesario eliminar tanto
la asignaci@'on de la etiqueta de salida que muestra el resultado,
como la del propio s@'{@dotless{i}}mbolo.

La funci@'on @code{kill} no evalua sus argumentos. 
El operador comilla-comilla, @code{'@w{}'}, obliga a que se realice la evaluaci@'on.

La llamada @code{kill (@var{symbol})} elimina todas las propiedades de @var{symbol}.
Por el contrario, @code{remvalue}, @code{remfunction}, @code{remarray} y @code{remrule}
eliminan propiedades espec@'{@dotless{i}}ficas. 

@code{kill} siempre devuelve @code{done}, incluso cuando alguno de sus 
argumentos carec@'{@dotless{i}}a de asignaci@'on previa. 

@end deffn



@deffn {Funci@'on} labels (@var{symbol})
@deffnx {Variable del sistema} labels
Retorna la lista de etiquetas de entrada, salida o de expresiones intermedias las cuales empiezan con @var{symbol}. 
T@'{@dotless{i}}picamente @var{symbol} es el valor de las variables @code{inchar}, @code{outchar} o @code{linechar}. 
El caract@'er de etiqueta puede ser pasado con o sin signo de porcentaje, 
as@'{@dotless{i}}, por ejemplo, @code{i} y @code{%i} producen el mismo resultado.  

Si ninguna etiqueta empieza con @var{symbol}, @code{labels} retorna a una
lista vac@'{@dotless{i}}a. 

La funci@'on @code{labels} no evalua su argumento.
El operador comilla-comilla, @code{'@w{}'}, obliga a que se realice la evaluaci@'on.
Por ejemplo, 
@code{labels (''inchar)} devuelve las etiquetas de entrada que empiezan con el caract@'er de etiqueta de entrada actual. 

La variable @code{labels} es una lista de las etiquetas de entrada, salida y expresiones intermedias, incluyendo todas las etiquetas anteriores en el caso de que @code{inchar}, @code{outchar} o @code{linechar} hayan sido redefinidas. 

Por defecto, Maxima muestra el resultado de cada expresi@'on introducida por el usuario, asignando al resultado una etiqueta de salida. 
La salida (es decir el resultado) puede ser suprimida terminando la expresi@'on de entrada con un @code{$} (signo de d@'olar) en vez de un @code{;} (punto y coma). 
En este caso, se crea la etiqueta de salida y se le asigna el resultado, aunque @'este no se muestre; a@'un as@'{@dotless{i}}, la etiqueta puede ser referenciada de la misma forma que se hace con aqu@'ellas cuyos resultados s@'{@dotless{i}} son mostrados.

V@'eanse tambi@'en: @code{%}, @code{%%} y @code{%th}. 

Las etiquetas de expresiones intermedias pueden ser generadas por algunas funciones. El interruptor @code{programmode} controla si @code{solve} y algunas otras funciones generan etiquetas de expresiones intermedias en vez de retornar una lista de expresiones. 
Algunas otras funciones, tales como @code{ldisplay}, siempre generan etiquetas de expresiones intermedias. 
 

V@'ease tambi@'en: @code{inchar}, @code{outchar}, @code{linechar} y @code{infolists}.

@end deffn




@defvr {Variable opcional} linechar
Valor por defecto: @code{%t}

La variable @code{linechar} es el prefijo de las etiquetas que
genera Maxima para expresiones intermedias. Cuando sea necesario,
Maxima crear@'a una etiqueta para cada expresi@'on intermedia 
concatenando @code{linechar} y @code{linenum}.

A @code{linechar} se le puede asignar cualquier s@'{@dotless{i}}mbolo 
o cadena, no necesariamente un carac@'acter sencillo. Puesto que
internamente Maxima solo tiene en cuenta el primer car@'acter del
prefijo, los prefijos @code{inchar}, @code{outchar} y @code{linechar}
deben comenzar con caracteres diferentes; en caso contrario, sentencias
como @code{kill(inlables)} pueden dar resultados inesperados.

Las expresiones intermedias pueden ser mostradas o no.
V@'eanse tambi@'en @code{programmode} y @code{labels}.

@end defvr



@defvr {Variable del sistema} linenum
El n@'umero de la l@'{@dotless{i}}nea del par de expresiones de entrada y salida actuales. 
@end defvr



@defvr {Variable del sistema} myoptions
Valor por defecto: @code{[]}

@code{myoptions} es la lista de todas las opciones que nunca fueron reconfiguradas por el usuario, aunque @'estas hayan sido reconfiguradas a su valor por defecto. 

@end defvr


@defvr {Variable opcional} nolabels
Valor por defecto: @code{false}

Cuando @code{nolabels} vale @code{true},
las etiquetas de entrada y salida 
(@code{%i} y @code{%o}, respectivamente)
son mostradas, pero a @'estas no se les 
asignan los resultados; adem@'as, las etiquetas no se
incorporan a la lista @code{labels}.
Puesto que a las etiquetas no se les asignan resultados, 
el colector de basura puede recuperar la memoria ocupada
por @'estos.

En el caso contrario, a las etiquetas de entrada y salida se les asignan los resultados correspondientes y son a@~nadidas a la lista @code{labels}.

Las etiquetas de expresiones intermedias (@code{%t}) no se ven afectadas por la variable @code{nolabels};
independientemente de que @code{nolabels} valga @code{true} o @code{false}, a las etiquetas de expresiones intermedias se les asignan siempre valores, adem@'as de ser a@~nadidas a la lista @code{labels}.

V@'eanse tambi@'en @code{batch}, @code{batchload} y @code{labels}. 

@end defvr


@defvr {Variable opcional} optionset
Valor por defecto: @code{false}

Cuando @code{optionset} tiene como valor @code{true}, Maxima imprime un
mensaje cada vez que una opci@'on de Maxima es reconfigurada. Esto es 
muy @'util si el usuario duda con frecuencia de la correctitud de alguna
opci@'on y quiere estar seguro de la variable a la que @'el asign@'o un
valor fue verdaramente una variable opci@'on (o interruptor). 

Ejemplo:

@example
(%i1) optionset:true;
assignment: assigning to option optionset
(%o1)                         true
(%i2) gamma_expand:true;
assignment: assigning to option gamma_expand
(%o2)                         true
@end example
@end defvr


@defvr {Variable opcional} outchar
Valor por defecto: @code{%o}

La variable @code{outchar} es el prefijo de las etiquetas de las 
expresiones calculadas por Maxima. Maxima crea autom@'aticamente 
una etiqueta para cada expresi@'on calculada concatenando @code{outchar}
y @code{linenum}.

A @code{outchar} se le puede asignar cualquier s@'{@dotless{i}}mbolo 
o cadena, no necesariamente un carac@'acter sencillo. Puesto que
internamente Maxima solo tiene en cuenta el primer car@'acter del
prefijo, los prefijos @code{inchar}, @code{outchar} y @code{linechar}
deben comenzar con caracteres diferentes; en caso contrario, sentencias
como @code{kill(inlables)} pueden dar resultados inesperados.

V@'ease tambi@'en @code{labels}.

Ejemplo:

@c ===beg===
@c outchar: "output";
@c expand((a+b)^3);
@c ===end===
@example
(%i1) outchar: "output";
(output1)                    output
(%i2) expand((a+b)^3);
                     3        2      2      3
(output2)           b  + 3 a b  + 3 a  b + a
(%i3)
@end example
@end defvr



@deffn {Funci@'on} playback ()
@deffnx {Funci@'on} playback (@var{n})
@deffnx {Funci@'on} playback ([@var{m}, @var{n}])
@deffnx {Funci@'on} playback ([@var{m}])
@deffnx {Funci@'on} playback (input)
@deffnx {Funci@'on} playback (slow)
@deffnx {Funci@'on} playback (time)
@deffnx {Funci@'on} playback (grind)
Muestra las entradas, salidas y expresiones intermedias 
sin recalcularlas. 
@code{playback} s@'olo muestra las expresiones asociadas con etiquetas; 
cualquier otra salida (tal como texto impreso por @code{print} o @code{describe}, o mensajes de error) no es mostrada. 
V@'ease tambi@'en: @code{labels}. 

@code{playback} no evalua sus argumentos. 
El operador comilla-comilla, @code{'@w{}'}, obliga a que se realice la evaluaci@'on.
@code{playback} siempre devuelve @code{done}. 

@code{playback ()} (sin argumentos) muestra todas las entradas, salidas y expresiones intermedias generadas hasta el momento. 
Una expresi@'on de salida es mostrada incluso si @'esta fue suprimida por el caracter de terminaci@'on @code{$}, cuando fue originalmente calculada. 

@code{playback (@var{n})}  muestra las @var{n} expresiones m@'as recientes. Cada entrada, salida y expresi@'on intermedia cuenta como una. 

@code{playback ([@var{m}, @var{n}])} muestra entradas, salidas y expresiones intermedias con los n@'umeros desde @var{m} hasta @var{n}, ambos inclusive. 

@code{playback ([@var{m}])} es equivalente a @code{playback ([@var{m}, @var{m}])};
esto usualmente imprime un par de expresiones de entrada y salida. 

@code{playback (input)} muestra todas las expresiones de entrada generadas hasta el momento. 

@code{playback (slow)} hace pausas entre expresiones y
espera a que el usuario pulse la tecla @code{enter} para continuar. 
Esto es un comportamiento similar a @code{demo}. 

@c WHAT DOES THE FOLLOWING MEAN ???
@c HAY QUE ESPERAR PARA ACLARAR ESTA PARTE
@code{playback (slow)} es muy @'util en conjunci@'on con @code{save} o
@code{stringout} cuando se crea un archivo secundario de almacenamiento con el objetivo de elegir cuidadosamente las expresiones realmente @'utiles. 

@c @code{playback (slow)} is useful in conjunction with @code{save} or @code{stringout}
@c when creating a secondary-storage file in order to pick out useful expressions.

@code{playback (time)} muestra el tiempo de computo por cada expresi@'on. 

@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} muestra las expresiones de entrada 
en el mismo formato como la funci@'on @code{grind}. 
Las expresiones de salida no se ven afectadas por la opci@'on 
@code{grind}. 
Vea @code{grind}. 
Los argumentos pueden ser combinados, por ejemplo, 
@code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@end deffn


@defvr {Variable opcional} prompt
Valor por defecto: @code{_}

@code{prompt} es el s@'{@dotless{i}}mbolo del prompt de la funci@'on @code{demo}, 
del modo @code{playback (slow)} y del bucle de interrupci@'on de Maxima (el que se invoca con @code{break}). 

@end defvr




@deffn {Funci@'on} quit ()
Termina una sesi@'on de Maxima. 
N@'otese que la funci@'on debe ser invocada como @code{quit();} o @code{quit()$}, no como @code{quit}. 

Para parar un c@'alculo muy demorado 
pulse @code{Control-C}. 
La acci@'on por defecto es retornar a prompt de Maxima. 
Si @code{*debugger-hook*} tiene como valor @code{nil},
pulsar @code{Control-C} abrir@'a el depurador de Lisp. 
Vea tambi@'en: @code{debugging}. 

@end deffn


@deffn {Funci@'on} read (@var{expr_1}, ..., @var{expr_n})
Imprime @var{expr_1}, ..., @var{expr_n} y a continuaci@'on lee una expresi@'on desde la consola y devuelve la expresi@'on evaluada. La expresi@'on termina con un punto y coma @code{;} o con el s@'{@dotless{i}}mbolo de d@'olar @code{$}.

V@'ease tambi@'en @code{readonly}.

@example
(%i1) foo: 42$ 
(%i2) foo: read ("foo vale", foo, " -- nuevo valor.")$
foo vale 42  -- nuevo valor. 
(a+b)^3;
(%i3) foo;
                                     3
(%o3)                         (b + a)
@end example

@end deffn



@deffn {Funci@'on} readonly (@var{expr_1}, ..., @var{expr_n})
Imprime @var{expr_1}, ..., @var{expr_n} y a continuaci@'on lee una expresi@'on desde la consola y devuelve la expresi@'on sin evaluar. La expresi@'on termina con un punto y coma @code{;} o con el s@'{@dotless{i}}mbolo de d@'olar @code{$}.

@example
(%i1) aa: 7$
(%i2) foo: readonly ("Introducir expresion:");
Introducir expresion: 
2^aa;
                                  aa
(%o2)                            2
(%i3) foo: read ("Introducir expresion:");
Introducir expresion: 
2^aa;
(%o3)                            128
@end example

V@'ease tambi@'en @code{read}.

@end deffn



@deffn {Funci@'on} reset ()
Reconfigura muchas variables y opciones globales y algunas otras variables a sus valores por defecto. 

@code{reset} procesa las variables que se encuentran en la lista Lisp 
@code{*variable-initial-values*}. 
La macro Lisp @code{defmvar} pone las variables en @'esta lista (entre otras acciones). 
Muchas, pero no todas, las variables y opciones globales son definidas por @code{defmvar}, y algunas variables definidas por @code{defmvar} no son ni variables ni opciones globales. 

@end deffn


@defvr {Variable opcional} showtime
Valor por defecto: @code{false}

Cuando @code{showtime} tiene como valor @code{true}, el tiempo de c@'alculo y el tiempo de retardo se imprimen junto con la salida de cada expresi@'on. 

El tiempo de c@'alculo se almacena siempre, de manera que @code{time} y @code{playback} puedan mostrar el tiempo de c@'alculo incluso cuando @code{showtime} vale @code{false}.

V@'ease tambi@'en @code{timer}.

@end defvr


@deffn {Function} to_lisp ()
Entra en el int@'erprete Lisp bajo Maxima. @code{(to-maxima)} retorna de nuevo a Maxima. 

Ejemplo:

Define una funci@'on y entra en el nivel Lisp. La definici@'on
se consulta en la lista de propiedades, luego se extrae la definici@'on
de la funci@'on, se factoriza y almacena el resultado en la variable @code{$result}.
Esta variable se puede utilizar luego una vez se haya vuelto al nivel
de Maxima.

@example
(%i1) f(x):=x^2+x;
                                         2
(%o1)                           f(x) := x  + x
(%i2) to_lisp();
Type (to-maxima) to restart, ($quit) to quit Maxima.

MAXIMA> (symbol-plist '$f)
(MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X) ((MPLUS) ((MEXPT) $X 2) $X))))
MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
MAXIMA> (to-maxima)
Returning to Maxima
(%o2)                                true
(%i3) result;
(%o3)                              x (x + 1)
@end example
@end deffn



@defvr {Variable del sistema} values
Valor inicial: @code{[]}

@code{values} es una lista de todas las variables que el usuario ha creado
(no incluye las opciones de Maxima ni los interruptores). 
La lista comprende los s@'{@dotless{i}}mbolos a los que se ha asignado un
valor mediante @code{:} o @code{::}.

Si el valor de una variable se borra con cualquiera de las instrucciones
@code{kill}, @code{remove} o @code{remvalue}, dicha variable desaparece
de la lista @code{values}.

V@'ease @code{functions} para una lista de funciones definidas por el
usuario.

Ejemplos:

Primero, @code{values} muestra los s@'{@dotless{i}}mbolos @code{a}, 
@code{b} y @code{c}, pero no @code{d}, pues no tiene valor asignado,
ni la funci@'on de usuario @code{f}. Luego los valores de las variables se
borran y @code{values} queda como una lista vac@'{@dotless{i}}a.

@c ===beg===
@c [a:99, b:: a-90, c:a-b, d, f(x):=x^2];
@c values;
@c [kill(a), remove(b,value), remvalue(c)];
@c values;
@c ===end===
@example
(%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                  2
(%o1)                     [99, 9, 90, d, f(x) := x ]
(%i2) values;
(%o2)                              [a, b, c]
(%i3) [kill(a), remove(b,value), remvalue(c)];
(%o3)                          [done, done, [c]]
(%i4) values;
(%o4)                                 []
@end example

@end defvr













@node Funciones y variables para la impresi@'on, , Funciones y variables para la l@'{@dotless{i}}nea de comandos, L@'{@dotless{i}}nea de comandos

@section Funciones y variables para la impresi@'on


@defvr {Variable opcional} %edispflag
Valor por defecto: @code{false}

Si @code{%edispflag} vale @code{true}, Maxima muestra @code{%e} elevado
a un exponente negativo como un cociente. Por ejemplo, @code{%e^-x} se
muestra como @code{1/%e^x}. V@'ease tambi@'en @code{exptdispflag}.

Ejemplo:

@c ===beg===
@c %e^-10;
@c %edispflag:true$
@c %e^-10;
@c ===end===
@example
(%i1) %e^-10;
                               - 10
(%o1)                        %e
(%i2) %edispflag:true$
(%i3) %e^-10;
                               1
(%o3)                         ----
                                10
                              %e
@end example
@end defvr



@defvr {Variable opcional} absboxchar
Valor por defecto: @code{!}

La variable @code{absboxchar} es el car@'acter utilizado para representar el valor absoluto de una expresi@'on que ocupa m@'as de una l@'{@dotless{i}}nea de altura.

Ejemplo:

@example
(%i1) abs((x^3+1));
                            ! 3    !
(%o1)                       !x  + 1!
@end example
@end defvr


@deffn {Funci@'on} disp (@var{expr_1}, @var{expr_2}, ...)

Es como @code{display} pero s@'olo se muestran los valores de
los argumentos, no las ecuaciones. Es @'util para argumentos 
complicados que no tienen nombre o en situaciones en las que 
solamente es de inter@'es el valor del argumento pero no su nombre.

V@'eanse tambi@'en @code{ldisp} y @code{print}.

Ejemplos:

@c ===beg===
@c b[1,2]:x-x^2$
@c x:123$
@c disp(x, b[1,2], sin(1.0));
@c ===end===
@example
(%i1) b[1,2]:x-x^2$
(%i2) x:123$
(%i3) disp(x, b[1,2], sin(1.0));
                               123

                                  2
                             x - x

                        .8414709848078965

(%o3)                         done
@end example
@end deffn


@deffn {Funci@'on} display (@var{expr_1}, @var{expr_2}, ...)

Muestra las ecuaciones cuyos miembros izquierdos son 
@var{expr_i} sin evaluar y cuyos miembros derechos son los 
valores de las expresiones. Esta funci@'on es @'util en los 
bloques y en las sentencias @code{for} para mostrar resultados 
intermedios.  Los argumentos de @code{display} suelen ser @'atomos, 
variables subindicadas o llamadas a funciones.

V@'eanse tambi@'en @code{ldisplay}, @code{disp} y @code{ldisp}.

Ejemplos:

@c ===beg===
@c b[1,2]:x-x^2$
@c x:123$
@c display(x, b[1,2], sin(1.0));
@c ===end===
@example
(%i1) b[1,2]:x-x^2$
(%i2) x:123$
(%i3) display(x, b[1,2], sin(1.0));
                             x = 123

                                      2
                         b     = x - x
                          1, 2

                  sin(1.0) = .8414709848078965

(%o3)                         done
@end example
@end deffn


@defvr {Variable opcional} display2d
Valor por defecto: @code{true}

Si @code{display2d} vale @code{false}, la salida por consola es
una cadena unidimensional, en lugar de una expresi@'on bidimensional.

Ejemplo:

@c ===beg===
@c x/(x^2+1);
@c display2d:false$
@c x/(x^2+1);
@c ===end===
@example
(%i1) x/(x^2+1);
                               x
(%o1)                        ------
                              2
                             x  + 1
(%i2) display2d:false$
(%i3) x/(x^2+1);
(%o3) x/(x^2+1)
@end example
@end defvr


@defvr {Variable opcional} display_format_internal
Valor por defecto: @code{false}

Si @code{display_format_internal} vale @code{true},
las expresiones se muestran sin ser transformadas de manera que oculten su representaci@'on matem@'atica interna. Se representa lo que la funci@'on @code{inpart} devolver@'{@dotless{i}}a, en oposici@'on a @code{part}.

Ejemplos:

@example
User     part       inpart
a-b;      a - b     a + (- 1) b

           a            - 1
a/b;       -         a b
           b
                       1/2
sqrt(x);   sqrt(x)    x

          4 X        4
X*4/3;    ---        - X
           3         3
@end example

@end defvr


@deffn {Funci@'on} dispterms (@var{expr})
Muestra @var{expr} en partes, una debajo de la otra.
Esto es, primero se muestra el operador de @var{expr}, luego 
cada t@'ermino si se trata de una suma, o cada factor si es un 
producto, o si no se muestra separadamente la parte de una expresi@'on 
m@'as general. Es @'util si @var{expr} es demasiado grande para 
representarla de otra forma.  Por ejemplo, si @code{P1}, @code{P2}, ...  
son expresiones muy grandes, entonces el programa de representaci@'on 
puede superar el espacio de almacenamiento tratando de mostrar 
@code{P1 + P2 + ...} todo junto.  Sin embargo, @code{dispterms (P1 + P2 + ...)} 
muestra @code{P1}, debajo  @code{P2}, etc.  Cuando una expresi@'on exponencial 
es demasiado ancha para ser representada como @code{A^B}, si no se utiliza 
@code{dispterms}, entonces aparecer@'a como @code{expt (A, B)} (o como 
@code{ncexpt (A, B)}, en lugar de @code{A^^B}).

Ejemplo:

@example
(%i1) dispterms(2*a*sin(x)+%e^x);

+

2 a sin(x)

  x
%e

(%o1)                         done
@end example
@end deffn


@deffn {S@'{@dotless{i}}mbolo especial} expt (@var{a}, @var{b})
@deffnx {S@'{@dotless{i}}mbolo especial} ncexpt (@var{a}, @var{b})
Si una expresi@'on exponencial es demasiado ancha para ser mostrada como @code{@var{a}^@var{b}} aparecer@'a como @code{expt (@var{a}, @var{b})} (o como @code{ncexpt (@var{a}, @var{b})} en lugar de @code{@var{a}^^@var{b}}).

@c THIS SEEMS LIKE A BUG TO ME. expt, ncexpt SHOULD BE RECOGNIZED SINCE MAXIMA
@c ITSELF PRINTS THEM SOMETIMES. THESE SHOULD JUST SIMPLIFY TO ^ AND ^^, RESPECTIVELY.
Las funciones @code{expt} y @code{ncexpt} no se reconocen en una entrada.

@end deffn


@defvr {Variable opcional} exptdispflag
Valor por defecto: @code{true}

Si @code{exptdispflag} vale @code{true}, Maxima muestra las expresiones con 
exponentes negativos como cocientes. V@'ease tambi@'en @code{%edispflag}.

Ejemplo:

@example
(%i1) exptdispflag:true;
(%o1)                         true
(%i2) 10^-x;
                                1
(%o2)                          ---
                                 x
                               10
(%i3) exptdispflag:false;
(%o3)                         false
(%i4) 10^-x;
                                - x
(%o4)                         10
@end example

@end defvr


@deffn {Funci@'on} grind (@var{expr})
@deffnx {Variable opcional} grind
La funci@'on @code{grind} imprime @var{expr}
en la consola en un formato admisible como entrada para Maxima. La funci@'on 
@code{grind} devuelve siempre @code{done}.

Cuando @var{expr} es el nombre de una funci@'on o macro, @code{grind}
muestra la definici@'on de la funci@'on o de la macro en lugar de s@'olo
su nombre.

V@'ease tambi@'en @code{string}, que devuelve una cadena en lugar de imprimir la salida. La funci@'on
@code{grind} intenta imprimir la expresi@'on de forma que sea lago m@'as sencilla de leer que la salida de @code{string}.

Cuando la variable @code{grind} vale @code{true},
la salida de @code{string} y @code{stringout} tienen el mismo formato que la de @code{grind};
en caso contrario no se formatea la salida de esas funciones.
El valor por defecto de la variable @code{grind} es @code{false}.

La variable @code{grind} tambi@'en se puede utilizar como  argumento en @code{playback}.
Si @code{grind} est@'a presente,
@code{playback} imprime las expresiones de entrada en el mismo formato que lo hace la funci@'on @code{grind};
en caso contrario no se formatean la expresiones de entrada.

La funci@'on @code{grind} eval@'ua sus argumentos.

Ejemplos:

@c ===beg===
@c aa + 1729;
@c grind (%);
@c [aa, 1729, aa + 1729];
@c grind (%);
@c matrix ([aa, 17], [29, bb]);
@c grind (%);
@c set (aa, 17, 29, bb);
@c grind (%);
@c exp (aa / (bb + 17)^29);
@c grind (%);
@c expr: expand ((aa + bb)^10);
@c grind (expr);
@c string (expr);
@c cholesky (A):= block ([n : length (A), L : copymatrix (A),
@c   p : makelist (0, i, 1, length (A))], 
@c   for i thru n do for j : i thru n do
@c   (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1), 
@c   if i = j then @c   p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]), 
@c   for i thru n do L[i, i] : 1 / p[i],
@c   for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
@c grind (cholesky);
@c string (fundef (cholesky));
@c ===end===
@example
(%i1) aa + 1729;
(%o1)                       aa + 1729
(%i2) grind (%);
aa+1729$
(%o2)                         done
(%i3) [aa, 1729, aa + 1729];
(%o3)                 [aa, 1729, aa + 1729]
(%i4) grind (%);
[aa,1729,aa+1729]$
(%o4)                         done
(%i5) matrix ([aa, 17], [29, bb]);
                           [ aa  17 ]
(%o5)                      [        ]
                           [ 29  bb ]
(%i6) grind (%);
matrix([aa,17],[29,bb])$
(%o6)                         done
(%i7) set (aa, 17, 29, bb);
(%o7)                   @{17, 29, aa, bb@}
(%i8) grind (%);
@{17,29,aa,bb@}$
(%o8)                         done
(%i9) exp (aa / (bb + 17)^29);
                                aa
                            -----------
                                     29
                            (bb + 17)
(%o9)                     %e
(%i10) grind (%);
%e^(aa/(bb+17)^29)$
(%o10)                        done
(%i11) expr: expand ((aa + bb)^10);
         10           9        2   8         3   7         4   6
(%o11) bb   + 10 aa bb  + 45 aa  bb  + 120 aa  bb  + 210 aa  bb
         5   5         6   4         7   3        8   2
 + 252 aa  bb  + 210 aa  bb  + 120 aa  bb  + 45 aa  bb
        9        10
 + 10 aa  bb + aa
(%i12) grind (expr);
bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6
     +252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2
     +10*aa^9*bb+aa^10$
(%o12)                        done
(%i13) string (expr);
(%o13) bb^10+10*aa*bb^9+45*aa^2*bb^8+120*aa^3*bb^7+210*aa^4*bb^6\
+252*aa^5*bb^5+210*aa^6*bb^4+120*aa^7*bb^3+45*aa^8*bb^2+10*aa^9*\
bb+aa^10
(%i14) cholesky (A):= block ([n : length (A), L : copymatrix (A),
  p : makelist (0, i, 1, length (A))], for i thru n do
  for j : i thru n do
  (x : L[i, j], x : x - sum (L[j, k] * L[i, k], k, 1, i - 1),
  if i = j then p[i] : 1 / sqrt(x) else L[j, i] : x * p[i]),
  for i thru n do L[i, i] : 1 / p[i],
  for i thru n do for j : i + 1 thru n do L[i, j] : 0, L)$
(%i15) grind (cholesky);
cholesky(A):=block(
         [n:length(A),L:copymatrix(A),
          p:makelist(0,i,1,length(A))],
         for i thru n do
             (for j from i thru n do
                  (x:L[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),
                   if i = j then p[i]:1/sqrt(x)
                       else L[j,i]:x*p[i])),
         for i thru n do L[i,i]:1/p[i],
         for i thru n do (for j from i+1 thru n do L[i,j]:0),L)$
(%o15)                        done
(%i16) string (fundef (cholesky));
(%o16) cholesky(A):=block([n:length(A),L:copymatrix(A),p:makelis\
t(0,i,1,length(A))],for i thru n do (for j from i thru n do (x:L\
[i,j],x:x-sum(L[j,k]*L[i,k],k,1,i-1),if i = j then p[i]:1/sqrt(x\
) else L[j,i]:x*p[i])),for i thru n do L[i,i]:1/p[i],for i thru \
n do (for j from i+1 thru n do L[i,j]:0),L)
@end example
@end deffn




@defvr {Variable opcional} ibase
Valor por defecto: @code{10}

@code{ibase} es la base en la que Maxima lee valores enteros.

A @code{ibase} se le puede asignar cualquier entero entre
2 y 36 (base decimal), ambos inclusive.
Si @code{ibase} es mayor que 10,
las cifras a utilizar ser@'an los d@'{@dotless{i}}gitos de
0 a 9, junto con las letras del alfabeto A, B, C, ..., 
tantas como sean necesarias para completar la base @code{ibase}.
Las letras se interpretar@'an como cifras s@'olo cuando el 
primer d@'{@dotless{i}}gito sea un valor entre 9.
Es indiferente hacer uso de letras may@'usculas o min@'usculas.
Las cifras para la base 36, la mayor posible, son los 
d@'{@dotless{i}}gitos num@'ericos de 0 a 9 y las letras desde
la A hasta la Z.

Cualquiera que sea el valor de @code{ibase}, si un entero termina
con un punto decimal, se interpretar@'a en base 10.

V@'ease tambi@'en @code{obase}.

Ejemplos:

@code{ibase} menor que 10.

@c ===beg===
@c ibase : 2 $
@c obase;
@c 1111111111111111;
@c ===end===
@example
(%i1) ibase : 2 $
(%i2) obase;
(%o2)                          10
(%i3) 1111111111111111;
(%o3)                         65535
@end example

@code{ibase} mayor que 10.
Las letras se interpretan como d@'{@dotless{i}}gitos s@'olo
si el primer d@'{@dotless{i}}gito es una cifra entre 0 y 9.

@c ===beg===
@c ibase : 16 $
@c obase;
@c 1000;
@c abcd;
@c symbolp (abcd);
@c 0abcd;
@c symbolp (0abcd);
@c ===end===
@example
(%i1) ibase : 16 $
(%i2) obase;
(%o2)                          10
(%i3) 1000;
(%o3)                         4096
(%i4) abcd;
(%o4)                         abcd
(%i5) symbolp (abcd);
(%o5)                         true
(%i6) 0abcd;
(%o6)                         43981
(%i7) symbolp (0abcd);
(%o7)                         false
@end example

Independientemente del valor de @code{ibase}, si el entero
termina con un punto decimal, se interpretar@'a en base
diez.

@c ===beg===
@c ibase : 36 $
@c obase;
@c 1234;
@c 1234.;
@c ===end===
@example
(%i1) ibase : 36 $
(%i2) obase;
(%o2)                          10
(%i3) 1234;
(%o3)                         49360
(%i4) 1234.;
(%o4)                         1234
@end example
@end defvr



@deffn {Funci@'on} ldisp (@var{expr_1}, ..., @var{expr_n})
Muestra las expresiones @var{expr_1}, ..., @var{expr_n} en la consola con el formato de salida;
@code{ldisp} asigna una etiqueta a cada argumento y devuelve la lista de etiquetas.

V@'eanse tambi@'en @code{disp}, @code{display} y @code{ldisplay}.

@example
(%i1) e: (a+b)^3;
                                   3
(%o1)                       (b + a)
(%i2) f: expand (e);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(%i3) ldisp (e, f);
                                   3
(%t3)                       (b + a)

                     3        2      2      3
(%t4)               b  + 3 a b  + 3 a  b + a

(%o4)                      [%t3, %t4]
(%i4) %t3;
                                   3
(%o4)                       (b + a)
(%i5) %t4;
                     3        2      2      3
(%o5)               b  + 3 a b  + 3 a  b + a
@end example

@end deffn



@deffn {Funci@'on} ldisplay (@var{expr_1}, ..., @var{expr_n})
Muestra las expresiones @var{expr_1}, ..., @var{expr_n} en la consola con el formato de salida.
Cad expresi@'on se muestra como una ecuaci@'on de la forma @code{lhs = rhs}
en la que @code{lhs} es uno de los argumentos de @code{ldisplay}
y @code{rhs} su valor. Normalmente, cada argumento ser@'a el nombre de una variable. La funci@'on
@code{ldisp} asigna una etiqueta a cada ecuaci@'on y devuelve la lista de etiquetas.

V@'eanse tambi@'en @code{disp}, @code{display} y @code{ldisp}.

@example
(%i1) e: (a+b)^3;
                                   3
(%o1)                       (b + a)
(%i2) f: expand (e);
                     3        2      2      3
(%o2)               b  + 3 a b  + 3 a  b + a
(%i3) ldisplay (e, f);
                                     3
(%t3)                     e = (b + a)

                       3        2      2      3
(%t4)             f = b  + 3 a b  + 3 a  b + a

(%o4)                      [%t3, %t4]
(%i4) %t3;
                                     3
(%o4)                     e = (b + a)
(%i5) %t4;
                       3        2      2      3
(%o5)             f = b  + 3 a b  + 3 a  b + a
@end example

@end deffn


@defvr {Variable opcional} linel
Valor por defecto: @code{79}

La variable @code{linel} es la anchura (medida en n@'umero de caracteres) de la consola que se le da a Maxima para que muestre las expresiones. A @code{linel} se le puede asignar cualquier valor, pero si @'este es muy peque@~no o grande resultar@'a de poca utilidad. El texto que impriman las funciones internas de Maxima, como los mensajes de error y las salidas de la funci@'on @code{describe}, no se ve afectado por el valor de @code{linel}.

@end defvr


@defvr {Variable opcional} lispdisp
Valor por defecto: @code{false}

Si @code{lispdisp} vale @code{true}, los s@'{@dotless{i}}mbolos de Lisp se muestran precedidos del car@'acter de interrogaci@'on @code{?}. En caso contrario, los s@'{@dotless{i}}mbolos de Lisp se muestran sin esta marca.

Ejemplos:

@c ===beg===
@c lispdisp: false$
@c ?foo + ?bar;
@c lispdisp: true$
@c ?foo + ?bar;
@c ===end===
@example
(%i1) lispdisp: false$
(%i2) ?foo + ?bar;
(%o2)                       foo + bar
(%i3) lispdisp: true$
(%i4) ?foo + ?bar;
(%o4)                      ?foo + ?bar
@end example

@end defvr


@defvr {Variable opcional} negsumdispflag
Valor por defecto: @code{true}

Si @code{negsumdispflag} vale @code{true}, @code{x - y} se muestra como @code{x - y}
en lugar de @code{- y + x}.  D@'andole el valor @code{false} se realiza un an@'alisis adicional para que no se representen de forma muy diferente dos expresiones similares.  Una aplicaci@'on puede ser para que @code{a + %i*b} y @code{a - %i*b} se representen ambas de la misma manera.

@end defvr


@defvr {Variable opcional} obase
Valor por defecto: @code{10}

@code{obase} es la base en la que Maxima imprime los n@'umeros enteros.

A @code{obase} se le puede asignar cualquier entero entre
2 y 36 (base decimal), ambos inclusive.
Si @code{obase} es mayor que 10,
las cifras a utilizar ser@'an los d@'{@dotless{i}}gitos de
0 a 9, junto con las letras del alfabeto A, B, C, ..., 
tantas como sean necesarias para completar la base @code{obase}.
Si el primer d@'{@dotless{i}}gito resulta ser una letra, se le
a@~nadir@'a el cero como prefijo.
Las cifras para la base 36, la mayor posible, son los 
d@'{@dotless{i}}gitos num@'ericos de 0 a 9 y las letras desde
la A hasta la Z.

V@'ease tambi@'en @code{ibase}.

Ejemplos:

@c ===beg===
@c obase : 2;
@c 2^8 - 1;
@c obase : 8;
@c 8^8 - 1;
@c obase : 16;
@c 16^8 - 1;
@c obase : 36;
@c 36^8 - 1;
@c ===end===
@example
(%i1) obase : 2;
(%o1)                          10
(%i2) 2^8 - 1;
(%o10)                      11111111
(%i3) obase : 8;
(%o3)                          10
(%i4) 8^8 - 1;
(%o4)                       77777777
(%i5) obase : 16;
(%o5)                          10
(%i6) 16^8 - 1;
(%o6)                       0FFFFFFFF
(%i7) obase : 36;
(%o7)                          10
(%i8) 36^8 - 1;
(%o8)                       0ZZZZZZZZ
@end example
@end defvr


@defvr {Variable opcional} pfeformat
Valor por defecto: @code{false}

Si @code{pfeformat} vale @code{true}, una fracci@'on de enteros ser@'a mostrada con el car@'acter de barra inclinada @code{/} entre ellos.


@example
(%i1) pfeformat: false$
(%i2) 2^16/7^3;
                              65536
(%o2)                         -----
                               343
(%i3) (a+b)/8;
                              b + a
(%o3)                         -----
                                8
(%i4) pfeformat: true$ 
(%i5) 2^16/7^3;
(%o5)                       65536/343
(%i6) (a+b)/8;
(%o6)                      1/8 (b + a)
@end example

@end defvr


@defvr {Variable opcional} powerdisp
Valor por defecto: @code{false}

Si @code{powerdisp} vale @code{true}, se muestran las sumas con sus t@'erminos ordenados de menor a mayor potencia. As@'{@dotless{i}}, un polinomio se presenta como una serie de potencias truncada con el t@'ermino constante al principio y el de mayor potencia al final.

Por defecto, los t@'erminos de una suma se muestran en el orden de las potencias decrecientes.

Ejemplo:

@example
(%i1) powerdisp:true;
(%o1)                         true
(%i2) x^2+x^3+x^4;
                           2    3    4
(%o2)                     x  + x  + x
(%i3) powerdisp:false;
(%o3)                         false
(%i4) x^2+x^3+x^4;
                           4    3    2
(%o4)                     x  + x  + x
@end example
@end defvr


@deffn {Funci@'on} print (@var{expr_1}, ..., @var{expr_n})
Eval@'ua y muestra las expresiones  @var{expr_1}, ..., @var{expr_n} secuencialmente de izquierda a derecha, comenzando la impresi@'on por el borde izquierdo de la consola.

El valor devuelto por @code{print} es el valor de su @'ultimo argumento. La funci@'on @code{print} no genera etiquetas para las expresiones intermedias.

V@'eanse tambi@'en @code{display}, @code{disp}, @code{ldisplay} y @code{ldisp}, que muestran una expresi@'on por l@'{@dotless{i}}nea, mientras que @code{print} trata de mostrar dos o m@'as expresiones por l@'{@dotless{i}}nea.

Para mostrar el contenido de un archivo v@'ease @code{printfile}.

@example
(%i1) r: print ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
      radcan (log (a^10/b)))$
            3        2      2      3
(a+b)^3 is b  + 3 a b  + 3 a  b + a  log (a^10/b) is 

                                              10 log(a) - log(b) 
(%i2) r;
(%o2)                  10 log(a) - log(b)
(%i3) disp ("(a+b)^3 is", expand ((a+b)^3), "log (a^10/b) is",
      radcan (log (a^10/b)))$
                           (a+b)^3 is

                     3        2      2      3
                    b  + 3 a b  + 3 a  b + a

                         log (a^10/b) is

                       10 log(a) - log(b)
@end example

@end deffn


@defvr {Variable opcional} sqrtdispflag
Valor por defecto: @code{true}

Si @code{sqrtdispflag} vale @code{false}, har@'a que @code{sqrt} se muestre con el exponente 1/2.
@c AND OTHERWISE ... ??
@end defvr


@defvr {Variable opcional} stardisp
Valor por defecto: @code{false}

Si @code{stardisp} vale @code{true}, la multiplicaci@'on se muestra con un asterisco @code{*} entre los operandos.

@end defvr


@defvr {Variable opcional} ttyoff
Valor por defecto: @code{false}

Si @code{ttyoff} vale @code{true}, no se muestran las expresiones resultantes, pero @'estas se calculan de todos modos y se les asignan etiquetas. V@'ease @code{labels}.

El texto que escriban las funciones internas de Maxima, tales como los mensajes de error y las salidas de @code{describe},
no se ven afectadas por @code{ttyoff}.

@end defvr
