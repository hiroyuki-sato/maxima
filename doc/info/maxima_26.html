<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Matrices and Linear Algebra</TITLE>
<link href="maxima_27.html" rel=Next>
<link href="maxima_25.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_25.html">previous</A>, <A HREF="maxima_27.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC82" HREF="maxima_toc.html#TOC82">Matrices and Linear Algebra</A></H1>



<H2><A NAME="SEC83" HREF="maxima_toc.html#TOC83">Introduction to Matrices and Linear Algebra</A></H2>



<H3><A NAME="SEC84" HREF="maxima_toc.html#TOC84">DOT</A></H3>
<P>
 - . The dot operator, for matrix (non-commutative)
multiplication.  When "." is used in this way, spaces should be left
on both sides of it, e.g. A . B.  This distinguishes it plainly from a
decimal point in a floating point number.  Do APROPOS(DOT); for a list
of the switches which affect the dot operator.

</P>


<H3><A NAME="SEC85" HREF="maxima_toc.html#TOC85">VECTORS</A></H3>
<P>
 - The file SHARE;VECT &#62; contains a vector analysis package,
share/vect.dem contains a corresponding demonstration, and SHARE;VECT
ORTH contains definitions of various orthogonal curvilinear coordinate
systems.  LOAD(VECT); will load this package for you.
The vector analysis package can combine and simplify symbolic 
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is under
user control, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.
There is also a capability for deriving the scalar or vector potential
of a field.
The package contains the following commands: VECTORSIMP, SCALEFACTORS,
EXPRESS, POTENTIAL, and VECTORPOTENTIAL.  Do DESCRIBE(cmd) on these
command names, or PRINTFILE(VECT,USAGE,SHARE); for details.
Warning:  The VECT package declares "." to be a commutative operator.

</P>


<H2><A NAME="SEC86" HREF="maxima_toc.html#TOC86">Definitions for Matrices and Linear Algebra</A></H2>
<P>
<DL>
<DT><U>Function:</U> <B>ADDCOL</B> <I>(M,list1,list2,...,listn)</I>
<DD><A NAME="IDX628"></A>
appends the column(s) given by the one
or more lists (or matrices) onto the matrix M.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ADDROW</B> <I>(M,list1,list2,...,listn)</I>
<DD><A NAME="IDX629"></A>
appends the row(s) given by the one or
more lists (or matrices) onto the matrix M.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ADJOINT</B> <I>(matrix)</I>
<DD><A NAME="IDX630"></A>
computes the adjoint of a matrix.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>AUGCOEFMATRIX</B> <I>([eq1, ...], [var1, ...])</I>
<DD><A NAME="IDX631"></A>
the augmented coefficient
matrix for the variables var1,... of the system of linear equations
eq1,....  This is the coefficient matrix with a column adjoined for
the constant terms in each equation (i.e. those not dependent upon
var1,...).  Do EXAMPLE(AUGCOEFMATRIX); for an example.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CHARPOLY</B> <I>(M, var)</I>
<DD><A NAME="IDX632"></A>
computes the characteristic polynomial for Matrix M
with respect to var.  That is, DETERMINANT(M - DIAGMATRIX(LENGTH(M),var)).
For examples of this command, do EXAMPLE(CHARPOLY); .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>COEFMATRIX</B> <I>([eq1, ...], [var1, ...])</I>
<DD><A NAME="IDX633"></A>
the coefficient matrix for the
variables var1,... of the system of linear equations eq1,...

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>COL</B> <I>(M,i)</I>
<DD><A NAME="IDX634"></A>
gives a matrix of the ith column of the matrix M.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>COLUMNVECTOR</B> <I>(X)</I>
<DD><A NAME="IDX635"></A>
a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  COLUMNVECTOR takes a LIST as its argument and returns a
column vector the components of which are the elements of the list.
The first element is the first component,...etc...(This is useful if
you want to use parts of the outputs of the functions in this package
in matrix calculations.)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CONJUGATE</B> <I>(X)</I>
<DD><A NAME="IDX636"></A>
a function in the EIGEN package on the SHARE
directory.  It returns the complex conjugate of its argument.  This
package may be loaded by LOAD(EIGEN); .  For a complete description
of this package, do PRINTFILE("eigen.usg"); .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>COPYMATRIX</B> <I>(M)</I>
<DD><A NAME="IDX637"></A>
creates a copy of the matrix M.  This is the only way
to make a copy aside from recreating M elementwise.  Copying a matrix
may be useful when SETELMX is used.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DETERMINANT</B> <I>(M)</I>
<DD><A NAME="IDX638"></A>
computes the determinant of M by a method similar to
Gaussian elimination.  The form of the result depends upon the setting
of the switch RATMX.  There is a special routine for dealing with
sparse determininants which can be used by setting the switches
RATMX:TRUE and SPARSE:TRUE.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DETOUT</B>
<DD><A NAME="IDX639"></A>
 default: [FALSE] if TRUE will cause the determinant of a
matrix whose inverse is computed to be kept outside of the inverse.
For this switch to have an effect DOALLMXOPS and DOSCMXOPS should be
FALSE (see their descriptions).  Alternatively this switch can be
given to EV which causes the other two to be set correctly.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DIAGMATRIX</B> <I>(n, x)</I>
<DD><A NAME="IDX640"></A>
returns a diagonal matrix of size n by n with the
diagonal elements all x.  An identity matrix is created by
DIAGMATRIX(n,1), or one may use IDENT(n).

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOALLMXOPS</B>
<DD><A NAME="IDX641"></A>
 default: [TRUE] if TRUE all operations relating to
matrices are carried out.  If it is FALSE then the setting of the
individual DOT switches govern which operations are performed.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOMXEXPT</B>
<DD><A NAME="IDX642"></A>
 default: [TRUE] if TRUE,

<PRE>
%E^MATRIX([1,2],[3,4]) ==&#62;
MATRIX([%E,%E^2],[%E^3,%E^4])
</PRE>

<P>
In general, this transformation
affects expressions of the form &#60;base&#62;^&#60;power&#62; where &#60;base&#62; is an
expression assumed scalar or constant, and &#60;power&#62; is a list or
matrix.  This transformation is turned off if this switch is set to
FALSE.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOMXMXOPS</B>
<DD><A NAME="IDX643"></A>
 default: [TRUE] if TRUE then all matrix-matrix or
matrix-list operations are carried out (but not scalar-matrix
operations); if this switch is FALSE they are not.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOMXNCTIMES</B>
<DD><A NAME="IDX644"></A>
 default: [FALSE] Causes non-commutative products of
matrices to be carried out.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DONTFACTOR</B>
<DD><A NAME="IDX645"></A>
 default: [] may be set to a list of variables with respect
to which factoring is not to occur.  (It is initially empty).
Factoring also will not take place with respect to any variables which
are less important (using the variable ordering assumed for CRE form)
than those on the DONTFACTOR list.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOSCMXOPS</B>
<DD><A NAME="IDX646"></A>
 default: [FALSE] if TRUE then scalar-matrix operations are
performed.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOSCMXPLUS</B>
<DD><A NAME="IDX647"></A>
 default: [FALSE] if TRUE will cause SCALAR + MATRIX to
give a matrix answer.  This switch is not subsumed under DOALLMXOPS.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOT0NSCSIMP</B>
<DD><A NAME="IDX648"></A>
 default: [TRUE] Causes a non-commutative product of zero
and a nonscalar term to be simplified to a commutative product.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOT0SIMP</B>
<DD><A NAME="IDX649"></A>
 default: [TRUE] Causes a non-commutative product of zero and
a scalar term to be simplified to a commutative product.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOT1SIMP</B>
<DD><A NAME="IDX650"></A>
 default: [TRUE] Causes a non-commutative product of one and
another term to be simplified to a commutative product.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOTASSOC</B>
<DD><A NAME="IDX651"></A>
 default: [TRUE] when TRUE causes (A.B).C to simplify to
A.(B.C)

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOTCONSTRULES</B>
<DD><A NAME="IDX652"></A>
 default: [TRUE] Causes a non-commutative product of a
constant and another term to be simplified to a commutative product.
Turning on this flag effectively turns on DOT0SIMP, DOT0NSCSIMP, and
DOT1SIMP as well.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOTDISTRIB</B>
<DD><A NAME="IDX653"></A>
 default: [FALSE] if TRUE will cause A.(B+C) to simplify to
A.B+A.C

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOTEXPTSIMP</B>
<DD><A NAME="IDX654"></A>
 default: [TRUE] when TRUE causes A.A to simplify to A^^2

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOTIDENT</B>
<DD><A NAME="IDX655"></A>
 default: [1]  The value to be returned by X^^0.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>DOTSCRULES</B>
<DD><A NAME="IDX656"></A>
 default: [FALSE] when TRUE will cause A.SC or SC.A to
simplify to SC*A and A.(SC*B) to simplify to SC*(A.B)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ECHELON</B> <I>(M)</I>
<DD><A NAME="IDX657"></A>
produces the echelon form of the matrix M.  That is, M
with elementary row operations performed on it such that the first
non-zero element in each row in the resulting matrix is a one and the
column elements under the first one in each row are all zero.

<PRE>
                        [2  1 - A  -5 B ]
(D2)                    [               ]
                        [A    B      C  ]

(C3) ECHELON(D2);
                 [      A - 1        5 B      ]
                 [1   - -----      - --      ]
                 [        2           2       ]
(D3)             [                            ]
                 [                2 C + 5 A B ]
                 [0     1         ------------]
                 [                       2    ]
                 [                2 B + A  - A]

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EIGENVALUES</B> <I>(mat)</I>
<DD><A NAME="IDX658"></A>
There is a package on the SHARE; directory which
contains functions for computing EIGENVALUES and EIGENVECTORS and
related matrix computations.  For information on it do
PRINTFILE(EIGEN,USAGE,SHARE); . 
EIGENVALUES(mat) takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the list of eigenvalues of the
matrix and the other sublist of which is the list of the
multiplicities of the eigenvalues in the corresponding order.  [ The
MACSYMA function SOLVE is used here to find the roots of the
characteristic polynomial of the matrix.  Sometimes SOLVE may not be
able to find the roots of the polynomial;in that case nothing in this
package except CONJUGATE, INNERPRODUCT, UNITVECTOR, COLUMNVECTOR and
GRAMSCHMIDT will work unless you know the eigenvalues.  In some cases
SOLVE may generate very messy eigenvalues.  You may want to simplify
the answers yourself before you go on.  There are provisions for this
and they will be explained below.  ( This usually happens when SOLVE
returns a not-so-obviously real expression for an eigenvalue which is
supposed to be real...)]  The EIGENVALUES command is available
directly from MACSYMA.  To use the other functions you must have
loaded in the EIGEN package, either by a previous call to EIGENVALUES,
or by doing LOADFILE("eigen"); .

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EIGENVECTORS</B> <I>(MAT)</I>
<DD><A NAME="IDX659"></A>
takes a MATRIX as its argument and returns a list
of lists the first sublist of which is the output of the EIGENVALUES
command and the other sublists of which are the eigenvectors of the
matrix corresponding to those eigenvalues respectively.  This function
will work directly from MACSYMA, but if you wish to take advantage of
the flags for controlling it (see below), you must first load in the
EIGEN package from the SHARE; directory.  You may do that by
LOADFILE("eigen");.  The flags that affect this function are:
NONDIAGONALIZABLE[FALSE] will be set to TRUE or FALSE depending on
whether the matrix is nondiagonalizable or diagonalizable after an
EIGENVECTORS command is executed.
HERMITIANMATRIX[FALSE] If set to TRUE will cause the degenerate
eigenvectors of the hermitian matrix to be orthogonalized using the
Gram-Schmidt algorithm.
KNOWNEIGVALS[FALSE] If set to TRUE the EIGEN package will assume the
eigenvalues of the matrix are known to the user and stored under the
global name LISTEIGVALS.  LISTEIGVALS should be set to a list similar
to the output of the EIGENVALUES command.  ( The MACSYMA function
ALGSYS is used here to solve for the eigenvectors. Sometimes if the
eigenvalues are messy, ALGSYS may not be able to produce a solution.
In that case you are advised to try to simplify the eigenvalues by
first finding them using EIGENVALUES command and then using whatever
marvelous tricks you might have to reduce them to something simpler.
You can then use the KNOWNEIGVALS flag to proceed further. )

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EMATRIX</B> <I>(m, n, x, i, j)</I>
<DD><A NAME="IDX660"></A>
will create an m by n matrix all of whose
elements are zero except for the i,j element which is x.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ENTERMATRIX</B> <I>(m, n)</I>
<DD><A NAME="IDX661"></A>
allows one to enter a matrix element by element
with MACSYMA requesting values for each of the m*n entries.

<PRE>
(C1) ENTERMATRIX(3,3);
Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric
 4. General

Answer 1, 2, 3 or 4
1;
Row 1 Column 1:  A;
Row 2 Column 2:  B;
Row 3 Column 3:  C;
Matrix entered.
                                 [ A  0  0 ]
                                 [         ]
(D1)                             [ 0  B  0 ]
                                 [         ]
                                 [ 0  0  C ]

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>GENMATRIX</B> <I>(array, i2, j2, i1, j1)</I>
<DD><A NAME="IDX662"></A>
generates a matrix from the array
using array(i1,j1) for the first (upper-left) element and array(i2,j2)
for the last (lower-right) element of the matrix.  If j1=i1 then j1
may be omitted. If j1=i1=1 then i1 and j1 may both be omitted. If a
selected element of the array doesn't exist a symbolic one will be
used.

<PRE>
(C1) H[I,J]:=1/(I+J-1)$
(C2) GENMATRIX(H,3,3);
                           [   1  1]
                           [1  -  -]
                           [   2  3]
                           [       ]
                           [1  1  1]
(D2)                       [-  -  -]
                           [2  3  4]
                           [       ]
                           [1  1  1]
                           [-  -  -]
                           [3  4  5]

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>GRAMSCHMIDT</B> <I>(X)</I>
<DD><A NAME="IDX663"></A>
a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  GRAMSCHMIDT takes a LIST of lists the sublists of which are
of equal length and not necessarily orthogonal (with respect to the
innerproduct defined above) as its argument and returns a similar list
each sublist of which is orthogonal to all others.  (Returned results
may contain integers that are factored.  This is due to the fact that
the MACSYMA function FACTOR is used to simplify each substage of the
Gram-Schmidt algorithm.  This prevents the expressions from getting
very messy and helps to reduce the sizes of the numbers that are
produced along the way.)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>HACH</B> <I>(a,b,m,n,l)</I>
<DD><A NAME="IDX664"></A>
An implementation of Hacijan's linear programming
algorithm is available by doing BATCH("kach.mc"$.  Details of use
are available by doing BATCH("kach.dem");

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>IDENT</B> <I>(n)</I>
<DD><A NAME="IDX665"></A>
produces an n by n identity matrix.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>INNERPRODUCT</B> <I>(X,Y)</I>
<DD><A NAME="IDX666"></A>
a function in the EIGEN package.  Do LOAD(EIGEN)
to use it.  INNERPRODUCT takes two LISTS of equal length as its
arguments and returns their inner (scalar) product defined by (Complex
Conjugate of X).Y (The "dot" operation is the same as the usual one
defined for vectors).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>INVERT</B> <I>(matrix)</I>
<DD><A NAME="IDX667"></A>
finds the inverse of a matrix using the adjoint
method.  This allows a user to compute the inverse of a matrix with
bfloat entries or polynomials with floating pt. coefficients without
converting to cre-form.  The DETERMINANT command is used to compute
cofactors, so if RATMX is FALSE (the default) the inverse is computed
without changing the representation of the elements.  The current
implementation is inefficient for matrices of high order.
The DETOUT flag if true keeps the determinant factored out of the
inverse.
Note: the results are not automatically expanded.  If the matrix
originally had polynomial entries, better appearing output can be
generated by EXPAND(INVERT(mat)),DETOUT.  If it is desirable to then
divide through by the determinant this can be accomplished by XTHRU(%)
or alternatively from scratch by
EXPAND(ADJOINT(mat))/EXPAND(DETERMINANT(mat)).
INVERT(mat):=ADJOINT(mat)/DETERMINANT(mat).
See also DESCRIBE("^^"); for another method of inverting a matrix.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>LMXCHAR</B>
<DD><A NAME="IDX668"></A>
 default: [[] - The character used to display the (left)
delimiter of a matrix (see also RMXCHAR).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MATRIX</B> <I>(row1, ..., rown)</I>
<DD><A NAME="IDX669"></A>
defines a rectangular matrix with the
indicated rows.  Each row has the form of a list of expressions, e.g.
[A, X**2, Y, 0] is a list of 4 elements.  There are a number of
MACSYMA commands which deal with matrices, for example:  DETERMINANT,
CHARPOLY, GENMATRIX, ADDCOL, ADDROW, COPYMATRIX, TRANSPOSE, ECHELON,
and RANK.  There is also a package on the SHARE directory for 
computing EIGENVALUES.  Try DESCRIBE on these for more information.
Matrix multiplication is effected by using the dot operator, ".",
which is also convenient if the user wishes to represent other
non-commutative algebraic operations.  The exponential of the "."
operation is "^^" .
Thus, for a matrix A, A.A = A^^2 and, if it exists, A^^-1 is the
inverse of A.
The operations +,-,*,** are all element-by-element operations; all
operations are normally carried out in full, including the . (dot)
operation.  Many switches exist for controlling simplification rules
involving dot and matrix-list operations.
Options Relating to Matrices:
LMXCHAR, RMXCHAR, RATMX, LISTARITH, DETOUT, DOALLMXOPS, DOMXEXPT
DOMXMXOPS, DOSCMXOPS, DOSCMXPLUS, SCALARMATRIX, and SPARSE.
Do DESCRIBE(option) for details on them.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MATRIXMAP</B> <I>(fn, M)</I>
<DD><A NAME="IDX670"></A>
will map the function fn onto each element of the
matrix M.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MATRIXP</B> <I>(exp)</I>
<DD><A NAME="IDX671"></A>
is TRUE if exp is a matrix else FALSE.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>MATRIX_ELEMENT_ADD</B>
<DD><A NAME="IDX672"></A>
 default: [+] - May be set to "?"; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.  For more details,
do DEMO("matrix.dem1"); and DEMO("matrix.dem2");.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>MATRIX_ELEMENT_MULT</B>
<DD><A NAME="IDX673"></A>
 default: [*] - May be set to "."; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.  For more details,
do DEMO("matrix.dem1"); and DEMO("matrix.dem2");

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>MATRIX_ELEMENT_TRANSPOSE</B>
<DD><A NAME="IDX674"></A>
 default: [FALSE] - Other useful settings are
TRANSPOSE and NONSCALARS; may also be the name of a function, or a
LAMBDA expression.  In this way, a rich variety of algebraic
structures may be simulated.  For more details, do
DEMO("matrix.dem1"); and DEMO("matrix.dem2");.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MATTRACE</B> <I>(M)</I>
<DD><A NAME="IDX675"></A>
computes the trace [sum of the elements on the main diagonal] of
the square matrix M.  It is used by NCHARPOLY, an alternative to MACSYMA's
CHARPOLY.  It is used by doing LOADFILE("nchrpl");

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MINOR</B> <I>(M, i, j)</I>
<DD><A NAME="IDX676"></A>
computes the i,j minor of the matrix M.  That is, M
with row i and column j removed.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NCEXPT</B> <I>(A,B)</I>
<DD><A NAME="IDX677"></A>
if an (non-commutative) exponential expression is too
wide to be displayed as A^^B it will appear as NCEXPT(A,B).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NCHARPOLY</B> <I>(M,var)</I>
<DD><A NAME="IDX678"></A>
finds the characteristic polynomial of the matrix M
with respect to var.  This is an alternative to MACSYMA's CHARPOLY.
NCHARPOLY works by computing traces of powers of the given matrix,
which are known to be equal to sums of powers of the roots of the
characteristic polynomial.  From these quantities the symmetric
functions of the roots can be calculated, which are nothing more than
the coefficients of the characteristic polynomial.  CHARPOLY works by
forming the determinant of VAR * IDENT [N] - A.  Thus NCHARPOLY wins,
for example, in the case of large dense matrices filled with integers,
since it avoids polynomial arithmetic altogether.  It may be used by
doing LOADFILE("nchrpl");

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NEWDET</B> <I>(M,n)</I>
<DD><A NAME="IDX679"></A>
also computes the determinant of M but uses the
Johnson-Gentleman tree minor algorithm.  M may be the name of a
matrix or array.  The argument n is the order; it is optional if M is
a matrix.

</P>
</DL>
<P>
<DL>
<DT><U>declaration:</U> <B>NONSCALAR</B>
<DD><A NAME="IDX680"></A>
 - makes ai behave as does a list or matrix with respect to
the dot operator.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>NONSCALARP</B> <I>(exp)</I>
<DD><A NAME="IDX681"></A>
is TRUE if exp is a non-scalar, i.e.  it contains
atoms declared as non-scalars, lists, or matrices.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>PERMANENT</B> <I>(M,n)</I>
<DD><A NAME="IDX682"></A>
computes the permanent of the matrix M.  A permanent
is like a determinant but with no sign changes.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>RANK</B> <I>(M)</I>
<DD><A NAME="IDX683"></A>
computes the rank of the matrix M.  That is, the order of the
largest non-singular subdeterminant of M.  Caveat: RANK may return the
wrong answer if it cannot determine that a matrix element that is
equivalent to zero is indeed so.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>RATMX</B>
<DD><A NAME="IDX684"></A>
 default: [FALSE] - if FALSE will cause determinant and matrix
addition, subtraction, and multiplication to be performed in the
representation of the matrix elements and will cause the result of
matrix inversion to be left in general representation.  If it is TRUE,
the 4 operations mentioned above will be performed in CRE form and the
result of matrix inverse will be in CRE form.  Note that this may
cause the elements to be expanded (depending on the setting of RATFAC)
which might not always be desired.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ROW</B> <I>(M, i)</I>
<DD><A NAME="IDX685"></A>
gives a matrix of the ith row of matrix M.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>SCALARMATRIXP</B>
<DD><A NAME="IDX686"></A>
 default: [TRUE] - if TRUE, then whenever a 1 x 1 matrix
is produced as a result of computing the dot product of matrices it
will be converted to a scalar, namely the only element of the matrix.
If set to ALL, then this conversion occurs whenever a 1 x 1 matrix is
simplified.  If set to FALSE, no conversion will be done.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SETELMX</B> <I>(x, i, j, M)</I>
<DD><A NAME="IDX687"></A>
changes the i,j element of M to x.  The altered
matrix is returned as the value.  The notation M[i,j]:x may also be
used, altering M in a similar manner, but returning x as the value.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SIMILARITYTRANSFORM</B> <I>(MAT)</I>
<DD><A NAME="IDX688"></A>
a function in the EIGEN package.  Do
LOAD(EIGEN) to use it.  SIMILARITYTRANSFORM takes a MATRIX as its
argument and returns a list which is the output of the
UNITEIGENVECTORS command.  In addition if the flag NONDIAGONALIZABLE
is FALSE two global matrices LEFTMATRIX and RIGHTMATRIX will be
generated.  These matrices have the property that
LEFTMATRIX.MAT.RIGHTMATRIX is a diagonal matrix with the eigenvalues
of MAT on the diagonal.  If NONDIAGONALIZABLE is TRUE these two
matrices will not be generated.  If the flag HERMITIANMATRIX is TRUE
then LEFTMATRIX is the complex conjugate of the transpose of
RIGHTMATRIX.  Otherwise LEFTMATRIX is the inverse of RIGHTMATRIX.
RIGHTMATRIX is the matrix the columns of which are the unit
eigenvectors of MAT.  The other flags (see DESCRIBE(EIGENVALUES); and
DESCRIBE(EIGENVECTORS);) have the same effects since
SIMILARITYTRANSFORM calls the other functions in the package in order
to be able to form RIGHTMATRIX.

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>SPARSE</B>
<DD><A NAME="IDX689"></A>
 default: [FALSE] - if TRUE and if RATMX:TRUE then DETERMINANT
will use special routines for computing sparse determinants.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>SUBMATRIX</B> <I>(m1, ..., M, n1, ...)</I>
<DD><A NAME="IDX690"></A>
creates a new matrix composed of the
matrix M with rows mi deleted, and columns ni deleted.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>TRANSPOSE</B> <I>(M)</I>
<DD><A NAME="IDX691"></A>
produces the transpose of the matrix M.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>TRIANGULARIZE</B> <I>(M)</I>
<DD><A NAME="IDX692"></A>
produces the upper triangular form of the matrix M
which needn't be square.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>UNITEIGENVECTORS</B> <I>(MAT)</I>
<DD><A NAME="IDX693"></A>
a function in the EIGEN package.  Do
LOAD(EIGEN) to use it.  UNITEIGENVECTORS takes a MATRIX as its
argument and returns a list of lists the first sublist of which is the
output of the EIGENVALUES command and the other sublists of which are
the unit eigenvectors of the matrix corresponding to those eigenvalues
respectively.  The flags mentioned in the description of the
EIGENVECTORS command have the same effects in this one as well.  In
addition there is a flag which may be useful :
KNOWNEIGVECTS[FALSE] - If set to TRUE the EIGEN package will assume
that the eigenvectors of the matrix are known to the user and are
stored under the global name LISTEIGVECTS.  LISTEIGVECTS should be set
to a list similar to the output of the EIGENVECTORS command.  (If
KNOWNEIGVECTS is set to TRUE and the list of eigenvectors is given the
setting of the flag NONDIAGONALIZABLE may not be correct.  If that is
the case please set it to the correct value.  The author assumes that
the user knows what he is doing and will not try to diagonalize a
matrix the eigenvectors of which do not span the vector space of the
appropriate dimension...)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>UNITVECTOR</B> <I>(X)</I>
<DD><A NAME="IDX694"></A>
a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  UNITVECTOR takes a LIST as its argument and returns a unit
list.  (i.e. a list with unit magnitude).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>VECTORSIMP</B> <I>(vectorexpression)</I>
<DD><A NAME="IDX695"></A>
This function employs additional
simplifications, together with various optional
expansions according to the settings of the following global flags:

</P>

<PRE>
EXPANDALL, EXPANDDOT, EXPANDDOTPLUS, EXPANDCROSS, EXPANDCROSSPLUS,
EXPANDCROSSCROSS, EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD,
EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD, EXPANDCURL, EXPANDCURLPLUS,
EXPANDCURLCURL, EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS,
EXPANDLAPLACIANPROD.
</PRE>

<P>
All these flags have default value FALSE. The PLUS suffix refers to
employing additivity or distributivity.  The PROD suffix refers to the
expansion for an operand that is any kind of product.
EXPANDCROSSCROSS refers to replacing p~(q~r) with (p.r)*q-(p.q)*r, and
EXPANDCURLCURL refers to replacing CURL CURL p with GRAD DIV p + DIV
GRAD p.  EXPANDCROSS:TRUE has the same effect as
EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other flags,
EXPANDPLUS and EXPANDPROD, have the same effect as setting all
similarly suffixed flags true.  When TRUE, another flag named
EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
composition DIV GRAD.  All of these flags are initially FALSE.  For
convenience, all of these flags have been declared EVFLAG.
For orthogonal curvilinear coordinates, the global variables
COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are set
by the function invocation

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>VECT_CROSS</B>
<DD><A NAME="IDX696"></A>
 default:[FALSE] - If TRUE allows DIFF(X~Y,T) to work where
~ is defined in SHARE;VECT (where VECT_CROSS is set to TRUE, anyway.)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ZEROMATRIX</B> <I>(m,n)</I>
<DD><A NAME="IDX697"></A>
takes integers m,n as arguments and returns an m by
n matrix of 0's.

</P>
</DL>
<P>
<DL>
<DT><U>special symbol:</U> <B>"["</B>
<DD><A NAME="IDX698"></A>
  - [ and ] are the characters which MACSYMA uses to delimit a
list.
</DL>

</P>
<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_25.html">previous</A>, <A HREF="maxima_27.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
