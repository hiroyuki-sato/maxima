<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from maxima.texi on 10 May 2004 -->

<TITLE>Maxima Manual - Lists</TITLE>
<link href="maxima_38.html" rel=Next>
<link href="maxima_36.html" rel=Previous>
<link href="maxima_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_36.html">previous</A>, <A HREF="maxima_38.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC115" HREF="maxima_toc.html#TOC115">Lists</A></H1>



<H2><A NAME="SEC116" HREF="maxima_toc.html#TOC116">Introduction to Lists</A></H2>
<P>
Lists are the basic building block for maxima and lisp.   All data types
other than arrays, hash tables, numbers are represented as lisp lists,
These lisp lists have the form

<PRE>
((mplus) $A 2)
</PRE>

<P>
to indicate an expression <CODE>A+2</CODE>.   At maxima level one would see
the infix notation <CODE>A+2</CODE>.   Maxima also has lists which are printed
as

<PRE>
[1, 2, 7, x+y]
</PRE>

<P>
for a list with 4 elements.   Internally this corresponds to a lisp list
of the form

<PRE>
((mlist) 1  2  7  ((mplus)  $X $Y ))
</PRE>

<P>
The flag which denotes the type field of the maxima expression is a list
itself, since after it has been through the simplifier the list would become

<PRE>
((mlist simp) 1 2 7 ((mplus simp) $X $Y))
</PRE>



<H2><A NAME="SEC117" HREF="maxima_toc.html#TOC117">Definitions for Lists</A></H2>

<P>
<DL>
<DT><U>Function:</U> <B>APPEND</B> <I>(list1, list2, ...)</I>
<DD><A NAME="IDX917"></A>
returns a single list of the elements of
list1 followed by the elements of list2,...  APPEND also works on
general expressions, e.g. APPEND(F(A,B), F(C,D,E)); -&#62; F(A,B,C,D,E).
Do EXAMPLE(APPEND); for an example.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ASSOC</B> <I>(exp)</I>
<DD><A NAME="IDX918"></A>
This function searches for the key in the left hand side of the input list
of the form [x,y,z...] where each of the list elements is a expression of
a binary operand and 2 elements.  For example x=1, 2^3, [a,b] etc.
The key checked againts the first operand and and returns the second
operand if the key is found.
If the key is not found it either returns the default value if supplied or
false.
</DL>
<DL>
<DT><U>Function:</U> <B>ATOM</B> <I>(exp)</I>
<DD><A NAME="IDX919"></A>
is TRUE if exp is atomic (i.e. a number or name) else
FALSE.  Thus ATOM(5) is TRUE while ATOM(A[1]) and ATOM(SIN(X)) are
FALSE.  (Assuming A[1] and X are unbound.)

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>CONS</B> <I>(exp, list)</I>
<DD><A NAME="IDX920"></A>
returns a new list constructed of the element exp as
its first element, followed by the elements of list.  CONS also works
on other expressions, e.g. CONS(X, F(A,B,C));  -&#62;  F(X,A,B,C).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>COPYLIST</B> <I>(L)</I>
<DD><A NAME="IDX921"></A>
creates a copy of the list L.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>DELETE</B> <I>(exp1, exp2)</I>
<DD><A NAME="IDX922"></A>
removes all occurrences of exp1 from exp2.  Exp1
may be a term of exp2 (if it is a sum) or a factor of exp2 (if it is a
product).

<PRE>
(C1)  DELETE(SIN(X),X+SIN(X)+Y);
(D1)               Y + X

</PRE>

<P>
DELETE(exp1, exp2, integer) removes the first integer occurrences of
exp1 from exp2.  Of course, if there are fewer than integer
occurrences of exp1 in exp2 then all occurrences will be deleted.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>ENDCONS</B> <I>(exp, list)</I>
<DD><A NAME="IDX923"></A>
returns a new list consisting of the elements of
list followed by exp.  ENDCONS also works on general expressions, e.g.
ENDCONS(X, F(A,B,C));  -&#62;  F(A,B,C,X).

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>EVERY</B> <I>(exp)</I>
<DD><A NAME="IDX924"></A>
This function takes a list, or a positive number of arguments and returns
true if all its arguments are not false.

</P>
</DL>

<P>
<DL>
<DT><U>Function:</U> <B>FIRST</B> <I>(exp) SECOND (exp) .. TENTH (exp)</I>
<DD><A NAME="IDX925"></A>
yields the first part of exp which may result in the first
element of a list, the first row of a matrix, the first term of a sum,
etc.  Note that FIRST and its related functions, REST and LAST, work
on the form of exp which is displayed not the form which is typed on
input.  If the variable INFLAG [FALSE] is set to TRUE however, these
functions will look at the internal form of exp.  Note that the
simplifier re-orders expressions.  Thus FIRST(X+Y) will be X if INFLAG
is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same
results).  The functions SECOND .. TENTH yield the second through the
tenth part of their input argument.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>FLATTEN(exp)</B>
<DD><A NAME="IDX926"></A>
Takes a list of the form [[1,2],[3,4]] and returns [1,2,3,4].

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>GET</B> <I>(a, i)</I>
<DD><A NAME="IDX927"></A>
retrieves the user property indicated by i associated with
atom a or returns FALSE if a doesn't have property i.

<PRE>
(C1) PUT(%E,'TRANSCENDENTAL,'TYPE);
(D1) 			        TRANSCENDENTAL
(C2) PUT(%PI,'TRANSCENDENTAL,'TYPE)$
(C3) PUT(%I,'ALGEBRAIC,'TYPE)$
(C4) TYPEOF(EXP) := BLOCK([Q],
                        IF NUMBERP(EXP)
                        THEN RETURN('ALGEBRAIC),
                        IF NOT ATOM(EXP)
                        THEN RETURN(MAPLIST('TYPEOF, EXP)),
                        Q : GET(EXP, 'TYPE),
                        IF Q=FALSE
			THEN ERRCATCH(ERROR(EXP,"is not numeric.")) ELSE Q)$
(C5) TYPEOF(2*%E+X*%PI);
X is not numeric.
(D5) 	     [[TRANSCENDENTAL, []], [ALGEBRAIC, TRANSCENDENTAL]]
(C6) TYPEOF(2*%E+%PI);
(D6) 	        [TRANSCENDENTAL, [ALGEBRAIC, TRANSCENDENTAL]]

</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LAST</B> <I>(exp)</I>
<DD><A NAME="IDX928"></A>
yields the last part (term, row, element, etc.) of the exp.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LENGTH</B> <I>(exp)</I>
<DD><A NAME="IDX929"></A>
gives (by default) the number of parts in the external
(displayed) form of exp.  For lists this is the number of elements,
for matrices it is the number of rows, and for sums it is the number
of terms. (See DISPFORM).  The LENGTH command is affected by the
INFLAG switch [default FALSE].  So, e.g. LENGTH(A/(B*C)); gives 2 if
INFLAG is FALSE (Assuming EXPTDISPFLAG is TRUE), but 3 if INFLAG is
TRUE (the internal representation is essentially A*B^-1*C^-1).

</P>
</DL>
<P>
<DL>
<DT><U>Variable:</U> <B>LISTARITH</B>
<DD><A NAME="IDX930"></A>
 default: [TRUE] - if FALSE causes any arithmetic operations
with lists to be suppressed; when TRUE, list-matrix operations are
contagious causing lists to be converted to matrices yielding a result
which is always a matrix.  However, list-list operations should return
lists.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>LISTP</B> <I>(exp)</I>
<DD><A NAME="IDX931"></A>
is TRUE if exp is a list else FALSE.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MAKELIST</B> <I>(exp,var,lo,hi)</I>
<DD><A NAME="IDX932"></A>
returns a list as value.  MAKELIST may be called as
MAKELIST(exp,var,lo,hi) ["lo" and "hi" must be integers], or as
MAKELIST(exp,var,list).  In the first case MAKELIST is analogous to
SUM, whereas in the second case MAKELIST is similar to MAP.  Examples:

<PRE>
   MAKELIST(CONCAT(X,I),I,1,6) yields [X1,X2,X3,X4,X5,X6]
   MAKELIST(X=Y,Y,[A,B,C]) yields [X=A,X=B,X=C]
</PRE>

</DL>
<P>
<DL>
<DT><U>Function:</U> <B>MEMBER</B> <I>(exp, list)</I>
<DD><A NAME="IDX933"></A>
returns TRUE if exp occurs as a member of list (not
within a member).  Otherwise FALSE is returned.  Member also works on
non-list expressions, e.g. MEMBER(B, F(A,B,C));  -&#62;  TRUE.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>REST</B> <I>(exp, n)</I>
<DD><A NAME="IDX934"></A>
yields exp with its first n elements removed if n is
positive and its last -n elements removed if n is negative.  If n is 1
it may be omitted.  Exp may be a list, matrix, or other expression.

</P>
</DL>
<P>
<DL>
<DT><U>Function:</U> <B>REVERSE</B> <I>(list)</I>
<DD><A NAME="IDX935"></A>
reverses the order of the members of the list (not
the members themselves).  REVERSE also works on general expressions,
e.g.  REVERSE(A=B); gives B=A.
REVERSE default: [FALSE] - in the Plotting functions, if TRUE cause a
left-handed coordinate system to be assumed.

</P>
</DL>

<P><HR><P>
<p>Go to the <A HREF="maxima_1.html">first</A>, <A HREF="maxima_36.html">previous</A>, <A HREF="maxima_38.html">next</A>, <A HREF="maxima_42.html">last</A> section, <A HREF="maxima_toc.html">table of contents</A>.
</BODY>
</HTML>
