This is maxima.info, produced by makeinfo version 4.8 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994,2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definiciones para Contextos,  Prev: Contextos,  Up: Contextos

11.1 Definiciones para Contextos
================================

 -- Función: activate (<context_1>, ..., <context_n>)
     Activa los contextos <context_1>, ..., <context_n>.  Los hechos en
     estos contextos están disponibles para hacer deducciones y extraer
     información.  Los hechos en estos contextos no se listan al
     invocar `facts ()'.

     La variable `activecontexts' es la lista de contextos que se han
     activado por medio de la función `activate'.


 -- Variable del sistema: activecontexts
     Valor por defecto: `[]'

     La variable `activecontexts' es la lista de contextos que se han
     activado por medio de la función `activate', pero que no se han
     activado por ser subcontextos del contexto actual.


 -- Función: assume (<pred_1>, ..., <pred_n>)
     Añade los predicados <pred_1>, ..., <pred_n> al contexto actual.
     Si un predicado es inconsistente o redundante con los otros
     predicados del contexto actual, entonces no es añadido al contexto.
     El contexto va acumulando predicados con cada llamada a `assume'.

     La función `assume' devuelve una lista cuyos miembros son los
     predicados que han sido añadidos al contexto, o los átomos
     `redundant' o `inconsistent' si fuere necesario.

     Los predicados <pred_1>, ..., <pred_n> tan solo pueden ser
     expresiones formadas con los operadores relacionales `< <= equal
     notequal >=' y `>'. Los predicados no pueden estar formados por
     expresiones que sean del tipo igualdad `=' ni del tipo desigualdad
     `#', ni tampoco pueden ser funciones de predicado como `integerp'.

     En cambio, sí se reconocen predicados compuestos de la forma
     `<pred_1> and ... and <pred_n>', pero no `<pred_1> or ... or
     <pred_n>'.  También se reconoce `not <pred_k>' si <pred_k> es un
     predicado relacional. Expresiones de la forma `not (<pred_1> and
     <pred_2>)' y `not (<pred_1> or <pred_2>)' no son reconocidas.

     El mecanismo deductivo de Maxima no es muy potente; existen muchas
     consecuencias que, siendo obvias, no pueden ser obtenidas por `is'.
     Se trata de una debilidad reconocida.

     La función `assume' evalúa sus argumentos.

     Véanse también `is', `facts', `forget', `context' y `declare'.

     Ejemplos:

          (%i1) assume (xx > 0, yy < -1, zz >= 0);
          (%o1)              [xx > 0, yy < - 1, zz >= 0]
          (%i2) assume (aa < bb and bb < cc);
          (%o2)                  [bb > aa, cc > bb]
          (%i3) facts ();
          (%o3)     [xx > 0, - 1 > yy, zz >= 0, bb > aa, cc > bb]
          (%i4) is (xx > yy);
          (%o4)                         true
          (%i5) is (yy < -yy);
          (%o5)                         true
          (%i6) is (sinh (bb - aa) > 0);
          (%o6)                         true
          (%i7) forget (bb > aa);
          (%o7)                       [bb > aa]
          (%i8) prederror : false;
          (%o8)                         false
          (%i9) is (sinh (bb - aa) > 0);
          (%o9)                        unknown
          (%i10) is (bb^2 < cc^2);
          (%o10)                       unknown


 -- Variable opcional: assumescalar
     Valor por defecto: `true'

     La variable `assumescalar' ayuda a controlar si una expresión
     `expr' para la cual `nonscalarp (expr)' es `false' va a tener un
     comportamiento similar a un escalar bajo ciertas transformaciones.

     Sea `expr' cualquier expresión distinta de una lista o matriz, y
     sea también `[1, 2, 3]' una lista o una matriz. Entonces, `expr .
     [1, 2, 3]' dará como resultado `[expr, 2 expr, 3 expr]' si
     `assumescalar' es `true', o si `scalarp (expr)' es `true', o si
     `constantp (expr)' es `true'.

     Si `assumescalar' vale `true', la expresión se comportará como un
     escalar sólo en operaciones conmutativas, pero no en el caso de la
     multiplicación no conmutativa o producto matricial `.'.

     Si `assumescalar' vale `false', la expresión se comportará como un
     no escalar.

     Si `assumescalar' vale `all', la expresión se comportará como un
     escalar para todas las operaciones.


 -- Variable opcional: assume_pos
     Valor por defecto: `false'

     Si `assume_pos' vale `true' y el signo de un parámetro <x> no
     puede ser determinado a partir del contexto actual o de otras
     consideraciones, `sign' y `asksign (<x>)' devolverán `true'. Con
     esto se pueden evitar algunas preguntas al usuario que se generan
     automáticamente, como las que hacen `integrate' y otras funciones.

     By default, a parameter is <x> such that `symbolp (<x>)' or
     `subvarp (<x>)'.

     Por defecto, un parámetro <x> es aquel para el que `symbolp (<x>)'
     o `subvarp (<x>)' devuelven `true'.  La clase de expresiones que
     se consideran parámetros se puede extender mediante la utilización
     de la variable `assume_pos_pred'.

     Las funciones `sign' y `asksign' intentan deducir el signo de una
     expresión a partir de los signos de los operandos que contiene.
     Por ejemplo, si `a' y `b' son ambos positivos, entonces `a + b'
     también es positivo.

     Sin embargo, no es posible obviar todas las preguntas que hace
     `asksign'. En particular, cuando el argumento de `asksign' es una
     diferencia `<x> - <y>' o un logaritmo `log(<x>)', `asksign'
     siempre solicita una respuesta por parte del usuario, incluso
     cuando `assume_pos' vale `true' y `assume_pos_pred' es una función
     que devuelve `true' para todos los argumentos.


 -- Variable opcional: assume_pos_pred
     Valor por defecto: `false'

     Cuando a `assume_pos_pred' se le asigna el nombre de una función o
     una expresión lambda de un único argumento <x>, ésta será invocada
     para determinar si <x> se considera un parámetro por `assume_pos'.
     La variable `assume_pos_pred' se ignora cuando `assume_pos' vale
     `false'.

     La función `assume_pos_pred' es invocada por  `sign' y por
     `asksign' con un argumento <x>, el cual puede ser un átomo, una
     variable subindicada o una expresión de llamada a una función. Si
     la función `assume_pos_pred' devuelve `true', <x> será considerada
     como un parámetro por `assume_pos'.

     Por defecto, un parámetro <x> es aquel para el que `symbolp (<x>)'
     o `subvarp (<x>)' devuelven `true'.

     Véanse también `assume' y `assume_pos'.

     Ejemplos:

          (%i1) assume_pos: true$
          (%i2) assume_pos_pred: symbolp$
          (%i3) sign (a);
          (%o3)                          pos
          (%i4) sign (a[1]);
          (%o4)                          pnz
          (%i5) assume_pos_pred: lambda ([x], display (x), true)$
          (%i6) asksign (a);
                                        x = a

          (%o6)                          pos
          (%i7) asksign (a[1]);
                                       x = a
                                            1

          (%o7)                          pos
          (%i8) asksign (foo (a));
                                     x = foo(a)

          (%o8)                          pos
          (%i9) asksign (foo (a) + bar (b));
                                     x = foo(a)

                                     x = bar(b)

          (%o9)                          pos
          (%i10) asksign (log (a));
                                        x = a

          Is  a - 1  positive, negative, or zero?

          p;
          (%o10)                         pos
          (%i11) asksign (a - b);
                                        x = a

                                        x = b

                                        x = a

                                        x = b

          Is  b - a  positive, negative, or zero?

          p;
          (%o11)                         neg


 -- Variable opcional: context
     Valor por defecto: `initial'

     La variable `context' da nombre al conjunto de hechos establecidos
     desde `assume' y `forget'. La función `assume' añade nuevos hechos
     al conjunto nombrado por `context', mientras que `forget' los va
     eliminando.  Asignando a `context' un nuevo nombre <foo> cambia el
     contexto actual a <foo>. Si el contexto <foo> no existe todavía,
     se crea automáticamente mediante una llamada a `newcontext'.

     Véase `contexts' para una descripción general del mecanismo que
     siguen los contextos.


 -- Variable opcional: contexts
     Valor por defecto: `[initial, global]'

     La variable `contexts' es una lista que contiene los contextos
     existentes, incluyendo el actualmente activo.

     The context mechanism makes it possible for a user to bind together
     and name a collection of facts, called a context.

     El mecanismo que siguen los contextos permiten al usuario agrupar
     y nombrar un conjunto de hechos, que recibe el nombre de contexto.
     Una vez hecho esto, el usuario puede hacer que Maxima tenga en
     cuenta o que olvide cualquier número de hechos sin más que activar
     o desactivar su contexto.

     Cualquier átomo simbólico puede ser el nombre de un contexto, y
     los hechos contenidos en tal contexto pueden ser almacenados hasta
     que se destruyan uno a uno mediante llamadas a la función
     `forget', o que se destruyan conjuntamente invocando a `kill' para
     eliminar el contexto al que pertenecen.

     Los contextos tienen estructura jerárquica, siendo su raíz el
     contexto `global', el cual contiene información sobre Maxima que
     necesitan algunas funciones. Cuando en un contexto todos los
     hechos están activos (lo que significa que están siendo utilizados
     en deducciones) lo estarán también en cualquier subcontexto del
     contexto actual.

     Cuando se comienza una sesión de Maxima, el usuario estará
     trabajando en un contexto llamado `initial', el cual tiene un
     subcontexto de nombre `global'.

     Véanse también `facts', `newcontext', `supcontext', `killcontext',
     `activate', `deactivate', `assume' y `forget'.


 -- Función: deactivate (<contexto_1>, ..., <contexto_n>)
     Desactiva los contextos especificados <contexto_1>, ...,
     <contexto_n>.


 -- Función: facts (<item>)
 -- Función: facts ()
     Si <item> es el nombre de un contexto, `facts (<item>)' devuelve
     una lista con los hechos asociados al contexto especificado.

     Si <item> no es el nombre de un contexto, `facts (<item>)'
     devuelve una lista con los hechos conocidos acerca de <item> en el
     contexto actual. Los hechos que estén activos en contextos
     diferentes no aparecen en la lista.

     La lamada `facts ()', sin argumentos, muestra el contexto actual.


 -- Declaración: features
     Maxima reconoce ciertas propiedades matemáticas sobre funciones y
     variables.

     La llamada `declare (<x>, <foo>)' asocia la propiedad <foo> a la
     función o variable <x>.

     La llamada `declare (<foo>, feature)' declara una nueva propiedad
     <foo>. Por ejemplo, `declare ([rojo, verde, azul], feature)'
     declara tres nuevas propiedades, `rojo', `verde' y `azul'.

     El predicado `featurep (<x>, <foo>)' devuelve `true' si <x> goza
     de la propiedad <foo>, y `false' en caso contrario.

     La lista `features' contiene las propiedades que reconoce Maxima;
     a saber, `integer', `noninteger', `even', `odd', `rational',
     `irrational', `real', `imaginary', `complex', `analytic',
     `increasing', `decreasing', `oddfun', `evenfun', `posfun',
     `commutative', `lassociative', `rassociative', `symmetric', and
     `antisymmetric', junto con las definidas por el usuario.

     La lista `features' sólo contiene propiedades matemáticas. Hay
     otra lista con propiedades no matemáticas; Véase `status'.


 -- Función: forget (<pred_1>, ..., <pred_n>)
 -- Función: forget (<L>)
     Borra los predicados establecidos por `assume'. Los predicados
     pueden ser expresiones equivalentes, pero no necesariamente
     idénticas, a las establecidas por `assume'.  The predicates may be
     expressions equivalent to (but not necessarily identical to) those
     previously assumed.

     La llamada `forget (<L>)', siendo <L> una lista de predicados,
     borra todos los predicados contenidos en ella.


 -- Función: killcontext (<contexto_1>, ..., <contexto_n>)
     Elimina los contextos <contexto_1>, ..., <contexto_n>.

     Si alguno de estos contextos es el actual, el nuevo contexto
     activo será el primer subcontexto disponible del actual que no
     haya sido eliminado. Si el primer contexto no eliminado disponible
     es `global' entonces `initial' será usado en su lugar.  Si el
     contexto `initial' es eliminado, se creará un nuevo contexto
     `initial' completamente vacío.

     La función `killcontext' no elimina un contexto actualmente activo
     si es un subcontexto del contexto actual, o si se hace uso de la
     función `activate'.

     La función `killcontext' evalúa sus argumentos y devuelve `done'.


 -- Función: newcontext (<nombre>)
     Crea un nuevo contexto vacío <nombre>, el cual tiene a `global'
     como su único subcontexto. El recién creado contexto pasa a ser el
     contexto actualmente activo.

     La función `newcontext' evalúa sus argumentos y devuelve <nombre>.


 -- Función: supcontext (<nombre>, <contexto>)
 -- Función: supcontext (<nombre>)
     Crea un nuevo contexto <nombre>, que tiene a <contexto> como
     subcontexto. El argumento <contexto> debe existir ya.

     Si no se especifica <context>, se tomará como tal el actual.



File: maxima.info,  Node: Polinomios,  Next: Constantes,  Prev: Contextos,  Up: Top

12 Polinomios
*************

* Menu:

* Introducción a los Polinomios::
* Definiciones para Polinomios::


File: maxima.info,  Node: Introducción a los Polinomios,  Next: Definiciones para Polinomios,  Prev: Polinomios,  Up: Polinomios

12.1 Introducción a los Polinomios
==================================

Los polinomios se almacenan en Maxima, bien en un formato general, bien
en una forma conocida como canónica (Cannonical Rational Expressions,
CRE). La última corresponde al formato estándar y se utiliza
internamente para realizar operaciones como `factor', `ratsimp' y demás.

   Las Expresiones Racionales Canónicas (CRE) constituyen un tipo de
representación que es especialmente apropiado para expandir polinomios
y funciones racionales (así como para polinomios parcialmente
factorizados y funciones racionales cuando a la variable `ratfac' se le
asigna el valor `true'). En esta forma CRE las variables se ordenan de
mayor a menor. Los polinomios se representan recursivamente como una
lista compuesta por la variable principal seguida por una serie de
pares de expresiones, una por cada término del polinomio. El primer
miembro de cada par es el exponente de la variable principal en ese
término y el segundo miembro es el coeficiente de ese término, el cual
puede ser un número o un polinomio en otra variable representado
también de esta forma. Así, la parte principal de la forma CRE de
3*X^2-1 es (X 2 3 0 -1) y la de 2*X*Y+X-3 es (Y 1 (X 1 2) 0 (X 1 1 0
-3)) asumiendo que Y es la variable principal, y será (X 1 (Y 1 2 0 1)
0 -3) si se asume que la variable principal es X. Qué variable se
considera "principal" se determinada en orden alfabético inverso.  Las
"variables" de la expresión CRE no son necesariamente atómicas. De hecho
cualquier subexpresión cuyo operador principal no es + - * / ni ^ con
potencia entera puede ser considerada como una "variable" de la
expresión (en forma CRE) en el cual aparezca. Por ejemplo las variables
CRE de la expresión X+SIN(X+1)+2*SQRT(X)+1 son X, SQRT(X)  y SIN(X+1).
Si el usuario no especifica una ordenación de las variables mediante la
función `ratvars' Maxima escogerá una alfabéticamente. En general, laa
CRE representan expresiones racionales, esto es, fracciones de
polinomios, donde el numerador y el denominador  no tienen factores
comunes, siendo el denominador es positivo. La forma interna es
esencialmente un par de polinomios (el numerador y el denominador)
precedida por la lista de variables ordenadas. Si una expresión a ser
mostrada está en la forma CRE o contiene alguna subexpresión en forma
de CRE, el simbolo /R/ será seguido por la etiqueta de la línea de
comando.  Véase la función `rat' para convertir una expresión a la
forma CRE. Una extensión de la forma CRE se utiliza para la
representación de las series de Taylor. La noción de una expresión
racional se extiende de manera que los exponentes de las variables
pueden ser números racionales positivos o negativos y no sólo enteros
positivos y los coeficientes pueden ser también expresiones racionales
y no sólo polinomios. Estas expresiones se representan internamente por
una forma polinomial recursiva que es similar a la forma CRE, pero que
la generaliza, aportando información adicional como el grado de
truncamiento. Como con la forma CRE, el símbolo /T/ sigue la etiqueta
de línea de comando en la que se encuentra dicha expresión.


File: maxima.info,  Node: Definiciones para Polinomios,  Prev: Introducción a los Polinomios,  Up: Polinomios

12.2 Definiciones para Polinomios
=================================

 -- Variable opcional: algebraic
     Valor por defecto: `false'

     La variable `algebraic' debe valer `true' para que se pueda hacer
     la simplificación de enteros algebraicos.


 -- Variable opcional: berlefact
     Valor por defecto: `true'

     Si `berlefact' vale `false' entonces se utiliza el algoritmo de
     factorización de Kronecker, en caso contrario se utilizará el
     algoritmo de Berlekamp, que es el que se aplica por defecto.


 -- Función: bezout (<p1>, <p2>, <x>)
     Es una alternativa a la función `resultant'.  Devuelve una matriz.


 -- Función: bothcoef (<expr>, <x>)
     Devuelve una lista cuyo primer miembro es el coeficiente de <x> en
     <expr> (que coincide con el que devuelve `ratcoef' si <expr> está
     en formato CRE, o el que devuelve `coeff' si no está en este
     formato) y cuyo segundo miembro es la parte restante de <expr>.
     Esto es, `[A, B]' donde `<expr> = A*<x> + B'.

     Ejemplo:

          (%i1) islinear (expr, x) := block ([c],
                  c: bothcoef (rat (expr, x), x),
                  is (freeof (x, c) and c[1] # 0))$
          (%i2) islinear ((r^2 - (x - r)^2)/x, x);
          (%o2)                         true


 -- Función: coeff (<expr>, <x>, <n>)
     Devuelve el coeficiente de `<x>^<n>' en <expr>. El argumento <n>
     puede omitirse si es igual a la unidad. El argumento <x> puede ser
     un átomo  o una subexpresión completa de <expr>, por ejemplo
     `sin(x)', `a[i+1]', `x + y', etc. (En este último caso, la
     expresión `(x + y)' debe aparecer en <expr>).  En ocasiones puede
     ser necesario expandir o factorizar <expr> para hacer `<x>^<n>'
     explícito, lo cual no hace `coeff' automáticamente.

     Ejemplos:

          (%i1) coeff (2*a*tan(x) + tan(x) + b = 5*tan(x) + 3, tan(x));
          (%o1)                      2 a + 1 = 5
          (%i2) coeff (y + x*%e^x + 1, x, 0);
          (%o2)                         y + 1


 -- Función: combine (<expr>)
     Simplifica la suma <expr> combinando términos de con igual
     denominador reduciéndolos a un único término.


 -- Función: content (<p_1>, <x_1>, ..., <x_n>)
     Devuelve una lista cuyo primer miembro es el máximo común divisor
     de los coeficientes de los términos del polinomio <p_1> de
     variable <x_n> (este es el contenido) y cuyo segundo miembro es el
     polinomio <p_1> dividido por el contenido.

     Ejemplos:

          (%i1) content (2*x*y + 4*x^2*y^2, y);
                                             2
          (%o1)                   [2 x, 2 x y  + y]


 -- Función: denom (<expr>)
     Devuelve el denominador de la expresión racional <expr>.


 -- Función: divide (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Calcula el cociente y el resto del polinomio <p_1> dividido por el
     polinomio <p_2>, siendo la variable principal <x_n>.  Las otras
     funciones son como en la función `ratvars'. El resultado es una
     lista cuyo primer miembro es el cociente y el segundo miembro el
     resto.

     Ejemplos:

          (%i1) divide (x + y, x - y, x);
          (%o1)                       [1, 2 y]
          (%i2) divide (x + y, x - y);
          (%o2)                      [- 1, 2 x]

     Nótese que `y' es la variable principal en el segundo ejemplo.


 -- Función: eliminate ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_k>])
     Elimina variables de ecuaciones (o de expresiones que se supone
     valen cero) tomando resultantes sucesivas. Devuelve una lista con
     `<n> - <k>' expresiones y <k> variables <x_1>, ..., <x_k>
     eliminadas.  Primero se elimina  <x_1> dando `<n> - 1'
     expresiones, después se elimina `x_2', etc.  Si `<k> = <n>'
     entonces se devuelve una lista con una única expresión, libre de
     las variables <x_1>, ..., <x_k>. En este caso se llama a `solve'
     para resolver la última resultante para la última variable.

     Ejemplo:

          (%i1) expr1: 2*x^2 + y*x + z;
                                                2
          (%o1)                    z + x y + 2 x
          (%i2) expr2: 3*x + 5*y - z - 1;
          (%o2)                  - z + 5 y + 3 x - 1
          (%i3) expr3: z^2 + x - y^2 + 5;
                                    2    2
          (%o3)                    z  - y  + x + 5
          (%i4) eliminate ([expr3, expr2, expr1], [y, z]);
                       8         7         6          5          4
          (%o4) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                              3         2
                                      - 5154 x  - 1291 x  + 7688 x + 15376]


 -- Función: ezgcd (<p_1>, <p_2>, <p_3>, ...)
     Devuelve una lista cuyo primer elemento es el máximo común divisor
     (mcd) de los polinomios <p_1>, <p_2>, <p_3>, ...  siendo los
     miembros restantes los mismos polinomios divididos por el mcd. Se
     utiliza siempre el algoritmo `ezgcd'.


 -- Variable opcional: facexpand
     Valor por defecto: `true'

     La variable `facexpand' controla si los factores irreducibles
     devueltos por `factor' están en formato expandido (por defecto) o
     recursivo  (CRE normal).


 -- Función: factcomb (<expr>)
     Trata de combinar los coeficientes de los factoriales de <expr>
     con los mismos factoriales, convirtiendo, por ejemplo, `(n +
     1)*n!' en `(n + 1)!'.

     Si la variable `sumsplitfact' vale `false' hará que `minfactorial'
     se aplique después de `factcomb'.


 -- Función: factor (<expr>)
     Factoriza la expresión <expr>, que puede contener cualquier número
     de variables o funciones, en factores irreducibles respecto de los
     enteros. La llamada `factor (<expr>, p)' factoriza <expr> en el
     campo de los enteros con un elemento añadido cuyo polinomio mínimo
     es p.

     Si la variable `factorflag' vale `false' suprime la factorización
     de los factores enteros en las expresiones racionales.

     La variable `dontfactor' puede contener una lista de variables con
     respecto a las cuales no se factorizará (inicialmente está vacía).
     Tampoco se factorizará respecto de cualesquiera otra variables que
     sean menos importantes (según la ordenación que se sigue en el
     formato CRE) que aquellas que se encuentran en la lista
     `dontfactor'.

     Si la variable `savefactors' vale `true', los factores de una
     expresión en forma de producto se guardarán por ciertas funciones
     a fin de acelerar posteriores factorizaciones de expresiones que
     contengan algunos de estos mismos factores.

     Si `berlefact' vale `false' entonces se utiliza el algoritmo de
     factorización de Kronecker, en caso contrario se utilizará el
     algoritmo de Berlekamp, que es el que se aplica por defecto.

     La variable `intfaclim' guarda el mayor divisor que se ensayará al
     factorizar un número `bignum'. Si vale `false' (este es el caso
     cuando el usuario llama a `factor' explícitamente), o si el entero
     ocupa dos bytes, se intentará una factorización completa del
     entero. El valor dado por el usuario a `intfaclim' se utiliza en
     las llamadas internas a `factor'. Así, puede ser necesario cambiar
     `intfaclim' a fin de evitar que Maxima consuma un tiempo excesivo
     intentando factorizar números enteros grandes.

     Ejemplos:

          (%i1) factor (2^63 - 1);
                              2
          (%o1)              7  73 127 337 92737 649657
          (%i2) factor (-8*y - 4*x + z^2*(2*y + x));
          (%o2)               (2 y + x) (z - 2) (z + 2)
          (%i3) -1 - 2*x - x^2 + y^2 + 2*x*y^2 + x^2*y^2;
                          2  2        2    2    2
          (%o3)          x  y  + 2 x y  + y  - x  - 2 x - 1
          (%i4) block ([dontfactor: [x]], factor (%/36/(1 + 2*y + y^2)));
                                 2
                               (x  + 2 x + 1) (y - 1)
          (%o4)                ----------------------
                                     36 (y + 1)
          (%i5) factor (1 + %e^(3*x));
                                x         2 x     x
          (%o5)              (%e  + 1) (%e    - %e  + 1)
          (%i6) factor (1 + x^4, a^2 - 2);
                              2              2
          (%o6)             (x  - a x + 1) (x  + a x + 1)
          (%i7) factor (-y^2*z^2 - x*z^2 + x^2*y^2 + x^3);
                                 2
          (%o7)              - (y  + x) (z - x) (z + x)
          (%i8) (2 + x)/(3 + x)/(b + x)/(c + x)^2;
                                       x + 2
          (%o8)               ------------------------
                                                     2
                              (x + 3) (x + b) (x + c)
          (%i9) ratsimp (%);
                          4                  3
          (%o9) (x + 2)/(x  + (2 c + b + 3) x

               2                       2             2                   2
           + (c  + (2 b + 6) c + 3 b) x  + ((b + 3) c  + 6 b c) x + 3 b c )
          (%i10) partfrac (%, x);
                     2                   4                3
          (%o10) - (c  - 4 c - b + 6)/((c  + (- 2 b - 6) c

               2              2         2                2
           + (b  + 12 b + 9) c  + (- 6 b  - 18 b) c + 9 b ) (x + c))

                           c - 2
           - ---------------------------------
               2                             2
             (c  + (- b - 3) c + 3 b) (x + c)

                                   b - 2
           + -------------------------------------------------
                       2             2       3      2
             ((b - 3) c  + (6 b - 2 b ) c + b  - 3 b ) (x + b)

                                   1
           - ----------------------------------------------
                       2
             ((b - 3) c  + (18 - 6 b) c + 9 b - 27) (x + 3)
          (%i11) map ('factor, %);
                        2
                       c  - 4 c - b + 6                 c - 2
          (%o11) - ------------------------- - ------------------------
                          2        2                                  2
                   (c - 3)  (c - b)  (x + c)   (c - 3) (c - b) (x + c)

                                 b - 2                        1
                      + ------------------------ - ------------------------
                                       2                          2
                        (b - 3) (c - b)  (x + b)   (b - 3) (c - 3)  (x + 3)
          (%i12) ratsimp ((x^5 - 1)/(x - 1));
                                 4    3    2
          (%o12)                x  + x  + x  + x + 1
          (%i13) subst (a, x, %);
                                 4    3    2
          (%o13)                a  + a  + a  + a + 1
          (%i14) factor (%th(2), %);
                                 2        3        3    2
          (%o14)   (x - a) (x - a ) (x - a ) (x + a  + a  + a + 1)
          (%i15) factor (1 + x^12);
                                 4        8    4
          (%o15)               (x  + 1) (x  - x  + 1)
          (%i16) factor (1 + x^99);
                           2            6    3
          (%o16) (x + 1) (x  - x + 1) (x  - x  + 1)

             10    9    8    7    6    5    4    3    2
           (x   - x  + x  - x  + x  - x  + x  - x  + x  - x + 1)

             20    19    17    16    14    13    11    10    9    7    6
           (x   + x   - x   - x   + x   + x   - x   - x   - x  + x  + x

              4    3            60    57    51    48    42    39    33
           - x  - x  + x + 1) (x   + x   - x   - x   + x   + x   - x

              30    27    21    18    12    9    3
           - x   - x   + x   + x   - x   - x  + x  + 1)


 -- Variable opcional: factorflag
     Valor por defecto: `false'

     Si `factorflag' vale `false' se evita la factorización de factores
     enteros de expresiones racionales.


 -- Función: factorout (<expr>, <x_1>, <x_2>, ...)
     Reorganiza la suma <expr> como una suma de términos de la forma `f
     (<x_1>, <x_2>, ...)*g' donde `g' es un producto de expresiones que
     no contienen ningún <x_i> y `f' se factoriza.


 -- Función: factorsum (<expr>)
     Intenta agrupar términos en los factores de <expr> que son sumas
     en grupos de términos tales que su suma sea factorizable. La
     función `factorsum' puede restablecer el recuperar de `expand ((x
     + y)^2 + (z + w)^2)' pero no puede recuperar `expand ((x + 1)^2 +
     (x + y)^2)' porque los términos tienen variables comunes.

     Ejemplo:

          (%i1) expand ((x + 1)*((u + v)^2 + a*(w + z)^2));
                     2      2                            2      2
          (%o1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                                               2        2    2            2
                                  + 2 u v x + u  x + a w  + v  + 2 u v + u
          (%i2) factorsum (%);
                                             2          2
          (%o2)            (x + 1) (a (z + w)  + (v + u) )


 -- Función: fasttimes (<p_1>, <p_2>)
     Calcula el producto de los polinomios <p_1> y <p_2> utilizando un
     algoritmo especial. Los polinomios `p_1' y `p_2' deben ser
     multivariantes, densos y aproximadamente del mismo tamaño. La
     multiplicación clásica es de orden `n_1 n_2' donde `n_1' es el
     grado de  `p_1' y  `n_2' el grado de `p_2'. La función `fasttimes'
     es de orden `max (n_1, n_2)^1.585'.


 -- Función: fullratsimp (<expr>)
     Aplica repetidamente `ratsimp' a una expresión, seguida de
     simplificaciones no racionales, hasta que no se obtienen más
     transformaciones; entonces devuelve el resultado.

     En presencia de expresiones no racionales, una llamada a `ratsimp'
     seguida de una simplificación no racional ("general") puede no ser
     suficiente para conseguir un resultado simplificado. En ocasiones
     serán necesarias más de una llamada a `ratsimp', que es lo que
     hace precisamente `fullratsimp'.

     Ejemplo:

          (%i1) expr: (x^(a/2) + 1)^2*(x^(a/2) - 1)^2/(x^a - 1);
                                 a/2     2   a/2     2
                               (x    - 1)  (x    + 1)
          (%o1)                -----------------------
                                        a
                                       x  - 1
          (%i2) ratsimp (expr);
                                    2 a      a
                                   x    - 2 x  + 1
          (%o2)                    ---------------
                                        a
                                       x  - 1
          (%i3) fullratsimp (expr);
                                        a
          (%o3)                        x  - 1
          (%i4) rat (expr);
                                 a/2 4       a/2 2
                               (x   )  - 2 (x   )  + 1
          (%o4)/R/             -----------------------
                                        a
                                       x  - 1


 -- Función: fullratsubst (<a>, <b>, <c>)
     Similar a `ratsubst' excepto por el hecho de que se llama a í
     misma recursivamente hasta que el resultado deja de cambiar. Esta
     función es útil cuando la expresión a sustituir y la que la
     sustituye tienen variables comunes.

     La función `fullratsubst' también acepta sus argumentos en el
     formato de `lratsubst'.

     Es necesario ejecutar `load ("lrats")' para cargar `fullratsubst'
     y `lratsubst'.

     Ejemplos:

          (%i1) load ("lrats")$

        * `subst' puede hacer sustituciones múltiples; `lratsubst' es
          análoga a `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * Si sólo se quiere una sustitución, entonces se puede dar una
          única ecuación como primer argumento.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b

        * `fullratsubst' equivale a `ratsubst', excepto por el hecho de
          que se llama a í misma recursivamente hasta que el resultado
          deja de cambiar.

          (%i5) ratsubst (b*a, a^2, a^3);
                                         2
          (%o5)                         a  b
          (%i6) fullratsubst (b*a, a^2, a^3);
                                           2
          (%o6)                         a b

        * `fullratsubst' también acepta una lista de ecuaciones o una
          sóla ecuación como primer argumento.

          (%i7) fullratsubst ([a^2 = b, b^2 = c, c^2 = a], a^3*b*c);
          (%o7)                           b
          (%i8) fullratsubst (a^2 = b*a, a^3);
                                           2
          (%o8)                         a b

        * `fullratsubst' puede caer en una recursión infinita.

          (%i9) errcatch (fullratsubst (b*a^2, a^2, a^3));

          *** - Lisp stack overflow. RESET


 -- Función: gcd (<p_1>, <p_2>, <x_1>, ...)
     Devuelve el máximo común divisor de <p_1> y <p_2>.  La variable
     `gcd' determiona qué algoritmo se va a utilizar.  Asignándole a
     `gcd' los valores `ez', `eez', `subres', `red' o `spmod', se
     seleccionan los algoritmos `ezgcd', nuevo `eez' `gcd',
     subresultante `prs', reducido o modular, respectivamente.  Si
     `gcd' vale `false' entonces `gcd(p1,p2,var)' devolverá siempre 1
     para cualquier `var'.  Muchas funciones (por ejemplo,  `ratsimp',
     `factor', etc.) hacen uso de `gcd' implícitamente.  En caso de
     polinomios homogéneos se recomienda darle a `gcd' el valor
     `subres'.  Para calcular un máximo común divisor en presencia de
     raíces, como en `gcd(x^2-2*sqrt(2)*x+2,x-sqrt(2));' , la variable
     `algebraic' debe igualarse previamente a `true' y `gcd' no puede
     ser `ez'. Se recomienda utilizar el algoritmo `subres' en lugar de
     `red', por ser aquél más nuevo.

     Cuando la variable `gcd', cuyo valor por defecto es `subres', vale
     `false', no se calculará el máximo común divisor cuando las
     expresiones se conviertan a su forma canónica (CRE), lo que
     redundará en ocasiones en mayor rapidez de cálculo.


 -- Función: gcdex (<f>, <g>)
 -- Función: gcdex (<f>, <g>, <x>)
     Devuelve una lista `[<a>, <b>, <u>]' en la que <u> es el máximo
     común divisor (mcd) de <f> y <g>, e igual a `<a> <f> + <b> <g>'.
     Los argumentos <f> y <g> deben ser polinomios univariantes, o
     indicarles la variable principal <x> en caso de ser multivariantes.

     La función `gcdex' implementa el algoritmo de Euclides, en el que
     tenemos una secuencia de `L[i]: [a[i], b[i], r[i]]' todos ellos
     ortogonales a `[f, g, -1]' siendo el siguiente calculado a partir
     de `q = quotient(r[i]/r[i+1])' y `L[i+2]: L[i] - q L[i+1]'; el
     proceso termina en `L[i+1]' cuando el resto `r[i+2]' se anula.

          (%i1) gcdex (x^2 + 1, x^3 + 4);
                                 2
                                x  + 4 x - 1  x + 4
          (%o1)/R/           [- ------------, -----, 1]
                                     17        17
          (%i2) % . [x^2 + 1, x^3 + 4, -1];
          (%o2)/R/                        0


 -- Función: gcfactor (<n>)
     Factoriza el entero gaussiano <n> como producto, a su vez, de
     enteros gaussianos, (un entero gaussiano es de la forma`<a> + <b>
     `%i'' donde <a> y <b> son números enteros). Los factores se
     normalizan de manera que tanto la parte real como imaginaria sean
     no negativas.


 -- Función: gfactor (<expr>)
     Factoriza el polinomio <expr> sobre los enteros gaussianos (un
     entero gaussiano es de la forma`<a> + <b> `%i'' donde <a> y <b>
     son números enteros).  Es como `factor (<expr>, <a>^2+1)' donde
     <a> vale `%i'.

     Ejemplo:

          (%i1) gfactor (x^4 - 1);
          (%o1)           (x - 1) (x + 1) (x - %i) (x + %i)


 -- Función: gfactorsum (<expr>)
     Esta función es similar a `factorsum' pero aplica `gfactor' en
     lugar de `factor'.


 -- Función: hipow (<expr>, <x>)
     Devuelve el mayor exponente explícito de  <x> en <expr>.  El
     argumento<x> puede ser una variable o una expresión general.  Si
     <x> no aparece en <expr>, `hipow' devuelve `0'.

     La función `hipow' no tiene en cuenta expresiones equivalentes a
     `expr'.  En particular, `hipow' no expande `expr', de manera que
     `hipow (<expr>, <x>)' y `hipow (expand (<expr>, <x>))' pueden dar
     resultados diferentes.

     Ejemplos:

          (%i1) hipow (y^3 * x^2 + x * y^4, x);
          (%o1)                           2
          (%i2) hipow ((x + y)^5, x);
          (%o2)                           1
          (%i3) hipow (expand ((x + y)^5), x);
          (%o3)                           5
          (%i4) hipow ((x + y)^5, x + y);
          (%o4)                           5
          (%i5) hipow (expand ((x + y)^5), x + y);
          (%o5)                           0


 -- Variable opcional: intfaclim
     Valor por defecto: 1000

     La variable `intfaclim' guarda el mayor divisor que se ensayará al
     factorizar un número `bignum'. Si vale `false' (este es el caso
     cuando el usuario llama a `factor' explícitamente), o si el entero
     ocupa dos bytes, se intentará una factorización completa del
     entero.

     A la variable `intfaclim' se le asigna el valor `false' cuando los
     factores se calculan desde las funciones `divsum', `totient' y
     `primep'.

     Las llamadas internas a `factor' respetan el valor dado por el
     usuario a `intfaclim'. Asignando a `intfaclim' valores pequeños se
     puede reducir el tiempo de factorización de números enteros
     grandes.


 -- Variable opcional: keepfloat
     Valor por defecto: `false'

     Si `keepfloat' vale `true', los números decimales en coma flotante
     no se racionalizan cuando las expresiones que los contienen se
     convierten al formato canónico racional (CRE).


 -- Función: lratsubst (<L>, <expr>)
     Esta función es similar a `subst (<L>, <expr>)', excepto por el
     hecho de que utiliza `ratsubst' en lugar de `subst'.

     El primer argumento de `lratsubst' es una ecuación o lista de
     ecuaciones idénticas en formato a las aceptadas por `subst'.  Las
     sustituciones se hacen en el orden dado por la lista de
     ecuaciones, esto es, de izquierda a derecha.

     La instrucción `load ("lrats")' carga `fullratsubst' y `lratsubst'.

     Ejemplos:

          (%i1) load ("lrats")$

        * `subst' can carry out multiple substitutions.  `lratsubst' is
          analogous to `subst'.

          (%i2) subst ([a = b, c = d], a + c);
          (%o2)                         d + b
          (%i3) lratsubst ([a^2 = b, c^2 = d], (a + e)*c*(a + c));
          (%o3)                (d + a c) e + a d + b c

        * If only one substitution is desired, then a single equation
          may be given as first argument.

          (%i4) lratsubst (a^2 = b, a^3);
          (%o4)                          a b


 -- Variable opcional: modulus
     Valor por defecto: `false'

     Si `modulus' es un número positivo <p>, las operaciones con
     números racionales (como los devueltos por `rat' y funciones
     asociadas) se realizan módulo <p>, utilizando el llamado sistema
     de módulo balanceado, en el que `<n> módulo <p>' se define como un
     entero <k> de `[-(<p>-1)/2, ..., 0, ..., (<p>-1)/2]' si <p> es
     impar, o de `[-(<p>/2 - 1), ..., 0, ...., <p>/2]' si <p> es par,
     de tal manera que `<a> <p> + <k>' es igual a <n> para algún entero
     <a>.

     Normalmente a `modulus' se le asigna un número primo. Se acepta
     que a `modulus' se le asigne un entero positivo no primo, pero se
     obtendrá un mensaje de aviso. Maxima permitirá que a `modulus' se
     le asigne cero o un entero negativo, aunque no esté clara su
     utilidad.


 -- Función: num (<expr>)
     Devuelve el numerador de <expr> si se trata de una fracción. Si
     <expr> no es una fracción, se devuelve <expr>.

     La función `num' evalúa su argumento.


 -- Función: polydecomp (<p>, <x>)
     Descompone el polinomio <p> de variable <x> en una composición
     funcional de polinomios en <x>.  La función `polydecomp' devuelve
     una lista `[<p_1>, ..., <p_n>]' tal que

          lambda ([x], p_1) (lambda ([x], p_2) (... (lambda ([x], p_n) (x)) ...))

     es igual a  <p>.  El grado de <p_i> es mayor que 1 para <i> menor
     que <n>.

     Esta descomposición no es única.

     Ejemplos:

          (%i1) polydecomp (x^210, x);
                                    7   5   3   2
          (%o1)                   [x , x , x , x ]
          (%i2) p : expand (subst (x^3 - x - 1, x, x^2 - a));
                          6      4      3    2
          (%o2)          x  - 2 x  - 2 x  + x  + 2 x - a + 1
          (%i3) polydecomp (p, x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     La siguiente función compone `L = [e_1, ..., e_n]' como funciones
     de `x'; se trata de la inversa de `polydecomp':

          compose (L, x) :=
            block ([r : x], for e in L do r : subst (e, x, r), r) $

     Se vuelve a obtener el resultado del ejemplo de más arriba
     haciendo uso de `compose':

          (%i3) polydecomp (compose ([x^2 - a, x^3 - x - 1], x), x);
                                  2       3
          (%o3)                 [x  - a, x  - x - 1]

     Nótese que aunque `compose (polydecomp (<p>, <x>), <x>)' devuelve
     siempre <p> (sin expandir), `polydecomp (compose ([<p_1>, ...,
     <p_n>], <x>), <x>)'  no devuelve necesariamente `[<p_1>, ...,
     <p_n>]':

          (%i4) polydecomp (compose ([x^2 + 2*x + 3, x^2], x), x);
                                    2       2
          (%o4)                   [x  + 2, x  + 1]
          (%i5) polydecomp (compose ([x^2 + x + 1, x^2 + x + 1], x), x);
                                2       2
                               x  + 3  x  + 5
          (%o5)               [------, ------, 2 x + 1]
                                 4       2


 -- Función: quotient (<p_1>, <p_2>)
 -- Función: quotient (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Devuelve el polinomio <p_1> dividido por el polinomio <p_2>. Los
     argumentos <x_1>, ..., <x_n> se interpretan como en la función
     `ratvars'.

     La función `quotient' devuelve el primer elemento de la lista
     devuelta por `divide'.


 -- Función: rat (<expr>)
 -- Función: rat (<expr>, <x_1>, ..., <x_n>)
     Convierte <expr> al formato canónico racional (canonical rational
     expression o CRE) expandiendo y combinando todos los términos
     sobre un denominador común y cancelando el máximo común divisor
     del numerador y denominador, así como convirtiendo números
     decimales en coma flotante a números racionales dentro de la
     tolerancia indicada por `ratepsilon'. Las variables se ordenan de
     acuerdo a <x_1>, ..., <x_n> si se han especificado, como en la
     función `ratvars'.

     En general, `rat' no simplifica otras funciones que no sean la
     suma `+', resta `-', multiplicación `*', división `/' y
     exponenciación de exponente entero, mientras que `ratsimp' sí lo
     hace.  Nótese que los átomos (números y variables) en expresiones
     en formato CRE no son los mismos que en el formato general.  Por
     ejemplo, `rat(x)- x' devuelve `rat(0)', que tiene una
     representación interna diferente de 0.

     Si `ratprint' vale `false' no aparecerán mensajes informando al
     usuario sobre la conversión de números decimales en coma flotante
     a números racionales.

     Si `keepfloat' vale `true' no se convertirán números decimales en
     coma flotante a números racionales.

     Véanse también `ratexpand' y  `ratsimp'.

     Ejemplos:

          (%i1) ((x - 2*y)^4/(x^2 - 4*y^2)^2 + 1)*(y + a)*(2*y + x) /(4*y^2 + x^2);
                                                     4
                                            (x - 2 y)
                        (y + a) (2 y + x) (------------ + 1)
                                             2      2 2
                                           (x  - 4 y )
          (%o1)         ------------------------------------
                                        2    2
                                     4 y  + x
          (%i2) rat (%, y, a, x);
                                      2 a + 2 y
          (%o2)/R/                    ---------
                                       x + 2 y


 -- Variable opcional: ratalgdenom
     Valor por defecto: `true'

     Si `ratalgdenom' vale `true', se permite la racionalización de
     denominadores eliminando radicales.  La variable `ratalgdenom'
     sólo tiene efecto cuando expresiones en formato canónico (CRE)
     están siendo utilizadas en modo algebraico.


 -- Función: ratcoef (<expr>, <x>, <n>)
 -- Función: ratcoef (<expr>, <x>)
     Devuelve el coeficiente de la expresión `<x>^<n>' dentro de la
     expresión <expr>. Si se omite, <n> se considera igual a 1.

     El valor devuelto está libre de las variables en <x>, excepto
     quizás en un sentido no racional. Si no existe un coeficiente de
     este tipo se devuelve 0.

     La función `ratcoef' expande y simplifica racionalmente su primer
     argumento, por lo que puede dar una respuesta diferente a la dada
     por la función `coeff', la cual tiene un carácter puramente
     sintáctico.

     La llamada `ratcoef (<expr>, <x>, 0)', siendo <expr> una suma,
     devuelve una suma formada por los términos que no contienen <x>.

     Puesto que <expr> se simplifica racionalmente antes de ser
     examinada, algunos coeficientes puede que no aparezcan como en la
     expresión original.

     Ejemplo:

          (%i1) s: a*x + b*x + 5$
          (%i2) ratcoef (s, a + b);
          (%o2)                           x


 -- Función: ratdenom (<expr>)
     Devuelve el denominador de <expr>, después de transformar <expr>
     al formato canónico (CRE). El valor retornado está también en
     formato CRE.

     El argumento <expr> se transforma al formato CRE por la función
     `rat', a menos que ya esté en este formato.  Esta conversión puede
     cambiar la forma de <expr> colocando todos sus términos sobre un
     denominador común.

     La función `denom' es parecida, pero devuelve una expresión
     general en lugar de una CRE. Tampoco `denom' intenta colocar todos
     sus términos sobre un denominador común, de manera que algunas
     expresiones que son consideradas como divisiones por `ratdenom',
     no son tales para `denom'.


 -- Variable opcional: ratdenomdivide
     Valor por defecto: `true'

     Si `ratdenomdivide' vale `true', la función `ratexpand' expande
     una fracción en la que el numerador es una suma en una suma de
     divisiones. En otro caso, `ratexpand' reduce una suma de
     divisiones a una única fracción, cuyo numerador es la suma de los
     denominadores de cada fracción.

     Examples:
          (%i1) expr: (x^2 + x + 1)/(y^2 + 7);
                                      2
                                     x  + x + 1
          (%o1)                      ----------
                                        2
                                       y  + 7
          (%i2) ratdenomdivide: true$
          (%i3) ratexpand (expr);
                                 2
                                x        x        1
          (%o3)               ------ + ------ + ------
                               2        2        2
                              y  + 7   y  + 7   y  + 7
          (%i4) ratdenomdivide: false$
          (%i5) ratexpand (expr);
                                      2
                                     x  + x + 1
          (%o5)                      ----------
                                        2
                                       y  + 7
          (%i6) expr2: a^2/(b^2 + 3) + b/(b^2 + 3);
                                               2
                                     b        a
          (%o6)                    ------ + ------
                                    2        2
                                   b  + 3   b  + 3
          (%i7) ratexpand (expr2);
                                            2
                                       b + a
          (%o7)                        ------
                                        2
                                       b  + 3


 -- Función: ratdiff (<expr>, <x>)
     Deriva la expresión racional <expr> con respecto a <x>.  El
     argumento <expr> debe ser una fracción algebraica o un polinomio
     en <x>.  El argumento <x> puede ser una variable o una
     subexpresión de <expr>.

     El resultado equivale al devuelto por `diff', aunque es posible
     que se obtenga en una forma diferente.  La función `ratdiff' puede
     ser más rápida que `diff' en expresiones racionales.

     La función `ratdiff' devuelve una expresión en formato canónico o
     CRE si `expr' es también una expresión CRE. En otro caso,
     `ratdiff' devuelve una expresión general.

     La función `ratdiff' considera únicamente la dependencia de <expr>
     respecto de <x>, ignorando cualquier dependencia establecida por
     `depends'.

     Ejemplo:

          (%i1) expr: (4*x^3 + 10*x - 11)/(x^5 + 5);
                                     3
                                  4 x  + 10 x - 11
          (%o1)                   ----------------
                                        5
                                       x  + 5
          (%i2) ratdiff (expr, x);
                              7       5       4       2
                           8 x  + 40 x  - 55 x  - 60 x  - 50
          (%o2)          - ---------------------------------
                                    10       5
                                   x   + 10 x  + 25
          (%i3) expr: f(x)^3 - f(x)^2 + 7;
                                   3       2
          (%o3)                   f (x) - f (x) + 7
          (%i4) ratdiff (expr, f(x));
                                     2
          (%o4)                   3 f (x) - 2 f(x)
          (%i5) expr: (a + b)^3 + (a + b)^2;
                                        3          2
          (%o5)                  (b + a)  + (b + a)
          (%i6) ratdiff (expr, a + b);
                              2                    2
          (%o6)            3 b  + (6 a + 2) b + 3 a  + 2 a


 -- Función: ratdisrep (<expr>)
     Devuelve su argumento como una expresión general.  Si <expr> es
     una expresión general, se devuelve sin cambios.

     Normalmente se invoca a `ratdisrep' a fin de convertir una
     expresión en formato canónico (CRE) al formato general, lo que
     puede ser utilizado si se quiere parar el contagio que produce el
     formato CRE, o para utilizar funciones racionales en contextos no
     racionales.

     Véase también `totaldisrep'.


 -- Variable opcional: ratepsilon
     Valor por defecto: 2.0e-8

     La variable `ratepsilon' guarda la tolerancia utilizada en la
     conversión de números decimales en coma flotante a números
     racionales.


 -- Función: ratexpand (<expr>)
 -- Variable opcional: ratexpand
     Expande <expr> multiplicando productos de sumas y sumas con
     exponentes, combinando fracciones con común denominador,
     cancelando el máximo común divisor del numerador y del denominador
     y luego dividiendo los sumandos del numerador por el denominador.

     El valor que devuelve `ratexpand' es una expresión general,
     incluso cuando <expr> está en formato canónico o CRE.

     Si la variable `ratexpand' vale `true' hará que las expresiones
     CRE se expandan completamente cuando se conviertan al formato
     general o se muestren en el terminal, mientras que si vale `false'
     se mostrarán de forma recursiva. Véase también `ratsimp'.

     Si `ratdenomdivide' vale `true', `ratexpand' expande una fracción
     en la que el numerador es una suma en una suma de fracciones,
     todas ellas con denominador común. En otro caso, `ratexpand'
     reduce una suma de fracciones en una única fracción, cuyo
     numerador es la suma de los numeradores de cada fracción.

     Si `keepfloat' vale `true', los números decimales en coma flotante
     no se racionalizan cuando las expresiones que los contienen se
     convierten al formato canónico racional (CRE).

     Ejemplos:

          (%i1) ratexpand ((2*x - 3*y)^3);
                               3         2       2        3
          (%o1)          - 27 y  + 54 x y  - 36 x  y + 8 x
          (%i2) expr: (x - 1)/(x + 1)^2 + 1/(x - 1);
                                   x - 1       1
          (%o2)                   -------- + -----
                                         2   x - 1
                                  (x + 1)
          (%i3) expand (expr);
                              x              1           1
          (%o3)          ------------ - ------------ + -----
                          2              2             x - 1
                         x  + 2 x + 1   x  + 2 x + 1
          (%i4) ratexpand (expr);
                                  2
                               2 x                 2
          (%o4)           --------------- + ---------------
                           3    2            3    2
                          x  + x  - x - 1   x  + x  - x - 1


 -- Variable opcional: ratfac
     Valor por defecto: `false'

     Si `ratfac' vale `true', las expresiones canónicas (CRE) se
     manipulan en una forma parcialmente factorizada.

     Durante las operaciones racionales, las expresiones se mantienen
     completamente factorizadas tanto como sea posible sin llamar a
     `factor'. Esto debería ahorrar espacio y tiempo en algunos
     cálculos. El numerador y denominador se hacen primos relativos,
     por ejemplo `rat ((x^2 - 1)^4/(x + 1)^2)' devuelve `(x - 1)^4 (x +
     1)^2)', pero los factores dentro de cada parte pueden no ser
     primos relativos.

     En el paquete `ctensr' sobre manipulación de tensores por
     componentes, los tensores de Ricci, Einstein, Riemann y Weyl y la
     curvatura escalar se factorizan automáticamente si `ratfac' vale
     `true'; `ratfac' debe activarse únicamente en aquellos casos en
     los que se sabe que el número de términos de las componentes
     tensoriales es pequño.

     Nota: Los esquemas de comportamiento basados en `ratfac' y
     `ratweight' son incompatibles y no se debe  pretender usarlos al
     mismo tiempo.


 -- Función: ratnumer (<expr>)
     Devuelve el numerador de <expr>, después de reducir <expr> a su
     forma canónica (CRE).  El valor retornado está también en formato
     CRE.

     El argumento <expr> se transforma al formato CRE por la función
     `rat', a menos que ya esté en este formato.  Esta conversión puede
     cambiar la forma de <expr> colocando todos sus términos sobre un
     denominador común.

     Es parecida a la función `num', pero devuelve una expresión
     general en lugar de una CRE.  Además, `num' no intenta colocar
     todos los términos sobre un denominador común, de manera que
     algunas expresiones que son consideradas fracciones por `ratnumer'
     no se consideran como tales por `num'.


 -- Función: ratnump (<expr>)
     Devuelve `true' si <expr> es un entero literal o una fracción de
     enteros literales, en caso contrario devuelve `false'.


 -- Función: ratp (<expr>)
     Devuelve `true' si <expr> es una expresión canónica racional
     (canonical rational expression o CRE) o una CRE extendida, en caso
     contrario devuelve `false'.

     Las expresiones CRE son creadas por `rat' y funciones asociadas.
     Las CRE extendidas son creadas por `taylor' y funciones asociadas.


 -- Variable opcional: ratprint
     Valor por defecto: `true'

     Si `ratprint' vale `true', se muestra al usuario un mensaje dando
     cuenta de la conversión de números decimales en coma flotante a
     formato racional.


 -- Función: ratsimp (<expr>)
 -- Función: ratsimp (<expr>, <x_1>, ..., <x_n>)
     Simplifica la expresión <expr> y todas sus subexpresiones,
     incluyendo los argumentos de funciones no racionales. El resultado
     es un cociente de dos polinomios en una forma recursiva, esto es,
     los coeficientes de la variable principal son polinomios respecto
     de las otras variables. Las variables pueden incluir funciones no
     racionales, como `sin (x^2 + 1)', y los argumentos de tales
     funciones son también racionalmente simplificados.

     La llamada `ratsimp (<expr>, <x_1>, ..., <x_n>)' permite la
     simplificación racional con la especificación del orden de las
     variables, como en `ratvars'.

     Si `ratsimpexpons' vale `true', `ratsimp' se aplica a los
     exponentes de las expresiones durante la simplificación.

     Véase también `ratexpand'. Nótese que `ratsimp' se ve afectada por
     algunas de las variables globales que controlan a `ratexpand'.

     Ejemplos:

          (%i1) sin (x/(x^2 + x)) = exp ((log(x) + 1)^2 - log(x)^2);
                                                   2      2
                             x         (log(x) + 1)  - log (x)
          (%o1)        sin(------) = %e
                            2
                           x  + x
          (%i2) ratsimp (%);
                                       1          2
          (%o2)                  sin(-----) = %e x
                                     x + 1
          (%i3) ((x - 1)^(3/2) - (x + 1)*sqrt(x - 1))/sqrt((x - 1)*(x + 1));
                                 3/2
                          (x - 1)    - sqrt(x - 1) (x + 1)
          (%o3)           --------------------------------
                               sqrt((x - 1) (x + 1))
          (%i4) ratsimp (%);
                                     2 sqrt(x - 1)
          (%o4)                    - -------------
                                           2
                                     sqrt(x  - 1)
          (%i5) x^(a + 1/a), ratsimpexpons: true;
                                         2
                                        a  + 1
                                        ------
                                          a
          (%o5)                        x


 -- Variable opcional: ratsimpexpons
     Valor por defecto: `false'

     Si `ratsimpexpons' vale `true', `ratsimp' se aplica a los
     exponentes de las expresiones durante la simplificación.


 -- Función: ratsubst (<a>, <b>, <c>)
     Sustituye <b> por <a> en <c> y devuelve la expresión resultante.
     El argumento <b> puede ser una suma, un producto, una potencia,
     etc.

     La función `ratsubst' reconoce el significado de las expresiones,
     mientras que `subst' tan solo realiza sustituciones sintácticas.
     Así por ejemplo, `subst (a, x + y, x + y + z)' devuelve `x + y + z'
     cuando `ratsubst' devuelve `z + a'.

     Si `radsubstflag' vale `true', `ratsubst' sustituye radicales en
     expresiones que no los contienen explícitamente.

     Ejemplos:

          (%i1) ratsubst (a, x*y^2, x^4*y^3 + x^4*y^8);
                                        3      4
          (%o1)                      a x  y + a
          (%i2) cos(x)^4 + cos(x)^3 + cos(x)^2 + cos(x) + 1;
                         4         3         2
          (%o2)       cos (x) + cos (x) + cos (x) + cos(x) + 1
          (%i3) ratsubst (1 - sin(x)^2, cos(x)^2, %);
                      4           2                     2
          (%o3)    sin (x) - 3 sin (x) + cos(x) (2 - sin (x)) + 3
          (%i4) ratsubst (1 - cos(x)^2, sin(x)^2, sin(x)^4);
                                  4           2
          (%o4)                cos (x) - 2 cos (x) + 1
          (%i5) radsubstflag: false$
          (%i6) ratsubst (u, sqrt(x), x);
          (%o6)                           x
          (%i7) radsubstflag: true$
          (%i8) ratsubst (u, sqrt(x), x);
                                          2
          (%o8)                          u


 -- Función: ratvars (<x_1>, ..., <x_n>)
 -- Función: ratvars ()
 -- Variable del sistema: ratvars
     Declara como variables principales <x_1>, ..., <x_n> en
     expresiones racionales. Si <x_n> está presente en una expresión
     racional, se considerará como variable principal. Si no está
     presente, entonces se considerará principal a la variable
     <x_[n-1]> si aparece en la expresión, se continúa así hasta <x_1>,
     que se considerará como variable principal sólo si ninguna de las
     variables que le siguen está presente en la expresión.

     Si una variable de la expresión racional no está presente en la
     lista `ratvars', se le dará una prioridad inferior a la de <x_1>.

     Los argumentos de `ratvars' pueden ser tanto variables como
     funciones no racionales como `sin(x)'.

     La variable `ratvars' es una lista que contiene los argumentos
     pasados a la función `ratvars' la última vez que fue invocada.
     Cada llamada a la función `ratvars' reinicializa la lista. La
     llamada `ratvars ()' vacía la lista.


 -- Función: ratweight (<x_1>, <w_1>, ..., <x_n>, <w_n>)
 -- Función: ratweight ()
     Asigna un peso <w_i> a la variable <x_i>. Un término será
     reemplazado por 0 si su peso excede el valor de la variable
     `ratwtlvl' (por defecto no se realiza el truncamiento). El peso de
     un término es la suma de los productos de los pesos de las
     variables que lo forman multiplicados por sus exponentes. Por
     ejemplo, el peso de `3 x_1^2 x_2' es `2 w_1 + w_2'. El
     truncamiento basado en `ratwtlvl' solamente se lleva a cabo cuando
     se multiplican o se elevan a potencias expresiones canónicas (CRE).

     La llamada `ratweight ()' devuelve la lista acumulada de
     asignaciones de pesos.

     Nota: Los esquemas de comportamiento basados en `ratfac' y
     `ratweight' son incompatibles y no se debe  pretender usarlos al
     mismo tiempo.

     Ejemplos:

          (%i1) ratweight (a, 1, b, 1);
          (%o1)                     [a, 1, b, 1]
          (%i2) expr1: rat(a + b + 1)$
          (%i3) expr1^2;
                            2                  2
          (%o3)/R/         b  + (2 a + 2) b + a  + 2 a + 1
          (%i4) ratwtlvl: 1$
          (%i5) expr1^2;
          (%o5)/R/                  2 b + 2 a + 1


 -- Variable del sistema: ratweights
     Valor por defecto: `[]'

     La variable `ratweights' es una lista que contiene los pesos
     asignados por `ratweight'.  Las lista es acumulativa, en el
     sentido de que cada llamada a `ratweight' añade nuevos elementos a
     la lista.


 -- Variable opcional: ratwtlvl
     Valor por defecto: `false'

     La variable `ratwtlvl' se utiliza en combinación con la función
     `ratweight' para controlar el truncamiento de expresiones
     racionales canónicas (CRE). Con el valor por defecto, `false', no
     se produce truncamiento alguno.


 -- Función: remainder (<p_1>, <p_2>)
 -- Función: remainder (<p_1>, <p_2>, <x_1>, ..., <x_n>)
     Devuelve el resto de la división del polinomio <p_1> entre <p_2>.
     Los argumentos <x_1>, ..., <x_n> se interpretan como en `ratvars'.

     La función `remainder' devuelve el segundo elemento de la lista
     retornada por `divide'.


 -- Función: resultant (<p_1>, <p_2>, <x>)
 -- Variable: resultant
     Calcula la resultante de los dos polinomios <p_1> y <p_2>,
     eliminando la variable <x>.  La resultante es un determinante de
     los coeficientes de <x> en <p_1> y <p_2>, que es igual a cero si
     sólo si <p_1> y <p_2> tienen un factor común no constante.

     Si <p_1> o <p_2> pueden ser factorizados, puede ser necesario
     llamar a `factor' antes que invocar a `resultant'.

     La variable `resultant' controla qué algoritmo será utilizado para
     calcular la resultante.

     La función `bezout' toma los mismos argumentos que `resultant' y
     devuelve una matriz. El determinante del valor retornado es la
     resultante buscada.


 -- Variable opcional: savefactors
     Valor por defecto: `false'

     Si `savefactors' vale `true', los factores de una expresión
     producto se almacenan por ciertas funciones a fin de acelerar
     posteriores factorizaciones de expresiones que contengan algunos
     de estos factores.


 -- Función: tellrat (<p_1>, ..., <p_n>)
 -- Función: tellrat ()
     Añade al anillo de enteros algebraicos conocidos por Maxima los
     elementos que son soluciones de los polinomios <p_1>, ..., <p_n>.
     Cada argumento <p_i> es un polinomio de coeficientes enteros.

     La llamada `tellrat (<x>)' hace que se sustituya 0 por <x> en las
     funciones racionales.

     La llamada `tellrat ()' devuelve una lista con las sustituciones
     actuales.

     A la variable `algebraic' se le debe asignar el valor `true' a fin
     de poder realizar la simplificación de enteros algebraicos.

     Maxima reconoce la unidad imaginaria `%i' y todas las raíces de
     los enteros.

     La instrucción `untellrat' borra todas las propiedades de
     `tellrat'.

     Es ambiguo aplicar `tellrat' a un polinomio multivariante tal como
     `tellrat (x^2 - y^2)', pues no se sabe si sustituir `<y>^2' por
     `<x>^2' o al revés. Maxima sigue un cierto orden, pero si el
     usuario quiere especificar uno en concreto, puede hacerlo mediante
     la sintaxis `tellrat (y^2 = x^2)', que indica que se ponga `<x>^2'
     en lugar de `<y>^2'.

     Ejemplos:

          (%i1) 10*(%i + 1)/(%i + 3^(1/3));
                                     10 (%i + 1)
          (%o1)                      -----------
                                            1/3
                                      %i + 3
          (%i2) ev (ratdisrep (rat(%)), algebraic);
                       2/3      1/3              2/3      1/3
          (%o2)    (4 3    - 2 3    - 4) %i + 2 3    + 4 3    - 2
          (%i3) tellrat (1 + a + a^2);
                                      2
          (%o3)                     [a  + a + 1]
          (%i4) 1/(a*sqrt(2) - 1) + a/(sqrt(3) + sqrt(2));
                                1                 a
          (%o4)           ------------- + -----------------
                          sqrt(2) a - 1   sqrt(3) + sqrt(2)
          (%i5) ev (ratdisrep (rat(%)), algebraic);
                   (7 sqrt(3) - 10 sqrt(2) + 2) a - 2 sqrt(2) - 1
          (%o5)    ----------------------------------------------
                                         7
          (%i6) tellrat (y^2 = x^2);
                                  2    2   2
          (%o6)                 [y  - x , a  + a + 1]


 -- Función: totaldisrep (<expr>)
     Convierte cada subexpresión  de <expr> del formato canónico (CRE)
     al general y devuelve el resultado.  Si <expr> está en formato CRE
     entonces `totaldisrep' es idéntico a `ratdisrep'.

     La función `totaldisrep' puede ser útil para modificar expresiones
     como las ecuaciones, listas, matrices, etc., que tienen algunas
     subexpresiones en formato CRE.


 -- Función: untellrat (<x_1>, ..., <x_n>)
     Elimina de <x_1>, ..., <x_n> las propiedades relacionadas con
     `tellrat'.



File: maxima.info,  Node: Constantes,  Next: Logaritmos,  Prev: Polinomios,  Up: Top

13 Constantes
*************

* Menu:

* Definiciones para Constantes::


File: maxima.info,  Node: Definiciones para Constantes,  Prev: Constantes,  Up: Constantes

13.1 Definiciones para Constantes
=================================

 -- Constante: %e
     La base de los logaritmos naturales, e, se representa en Maxima
     como `%e'.


 -- Constante: false
     Constante lógica para "falso". (NIL en Lisp)


 -- Constante: inf
     Más infinito.


 -- Constante: infinity
     Infinito complejo.


 -- Constante: minf
     Menos infinito.


 -- Constante: %pi
     El valor "pi" se representa en Maxima como `%pi'.


 -- Constante: true
     Constante lógica para "verdadero". (T en Lisp)



File: maxima.info,  Node: Logaritmos,  Next: Trigonometría,  Prev: Constantes,  Up: Top

14 Logaritmos
*************

* Menu:

* Definiciones para Logaritmos::


File: maxima.info,  Node: Definiciones para Logaritmos,  Prev: Logaritmos,  Up: Logaritmos

14.1 Definiciones para Logaritmos
=================================

 -- Variable opcional: %e_to_numlog
     Valor por defecto: `false'

     Si `%e_to_numlog' vale `true', `r' es un número racional y `x' una
     expresión, `%e^(r*log(x))' se reduce a `x^r' .  Téngase en cuenta
     que la instrucción `radcan' también hace este tipo de
     transformaciones, así como otras más complicadas. La instrucción
     `logcontract' "contrae" expresiones que contienen algún `log'.


 -- Función: li [<s>] (<z>)
     Representa la función polilogarítmica de orden <s> y argumento <z>,
     definida por la serie infinita

                                           inf
                                           ====   k
                                           \     z
                                  Li (z) =  >    --
                                    s      /      s
                                           ====  k
                                           k = 1

     `li [1]' es `- log (1 - z)'.  `li [2]' y `li [3]' son las
     funciones di- y trilogaritmo, respectivamente.

     Cuando el orden es 1, el polilogaritmo se simplifica a `- log (1 -
     z)', el cual a su vez se reduce a un valor numérico si <z> es un
     número real o complejo en coma flotante o si está presente el
     término `numer'.

     Cuando el orden es 2 ó 3, el polilogaritmo se reduce a un valor
     numérico si <z> es un número real en coma flotante o si está
     presente el término `numer'.

     Ejemplos:

          (%i1) assume (x > 0);
          (%o1)                        [x > 0]
          (%i2) integrate ((log (1 - t)) / t, t, 0, x);
          (%o2)                       - li (x)
                                          2
          (%i3) li [2] (7);
          (%o3)                        li (7)
                                         2
          (%i4) li [2] (7), numer;
          (%o4)        1.24827317833392 - 6.113257021832577 %i
          (%i5) li [3] (7);
          (%o5)                        li (7)
                                         3
          (%i6) li [2] (7), numer;
          (%o6)        1.24827317833392 - 6.113257021832577 %i
          (%i7) L : makelist (i / 4.0, i, 0, 8);
          (%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
          (%i8) map (lambda ([x], li [2] (x)), L);
          (%o8) [0, .2676526384986274, .5822405249432515,
          .9784693966661848, 1.64493407, 2.190177004178597
           - .7010261407036192 %i, 2.374395264042415
           - 1.273806203464065 %i, 2.448686757245154
           - 1.758084846201883 %i, 2.467401098097648
           - 2.177586087815347 %i]
          (%i9) map (lambda ([x], li [3] (x)), L);
          (%o9) [0, .2584613953442624, 0.537213192678042,
          .8444258046482203, 1.2020569, 1.642866878950322
           - .07821473130035025 %i, 2.060877505514697
           - .2582419849982037 %i, 2.433418896388322
           - .4919260182322965 %i, 2.762071904015935
           - .7546938285978846 %i]


 -- Función: log (<x>)
     Representa el logaritmo natural (en base e) de <x>.

     Maxima no tiene definida una función para el logaritmo de base 10 u
     otras bases. El usuario puede hacer uso de la definición `log10(x)
     := log(x) / log(10)'.

     La simplificación y evaluación de logaritmos se controla cciertas
     variables globales:

     `logexpand' - hace que `log(a^b)' se convierta en `b*log(a)'.  Si
     toma el valor `all', `log(a*b)' también se reducirá a
     `log(a)+log(b)'.  Si toma el valor `super', entonces `log(a/b)'
     también se reducirá a `log(a)-log(b)', siendo `a/b' racional y
     `a#1',  (la expresión `log(1/b)', para `b' entero, se simplifica
     siempre).  Si toma el valor  `false', se desactivarán todas estas
     simplificaciones.

     `logsimp' - si vale `false', entonces no se transforma `%e' a
     potencias que contengan logaritmos.

     `lognumer' - si vale `true', entonces los argumentos de `log' que
     sean números decimales negativos en coma flotante se convertirán
     siempre a su valor absoluto antes de aplicar `log'.  Si `numer'
     vale también `true', entonces los argumentos enteros negativos de
     `log' también se convertirán en su valor absoluto.

     `lognegint' - si vale `true' se aplica la regla `log(-n)' ->
     `log(n)+%i*%pi' siendo `n' un entero positivo.

     `%e_to_numlog' - si vale `true', `r' es un número racional y `x'
     una expresión, `%e^(r*log(x))' se reduce a `x^r' .  Téngase en
     cuenta que la instrucción `radcan' también hace este tipo de
     transformaciones, así como otras más complicadas. La instrucción
     `logcontract' "contrae" expresiones que contienen algún `log'.


 -- Variable opcional: logabs
     Valor por defecto: `false'

     Cuando se calculan integrales indefinidas en las que se generan
     logaritmos, como en `integrate(1/x,x)', el resultado se devuelve
     de la forma  `log(abs(...))' si `logabs' vale `true', o de la
     forma `log(...)' si `logabs' vale `false'. En la integración
     definida se hace la asignación `logabs:true', ya que aquí es
     normalmente necesario evaluar la integral indefinida en los
     extremos del intervalo de integración.


 -- Variable opcional: logarc
     Valor por defecto: `false'

     Si `logarc' vale `true' hará que las funciones circulares e
     hiperbólicas inversas se conviertan a la forma logarítmica. La
     instrucción `logarc(<exp>)' hará esta conversión sólo en la
     expresión <exp> sin cambiar el valor de la variable global ni
     tener que volver a evaluar la expresión con `ev'.


 -- Variable opcional: logconcoeffp
     Valor por defecto: `false'

     Controla qué coeficientes se contraen cuando se utiliza
     `logcontract'. Se le puede asignar el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     `logcontract(1/2*log(x));' devolverá `log(sqrt(x))'.


 -- Función: logcontract (<expr>)
     Analiza la expresión <expr> recursivamente, transformando
     subexpresiones de la forma `a1*log(b1) + a2*log(b2) + c' en
     `log(ratsimp(b1^a1 * b2^a2)) + c'

          (%i1) 2*(a*log(x) + 2*a*log(y))$
          (%i2) logcontract(%);
                                           2  4
          (%o2)                     a log(x  y )

     Si se hace `declare(n,integer);' entonces
     `logcontract(2*a*n*log(x));' da `a*log(x^(2*n))'.  Los
     coeficientes que se contraen de esta manera son aquellos que como
     el 2 y el `n' satisfacen `featurep(coeff,integer)'. El usuario
     puede controlar qué coeficientes se contraen asignándole a la
     variable global `logconcoeffp' el nombre de una función de
     predicado de un argumento; por ejemplo, si se quiere introducir
     raíces cuadradas, se puede hacer `logconcoeffp:'logconfun$
     logconfun(m):=featurep(m,integer) or ratnump(m)$' .  Entonces
     `logcontract(1/2*log(x));' devolverá `log(sqrt(x))'.


 -- Variable opcional: logexpand
     Valor por defecto: `true'

     Si `logexpand' vale `true' hace que `log(a^b)' se convierta en
     `b*log(a)'.  Si toma el valor `all', `log(a*b)' también se
     reducirá a  `log(a)+log(b)'.  Si toma el valor `super', entonces
     `log(a/b)' también se reducirá a `log(a)-log(b)', siendo `a/b'
     racional y `a#1',  (la expresión `log(1/b)', para `b' entero, se
     simplifica siempre).  Si toma el valor  `false', se desactivarán
     todas estas simplificaciones.


 -- Variable opcional: lognegint
     Valor por defecto: `false'

     Si `lognegint' vale `true' se aplica la regla `log(-n)' ->
     `log(n)+%i*%pi' siendo `n' un entero positivo.


 -- Variable opcional: lognumer
     Valor por defecto: `false'

     Si `lognumer' vale `true', entonces los argumentos de `log' que
     sean números decimales negativos en coma flotante se convertirán
     siempre a su valor absoluto antes de aplicar `log'.  Si `numer'
     vale también `true', entonces los argumentos enteros negativos de
     `log' también se convertirán en su valor absoluto.


 -- Variable opcional: logsimp
     Valor por defecto: `true'

     Si `logsimp' vale `false', entonces no se transforma `%e' a
     potencias que contengan logaritmos.


 -- Función: plog (<x>)
     Representa la rama principal del logaritmo natural complejo con
     `-%pi' < `carg(<x>)' <= `+%pi' .



File: maxima.info,  Node: Trigonometría,  Next: Funciones Especiales,  Prev: Logaritmos,  Up: Top

15 Trigonometría
****************

* Menu:

* Introducción a la Trigonometría::
* Definiciones para Trigonometría::


File: maxima.info,  Node: Introducción a la Trigonometría,  Next: Definiciones para Trigonometría,  Prev: Trigonometría,  Up: Trigonometría

15.1 Introducción a la Trigonometría
====================================

Maxima reconoce muchas funciones trigonométricas. No están programadas
todas las identidades trigonométricas, pero el usuario puede añadir
muchas de ellas haciendo uso de las técnicas basadas en patrones.  Las
funciones trigonométricas definidas en Maxima son:  `acos', `acosh',
`acot', `acoth', `acsc', `acsch', `asec', `asech', `asin', `asinh',
`atan', `atanh', `cos', `cosh', `cot', `coth', `csc', `csch', `sec',
`sech', `sin', `sinh', `tan' y `tanh'. Hay también un determinado
número de instrucciones especiales para manipular funciones
trigonométricas;  véanse a este respecto `trigexpand', `trigreduce' y
la variable `trigsign'.  Dos paquetes adicionales amplían las reglas de
simplificación de Maxima, `ntrig' y `atrig1'.  Ejecútese
`describe(<command>)' para más detalles.


File: maxima.info,  Node: Definiciones para Trigonometría,  Prev: Introducción a la Trigonometría,  Up: Trigonometría

15.2 Definiciones para Trigonometría
====================================

 -- Function: acos (<x>)
     Arco coseno.


 -- Función: acosh (<x>)
     Arco coseno hiperbólico.


 -- Función: acot (<x>)
     Arco cotangente.


 -- Función: acoth (<x>)
     Arco cotangente hiperbólica.


 -- Función: acsc (<x>)
     Arco cosecante.


 -- Función: acsch (<x>)
     Arco cosecante hiperbólica.


 -- Función: asec (<x>)
     Arco secante.


 -- Función: asech (<x>)
     Arco secante hiperbólica.


 -- Función: asin (<x>)
     Arco seno.


 -- Función: asinh (<x>)
     Arco seno hiperbólico.


 -- Función: atan (<x>)
     Arco tangente.


 -- Función: atan2 (<y>, <x>)
     Calcula el valor de `atan(<y>/<x>)' en el intervalo de `-%pi' a
     `%pi'.


 -- Función: atanh (<x>)
     Arco tangente hiperbólica.


 -- Paquete: atrig1
     El paquete `atrig1' contiene ciertas reglas de simplificación
     adicionales para las funciones trigonométricas inversas. Junto con
     las reglas que ya conoce Maxima, los siguientes ángulos están
     completamente implementados: `0', `%pi/6', `%pi/4', `%pi/3' y
     `%pi/2'.  Los ángulos correspondientes en los otros tres
     cuadrantes también están disponibles.  Para hacer uso de estas
     reglas, ejecútese `load(atrig1);'.


 -- Función: cos (<x>)
     Coseno.


 -- Función: cosh (<x>)
     Coseno hiperbólico.


 -- Función: cot (<x>)
     Cotangente.


 -- Función: coth (<x>)
     Cotangente hiperbólica.


 -- Función: csc (<x>)
     Cosecante.


 -- Función: csch (<x>)
     Cosecante hiperbólica.


 -- Paquete: ntrig
     El paquete `ntrig' contiene un conjunto de reglas de
     simplificación que se pueden usar para simplificar funciones
     trigonométricas cuyos argumentos son de la forma `<f>(<n> %pi/10)'
     donde <f> es cualquiera de las funciones `sin', `cos', `tan',
     `csc', `sec' o `cot'.


 -- Función: sec (<x>)
     Secante.


 -- Función: sech (<x>)
     Secante hiperbólica.


 -- Función: sin (<x>)
     Seno.


 -- Función: sinh (<x>)
     Seno hiperbólico.


 -- Función: tan (<x>)
     Tangente.


 -- Función: tanh (<x>)
     Tangente hiperbólica.


 -- Función: trigexpand (<expr>)
     Expande funciones trigonométricas e hiperbólicas de sumas de
     ángulos y de múltiplos de ángulos presentes en <expr>.  Para
     mejorar los resultados, <expr> debería expandirse. Para facilitar
     el control por parte del usuario de las simplificaciones, esta
     función tan solo expande un nivel de cada vez, expandiendo sumas
     de ángulos o de múltiplos de ángulos. A fin de obtener una
     expansión completa en senos y coseno, se le dará a la variable
     `trigexpand' el valor `true'.

     La función `trigexpand' está controlada por las siguientes
     variables:

    `trigexpand'
          Si vale `true', provoca la expansión de todas las expresiones
          que contengan senos y cosenos.

    `trigexpandplus'
          Controla la regla de la suma para `trigexpand', la expansión
          de una suma como `sin(x + y)' se llevará a cabo sólo si
          `trigexpandplus' vale `true'.

    `trigexpandtimes'
          Controla la regla del producto para `trigexpand', la
          expansión de un producto como `sin(2 x)' se llevará a cabo
          sólo si `trigexpandtimes' vale `true'.

     Ejemplos:

          (%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                                   2           2
          (%o1)               - sin (x) + 3 cos (x) + x
          (%i2) trigexpand(sin(10*x+y));
          (%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)


 -- Variable optativa: trigexpandplus
     Valor por defecto: `true'

     La variable `trigexpandplus' controla la regla de la suma para
     `trigexpand'.  Así, si la instrucción `trigexpand' se utiliza o si
     la variable `trigexpand' vale `true', se realizará la expansión de
     sumas como `sin(x+y)' sólo si `trigexpandplus' vale `true'.


 -- Variable optativa: trigexpandtimes
     Valor por defecto: `true'

     La variable `trigexpandtimes' controla la regla del producto para
     `trigexpand'.  Así, si la instrucción `trigexpand' se utiliza o si
     la variable `trigexpand' vale `true', se realizará la expansión de
     productos como `sin(2*x)' sólo si `trigexpandtimes' vale `true'.


 -- Variable optativa: triginverses
     Valor por defecto: `all'

     La variable `triginverses' controla la simplificación de la
     composición de funciones trigonométricas e hiperbólicas con sus
     funciones inversas.

     Si vale `all', tanto `atan(tan(<x>))'  como `tan(atan(<x>))' se
     reducen a <x>.

     Si vale `true', se desactiva la simplificación de
     `<arcfun>(<fun>(<x>))'.

     Si vale `false', se desactivan las simplificaciones de
     `<arcfun>(<fun>(<x>))' y `<fun>(<arcfun>(<x>))'.


 -- Función: trigreduce (<expr>, <x>)
 -- Función: trigreduce (<expr>)
     Combina productos y potencias de senos y cosenos trigonométricos e
     hiperbólicos de <x>, transformándolos en otros que son múltiplos
     de <x>.  También intenta eliminar estas funciones cuando aparecen
     en los denominadores.  Si no se introduce el argumento <x>,
     entonces se utilizan todas las variables de <expr>.

     Véase también `poissimp'.

          (%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
                         cos(2 x)      cos(2 x)   1        1
          (%o1)          -------- + 3 (-------- + -) + x - -
                            2             2       2        2

     Las rutinas de simplificación trigonométrica utilizan información
     declarada en algunos casos sencillos. Las declaraciones sobre
     variables se utilizan como se indica a continuación:

          (%i1) declare(j, integer, e, even, o, odd)$
          (%i2) sin(x + (e + 1/2)*%pi);
          (%o2)                        cos(x)
          (%i3) sin(x + (o + 1/2)*%pi);
          (%o3)                       - cos(x)


 -- Variable optativa: trigsign
     Valor por defecto: `true'

     Si `trigsign' vale `true', se permite la simplificación de
     argumentos negativos en funciones trigonométricas, como en
     `sin(-x)', que se transformará en `-sin(x)' sólo si `trigsign'
     vale `true'.


 -- Función: trigsimp (<expr>)
     Utiliza las identidades sin(x)^2 + cos(x)^2 = 1 y cosh(x)^2 -
     sinh(x)^2 = 1 para simplificar expresiones que contienen `tan',
     `sec', etc., en expresiones con `sin', `cos', `sinh', `cosh'.

     Las funciones `trigreduce', `ratsimp' y `radcan' puden seguir
     siendo útiles para continuar el proceso de simplificación.

     La instrucción `demo ("trgsmp.dem")' muestra algunos ejemplos de
     `trigsimp'.


 -- Función: trigrat (<expr>)
     Devuelve una forma canónica simplificada cuasi-lineal de una
     expresión trigonométrica; <expr> es una fracción racional que
     contiene `sin', `cos' o `tan', cuyos argumentos son formas
     lineales respecto de ciertas variables (o kernels) y `%pi/<n>'
     (<n> entero) con coeficientes enteros. El resultado es una
     fracción simplificada con el numerador y denominador lineales
     respecto de `sin' y `cos'.

          (%i1) trigrat(sin(3*a)/sin(a+%pi/3));
          (%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1

     El siguiente ejemplo se ha tomado de Davenport, Siret y Tournier,
     Calcul Formel, Masson (o en inglés, Addison-Wesley), sección
     1.5.5, teorema de Morley.

          (%i1) c: %pi/3 - a - b;
                                              %pi
          (%o1)                     - b - a + ---
                                               3
          (%i2) bc: sin(a)*sin(3*c)/sin(a+b);
                                sin(a) sin(3 b + 3 a)
          (%o2)                 ---------------------
                                     sin(b + a)
          (%i3) ba: bc, c=a, a=c$
          (%i4) ac2: ba^2 + bc^2 - 2*bc*ba*cos(b);
                   2       2
                sin (a) sin (3 b + 3 a)
          (%o4) -----------------------
                         2
                      sin (b + a)

                                                  %pi
             2 sin(a) sin(3 a) cos(b) sin(b + a - ---) sin(3 b + 3 a)
                                                   3
           - --------------------------------------------------------
                                     %pi
                             sin(a - ---) sin(b + a)
                                      3

                2         2         %pi
             sin (3 a) sin (b + a - ---)
                                     3
           + ---------------------------
                       2     %pi
                    sin (a - ---)
                              3
          (%i5) trigrat (ac2);
          (%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)

           - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)

           - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)

           + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)

           + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)

           + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)

           - 9)/4



File: maxima.info,  Node: Funciones Especiales,  Next: Funciones elípticas,  Prev: Trigonometría,  Up: Top

16 Funciones Especiales
***********************

* Menu:

* Introducción a las Funciones Especiales::
* specint::
* Definiciones para las Funciones Especiales::


File: maxima.info,  Node: Introducción a las Funciones Especiales,  Next: specint,  Prev: Funciones Especiales,  Up: Funciones Especiales

16.1 Introducción a las Funciones Especiales
============================================


File: maxima.info,  Node: specint,  Next: Definiciones para las Funciones Especiales,  Prev: Introducción a las Funciones Especiales,  Up: Funciones Especiales

16.2 specint
============

El paquete `hypgeo' permite calcular transformadas de Laplace de
funciones especiales, mientras que `hyp' es otro paquete destinado al
cálculo de funciones hipergeométricas generalizadas.

   Por otro lado, `specint' tiene por objeto calcular la integral
definida (en el intervalo que va desde cero hasta infinito) de
expresiones que contengan funciones especiales. Cuando el integrando
contenga el factor `exp (-s t)', el resultado no es otro que la
transformada de Laplace.

   La sintaxis es la siguiente:

     specint (exp (-s*<t>) * <expr>, <t>);

   donde <t> es la variable de integración y <expr> es una expresión
que contiene funciones especiales.

   Si `specint' no puede calcular la integral, la respuesta que se
obtiene puede contener símbolos de Lisp, entre los que se incluyen
`other-defint-to-follow-negtest', `other-lt-exponential-to-follow',
`product-of-y-with-nofract-indices', etc.; este es un fallo conocido
del programa.

   A continuación se especifican las notaciones correspondientes a las
funciones especiales:

     bessel_j (index, expr)    Función de Bessel de primera especie
     bessel_y (index, expr)    Función de Bessel de segunda especie
     bessel_i (index, expr)    Función de Bessel modificada de primera especie
     bessel_k (index, expr)    Función de Bessel modificada de segunda especie
     %he[n] (z)                Polinomio de Hermite (Ojo: `he', no `h'. Ver A&S 22.5.18)
     %p[u,v] (z)               Función de Legendre de primera especie
     %q[u,v] (z)               Función de Legendre de segunda especie
     hstruve[n] (z)            Función H de Struve
     lstruve[n] (z)            Función L de Struve
     %f[p,q] ([], [], expr)    Función hipergeométrica generalizada
     gamma()                   Función Gamma
     gammagreek(a,z)           Función Gamma incompleta
     gammaincomplete(a,z)      Extremo de la función Gamma incompleta
     slommel
     %m[u,k] (z)               Función de Whittaker de primera especie
     %w[u,k] (z)               Función de Whittaker de segunda especie
     erfc (z)                  Complemento de la función de error, erf
     ei (z)                    Integral exponencial (?)
     kelliptic (z)             Integral elíptica completa de primera especie (K)
     %d [n] (z)                Función cilíndrica parabólica

   Con la instrucción `demo ("hypgeo")' se podrán ver algunos ejemplos
de transformadas de Laplace calculadas por `specint'.

   Este paquete aún está en desarrollo, por lo que algunos nombres de
funciones pueden sufrir cambios.


File: maxima.info,  Node: Definiciones para las Funciones Especiales,  Prev: specint,  Up: Funciones Especiales

16.3 Definiciones para las Funciones Especiales
===============================================

 -- Función: airy (<x>)
     Función Ai de Airy.  Si el argumento <x> es un número, se obtiene
     el valor numérico de `airy (<x>)'.  En caso contrario, se devuelve
     la expresión no evaluada `airy (<x>)'.

     La ecuación de Airy `diff (y(x), x, 2) - x y(x) = 0' tiene dos
     soluciones linealmente independientes, llamadas `ai' y `bi'. Esta
     ecuación es muy utilizada para obtener aproximaciones a problemas
     complejos en muchos ámbitos de la física matemática.

     La instrucción `load ("airy")' carga las funciones `ai', `bi',
     `dai' y `dbi'.

     El paquete `airy' contiene algoritmos para calcular `ai' y `bi',
     así como sus derivadas `dai' y `dbi'. El resultado es un número
     decimal en coma flotante si el argumento es a su vez un número, en
     caso contrario será una expresión no evaluada.

     Se producirá un error si el argumento es lo suficientemente grande
     como para que los exponenciales causen un desbordamiento
     (overflow), o una pérdida de precisión en el `sin' o en el `cos'.
     Con esto, el rango de validez es aproximadamente entre -2800 y
     10^38 para `ai' y `dai', y entre -2800 y 25 para `bi' y `dbi'.

     Maxima reconoce las siguientes derivadas:
        * `diff (ai(x), x)' devuelve `dai(x)',

        * `diff (dai(x), x)' devuelve `x ai(x)',

        * `diff (bi(x), x)' devuelve `dbi(x)',

        * `diff (dbi(x), x)' devuelve `x bi(x)'.

     Los valores de las funciones se calculan a partir del desarrollo
     convergente de Taylor para `abs(<x>) < 3', y de las expansiones
     asintóticas para `<x> < -3' o `<x> > 3', según sea necesario.  Con
     esto se consiguen discrepancias numéricas despreciables en `<x> =
     3' y `<x> = -3'.  Para detalles, véase Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 10.4 y Tabla 10.11.

     La llamada `ev (taylor (ai(x), x, 0, 9), infeval)' devuelve el
     desarrollo de Taylor con números decimales de la función `ai'. Se
     puede escribir una expresión similar para `bi'.


 -- Función: airy_ai (<x>)
     Función Ai de Airy, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 10.4.

     La ecuación de Airy `diff (y(x), x, 2) - x y(x) = 0' tiene dos
     soluciones linealmente independientes, `y = Ai(x)' y `y = Bi(x)'.
     La derivada `diff (airy_ai(x), x)' es `airy_dai(x)'.

     Si el argumento `x' es un número decimal real o complejo, se
     devolverá el valor numérico de `airy_ai' siempre que sea posible.

     Véanse `airy_bi', `airy_dai' y `airy_dbi'.

 -- Función: airy_dai (<x>)
     Es la derivada de la función Ai de Airy, `airy_ai(x)'.

     Véase `airy_ai'.

 -- Función: airy_bi (<x>)
     Es la función Bi de Airy, tal como la definen Abramowitz y Stegun,
     Handbook of Mathematical Functions, Sección 10.4. Se trata de la
     segunda solución de la ecuación de Airy `diff (y(x), x, 2) - x
     y(x) = 0'.

     Si el argumento `x' es un número decimal real o complejo, se
     devolverá el valor numérico de `airy_bi' siempre que sea posible.
     En los otros casos, se devuelve la expresión sin evaluar.

     La derivada `diff (airy_bi(x), x)' es `airy_dbi(x)'.

     Véanse `airy_ai' y `airy_dbi'.

 -- Función: airy_dbi (<x>)
     Es la derivada de la función Bi de Airy, `airy_bi(x)'.

     Véanse `airy_ai' y `airy_bi'.

 -- Función: asympa
     El paquete `asympa' contiene funciones de simplificación para
     realizar análisis asintótico, incluyendo las funciones  "big O" y
     "little o", de uso frecuente en el análisis complejo y numérico.

     La instrucción `load ("asympa")' carga este paquete.


 -- Función: bessel (<z>, <a>)
     Función de Bessel de primera especie.

     Ya no se recomienda su uso.  Utilícese `bessel_j (<z>, <a>)' en su
     lugar.


 -- Función: bessel_j (<v>, <z>)
     Función de Bessel de primera especie de orden v y argumento z.

     La función `bessel_j' calcula el arreglo `besselarray' tal que
     `besselarray [i] = bessel_j [i + v - int(v)] (z)' para `i' desde
     cero hasta `int(v)'.

     La función `bessel_j' se define como

                          inf
                          ====       k  - v - 2 k  v + 2 k
                          \     (- 1)  2          z
                           >    --------------------------
                          /        k! gamma(v + k + 1)
                          ====
                          k = 0

     aunque la serie infinita no se utiliza en los cálculos.


 -- Función: bessel_y (<v>, <z>)
     Función de Bessel de segunda especie de orden v y argumento z.

     La función `bessel_y' calcula el arreglo `besselarray' tal que
     `besselarray [i] = bessel_y [i + v - int(v)] (z)' para `i' desde
     cero hasta `int(v)'.

     La función `bessel_y' se define como

                        cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
                        -------------------------------------------
                                       sin(%pi v)

     si v no es un entero.  En caso de que  v sea un entero n, se
     calcula el límite cuando v se aproxima a n.


 -- Función: bessel_i (<v>, <z>)
     Función modificada de Bessel de primera especie de orden v y
     argumento z.

     La función `bessel_i' calcula el arreglo `besselarray' tal que
     `besselarray [i] = bessel_i [i + v - int(v)] (z)' para `i' desde
     cero hasta `int(v)'.

     La función `bessel_i' se define como

                              inf
                              ====   - v - 2 k  v + 2 k
                              \     2          z
                               >    -------------------
                              /     k! gamma(v + k + 1)
                              ====
                              k = 0

     aunque la serie infinita no se utiliza en los cálculos.


 -- Función: bessel_k (<v>, <z>)
     Función modificada de Bessel de segunda especie de orden v y
     argumento z.

     La función `bessel_k' calcula el arreglo `besselarray' tal que
     `besselarray [i] = bessel_k [i + v - int(v)] (z)' para `i' desde
     cero hasta `int(v)'.

     La función `bessel_k' se define como

                     %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
                     -------------------------------------------------
                                            2

     si v no es un entero.  Si v es igual al entero n, entonces se
     calcula el límite cuando v tiende a n.


 -- Variable optativa: besselexpand
     Valor por defecto: `false'

     Controla la expansión de las funciones de Bessel cuando el orden
     es la mitad de un entero impar. En tal caso, las funciones de
     Bessel se pueden expandir en términos de otras funciones
     elementales.  Si `besselexpand' vale `true', se expande la función
     de Bessel.

          (%i1) besselexpand: false$
          (%i2) bessel_j (3/2, z);
                                              3
          (%o2)                      bessel_j(-, z)
                                              2
          (%i3) besselexpand: true$
          (%i4) bessel_j (3/2, z);
                                    2 z   sin(z)   cos(z)
          (%o4)                sqrt(---) (------ - ------)
                                    %pi      2       z
                                            z

 -- Función: j0 (<x>)
     Función de Bessel de primera especie de orden 0.

     Ya no se recomienda su uso.  Utilícese `bessel_j (0, <x>)' en su
     lugar.


 -- Función: j1 (<x>)
     Función de Bessel de primera especie de orden 1.

     Ya no se recomienda su uso.  Utilícese `bessel_j (1, <x>)' en su
     lugar.


 -- Función: jn (<x>, <n>)
     Función de Bessel de primera especie de orden <n>.

     Ya no se recomienda su uso.  Utilícese `bessel_j (<n>, <x>)' en su
     lugar.


 -- Función: i0 (<x>)
     Función modificada de Bessel de primera especie de orden 0.

     Ya no se recomienda su uso.  Utilícese `bessel_i (0, <x>)' en su
     lugar.


 -- Función: i1 (<x>)
     Función modificada de Bessel de primera especie de orden 1.

     Ya no se recomienda su uso.  Utilícese `bessel_i (1, `x')' en su
     lugar.


 -- Función: beta (<x>, <y>)
     Función beta, definida como `gamma(x) gamma(y)/gamma(x + y)'.


 -- Función: gamma (<x>)
     Función gamma.

     Véase también `makegamma'.

     La variable `gammalim' controla la simplificación de la función
     gamma.

     La constante de Euler-Mascheroni es `%gamma'.


 -- Variable optativa: gammalim
     Valor por defecto: 1000000

     La variable `gammalim' controla la simplificación de la función
     gamma con argumentos enteros o racionales. Si el valor absoluto
     del argumento no es mayor que `gammalim', entonces se realizará la
     simplificación. Nótese que la variable `factlim' también controla
     la simplificación del resultado de `gamma' con argumento entero.


 -- Función: intopois (<a>)
     Convierte <a> en un codificado Poisson.


 -- Función: makefact (<expr>)
     Transforma las funciones `binomial', `gamma' y `beta' que aparecen
     en <expr> en su notación factorial.

     Véase también `makegamma'.


 -- Función: makegamma (<expr>)
     Transforma las funciones `binomial', `factorial' y `beta' que
     aparecen en <expr> en funciones `gamma'.

     Véase también `makefact'.


 -- Función: numfactor (<expr>)
     Devuelve el factor numérico que multiplica a la expresión <expr>,
     la cual debe tener un único término.

          (%i1) gamma (7/2);
                                    15 sqrt(%pi)
          (%o1)                     ------------
                                         8
          (%i2) numfactor (%);
                                         15
          (%o2)                          --
                                         8


 -- Función: outofpois (<a>)
     Convierte <a> desde codificado de Poisson a una representación
     general.  Si <a> no está en forma de Poisson, `outofpois' hace la
     conversión, siendo entonces el valor retornado `outofpois
     (intopois (<a>))'. Esta función es un simplificador canónico para
     sumas de potencias de senos y cosenos.


 -- Función: poisdiff (<a>, <b>)
     Deriva <a> con respecto a <b>. El argumento <b> debe aparecer sólo
     en los argumentos trigonométricos o sólo en los coeficientes.


 -- Función: poisexpt (<a>, <b>)
     Idéntico a `intopois (<a>^<b>)'. El argumento <b> debe ser un
     entero positivo.


 -- Variable optativa: poislim
     Valor por defecto: 5

     La variable `poislim' determina el dominio de los coeficientes en
     los argumentos de las funciones trigonométricas.  El valor por
     defecto 5 corresponde al intervalo [-2^(5-1)+1,2^(5-1)], o
     [-15,16], pero puede reasignarse para  [-2^(n-1)+1, 2^(n-1)].


 -- Función: poisplus (<a>, <b>)
     Idéntico a `intopois (a + b)'.


 -- Función: poissimp (<a>)
     Convierte <a> en una serie de Poisson para <a> en su
     representación general.


 -- Símbolo especial: poisson
     El símbolo `/P/' sigue a la etiqueta de las líneas que contienen
     expresiones que son series de Poisson.


 -- Función: poissubst (<a>, <b>, <c>)
     Sustituye <b> por <a> en <c>, donde  <c> es una serie de Poisson.

     (1) Si <b> es una de las variables <u>, <v>, <w>, <x>, <y> o <z>,
     entonces <a> debe ser una expresión lineal en esas variables (por
     ejemplo, `6*u + 4*v').

     (2) Si <b> no es ninguna de esas variables, entonces <a> no puede
     contener tampoco a ninguna de ellas, ni senos, ni cosenos.


 -- Función: poistimes (<a>, <b>)
     Idéntico a `intopois (<a>*<b>)'.


 -- Función: printpois (<a>)
     Presenta una serie de Poisson en un formato legible.
     Conjuntamente con `outofpois', si es necesario convertirá <a>
     primero en una codificación de Poisson.


 -- Función: psi (<x>)
 -- Función: psi [<n>](<x>)
     Derivada de `log (gamma (x))'.

     Maxima no calcula el valor numérico de `psi'. Sin embargo, la
     función `bfpsi' del paquete `bffac' puede calcular valores
     numéricos.



File: maxima.info,  Node: Funciones elípticas,  Next: Límites,  Prev: Funciones Especiales,  Up: Top

17 Funciones elípticas
**********************

* Menu:

* Introducción a las funciones e integrales elípticas::
* Definiciones para funciones elípticas::
* Definiciones para integrales elípticas::


File: maxima.info,  Node: Introducción a las funciones e integrales elípticas,  Next: Definiciones para funciones elípticas,  Prev: Funciones elípticas,  Up: Funciones elípticas

17.1 Introducción a las funciones e integrales elípticas
========================================================

Maxima da soporte para las funciones elípticas jacobianas y para las
integrales elípticas completas e incompletas.  Esto incluye la
manipulación simbólica de estas funciones y su evaluación numérica. Las
definiciones de estas funciones y de muchas de sus propiedades se
pueden encontrar en Abramowitz y Stegun, capítulos 16-17, que es la
fuente principal utilizada para su programación en Maxima, aunque
existen algunas diferencias.

   En particular, todas las funciones e integrales elípticas utilizan
el parámero m en lugar del módulo k o del ángulo alfa. Esta es una de
las diferencias con Abramowitz y Stegun, que utilizan el ángulo para
las funciones elípticas. Las siguientes relaciones son válidas:

   m = k^2 y k = sin(alfa).

   Las funciones e integrales elípticas en Maxima tienen como objetivo
primordial dar soporte al cálculo simbólico, de ahí que también estén
incluidas la mayoría de las derivadas e integrales asociadas a estas
funciones. No obstante lo anterior, si los argumentos dados a las
funciones son decimales en coma flotante, los resultados también serán
decimales.

   Sin embargo, la mayoría de las propiedades no realacionadas con las
derivadas de las funciones e integrales elípticas  todavía no han sido
programadas en Maxima.

   Algunos ejemplos de funciones elípticas:

     (%i1) jacobi_sn (u, m);
     (%o1)                    jacobi_sn(u, m)
     (%i2) jacobi_sn (u, 1);
     (%o2)                        tanh(u)
     (%i3) jacobi_sn (u, 0);
     (%o3)                        sin(u)
     (%i4) diff (jacobi_sn (u, m), u);
     (%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
     (%i5) diff (jacobi_sn (u, m), m);
     (%o5) jacobi_cn(u, m) jacobi_dn(u, m)

           elliptic_e(asin(jacobi_sn(u, m)), m)
      (u - ------------------------------------)/(2 m)
                          1 - m

                 2
        jacobi_cn (u, m) jacobi_sn(u, m)
      + --------------------------------
                   2 (1 - m)

   Algunos ejemplos de integrales elípticas:

     (%i1) elliptic_f (phi, m);
     (%o1)                  elliptic_f(phi, m)
     (%i2) elliptic_f (phi, 0);
     (%o2)                          phi
     (%i3) elliptic_f (phi, 1);
                                    phi   %pi
     (%o3)                  log(tan(--- + ---))
                                     2     4
     (%i4) elliptic_e (phi, 1);
     (%o4)                       sin(phi)
     (%i5) elliptic_e (phi, 0);
     (%o5)                          phi
     (%i6) elliptic_kc (1/2);
                                          1
     (%o6)                    elliptic_kc(-)
                                          2
     (%i7) makegamma (%);
                                      2 1
                                 gamma (-)
                                        4
     (%o7)                      -----------
                                4 sqrt(%pi)
     (%i8) diff (elliptic_f (phi, m), phi);
                                     1
     (%o8)                 ---------------------
                                         2
                           sqrt(1 - m sin (phi))
     (%i9) diff (elliptic_f (phi, m), m);
            elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
     (%o9) (-----------------------------------------------
                                   m

                                      cos(phi) sin(phi)
                                  - ---------------------)/(2 (1 - m))
                                                  2
                                    sqrt(1 - m sin (phi))

   El paquete para funciones e integrales elípticas fue programado por
Raymond Toy. Se distribuye, igual que Maxima, bajo la General Public
License (GPL).


File: maxima.info,  Node: Definiciones para funciones elípticas,  Next: Definiciones para integrales elípticas,  Prev: Introducción a las funciones e integrales elípticas,  Up: Funciones elípticas

17.2 Definiciones para funciones elípticas
==========================================

 -- Función: jacobi_sn (<u>, <m>)
     Función elíptica jacobiana sn(u,m).

 -- Función: jacobi_cn (<u>, <m>)
     Función elíptica jacobiana cn(u,m).

 -- Función: jacobi_dn (<u>, <m>)
     Función elíptica jacobiana dn(u,m).

 -- Función: jacobi_ns (<u>, <m>)
     Función elíptica jacobiana ns(u,m) = 1/sn(u,m).

 -- Función: jacobi_sc (<u>, <m>)
     Función elíptica jacobiana sc(u,m) = sn(u,m)/cn(u,m).

 -- Función: jacobi_sd (<u>, <m>)
     Función elíptica jacobiana sd(u,m) = sn(u,m)/dn(u,m).

 -- Función: jacobi_nc (<u>, <m>)
     Función elíptica jacobiana nc(u,m) = 1/cn(u,m).

 -- Función: jacobi_cs (<u>, <m>)
     Función elíptica jacobiana cs(u,m) = cn(u,m)/sn(u,m).

 -- Función: jacobi_cd (<u>, <m>)
     Función elíptica jacobiana cd(u,m) = cn(u,m)/dn(u,m).

 -- Función: jacobi_nd (<u>, <m>)
     Función elíptica jacobiana nc(u,m) = 1/cn(u,m).

 -- Función: jacobi_ds (<u>, <m>)
     Función elíptica jacobiana ds(u,m) = dn(u,m)/sn(u,m).

 -- Función: jacobi_dc (<u>, <m>)
     Función elíptica jacobiana dc(u,m) = dn(u,m)/cn(u,m).

 -- Función: inverse_jacobi_sn (<u>, <m>)
     Inversa de la función elíptica jacobiana sn(u,m).

 -- Función: inverse_jacobi_cn (<u>, <m>)
     Inversa de la función elíptica jacobiana cn(u,m).

 -- Función: inverse_jacobi_dn (<u>, <m>)
     Inversa de la función elíptica jacobiana dn(u,m).

 -- Función: inverse_jacobi_ns (<u>, <m>)
     Inversa de la función elíptica jacobiana ns(u,m).

 -- Función: inverse_jacobi_sc (<u>, <m>)
     Inversa de la función elíptica jacobiana sc(u,m).

 -- Función: inverse_jacobi_sd (<u>, <m>)
     Inversa de la función elíptica jacobiana sd(u,m).

 -- Función: inverse_jacobi_nc (<u>, <m>)
     Inversa de la función elíptica jacobiana nc(u,m).

 -- Función: inverse_jacobi_cs (<u>, <m>)
     Inversa de la función elíptica jacobiana cs(u,m).

 -- Función: inverse_jacobi_cd (<u>, <m>)
     Inversa de la función elíptica jacobiana cd(u,m).

 -- Función: inverse_jacobi_nd (<u>, <m>)
     Inversa de la función elíptica jacobiana nc(u,m).

 -- Función: inverse_jacobi_ds (<u>, <m>)
     Inversa de la función elíptica jacobiana ds(u,m).

 -- Función: inverse_jacobi_dc (<u>, <m>)
     Inversa de la función elíptica jacobiana dc(u,m).


File: maxima.info,  Node: Definiciones para integrales elípticas,  Prev: Definiciones para funciones elípticas,  Up: Funciones elípticas

17.3 Definiciones para integrales elípticas
===========================================

 -- Función: elliptic_f (<phi>, <m>)
     Integral elíptica incompleta de primera especie, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Véanse también `elliptic_e' y `elliptic_kc'.


 -- Función: elliptic_e (<phi>, <m>)
     Integral elíptica incompleta de segunda especie, definida como

     elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)

     Véanse también `elliptic_e' y `elliptic_ec'.


 -- Función: elliptic_eu (<u>, <m>)
     Integral elíptica incompleta de segunda especie, definida como

     integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),
     t, 0, tau)

     donde tau = sn(u,m)

     Esto se relaciona con `elliptic_e' mediante

     elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)

     Véase también `elliptic_e'.

 -- Función: elliptic_pi (<n>, <phi>, <m>)
     Integral elíptica incompleta de tercera especie, definida como

     integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)

     Maxima sólo conoce la derivada respecto de phi.

 -- Función: elliptic_kc (<m>)
     Integral elíptica completa de primera especie, definida como

     integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para algunos valores de m, se conoce el valor de la integral en
     términos de la función Gamma. Hágase uso de `makegamma' para
     realizar su cálculo.

 -- Función: elliptic_ec (<m>)
     Integral elíptica completa de segunda especie, definida como

     integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)

     Para algunos valores de m, se conoce el valor de la integral en
     términos de la función Gamma. Hágase uso de `makegamma' para
     realizar su cálculo.


File: maxima.info,  Node: Límites,  Next: Diferenciación,  Prev: Funciones elípticas,  Up: Top

18 Límites
**********

* Menu:

* Definiciones para Límites::


File: maxima.info,  Node: Definiciones para Límites,  Prev: Límites,  Up: Límites

18.1 Definiciones para Límites
==============================

 -- Variable optativa: lhospitallim
     Valor por defecto: 4

     Es el número máximo de veces que la regla de L'Hopital es aplicada
     en la función `limit', evitando bucles infinitos al iterar la
     regla en casos como `limit (cot(x)/csc(x), x, 0)'.


 -- Función: limit (<expr>, <x>, <val>, <dir>)
 -- Función: limit (<expr>, <x>, <val>)
 -- Función: limit (<expr>)
     Calcula el ímite de <expr> cuando la variable real <x> se aproxima
     al valor <val> desde la dirección <dir>. El argumento <dir> puede
     ser el valor `plus' para un límite por la derecha, `minus' para un
     límite por la izquierda o simplemente se omite para indicar un
     límite en ambos sentidos.

     La función `limit' utiliza los símbolos especiales siguientes:
     `inf' (más infinito) y `minf' (menos infinito). En el resultado
     también puede hacer uso de `und' (indefinido), `ind' (indefinido
     pero acotado) y `infinity' (infinito complejo).

     La variable `lhospitallim' guarda el número máximo de veces que la
     regla de L'Hopital es aplicada en la función `limit', evitando
     bucles infinitos al iterar la regla en casos como `limit
     (cot(x)/csc(x), x, 0)'.

     Si la variable `tlimswitch' vale `true' hará que el paquete sobre
     límites utilice desarrollos de Taylor siempre que sea posible.

     La variable `limsubst' evita que la función `limit' realice
     sustituciones sobre formas desconocidas, a fin de evitar fallos
     tales como que `limit (f(n)/f(n+1), n, inf)' devuelva 1.  Dándole
     a `limsubst' el valor `true' se permitirán tales sustituciones.

     La función `limit' con un solo argumento se utiliza frecuentemente
     para simplificar expresiones constantes, como por ejemplo `limit
     (inf-1)'.

     La instrucción `example (limit)' muestra algunos ejemplos.

     Para información sobre el método utilizado véase Wang, P.,
     "Evaluation of Definite Integrals by Symbolic Manipulation", Ph.D.
     thesis, MAC TR-92, October 1971.


 -- Variable optativa: limsubst
     Valor por defecto: `false'

     La variable `limsubst' evita que la función `limit' realice
     sustituciones sobre formas desconocidas, a fin de evitar fallos
     tales como que `limit (f(n)/f(n+1), n, inf)' devuelva 1.  Dándole
     a `limsubst' el valor `true' se permitirán tales sustituciones.


 -- Función: tlimit (<expr>, <x>, <val>, <dir>)
 -- Función: tlimit (<expr>, <x>, <val>)
 -- Función: tlimit (<expr>)
     Devuelve el límite solicitado dándole a `tlimswitch' el valor
     `true'.


 -- Variable optativa: tlimswitch
     Valor por defecto: `false'

     Si la variable `tlimswitch' vale `true' hará que el paquete sobre
     límites utilice desarrollos de Taylor siempre que sea posible.



File: maxima.info,  Node: Diferenciación,  Next: Integración,  Prev: Límites,  Up: Top

19 Diferenciación
*****************

* Menu:

* Definiciones para Diferenciación::


File: maxima.info,  Node: Definiciones para Diferenciación,  Prev: Diferenciación,  Up: Diferenciación

19.1 Definiciones para Diferenciación
=====================================

 -- Función: antid (<expr>, <x>, <u(x)>)
     Devuelve una lista con dos elementos, de manera que se pueda
     calcular la antiderivada de <expr> respecto de  <x> a partir de la
     lista. La expresión <expr> puede contener una función no
     especificada <u> y sus derivadas.

     Sea <L> la lista con dos elementos que devuelve la función `antid'.
     Entonces, `<L>[1] + 'integrate (<L>[2], <x>)' es una antiderivada
     de <expr> con respecto a <x>.

     Si la ejecución de `antid' resulta exitosa, el segundo elemento de
     la lista retornada es cero. En caso contrario, el segundo elemento
     es distinto de cero y el primero puede ser nulo o no. Si `antid'
     no es capaz de hacer ningún progreso, el primer elemento es nulo y
     el segundo no nulo.

     Es necesario ejecutar `load ("antid")' para cargar esta función.
     El paquete `antid' define también las funciones `nonzeroandfreeof'
     y `linear'.

     La función `antid' está relacionada con `antidiff' como se indica
     a continuación.  Sea <L> la lista devuelta por la función `antid'.
     Entonces, el resultado de `antidiff' es igual a  `<L>[1] +
     'integrate (<L>[2], <x>)', donde <x> es la variable de integración.

     Ejemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Función: antidiff (<expr>, <x>, <u>(<x>))
     Devuelve la antiderivada de <expr> respecto de <x>.  La expresión
     <expr> puede contener una función no especificada <u> y sus
     derivadas.

     Cuando `antidiff' se ejecuta con éxito, la expresión resultante no
     tiene símbolos integrales (esto es, no tiene referencias a la
     función `integrate'). En otro caso, `antidiff' devuelve una
     expresión que se encuentra total o parcialmente bajo el signo de
     integración. Si `antidiff' no puede ralizar ningún progreso, el
     valor devuelto se encuentra completamente bajo la integral.

     Es necesario ejecutar `load ("antid")' para cargar esta función.
     El paquete `antid' define también las funciones `nonzeroandfreeof'
     y `linear'.

     La función `antidiff' está relacionada con `antid' como se indica
     a continuación.  Sea <L> la lista de dos elementos que devuelve
     `antid'. Entonces, el valor retornado por `antidiff' es igual a
     `<L>[1] + 'integrate (<L>[2], <x>)', donde <x> es la variable de
     integración.

     Ejemplos:

          (%i1) load ("antid")$
          (%i2) expr: exp (z(x)) * diff (z(x), x) * y(x);
                                      z(x)  d
          (%o2)                y(x) %e     (-- (z(x)))
                                            dx
          (%i3) a1: antid (expr, x, z(x));
                                 z(x)      z(x)  d
          (%o3)          [y(x) %e    , - %e     (-- (y(x)))]
                                                 dx
          (%i4) a2: antidiff (expr, x, z(x));
                                      /
                               z(x)   [   z(x)  d
          (%o4)         y(x) %e     - I %e     (-- (y(x))) dx
                                      ]         dx
                                      /
          (%i5) a2 - (first (a1) + 'integrate (second (a1), x));
          (%o5)                           0
          (%i6) antid (expr, x, y(x));
                                       z(x)  d
          (%o6)             [0, y(x) %e     (-- (z(x)))]
                                             dx
          (%i7) antidiff (expr, x, y(x));
                            /
                            [        z(x)  d
          (%o7)             I y(x) %e     (-- (z(x))) dx
                            ]              dx
                            /


 -- Propiedad: atomgrad
     La propiedad `atomgrad' es asignada por `gradef'.


 -- Función: atvalue (<expr>, [<x_1> = <a_1>, ..., <x_m> = <a_m>], <c>)
 -- Función: atvalue (<expr>, <x_1> = <a_1>, <c>)
     Asigna el valor <c> a <expr> en el punto `<x> = <a>'.

     La expresión <expr> es una función del tipo `<f>(<x_1>, ...,
     <x_m>)', o una derivada, `diff (<f>(<x_1>, ..., <x_m>), <x_1>,
     <n_1>, ..., <x_n>, <n_m>)' en la que aparecen los argumentos de la
     función de forma explícita.  Los símbolos <n_i> se refieren al
     orden de diferenciación respecto de <x_i>.

     El punto en el que `atvalue' establece el valor se especifica
     mediante la lista de ecuaciones `[<x_1> = <a_1>, ..., <x_m> =
     <a_m>]'.  Si hay una única variable <x_1>, la ecuación puede
     escribirse sin formar parte de una lista.

     La llamada `printprops ([<f_1>, <f_2>, ...], atvalue)' muestra los
     valores asignados por `atvalue' a las funciones `<f_1>, <f_2>,
     ...'.  La llamada  `printprops (<f>, atvalue)' muestra los valores
     asignados por `atvalue' a la función <f>.  La llamada  `printprops
     (all, atvalue)' muestra los valores asignados por `atvalue' a
     todas las funciones.

     Los símbolos `@1', `@2', ... representan las variables <x_1>,
     <x_2>, ... cuando se muestran los valores asignados por `atvalue'.

     La función `atvalue' evalúa sus argumentos y devuelve <c>, el
     valor asignado.

     Ejemplos:

          (%i1) atvalue (f(x,y), [x = 0, y = 1], a^2);
                                          2
          (%o1)                          a
          (%i2) atvalue ('diff (f(x,y), x), x = 0, 1 + y);
          (%o2)                        @2 + 1
          (%i3) printprops (all, atvalue);
                                          !
                            d             !
                           --- (f(@1, @2))!       = @2 + 1
                           d@1            !
                                          !@1 = 0

                                               2
                                    f(0, 1) = a

          (%o3)                         done
          (%i4) diff (4*f(x,y)^2 - u(x,y)^2, x);
                            d                          d
          (%o4)  8 f(x, y) (-- (f(x, y))) - 2 u(x, y) (-- (u(x, y)))
                            dx                         dx
          (%i5) at (%, [x = 0, y = 1]);
                                                   !
                        2              d           !
          (%o5)     16 a  - 2 u(0, 1) (-- (u(x, y))!            )
                                       dx          !
                                                   !x = 0, y = 1


 -- Función: cartan -
     El cálculo exterior de formas diferenciales es una herramienta
     básica de la geometría diferencial desarrollada por Elie Cartan,
     teniendo importantes aplicaciones en la teoría de ecuaciones
     diferenciales en derivadas parciales.  El paquete `cartan' dispone
     de las funciones `ext_diff' y `lie_diff', así como de los
     operadores `~' (producto exterior) y `|' (contracción de una forma
     con un vector). La orden `demo (tensor)' permite ver una breve
     descripción de estas instrucciones, junto con ejemplos.

     El paquete `cartan' fue escrito por F.B. Estabrook y H.D.
     Wahlquist.


 -- Función: del (<x>)
     La expresión `del (<x>)' representa el diferencial de la variable
     x.

     La función `diff' devuelve una expresión que contiene a `del' si
     no se ha especificado una variable independiente. En este caso, el
     valor retornado es el llamado "diferencial total".

     Ejemplos:

          (%i1) diff (log (x));
                                       del(x)
          (%o1)                        ------
                                         x
          (%i2) diff (exp (x*y));
                               x y              x y
          (%o2)            x %e    del(y) + y %e    del(x)
          (%i3) diff (x*y*z);
          (%o3)         x y del(z) + x z del(y) + y z del(x)


 -- Función: delta (<t>)
     Es la función delta de Dirac.

     En el estado actual de desarrollo de Maxima, sólo `laplace'
     reconoce la función `delta'.

     Ejemplo:

          (%i1) laplace (delta (t - a) * sin(b*t), t, s);
          Is  a  positive, negative, or zero?

          p;
                                             - a s
          (%o1)                   sin(a b) %e


 -- Variable del sistema: dependencies
     Valor por defecto: `[]'

     La variable `dependencies' es la lista de átomos que tienen algún
     tipo de dependencia funcional, asignada por `depends' o `gradef'.
     La lista `dependencies' es acumulativa: cada llamada a `depends' o
     `gradef' añade elementos adicionales.

     Véanse `depends' y `gradef'.


 -- Función: depends (<f_1>, <x_1>, ..., <f_n>, <x_n>)
     Declara dependencias funcionales entre variables con el propósito
     de calcular derivadas.  En ausencia de una dependencia declarada,
     `diff (f, x)' devuelve cero.  Si se declara `depends (f, x)',
     `diff (f, x)' devuelve una derivada simbólica (esto es, una
     expresión con `diff').

     Cada argumento  <f_1>, <x_1>, etc., puede ser el nombre de una
     variable, de un arreglo o una lista de nombres.  Cada elemento de
     <f_i> (quizás un único elemento) se declara como dependiente de
     cada elemento de <x_i> (quizás también un único elemento). Si
     alguno de los  <f_i> es el nombre de un arreglo o contiene el
     nombre de un arreglo, todos los elemento del arregl dependen de
     <x_i>.

     La función `diff' reconoce dependencias indirectas establecidas
     por `depends' y aplica la regla de la cadena en tales casos.

     La instrucción `remove (<f>, dependency)' borra todas las
     dependencias declaradas para <f>.

     La función `depends' devuelve una lista con las dependencias que
     han sido establecidas. Las dependencias se añaden a la variable
     global `dependencies'. La función `depends' evalúa sus argumentos.

     La función `diff' es la única instrucción de Maxima que reconoce
     las dependencias establecidas por `depends'. Otras funciones
     (`integrate', `laplace', etc.) solamente reconocen dependencias
     explícitamente representadas por sus argumentos. Por ejemplo,
     `integrate' no reconoce la dependencia de `f' respecto de `x' a
     menos que se represente explícitamente como `integrate (f(x), x)'.

          (%i1) depends ([f, g], x);
          (%o1)                     [f(x), g(x)]
          (%i2) depends ([r, s], [u, v, w]);
          (%o2)               [r(u, v, w), s(u, v, w)]
          (%i3) depends (u, t);
          (%o3)                        [u(t)]
          (%i4) dependencies;
          (%o4)      [f(x), g(x), r(u, v, w), s(u, v, w), u(t)]
          (%i5) diff (r.s, u);
                                   dr           ds
          (%o5)                    -- . s + r . --
                                   du           du

          (%i6) diff (r.s, t);
                                dr du           ds du
          (%o6)                 -- -- . s + r . -- --
                                du dt           du dt

          (%i7) remove (r, dependency);
          (%o7)                         done
          (%i8) diff (r.s, t);
                                          ds du
          (%o8)                       r . -- --
                                          du dt


 -- Variable optativa: derivabbrev
     Valor por defecto: `false'

     Si `derivabbrev' vale `true', las derivadas simbólicas (esto es,
     expresiones con `diff') se muestran como subíndices. En otro caso,
     las derivadas se muestran en la notación de Leibniz, `dy/dx'.


 -- Función: derivdegree (<expr>, <y>, <x>)
     Devuelve el mayor grado de la derivada de la variable dependiente
     <y> respecto de la variable independiente <x> que aparece en
     <expr>.

     Ejemplo:
          (%i1) 'diff (y, x, 2) + 'diff (y, z, 3) + 'diff (y, x) * x^2;
                                   3     2
                                  d y   d y    2 dy
          (%o1)                   --- + --- + x  --
                                    3     2      dx
                                  dz    dx
          (%i2) derivdegree (%, y, x);
          (%o2)                           2


 -- Función: derivlist (<var_1>, ..., <var_k>)
     Hace que las derivadas calculadas por la instrucción `ev' se
     calculen respecto de las variables indicadas.


 -- Variable optativa: derivsubst
     Valor por defecto: `false'

     Si `derivsubst' vale `true', una sustitución no sintáctica del
     estilo `subst (x, 'diff (y, t), 'diff (y, t, 2))' devuelve `'diff
     (x, t)'.


 -- Función: diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)
 -- Función: diff (<expr>, <x>, <n>)
 -- Función: diff (<expr>, <x>)
 -- Función: diff (<expr>)
     Devuelve la derivada o diferencial de  <expr> respecto de alguna o
     de todas las variables presentes en <expr>.

     La llamada `diff (<expr>, <x>, <n>)' devuelve la <n>-esima
     derivada de <expr> respecto de <x>.

     La llamada `diff (<expr>, <x_1>, <n_1>, ..., <x_m>, <n_m>)'
     devuelve la derivada parcial de <expr> con respecto de <x_1>, ...,
     <x_m>.  Equivale a `diff (... (diff (<expr>, <x_m>, <n_m>) ...),
     <x_1>, <n_1>)'.

     La llamada `diff (<expr>, <x>)' devuelve la primera derivada de
     <expr> respecto de la variable <x>.

     La llamada `diff (<expr>)' devuelve el diferencial total de
     <expr>, esto es, la suma de las derivadas de <expr> respecto de
     cada una de sus variables, multiplicadas por el diferencial `del'
     de cada una de ellas.

     La forma nominal de `diff' es necesaria en algunos contextos, como
     para definir ecuaciones diferenciales.  En tales casos, `diff'
     puede ir precedida de un apóstrofo (como `'diff') para evitar el
     cálculo de la derivada.

     Si `derivabbrev' vale `true', las derivadas se muestran como
     subíndices. En otro caso, se muestran en la notación de Leibniz,
     `dy/dx'.

     Ejemplos:

          (%i1) diff (exp (f(x)), x, 2);
                               2
                        f(x)  d               f(x)  d         2
          (%o1)       %e     (--- (f(x))) + %e     (-- (f(x)))
                                2                   dx
                              dx
          (%i2) derivabbrev: true$
          (%i3) 'integrate (f(x, y), y, g(x), h(x));
                                   h(x)
                                  /
                                  [
          (%o3)                   I     f(x, y) dy
                                  ]
                                  /
                                   g(x)
          (%i4) diff (%, x);
                 h(x)
                /
                [
          (%o4) I     f(x, y)  dy + f(x, h(x)) h(x)  - f(x, g(x)) g(x)
                ]            x                     x                  x
                /
                 g(x)

     Para el paquete sobre tensores se han introducido las siguientes
     modificaciones:

     (1) Las derivadas de los objetos indexados en <expr> tendrán las
     variables <x_i> añadidas como argumentos adicionales. Entonces se
     ordenarán todos los índices de derivadas.

     (2) Las <x_i> pueden ser enteros entre 1 hasta el valor de la
     variable `dimension' [valor por defecto: 4].  Esto hará que la
     diferenciación sea llevada a cabo con respecto al <x_i>-ésimo
     número de la lista `coordinates', la cual debería contener una
     lista con los nombres de las coordenadas, por ejemplo, `[x, y, z,
     t]'. Si `coordinates' es una variableis atómica, entonces esa
     variable será utilizada como variable de diferenciación. Se
     permite la utilización de arreglos con los nombres de las
     coordenadas o nombres con subíndices, como `X[1]', `X[2]', ... to
     be used.  Si a `coordinates' no se le ha asignado ningún valor,
     entonces las variables serán tratadas como se ha indicado en (1).


 -- Símbolo especial: diff
     Si el nombre `diff' está presente en una llamada a la función `ev'
     en modo `evflag', entonces se calculan todas las derivadas
     presentes en `expr'.


 -- Función: express (<expr>)
     Transforma los nombres de operadores diferenciales en expresiones
     en términos de derivadas parciales. La función `express' reconoce
     los operadores `grad', `div', `curl' y `laplacian', así como el
     producto cruzado `~'.

     Las derivadas simbólicas (es decir, las que incluyen la forma
     nominal `diff') que aparecen el la expresión devuelta por
     `express' se pueden calcular añadiéndole a `ev' el término `diff'.
     En este contexto, `diff' sctúa como `evfun'.

     Es necesario ejecutar `load ("vect")' para cargar esta función.

     Ejemplos:

          (%i1) load ("vect")$
          (%i2) grad (x^2 + y^2 + z^2);
                                        2    2    2
          (%o2)                  grad (z  + y  + x )
          (%i3) express (%);
                 d    2    2    2   d    2    2    2   d    2    2    2
          (%o3) [-- (z  + y  + x ), -- (z  + y  + x ), -- (z  + y  + x )]
                 dx                 dy                 dz
          (%i4) ev (%, diff);
          (%o4)                    [2 x, 2 y, 2 z]
          (%i5) div ([x^2, y^2, z^2]);
                                        2   2   2
          (%o5)                   div [x , y , z ]
          (%i6) express (%);
                             d    2    d    2    d    2
          (%o6)              -- (z ) + -- (y ) + -- (x )
                             dz        dy        dx
          (%i7) ev (%, diff);
          (%o7)                    2 z + 2 y + 2 x
          (%i8) curl ([x^2, y^2, z^2]);
                                         2   2   2
          (%o8)                   curl [x , y , z ]
          (%i9) express (%);
                 d    2    d    2   d    2    d    2   d    2    d    2
          (%o9) [-- (z ) - -- (y ), -- (x ) - -- (z ), -- (y ) - -- (x )]
                 dy        dz       dz        dx       dx        dy
          (%i10) ev (%, diff);
          (%o10)                      [0, 0, 0]
          (%i11) laplacian (x^2 * y^2 * z^2);
                                            2  2  2
          (%o11)                laplacian (x  y  z )
          (%i12) express (%);
                   2                2                2
                  d     2  2  2    d     2  2  2    d     2  2  2
          (%o12)  --- (x  y  z ) + --- (x  y  z ) + --- (x  y  z )
                    2                2                2
                  dz               dy               dx
          (%i13) ev (%, diff);
                                2  2      2  2      2  2
          (%o13)             2 y  z  + 2 x  z  + 2 x  y
          (%i14) [a, b, c] ~ [x, y, z];
          (%o14)                [a, b, c] ~ [x, y, z]
          (%i15) express (%);
          (%o15)          [b z - c y, c x - a z, a y - b x]


 -- Función: gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)
 -- Función: gradef (<a>, <x>, <expr>)
     Define las derivadas parciales, o componentes del gradiente, de la
     función <f> o variable <a>.

     La llamada `gradef (<f>(<x_1>, ..., <x_n>), <g_1>, ..., <g_m>)'
     define `d<f>/d<x_i>' como <g_i>, donde <g_i> es una expresión;
     <g_i> puede ser una llamada a función, pero no el nombre de una
     función.  El número de derivadas parciales <m> puede ser menor que
     el número de argumentos <n>, en cuyo caso las derivadas se definen
     solamente con respecto a  <x_1>, ...., <x_m>.

     La llamada `gradef (<a>, <x>, <expr>)' define la derivada de la
     variable <a> respecto de <x> en <expr>. Con esto se establece la
     dependencia de <a> respecto de <x> a través de `depends (<a>,
     <x>)'.

     El primer argumento `<f>(<x_1>, ..., <x_n>)' o <a> no se evalúa,
     pero sí lo hacen el resto de argumentos <g_1>, ..., <g_m>.  La
     llamada a `gradef' devuelve la función o variable para la que se
     define la derivada parcial.

     La instrucción `gradef' puede redefinir las derivadas de las
     funciones propias de Maxima.  Por ejemplo, `gradef (sin(x), sqrt
     (1 - sin(x)^2))' redefine la derivada de `sin'.

     La instrucción `gradef' no puede definir derivadas parciales de
     funciones subindicadas.

     La llamada `printprops ([<f_1>, ..., <f_n>], gradef)' muestra las
     derivadas parciales de las funciones <f_1>, ..., <f_n>, tal como
     las definió `gradef'.

     La llamada `printprops ([<a_n>, ..., <a_n>], atomgrad)' muestra
     las derivadas parciales de las variables <a_n>, ..., <a_n>, tal
     como las definió `gradef'.

     La variable `gradefs' contiene la lista de las funciones para las
     que se han definido derivadas parciales con la instrucción
     `gradef', pero no incluye las variables para las que se han
     definido las derivadas parciales.

     Los gradientes son necesarios cuando una función no se conoce
     explícitamente pero sí sus primeras derivadas y es necesario
     calcular las derivadas de orden mayor.


 -- Variable del sistema: gradefs
     Valor por defecto: `[]'

     La variable `gradefs' contiene la lista de las funciones para las
     que se han definido derivadas parciales con la instrucción
     `gradef', pero no incluye las variables para las que se han
     definido las derivadas parciales.


 -- Función: laplace (<expr>, <t>, <s>)
     Calcula la transformada de Laplace de <expr> con respecto de la
     variable <t> y parámetro de transformación <s>. Si `laplace' no
     puede encontrar la solución, se devuelve la forma nominal
     `'laplace'.

     La función `laplace' reconoce en <expr> las funciones `delta',
     `exp', `log', `sin', `cos', `sinh', `cosh' y `erf', así como
     `derivative', `integrate', `sum' y `ilt'. Bajo la presencia de
     otras funciones, `laplace' puede que no sea capaz de calcular la
     transformada.

     La función `laplace' reconoce integrales de convolución de la
     forma `integrate (f(x) * g(t - x), x, 0, t)', no pudiendo
     reconocer otros tipos de convoluciones.

     Las relaciones funcionales se deben representar explícitamente en
     <expr>; las relaciones implícitas establecidas por `depends' no
     son reconocidas. Así, si <f> depende de <x> y <y>, `f (x, y)' debe
     aparecer en <expr>.

     Véase también `ilt', la transformada inversa de Laplace.

     Ejemplos:

          (%i1) laplace (exp (2*t + a) * sin(t) * t, t, s);
                                      a
                                    %e  (2 s - 4)
          (%o1)                    ---------------
                                     2           2
                                   (s  - 4 s + 5)
          (%i2) laplace ('diff (f (x), x), x, s);
          (%o2)             s laplace(f(x), x, s) - f(0)
          (%i3) diff (diff (delta (t), t), t);
                                    2
                                   d
          (%o3)                    --- (delta(t))
                                     2
                                   dt
          (%i4) laplace (%, t, s);
                                      !
                         d            !         2
          (%o4)        - -- (delta(t))!      + s  - delta(0) s
                         dt           !
                                      !t = 0



File: maxima.info,  Node: Integración,  Next: Ecuaciones,  Prev: Diferenciación,  Up: Top

20 Integración
**************

* Menu:

* Introducción a la Integración::
* Definiciones para Integración::


File: maxima.info,  Node: Introducción a la Integración,  Next: Definiciones para Integración,  Prev: Integración,  Up: Integración

20.1 Introducción a la Integración
==================================

Maxima tiene varias rutinas para calcular integrales. La función
`integrate' hace uso de la mayor parte de ellas.  También está el
paquete `antid', que opera con funciones no especificadas y sus
derivadas. Para usos numéricos se dispone de la función `romberg', un
integrador adaptativo que utiliza la regla de cuadratura de
Newton-Cotes, llamada `quanc8' y una batería de integradores
adaptativos de Quadpack, como `quad_qag', `quad_qags', etc.  También se
trabajan funciones hipergeométricas, véase `specint' para más detalles.
En términos generales, Maxima sólo opera con funciones que son
integrables en términos de funciones elementales, como las racionales,
trigonométricas, logarítmicas, exponenciales, radicales, etc., y unas
pocas extensiones de éstas, como la función de error o los
dilogaritmos. No opera con integrales en términos de funciones
desconocidas, como  `g(x)' o `h(x)'.


File: maxima.info,  Node: Definiciones para Integración,  Prev: Introducción a la Integración,  Up: Integración

20.2 Definiciones para Integración
==================================

 -- Función: changevar (<expr>, <f(x,y)>, <y>, <x>)
     Hace el cambio de variable dado por `<f(x,y)> = 0' en todas las
     integrales que aparecen en <expr> con la integración respecto de
     <x>. La nueva variable será <y>.

          (%i1) assume(a > 0)$
          (%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                                4
                               /
                               [    sqrt(a) sqrt(y)
          (%o2)                I  %e                dy
                               ]
                               /
                                0
          (%i3) changevar (%, y-z^2/a, z, y);
                                0
                               /
                               [                abs(z)
                             2 I            z %e       dz
                               ]
                               /
                                - 2 sqrt(a)
          (%o3)            - ----------------------------
                                          a

     Si una expresión contiene formas nominales, como aquélla en la que
     aparece `'integrate' en el ejemplo, podrá ser evaluada por `ev' si
     se utiliza el término `nouns'. Por ejemplo, la expresión devuelta
     por `changevar' se puede evaluar haciendo `ev (%o3, nouns)'.

     La función `changevar' también se puede utilizar para cambiar los
     índices de una suma o producto.  Sin embargo, debe tenerse en
     cuenta que cuando se realiza un cambio en una suma o producto, el
     mismo debe expresarse en términos de sumas, como `i = j+ ...', no
     como una función de mayor grado.

     Ejemplo:

          (%i4) sum (a[i]*x^(i-2), i, 0, inf);
                                   inf
                                   ====
                                   \         i - 2
          (%o4)                     >    a  x
                                   /      i
                                   ====
                                   i = 0
          (%i5) changevar (%, i-2-n, n, i);
                                  inf
                                  ====
                                  \               n
          (%o5)                    >      a      x
                                  /        n + 2
                                  ====
                                  n = - 2


 -- Función: dblint (<f>, <r>, <s>, <a>, <b>)
     Es una rutina para integrales dobles escrita en lenguaje Maxima y
     posteriormente traducida y compilada a código máquina. La
     instrucción `load (dblint)' carga esta función. Utiliza el método
     de Simpson en las dos direcciones `x' e `y' para calcular

          /b /s(x)
          |  |
          |  |    f(x,y) dy dx
          |  |
          /a /r(x)

     La función <f> debe ser una función traducida o compilada de dos
     variables, a la vez que <r> y <s> deben ser cada una de ellas una
     función traducida o compilada de una variable, mientras que <a> y
     <b> deben ser números en coma flotante. La rutina tiene dos
     variables globales que determinan el número de divisiones de los
     intervalos `x' e `y': `dblint_x' y `dblint_y', ambos con un valor
     por defecto de 10, pero que pueden cambiarse de forma
     independiente a otros valores enteros (hay `2*dblint_x+1' puntos a
     calcular en la dirección `x' y `2*dblint_y+1' en la dirección
     `y'). La rutina subdivide el eje X y luego para cada valor de X
     calcula primero `<r>(x)' y `<s>(x)'; entonces se subdivide el eje
     Y entre `<r>(x)' y `<s>(x)', evaluándose la integral a lo largo
     del eje Y aplicando la regla de Simpson; a continuación, se evalúa
     la integral a lo largo del eje X utilizando también la regla de
     Simpson tomando como valores de función las integrales sobre Y.
     Este procedimiento puede ser numéricamente inestable por múltiples
     motivos, pero es razonablemente rápido: evítese su uso con
     funciones con grandes oscilaciones o que tengan singularidades.
     Las integrales del eje Y dependen de la proximidad de los límites
     `<r>(x)' y `<s>(x)', de manera que si la distancia `<s>(x) -
     <r>(x)' varía rápidamente con X, puede dar lugar errores
     importantes debido a truncamientos de diferente amplitud en las
     integrales de Y. Se puede aumentar `dblint_x' y `dblint_y' al
     objeto de mejorar el recubrimiento de la región de integración,
     pero a costa del tiempo de cómputo. Es necesario que las funciones
     <f>, <r> y <s> estén traducidas o compiladas antes de utilizar
     `dblint', lo cual redundará en una mejora del tiempo de ejecución
     de varios órdenes de magnitud respecto de la ejecución de código
     interpretado.


 -- Función: defint (<expr>, <x>, <a>, <b>)
     Intenta calcular una integral definida. La función `defint' es
     invocada por  `integrate' cuando se especifican los límites de
     integración, por ejemplo `integrate (<expr>, <x>, <a>, <b>)'. Así,
     desde el punto de vista del usuario, es suficiente con utilizar
     `integrate'.

     La función `defint' devuelve una expresión simbólica, bien sea el
     resultado calculado o la forma nominal.  Véase `quad_qag' y sus
     funciones relacionadas para aproximaciones numéricas de integrales
     definidas.


 -- Función: erf (<x>)
     Es la función de error, cuya derivada es `2*exp(-x^2)/sqrt(%pi)'.


 -- Variable optativa: erfflag
     Valor por defecto: `true'

     Si `erfflag' vale `false', la función `risch' no introduce la
     función `erf' en el resultado si no había ninguna en el integrando.


 -- Función: ilt (<expr>, <t>, <s>)
     Calcula la transformada inversa de Laplace de <expr> con respecto
     de <t> y parámetro <s>. El argumento  <expr> debe ser una fracción
     de polinomios cuyo denominador tenga sólo factores lineales y
     cuadráticos. Utilizando las funciones `laplace' y `ilt', junto con
     las funciones `solve' o `linsolve', el usuario podrá resolver
     ciertas ecuaciones integrales.

          (%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
                        t
                       /
                       [                                    2
          (%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
                       ]
                       /
                        0
          (%i2) laplace (%, t, s);
                                         a laplace(f(t), t, s)   2
          (%o2)  b laplace(f(t), t, s) + --------------------- = --
                                                 2    2           3
                                                s  - a           s
          (%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                                  2      2
                                               2 s  - 2 a
          (%o3)     [laplace(f(t), t, s) = --------------------]
                                              5         2     3
                                           b s  + (a - a  b) s
          (%i4) ilt (rhs (first (%)), s, t);
          Is  a b (a b - 1)  positive, negative, or zero?

          pos;
                         sqrt(a b (a b - 1)) t
                  2 cosh(---------------------)       2
                                   b               a t
          (%o4) - ----------------------------- + -------
                        3  2      2               a b - 1
                       a  b  - 2 a  b + a

                                                                 2
                                                       + ------------------
                                                          3  2      2
                                                         a  b  - 2 a  b + a


 -- Función: integrate (<expr>, <x>)
 -- Función: integrate (<expr>, <x>, <a>, <b>)
     Calcula simbólicamente la integral de <expr> respecto de <x>. La
     llamada `integrate (<expr>, <x>)' resuelve una integral
     indefinida, mientras que  `integrate (<expr>, <x>, <a>, <b>)'
     resuelve una integral definida con límites de integración <a> y
     <b>.  Los límites no pueden contener a <x>. El argumento <a> no
     necesita ser menor que <b>.  Si <b> es igual a <a>, `integrate'
     devuelve cero.

     Véase `quad_qag' y funciones relacionadas para la aproximación
     numérica de integrales definidas.  Véase `residue' para el cálculo
     de residuos (integración compleja).  Véase `antid' para un método
     alternativo de resolución de integrales indefinidas.

     Se obtendrá una integral (es decir, una expresión sin `integrate')
     si `integrate' tiene éxito en el cálculo. En otro caso, la
     respuesta es la forma nominal de la integral (esto es, el operador
     `'integrate' precedido de apóstrofo) o una expresión que contiene
     una o más formas nominales. La forma nominal de `integrate' se
     muestra con un símbolo integral.

     En ciertos casos es útil proporcionar una forma nominal 'a mano',
     haciendo preceder `integrate' con una comilla simple o apóstrofo,
     como en `'integrate (<expr>, <x>)'.  Por ejemplo, la integral
     puede depender de algunos parámetros que todavía no han sido
     calculados.  La forma nominal puede aplicarse después a sus
     argumentos haciendo `ev (<i>, nouns)' donde <i> es la forma
     nominal de interés.

     La función `integrate' trata de manera diferente las integrales
     definidas de las indefinidas, empleando una batería de heurísticas
     especial para cada caso.  Casos especiales de integrales definidas
     incluyen las que tienen límites de integración iguales a cero o a
     infinito (`inf' o `minf'), funciones trigonométricas con límites
     de integración igual a cero y `%pi' o `2 %pi', funciones
     racionales, integrales relacionadas con las funciones `beta' y
     `psi' y algunas integrales logarítmicas y trigonométricas. El
     tratamiento de funciones racionales puede incluir el cálculo de
     residuos.  Si no se reconoce ninguno de los casos especiales, se
     intenta resolver la integral idefinida y evaluarla en los límites
     de integración. Esto incluye tomar límites cuando alguno de los
     extremos del intervalo de integración se acerca a más infinito o a
     menos infinito; véase también `ldefint'.

     Casos especiales de integrales indefinidas incluyen a las
     funciones trigonométricas, exponenciales, logarítmicas y
     racionales. La función `integrate' también hace uso de una pequeña
     tabla de integrales elementales.

     La función `integrate' puede llevar a cabo cambios de variable si
     el integrando es de la forma `f(g(x)) * diff(g(x), x)', entonces
     `integrate' trata de encontrar una subexpresión de `g(x)' tal que
     la derivada de  `g(x)' divida el integrando. Esta búsqueda puede
     hacer uso de las derivadas establecidas con la función `gradef'.
     Véanse también `changevar' y `antid'.

     Si ninguna de las heurísticas descritas resuelve la integral
     indefinida, se ejecuta el algoritmo de Risch.  La variable `risch'
     puede utilizarse como una `evflag', en una llamada a `ev' o en la
     línea de comandos por ejemplo, `ev (integrate (<expr>, <x>),
     risch)' o `integrate (<expr>, <x>), risch'.  Si `risch' está
     presenta, `integrate' llama a la función `risch' sin intentar
     primero las heurísticas. Véase también `risch'.

     La función `integrate' opera únicamente con relaciones funcionales
     que se representen explícitamente con la notación `f(x)', sin
     considerar las dependencias implícitas establecidas mediante la
     función `depends'.

     Es posible que `integrate' necesite conocer alguna propiedad de
     alguno de los parámetros presentes en el integrando, en cuyo caso
     `integrate' consultará en primer lugar la base de datos creada con
     `assume', y si la variable de interés no se encuentra ahí,
     `integrate' le preguntará al usuario. Dependiendo de la pregunta,
     posibles respuestas son: `yes;', `no;', `pos;', `zero;' o `neg;'.

     Por defecto, `integrate' no se considera lineal. Véanse `declare'
     y `linear'.

     La función `integrate' intentará la integración por partes sólo en
     casos especiales.

     Ejemplos:

        * Integrales elementales indefinidas y definidas.

               (%i1) integrate (sin(x)^3, x);
                                          3
                                       cos (x)
               (%o1)                   ------- - cos(x)
                                          3
               (%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                                2    2
               (%o2)                    - sqrt(b  - x )
               (%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                                              %pi
                                          3 %e      3
               (%o3)                      ------- - -
                                             5      5
               (%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                                           sqrt(%pi)
               (%o4)                       ---------
                                               2

        * Utilización de `assume' e interacción.

               (%i1) assume (a > 1)$
               (%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
                   2 a + 2
               Is  -------  an integer?
                      5

               no;
               Is  2 a - 3  positive, negative, or zero?

               neg;
                                                  3
               (%o2)                  beta(a + 1, - - a)
                                                  2

        * Cambio de variable. En este ejemplo hay dos cambios de
          variable: uno utilizando una derivada establecida con
          `gradef' y otra utilizando la derivada `diff(r(x))' de una
          función no especificada `r(x)'.

               (%i3) gradef (q(x), sin(x**2));
               (%o3)                         q(x)
               (%i4) diff (log (q (r (x))), x);
                                     d               2
                                    (-- (r(x))) sin(r (x))
                                     dx
               (%o4)                ----------------------
                                           q(r(x))
               (%i5) integrate (%, x);
               (%o5)                     log(q(r(x)))

        * El valor devuelto contiene la forma nominal `'integrate'.  En
          este ejemplo, Maxima puede extraer un factor del denominador
          de una función racional, pero no puede factorizar el resto.
          La función `grind' muestra la forma nominal `'integrate' del
          resultado.  Véase también `integrate_use_rootsof' para más
          información sobre integrales de funciones racionales.

               (%i1) expand ((x-4) * (x^3+2*x+1));
                                   4      3      2
               (%o1)              x  - 4 x  + 2 x  - 7 x - 4
               (%i2) integrate (1/%, x);
                                             /  2
                                             [ x  + 4 x + 18
                                             I ------------- dx
                                             ]  3
                                log(x - 4)   / x  + 2 x + 1
               (%o2)            ---------- - ------------------
                                    73               73
               (%i3) grind (%);
               log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$

        * Definición de una función mediante una integral.  El cuerpo
          de una función no se evalúa cuando ésta se define, de manera
          que el cuerpo de `f_1' en este ejemplo contiene la forma
          nominal de `integrate'.  El operador consistente en dos
          comillas simples `''' hace que se evalúe la integral y su
          resultado será el que defina a la función `f_2'.

               (%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                                    3
               (%o1)           f_1(a) := integrate(x , x, 1, a)
               (%i2) ev (f_1 (7), nouns);
               (%o2)                          600
               (%i3) /* Note parentheses around integrate(...) here */
                     f_2 (a) := ''(integrate (x^3, x, 1, a));
                                                  4
                                                 a    1
               (%o3)                   f_2(a) := -- - -
                                                 4    4
               (%i4) f_2 (7);
               (%o4)                          600


 -- Variable del sistema: integration_constant_counter
     Valor por defecto: 0

     La variable `integration_constant_counter' es un contador que se
     actualiza cada vez que se introduce una constante de integración
     en una expresión como resultado de una integración indefinida.


 -- Variable optativa: integrate_use_rootsof
     Valor por defecto: `false'

     Si `integrate_use_rootsof' vale `true' y el denominador de una
     función racional no se puede factorizar,  `integrate' devuelve la
     integral como una suma respecto de las raíces desconocidas del
     denominador.

     Por ejemplo, dándole a `integrate_use_rootsof' el valor `false',
     `integrate' devuelve la integral no resuelta de la función
     racional en forma nominal:

          (%i1) integrate_use_rootsof: false$
          (%i2) integrate (1/(1+x+x^5), x);
                  /  2
                  [ x  - 4 x + 5
                  I ------------ dx                            2 x + 1
                  ]  3    2                2            5 atan(-------)
                  / x  - x  + 1       log(x  + x + 1)          sqrt(3)
          (%o2)   ----------------- - --------------- + ---------------
                          7                 14             7 sqrt(3)

     Si ahora se le da a la variable el valor `true', la parte no
     resuelta de la integral se expresa como una suma cuyos sumandos
     dependen de las raíces del denominador de la función racional:

          (%i3) integrate_use_rootsof: true$
          (%i4) integrate (1/(1+x+x^5), x);
                ====        2
                \       (%r4  - 4 %r4 + 5) log(x - %r4)
                 >      -------------------------------
                /                    2
                ====            3 %r4  - 2 %r4
                                3    2
                %r4 in rootsof(x  - x  + 1)
          (%o4) ----------------------------------------------------------
                         7

                                                                       2 x + 1
                                                   2            5 atan(-------)
                                              log(x  + x + 1)          sqrt(3)
                                            - --------------- + ---------------
                                                    14             7 sqrt(3)

     Alternativamente, el usuario puede calcular las raíces del
     denominador separadamente y luego representar el integrando en
     función de dichas raíces, como por ejemplo `1/((x - a)*(x - b)*(x
     - c))' o `1/((x^2 - (a+b)*x + a*b)*(x - c))' si el denominador es
     un polinomio de tercer grado. En algunos casos, esto ayudará a
     Maxima mejorar sus resultados.


 -- Función: ldefint (<expr>, <x>, <a>, <b>)
     Calcula la integral definida de <expr> utilizando `limit' tras el
     cálculo de la integral indefinida de <expr> respecto a <x> en los
     extremos de integración <b> y <a>.  Si no consigue calcular la
     integral definida, `ldefint' devuelve una expresión con los
     límites en forma nominal.

     La función `integrate' no llama a `ldefint', de modo que la
     ejecución de `ldefint (<expr>, <x>, <a>, <b>)' puede dar un
     resultado diferente que `integrate (<expr>, <x>, <a>, <b>)'. La
     función `ldefint' siempre utiliza el mismo método para calcular la
     integral definida, mientras que `integrate' puede hacer uso de
     varias heurísticas y reconocer así casos especiales.


 -- Función: qq
     El paquete `qq', que puede cargarse haciendo `load ("qq")',
     contiene la función  `quanc8' que puede tomar 3 ó 4 argumentos. La
     versión para 3 argumentos calcula la integral de la función
     especificada en el primer argumento dentro del intervalo que va
     desde `lo' hasta `hi', como en `quanc8 ('function, lo, hi)'.  El
     nombre de la función debe ir precedido del apóstrofo.  La versión
     para 4 argumentos calcula la integral de la función especificada
     como primer argumento con respecto a la variable, que es el
     segundo argumento, en el intervalo que va desde `lo' hasta `hi',
     como en `quanc8(<f(x) or expression in x>, x, lo, hi)'.  El método
     utilizado es el de cuadratura polinomial de octavo orden de
     Newton-Cotes.


 -- Función: quanc8 (<expr>, <a>, <b>)
     Es un integrador adaptativo. Se incluyen ejemplos de uso. El
     m'etodo que sigue es el de cuadratura polinomial de octavo orden
     de Newton-Cotes, de ahí el nombre de la función `quanc8',
     disponible para 3 y 4 argumentos. Se hace control de error
     absoluto y relativo. Se carga en memoria haciendo `load ("qq")'.
     Véase también `qq'.


 -- Función: residue (<expr>, <z>, <z_0>)
     Calcula el residuo en el plano complejo de la expresión  <expr>
     cuando la variable <z> toma el valor <z_0>.  El residuo es el
     coeficiente de `(<z> - <z_0>)^(-1)' en el desarrollo de Laurent de
     <expr>.

          (%i1) residue (s/(s**2+a**2), s, a*%i);
                                          1
          (%o1)                           -
                                          2
          (%i2) residue (sin(a*x)/x**4, x, 0);
                                           3
                                          a
          (%o2)                         - --
                                          6


 -- Función: risch (<expr>, <x>)
     Integra <expr> respecto de <x> utilizando el caso trascendental
     del algoritmo de Risch. El caso algebraico del algoritmo de Risch
     no se ha implementado. Este método trata los casos de
     exponenciales y logaritmos anidados que no resuelve el
     procedimiento principal de `integrate'. La función `integrate'
     llamará automáticamente a `risch' si se presentan estos casos.

     Si la variable `erfflag' vale `false', evita que `risch'
     introduzca la función `erf' en la respuesta si ésta no estaba
     presente previamente en el integrando.

          (%i1) risch (x^2*erf(x), x);
                                                                  2
                       3                      2                - x
                  %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
          (%o1)   -------------------------------------------------
                                        3 %pi
          (%i2) diff(%, x), ratsimp;
                                       2
          (%o2)                       x  erf(x)


 -- Función: romberg (<expr>, <x>, <a>, <b>)
 -- Función: romberg (<expr>, <a>, <b>)
     Integración de Romberg. Hay dos formas de utilizar esta función.
     La primera es ineficiente: `romberg (<integrando>, <variable de
     integración>, <límite inferior>, <límite superior>)'.

     Ejemplos:

          (%i1) showtime: true$
          (%i2) romberg (sin(y), y, 0, %pi);
          Evaluation took 0.00 seconds (0.01 elapsed) using 25.293 KB.
          (%o2)                   2.000000016288042
          (%i3) 1/((x-1)^2+1/100) + 1/((x-2)^2+1/1000) + 1/((x-3)^2+1/200)$
          (%i4) f(x) := ''%$
          (%i5) rombergtol: 1e-6$
          (%i6) rombergit: 15$
          (%i7) romberg (f(x), x, -5, 5);
          Evaluation took 11.97 seconds (12.21 elapsed) using 12.423 MB.
          (%o7)                   173.6730736617464

     La segunda forma es más eficiente y se utiliza como sigue:

          romberg (<function name>, <lower limit>, <upper limit>);

     Continuando con el ejemplo anterior, se tiene:
          (%i8) f(x) := (mode_declare ([function(f), x], float), ''(%th(5)))$
          (%i9) translate(f);
          (%o9)                          [f]
          (%i10) romberg (f, -5, 5);
          Evaluation took 3.51 seconds (3.86 elapsed) using 6.641 MB.
          (%o10)                  173.6730736617464

     El primer argumento debe ser una función traducida o compilada.
     (Si está compilada, debe declararse para que devuelvaun `flonum'.)
     Si el primer argumento no está ya traducido,  `romberg' no
     intentará traducirlo y emitirá un mensaje de error.

     La precisión de la integración se controla con las variables
     globales `rombergtol' (valor por defecto 1.E-4) y `rombergit'
     (valor por defecto 11).  La función `romberg' devolverá un
     resultado si la diferencia relativa de aproximaciones sucesivas es
     menor que `rombergtol'.  Intentará disminuir el tamaño de los
     pasos `rombergit' veces antes de abandonar.  El número de
     iteraciones y evaluaciones de las funciones que hará `romberg' se
     controla con `rombergabs' y `rombergmin'.

     La función `romberg' puede llamarse recursivamente, de manera que
     puede calcular integrales dobles y triples.

     Ejemplo:
          (%i1) assume (x > 0)$
          (%i2) integrate (integrate (x*y/(x+y), y, 0, x/2), x, 1, 3)$
          (%i3) radcan (%);
                              26 log(3) - 26 log(2) - 13
          (%o3)             - --------------------------
                                          3
          (%i4) %,numer;
          (%o4)                   .8193023963959073
          (%i5) define_variable (x, 0.0, float, "Global variable in function F")$
          (%i6) f(y) := (mode_declare (y, float), x*y/(x+y))$
          (%i7) g(x) := romberg ('f, 0, x/2)$
          (%i8) romberg (g, 1, 3);
          (%o8)                   .8193022864324522


 -- Variable optativa: rombergabs
     Valor por defecto: 0.0

     Supuesto que las sucesivas estimaciones producidas por `romberg'
     son `y[0]', `y[1]', `y[2]', etc., entonces `romberg' devolverá un
     resultado después de `n' iteraciones, si

           (abs(y[n]-y[n-1]) <= rombergabs or
           abs(y[n]-y[n-1])/(if y[n]=0.0 then 1.0 else y[n]) <= rombergtol)

     vale `true'.  (La condición sobre el número de iteraciones dado
     por `rombergmin' también debe verificarse.)  Así, si `rombergabs'
     es 0.0 (el valor por defecto) se realiza el test relativo.

 -- Variable optativa: rombergit
     Valor por defecto: 11

     La precisión de la función de integración `romberg' está
     controlada por las variables globales `rombergtol' y `rombergit'.
     La función  `romberg' devolverá un resultado si la diferencia
     relativa de aproximaciones sucesivas es menor que `rombergtol'.
     Intentará disminuir el tamaño de los pasos `rombergit' veces antes
     de abandonar.


 -- Variable optativa: rombergmin
     Valor por defecto: 0

     La variable `rombergmin' controla el número mínimo de evaluaciones
     de función que realizará la función `romberg', la cual calculará
     su primer argumento al menos `2^(rombergmin+2)+1' veces.


 -- Variable optativa: rombergtol
     Valor por defecto: 1e-4

     La precisión de la función de integración `romberg' está
     controlada por las variables globales `rombergtol' y `rombergit'.
     La función  `romberg' devolverá un resultado si la diferencia
     relativa de aproximaciones sucesivas es menor que `rombergtol'.
     Intentará disminuir el tamaño de los pasos `rombergit' veces antes
     de abandonar.


 -- Función: tldefint (<expr>, <x>, <a>, <b>)
     Equivale a `ldefint' cuando `tlimswitch' vale `true'.


 -- Función: quad_qag (<f(x)>, <x>, <a>, <b>, <key>, <epsrel>, <limit>)
     Calcula numéricamente la integral

     integrate (f(x), x, a, b)

     utilizando un integrador adaptativo simple.

     La función a integrar es <f(x)>, con variable independiente <x>,
     siendo el intervalo de integración el comprendido entre <a> y <b>.
     El argumento <key> indica el integrador a utilizar y debe ser un
     número entero entre 1 y 6, ambos inclusive.  El valor de <key>
     selecciona el orden de la regla de integración de Gauss-Kronrod.

     La integración numérica se hace de forma adaptativa particionando
     la región de integración en subintervalos hasta conseguir la
     precisión requerida.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     La función `quad_qag' devuelve una lista de cuatro elementos:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3);
          (%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
          (%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                          4
          (%o2)                           -
                                          9

 -- Función: quad_qags (<f(x)>, <x>, <a>, <b>, <epsrel>, <limit>)
     Integra numéricamente la función dada utilizando una cuadratura
     adaptativa con extrapolación. La función a integrar es <f(x)>, con
     variable independiente <x>, siendo el intervalo de integración el
     comprendido entre <a> y <b>.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     La función `quad_qags' devuelve una lista de cuatro elementos:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `4'
          fallo de convergencia;

    `5'
          la integral es probablemente divergente o de convergencia
          lenta;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qags (x^(1/2)*log(1/x), x, 0 ,1);
          (%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]

     Nótese que `quad_qags' es más precisa y eficiente que `quad_qag'
     para este integrando.


 -- Función: quad_qagi (<f(x)>, <x>, <a>, <inftype>, <epsrel>, <limit>)
     Calcula numéricamente cualquiera las siguientes integrales:

     integrate (f(x), x, a, inf)

     integrate (f(x), x, minf, a)

     integrate (f(x), x, a, minf, inf)

     utilizando la rutina QAGI de Quadpack QAGI. La función a integrar
     es <f(x)>, con variable independiente <x>, siendo el intervalo de
     integración de rango infinito.

     El argumento <inftype> determina el intervalo de integración como
     sigue:

    `inf'
          El intervalo es desde <a> hasta más infinito.

    `minf'
          El intervalo es desde menos infinito hasta <a>.

    `both'
          El intervalo es toda la recta real.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     La función `quad_qagi' devuelve una lista de cuatro elementos:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `4'
          fallo de convergencia;

    `5'
          la integral es probablemente divergente o de convergencia
          lenta;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf);
          (%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
          (%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                                         1
          (%o2)                          --
                                         32


 -- Función: quad_qawc (<f(x)>, <x>, <c>, <a>, <b>, <epsrel>, <limit>)
     Calcula numéricamente el valor principal de Cauchy de

     integrate (f(x)/(x - c), x, a, b)

     utilizando la rutina QAWC de Quadpack.  La función a integrar es
     `<f(x)>/(<x> - <c>)', con variable independiente <x>, siendo el
     intervalo de integración el comprendido entre <a> y <b>.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     `quad_qawc' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5);
          (%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
          (%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1), x, 0, 5);
          Principal Value
                                 alpha
                  alpha       9 4                 9
                 4      log(------------- + -------------)
                                alpha           alpha
                            64 4      + 4   64 4      + 4
          (%o2) (-----------------------------------------
                                  alpha
                               2 4      + 2

                   3 alpha                       3 alpha
                   -------                       -------
                      2            alpha/2          2          alpha/2
                2 4        atan(4 4       )   2 4        atan(4       )   alpha
              - --------------------------- - -------------------------)/2
                          alpha                        alpha
                       2 4      + 2                 2 4      + 2
          (%i3) ev (%, alpha=5, numer);
          (%o3)                    - 3.130120337415917


 -- Función: quad_qawf (<f(x)>, <x>, <a>, <omega>, <trig>, <epsabs>,
          <limit>, <maxp1>, <limlst>)
     Calcula numéricamente integrales de tipo Fourier utilizando la
     rutina QAWF de Quadpack.  La integral es

     integrate (f(x)*w(x), x, a, inf)

     La función peso w se selecciona mediante <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Los argumentos opcionales son:

    <epsabs>
          El error absoluto deseado para la aproximación. El valor por
          defecto es 1d-10.

    <limit>
          Tamaño del arreglo interno de trabajo.  (<limit> -
          <limlst>)/2 es el número máximo de subintervalos para la
          partición. El valor por defecto es 200.

    <maxp1>
          Número máximo de momentos de Chebyshev. Debe ser mayor que 0.
          El valor por defecto es 100.

    <limlst>
          Cota superior del número de ciclos. Debe ser mayor o igual
          que 3.  El valor por defecto es 10.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     `quad_qawf' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos);
          (%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
          (%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                                    - 1/4
                                  %e      sqrt(%pi)
          (%o2)                   -----------------
                                          2
          (%i3) ev (%, numer);
          (%o3)                   .6901942235215714


 -- Función: quad_qawo (<f(x)>, <x>, <a>, <b>, <omega>, <trig>,
          <epsabs>, <limit>, <maxp1>, <limlst>)
     Realiza la integración numérica utizando la rutina QAWO de
     Quadpack:

     integrate (f(x)*w(x), x, a, b)

     La función peso w se selecciona mediante <trig>:

    `cos'
          w(x) = cos (omega x)

    `sin'
          w(x) = sin (omega x)

     Los argumentos opcionales son:

    <epsabs>
          El error absoluto deseado para la aproximación. El valor por
          defecto es 1d-10.

    <limit>
          Tamaño del arreglo interno de trabajo.  (<limit> -
          <limlst>)/2 es el número máximo de subintervalos para la
          partición. El valor por defecto es 200.

    <maxp1>
          Número máximo de momentos de Chebyshev. Debe ser mayor que 0.
          El valor por defecto es 100.

    <limlst>
          Cota superior del número de ciclos. Debe ser mayor o igual
          que 3.  El valor por defecto es 10.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     `quad_qawo' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
          (%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
          (%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x), x, 0, inf));
                             alpha/2 - 1/2            2 alpha
                  sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
          (%o2)   -----------------------------------------------------
                                         2 alpha
                                   sqrt(2        + 1)
          (%i3) ev (%, alpha=2, numer);
          (%o3)                     1.376043390090716


 -- Función: quad_qaws (<f(x)>, <x>, <a>, <b>, <alfa>, <beta>, <wfun>,
          <epsabs>, <limit>)
     Realiza la integración numérica utizando la rutina QAWS de
     Quadpack:

     integrate (f(x)*w(x), x, a, b)

     La función peso w se selecciona mediante <wfun>:

    `1'
          w(x) = (x - a)^alfa (b - x)^beta

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a)

    `3'
          w(x) = (x - a)^alfa (b - x)^beta log(b - x)

    `2'
          w(x) = (x - a)^alfa (b - x)^beta log(x - a) log(b - x)

     Los argumentos opcionales son:

    <epsabs>
          El error absoluto deseado para la aproximación. El valor por
          defecto es 1d-10.

    <limit>
          Tamaño del arreglo interno de trabajo.  (<limit> -
          <limlst>)/2 es el número máximo de subintervalos para la
          partición. El valor por defecto es 200.

     Los argumentos opcionales <epsrel> y <limit> son el error relativo
     y el número máximo  de subintervalos, respectivamente. La variable
     <epsrel> tiene por defecto el valor 1e-8 y <limit> el de 200.

     `quad_qaws' returns a list of four elements:

        * la aproximación a la integral,

        * el error absoluto estimado de la aproximación,

        * el número de evaluaciones del integrando,

        * un código de error.

     El código de error (el cuarto elemento del resultado) puede tener
     los siguientes valores:

    `0'
          si no ha habido problemas;

    `1'
          si se utilizaron demasiados intervalos;

    `2'
          si se encontró un número excesivo de errores de redondeo;

    `3'
          si el integrando ha tenido un comportamiento extraño frente a
          la integración;

    `6'
          si los argumentos de entrada no son válidos.

     Ejemplos:

          (%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1);
          (%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
          (%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
                 alpha
          Is  4 2      - 1  positive, negative, or zero?

          pos;
                                    alpha         alpha
                             2 %pi 2      sqrt(2 2      + 1)
          (%o2)              -------------------------------
                                         alpha
                                      4 2      + 2
          (%i3) ev (%, alpha=4, numer);
          (%o3)                     8.750097361672829



File: maxima.info,  Node: Ecuaciones,  Next: Ecuaciones Diferenciales,  Prev: Integración,  Up: Top

21 Ecuaciones
*************

* Menu:

* Definiciones para Ecuaciones::


File: maxima.info,  Node: Definiciones para Ecuaciones,  Prev: Ecuaciones,  Up: Ecuaciones

21.1 Definiciones para Ecuaciones
=================================

 -- Variable del sistema: %rnum_list
     Valor por defecto: `[]'

     La variable `%rnum_list' es la lista de variables introducidas en
     las soluciones por la función `algsys'.  Las variables `%r' se
     añaden a `%rnum_list' en su orden de creación. Esto es útil para
     hacer sustituciones en la solución.


 -- Variable opcional: algexact
     Default value: `false'

     El contenido de la variable `algexact' afecta al comportamiento de
     `algsys' de la siguiente forma:

     Si `algexact' vale `true', `algsys' llamará siempre a `solve' y
     luego utilizará `realroots'.

     Si `algexact' vale `false', `solve' será llamada sólo si la
     ecuación no es univariante, o si es cuadrática o bicuadrática.

     Sin embargo, `algexact: true' no garantiza que únicamente se
     obtengan soluciones exactas, ya que aunque `algsys' intente
     siempre dar soluciones exactas, dará resultados aproximados si no
     encuentra una solución mejor.


 -- Función: algsys ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
 -- Función: algsys ([<eqn_1>, ..., <eqn_m>], [<x_1>, ..., <x_n>])
     Resuelve el sistema de ecuaciones polinómicas <expr_1>, ...,
     <expr_m> o las ecuaciones <eqn_1>, ..., <eqn_m> para las variables
     <x_1>, ..., <x_n>.  La expresión <expr> equivale a la ecuación
     `<expr> = 0'. Puede haber más ecuaciones que variables o viceversa.

     La función `algsys' devuelve una lista de soluciones, cada una de
     las cuales consistente a su vez en una lista de ecuaciones
     asociando valores a las variables <x_1>, ..., <x_n> que satisfacen
     el sistema de ecuaciones.  Si `algsys' no puede encontrar
     soluciones devuelve la lista vacía `[]'.

     Si es necesario se introducen en la solución los símbolos  `%r1',
     `%r2', ..., para representar parámetros arbitrarios; estas
     variables también se añaden a la lista `%rnum_list'.

     El proceso que se sigue es el siguiente:

     (1) Primero se factorizan las ecuaciones y se reparten en
     subsistemas.

     (2) Para cada subsistema <S_i>, se seleccionan una ecuación <E> y
     una variable <x>. Se elige la variable que tenga grado menor.
     Entonces se calcula el resultado de <E> y <E_j> respecto de <x>,
     siendo las <E_j> el resto de ecuaciones del subsistema <S_i>. De
     aquí se obtiene otro subsistema <S_i'> con una incógnita menos, ya
     que <x> ha sido eliminada. El proceso ahora vuelve al paso (1).

     (3) En ocasiones se obtiene un subsistema consistente en una única
     ecuación. Si la ecuación es multivariante y no se han introducido
     aproximaciones en formato decimal de coma flotante, entonces  se
     llama a `solve' para tratar de encontrar una solución exacta.

     En algunos casos, `solve' no puede encontrar la solución, o si lo
     consigue puede que el resultado tenga una expresión muy grande.

     Si la ecuación tiene una sóla incógnita y es lineal, o cuadrática
     o bicuadrática, entonces se llama a la función `solve' si no se
     han introducido aproximaciones en formato decimal. Si se han
     introducido aproximaciones, o si hay más de una incógnita, o si no
     es lineal, ni cuadrática ni bicuadrática, y si la variables
     `realonly' vale `true', entonces se llama a la función `realroots'
     para calcular las soluciones reales.  Si `realonly' vale `false',
     entonces se llama a `allroots' para obtener las soluciones reales
     y complejas.

     Si `algsys' devuelve una solución que tiene menos dígitos
     significativos de los requeridos, el usuario puede cambiar a
     voluntad el valor de `algepsilon' para obtener mayor precisión.

     Si `algexact' vale `true', se llamará siempre a `solve'.

     Cuando `algsys' encuentra una ecuación con múltiples incógnitas y
     que contiene aproximaciones en coma flotante (normalmente debido a
     la imposibilidad de encontrar soluciones exactas en pasos
     anteriores), entonces no intenta aplicar los métodos exactos a
     estas ecuaciones y presenta el mensaje: "`algsys' cannot solve -
     system too complicated."

     Las interacciones con `radcan' pueden dar lugar a expresiones
     grandes o complicadas. En tal caso, puede ser posible aislar
     partes del resultado con  `pickapart' o `reveal'.

     Ocasionalmente, `radcan' puede introducir la unidad imaginaria
     `%i' en una solución que de hecho es real.

     Ejemplos:

          (%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
          (%o1)              2 (1 - a1) x - 2 a2 (x - 1)
          (%i2) e2: a2 - a1;
          (%o2)                        a2 - a1
          (%i3) e3: a1*(-y - x^2 + 1);
                                             2
          (%o3)                   a1 (- y - x  + 1)
          (%i4) e4: a2*(y - (x - 1)^2);
                                                 2
          (%o4)                   a2 (y - (x - 1) )
          (%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
          (%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0],

                                            [x = 1, y = 0, a1 = 1, a2 = 1]]
          (%i6) e1: x^2 - y^2;
                                        2    2
          (%o6)                        x  - y
          (%i7) e2: -1 - y + 2*y^2 - x + x^2;
                                   2        2
          (%o7)                 2 y  - y + x  - x - 1
          (%i8) algsys ([e1, e2], [x, y]);
                           1            1
          (%o8) [[x = - -------, y = -------],
                        sqrt(3)      sqrt(3)

                  1              1             1        1
          [x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
               sqrt(3)        sqrt(3)          3        3


 -- Función: allroots (<expr>)
 -- Función: allroots (<eqn>)
     Calcula aproximaciones numéricas de las raíces reales y complejas
     del polinomio <expr> o ecuación polinómica <eqn> de una variable.

     Si la variable `polyfactor' vale `true' hace que la función
     `allroots' factorice el polinomio para números reales si el
     polinomio es real, o para números complejos si el polinomio es
     complejo.

     La función `allroots' puede dar resultados inexactos en caso de
     que haya raíces múltiples.  Si el polinomio es real, `allroots
     (%i*<p>)') puede alcanzar mejores aproximaciones que `allroots
     (<p>)', ya que `allroots' ejecuta entonces un algoritmo diferente.

     La función `allroots' no opera sobre expresiones no polinómicas,
     pues requiere que el numerador sea reducible a un polinomio y el
     denominador sea, como mucho, un número complejo.

     Para polinomios complejos se utiliza el algoritmo de Jenkins y
     Traub descrito en (Algorithm 419, Comm. ACM, vol. 15, (1972), p.
     97). Para polinomios reales se utiliza el algoritmo de Jenkins
     descrito en (Algorithm 493, ACM TOMS, vol. 1, (1975), p.178).

     Ejemplos:

          (%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                                      3          5
          (%o1)              (2 x + 1)  = 13.5 (x  + 1)
          (%i2) soln: allroots (eqn);
          (%o2) [x = .8296749902129361, x = - 1.015755543828121,

          x = .9659625152196369 %i - .4069597231924075,

          x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
          (%i3) for e in soln
                  do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                                - 3.5527136788005E-15

                               - 5.32907051820075E-15

                   4.44089209850063E-15 %i - 4.88498130835069E-15

                  - 4.44089209850063E-15 %i - 4.88498130835069E-15

                                 3.5527136788005E-15

          (%o3)                         done
          (%i4) polyfactor: true$
          (%i5) allroots (eqn);
          (%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                                     2
           (x + 1.015755543828121) (x  + .8139194463848151 x

           + 1.098699797110288)


 -- Variable opcional: breakup
     Valor por defecto: `true'

     Si `breakup' vale `true', `solve' expresa sus soluciones a las
     ecuaciones cúbicas y cuárticas en términos de subexpresiones
     comunes, las cuales son asignadas a etiquetas del tipo `%t1',
     `%t2', etc.  En otro caso, no se identifican subexpresiones
     comunes.

     La asignación `breakup: true' sólo tiene efecto cuando
     `programmode' vale `false'.

     Ejemplos:

          (%i1) programmode: false$
          (%i2) breakup: true$
          (%i3) solve (x^3 + x^2 - 1);

                                  sqrt(23)    25 1/3
          (%t3)                  (--------- + --)
                                  6 sqrt(3)   54
          Solution:

                                                sqrt(3) %i   1
                                                ---------- - -
                          sqrt(3) %i   1            2        2   1
          (%t4)    x = (- ---------- - -) %t3 + -------------- - -
                              2        2            9 %t3        3

                                                sqrt(3) %i   1
                                              - ---------- - -
                        sqrt(3) %i   1              2        2   1
          (%t5)    x = (---------- - -) %t3 + ---------------- - -
                            2        2             9 %t3         3

                                             1     1
          (%t6)                  x = %t3 + ----- - -
                                           9 %t3   3
          (%o6)                    [%t4, %t5, %t6]
          (%i6) breakup: false$
          (%i7) solve (x^3 + x^2 - 1);
          Solution:

                       sqrt(3) %i   1
                       ---------- - -
                           2        2        sqrt(23)    25 1/3
          (%t7) x = --------------------- + (--------- + --)
                       sqrt(23)    25 1/3    6 sqrt(3)   54
                    9 (--------- + --)
                       6 sqrt(3)   54

                                                        sqrt(3) %i   1    1
                                                     (- ---------- - -) - -
                                                            2        2    3

                     sqrt(23)    25 1/3  sqrt(3) %i   1
          (%t8) x = (--------- + --)    (---------- - -)
                     6 sqrt(3)   54          2        2

                                                      sqrt(3) %i   1
                                                    - ---------- - -
                                                          2        2      1
                                                + --------------------- - -
                                                     sqrt(23)    25 1/3   3
                                                  9 (--------- + --)
                                                     6 sqrt(3)   54

                      sqrt(23)    25 1/3             1             1
          (%t9)  x = (--------- + --)    + --------------------- - -
                      6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                           9 (--------- + --)
                                              6 sqrt(3)   54
          (%o9)                    [%t7, %t8, %t9]


 -- Función: dimension (<eqn>)
 -- Función: dimension (<eqn_1>, ..., <eqn_n>)
     El paquete `dimen' es para análisis dimensional. La instrucción
     `load ("dimen")' carga el paquete y `demo ("dimen")' presenta una
     pequeña demostración.


 -- Variable opcional: dispflag
     Valor por defecto: `true'

     Si `dispflag' vale `false', entonces se inhibirá que Maxima
     muestre resultados de las funciones que resuelven ecuaciones
     cuando éstas son llamadas desde dentro de un bloque (`block').
     Cuando un bloque termina con el signo del dólar, $, a la variable
     `dispflag' se le asigna `false'.


 -- Función: funcsolve (<eqn>, <g>(<t>))
     Devuelve `[<g>(<t>) = ...]'  o `[]', dependiendo de que exista o
     no una función racional  `<g>(<t>)' que satisfaga <eqn>, la cual
     debe ser un polinomio de primer orden, lineal para `<g>(<t>)' y
     `<g>(<t>+1)'

          (%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1) = (n - 1)/(n + 2);
                                      (n + 3) f(n + 1)   n - 1
          (%o1)        (n + 1) f(n) - ---------------- = -----
                                           n + 1         n + 2
          (%i2) funcsolve (eqn, f(n));

          Dependent equations eliminated:  (4 3)
                                             n
          (%o2)                f(n) = ---------------
                                      (n + 1) (n + 2)

     Aviso: esta es una implemetación rudimentaria, por lo que debe ser
     utilizada con cautela.


 -- Variable opcional: globalsolve
     Valor por defecto: `false'

     Si `globalsolve' vale `true', a las incógnitas de las ecuaciones
     se les asignan las soluciones encontradas por `linsolve' y por
     `solve' cuando se resuelven sistemas de dos o más ecuaciones
     lineales.

     Si `globalsolve' vale `false', las soluciones encontradas por
     `linsolve' y por `solve' cuando se resuelven sistemas de dos o más
     ecuaciones lineales se expresan como ecuaciones y a las incógnitas
     no se le asignan valores.

     Cuando se resuelven ecuaciones que no son sistemas de dos o más
     ecuaciones lineales, `solve' ignora el valor de `globalsolve'.
     Otras funciones que resuelven ecuaciones (como `algsys') ignoran
     siempre el valor de `globalsolve'.

     Ejemplos:

          (%i1) globalsolve: true$
          (%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t2)                        x : --
                                           7

                                             1
          (%t3)                        y : - -
                                             7
          (%o3)                     [[%t2, %t3]]
          (%i3) x;
                                         17
          (%o3)                          --
                                         7
          (%i4) y;
                                           1
          (%o4)                          - -
                                           7
          (%i5) globalsolve: false$
          (%i6) kill (x, y)$
          (%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
          Solution

                                           17
          (%t7)                        x = --
                                           7

                                             1
          (%t8)                        y = - -
                                             7
          (%o8)                     [[%t7, %t8]]
          (%i8) x;
          (%o8)                           x
          (%i9) y;
          (%o9)                           y


 -- Función: ieqn (<ie>, <unk>, <tech>, <n>, <guess>)
     El paquete `inteqn' se dedica a la resolución de ecuaciones
     integrales. Para hacer uso de él, ejecutar la instrucción `load
     ("inteqn")'.

     El argumento <ie> es la ecuación integral; <unk> es la función
     incógnita; <tech> es el método a aplicar para efectuar la
     resolución del problema (<tech> = `first' significa: aplica el
     primer método que encuentre una solución; <tech> = `all'
     significa: aplica todos los métodos posibles); <n> es el número
     máximo de términos que debe tomar `taylor', `neumann',
     `firstkindseries' o `fredseries' (también es el máximo nivel de
     recursión para el método de diferenciación); <guess> es la
     solución candidata inicial para `neumann' o `firstkindseries'.

     Valores por defecto para los argumentos segundo a quinto son:

     <unk>: `<p>(<x>)', donde <p> es la primera función desconocida que
     Maxima encuentra en el integrando y <x> es la variable que actúa
     como argumento en la primera aparición de <p> encontrada fuera de
     una integral en el caso de ecuaciones de segunda especie
     (`secondkind'), o es la única variable aparte de la de integración
     en el caso de ecuaciones de primera especie (`firstkind'). Si el
     intento de encontrar <x> falla, el usuario será consultado para
     suministrar una variable independiente.


 -- Variable opcional: ieqnprint
     Valor por defecto: `true'

     La variable `ieqnprint' controla el comportamiento del resultado
     retornado por la instrucción `ieqn'. Si `ieqnprint' vale `false',
     la lista devuelta por la función `ieqn' tiene el formato

     [<solución>, <método utilizado>, <nterms>, <variable>]

     donde <variable> estará ausente si la solución es exacta; en otro
     caso, será la palabra `approximate' o `incomplete' según que la
     solución sea inexacta o que no tenga forma explícita,
     respectivamente. Si se ha utilizado un método basado en series,
     <nterms> es el número de términos utilizado, que puede ser menor
     que el `n' dado a `ieqn'.


 -- Función: lhs (<expr>)
     Devuelve el miembro izquierdo (es decir, el primer argumento) de
     la expresión <expr>, cuando el operador de <expr> es uno de los
     operadores de relación `< <= = # equal notequal >= >', o un
     operadores de asignación `:= ::= : ::', o un operador infijo
     binario definido por el usuario mediante `infix'.

     Si <expr> es un átomo o si su operador es diferente de los citados
     más arriba, `lhs' devuelve <expr>.

     Véase también `rhs'.

     Ejemplo:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [lhs (aa < bb), lhs (aa <= bb), lhs (aa >= bb), lhs (aa > bb)];
          (%o4)                   [aa, aa, aa, aa]
          (%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)), lhs (notequal (aa, bb))];
          (%o5)                   [aa, aa, aa, aa]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
          (%o10)               [foo(x), bar(y), x, x]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) lhs (aa ][ bb);
          (%o12)                         aa


 -- Función: linsolve ([<expr_1>, ..., <expr_m>], [<x_1>, ..., <x_n>])
     Resuelve la lista de ecuaciones lineales simultáneas para la lista
     de variables. Las expresiones deben ser polinomios lineales
     respecto de las variables o ecuaciones.

     Si `globalsolve' vale `true', a cada incógnita se le asigna el
     valor de la solución encontrada.

     Si `backsubst' vale `false', `linsolve' no hace la sustitución
     tras la triangulariación de las ecuaciones.  Esto puede ser
     necesario en problemas muy grandes en los que la sustitución puede
     dar lugar a la generación de expresiones enormes.

     Si `linsolve_params' vale `true', `linsolve' también genera
     símbolos `%r' para representar parámetros arbitrarios como los
     descritos para la función `algsys'. Si vale `false', el resultado
     devuelto por `linsolve' expresará, si es el sistema es
     indeterminado, unas variables en función de otras.

     Si `programmode' vale `false', `linsolve' muestra la solución con
     etiquetas de expresiones intermedias (`%t') y devuelve las lista
     de etiquetas.

          (%i1) e1: x + z = y;
          (%o1)                       z + x = y
          (%i2) e2: 2*a*x - y = 2*a^2;
                                                 2
          (%o2)                   2 a x - y = 2 a
          (%i3) e3: y - 2*z = 2;
          (%o3)                      y - 2 z = 2
          (%i4) [globalsolve: false, programmode: true];
          (%o4)                     [false, true]
          (%i5) linsolve ([e1, e2, e3], [x, y, z]);
          (%o5)            [x = a + 1, y = 2 a, z = a - 1]
          (%i6) [globalsolve: false, programmode: false];
          (%o6)                    [false, false]
          (%i7) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t7)                       z = a - 1

          (%t8)                        y = 2 a

          (%t9)                       x = a + 1
          (%o9)                    [%t7, %t8, %t9]
          (%i9) ''%;
          (%o9)            [z = a - 1, y = 2 a, x = a + 1]
          (%i10) [globalsolve: true, programmode: false];
          (%o10)                    [true, false]
          (%i11) linsolve ([e1, e2, e3], [x, y, z]);
          Solution

          (%t11)                      z : a - 1

          (%t12)                       y : 2 a

          (%t13)                      x : a + 1
          (%o13)                 [%t11, %t12, %t13]
          (%i13) ''%;
          (%o13)           [z : a - 1, y : 2 a, x : a + 1]
          (%i14) [x, y, z];
          (%o14)                 [a + 1, 2 a, a - 1]
          (%i15) [globalsolve: true, programmode: true];
          (%o15)                    [true, true]
          (%i16) linsolve ([e1, e2, e3], '[x, y, z]);
          (%o16)           [x : a + 1, y : 2 a, z : a - 1]
          (%i17) [x, y, z];
          (%o17)                 [a + 1, 2 a, a - 1]


 -- Variable opcional: linsolvewarn
     Valor por defecto: `true'

     Si `linsolvewarn' vale `true', `linsolve' mostrará el mensaje:
     "Dependent equations eliminated".


 -- Variable opcional: linsolve_params
     Valor por defecto: `true'

     Si `linsolve_params' vale `true', `linsolve' también genera
     símbolos `%r' para representar parámetros arbitrarios como los
     descritos para la función `algsys'. Si vale `false', el resultado
     devuelto por `linsolve' expresará, si es el sistema es
     indeterminado, unas variables en función de otras.


 -- System variable: multiplicities
     Valor por defecto: `not_set_yet'

     La variable `multiplicities' es una con las multiplicidades de las
     soluciones encontradas por `solve' o `realroots'.


 -- Función: nroots (<p>, <low>, <high>)
     Devuelve el número de raíces reales del polinomio real univariante
     <p> en el intervalo semiabierto `(<low>, <high>]'. Los extremos
     del intervalo pueden ser `minf' o `inf', menos y más infinito.

     La función `nroots' utiliza el método de las secuencias de Sturm.

          (%i1) p: x^10 - 2*x^4 + 1/2$
          (%i2) nroots (p, -6, 9.1);
          (%o2)                           4


 -- Función: nthroot (<p>, <n>)
     Siendo `p' un polinomio de coeficientes enteros y `n' un entero
     positivo, `nthroot' devuelve un polinomio `q', también de
     coeficientes enteros, tal que `q^n=p', o un mensaje de error
     indicando que `p' no es una `n'-potencia exacta. Esta función es
     bastante más rápida que `factor' y que `sqfr'.


 -- Variable opcional: programmode
     Valor por defecto: `true'

     Si `programmode' vale `true', `solve', `realroots', `allroots' y
     `linsolve' devuelve sus soluciones como elementos de una lista.
     Si `programmode' vale `false', `solve' y las demás crean
     expresiones intermedias etiquetadas `%t1', `t2', etc., y les
     asinan las soluciones.

          (%i1) solve(x^2+x+1);
                              sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o1)        [x = - --------------, x = --------------]
                                    2                   2
          (%i2) programmode:false$
          (%i3) solve(x^2+x+1);
          Solution:

                                        sqrt(3) %i + 1
          (%t3)                   x = - --------------
                                              2

                                       sqrt(3) %i - 1
          (%t4)                    x = --------------
                                             2
          (%o4)                        [%t4, %t5]


 -- Variable opcional: realonly
     Valor por defecto: `false'

     Si `realonly' vale `true', `algsys' sólo devuelve aquellas
     soluciones exentas de la constante `%i'.


 -- Función: realroots (<poly>, <bound>)
     Encuentra todas las raíces reales del polinomio real univariante
     con la tolerancia especificada por `bound', que si es menor que 1,
     hace que se busquen las raíces enteras de forma exacta. El
     argumento `bound' puede ser arbitrariamente pequeño a fin de
     conseguir la precisión deseada. El primer argumento también puede
     ser una ecuación. La función `realroots' asigna un valor a
     `multiplicities', útil en caso de raíces múltiples. La llamada
     `realroots (<p>)' equivale a `realroots (<p>, rootsepsilon)'. La
     variable `rootsepsilon' es un númeroreal que establece los
     intervalos de confianza para las raíces. Hágase `example
     (realroots)' para ver un ejemplo.


 -- Función: rhs (<expr>)
     Devuelve el miembro derecho (es decir, el segundo argumento) de la
     expresión <expr>, cuando el operador de <expr> es uno de los
     operadores de relación `< <= = # equal notequal >= >', o un
     operadores de asignación `:= ::= : ::', o un operador infijo
     binario definido por el usuario mediante `infix'.

     Si <expr> es un átomo o si su operador es diferente de los citados
     más arriba, `rhs' devuelve <expr>.

     Véase también `lhs'.

     Ejemplo:

          (%i1) e: aa + bb = cc;
          (%o1)                     bb + aa = cc
          (%i2) lhs (e);
          (%o2)                        bb + aa
          (%i3) rhs (e);
          (%o3)                          cc
          (%i4) [rhs (aa < bb), rhs (aa <= bb), rhs (aa >= bb), rhs (aa > bb)];
          (%o4)                   [bb, bb, bb, bb]
          (%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)), rhs (notequal (aa, bb))];
          (%o5)                   [bb, bb, bb, bb]
          (%i6) e1: '(foo(x) := 2*x);
          (%o6)                     foo(x) := 2 x
          (%i7) e2: '(bar(y) ::= 3*y);
          (%o7)                    bar(y) ::= 3 y
          (%i8) e3: '(x : y);
          (%o8)                         x : y
          (%i9) e4: '(x :: y);
          (%o9)                        x :: y
          (%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
          (%o10)                  [2 x, 3 y, y, y]
          (%i11) infix ("][");
          (%o11)                         ][
          (%i12) rhs (aa ][ bb);
          (%o12)                         bb


 -- Variable opcional: rootsconmode
     Valor por defecto: `true'

     La variable `rootsconmode' controla el comportamiento de la
     instrucción `rootscontract'.  Véase `rootscontract' para más
     detalles.


 -- Función: rootscontract (<expr>)
     Convierte productos de raíces en raíces de productos. Por ejemplo,
     `rootscontract (sqrt(x)*y^(3/2))' devuelve `sqrt(x*y^3)'.

     Si `radexpand' vale `true' y `domain' vale `real', `rootscontract'
     convierte `abs' en `sqrt', por ejemplo, `rootscontract
     (abs(x)*sqrt(y))' devuelve `sqrt(x^2*y)'.

     La opción `rootsconmode' afecta el resultado de `rootscontract'
     como sigue:

          Problema            Valor de         Resultadod de
                            rootsconmode        rootscontract

          x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
          x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
          x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
          x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
          x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
          x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)

     Si `rootsconmode' vale `false', `rootscontract' contrae sólamente
     respecto de exponentes racionales cuyos denominadores sean
     iguales. La clave para los ejemplos `rootsconmode: true' es
     simplemente que 2 divide a 4 pero no a 3. La asignación
     `rootsconmode: all' hace que se calcule el mínimo común múltiplo
     de los denominadores de los exponentes.

     La función `rootscontract' utiliza `ratsimp' de forma similar a
     como lo hace `logcontract'.

     Ejemplos:

          (%i1) rootsconmode: false$
          (%i2) rootscontract (x^(1/2)*y^(3/2));
                                             3
          (%o2)                      sqrt(x y )
          (%i3) rootscontract (x^(1/2)*y^(1/4));
                                             1/4
          (%o3)                     sqrt(x) y
          (%i4) rootsconmode: true$
          (%i5) rootscontract (x^(1/2)*y^(1/4));
          (%o5)                    sqrt(x sqrt(y))
          (%i6) rootscontract (x^(1/2)*y^(1/3));
                                             1/3
          (%o6)                     sqrt(x) y
          (%i7) rootsconmode: all$
          (%i8) rootscontract (x^(1/2)*y^(1/4));
                                        2   1/4
          (%o8)                       (x  y)
          (%i9) rootscontract (x^(1/2)*y^(1/3));
                                       3  2 1/6
          (%o9)                      (x  y )
          (%i10) rootsconmode: false$
          (%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                              *sqrt(sqrt(1 + x) - sqrt(x)));
          (%o11)                          1
          (%i12) rootsconmode: true$
          (%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
          (%o13)                          0


 -- Variable opcional: rootsepsilon
     Valor por defecto: 1.0e-7

     La variable `rootsepsilon' es la tolerancia que establece el
     intervalo de confianza para las raíces calculadas por la función
     `realroots'.


 -- Función: solve (<expr>, <x>)
 -- Función: solve (<expr>)
 -- Función: solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     Resuelve la ecuación algebraica <expr> de incógnita <x> y devuelve
     una lista de igualdades con la <x> despejada.  Si <expr> no es una
     igualdad, se supone que se quiere resolver la ecuación `<expr> =
     0'.  El argumento <x> puede ser una función (por ejemplo, `f(x)'),
     u otra expresión no atómica, excepto una suma o producto. Puede
     omitirse <x> si <expr> contiene solamente una variable. El
     argumento <expr> puede ser una expresión racional y puede contener
     funciones trigonométricas, exponenciales, etc.

     Se utiliza el siguiente método de resolución:

     Sea <E> la expresión y <X> la incógnita. Si <E> es lineal respecto
     de <X> entonces <X> se resuelve de forma trivial. En caso
     contrario, si <E> es de la forma `A*X^N + B' entonces el resultado
     es `(-B/A)^1/N)' multiplicado por las `N'-ésimas raíces de la
     unidad.

     Si <E> no es lineal respecto de <X> entonces el máximo común
     divisor de los exponentes de <X> en <E> (supóngase que es <N>) se
     divide entre los exponentes y la multiplicidad de las raíces se
     multiplica por <N>.  Entonces es llamado recursivamente `solve'
     para este resultado. Si <E> es factorizable entonces `solve' es
     invocado para cada uno de los factores.  Finalmente, `solve'
     usará, según sea necesario, las fórmulas cuadrática, cúbica o
     cuártica.

     En caso de que <E> sea un polinomio respecto de una función de la
     incógnita, por ejemplo `F(X)', entonces se calcula primero para
     `F(X)' (sea <C> el resultado obtenido), entonces la ecuación
     `F(X)=C' se resuelve para <X> en el supuesto que se conozca la
     inversa de la función <F>.

     Si la variable `breakup' vale `false' hará que `solve' muestre las
     soluciones de las ecuaciones cúbicas o cuárticas como expresiones
     únicas, en lugar de utilizar varias subexpresiones comunes, que es
     el formato por defecto.

     A la variable `multiplicities' se le asignará una lista con las
     multiplicidades de las soluciones individuales devueltas por
     `solve', `realroots' o `allroots'. La instrucción `apropos
     (solve)' hará que se muestren las variables optativas que de algún
     modo afectan al comportamiento de `solve'. Se podrá luego utilizar
     la función  `describe' para aquellas variables cuyo objeto no esté
     claro.

     La llamada `solve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])'
     resuelve un sistema de ecuaciones polinómicas simultáneas
     (lineales o no) llamando a `linsolve' o `algsys' y devuelve una
     lista de listas con soluciones para las incógnitas. En caso de
     haberse llamado a `linsolve' esta lista contendrá una única lista
     de soluciones. La llamada a `solve' tiene dos listas como
     argumentos. La primera lista tiene las ecuaciones a resolver y la
     segunda son las incógnitas cuyos valores se quieren calcular. Si
     el número de variables en las ecuaciones es igual al número de
     incógnitas, el segundo argumento puede omitirse. En caso de
     sistemas lineales incompatibles se mostrará el mensaje
     `inconsistent' (véase la variable `solve_inconsistent_error'); si
     no existe una única solución, se mostrará el mensaje `singular'.

     Si `programmode' vale `false', `solve' muestra la solución con
     etiquetas de expresiones intermedias (`%t') y devuelve las lista
     de etiquetas.

     Si `globalsolve' vale `true' y el problema consiste en resolver un
     sistema de dos o más ecuaciones lineales, a cada incógnita se le
     asigna el valor encontrado en la resolución del sistema.

     Ejemplos:
          (%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

          SOLVE is using arc-trig functions to get a solution.
          Some solutions will be lost.
                                      %pi
          (%o1)                  [x = ---, f(x) = 1]
                                       6
          (%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                          log(125)
          (%o2)                   [f(x) = --------]
                                           log(5)
          (%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                                2    2
          (%o3)             [4 x  - y  = 12, x y - x = 2]
          (%i4) solve (%, [x, y]);
          (%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

           - .1331240357358706, y = .0767837852378778

           - 3.608003221870287 %i], [x = - .5202594388652008 %i

           - .1331240357358706, y = 3.608003221870287 %i

           + .0767837852378778], [x = - 1.733751846381093,

          y = - .1535675710019696]]
          (%i5) solve (1 + a*x + x^3, x);
                                                 3
                        sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (%o5) [x = (- ---------- - -) (--------------- - -)
                            2        2      6 sqrt(3)      2

                  sqrt(3) %i   1
                 (---------- - -) a
                      2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                                    3
           sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
          (---------- - -) (--------------- - -)
               2        2      6 sqrt(3)      2

                   sqrt(3) %i   1
                (- ---------- - -) a
                       2        2
           - --------------------------, x =
                        3
                sqrt(4 a  + 27)   1 1/3
             3 (--------------- - -)
                   6 sqrt(3)      2

                   3
           sqrt(4 a  + 27)   1 1/3               a
          (--------------- - -)    - --------------------------]
              6 sqrt(3)      2                  3
                                        sqrt(4 a  + 27)   1 1/3
                                     3 (--------------- - -)
                                           6 sqrt(3)      2
          (%i6) solve (x^3 - 1);
                       sqrt(3) %i - 1        sqrt(3) %i + 1
          (%o6)   [x = --------------, x = - --------------, x = 1]
                             2                     2
          (%i7) solve (x^6 - 1);
                     sqrt(3) %i + 1      sqrt(3) %i - 1
          (%o7) [x = --------------, x = --------------, x = - 1,
                           2                   2

                               sqrt(3) %i + 1        sqrt(3) %i - 1
                         x = - --------------, x = - --------------, x = 1]
                                     2                     2
          (%i8) ev (x^6 - 1, %[1]);
                                                6
                                (sqrt(3) %i + 1)
          (%o8)                 ----------------- - 1
                                       64
          (%i9) expand (%);
          (%o9)                           0
          (%i10) x^2 - 1;
                                        2
          (%o10)                       x  - 1
          (%i11) solve (%, x);
          (%o11)                  [x = - 1, x = 1]
          (%i12) ev (%th(2), %[1]);
          (%o12)                          0


 -- Variable opcional: solvedecomposes
     Valor por defecto: `true'

     Si `solvedecomposes' vale `true', `solve' llama a `polydecomp' en
     caso de que se le pida resolver ecuaciones polinómicas.


 -- Variable opcional: solveexplicit
     Valor por defecto: `false'

     Si `solveexplicit' vale `true', le inhibe a `solve' devolver
     soluciones implícitas, esto es, soluciones de la forma `F(x) = 0',
     donde `F' es cierta función.


 -- Variable opcional: solvefactors
     Valor por defecto: `true'

     Si `solvefactors' vale `false', `solve' no intenta factorizar la
     expresión.  Este valor `false' puede ser útil en algunos casos en
     los que la factorización no es necesaria.


 -- Variable opcional: solvenullwarn
     Valor por defecto: `true'

     Si `solvenullwarn' vale `true',  `solve' muestra un mensaje de
     aviso si es llamado con una lista de ecuaciones vacía o con una
     lista de incógnitas vacía. Por ejemplo, `solve ([], [])' imprimirá
     dos mensajes de aviso y devolverá `[]'.


 -- Variable opcional: solveradcan
     Valor por defecto: `false'

     Si `solveradcan' vale `true', `solve' llama a `radcan', lo que
     hará que `solve' se ejecute de forma más lenta, pero permitirá que
     se resuelvan ciertas ecuaciones que contengan exponenciales y
     logaritmos.


 -- Variable opcional: solvetrigwarn
     Valor por defecto: `true'

     Si `solvetrigwarn' vale `true', `solve' puede presentar un mensaje
     diciendo que está utilizando funciones trigonométricas inversas
     para resolver la ecuación, y que por lo tanto puede estar
     ignorando algunas soluciones.


 -- Variable opcional: solve_inconsistent_error
     Valor por defecto: `true'

     Si `solve_inconsistent_error' vale `true', `solve' y `linsolve'
     devuelven un error si las ecuaciones a resolver son incompatibles.
     Si vale `false', `solve' y `linsolve' devuelven la lista vacía
     `[]' en caso de incompatibilidad.

     Ejemplo:

          (%i1) solve_inconsistent_error: true$
          (%i2) solve ([a + b = 1, a + b = 2], [a, b]);
          Inconsistent equations:  (2)
           -- an error.  Quitting.  To debug this try debugmode(true);
          (%i3) solve_inconsistent_error: false$
          (%i4) solve ([a + b = 1, a + b = 2], [a, b]);
          (%o4)                          []



File: maxima.info,  Node: Ecuaciones Diferenciales,  Next: Métodos numéricos,  Prev: Ecuaciones,  Up: Top

22 Ecuaciones Diferenciales
***************************

* Menu:

* Definiciones para Ecuaciones Diferenciales::


File: maxima.info,  Node: Definiciones para Ecuaciones Diferenciales,  Prev: Ecuaciones Diferenciales,  Up: Ecuaciones Diferenciales

22.1 Definiciones para Ecuaciones Diferenciales.
================================================

 -- Función: bc2 (<soluc>, <xval1>, <yval1>, <xval2>, <yval2>)
     Resuelve el problema del valor en la frontera para ecuaciones
     diferenciales de segundo orden.  Aquí, <soluc> es una solución
     general de la ecuación, como las que calcula `ode2', <xval1> es
     una ecuación de la forma `<x> = <x0>' para la variable
     independiente y <yval1> es una ecuación de la forma `<y> = <y0>'
     para la variable dependiente.  Los argumentos <xval2> y <yval2>
     son ecuaciones a verificar por estas mismas variables en otro
     punto. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: desolve (<ecu>, <x>)
 -- Función: desolve ([<eqn_1>, ..., <eqn_n>], [<x_1>, ..., <x_n>])
     La función `dsolve' resuelve sistemas de ecuaciones diferenciales
     ordinarias lineales utilizando la transformada de Laplace.  Aquí
     las <eqi> (`i'=1,..,n) son ecuaciones diferenciales con variables
     dependientes <x_1>, ..., <x_n>. Las relaciones funcionales deben
     indicarse explícitamente tanto para las ecuaciones como para las
     variables. Por ejemplo,

          'diff(f,x,2)=sin(x)+'diff(g,x);
          'diff(f,x)+x^2-f=2*'diff(g,x,2);

     no es el formato apropiado. El método correcto es

          'diff(f(x),x,2)=sin(x)+'diff(g(x),x);
          'diff(f(x),x)+x^2-f=2*'diff(g(x),x,2);

     La llamada a la función debe ser entonces
     `desolve([%o3,%o4],[f(x),g(x)]);' .

     Si las condiciones iniciales en 0 son conocidas, deben ser
     suministradas antes de llamar a `desolve' haciendo uso previo de
     la función `atvalue',

          (%i1) 'diff(f(x),x)='diff(g(x),x)+sin(x);
                           d           d
          (%o1)            -- (f(x)) = -- (g(x)) + sin(x)
                           dx          dx
          (%i2) 'diff(g(x),x,2)='diff(f(x),x)-cos(x);
                            2
                           d            d
          (%o2)            --- (g(x)) = -- (f(x)) - cos(x)
                             2          dx
                           dx
          (%i3) atvalue('diff(g(x),x),x=0,a);
          (%o3)                           a
          (%i4) atvalue(f(x),x=0,1);
          (%o4)                           1
          (%i5) desolve([%o1,%o2],[f(x),g(x)]);
                            x
          (%o5) [f(x) = a %e  - a + 1, g(x) =

                                                          x
                                             cos(x) + a %e  - a + g(0) - 1]
          (%i6) [%o1,%o2],%o5,diff;
                       x       x      x                x
          (%o6)   [a %e  = a %e , a %e  - cos(x) = a %e  - cos(x)]

     Si `desolve' no encuentra una solución, entonces devuelve `false'.


 -- Función: ic1 (<soluc>, <xval>, <yval>)
     Resuelve el problema del valor inicial en ecuaciones diferenciales
     de primer orden.  Aquí, <soluc> es una solución general de la
     ecuación, como las que calcula `ode2', <xval> es una ecuación de
     la forma `<x> = <x0>' para la variable independiente y <yval> es
     una ecuación de la forma `<y> = <y0>' para la variable
     dependiente. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: ic2 (<soluc>, <xval>, <yval>, <dval>)
     Resuelve el problema del valor inicial en ecuaciones diferenciales
     de segundo orden.  Aquí, <soluc> es una solución general de la
     ecuación, como las que calcula `ode2', <xval> es una ecuación de
     la forma `<x> = <x0>' para la variable independiente y <yval> es
     una ecuación de la forma `<y> = <y0>' para la variable
     dependiente, siendo <dval> una ecuación para la derivada de la
     variable dependiente respecto de la independiente en el punto
     <xval>. Véase `ode2' para un ejemplo sobre su utilización.


 -- Función: ode2 (<ecu>, <dvar>, <ivar>)
     La función `ode2' resuelve ecuaciones diferenciales ordinarias de
     primer y segundo orden. Admite tres argumentos: una ecuación
     diferencial ordinaria <ecu>, la variable dependiente <dvar> y la
     variable independiente <ivar>.  Si ha tenido éxito en la
     resolución de la ecuación, devuelve una solución, explícita o
     implícita, para la variable dependiente. El símbolo `%c' se
     utiliza para representar la constante en el caso de ecuaciones de
     primer orden y los símbolos `%k1' y `%k2' son las constantes de
     las ecuaciones de segundo orden. Si por cualquier razón `ode2' no
     puede calcular la solución, devolverá `false', acompañado quizás
     de un mensaje de error. Los métodos utilizados para las ecuaciones
     de primer orden, en el orden en que se hace la tentativa de
     resolución son: lineal, separable, exacto (pudiendo solicitar en
     este caso un factor de integración), homogéneo, ecuación de
     Bernoulli y un método homogéneo generalizado. Para las ecuaciones
     de segundo orden: coeficiente constante, exacto, homogéneo lineal
     con coeficientes no constantes  que pueden ser transformados en
     coeficientes constantes, ecuación equidimensional o de Euler,
     método de variación de parámetros y ecuaciones exentas de las
     variables dependientes o independientes de manera que se puedan
     reducir a dos ecuaciones lineales de primer a ser resueltas
     secuencialmente. Durante el proceso de resolución de ecuaciones
     diferenciales ordinarias, ciertas variables se utilizan con el
     único propósito de suministrar información al usuario: `method'
     almacena el método utilizado para encontrar la solución (como por
     ejemplo `linear'), `intfactor' para el factor de integración que
     se haya podido utilizar, `odeindex' para el índice del método de
     Bernoulli o el homogéneo generalizado y `yp' para la solución
     particular del método de variación de parámetros.

     A fin de resolver problemas con valores iniciales y problemas con
     valores en la frontera, la función `ic1' está disponible para
     ecuaciones de primer orden y las funciones `ic2' y `bc2' para
     problemas de valores iniciales y de frontera, respectivamente, en
     el caso de las ecuaciones de segundo orden.

     Ejemplo:

          (%i1) x^2*'diff(y,x) + 3*y*x = sin(x)/x;
                                2 dy           sin(x)
          (%o1)                x  -- + 3 x y = ------
                                  dx             x
          (%i2) ode2(%,y,x);
                                       %c - cos(x)
          (%o2)                    y = -----------
                                            3
                                           x
          (%i3) ic1(%o2,x=%pi,y=0);
                                        cos(x) + 1
          (%o3)                   y = - ----------
                                             3
                                            x
          (%i4) 'diff(y,x,2) + y*'diff(y,x)^3 = 0;
                                   2
                                  d y      dy 3
          (%o4)                   --- + y (--)  = 0
                                    2      dx
                                  dx
          (%i5) ode2(%,y,x);
                                3
                               y  + 6 %k1 y
          (%o5)                ------------ = x + %k2
                                    6
          (%i6) ratsimp(ic2(%o5,x=0,y=0,'diff(y,x)=2));
                                       3
                                    2 y  - 3 y
          (%o6)                   - ---------- = x
                                        6
          (%i7) bc2(%o5,x=0,y=1,x=1,y=3);
                                   3
                                  y  - 10 y       3
          (%o7)                   --------- = x - -
                                      6           2



File: maxima.info,  Node: Métodos numéricos,  Next: Estadística,  Prev: Ecuaciones Diferenciales,  Up: Top

23 Métodos numéricos
********************

* Menu:

* Introducción a los métodos numéricos::
* Series de Fourier::
* Definiciones para los métodos numéricos::
* Definiciones para las series de Fourier::


File: maxima.info,  Node: Introducción a los métodos numéricos,  Next: Series de Fourier,  Prev: Métodos numéricos,  Up: Métodos numéricos

23.1 Introducción a los métodos numéricos
=========================================


File: maxima.info,  Node: Series de Fourier,  Next: Definiciones para los métodos numéricos,  Prev: Introducción a los métodos numéricos,  Up: Métodos numéricos

23.2 Series de Fourier
======================

El paquete `fft' contiene funciones para el cálculo numérico (no
simbólico) de la transformada rápida de Fourier. La instrucción `load
("fft")' carga el paquete. Véase `fft'.

   El paquete `fourie' contiene funciones para el cálculo simbólico de
series de Fourier. La instrucción `load ("fourie")' carga el paquete.
Hay funciones en el paquete `fourie' para calcular los coeficientes de
Fourier y para la transformación de expresiones. Véase `Definiciones
para las series de Fourier'.


File: maxima.info,  Node: Definiciones para los métodos numéricos,  Next: Definiciones para las series de Fourier,  Prev: Series de Fourier,  Up: Métodos numéricos

23.3 Definiciones para los métodos numéricos
============================================

 -- Función: polartorect (<magnitude_array>, <phase_array>)
     Transforma valores complejos de la forma `r %e^(%i t)' a la forma
     `a + b %i'. La instrucción `load ("fft")' carga esta función en
     Maxima. Véase también `fft'.

     El módulo y la fase, `r' y `t', se toman de <magnitude_array> y
     <phase_array>, respectivamente. Los valores originales de los
     arreglos de entrada se reemplazan por las partes real e
     imaginaria, `a' y `b'. Los resultados se calculan como

          a: r cos (t)
          b: r sin (t)

     Los arreglos de entrada deben ser de igual tamaño y de dimensión
     1. El tamaño del arreglo no necesita ser potencia de 2.

     La función `polartorect' es la inversa de  `recttopolar'.


 -- Función: recttopolar (<real_array>, <imaginary_array>)
     Transforma valores complejos de la forma `a + b %i' a la forma `r
     %e^(%i t)'. La instrucción `load ("fft")' carga esta función en
     Maxima. Véase también `fft'.

     Las partes real e imaginaria, `a' y `b', se toman de <real_array>
     y <imaginary_array>, respectivamente. Los valores originales de
     los arreglos de entrada se reemplazan por el módulo y el
     argumento, `r' y `t'. Los resultados se calculan como

          r: sqrt (a^2 + b^2)
          t: atan2 (b, a)

     El ángulo calculado está en el rango entre `-%pi' y `%pi'.

     Los arreglos de entrada deben ser de igual tamaño y de dimensión
     1. El tamaño del arreglo no necesita ser potencia de 2.

     La función `recttopolar' es la inversa de `polartorect'.


 -- Función: ift (<real_array>, <imaginary_array>)
     Tranformada discreta inversa de Fourier. La instrucción `load
     ("fft")' carga esta función en Maxima.

     La función `ift' calcula la transformada rápida inversa compleja
     de Fourier de arreglos unidimensionales de números decimales en
     coma flotante. La transformada inversa se define como

          x[j]: sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Véase `fft' para más detalles.


 -- Función: fft (<real_array>, <imaginary_array>)
 -- Función: ift (<real_array>, <imaginary_array>)
 -- Función: recttopolar (<real_array>, <imaginary_array>)
 -- Función: polartorect (<magnitude_array>, <phase_array>)
     Transformada rápida de Fourier y funciones asociadas. La
     instrucción `load ("fft")' carga estas funciones en Maxima.

     Las funciones `fft' y `ift' calculan la transformada rápida
     compleja de Fourier y su inversa de arreglos unidimensionales de
     números decimales en coma flotante. El tamaño de <imaginary_array>
     debe ser igual al de <real_array>.

     Los resultados devueltos por las funciones `fft' y `ift'
     sustituyen al contenido original de los arreglos de entrada. La
     función `fillarray' puede hacer una copia de un array en caso de
     ser necesario.

     La transformada discreta de Fourier y la transformada inversa se
     definen como sigue. Sea `x' el arreglo con los datos originales,
     con

          x[i]: real_array[i] + %i imaginary_array[i]

     Sea `y' el arreglo con los datos transformados. Las transformadas
     directa e inversa son

          y[k]: (1/n) sum (x[j] exp (-2 %i %pi j k / n), j, 0, n-1)

          x[j]:       sum (y[j] exp (+2 %i %pi j k / n), k, 0, n-1)

     Arreglos apropiados se pueden preparar con la función `array'. Por
     ejemplo:

          array (my_array, float, n-1)$

     declara un arreglo unidimensional con `n' elementos, indexado de 0
     a n-1, ambos inclusive. El número de elementos, `n', debe ser par.

     La función `fft' se puede aplicar a datos reales (con partes
     imaginarias nulas) para obtener coeficientes seno y coseno.
     Después de llamar a la función `fft', los coeficientes del seno y
     coseno, llamémosles `a' y `b', se pueden calcular como

          a[0]: real_array[0]
          b[0]: 0

     y

          a[j]: real_array[j] + real_array[n-j]
          b[j]: imaginary_array[j] - imaginary_array[n-j]

     para j tomando valores de 1 a n/2-1, y

          a[n/2]: real_array[n/2]
          b[n/2]: 0

     La función `recttopolar' transforma valores complejos de la forma
     `a + b %i' a la forma `r %e^(%i t)'. Véase `recttopolar'.

     La función `polartorect' transforma valores complejos de la forma
     `r %e^(%i t)' a la forma `a + b %i'. Véase `polartorect'.

     La instrucción `demo ("fft")' presenta una demostarción del
     paquete `fft'.


 -- Variable opcional: fortindent
     Valor por defecto: 0

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.


 -- Función: fortran (<expr>)
     Escribe <expr> en código Fortran. La salida se escribe con
     márgenes, y si ésta es demasiado larga `fortran' sigue escribiendo
     en líneas sucesivas. La función `fortran' escribe el operador de
     exponenciación `^' como `**', e imprime un número complejo `a + b
     %i' como `(a,b)'.

     El argumento <expr> puede ser una ecuación. En tal caso, `fortran'
     escribe una sentencia de asignación, dándole el valor del miembro
     derecho de la expresión al miembro izquierdo. En particular, si el
     miembro derecho de <expr> es el nombre de una matriz, entonces
     `fortran' escribe una sentencia de asignación para cada elemento
     de la matriz.

     Si <expr> no es reconozida por `fortran', la expresión se escribe
     en formato `grind' sin avisos. La función `fortran' no reconoce
     listas, arreglos ni funciones.

     La variable `fortindent' controla el margen izquierdo de las
     expresiones que escribe la instrucción `fortran'.  El valor 0
     escribe con un margen normal de 6 espacios; valores positivos
     harán que las expresiones se escriban más a la derecha.

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.

     La función `fortran' evalúa sus argumentos; un argumento precedido
     de apóstrofo previene de la evaluación.  La función `fortran'
     siempre devuelve `done'.

     Ejemplos:

          (%i1) expr: (a + b)^12$
          (%i2) fortran (expr);
                (b+a)**12
          (%o2)                         done
          (%i3) fortran ('x=expr);
                x = (b+a)**12
          (%o3)                         done
          (%i4) fortran ('x=expand (expr));
                x = b**12+12*a*b**11+66*a**2*b**10+220*a**3*b**9+495*a**4*b**8+792
               1   *a**5*b**7+924*a**6*b**6+792*a**7*b**5+495*a**8*b**4+220*a**9*b
               2   **3+66*a**10*b**2+12*a**11*b+a**12
          (%o4)                         done
          (%i5) fortran ('x=7+5*%i);
                x = (7,5)
          (%o5)                         done
          (%i6) fortran ('x=[1,2,3,4]);
                x = [1,2,3,4]
          (%o6)                         done
          (%i7) f(x) := x^2$
          (%i8) fortran (f);
                f
          (%o8)                         done


 -- Variable opcional: fortspaces
     Valor por defecto: `false'

     Si `fortspaces' vale `true', `fortran' rellena las líneas con
     espacios de 80 columnas.


 -- Función: horner (<expr>, <x>)
 -- Función: horner (<expr>)
     Cambia el formato de <expr> según la regla de Horner utilizando
     <x> como variable principal, si ésta se especifica. El argumento
     `x' se puede omitir, en cuyo caso se considerará como variable
     principal la de <expr> en su formato racional canónico (CRE).

     La función `horner' puede mejorar las estabilidad si `expr' va a
     ser numéricamente evaluada. También es útil si Maxima se utiliza
     para generar programas que serán ejecutados en Fortran. Véase
     también `stringout'.

          (%i1) expr: 1e-155*x^2 - 5.5*x + 5.2e155;
                                     2
          (%o1)            1.0E-155 x  - 5.5 x + 5.2E+155
          (%i2) expr2: horner (%, x), keepfloat: true;
          (%o2)            (1.0E-155 x - 5.5) x + 5.2E+155
          (%i3) ev (expr, x=1e155);
          Maxima encountered a Lisp error:

           floating point overflow

          Automatically continuing.
          To reenable the Lisp debugger set *debugger-hook* to nil.
          (%i4) ev (expr2, x=1e155);
          (%o4)                       7.0E+154


 -- Función: find_root (<f>(<x>), <x>, <a>, <b>)
 -- Función: find_root (<f>, <a>, <b>)
     Calcula el cero de la función <f> cuando <x> varía en el rango
     `[<a>, <b>]'.  La función debe tener signos diferentes en los
     extremos del intervalo. Si esta condición no se cumple, la acción
     de esta función la gobierna la variable `find_root_error'.  Si
     `find_root_error' vale `true' entonces se emite un mensaje de
     error, en otro caso se devuelve el valor de `find_root_error'. En
     caso contrario, dado que Maxima pouede evaluar el primer argumento
     en el rango especificado, el cual es continuo, está garantizado
     que `find_root' encontrará el cero buscado (o uno de ellos en caso
     de haber varios). La precisión de `find_root' está gobernada por
     `find_root_abs' y `find_root_rel', que deben ser números no
     negativos en coma flotante. La función `find_root' se detendrá
     cuando el primer argumento tome un valor menor o igual que
     `find_root_abs', o cuando sucesivas aproximaciones de la raíz se
     diferencien en menos de `find_root_rel * <one of the
     approximants>'. El valor por defecto de `find_root_abs' y
     `find_root_rel' es 0.0 en ambos casos, de forma que `find_root'
     obtiene la mejor aproximación posible para la aritmética de simple
     precisión de que se dispone. El primer argumento puede ser una
     ecuación. La ordenación de los dos últimos argumentos es
     irrelevante. Así,

          find_root (sin(x) = x/2, x, %pi, 0.1);

     equivale a

          find_root (sin(x) = x/2, x, 0.1, %pi);

     El método que se aplica es una búsqueda binaria en el rango
     especificado por los dos últimos argumentos. Cuando el algoritmo
     considera que la función está lo suficientemente cerca de ser
     lineal, comienza a utilizar interpolación lineal.

     Ejemplos:

          (%i1) f(x) := sin(x) - x/2;
                                                  x
          (%o1)                  f(x) := sin(x) - -
                                                  2
          (%i2) find_root (sin(x) - x/2, x, 0.1, %pi);
          (%o2)                   1.895494267033981
          (%i3) find_root (sin(x) = x/2, x, 0.1, %pi);
          (%o3)                   1.895494267033981
          (%i4) find_root (f(x), x, 0.1, %pi);
          (%o4)                   1.895494267033981
          (%i5) find_root (f, 0.1, %pi);
          (%o5)                   1.895494267033981


 -- Variable opcional: find_root_abs
     Valor por defecto: 0.0

     La variable `find_root_abs' es la precisión de la instrucción
     `find_root', cuyo comportamiento lo controlan `find_root_abs' y
     `find_root_rel', variables que deben guardar dos números no
     negativos decimales en coma flotante.  La función `find_root'
     parará cuando su primer argumento tome un valor menor o igual que
     `find_root_abs' o si sucesivas aproximaciones a la raíz difieren
     entre sí en no más de `find_root_rel * <one of the approximants>'.
     El valor por defecto de `find_root_abs' y `find_root_rel' es 0.0
     en ambos casos, de forma que `find_root' obtiene la mejor
     aproximación posible para la aritmética de simple precisión de que
     se dispone.


 -- Variable opcional: find_root_error
     Valor por defecto: `true'

     La variable `find_root_error' controla el comportamiento de
     `find_root'.  Cuando se llama a la función `find_root', ésta
     determina si la función a ser resuelta satisface la condición de
     que sus valores en los extremos de los intervalos tengan signos
     diferentes. Si son de signo opuesto, se procede a la
     interpolación. Si son del mismo signo, y `find_root_error' vale
     `true', entonces se señala un error. Si son del mismo signo y
     `find_root_error' no vale `true', retornará el valor de
     `find_root_error'.


 -- Variable opcional: find_root_rel
     Valor por defecto: 0.0

     La variable `find_root_rel' es la precisión de la instrucción
     `find_root', cuyo comportamiento lo controlan `find_root_abs' y
     `find_root_rel', variables que deben guardar dos números no
     negativos decimales en coma flotante.  La función `find_root'
     parará cuando su primer argumento tome un valor menor o igual que
     `find_root_abs' o si sucesivas aproximaciones a la raíz difieren
     entre sí en no más de `find_root_rel * <one of the approximants>'.
     El valor por defecto de `find_root_abs' y `find_root_rel' es 0.0
     en ambos casos, de forma que `find_root' obtiene la mejor
     aproximación posible para la aritmética de simple precisión de que
     se dispone.



File: maxima.info,  Node: Definiciones para las series de Fourier,  Prev: Definiciones para los métodos numéricos,  Up: Métodos numéricos

23.4 Definiciones para las series de Fourier
============================================

 -- Función: equalp (<x>, <y>)
     Devuelve `true' si `equal (<x>, <y>)', en otro caso devuelve
     `false'. No devuelve el mensaje de error que se obtiene de  `equal
     (x, y)' en un caso como éste.


 -- Función: remfun (<f>, <expr>)
 -- Función: remfun (<f>, <expr>, <x>)
     La llamada `remfun (<f>, <expr>)' reemplaza todas las
     subexpresiones `<f> (<arg>)' por <arg> en <expr>.

     La llamada `remfun (<f>, <expr>, <x>)' reemplaza todas las
     subexpresiones `<f> (<arg>)' por <arg> en <expr> sólo si <arg>
     contiene a la variable <x>.


 -- Función: funp (<f>, <expr>)
 -- Función: funp (<f>, <expr>, <x>)
     La llamada `funp (<f>, <expr>)' devuelve `true' si <expr> contiene
     la función <f>.

     La llamada `funp (<f>, <expr>, <x>)' devuelve `true' si <expr>
     contiene la función <f> y la variable <x> está presente en el
     argumento de alguna de las presencias de <f>.


 -- Función: absint (<f>, <x>, <halfplane>)
 -- Función: absint (<f>, <x>)
 -- Función: absint (<f>, <x>, <a>, <b>)
     La llamada `absint (<f>, <x>, <halfplane>)' devuelve la integral
     indefinida de <f> con respecto a <x> en el semiplano dado (`pos',
     `neg' o `both'). La función <f> puede contener expresiones de la
     forma `abs (x)', `abs (sin (x))', `abs (a) * exp (-abs (b) * abs
     (x))'.

     La llamada `absint (<f>, <x>)' equivale a `absint (<f>, <x>, pos)'.

     La llamada `absint (<f>, <x>, <a>, <b>)' devuelve la integral
     definida de <f> con respecto a  <x> de <a> a <b>.


 -- Función: fourier (<f>, <x>, <p>)
     Devuelve una lista con los coeficientes de Fourier de `<f>(<x>)'
     definida en el intervalo `[-%pi, %pi]'.


 -- Función: foursimp (<l>)
     Simplifica `sin (n %pi)' a 0 si `sinnpiflag' vale `true' y `cos (n
     %pi)' a `(-1)^n' si `cosnpiflag' vale `true'.


 -- Variable opcional: sinnpiflag
     Valor por defecto: `true'

     Véase `foursimp'.


 -- Variable opcional: cosnpiflag
     Valor por defecto: `true'

     Véase `foursimp'.


 -- Función: fourexpand (<l>, <x>, <p>, <limit>)
     Calcula y devuelve la serie de Fourier a partir de la lista de los
     coeficientes de Fourier <l> hasta el término <limit> (<limit>
     puede ser `inf'). Los argumentos <x> y <p> tienen el mismo
     significado que en `fourier'.


 -- Función: fourcos (<f>, <x>, <p>)
     Devuelve los coeficientes de los cosenos de Fourier de `<f>(<x>)'
     definida en `[0, %pi]'.


 -- Función: foursin (<f>, <x>, <p>)
     Devuelve los coeficientes de los senos de Fourier de `<f>(<x>)'
     definida en `[0, %pi]'.


 -- Función: totalfourier (<f>, <x>, <p>)
     Devuelve `fourexpand (foursimp (fourier (<f>, <x>, <p>)), <x>,
     <p>, 'inf)'.


 -- Función: fourint (<f>, <x>)
     Calcula y devuelve la lista de los coeficientes integrales de
     Fourier de `<f>(<x>)' definida en `[minf, inf]'.


 -- Función: fourintcos (<f>, <x>)
     Devuelve los coeficientes integrales de los cosenos  `<f>(<x>)' en
     `[0, inf]'.


 -- Función: fourintsin (<f>, <x>)
     Devuelve los coeficientes integrales de los senos  `<f>(<x>)' en
     `[0, inf]'.



File: maxima.info,  Node: Estadística,  Next: Arreglos y Tablas,  Prev: Métodos numéricos,  Up: Top

24 Estadística
**************

* Menu:

* Definiciones para Estadística::


File: maxima.info,  Node: Definiciones para Estadística,  Prev: Estadística,  Up: Estadística

24.1 Definiciones para Estadística
==================================

 -- Función: gauss (<n>, <s>)
     Devuelve un número decimal seudoaleatorio en coma flotante con
     distribución normal de media <n> y desviación típica <s>.



File: maxima.info,  Node: Arreglos y Tablas,  Next: Matrices y Álgebra Lineal,  Prev: Estadística,  Up: Top

25 Tablas y Arreglos
********************

* Menu:

* Definiciones para Arreglos y Tablas::


File: maxima.info,  Node: Definiciones para Arreglos y Tablas,  Prev: Arreglos y Tablas,  Up: Arreglos y Tablas

25.1 Definiciones para Arreglos y Tablas
========================================

 -- Función: array (<nombre>, <dim_1>, ..., <dim_n>)
 -- Función: array (<nombre>, <type>, <dim_1>, ..., <dim_n>)
 -- Función: array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
          <dim_n>)
     Crea un arreglo de dimensión n, que debe ser menor o igual que 5.
     Los subíndices de la i-ésima dimensión son enteros que toman
     valores entre 0 y <dim_i>.

     La llamada `array (<nombre>, <dim_1>, ..., <dim_n>)' crea un
     arreglo de tipo general.

     La llamada `array (<nombre>, <type>, <dim_1>, ..., <dim_n>)' crea
     un arreglo con sus elementos del tipo especificado. El tipo <type>
     puede ser `fixnum' para enteros de tamaño limitado o `flonum' para
     números decimales en coma flotante.

     La llamada `array ([<nombre_1>, ..., <nombre_m>], <dim_1>, ...,
     <dim_n>)' crea m arreglos,  todos ellos de igual dimensión.

     Si el usuario asigna un valor a una variable subindicada antes de
     declarar el arreglo correspondiente, entonces se construye un
     arreglo no declarado. Los arreglos no declarados, también
     conocidos por el nombre de "arreglos de claves" (hashed arrays),
     son más generales que los arreglos declarados. El usuario no
     necesita declarar su tamaño máximo y pueden ir creciendo de forma
     dinámica. Los subíndices de los arreglos no declarados no
     necesitan ser necesariamente números. Sin embargo, a menos que un
     arreglo tenga sus elementos dispersos, probablemente sea más
     eficiente declararlo siempre que sea posible antes que dejarlo
     como no declarado. La función `array' puede utilizarse para
     transformar un arreglo no declarado a a uno declarado.


 -- Función: arrayapply (<A>, [<i_1>, ..., <i_n>])
     Evalúa `<A> [<i_1>, ..., <i_n>]', donde <A> es un arreglo y <i_1>,
     ..., <i_n> son enteros.

     Esto es como `apply', excepto por el hecho de que el primer
     argumento es un arreglo en lugar de una función.


 -- Función: arrayinfo (<A>)
     Devuelve una lista con información sobre el arreglo <A>. Para
     arreglos de claves (hashed arrays) devuelve una lista `hashed', el
     número de subíndices y los subíndices de aquellos elementos que
     tengan valor. Para arreglos declarados devuelve una lista
     `declared', el número de subíndices y los valores dados a la
     función `array' cuando fue invocada para crear <A>.  Hágase
     `example(arrayinfo);' para ver un ejemplo.


 -- Función: arraymake (<name>, [<i_1>, ..., <i_n>])
     Devuelve la expresión `<name> [<i_1>, ..., <i_n>]'.

     Esta función es similar a `funmake', excepto que el valor
     retornado es referencia a un arreglo no evaluado, en lugar de una
     llamada a una función no evaluada.


 -- Variable del sistema: arrays
     Valor por defecto: `[]'

     La variable `arrays' es una lista con todos los arreglos que han
     sido alojados, hayan sido declarados o no.

     Véanse también `array', `arrayapply', `arrayinfo', `arraymake',
     `fillarray', `listarray' y `rearray'.


 -- Función: bashindices (<expr>)
     Transforma la expresión <expr> dándole a cada suma y producto un
     único índice. Esto le da a `changevar' mayor precisión cuando
     opera con sumas y productos. La forma del único índice es
     `j<number>'. La cantidad <number> se determina en función de
     `gensumnum', valor que puede cambiar el usuario.  Por ejemplo,
     haciendo `gensumnum:0$'.


 -- Función: fillarray (<A>, <B>)
     Rellena el arreglo <A> con los valores de <B>, que puede ser una
     lista o arreglo.

     Si <A> es un array de números decimales en coma flotante (enteros)
     entonces <B> debe ser o bien una lista de números decimales en
     coma flotante  (enteros), o bien otro arreglo de números en coma
     flotante (enteros).

     Si las dimensiones de los areglos son diferentes, <A> se rellena
     según el orden de las filas. Si no hay suficientes elementos en
     <B> el último elemento se utiliza para cubrir el resto de <A>. Si
     hay demasiados, los elementos sobrantes son ignorados.

     La función `fillarray' devuelve su primer argumento.


 -- Función: listarray (<A>)
     Devuelve una lista con los elementos del arreglo declarado o tabla
     de claves <A>, en el orden de las filas. Los elementos que todavía
     no han sido declarados se representan mediante `#####'.


 -- Función: make_array (<tipo>, <dim_1>, ..., <dim_n>)
     Construye y devuelve un arreglo de Lisp. El argumento <tipo> puede
     ser  `any', `flonum', `fixnum', `hashed' o `functional'. Hay n
     índices, y el índice i-ésimo va de  0 a <dim_i> - 1.

     La ventaja de `make_array' sobre `array' estriba en que el valor
     retornado no tiene nombre, y una vez que un puntero deja de
     referenciarlo, el valor desaparece. Por ejemplo, si `y: make_array
     (...)' entonces `y' apunta a un objeto que ocupa cierto espacio en
     la memoria, pero después de `y: false', `y' ya no apunta al
     objeto, por lo que éste puede ser considerado basura y
     posteriormente eliminado.

     En la instrucción `y: make_array ('functional, 'f, 'hashed, 1)' el
     segundo argumento de `make_array'  es la función que se debe
     invocar para calcular los elementos del arreglo, pasándose
     recursivamente a `make_array' el resto de los argumentos para
     generar la "memoria" de la función arreglo.


 -- Función: rearray (<A>, <dim_1>, ..., <dim_n>)
     Cambia las dimensiones de un arreglo. El nuevo arreglo será
     rellenado con los elementos del viejo según el orden de las filas.
     Si el arreglo antiguo era demasiado pequeño, los elementos
     restantes se rellenan con `false', `0.0' o `0', dependiendo del
     tipo del arreglo. El tipo del arreglo no se puede cambiar.


 -- Función: remarray (<A_1>, ..., <A_n>)
 -- Función: remarray (all)
     Borra los arreglos y las funciones relacionadas con ellos,
     liberando el espacio de memoria ocupado.

     La llamada `remarray (all)' borra todos los elementos de la lista
     global `arrays'.

     La función `remarray' devuelve la lista de los arreglos borrados.


 -- Función: subvar (<x>, <i>)
     Evalúa la expresión subindicada `<x>[<i>]'.

     La función `subvar' evalúa sus argumentos.

     La instrucción `arraymake (<x>, [<i>]' construye la expresión
     `<x>[<i>]', pero no la evalúa.

     Ejemplos:

          (%i1) x : foo $

          (%i2) i : 3 $

          (%i3) subvar (x, i);
          (%o3)                         foo
                                           3
          (%i4) foo : [aa, bb, cc, dd, ee]$

          (%i5) subvar (x, i);
          (%o5)                          cc
          (%i6) arraymake (x, [i]);
          (%o6)                         foo
                                           3
          (%i7) ''%;
          (%o7)                          cc


 -- Variable opcional: use_fast_arrays
     Valor por defecto: `false'

     Si `use_fast_arrays' vale `true' entonces tan solo se reconocen
     dos tipos de arreglos.



File: maxima.info,  Node: Matrices y Álgebra Lineal,  Next: Afines,  Prev: Arreglos y Tablas,  Up: Top

26 Matrices y Álgebra Lineal
****************************

* Menu:

* Introducción a las Matrices y al Álgebra Lineal::
* Definiciones para las Matrices y el Álgebra Lineal::


File: maxima.info,  Node: Introducción a las Matrices y al Álgebra Lineal,  Next: Definiciones para las Matrices y el Álgebra Lineal,  Prev: Matrices y Álgebra Lineal,  Up: Matrices y Álgebra Lineal

26.1 Introducción a las Matrices y al Álgebra Lineal
====================================================

* Menu:

* Operador punto::
* Vectores::
* Paquete eigen::


File: maxima.info,  Node: Operador punto,  Next: Vectores,  Prev: Introducción a las Matrices y al Álgebra Lineal,  Up: Introducción a las Matrices y al Álgebra Lineal

26.1.1 Operador punto
---------------------

El operador  `.' realiza la multiplicación matricial y el producto
escalar.  Cuando los operandos son dos matrices columna o matrices fila
`a' y `b', la expresión `a.b' es equivalente a `sum (a[i]*b[i], i, 1,
length(a))'.  Si `a' y `b' no son complejos, estamos en el caso del
producto escalar.  En caso de ser `a' y `b' vectores en el campo
complejo, el producto escalar se define como `conjugate(a).b'; la
función `innerproduct' del paquete `eigen' realiza el producto escalar
complejo.

   Cuando los operandos son matrices de índole más general, el
resultado que se obtiene es el producto matricial de `a' por `b'.  El
número de filas de `b' debe ser igual al número de columnas de `a', y
el resultado tiene un número de filas igual al de `a' y un número de
columnas igual al de `b'.

   Al objeto de distinguir `.' como operador aritmético del punto
decimal de la notación en coma flotante, puede ser necesario dejar
espacios a ambos lados.  Por ejemplo, `5.e3' es `5000.0' pero `5 . e3'
es `5' por `e3'.

   Hay algunas variables globales que controlan la simplificación de
expresiones que contengan al operador `.', a saber, `dot',
`dot0nscsimp', `dot0simp', `dot1simp', `dotassoc', `dotconstrules',
`dotdistrib', `dotexptsimp', `dotident', y `dotscrules'.


File: maxima.info,  Node: Vectores,  Next: Paquete eigen,  Prev: Operador punto,  Up: Introducción a las Matrices y al Álgebra Lineal

26.1.2 Vectores
---------------

El paquete `vect' define funciones para análisis vectorial. Para cargar
el paquete en memoria se debe hacer `load ("vect")'  y con `demo
("vect")' se presenta una demostración sobre las funciones del paquete.

   El paquete de análisis vectorial puede combinar y simplificar
expresiones simbólicas que incluyan productos escalares y vectoriales,
junto con los operadores de gradiente, divergencia, rotacional y
laplaciano. La distribución de estos operadores sobre sumas o productos
se gobierna por ciertas variables, al igual que otras transformaciones,
incluida la expansión en componentes en cualquier sistema de
coordenadas especificado.  También hay funciones para obtener el
potencial escalar o vectorial de un campo.

   El paquete `vect' contiene las siguientes funciones: `vectorsimp',
`scalefactors', `express', `potential' y `vectorpotential'.

   Aviso: el paquete `vect' declara el operador `.' como conmutativo.


File: maxima.info,  Node: Paquete eigen,  Prev: Vectores,  Up: Introducción a las Matrices y al Álgebra Lineal

26.1.3 Paquete eigen
--------------------

El paquete `eigen' contiene funciones para el cálculo simbólico de
valores y vectores propios. Maxima carga el paquete automáticamente si
se hace una llamada a cualquiera de las dos funciones `eigenvalues' o
`eigenvectors'. El paquete se puede cargar de forma explícita mediante
`load ("eigen")'.

   La instrucción `demo ("eigen")' hace una demostración de las
funciones de este paquete; `batch ("eigen")' realiza la misma
demostración pero sin pausas entre los sucesivos cálculos.

   Las funciones del paquete `eigen' son `innerproduct', `unitvector',
`columnvector', `gramschmidt', `eigenvalues', `eigenvectors',
`uniteigenvectors' y `similaritytransform'.



Local Variables:
coding: iso-8859-1
End:
