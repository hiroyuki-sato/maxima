This is maxima.info, produced by makeinfo version 4.7 from maxima.texi.

   Este es el Manual de Maxima en versión Texinfo

   Copyright 1994, 2001 William F. Schelter

START-INFO-DIR-ENTRY
* Maxima: (maxima).  Un sistema de cálculo simbólico
END-INFO-DIR-ENTRY


File: maxima.info,  Node: Definiciones para polinomios ortogonales,  Prev: Introducción a polinomios ortogonales,  Up: orthopoly

61.2 Definiciones para polinomios ortogonales
=============================================

 -- Función: assoc_legendre_p (<n>, <m>, <x>)
     Función asociada de Legendre de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.37, página 779,
     8.6.6 (segunda ecuación), página 334 y  8.2.5, página 333.

 -- Función: assoc_legendre_q (<n>, <m>, <x>)
     Función asociada de Legendre de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 8.5.3 y 8.1.8.

 -- Función: chebyshev_t (<n>, <x>)
     Función de Chebyshev de primera especie.

     Referencia: Abramowitz y Stegun, ecuación 22.5.47, página 779.

 -- Función: chebyshev_u (<n>, <x>)
     Función de Chebyshev de segunda especie.

     Referencia: Abramowitz y Stegun, ecuación 22.5.48, página 779.

 -- Función: gen_laguerre (<n>, <a>, <x>)
     Polinomio de Laguerre generalizado.

     Referencia: Abramowitz y Stegun, ecuación 22.5.54, página 780.

 -- Función: hermite (<n>, <x>)
     Polinomio de Hermite.

     Referencia: Abramowitz y Stegun, ecuación 22.5.55, página 780.

 -- Función: intervalp (<e>)
     Devuelve `true' si la entrada es un intervalo y `false' en caso
     contrario.

 -- Función: jacobi_p (<n>, <a>, <b>, <x>)
     Polinomio de Jacobi.

     Los polinomios de Jacobi están definidos para todo <a> y <b>; sin
     embargo, el peso `(1 - <x>)^<a> (1 + <x>)^<b>' no es integrable
     para `<a> <= -1' o `<b> <= -1'.

     Referencia: Abramowitz y Stegun, ecuación 22.5.42, página 779.

 -- Función: laguerre (<n>, <x>)
     Polinomio de Laguerre.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.16 y 22.5.54,
     página 780.

 -- Función: legendre_p (<n>, <x>)
     Polinomio de Legendre de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 22.5.50 y 22.5.51,
     página 779.

 -- Función: legendre_q (<n>, <x>)
     Polinomio de Legendre de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 8.5.3 y 8.1.8.

 -- Función: orthopoly_recur (<f>, <args>)
     Devuelve una relación recursiva para la familia de funciones
     ortogonales <f> con argumentos <args>. La recursión se hace con
     respecto al grado del polinomio.

          (%i1) orthopoly_recur (legendre_p, [n, x]);
                          (2 n - 1) P     (x) x + (1 - n) P     (x)
                                     n - 1                 n - 2
          (%o1)   P (x) = -----------------------------------------
                   n                          n

     El segundo argumento de `orthopoly_recur' debe ser una lista con
     el número correcto de argumentos para la función <f>; si no lo es,
     Maxima emite un mensaje de error.

          (%i1) orthopoly_recur (jacobi_p, [n, x]);

          Function jacobi_p needs 4 arguments, instead it received 2
           -- an error.  Quitting.  To debug this try debugmode(true);

     Además, si <f> no es el nombre de ninguna de las familias de
     polinomios ortogonales, se emite otro mensaje de error.

          (%i1) orthopoly_recur (foo, [n, x]);

          A recursion relation for foo isn't known to Maxima
           -- an error.  Quitting.  To debug this try debugmode(true);

 -- Variable opcional: orthopoly_returns_intervals
     Valor por defecto: `true'

     Si `orthopoly_returns_intervals' vale `true', los números
     decimales en coma flotante se retornan con el formato `interval
     (<c>, <r>)', donde <c> es el centro del intervalo y <r> su radio.
     El centro puede ser un número complejo, en cuyo caso el intervalo
     es un disco en el plano complejo.

 -- Función: orthopoly_weight (<f>, <args>)
     Devuelve una lista con tres elementos; el primer elemento es la
     fórmula del peso para la familia de polinomios ortogonales <f> con
     los argumentos dados por la lista <args>; el segundo y tercer
     elementos son los extremos inferior y superior del intervalo de
     ortogonalidad. Por ejemplo,

          (%i1) w : orthopoly_weight (hermite, [n, x]);
                                      2
                                   - x
          (%o1)                 [%e    , - inf, inf]
          (%i2) integrate (w[1] * hermite (3, x) * hermite (2, x), x, w[2], w[3]);
          (%o2)                           0

     La variable principal de <f> debe ser un símbolo, en caso
     contrario Maxima emite un mensaje de error.

 -- Función: pochhammer (<n>, <x>)
     Símbolo de Pochhammer. Para enteros no negativos <n> con `<n> <=
     pochhammer_max_index', la expresión `pochhammer (<x>, <n>)' se
     evalúa como el producto `<x> (<x> + 1) (<x> + 2) ... (<x> + n -
     1)' si `<n> > 0' y como 1 si `<n> = 0'. Para <n> negativo,
     `pochhammer (<x>, <n>)' se define como `(-1)^<n> / pochhammer (1 -
     <x>, -<n>)'.  Así por ejemplo,

          (%i1) pochhammer (x, 3);
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, -3);
                                           1
          (%o2)               - -----------------------
                                (1 - x) (2 - x) (3 - x)

     A fin de convertir el símbolo de Pochhammer en un cociente de
     funciones gamma (véase Abramowitz y Stegun, ecuación 6.1.22),
     hágase uso de `makegamma'. Por ejemplo,

          (%i1) makegamma (pochhammer (x, n));
                                    gamma(x + n)
          (%o1)                     ------------
                                      gamma(x)

     Si <n> es mayor que `pochhammer_max_index' o si <n> es simbólico,
     `pochhammer' devuelve una forma nominal.

          (%i1) pochhammer (x, n);
          (%o1)                         (x)
                                           n

 -- Variable opcional: pochhammer_max_index
     Valor por defecto: 100

     `pochhammer (<n>, <x>)' se evalúa como un producto si y sólo si
     `<n> <= pochhammer_max_index'.

     Ejemplos:

          (%i1) pochhammer (x, 3), pochhammer_max_index : 3;
          (%o1)                   x (x + 1) (x + 2)
          (%i2) pochhammer (x, 4), pochhammer_max_index : 3;
          (%o2)                         (x)
                                           4

     Referencia: Abramowitz y Stegun, ecuación 6.1.16, página 256.

 -- Función: spherical_bessel_j (<n>, <x>)
     Función de Bessel esférica de primera especie.

     Referencia: Abramowitz y Stegun, ecuaciones 10.1.8, página 437 y
     10.1.15, página 439.

 -- Función: spherical_bessel_y (<n>, <x>)
     Función de Bessel esférica de segunda especie.

     Referencia: Abramowitz y Stegun, ecuaciones 10.1.9, página 437 y
     10.1.15, página 439.

 -- Función: spherical_hankel1 (<n>, <x>)
     Función esférica de Hankel de primera especie.

     Referencia: Abramowitz y Stegun, ecuación 10.1.36, página 439.

 -- Función: spherical_hankel2 (<n>, <x>)
     Función esférica de Hankel de segunda especie.

     Referencia: Abramowitz y Stegun, ecuación 10.1.17, página 439.

 -- Función: spherical_harmonic (<n>, <m>, <x>, <y>)
     Función armónica esférica.

     Referencia: Merzbacher 9.64.

 -- Función: unit_step (<x>)
     Función de escalón unidad continua por la izquierda, definida de
     tal forma que `unit_step (<x>)' se anula para `<x> <= 0' y es
     igual a 1 para `<x> > 0'.

     En caso de ser necesaria una función escalón unidad que tome el
     valor 1/2 en el origen, utilícese `(1 + signum (<x>))/2'.

 -- Función: ultraspherical (<n>, <a>, <x>)
     Polinomio ultraesférico o de Gegenbauer.

     Referencia: Abramowitz y Stegun, ecuación 22.5.46, página 779.


File: maxima.info,  Node: plotdf,  Next: simplex,  Prev: orthopoly,  Up: Top

62 plotdf
*********

* Menu:

* Introducción a plotdf::
* Definiciones para plotdf::


File: maxima.info,  Node: Introducción a plotdf,  Next: Definiciones para plotdf,  Prev: plotdf,  Up: plotdf

62.1 Introducción a plotdf
==========================

La función `plotdf' crea un gráfico del campo de direcciones para una
Ecuación Diferencial Ordinaria (EDO) de primer orden, o para un sistema
de dos EDO's autónomas, de primer orden.

   Para dibujar el campo de direcciones de una única EDO, esa ecución
deberá escribirse en la forma siguiente:
            dy
            -- = F(x,y)
            dx

   y la función <F> será dada como argumento para el comando `plotdf'.
La variable independiente tiene que ser siempre <x> y la variable
dependiente <y>. A esas dos variables no podrá estar asociado ningún
valor numérico.

   Para dibujar el campo de direcciones de un sistema autónomo de dos
EDO's, Las dos ecuaciones deben ser escritas en la forma siguiente
            dx             dy
            -- = G(x,y)    -- = F(x,y)
            dt             dt

   y el argumento para el comando `plotdf' será una lista con dos
expresiones para las funciones <F> y <G>.

   Cuando se trabaja con una única ecuación, `plotdf' asume
implícitamente que `x=t' y `G(x,y)=1', transformando la ecuación en un
sistema autónomo con dos ecuaciones.


File: maxima.info,  Node: Definiciones para plotdf,  Prev: Introducción a plotdf,  Up: plotdf

62.2 Definiciones para plotdf
=============================

 -- Function: plotdf (<dydx>,...opciones...)
 -- Function: plotdf (`['<dxdt>,<dydt>`]',...opciones...)
     Dibuja un campo de direcciones en dos dimensiones <x> and <y>.

     <dydx>, <dxdt> y <dydt> son expresiones que dependen de <x> y <y>.
     Además de esas dos variables, las dos expresiones pueden depender
     de un conjunto de parámetros, con valores numéricos que son dados
     por medio de la opción `parameters' (la sintaxis de esa opción se
     explica mas al frente), o con un rango de posibles valores
     definidos con la opción <sliders>.

     Varias otras opciones se pueden incluir dentro del comando, o en
     el menú que aparece cuando se hace click en la esquina superior
     izquierda de la ventana del gráfico. Haciendo click en un punto
     del gráfico se puede hacer que sea dibujada la curva integral que
     pasa por ese punto; lo mismo puede ser hecho dando las coordenadas
     del punto con la opción `trajectory_at' dentro del comando plotdf.
     La dirección de integración se puede controlar con la opción
     `direction', que acepta valores de "forward", "backward" o "both".
     El número de pasos realizado en la integración numérica se
     controla con la opción `nsteps' y el incremento del tiempo en cada
     paso con la opción `tstep'. Se usa el método de Adams Moulton para
     hacer la integración numérica; también es posible cambiar para el
     método de Runge-Kutta de cuarto orden con ajuste de pasos.

     Menú de la ventana del gráfico:

     El menú de la ventana gráfica dispone de las siguientes opciones:
     "Zoom", que permite cambiar el comportamiento del ratón, de manera
     que hará posible el hacer zoom en la región del gráfico haciendo
     clic con el botón izquierdo. Cada clic agranda la imagen
     manteniendo como centro de la misma el punto sobre el cual se ha
     hecho clic. Manteniendo pulsada la tecla SHIFT mientras se hace
     clic, retrocede al tamaño anterior. Para reanudar el cálculo de
     las trayectorias cuando se hace clic, selecciónese la opción
     "Integrate" del menú.

     La opción "Config" del menú se puede utilizar para cambiar la(s)
     EDO(S) y algunos otros ajustes. Después de hacer los cambios, se
     debe utilizar la opción "Replot" para activar los nuevos ajustes.
     Si en el campo "Trajectory at" del menú de diálogo de "Config" se
     introducen un par de coordenadas y luego se pulsa la tecla
     "retorno", se mostrará una nueva curva integral, además de las ya
     dibujadas.  Si se selecciona la opción "Replot", sólo se mostrará
     la última curva integral seleccionada.

     Manteniendo pulsado el botón derecho del ratón mientras se mueve
     el cursor, se puede arrastrar el gráfico horizontal y
     verticalmente.  Otros parámetros, como pueden ser el número de
     pasos, el valor inicial de <t>, las coordenadas del centro y el
     radio, pueden cambiarse en el submenú de la opción "Config".

     Con la opción "Save", se puede obtener una copia del gráfico en una
     impresora Postscript o guardarlo en un fichero Postscript. Para
     optar entre la impresión o guardar en fichero, se debe seleccionar
     "Print Options" en la ventana de diálogo de "Config". Una vez
     cubiertos los campos de la ventana de diálogo de "Save", será
     necesario seleccionar la opción "Save" del primer menú para crear
     el fichero o imprimir el gráfico.

     Opciones gráficas:

     La función `plotdf' admite varias opciones, cada una de las cuales
     es una lista de dos o más elementos. El primer elemento es el
     nombre de la opción, y el resto está formado por el valor o
     valores asignados a dicha opción.

     La función `plotdf' reconoce las siguientes opciones:

        * Opción: `tstep' establece la amplitud de los incrementos en la
          variable independiente <t>, utilizados para calcular la curva
          integral. Si se sólo se aporta una expresión <dydx>, la
          variable <x> será directamente proporcional a <t>: `x -
          xinitial = t - tinitial'.
               [tstep,0.01]
          El valor por defecto es 0.1.

        * Opción: `nsteps' establece el número de pasos de longitud
          `tstep' que se utilizarán en la variable independiente para
          calcular la curva integral.
               [nsteps,500]
          El valor por defecto es 100.

        * Opción: `direction' establece la dirección de la variable
          independiente que será seguida para calcular una curva
          integral.  Valores posibles son: `forward', para hacer que la
          variable independiente aumente `nsteps' veces, con
          incrementos `tstep'; `backward', para hacer que la variable
          independiente disminuya; `both', para extender la curva
          integral `nsteps' pasos hacia adelante y `nsteps' pasos hacia
          atrás.  Las palabras `right' y `left' se pueden utilizar como
          sinónimos de `forward' y `backward'.
               [direction,forward]
          El valor por defecto es `both'.

        * Opción: `tinitial' establece el valor inicial de la variable
          <t> utilizado para calcular curvas integrales. Puesto que las
          ecuaciones diferenciales son autónomas, esta opción sólo
          aparecerá en los gráficos de las curvas como funciones de <t>.
               [tinitial,6.7]
          El valor por defecto es 0.

        * Opción: `versus_t' se utiliza para crear una segunda ventana
          gráfica, con el gráfico de una curva integral, como dos
          funciones <x>, <y>, de variable independiente <t>. Si se le
          da a `versus_t' cualquier valor diferente de 0, se mostrará la
          segunda ventana gráfica, la cual incluye otro menú, similar
          al de la ventana principal.
               [versus_t,1]
          El valor por defecto es 0.

        * Opción: `trajectory_at' establece las coordenadas <xinitial>
          y <yinitial> para el extremo inicial de la curva integral.
               [trajectory_at,0.1,3.2]
          No tiene asignado valor por defecto.

        * Opción: `parameters' establece una lista de parámetros, junto
          con sus valores numéricos, que son utilizados en la
          definición de la ecuación diferencial. Los nombres de los
          parámetros y sus valores deben escribirse en formato de cadena
          de caracteres como una secuencia de pares `nombre=valor'
          separados por comas.
               [parameters,"k=1.1,m=2.5"]

        * Opción: `sliders' establece una lista de parámetros que se
          cambiarán interactivamente utilizando barras de deslizamiento,
          así como los rangos de variación de dichos parámetros.  Los
          nombres de los parámetros y sus rangos deben escribirse en
          formato de cadena de caracteres como una secuencia de pares
          `nombre=min:max' separados por comas.
               [sliders,"k=0:4,m=1:3"]

        * Opción: `xfun' establece una cadena de caracteres con
          funciones de <x> separadas por puntos y comas para ser
          representadas por encima del campo de direcciones. Estas
          funciones serán interpretadas por Tcl, no por Maxima.
               [xfun,"x^2;sin(x);exp(x)"]

        * Opción: `xradius' es la mitad de la longitud del rango de
          valores a representar en la dirección x.
               [xradius,12.5]
          El valor por defecto es 10.

        * Opción: `yradius' es la mitad de la longitud del rango de
          valores a representar en la dirección y.
               [yradius,15]
          El valor por defecto es 10.

        * Opción: `xcenter' es la coordenada x del punto situado en el
          centro del gráfico.
               [xcenter,3.45]
          El valor por defecto es 0.

        * Opción: `ycenter' es la coordenada y del punto situado en el
          centro del gráfico.
               [ycenter,4.5]
          El valor por defecto es 0.

        * Opción: `width' establece el ancho de la ventana gráfica en
          píxeles.
               [width,800]
          El valor por defecto es 500.

        * Opción: `height' establece la altura de la ventana gráfica en
          píxeles.
               [width,600]
          El valor por defecto es 500.


     Ejemplos:

     NOTA: debido a un fallo en `openmath', todas las funciones,
     incluida `plotdf', deben terminar en punto y coma, no con el
     símbolo de dólar, el cual puede ser válido en otros contextos
     gráficos; para evitar problemas, se usará el punto y coma en los
     ejemplos.

        * Para mostrar el campo de direcciones de la ecuación
          diferencial y' = exp(-x) + y y la solución que pasa por (2,
          -0.1):
               (%i1) load("plotdf")$

               (%i2) plotdf(exp(-x)+y,[trajectory_at,2,-0.1]);

        * Para mostrar el campo de direcciones de la ecuación diff(y,x)
          = x - y^2 y la solución de condición inicial y(-1) = 3, se
          puede utilizar la sentencia:
               (%i3) plotdf(x-y^2,[xfun,"sqrt(x);-sqrt(x)"],
                         [trajectory_at,-1,3], [direction,forward],
                         [yradius,5],[xcenter,6]);
          El gráfico también muestra la función y = sqrt(x).

        * El siguiente ejemplo muestra el campo de direcciones de un
          oscilador armónico, definido por las ecuaciones dx/dt = y y
          dy/dt = -k*x/m, y la curva integral que pasa por (x,y) =
          (6,0), con una barra de deslizamiento que permitirá cambiar
          el valor de m interactivamente (k está permanece fijo a 2):
               (%i4) plotdf([y,-k*x/m],[parameters,"m=2,k=2"],
                           [sliders,"m=1:5"], [trajectory_at,6,0]);

        * Para representar el campo de direcciones de la ecuación de
          Duffing, m*x"+c*x'+k*x+b*x^3 = 0, se introduce la variable
          y=x' y se hace:
               (%i5) plotdf([y,-(k*x + c*y + b*x^3)/m],
                             [parameters,"k=-1,m=1.0,c=0,b=1"],
                             [sliders,"k=-2:2,m=-1:1"],[tstep,0.1]);

        * El campo de direcciones de un péndulo amortiguado, incluyendo
          la solución para condiciones iniciales dadas, con una barra
          de deslizamiento que se puede utilizar para cambiar el valor
          de la masa, m, y con el gráfico de las dos variables de
          estado como funciones del tiempo:

               (%i6) plotdf([y,-g*sin(x)/l - b*y/m/l],
                        [parameters,"g=9.8,l=0.5,m=0.3,b=0.05"],
                        [trajectory_at,1.05,-9],[tstep,0.01],
                        [xradius,6],[yradius,14],
                        [xcenter,-4],[direction,forward],[nsteps,300],
                        [sliders,"m=0.1:1"], [versus_t,1]);


     Para hacer uso de esta función, ejecútese primero `load("plotdf")'.


File: maxima.info,  Node: simplex,  Next: simplification,  Prev: plotdf,  Up: Top

63 simplex
**********

* Menu:

* Introducción a simplex::
* Definiciones para simplex::


File: maxima.info,  Node: Introducción a simplex,  Next: Definiciones para simplex,  Prev: simplex,  Up: simplex

63.1 Introducción a simplex
===========================

El paquete `simplex' utiliza el algoritmo simplex para programación
lineal.

   Ejemplo:

     (%i1) load("simplex")$
     (%i2) minimize_sx(x+y, [3*x+2*y>2, x+4*y>3]);
                            9        7       1
     (%o2)                 [--, [y = --, x = -]]
                            10       10      5


File: maxima.info,  Node: Definiciones para simplex,  Prev: Introducción a simplex,  Up: simplex

63.2 Definiciones para simplex
==============================

 -- Variable opcional: epsilon_sx
     Valor por defecto: `10^-8'

     Error epsilon utilizado en los cálculos numéricos de
     `linear_program'.

     Véase también `linear_program'.


 -- Función: linear_program (<A>, <b>, <c>)
     La función `linear_program' es una implementación del algoritmo
     simplex. La instrucción `linear_program(A, b, c)' calcula un
     vector <x> tal que minimiza `c.x' bajo las restricciones `A.x = b'
     y `x >= 0'. El argumento <A> es una matriz y los argumentos <b> y
     <c> son listas.

     La función `linear_program' devuelve una lista que contiene el
     vector solución <x> y el valor mínimo de `c.x'.  Si el problema no
     está acotado, devuelve el mensaje "Problem not bounded!"  y si el
     problema no es factible, devuelve el mensaje "Problem not
     feasible!".

     Para usar esta función, cárguese primero el paquete con la
     instrucción `load(simplex);'.

     Ejemplo:

          (%i1) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
          (%i2) b: [1,1,6]$
          (%i3) c: [1,-2,0,0]$
          (%i4) linear_program(A, b, c);
                               [ 1   1   - 1   0  ]
                               [                  ]
          (%o4) linear_program([ 2  - 3   0   - 1 ], [1, 1, 6],
                               [                  ]
                               [ 4  - 5   0    0  ]
                                                            [1, - 2, 0, 0])

     Véanse también `minimize_sx', `scale_sx' y `epsilon_sx'.


 -- Función: maximize_sx (<obj>, <cond>, [<pos>])
     Maximiza la función objetivo lineal <obj> sujeta a ciertas
     restricciones lineales <cond>. Véase `minimize_sx' para una
     descripción detallada de los argumentos y de la respuesta dada por
     esta función.


 -- Función: minimize_sx (<obj>, <cond>, [<pos>])
     Minimiza la función objetivo lineal <obj> sujeta a ciertas
     restricciones lineales <cond>, siendo ésta una lista de ecuaciones
     o inecuaciones lineales.  En las inecuaciones estrictas se
     reemplaza `>' por `>=' y `<' por `<='. El argumento opcional <pos>
     es una lista de variables de decisión que se suponen positivas.

     Si el mínimo existe, `minimize_sx' devuelve una lista que contiene
     el valor mínimo de la función objetivo y una lista de valores para
     las variables de decisión con los que se alcanza el mínimo.  Si el
     problema no está acotado, devuelve el mensaje "Problem not
     bounded!"  y si el problema no es factible, devuelve el mensaje
     "Problem not feasible!".

     Las variables de decisión no se suponen no negativas. Si todas las
     variables de decisión son no negativas, asígnese el valor `true' a
     la variable `nonegative_sx'. Si sólo algunas de las variables de
     decisión son positivas, lístense en el argumento opcional <pos>,
     lo cual es más eficiente que añadir restricciones.

     La función `minimize_sx' utiliza el algoritmo simplex implementado
     en la función `linear_program' de Maxima.

     Para usar esta función, cárguese primero el paquete con la
     instrucción `load(simplex);'.

     Ejemplos:

          (%i1) minimize_sx(x+y, [3*x+y=0, x+2*y>2]);
          (%o1)    minimize_sx(y + x, [y + 3 x = 0, 2 y + x > 2])
          (%i2) minimize_sx(x+y, [3*x+y>0, x+2*y>2]), nonegative_sx=true;
          (%o2)    minimize_sx(y + x, [y + 3 x > 0, 2 y + x > 2])
          (%i3) minimize_sx(x+y, [3*x+y=0, x+2*y>2]), nonegative_sx=true;
          (%o3)    minimize_sx(y + x, [y + 3 x = 0, 2 y + x > 2])
          (%i4) minimize_sx(x+y, [3*x+y>0]);
          (%o4)           minimize_sx(y + x, [y + 3 x > 0])

     Véanse también `maximize_sx', `nonegative_sx' y `epsilon_sx'.


 -- Variable opcional: nonegative_sx
     Valor por defecto: `false'

     Si `nonegative_sx' vale `true' todas las variables de decisión
     pasadas a `minimize_sx' y a `maximize_sx' se suponen positivas.

     Véase también `minimize_sx'.



File: maxima.info,  Node: simplification,  Next: solve_rec,  Prev: simplex,  Up: Top

64 simplification
*****************

* Menu:

* Introducción a simplification::
* Definiciones para simplification::


File: maxima.info,  Node: Introducción a simplification,  Next: Definiciones para simplification,  Prev: simplification,  Up: simplification

64.1 Introducción a simplification
==================================

El directorio `maxima/share/simplification' contiene programas que
implementan algunas reglas y funciones para simplificar expresiones,
así como ciertas funciones no relacionadas con la simplificación.


File: maxima.info,  Node: Definiciones para simplification,  Prev: Introducción a simplification,  Up: simplification

64.2 Definiciones para simplification
=====================================

64.2.1 Paquete absimp
---------------------

El paquete `absimp' contiene reglas para aplicar patrones que extienden
el sistema de reglas nativo de Maxima para las funciones `abs' y
`signum', respetando las relaciones establecidas con la función
`assume' o con declaraciones tales como `modedeclare (m, even, n, odd)'
para enteros pares o impares.

   En el paquete `absimp' se definen las funciones `unitramp' y
`unitstep' en términos de `abs' y `signum'.

   La instrucción `load (absimp)' carga este paquete y `demo (absimp)'
desarrolla una demostración sobre el uso del mismo.

   Ejemplos:

     (%i1) load (absimp)$
     (%i2) (abs (x))^2;
                                            2
     (%o2)                                 x
     (%i3) diff (abs (x), x);
                                           x
     (%o3)                               ------
                                         abs(x)
     (%i4) cosh (abs (x));
     (%o4)                               cosh(x)

64.2.2 Paquete facexp
---------------------

El paquete `facexp' contiene varias funciones que le aportan al usuario
la posibilidad de estructurar expresiones controlando su expansión.
Esta capacidad es especialmente útil cuando la expresión contiene
variables con significado físico, ya que se suele dar el caso de que la
forma más sencilla para estas expresiones se obtiene cuando se expanden
respecto de estas variables y luego se factoriza respecto de sus
coeficientes. Si bien es cierto que este procedimiento no es difícil de
llevar a cabo con las funciones estándar de Maxima, pueden ser
necesarios algunos retoques adicionales que sí pueden ser más difíciles
de hacer.

   La función `facsum' y sus formas relacionadas proporcionan un método
para controlar la estructura de expresiones. La función `collectterms'
puede usarse para añadir dos o más expresiones que ya hayan sido
simplificadas de la forma indicada, sin necesidad de volver a
simplificar la expresión completa.  Esta función puede ser útil cuando
las expresiones sean largas.

   La instrucción `load (facexp)' carga este paquete y `demo (facexp)'
hace una demostración sobre su uso.

 -- Función: facsum (<expr>, <arg_1>, ..., <arg_n>)
     Devuelve una expresión equivalente a <expr>, la cual depende de
     los argumentos <arg_1>, ..., <arg_n>, y éstos pueden ser de
     cualquiera de las formas aceptables para `ratvars', o listas de
     estas formas. Si los argumentos no son listas, la forma devuelta
     se expande completamente con respecto de los argumentos, siendo los
     coeficientes de tales argumentos factorizados. Estos coeficientes
     no contienen a ninguno de los argumentos, excepto quizás de una
     forma no racional.

     En caso de que cualquiera de los argumentos sea una lista, entonces
     todos ellos se combinan en una única lista, y en lugar de llamar a
     `factor' para los coeficientes de los argumentos, `facsum' se
     llama a sí misma utilizando esta nueva lista única como lista de
     argumentos.

     Es posible que se quiera utilizar `facsum' con respecto a
     expresiones más complicadas, tales como `log (x + y)'. Estos
     argumentos son también admisibles. Si no se especifican variables,
     como en `facsum (<expr>)', el resultado devuelto es el mismo que
     el conseguido mediante `ratsimp (<expr>)'.

     En ocasiones puede ser necesario obtener cualquiera de las formas
     anteriores especificadas por sus operadores principales. Por
     ejemplo, se puede querer aplicar `facsum' con respecto a todos los
     `log'; en este caso, se puede incluir entre los argumentos bien
     los `log' específicos que se quieran tratar de esta manera, bien
     la expresión `operator (log)' o `'operator (log)'.  Si se quiere
     aplicar `facsum' a <expr> con respecto a los operadores <op_1>,
     ..., <op_n>, se debe evaluar `facsum (<expr>, operator (<op_1>,
     ..., <op_n>))'.  La forma `operator' puede aparecer también dentro
     de las listas de argumentos.

     Además, dándole valores a las variables opcionales `facsum_combine'
     y `nextlayerfactor' se puede controlar el resultado de `facsum'.

 -- Variable global: nextlayerfactor
     Valor por defecto: `false'

     Si `nextlayerfactor' vale `true', las llamadas recursivas de
     `facsum' se aplican a los factores de la forma factorizada de los
     coeficientes de los argumentos.

     Si vale `false', `facsum' se aplica a cada coeficiente como un
     todo cada vez que se efectúen llamadas recursivas a `facsum'.

     La inclusión del átomo `nextlayerfactor' en la lista de argumentos
     de `facsum' tiene el mismo efecto que `nextlayerfactor: true',
     pero solamente para el siguiente nivel de la expresión. Puesto que
     `nextlayerfactor' toma siempre uno de los valores `true' o
     `false', debe aparecer comentado (comilla simple) cada vez que
     aparezca en la lista de argumentos de `facsum'.

 -- Variable global: facsum_combine
     Valor por defecto: `true'

     La variable `facsum_combine' controla la forma del resultado final
     devuelto por `facsum' si su argumento es un cociente de polinomios.
     Si `facsum_combine' vale `false', el resultado será una suma
     completamente expandida, pero si vale `true', la expresión devuelta
     es un cociente de polinomios.


 -- Función: factorfacsum (<expr>, <arg_1>, ... <arg_n>)
     Devuelve una expresión equivalente a <expr> obtenida aplicando
     `facsum' a los factores de <expr>, de argumentos <arg_1>, ...
     <arg_n>. Si alguno de los factores de <expr> se eleva a una
     potencia, tanto el factor como el exponente se procesarán de esta
     manera.

 -- Función: collectterms (<arg_1>, ..., <arg_n>)
     Si algunas expresiones fueron ya simplificadas con `facsum',
     `factorfacsum', `factenexpand',  `facexpten' o `factorfacexpten',
     debiendo ser luego sumadas, puede ser conveniente combinarlas
     utilizando la función `collecterms', la cual admite como
     argumentos todos aquéllos que se puedan pasar a las anteriormente
     citadas funciones, con la excepción de `nextlayerfactor', que no
     tiene efecto alguno sobre `collectterms'.  La ventaja de
     `collectterms' es que devuelve una forma similar a la de `facsum',
     pero debido a que suma expresiones que ya han sido previamente
     procesadas, no necesita repetir esta operación, lo cual resulta
     ser especialmente útil cuando las expresiones a sumar son muy
     grandes.

64.2.3 Paquete functs
---------------------

 -- Función: rempart (<expr>, <n>)
     Elimina la parte <n> de la expresión <expr>.

     Si <n> es una lista de la forma `[<l>, <m>]', entonces las partes
     desde <l> a <m> serán eliminadas.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: wronskian ([<f_1>, ..., <f_n>], <x>)
     Devuelve la matriz wronskiana de las funciones <f_1>, ..., <f_n>
     dependeientes de la variable <x>.

     Los argumentos <f_1>, ..., <f_n> pueden ser nombres de funciones
     definidas por el usuario, o expresiones de variable <x>.

     El determinante de la matriz wronskiana es el determinante
     wronskiano del conjunto de funciones. Las funciones serán
     linealmente dependientes si este determinante es nulo.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: tracematrix (<M>)
     Devuelve la traza (suma de los elementos de la diagonal) de la
     matriz <M>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: rational (<z>)
     Multiplica el numerador y denominador de <z> por el complejo
     conjugado del denominador, racionalizando así el denominador.
     Devuelve la expresión canónica racional (canonical rational
     expression, CRE) si el argumento <z> es de esta forma, en caso
     contrario devuelve una expresión en formato común.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: logand (<x>,<y>)
     Devuelve el "y" lógico binario de los argumentos <x> e <y>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: logor (<x>,<y>)
     Devuelve el "o" lógico binario de los argumentos <x> e <y>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: logxor (<x>,<y>)
     Devuelve el "o-excusivo" lógico binario de los argumentos <x> e
     <y>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: nonzeroandfreeof (<x>, <expr>)
     Devuelve `true' si <expr> es diferente de cero y `freeof (<x>,
     <expr>)' devuelve `true'.  En caso contrario devuelve `false'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: linear (<expr>, <x>)
     Si <expr> es una expresión lineal respecto de la variable <x>,
     `linear' devuelve `<a>*<x> + <b>', siendo <a> no nula y, junto con
     <b>, no incluye a <x>. En otro caso, `linear' devuelve <expr>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: gcdivide (<p>, <q>)
     Si `takegcd' vale `true', `gcdivide' divide los polinomios <p> y
     <q> por su máximo común divisor y devuelve el cociente de los
     resultados.

     Si `takegcd' vale `false', `gcdivide' devuelve el cociente
     `<p>/<q>'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: arithmetic (<a>, <d>, <n>)
     Devuelve el <n>-ésimo término de la progresión aritmética `<a>,
     <a> + <d>, <a> + 2*<d>, ..., <a> + (<n> - 1)*<d>'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: geometric (<a>, <r>, <n>)
     Devuelve el <n>-ésimo término de la progresión geométrica `<a>,
     <a>*<r>, <a>*<r>^2, ..., <a>*<r>^(<n> - 1)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: harmonic (<a>, <b>, <c>, <n>)
     Devuelve el <n>-ésimo término de la progresión armónica `<a>/<b>,
     <a>/(<b> + <c>), <a>/(<b> + 2*<c>), ..., <a>/(<b> + (<n> -
     1)*<c>)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: arithsum (<a>, <d>, <n>)
     Devuelve la suma de la progresión aritmética desde hasta el
     <n>-ésimo término.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: geosum (<a>, <r>, <n>)
     Devuelve la suma de la sucesión geométrica hasta el <n>-ésimo
     término.  Si <n> es infinito (`inf') la suma será finita sólo si
     el valor absoluto de <r> es menor que 1.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: gaussprob (<x>)
     Devuelve la función de densidad de probabilidad, normal
     `%e^(-<x>^2/2) / sqrt(2*%pi)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: gd (<x>)
     Devuelve la función de Gudermann, `2 * atan(%e^<x> - %pi/2)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: agd (<x>)
     Devuelve la inversa de la función de Gudermann, `log (tan (%pi/4 +
     x/2)))'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: vers (<x>)
     Devuelve `1 - cos (x)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: covers (<x>)
     Devuelve `1 - sin (<x>)'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: exsec (<x>)
     Devuelve `sec (<x>) - 1'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: hav (<x>)
     Devuelve `(1 - cos(x))/2'.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: combination (<n>, <r>)
     Calcula el número de combinaciones de <n> objetos tomados de <r>
     en <r>.

     Para hacer uso de esta función ejecutar `load(functs)'.

 -- Función: permutation (<n>, <r>)
     Calcula el número de permutaciones de <r>, seleccionados de un
     conjunto de <n>.

     Para hacer uso de esta función ejecutar `load(functs)'.

64.2.4 Paquete ineq
-------------------

El paquete `ineq' contiene reglas de simplificación para desigualdades

   Una sesión de ejemplo:

     (%i1) load(ineq)$
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     Warning: Putting rules on '+' or '*' is inefficient, and may not work.
     (%i2) a>=4;  /* a sample inequality */
     (%o2)                               a >= 4
     (%i3) (b>c)+%; /* add a second, strict inequality */
     (%o3)                            b + a > c + 4
     (%i4) 7*(x<y); /* multiply by a positive number */
     (%o4)                              7 x < 7 y
     (%i5) -2*(x>=3*z); /* multiply by a negative number */
     (%o5)                           - 2 x <= - 6 z
     (%i6) (1+a^2)*(1/(1+a^2)<=1); /* Maxima knows that 1+a^2 > 0 */
                                             2
     (%o6)                             1 <= a  + 1
     (%i7) assume(x>0)$ x*(2<3); /* assuming x>0 */
     (%o7)                              2 x < 3 x
     (%i8) a>=b; /* another inequality */
     (%o8)                               a >= b
     (%i9) 3+%; /* add something */
     (%o9)                           a + 3 >= b + 3
     (%i10) %-3; /* subtract it out */
     (%o10)                              a >= b
     (%i11) a>=c-b; /* yet another inequality */
     (%o11)                            a >= c - b
     (%i12) b+%; /* add b to both sides */
     (%o12)                            b + a >= c
     (%i13) %-c; /* subtract c from both sides */
     (%o13)                         - c + b + a >= 0
     (%i14) -%;  /* multiply by -1 */
     (%o14)                          c - b - a <= 0
     (%i15) (z-1)^2>-2*z; /* determining truth of assertion */
                                           2
     (%o15)                         (z - 1)  > - 2 z
     (%i16) expand(%)+2*z; /* expand this and add 2*z to both sides */
                                        2
     (%o16)                            z  + 1 > 0
     (%i17) %,pred;
     (%o17)                               true

   Debe tenerse cuidado con el uso de paréntesis que incluyan
desigualdades; si se escribe `(A > B) + (C = 5)' el resultado es `A + C
> B + 5', pero `A > B + C = 5' es un error sintáctico y `(A > B + C) =
5' es una cosa completamente diferente.

   Ejecútese `disprule (all)' para ver la lista completa de las reglas
definidas.

   Maxima preguntará al usuario cuando desconozca el signo de una
cantidad que multiplica a una desigualdad.

   Los fallos más comunes son:

     eq: a > b;
     2*eq;
     % - eq;

   Otro problema es el producto de una desigualdad por cero.  Si se
escribe `x*<some_inequality>' y Maxima pregunta por el signo de `x' y
se responde que vale `zero' (o `z'), el programa devuelve
`x*<some_inequality>' sin hacer uso de la información de que `x' es 0.
En tal caso se debería escribir `ev (%, x: 0)', ya que la base de datos
sólo será utilizada para fines comparativos y no para evaluar `x'.

   El usuario puede apreciar que las respuestas son más lentas al
cargarse este paquete, ya que el simplificador deberá examinar más
reglas que cuando no se hace uso del paquete, por lo que puede ser
conveniente borrar estas reglas cuando ya no se haga uso de ellas.
Ejecútese `kill (rules)' para eliminar todas las reglas (incluidas las
definidas por el usuario); también es posible eliminar parte de ellas o
utilizar `remrule' sobre una reglas específica.

   Nótese que si se carga este paquete después de haber definido otras
reglas de igual nombre,se borrarán las antiguas. Las reglas de este
paquete son: `*rule1', ..., `*rule8', `+rule1', ..., `+rule18',
debiéndose encerrar entre comillas el nombre de la reglas para
referenciarse a ellas, como en `remrule ("+", "+rule1")' para eliminar
la primera regla sobre `"+"', o `disprule ("*rule2")' para mostrar la
definición de la segunda regla multiplicativa.

64.2.5 Paquete rducon
---------------------

 -- Función: reduce_consts (<expr>)
     Sustituye subexpresiones constantes de <expr> por átomos,
     guardando la definición de todos ellos en la lista de ecuaciones
     `const_eqns' y devolviendo el expresión <expr> ya modificada. Se
     consideran partes constantes de <expr> aquellas que devuelven
     `true' cuando se les aplica la función `constantp', por lo que
     antes de llamar a `reduce_consts' se debe ejecutar

          declare ([<objetos a los que se quiera dar la propiedad de ser constantes>], constant)$

     para crear la base de datos de las cantidades constantes presentes
     en la expresión.

     Si se pretende generar código Fortran después de estos cálculos
     simbólicos, una de las primeras secciones del código debe ser el
     cálculo de las constantes. Para generar este segmento de código
     hacer

          map ('fortran, const_eqns)$

     Junto a `const_eqns', otras variables que afectan a
     `reduce_consts' son:

     `const_prefix' (Valor por defecto: `xx') es la cadena de
     caracteres utilizada como prefijo para todos los símbolos
     generados por `reduce_consts' para representar subexpresiones
     constantes.

     `const_counter' (Valor por defecto: 1) es el índice entero
     utilizado para generar los símbolos que representen a las
     subexpresiones constantes encontradas por `reduce_consts'.

     La instrucción `load (rducon)' carga esta función y `demo (rducon)'
     hace una demostración sobre su uso.

64.2.6 Paquete scifac
---------------------

 -- Función: gcfac (<expr>)
     Es una función de factorización que intenta aplicar la misma
     heurística que los humanos cuando tratan de hacer las expresiones
     más simples, limitándose a la factorización de monomios. En caso
     de sumas, `gcfac' hace lo siguiente:

       1. Factoriza los enteros.

       2. Factoriza las potencias mayores de los términos que aparecen
          como coeficientes, independientemente de su complejidad.

       3. Utiliza (1) y (2) en la factorización de pares de términos
          adyacentes.

       4. Aplica estas técnicas repetida y recursivamente hasta que la
          expresión deje de sufrir cambios.

     En general, el apartado (3) no hace una factorización óptima
     debido a la naturaleza combinatoria y compleja de encontrar cuál
     de todas las ordenaciones posibles de los pares da lugar a la
     expresión más compacta.

     La instrucción `load (scifac)' carga esta función y `demo (scifac)'
     hace una demostración sobre su uso.

64.2.7 Paquete sqdnst
---------------------

 -- Función: sqrtdenest (<expr>)
     Reduce expresiones en las que se encuentren raíces cuadradas
     anidadas, siempre que sea posible

     Ejemplo:

          (%i1) load (sqdnst)$
          (%i2) sqrt(sqrt(3)/2+1)/sqrt(11*sqrt(2)-12);
                                              sqrt(3)
                                         sqrt(------- + 1)
                                                 2
          (%o2)                        ---------------------
                                       sqrt(11 sqrt(2) - 12)
          (%i3) sqrtdenest(%);
                                            sqrt(3)   1
                                            ------- + -
                                               2      2
          (%o3)                            -------------
                                              1/4    3/4
                                           3 2    - 2

     A veces conviene aplicar `sqrtdenest' más de una vez, como en el
     caso `(19601-13860 sqrt(2))^(7/4)'.

     La sentencia `load (sqdnst)' carga esta función.


File: maxima.info,  Node: solve_rec,  Next: stirling,  Prev: simplification,  Up: Top

65 solve_rec
************

* Menu:

* Introducción a solve_rec::
* Definiciones para solve_rec::


File: maxima.info,  Node: Introducción a solve_rec,  Next: Definiciones para solve_rec,  Prev: solve_rec,  Up: solve_rec

65.1 Introducción a solve_rec
=============================

El paquete `solve_rec' resuelve expresiones recurrentes lineales con
coeficientes polinomiales.

   Ejecútese `demo(solve_rec);' para ver una demostración sobre la
utilización de este paquete.

   Ejemplo:

     (%i1) load("solve_rec")$
     (%i2) solve_rec((n+4)*s[n+2] + s[n+1] - (n+1)*s[n], s[n]);
                                         n
                      %k  (2 n + 3) (- 1)          %k
                        1                            2
     (%o2)       s  = -------------------- + ---------------
                  n     (n + 1) (n + 2)      (n + 1) (n + 2)


File: maxima.info,  Node: Definiciones para solve_rec,  Prev: Introducción a solve_rec,  Up: solve_rec

65.2 Definiciones para solve_rec
================================

 -- Función: closed_form (<expr>)
     Intenta reducir todas las sumas que aparecen en <expr> a una forma
     cerrada. La función `closed_form' utiliza los algoritmos de Gosper
     y Zeilberger para reducir las sumas.

     Para utilizar esta función cárguese previamente el paquete
     `closed_form' ejecutando la instrucción `load(closed_form)'.

     Ejemplo:

          (%i1) load("closed_form")$
          (%i2) sum(binom(n+k,k)/2^k, k, 0, n) + sum(binom(2*n, 2*k), k, 0, n);
                   n                            n
                  ====                         ====
                  \      binomial(n + k, k)    \
          (%o2)    >     ------------------ +   >    binomial(2 n, 2 k)
                  /               k            /
                  ====           2             ====
                  k = 0                        k = 0
          (%i3) closed_form(%);
                                         n
                                        4     n
          (%o3)                         -- + 2
                                        2


 -- Función: reduce_order (<rec>, <sol>, <var>)
     Reduce el orden de la expresión recurrente lineal <rec> cuando se
     conoce una solución particular <sol>. La recurrencia reducida
     puede utilizarse para obterner más soluciones.

     Ejemplo:

          (%i3) rec: x[n+2] = x[n+1] + x[n]/n;
                                                x
                                                 n
          (%o3)               x      = x      + --
                               n + 2    n + 1   n
          (%i4) solve_rec(rec, x[n]);
          WARNING: found some hypergeometrical solutions!
          (%o4)                    x  = %k  n
                                    n     1
          (%i5) reduce_order(rec, n, x[n]);
          (%t5)                    x  = n %z
                                    n       n

                                     n - 1
                                     ====
                                     \
          (%t6)                %z  =  >     %u
                                 n   /        %j
                                     ====
                                     %j = 0

          (%o6)             (- n - 2) %u     - %u
                                        n + 1     n
          (%i6) solve_rec((n+2)*%u[n+1] + %u[n], %u[n]);
                                               n
                                      %k  (- 1)
                                        1
          (%o6)                 %u  = ----------
                                  n    (n + 1)!

     So the general solution is

                       n - 1
                       ====        n
                       \      (- 1)
                 %k  n  >    -------- + %k  n
                   2   /     (n + 1)!     1
                       ====
                       n = 0


 -- Variable opcional: simplify_products
     Valor por defecto: `true'

     Si `simplify_products' vale `true', `solve_rec' intentará
     simplificar los productos del resultado.

     Véase también `solve_rec'.


 -- Función: solve_rec (<eqn>, <var>, [<init>])
     Obtiene las soluciones hipergeométricas de la expresión recurrente
     <eqn> con coeficientes lineales en la variable <var>. Los
     argumentos opcionales <init> son condiciones iniciales.

     La función `solve_rec' puede resolver expresiones recurrentes con
     coeficientes constantes, encuentra soluciones hipergeométricas de
     expresiones recurrentes lineales homogéneas con coeficientes
     polinomiales, obtiene soluciones racionales de expresiones
     recurrentes lineales con coeficientes lineales y resuelve también
     expresiones recurrentes de Ricatti.

     Nótese que el tiempo de ejecución del algoritmo para encontrar
     soluciones hipergeométricas es exponencial respecto del grado del
     coeficiente principal.

     Para hacer uso de esta función ejecútese previamente
     `load(solve_rec);'.

     Ejemplo de recurrencia lineal con coeficientes constantes:

          (%i2) solve_rec(a[n]=a[n-1]+a[n-2]+n/2^n, a[n]);
                                  n          n
                     (sqrt(5) - 1)  %k  (- 1)
                                      1           n
          (%o2) a  = ------------------------- - ----
                 n               n                  n
                                2                5 2
                                                          n
                                             (sqrt(5) + 1)  %k
                                                              2    2
                                           + ------------------ - ----
                                                      n              n
                                                     2            5 2

     Ejemplo de recurrencia lineal con coeficientes polinomiales:

          (%i7) 2*x*(x+1)*y[x] - (x^2+3*x-2)*y[x+1] + (x-1)*y[x+2];
                                   2
          (%o7) (x - 1) y      - (x  + 3 x - 2) y      + 2 x (x + 1) y
                         x + 2                   x + 1                x
          (%i8) solve_rec(%, y[x], y[1]=1, y[3]=3);
                                        x
                                     3 2    x!
          (%o9)                 y  = ---- - --
                                 x    4     2

     Ejemplo de recurrencia de Ricatti:

          (%i2) x*y[x+1]*y[x] - y[x+1]/(x+2) + y[x]/(x-1) = 0;
                                      y         y
                                       x + 1     x
          (%o2)         x y  y      - ------ + ----- = 0
                           x  x + 1   x + 2    x - 1
          (%i3) solve_rec(%, y[x], y[3]=5)$
          (%i4) ratsimp(minfactorial(factcomb(%)));
                                             3
                                         30 x  - 30 x
          (%o4) y  = - -------------------------------------------------
                 x        6      5       4       3       2
                       5 x  - 3 x  - 25 x  + 15 x  + 20 x  - 12 x - 1584

     Véanse también `solve_rec_rat', `simplify_products' y
     `product_use_gamma'.


 -- Función: solve_rec_rat (<eqn>, <var>, [<init>])
     Calcula las soluciones racionales de las expresiones recurrentes
     lineales.  Véase `solve_rec' para la descripción de sus argumentos.

     Para hacer uso de esta función ejecútese previamente
     `load(solve_rec);'.

     Ejemplo:

          (%i1) (x+4)*a[x+3] + (x+3)*a[x+2] - x*a[x+1] + (x^2-1)*a[x];
          (%o1)  (x + 4) a      + (x + 3) a      - x a
                          x + 3            x + 2      x + 1
                                                             2
                                                         + (x  - 1) a
                                                                      x
          (%i2) solve_rec_rat(% = (x+2)/(x+1), a[x]);
                                 1
          (%o2)      a  = ---------------
                      x   (x - 1) (x + 1)

     Véase también `solve_rec'.


 -- Variable opcional: product_use_gamma
     Valor por defecto:`true'

     Si `product_use_gamma' vale `true',  `solve_rec' introduce la
     función gamma en la expresión del resultado cuando se simplifican
     productos.

     Véanse también `simplify_products' y `solve_rec'.


 -- Función: summand_to_rec (<summand>, <k>, <n>)
     Devuelve la expresión recurrente que satisface la suma

              inf
              ====
              \
               >     sumando
              /
              ====
            k = minf

     donde el sumando es hipergeométrico en  <k> y <n>.

     Para hacer uso de esta función deben cargarse previamente los
     paquetes `zeilberger' y `solve_rec' mediante la ejecución de las
     sentencias `load(solve_rec)' y `load(zeilberger)'.

          (%i17) load("zeilberger")$
          (%i18) summand: binom(3*k+1,k)*binom(3*(n-k),n-k)/(3*k+1)$
          (%i19) summand_to_rec(summand, k, n);
          Dependent equations eliminated:  (3 2)
          (%o19) - 4 (n + 2) (2 n + 3) (2 n + 5) sm
                                                   n + 2
                              2
           + 12 (2 n + 3) (9 n  + 27 n + 22) sm
                                               n + 1
           - 81 (n + 1) (3 n + 2) (3 n + 4) sm
                                              n
          (%i21) sum(''summand, k, 0, n), n=0;
          (%o21)                       1
          (%i22) sum(''summand, k, 0, n), n=1;
          (%o22)                       4
          (%i23) product_use_gamma: false$
          (%i24) solve_rec(%o19, sm[n], sm[0]=1, sm[1]=4);
                        n - 1               n - 1
                        /===\               /===\
                         ! !                 ! !                n
                       ( ! !   (3 %j + 2)) ( ! !   (3 %j + 4)) 3
                         ! !                 ! !
                        %j = 0              %j = 0
          (%o24) sm  = ------------------------------------------
                   n            n - 1
                                /===\
                                 ! !                n
                               ( ! !   (2 %j + 3)) 2  n!
                                 ! !
                                %j = 0



File: maxima.info,  Node: stirling,  Next: stringproc,  Prev: solve_rec,  Up: Top

66 stirling
***********

* Menu:

* Definiciones para stirling::


File: maxima.info,  Node: Definiciones para stirling,  Prev: stirling,  Up: stirling

66.1 Definiciones para stirling
===============================

 -- Función: stirling (<z>,<n>)
     Sustituye `gamma(x)' por la fórmula de Stirling O(1/x^(2n-1)).  Si
     <n> no es un entero no negativo, emite un mensaje de error.

     Referencia: Abramowitz & Stegun, " Handbook of mathematical
     functions", 6.1.40.

     Ejemplos:
          (%i1) load (stirling)$

          (%i2) stirling(gamma(%alpha+x)/gamma(x),1);
                 1/2 - x             x + %alpha - 1/2
          (%o2) x        (x + %alpha)
                                             1           1
                                      --------------- - ---- - %alpha
                                      12 (x + %alpha)   12 x
                                    %e
          (%i3) taylor(%,x,inf,1);
                              %alpha       2    %alpha
                    %alpha   x       %alpha  - x       %alpha
          (%o3)/T/ x       + -------------------------------- + . . .
                                           2 x
          (%i4) map('factor,%);
                                                 %alpha - 1
                   %alpha   (%alpha - 1) %alpha x
          (%o4)   x       + -------------------------------
                                            2

     La función `stirling' conoce la diferencia existente entre la
     variable 'gamma' y la función gamma:

          (%i5) stirling(gamma + gamma(x),0);
                                              x - 1/2   - x
          (%o5)    gamma + sqrt(2) sqrt(%pi) x        %e
          (%i6) stirling(gamma(y) + gamma(x),0);
                                   y - 1/2   - y
          (%o6) sqrt(2) sqrt(%pi) y        %e
                                                        x - 1/2   - x
                                   + sqrt(2) sqrt(%pi) x        %e

     Antes de hacer uso de esta función ejecútese  `load("stirling")'.


File: maxima.info,  Node: stringproc,  Next: unit,  Prev: stirling,  Up: Top

67 stringproc
*************

* Menu:

* Introducción al procesamiento de cadenas::
* Definiciones para entrada y salida::
* Definiciones para caracteres::
* Definiciones para cadenas::


File: maxima.info,  Node: Introducción al procesamiento de cadenas,  Next: Definiciones para entrada y salida,  Prev: stringproc,  Up: stringproc

67.1 Introducción al procesamiento de cadenas
=============================================

El paquete `stringproc' amplía las capacidades de Maxima para manipular
cadenas de caracteres; para cargarlo basta con ejecutar la sentencia
`load("stringproc")'.

   En Maxima, una cadena de caracteres se construye fácilmente
escribiéndola entre comillas dobles (`"'). Téngase en cuenta que las
cadenas de Maxima no son cadenas de Lisp, pudiéndose ejecutar las
funciones de chequeo `stringp' y `lstringp' con el fin de dilucidar qué
tipo de cadena es su argumento. Si por cualquier motivo el usuario
tiene una cadena de Lisp y la quiere convertir a una cadena de Maxima
habrá de utilizar la función conversora `sunlisp'.

     (%i1) load("stringproc")$
     (%i2) m: "text";
     (%o2)                         text
     (%i3) [stringp(m),lstringp(m)];
     (%o3)                     [true, false]
     (%i4) l: sconcat("text");
     (%o4)                         text
     (%i5) [stringp(l),lstringp(l)];
     (%o5)                     [false, true]
     (%i6) stringp( sunlisp(l) );
     (%o6)                         true

   Todas las cadenas devueltas por las funciones de `stringproc' son
cadenas de Maxima.

   Los caracteres individuales se introducen como cadenas de Maxima de
longitud igual a la unidad. Estos caracteres no son caracteres de Lisp
y se pueden chequear con las funciones `charp' y `lcharp', pudiéndose
convertir los caracteres de Lisp a Maxima mediante `cunlisp'.

     (%i1) load("stringproc")$
     (%i2) c: "e";
     (%o2)                           e
     (%i3) [charp(c),lcharp(c)];
     (%o3)                     [true, false]
     (%i4) supcase(c);
     (%o4)                           E
     (%i5) charp(%);
     (%o5)                         true

   Todos los caracteres devueltos por las funciones de `stringproc' son
caracteres de Maxima. Puesto que los caracteres introducidos son
cadenas de longitud igual a la unidad, se pueden utilizar las funciones
de cadenas también para los caracteres, como se ha hecho con `supcase'
en el anterior ejemplo.

   Es importante tener en cuenta que el primer carácter en una cadena
de Maxima ocupa la posición 1. Esto se ha diseñado así para mantener la
compatibilidad con las listas de Maxima. Véanse las definiciones de
`charat' y `charlist' para ver ejemplos.

   Las funciones de cadenas se utilizan frecuentemente cuando se
trabaja con ficheros. El paquete `stringproc' dispone de algunas
funciones de escritura que pueden ser útiles. Por ejemplo, si un
fichero contiene instrucciones de entrada y salidas de Maxima, la
función `extracti' extrae los valores de todas las etiquetas de entrada
para un fichero que puede ser leído por Maxima y cuya ruta es devuelta
por la función. El fichero podrá ser ejecutado inmediatamente con
`batch(%)'.  Nótese que `extracti' falla si al menos una de las
etiquetas está dañada, quizás debido a haber borrado `).', o si algunas
entradas procedían de la lectura de ficheros externos (mediante
`batch'), o si existen caracteres más allá de los símbolos de
terminación de sentencia `;' o `$'.

     extracti(file):= block(
        [ s1: openr(file), ifile: sconc(file,".in"), line, nl: false ],
        s2: openw(ifile),

        while ( stringp(line: readline(s1)) ) do (
           if ssearch( sconc("(",inchar),line ) = 1 then (
              line: strim(" ",substring( line,ssearch(")",line)+1 )),
              printf( s2,"~a~%",line ),
              checklast(line) )
           else if nl then (
              line: strimr(" ",line),
              printf( s2,"~a~%",line ),
              checklast(line) )),

        close(s1), close(s2),
        ifile)$

     checklast(line):= block(
        [ last: charat( line,slength(line) ) ],
        if cequal(last,";") or cequal(last,"$") then
           nl:false else nl:true )$

   Contenido del fichero 'C:\home\maxima\test.out':

     (%i1) f(x):= sin(x)$
     (%i2) diff(f(x),x);
     (%o2)                               cos(x)
     (%i3) df(x):= ''%;
     (%o3)                           df(x) := cos(x)
     (%i4) df(0);
     (%o4)                                  1

   Ahora desde Maxima:

     (%i11) extracti("C:\\home\\maxima\\test.out");
     (%o11)             C:\home\maxima\test.out.in
     (%i12) batch(%);

     batching #pC:/home/maxima/test.out.in
     (%i13)                          f(x) := sin(x)
     (%i14)                           diff(f(x), x)
     (%o14)                              cos(x)
     (%i15)                          df(x) := cos(x)
     (%o15)                          df(x) := cos(x)
     (%i16)                               df(0)
     (%o16)                                 1


File: maxima.info,  Node: Definiciones para entrada y salida,  Next: Definiciones para caracteres,  Prev: Introducción al procesamiento de cadenas,  Up: stringproc

67.2 Definiciones para entrada y salida
=======================================

Ejemplo:

     (%i1) s: openw("C:\\home\\file.txt");
     (%o1)                 #<output stream C:\home\file.txt>
     (%i2) control: "~2tAn atom: ~20t~a~%~2tand a list: ~20t~{~r ~}~%~2tand an integer: ~20t~d~%"$
     (%i3) printf( s,control, 'true,[1,2,3],42 )$
     (%o3)                                false
     (%i4) close(s);
     (%o4)                                true
     (%i5) s: openr("C:\\home\\file.txt");
     (%o5)                 #<input stream C:\home\file.txt>
     (%i6) while stringp( tmp:readline(s) ) do print(tmp)$
       An atom:          true
       and a list:       one two three
       and an integer:   42
     (%i7) close(s)$

 -- Función: close (<stream>)
     Cierra el flujo de datos <stream> y devuelve `true' si <stream>
     había sido abierto.


 -- Función: flength (<stream>)
     Devuelve el número de elementos en el flujo de datos <stream>.


 -- Función: fposition (<stream>)
 -- Función: fposition (<stream>, <pos>)
     Devuelve la posición actual en el flujo de datos <stream> si no se
     utiliza <pos>.  Si se utiliza <pos>, `fposition' ajusta la
     posición en <stream>.  El argumento <pos> debe ser un número
     positivo, ocupando el primer elemento en <stream> la posición 1.


 -- Función: freshline ()
 -- Función: freshline (<stream>)
     Escribe una nueva línea en el  flujo de datos <stream> si la
     posición actual no corresponde al inicio de la línea.  La función
     `freshline' no trabaja correctamente con los flujos de datos
     `true' y `false'.


 -- Función: newline ()
 -- Función: newline (<stream>)
     Escribe una nueva línea en el  flujo de datos  <stream>.  La
     función `freshline' no trabaja correctamente con los flujos de
     datos `true' y `false'.  Véase `sprint' para un ejemplo de
     utilización de `newline'.


 -- Función: opena (<file>)
     Devuelve un flujo de datos al fichero <file>.  Si se abre un
     fichero ya existente, `opena' añade elementos al final del fichero.


 -- Función: openr (<file>)
     Devuelve un flujo de datos de entrada al fichero <file>.  Si
     <file> no existe, será creado.

 -- Función: openw (<file>)
     Devuelve un flujo de datos de salida al fichero <file>.  Si <file>
     no existe, será creado.  Si se abre un fichero ya existente,
     `openw' lo modifica borrando el contenido anterior.

 -- Función: printf (<dest>, <string>)
 -- Función: printf (<dest>, <string>, <expr_1>, ..., <expr_n>)
     La función `printf' se comporta de forma similar a la de FORMAT en
     Common Lisp.  Véanse las referencias de Lisp para más información.
     Téngase en cuenta que hay alhunas directivas que funcionan en
     Lisp, pero no en Maxima. Por ejemplo, `~:[' falla.

     La función `printf' ha sido diseñada para que `~s' se interprete
     igual que `~a'. Además la directiva de selección `~[' se indexa a
     partir del cero.

             ~%       nueva línea
             ~&       línea de refresco
             ~t       tabulación
             ~$       moneda
             ~d       entero en base decimal
             ~b       entero en base binaria
             ~o       entero en base octal
             ~x       entero en base hexadecimal
             ~br      entero en base b
             ~r       deletrea un entero
             ~p       plural
             ~f       decimal en coma flotante
             ~e       notación científica
             ~g       ~f o ~e, dependiendo de la magnitud
             ~a       tal como imprime la función de Maxima `print'
             ~s       como ~a
             ~~       ~
             ~<       justificación, ~> termina
             ~(       conversor mayúscula/minúscula, ~) termina
             ~[       selección, ~] termina
             ~{       iteración, ~} termina

          (%i1) printf( false, "~s ~a ~4f ~a ~@r",
          "String",sym,bound,sqrt(8),144), bound = 1.234;
          (%o1)                 String sym 1.23 2*sqrt(2) CXLIV
          (%i2) printf( false,"~{~a ~}",["one",2,"THREE"] );
          (%o2)                          one 2 THREE
          (%i3) printf( true,"~{~{~9,1f ~}~%~}",mat ),
          mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
                1.1       2.0       3.3
                4.0       5.0       6.0
                7.0       8.9       9.0
          (%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
          (%i5) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
          (%o5)                    Two birds are singing.

     Si <dest> es un flujo de datos o `true', entonces `printf'
     devuelve `false'. En otro caso, `printf' devuelve una cadena con
     la salida.

 -- Función: readline (<stream>)
     Devuelve una cadena con los caracteres desde la posición actual en
     el flujo de datos <stream> hasta el final de la línea, o `false'
     si está al final del fichero.

 -- Función: sprint (<expr_1>, ..., <expr_n>)
     Evalúa y muestra sus argumentos uno tras otro en un renglón
     comenzando en su extremo izquierdo.

          (%i1) load("stringproc")$
          (%i2) for n:0 thru 16 do sprint( fib(n) )$
          0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

     Si se quiere un salto de línea antes de cada impresión, añádase
     `,newline()'.

     Véase `ascii' para un ejemplo.


File: maxima.info,  Node: Definiciones para caracteres,  Next: Definiciones para cadenas,  Prev: Definiciones para entrada y salida,  Up: stringproc

67.3 Definiciones para caracteres
=================================

 -- Función: alphacharp (<char>)
     Devuelve `true' si <char> es una carácter alfabético.

 -- Función: alphanumericp (<char>)
     Devuelve `true' si <char> es una carácter alfabético o un dígito.

 -- Función: ascii (<int>)
     Devuelve el carácter correspondiente al número ASCII <int>,
     debiendo ser -1 < int < 256.

          (%i1) for n from 0 thru 255 do ( tmp: ascii(n),
          if alphacharp(tmp) then sprint(tmp) ), newline()$
          A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g
          h i j k l m n o p q r s t u v w x y z


 -- Función: cequal (<char_1>, <char_2>)
     Devuelve `true' si <char_1> y <char_2> son el mismo carácter.

 -- Función: cequalignore (<char_1>, <char_2>)
     Como `cequal', pero ignora si las letras están en mayúsculas o
     minúsculas.

 -- Función: cgreaterp (<char_1>, <char_2>)
     Devuelve  `true' si el número ASCII de <char_1> es mayor que el de
     <char_2>.

 -- Función: cgreaterpignore (<char_1>, <char_2>)
     Como `cgreaterp', pero ignora si las letras están en mayúsculas o
     minúsculas.

 -- Función: charp (<obj>)
     Devuelve `true' si <obj> es un carácter de Maxima.

 -- Función: cint (<char>)
     Devuelve el número ASCII de <char>.

 -- Función: clessp (<char_1>, <char_2>)
     Devuelve  `true' si el número ASCII de <char_1> es menor que el de
     <char_2>.

 -- Función: clesspignore (<char_1>, <char_2>)
     Como `clessp', pero ignora si las letras están en mayúsculas o
     minúsculas.

 -- Función: constituent (<char>)
     Devuelve `true' si <char> es un carácter gráfico y no el carácter
     espacio. Un carácter gráfico es el que se puede ver y con un
     espacio añadido; `constituent' está definido por Paul Graham, ANSI
     Common Lisp, 1996, page 67.

          (%i1) for n from 0 thru 255 do ( tmp: ascii(n),
          if constituent(tmp) then sprint(tmp) ), newline()$
          ! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B
          C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
          d e f g h i j k l m n o p q r s t u v w x y z { | } ~


 -- Función: cunlisp (<lisp_char>)
     Convierte un carácter Lisp en uno de Maxima. El uso de esta
     función por parte del usuario no será necesario.

 -- Función: digitcharp (<char>)
     Devuelve `true' si <char> es un dígito.

 -- Función: lcharp (<obj>)
     Devuelve `true' si <obj> es un carácter de Lisp.  El uso de esta
     función por parte del usuario no será necesario.

 -- Función: lowercasep (<char>)
     Devuelve  `true' si <char> es un carácter en minúscula.

 -- Variable: newline
     El carácter de nueva línea.

 -- Variable: space
     El carácter de espacio.

 -- Variable: tab
     El carácter de tabulación.

 -- Función: uppercasep (<char>)
     Devuelve `true' si <char> es un carácter en mayúscula.


File: maxima.info,  Node: Definiciones para cadenas,  Prev: Definiciones para caracteres,  Up: stringproc

67.4 Definiciones para cadenas
==============================

 -- Función: sunlisp (<lisp_string>)
     Convierte una cadena Lisp en una de Maxima.  El uso de esta
     función por parte del usuario no será necesario.

 -- Función: lstringp (<obj>)
     Devuelve `true' si <obj> es una cadena de Lisp.  El uso de esta
     función por parte del usuario no será necesario.

 -- Función: stringp (<obj>)
     Devuelve `true' si <obj> es una cadena de Maxima.  Véase un
     ejemplo en la introducción.

 -- Función: charat (<string>, <n>)
     Devuelve el <n>-ésimo carácter de <string>.  Al primer carácter de
     <string> le corresponde <n> = 1.

          (%i1) load("stringproc")$
          (%i2) charat("Lisp",1);
          (%o2)                           L


 -- Función: charlist (<string>)
     Devuelve una lista con todos los caracteres de <string>.

          (%i1) load("stringproc")$
          (%i2) charlist("Lisp");
          (%o2)                     [L, i, s, p]
          (%i3) %[1];
          (%o3)                           L


 -- Función: parsetoken (<string>)
     La función `parsetoken' convierte el primer lexema de <string> a
     su forma numérica, devolviendo `false' si no se puede determinar
     este número. El conjunto de delimitadores de lexemas es `{space,
     comma, semicolon, tab, newline}'.

          (%i1) load("stringproc")$
          (%i2) 2*parsetoken("1.234 5.678");
          (%o2)                         2.468

     También se puede utilizar la función `parse_string' para el
     análisis sintáctico.

 -- Función: sconc (<expr_1>, ..., <expr_n>)
     Evalúa sus argumentos y los yuxtapone para formar una cadena.
     Esta función es similar a `sconcat', pero devuelve una cadena de
     Maxima.

          (%i1) load("stringproc")$
          (%i2) sconc("xx[",3,"]:",expand((x+y)^3));
          (%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i3) stringp(%);
          (%o3)                         true


 -- Función: scopy (<string>)
     Devuelve una copia nueva de la cadena <string>.

 -- Función: sdowncase (<string>)
 -- Función: sdowncase (<string>, <start>)
 -- Función: sdowncase (<string>, <start>, <end>)
     Convierte caracteres en minúscula a mayúscula. Véase también
     `supcase'.

 -- Función: sequal (<string_1>, <string_2>)
     Devuelve `true' si <string_1> y <string_2> son dos cadenas de
     caracteres iguales.


 -- Función: sequalignore (<string_1>, <string_2>)
     Igual que `sequal' pero no diferencia entre minúsculas y
     mayúsculas..


 -- Función: sexplode (<string>)
     El nombre `sexplode' es un seudónimo de la función `charlist'.


 -- Función: simplode (<list>)
 -- Función: simplode (<list>, <delim>)
     La función `simplode' admite como entrada una lista de expresiones
     para luego convertirla en una cadena de caracteres. Si no se
     utiliza la opción <delim> para indicar el delimitador, entonces
     `simplode' actúa como `sconc' y no hace uso de ninguno. El valor
     de <delim> puede ser cualquier cadena.

          (%i1) load("stringproc")$
          (%i2) simplode(["xx[",3,"]:",expand((x+y)^3)]);
          (%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
          (%i3) simplode( sexplode("stars")," * " );
          (%o3)                   s * t * a * r * s
          (%i4) simplode( ["One","more","coffee."]," " );
          (%o4)                   One more coffee.


 -- Función: sinsert (<seq>, <string>, <pos>)
     Devuelve la concatenación de las cadenas `substring (<string>, 1,
     <pos> - 1)', <seq> y `substring (<string>, <pos>)'.  Nótese que al
     primer carácter de <string> le corresponde la posición 1.

          (%i1) load("stringproc")$
          (%i2) s: "A submarine."$
          (%i3) sconc( substring(s,1,3),"yellow ",substring(s,3) );
          (%o3)                  A yellow submarine.
          (%i4) sinsert("hollow ",s,3);
          (%o4)                  A hollow submarine.


 -- Función: sinvertcase (<string>)
 -- Función: sinvertcase (<string>, <start>)
 -- Función: sinvertcase (<string>, <start>, <end>)
     Devuelve la misma cadena <string> pero con todos sus caracteres
     desde la posición <start> hasta <end> quedan invertidos, esto es,
     las mayúsculas se convierten en minúsculas y éstas en mayúsculas.
     Si no se incluye el argumento <end>, se invierten todos los
     caracteres desde <start> hasta el final de la cadena.

          (%i1) load("stringproc")$
          (%i2) sinvertcase("sInvertCase");
          (%o2)                      SiNVERTcASE


 -- Función: slength (<string>)
     Devuelve el número de caracteres de <string>.


 -- Función: smake (<num>, <char>)
     Construye una cadena de longitud <num> con todos sus caracteres
     iguales a <char>.

          (%i1) load("stringproc")$
          (%i2) smake(3,"w");
          (%o2)                          www


 -- Función: smismatch (<string_1>, <string_2>)
 -- Función: smismatch (<string_1>, <string_2>, <test>)
     Devuelve la posición del primer carácter de <string_1> distinto del
     correpondiente a <string_2>. La respuesta será `false' si no existe
     tal carácter. Por defecto, la función de comparación es `sequal'.
     Si se quiere ignorar la diferencia entre mayúsculas y minúsculas,
     hágase uso de `sequalignore' para el argumento <test>.

          (%i1) load("stringproc")$
          (%i2) smismatch("seven","seventh");
          (%o2)                           6


 -- Función: split (<string>)
 -- Función: split (<string>, <delim>)
 -- Función: split (<string>, <delim>, <multiple>)
     Devuelve la lista de todos los lexemas (tokens) de <string>.  La
     función `split' utiliza <delim> como delimitador, y en caso de no
     ser utilizado este argumento, será utilizado el espacio en blanco
     como delimitador por defecto. El argumento <multiple> es una
     variable booleana con valor `true' por defecto. Los delimitadores
     múltiples se leen como uno solo, lo que resulta de utilidad si las
     tabulaciones son almacenadas como secuencias de espacios en
     blanco. Si a <multiple> se le asigna el valor `false', se
     consirararán todos los delimitadores.

          (%i1) load("stringproc")$
          (%i2) split("1.2   2.3   3.4   4.5");
          (%o2)                 [1.2, 2.3, 3.4, 4.5]
          (%i3) split("first;;third;fourth",";",false);
          (%o3)               [first, , third, fourth]


 -- Función: sposition (<char>, <string>)
     Devuelve la posición del primer carácter de <string> que coincide
     con <char>. Al primer carácter de <string> le corresponde la
     posición 1.  Para cuando se quiera ignorar la diferencia entre
     mayúsculas y minúsculas, véase <ssearch>.

 -- Función: sremove (<seq>, <string>)
 -- Función: sremove (<seq>, <string>, <test>)
 -- Función: sremove (<seq>, <string>, <test>, <start>)
 -- Función: sremove (<seq>, <string>, <test>, <start>, <end>)
     Devuelve la cadena <string> pero sin las subcadenas que coinciden
     con <seq>.  La función de comparación por defecto es `sequal'.  Si
     se quiere ignorar la diferencia entre mayúsculas y minúsculas,
     hágase uso de `sequalignore' para el argumento <test>.  Utilícense
     <start> y <end> para acotar la búsqueda.  Al primer carácter de
     <string> le corresponde la posición 1.

          (%i1) load("stringproc")$
          (%i2) sremove("n't","I don't like coffee.");
          (%o2)                   I do like coffee.
          (%i3) sremove ("DO ",%,'sequalignore);
          (%o3)                    I like coffee.


 -- Función: sremovefirst (<seq>, <string>)
 -- Función: sremovefirst (<seq>, <string>, <test>)
 -- Función: sremovefirst (<seq>, <string>, <test>, <start>)
 -- Función: sremovefirst (<seq>, <string>, <test>, <start>, <end>)
     Actúa de forma similar a la función `sremove', pero sólo elimina
     la primera aparición de la subcadena `seq'.


 -- Función: sreverse (<string>)
     Devuelve una cadena con todos los caracteres de <string> en orden
     inverso.


 -- Función: ssearch (<seq>, <string>)
 -- Función: ssearch (<seq>, <string>, <test>)
 -- Función: ssearch (<seq>, <string>, <test>, <start>)
 -- Función: ssearch (<seq>, <string>, <test>, <start>, <end>)
     Devuelve la posición de la primera subcadena de <string> que
     coincide con la cadena <seq>.  La función de comparación por
     defecto es `sequal'.  Si se quiere ignorar la diferencia entre
     mayúsculas y minúsculas, hágase uso de `sequalignore' para el
     argumento <test>.  Utilícense <start> y <end> para acotar la
     búsqueda.  Al primer carácter de <string> le corresponde la
     posición 1.

          (%i1) ssearch("~s","~{~S ~}~%",'sequalignore);
          (%o1)                                  4


 -- Función: ssort (<string>)
 -- Función: ssort (<string>, <test>)
     Devuelve una cadena con todos los caracteres de <string> en un
     orden tal que no haya dos caracteres sucesivos <c> y <d> que
     verifiquen que `test (<c>, <d>)' sea igual `false' y `test (<d>,
     <c>)' igual a `true'.  La función de comparación <test> por
     defecto es  <clessp>, siendo el conjunto de posibles valores para
     este argumento `{clessp, clesspignore, cgreaterp, cgreaterpignore,
     cequal, cequalignore}'.

          (%i1) load("stringproc")$
          (%i2) ssort("I don't like Mondays.");
          (%o2)                    '.IMaddeiklnnoosty
          (%i3) ssort("I don't like Mondays.",'cgreaterpignore);
          (%o3)                 ytsoonnMlkIiedda.'


 -- Función: ssubst (<new>, <old>, <string>)
 -- Función: ssubst (<new>, <old>, <string>, <test>)
 -- Función: ssubst (<new>, <old>, <string>, <test>, <start>)
 -- Función: ssubst (<new>, <old>, <string>, <test>, <start>, <end>)
     Devuelve una cadena similar a <string> pero en la que aquellas
     subcadenas coincidentes con <old> han sido sustituidas por <new>.
     Las subcadenas <old> y <new> no necesitan ser de la misma longitud.
     La función de comparación por defecto es `sequal'.  Si se quiere
     ignorar la diferencia entre mayúsculas y minúsculas durante la
     búsqueda de <old>, hágase uso de `sequalignore' para el argumento
     <test>.  Utilícense <start> y <end> para acotar la búsqueda.  Al
     primer carácter de <string> le corresponde la posición 1.

          (%i1) load("stringproc")$
          (%i2) ssubst("like","hate","I hate Thai food. I hate green tea.");
          (%o2)          I like Thai food. I like green tea.
          (%i3) ssubst("Indian","thai",%,'sequalignore,8,12);
          (%o3)         I like Indian food. I like green tea.


 -- Función: ssubstfirst (<new>, <old>, <string>)
 -- Función: ssubstfirst (<new>, <old>, <string>, <test>)
 -- Función: ssubstfirst (<new>, <old>, <string>, <test>, <start>)
 -- Función: ssubstfirst (<new>, <old>, <string>, <test>, <start>,
          <end>)
     Actúa de forma similar a la función `subst', pero sólo hace la
     sustitución en la primera coincidencia con <old>.

 -- Función: strim (<seq>,<string>)
     Devuelve la cadena <string> pero recortando los caracteres de
     <seq> que tuviese en sus extremos.

          (%i1) load("stringproc")$
          (%i2) "/* comment */"$
          (%i3) strim(" /*",%);
          (%o3)                        comment
          (%i4) slength(%);
          (%o4)                           7


 -- Función: striml (<seq>, <string>)
     Actúa de forma similar a `strim', pero sólo recorta en el extremo
     final de <string>.

 -- Función: strimr (<seq>, <string>)
     Actúa de forma similar a `strim', pero sólo recorta en el extremo
     inicial de <string>.

 -- Función: substring (<string>, <start>)
 -- Función: substring (<string>, <start>, <end>)
     Devuelve la subcadena de <string> que comienza en la posición
     <start> y termina en la posición <end>.  El carácter en la
     posición <end> no se incluye.  En caso de no suministrarse el
     argumento <end>, la subcadena se extenderá hasta el final.  Al
     primer carácter de <string> le corresponde la posición 1.

          (%i1) load("stringproc")$
          (%i2) substring("substring",4);
          (%o2)                        string
          (%i3) substring(%,4,6);
          (%o3)                          in


 -- Función: supcase (<string>)
 -- Función: supcase (<string>, <start>)
 -- Función: supcase (<string>, <start>, <end>)
     Devuelve la cadena <string> con todos sus caracteres entre las
     posiciones <start> y <end> en minúscula transformados a mayúscula.
     En caso de no suministrarse el argumento <end>, los cambios se
     extenderán hasta el final.

          (%i1) load("stringproc")$
          (%i2) supcase("english",1,2);
          (%o2)                        English


 -- Función: tokens (<string>)
 -- Función: tokens (<string>, <test>)
     Devuelve la lista de todos los lexemas (tokens) de <string>.  Los
     lexemas son subcadenas cuyos caracteres satisfacen la  condición
     <test>.  Si no se suministra el argumento <test>, se utilizará la
     condición <constituent>, siendo el conjunto de las otras
     alternativas `{constituent, alphacharp, digitcharp, lowercasep,
     uppercasep, charp, characterp, alphanumericp}'.

          (%i1) load("stringproc")$
          (%i2) tokens("24 October 2005");
          (%o2)                  [24, October, 2005]
          (%i3) tokens("05-10-24",'digitcharp);
          (%o3)                     [05, 10, 24]
          (%i4) map(parsetoken,%);
          (%o4)                      [5, 10, 24]



File: maxima.info,  Node: unit,  Next: zeilberger,  Prev: stringproc,  Up: Top

68 unit
*******

* Menu:

* Introducción a Units::
* Definiciones para Units::


File: maxima.info,  Node: Introducción a Units,  Next: Definiciones para Units,  Prev: unit,  Up: unit

68.1 Introducción a Units
=========================

El paquete `unit' permite al usuario hacer cambios de unidades y llevar
a cabo el análisis dimensional de las ecuaciones. La forma de operar de
este paquete es radicalmente diferente de la del paquete original de
Maxima; mientras que en el paquete original era tan solo una lista de
definiciones, aquí se utiliza un conjunto de reglas que permiten
seleccionar al usuario en qué unidades debe devolverse la expresión
final.

   Junto con el análisis dimensional, el paquete aporta una serie de
herramientas para controlar las opciones de conversión y simplificación.
Además de la conversión automática adaptable a las necesidades del
usuario, el paquete `unit' permite hacer conversiones a la manera
tradicional.

   Nota: Cuando los factores de conversión no son exactos, Maxima los
transformará a fracciones como consecuencia de la metodología utilizada
para simplificar las unidades. Los mensajes de aviso concernientes a
estas transformaciones están desactivados por defecto en el caso de las
unidades (lo habitual es que estén activados en otros contextos) debido
a que al ser una operación muy frecuente, serían un estorbo.  El estado
previo de la variable `ratprint' queda restaurado tras la conversión de
las unidades, de manera que se mantendrá la opción seleccionada por el
usuario; en caso de que éste necesite ver dichos avisos, podrá hacer la
asignación `unitverbose:on' para reactivarlos desde el proceso de
conversión de unidades.

   El paquete `unit' se aloja en el directorio `share/contrib/unit' y
se ajusta a las convenciones de Maxima para la carga de paquetes:

     (%i1) load("unit")$
     *******************************************************************
     *                       Units version 0.50                        *
     *          Definitions based on the NIST Reference on             *
     *              Constants, Units, and Uncertainty                  *
     *       Conversion factors from various sources including         *
     *                   NIST and the GNU units package                *
     *******************************************************************

     Redefining necessary functions...
     WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
     WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
     WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
     WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
     Initializing unit arrays...
     Done.

   Los avisos del tipo `WARNING' son normales y no deben interpretarse
como errores; tan solo indican que el paquete `unit' está redefiniendo
funciones que ya estaban definidas en Maxima. Esto es necesario para
que las unidades se gestionen de forma correcta. El usuario debe tener
en cuenta que si otros paquetes han cambiado las definiciones de estas
funciones, tales cambios serán ignorados por el proceso de carga de
`unit'.

   El paquete `unit' también carga el fichero de Lisp
`unit-functions.lisp', el cual contiene las funciones Lisp necesarias.

   El autor principal de este paquete es Clifford Yapp, quien ha
recibido ayuda y asistencia, entre otros, de Barton Willis y Robert
Dodier.


File: maxima.info,  Node: Definiciones para Units,  Prev: Introducción a Units,  Up: unit

68.2 Definiciones para Units
============================

 -- Función: setunits (<list>)
     El paquete `unit' no utiliza por defecto dimensiones derivadas,
     pero convierte todas las unidades a las siete fundamentales en
     unidades MKS.

          (%i2) N;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) dyn;
                                             1      kg m
          (%o3)                           (------) (----)
                                           100000     2
                                                     s
          (%i4) g;
                                              1
          (%o4)                             (----) (kg)
                                             1000
          (%i5) centigram*inch/minutes^2;
                                            127        kg m
          (%o5)                       (-------------) (----)
                                       1800000000000     2
                                                        s

     Este es el comportamiento que se desea en ciertos casos. Si el
     usuario necesita utilizar otras unidades, habrá de utilizar la
     instrucción `setunits':
          (%i6) setunits([centigram,inch,minute]);
          (%o6)                                done
          (%i7) N;
                                      1800000000000   %in cg
          (%o7)                      (-------------) (------)
                                           127            2
                                                      %min
          (%i8) dyn;
                                         18000000   %in cg
          (%o8)                         (--------) (------)
                                           127          2
                                                    %min
          (%i9) g;
          (%o9)                             (100) (cg)
          (%i10) centigram*inch/minutes^2;
                                              %in cg
          (%o10)                              ------
                                                  2
                                              %min

     La especificación de las variables es relativamente flexible.  Por
     ejemplo, si se quiere volver a utilizar kilogramos, metros y
     segundos como unidades por defecto, podemos hacer:
          (%i11) setunits([kg,m,s]);
          (%o11)                               done
          (%i12) centigram*inch/minutes^2;
                                            127        kg m
          (%o12)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     Las unidades derivadas también se controlan con esta misma
     instrucción:
          (%i17) setunits(N);
          (%o17)                               done
          (%i18) N;
          (%o18)                                 N
          (%i19) dyn;
                                              1
          (%o19)                           (------) (N)
                                            100000
          (%i20) kg*m/s^2;
          (%o20)                                 N
          (%i21) centigram*inch/minutes^2;
                                              127
          (%o21)                        (-------------) (N)
                                         1800000000000

     Téngase en cuenta que el paquete `unit' reconoce que la
     combinación de masa, longitud e inversa del cuadrado del tiempo da
     lugar a una fuerza, convirtiéndola a newtons. Esta es la forma
     general en la que trabaja Maxima. Si el usuario prefiere dinas a
     newtons, tan solo tendrá que hacer lo siguiente:
          (%i22) setunits(dyn);
          (%o22)                               done
          (%i23) kg*m/s^2;
          (%o23)                          (100000) (dyn)
          (%i24) centigram*inch/minutes^2;
                                            127
          (%o24)                         (--------) (dyn)
                                          18000000

     Para desactivar una unidad se utiliza la instrucción `uforget':
          (%i26) uforget(dyn);
          (%o26)                               false
          (%i27) kg*m/s^2;
                                               kg m
          (%o27)                               ----
                                                 2
                                                s
          (%i28) centigram*inch/minutes^2;
                                            127        kg m
          (%o28)                      (-------------) (----)
                                       1800000000000     2
                                                        s
     Esto también hubiese funcionado con `uforget(N)' o
     `uforget(%force)'.

     Véase también `uforget'. Para hacer uso de esta función ejecútese
     `load("unit")'.

 -- Función: uforget (<list>)
     Por defecto, el paquete `unit' convierte todas las unidades a las
     siete fundamentales del sistema MKS. Este comportamiento puede
     alterarse mediante la instrucción `setunits'. Después, si el
     usuario quiere restaurar el comportamiento por defecto podrá
     hacerlo para una dimensión determinada haciendo uso de la
     instrucción `uforget':
          (%i13) setunits([centigram,inch,minute]);
          (%o13)                               done
          (%i14) centigram*inch/minutes^2;
                                              %in cg
          (%o14)                              ------
                                                  2
                                              %min
          (%i15) uforget([cg,%in,%min]);
          (%o15)                     [false, false, false]
          (%i16) centigram*inch/minutes^2;
                                            127        kg m
          (%o16)                      (-------------) (----)
                                       1800000000000     2
                                                        s

     La instrucción `uforget' opera sobre dimensiones, no sobre
     unidades, de modo que valdrá para cualquier unidad de una
     dimensión concreta. La propia dimensión es una argumento válido
     para esta función.

     Véase también `setunits'. Para hacer uso de esta función ejecútese
     `load("unit")'.

 -- Función: convert (<expr>, <list>)
     La función `convert' permite conversiones de una sola vez sin
     alterar el entorno global de ejecución. Acepta tanto un único
     argumento como una lista de unidades a utilizar en las
     conversiones. Cuando se realiza una llamada a `convert' se ignora
     el sistema global de evaluación, con el fin de evitar que el
     resultado deseado sea nuevamente transformado.  Como consecuencia
     de esto, en los cálculos con decimales, los avisos de tipo `rat'
     se harán visibles si la variable global `ratprint' vale `true'.
     Otra propiedad de `convert' es que permite al usuario hacer
     conversiones al sistema fundamental de dimensiones incluso cuando
     el entorno ha sido ajustado para simplificar a una dimensión
     derivada.
          (%i2) kg*m/s^2;
                                               kg m
          (%o2)                                ----
                                                 2
                                                s
          (%i3) convert(kg*m/s^2,[g,km,s]);
                                               g km
          (%o3)                                ----
                                                 2
                                                s
          (%i4) convert(kg*m/s^2,[g,inch,minute]);

          `rat' replaced 39.37007874015748 by 5000//127 = 39.37007874015748
                                        18000000000   %in g
          (%o4)                        (-----------) (-----)
                                            127           2
                                                      %min
          (%i5) convert(kg*m/s^2,[N]);
          (%o5)                                  N
          (%i6) convert(kg*m^2/s^2,[N]);
          (%o6)                                 m N
          (%i7) setunits([N,J]);
          (%o7)                                done
          (%i8) convert(kg*m^2/s^2,[N]);
          (%o8)                                 m N
          (%i9) convert(kg*m^2/s^2,[N,inch]);

          `rat' replaced 39.37007874015748 by 5000//127 = 39.37007874015748
                                           5000
          (%o9)                           (----) (%in N)
                                           127
          (%i10) convert(kg*m^2/s^2,[J]);
          (%o10)                                 J
          (%i11) kg*m^2/s^2;
          (%o11)                                 J
          (%i12) setunits([g,inch,s]);
          (%o12)                               done
          (%i13) kg*m/s^2;
          (%o13)                                 N
          (%i14) uforget(N);
          (%o14)                               false
          (%i15) kg*m/s^2;
                                          5000000   %in g
          (%o15)                         (-------) (-----)
                                            127       2
                                                     s
          (%i16) convert(kg*m/s^2,[g,inch,s]);

          `rat' replaced 39.37007874015748 by 5000//127 = 39.37007874015748
                                          5000000   %in g
          (%o16)                         (-------) (-----)
                                            127       2
                                                     s

     Véanse también `setunits' y `uforget'.  Para hacer uso de esta
     función ejecútese `load("unit")'.

 -- Variable opcional: usersetunits
     Valor por defecto: ninguno

     En caso de que el usuario desee que el comportamiento por defecto
     del paquete `unit' sea distinto del descrito, puede hacer uso del
     fichero `maxima-init.mac' y de la variable global `usersetunits'.
     El paquete `unit' comprobará al ser cargado si se le ha dado a esta
     variable una lista de unidades; en caso afirmativo, aplicará
     `setunits' a las unidades de esta lista y las utilizará por
     defecto. Una llamada a la función `uforget' permitirá retornar al
     comportamiento establecido por defecto por el usuario. Por
     ejemplo, si en el archivo `maxima-init.mac' se tiene el siguiente
     código:
          usersetunits : [N,J];

     observaríamos el siguiente comportamiento:
          (%i1) load("unit")$
          *******************************************************************
          *                       Units version 0.50                        *
          *          Definitions based on the NIST Reference on             *
          *              Constants, Units, and Uncertainty                  *
          *       Conversion factors from various sources including         *
          *                   NIST and the GNU units package                *
          *******************************************************************

          Redefining necessary functions...
          WARNING: DEFUN/DEFMACRO: redefining function TOPLEVEL-MACSYMA-EVAL ...
          WARNING: DEFUN/DEFMACRO: redefining function MSETCHK ...
          WARNING: DEFUN/DEFMACRO: redefining function KILL1 ...
          WARNING: DEFUN/DEFMACRO: redefining function NFORMAT ...
          Initializing unit arrays...
          Done.
          User defaults found...
          User defaults initialized.
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) kg*m^3/s^2;
          (%o4)                                 J m
          (%i5) kg*m*km/s^2;
          (%o5)                             (1000) (J)
          (%i6) setunits([dyn,eV]);
          (%o6)                                done
          (%i7) kg*m/s^2;
          (%o7)                           (100000) (dyn)
          (%i8) kg*m^2/s^2;
          (%o8)                     (6241509596477042688) (eV)
          (%i9) kg*m^3/s^2;
          (%o9)                    (6241509596477042688) (eV m)
          (%i10) kg*m*km/s^2;
          (%o10)                   (6241509596477042688000) (eV)
          (%i11) uforget([dyn,eV]);
          (%o11)                           [false, false]
          (%i12) kg*m/s^2;
          (%o12)                                 N
          (%i13) kg*m^2/s^2;
          (%o13)                                 J
          (%i14) kg*m^3/s^2;
          (%o14)                                J m
          (%i15) kg*m*km/s^2;
          (%o15)                            (1000) (J)

     De no haber hecho uso de `usersetunits', las entradas iniciales
     hubiesen sido convertidas a unidades MKS y cualquier llamada a
     `uforget' hubiese retornado también a MKS. Sin embargo, las
     preferencias establecidas por el usuario se respetan en ambos
     casos. Para eliminar las preferencias del usuario y volver a
     utilizar las establecidas por defecto por el paquete `unit', debe
     utilizarse la instrucción `dontusedimension'. La función `uforget'
     puede restaurar nuevamente las preferencias del usuario, pero sólo
     si `usedimension' mantiene su valor. Alternativamente,
     `kill(usersetunits)'  eliminará completamente cualquier vestigio
     de las preferencias del usuario durante la sesión actual. Véanse a
     continuación algunos ejemplos de aplicación de estas opciones:
          (%i2) kg*m/s^2;
          (%o2)                                  N
          (%i3) kg*m^2/s^2;
          (%o3)                                  J
          (%i4) setunits([dyn,eV]);
          (%o4)                                done
          (%i5) kg*m/s^2;
          (%o5)                           (100000) (dyn)
          (%i6) kg*m^2/s^2;
          (%o6)                     (6241509596477042688) (eV)
          (%i7) uforget([dyn,eV]);
          (%o7)                            [false, false]
          (%i8) kg*m/s^2;
          (%o8)                                  N
          (%i9) kg*m^2/s^2;
          (%o9)                                  J
          (%i10) dontusedimension(N);
          (%o10)                             [%force]
          (%i11) dontusedimension(J);
          (%o11)                         [%energy, %force]
          (%i12) kg*m/s^2;
                                               kg m
          (%o12)                               ----
                                                 2
                                                s
          (%i13) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o13)                               -----
                                                 2
                                                s
          (%i14) setunits([dyn,eV]);
          (%o14)                               done
          (%i15) kg*m/s^2;
                                               kg m
          (%o15)                               ----
                                                 2
                                                s
          (%i16) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o16)                               -----
                                                 2
                                                s
          (%i17) uforget([dyn,eV]);
          (%o17)                         [false, false]
          (%i18) kg*m/s^2;
                                               kg m
          (%o18)                               ----
                                                 2
                                                s
          (%i19) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o19)                               -----
                                                 2
                                                s
          (%i20) usedimension(N);
          Done.  To have Maxima simplify to this dimension, use setunits([unit])
          to select a unit.
          (%o20)                               true
          (%i21) usedimension(J);
          Done.  To have Maxima simplify to this dimension, use setunits([unit])
          to select a unit.
          (%o21)                               true
          (%i22) kg*m/s^2;
                                               kg m
          (%o22)                               ----
                                                 2
                                                s
          (%i23) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o23)                               -----
                                                 2
                                                s
          (%i24) setunits([dyn,eV]);
          (%o24)                               done
          (%i25) kg*m/s^2;
          (%o25)                          (100000) (dyn)
          (%i26) kg*m^2/s^2;
          (%o26)                    (6241509596477042688) (eV)
          (%i27) uforget([dyn,eV]);
          (%o27)                           [false, false]
          (%i28) kg*m/s^2;
          (%o28)                                 N
          (%i29) kg*m^2/s^2;
          (%o29)                                 J
          (%i30) kill(usersetunits);
          (%o30)                               done
          (%i31) uforget([dyn,eV]);
          (%o31)                          [false, false]
          (%i32) kg*m/s^2;
                                               kg m
          (%o32)                               ----
                                                 2
                                                s
          (%i33) kg*m^2/s^2;
                                                   2
                                               kg m
          (%o33)                               -----
                                                 2
                                                s

     Desafortunadamente, esta amplia variedad de opciones puede resultar
     confusa en un primer momento, pero una vez se practica un poco con
     ellas, el usuario comprobará que tiene un control absoluto sobre
     su entorno de trabajo.


 -- Función: metricexpandall (<x>)
     Reconstruye automáticamente las listas globales de unidades
     creando todas los múltiplos y submúltiplos métricos necesarios. El
     argumento numérico <x> se utiliza para especificar cuántos
     prefijos numéricos quiere utilizar el usuario. Los argumentos son
     los siguientes:
                         0 - none. Only base units
                         1 - kilo, centi, milli
          (por defecto)  2 - giga, mega, kilo, hecto, deka, deci, centi,
                             milli, micro, nano
                         3 - peta, tera, giga, mega, kilo, hecto, deka,
                             deci, centi, milli, micro, nano, pico,
                             femto
                         4 - todos

     Normalmente, Maxima no definirá el juego completo de múltiplos y
     submúltiplos, lo que implica un número muy grande de unidades, pero
     `metricexpandall' puede utilizarse para reconstruir la lista. La
     variable fundamental del paquete `unit' es `%unitexpand'.

 -- Variable opcional: %unitexpand
     Valor por defecto: `2'

     Es el valor suministrado a `metricexpandall' durante la carga del
     paquete `unit'.


File: maxima.info,  Node: zeilberger,  Next: Índice de Funciones y Variables,  Prev: unit,  Up: Top

69 zeilberger
*************

* Menu:

* Introducción a zeilberger::
* Definiciones para zeilberger::


File: maxima.info,  Node: Introducción a zeilberger,  Next: Definiciones para zeilberger,  Prev: zeilberger,  Up: zeilberger

69.1 Introducción a zeilberger
==============================

El paquete `zeilberger' implementa el algoritmo de Zeilberger para la
suma hipergeométrica definida y el algoritmo de Gosper para la suma
hipergeométrica indefinida. Además, hace uso del método de optimización
por filtrado desarrollado por Axel Riese.

   El autor de este paquete es Fabrizio Caruso.

   Antes de hacer uso de las funciones aquí definidas, ejecútese la
sentencia `load (zeilberger)'.

69.1.0.1 El problema de la suma indefinida
..........................................

El paquete `zeilberger' implementa el algoritmo de Gosper para la suma
hipergeométrica indefinida.  Dado el término general hipergeométrico
F_k de índice k, se plantea el problema de encontrar su antidiferencia
hipergeométrica, esto es, el término hipergeométrico tal que F_k =
f_(k+1) - f_k.

69.1.0.2 El problema de la suma definida
........................................

El paquete `zeilberger' implementa el algoritmo de Zeilberger para la
suma hipergeométrica definida.  Dados el término hipergeométrico propio
F_(n,k), de índices n y k, y el entero positivo d, se plantea el
problema de encontrar una expresión recurrente lineal de orden d con
coeficientes polinomiales en n y una función racional R en n y k tales
que

   a_0 F_(n,k) + ... + a_d F_(n+d),k = Delta_K(R(n,k) F_(n,k))

   donde Delta_k es el k-ésimo operador diferencia hacia adelante, esto
es, Delta_k(t_k) := t_(k+1) - t_k.

69.1.1 Niveles de información
-----------------------------

Hay versiones extendidas de los nombres de las instrucciones, que se
construyen añadiendo uno de los siguientes prefijos:

`Summary'
     Tan solo muestra un sumario al final

`Verbose'
     Alguna información en los niveles intermedios

`VeryVerbose'
     Más información

`Extra'
     Aún más información, incluida alguna sobre el sistema lineal en el
     algoritmo de Zeilberger.

   Por ejemplo: `GosperVerbose', `parGosperVeryVerbose',
`ZeilbergerExtra', `AntiDifferenceSummary'.


File: maxima.info,  Node: Definiciones para zeilberger,  Prev: Introducción a zeilberger,  Up: zeilberger

69.2 Definiciones para zeilberger
=================================

 -- Función: AntiDifference (<F_k>, <k>)
     Returns the hypergeometric anti-difference of <F_k>, if it exists.
     Otherwise `AntiDifference' returns `no_hyp_antidifference'.

 -- Función: Gosper (<F_k>, <k>)
     Devuelve, si existe, el elemento racional asociado a <F_k>, esto
     es, la función racional que verifica

     F_k = R(k+1) F_(k+1) - R(k) F_k.

     En caso de no existir este elemento, `Gosper' devuelve
     `no_hyp_sol'.

 -- Función: GosperSum (<F_k>, <k>, <a>, <b>)
     Devuelve la suma de los términos <F_k> desde <k> = <a> hasta <k> =
     <b> si <F_k> tiene una antidiferencia hipergeométrica. En caso
     contrario, `GosperSum' devuelve `nongosper_summable'.

     Ejemplos:

          (%i1) load (zeilberger);
          (%o1)  /usr/share/maxima/share/contrib/Zeilberger/zeilberger.mac
          (%i2) GosperSum ((-1)^k*k / (4*k^2 - 1), k, 1, n);

          Dependent equations eliminated:  (1)
                                     3       n + 1
                                (n + -) (- 1)
                                     2               1
          (%o2)               - ------------------ - -
                                            2        4
                                2 (4 (n + 1)  - 1)
          (%i3) GosperSum (1 / (4*k^2 - 1), k, 1, n);
                                          3
                                    - n - -
                                          2       1
          (%o3)                  -------------- + -
                                          2       2
                                 4 (n + 1)  - 1
          (%i4) GosperSum (x^k, k, 1, n);
                                    n + 1
                                   x          x
          (%o4)                    ------ - -----
                                   x - 1    x - 1
          (%i5) GosperSum ((-1)^k*a! / (k!*(a - k)!), k, 1, n);
                                          n + 1
                          a! (n + 1) (- 1)              a!
          (%o5)       - ------------------------- - ----------
                        a (- n + a - 1)! (n + 1)!   a (a - 1)!
          (%i6) GosperSum (k*k!, k, 1, n);

          Dependent equations eliminated:  (1)
          (%o6)                     (n + 1)! - 1
          (%i7) GosperSum ((k + 1)*k! / (k + 1)!, k, 1, n);
                            (n + 1) (n + 2) (n + 1)!
          (%o7)             ------------------------ - 1
                                    (n + 2)!
          (%i8) GosperSum (1 / ((a - k)!*k!), k, 1, n);
          (%o8)                  nonGosper_summable

 -- Función: parGosper (<F_{n,k}>, <k>, <n>, <d>)
     Intenta calcular una recurrecia de orden <d> para <F_{n,k}>.

     El algoritmo devuelve una secuencia [s_1, s_2, ..., s_m] de
     soluciones, cada una de las cuales tiene la forma

     [R(n, k), [a_0, a_1, ..., a_d]].

     La función `parGosper' devuelve `[]' si no encuentra ninguna
     recurrencia.

 -- Función: Zeilberger (<F_{n,k}>, <k>, <n>)
     Intenta calcular la suma hipergeométrica indefinida de <F_{n,k}>.

     La función `Zeilberger' invoca en primer lugar a `Gosper', y en
     caso de no encontrar una solución, llama después a `parGosper' con
     los órdenes 1, 2, 3, ..., hasta `max_ord'. Si `Zeilberger'
     encuentra una solución antes de alcanzar `max_ord', se detiene su
     ejecución y devuelve el resultado.

     El algoritmo devuelve una secuencia [s_1, s_2, ..., s_m] de
     soluciones, cada una de las cuales tiene la forma

     [R(n, k), [a_0, a_1, ..., a_d]].

     La función `Zeilberger' devuelve `[]' si no encuentra ninguna
     solución.

     La función `Zeilberger' llama a `Gosper' sólo si
     `gosper_in_zeilberger' tiene el valor `true'.

 -- Variable opcional: max_ord
     Valor por defecto: 5

     `max_ord' es el máximo orden de recurrencia que ensayará la
     función `Zeilberger'.

 -- Variable opcional: simplified_output
     Valor por defecto: `false'

     Si `simplified_output' vale `true', las funciones del paquete
     `zeilberger' tratan de presentar las soluciones simplificadas.

 -- Variable opcional: linear_solver
     Valor por defecto: `linsolve'

     La variable `linear_solver' guarda el nombre de la función que se
     utilizará para resolver el sistema de ecuaciones del algoritmo de
     Zeilberger.

 -- Variable opcional: warnings
     Valor por defecto: `true'

     Si `warnings' vale `true', las funciones del paquete `zeilberger'
     emiten mensajes de aviso durante su ejecución.

 -- Variable opcional: gosper_in_zeilberger
     Valor por defecto: `true'

     Si `gosper_in_zeilberger' vale `true', la función `Zeilberger'
     llama a la función `Gosper' antes de llamar a `parGosper'.  En
     caso contrario, `Zeilberger' invoca inmediatamente a `parGosper'.

 -- Variable opcional: trivial_solutions
     Valor por defecto: `true'

     Si `trivial_solutions' vale `true', la función `Zeilberger'
     devuelve soluciones triviales.

 -- Variable opcional: mod_test
     Valor por defecto: `false'

     Si `mod_test' vale `true', la función `parGosper' ejecuta una
     prueba modular para descartar sistemas sin soluciones.

 -- Variable opcional: modular_linear_solver
     Valor por defecto: `linsolve'

     La variable `modular_linear_solver' guarda el nombre de la función
     que deberá ser llamada por la prueba modular de `parGosper' para
     resolver sistemas lineales.

 -- Variable opcional: ev_point
     Valor por defecto: `big_primes[10]'

     La variable `ev_point' guarda el valor para el que debe evaluarse
     <n> durante la ejecución de la prueba modular de `parGosper'.

 -- Variable opcional: mod_big_prime
     Valor por defecto: `big_primes[1]'

     La variable `mod_big_prime' guarda el módulo utilizado por la
     prueba modular de `parGosper'.

 -- Variable opcional: mod_threshold
     Valor por defecto: 4

     La variable `mod_threshold' es el máximo orden que ensaya la
     prueba modular de `parGosper'.



Local Variables:
coding: iso-8859-1
End:
